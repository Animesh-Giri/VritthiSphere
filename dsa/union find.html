<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>union find - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>union find</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">91</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Account Merge</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">Accounts Merge</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Avoid Explosion</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">Bricks Falling When Hit</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Check if the Rectangle Corner Is Reachable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Check if There is a Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Checking Existence of Edge Length Limited Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">City With the Smallest Number of Neighbors at a Threshold Distance</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-8" class="toc-link">Connected Components in an Undirected Graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-9" class="toc-link">Connecting the graph</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">Connecting the special nodes</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-11" class="toc-link">Count Connected Components in LCM Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Count Islands With Total Value Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Count Servers that Communicate</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Count Sub Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Count the Number of Complete Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Count Unreachable Pairs of Nodes in an Undirected Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Couples Holding Hands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Detect Cycles in 2D Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Detect Cycle using DSU</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-20" class="toc-link">Divide Nodes Into the Maximum Number of Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Evaluate Division</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Find All People With Secret</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Find if Path Exists in Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Find number of closed islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-26" class="toc-link">Find the Safest Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Find the String with LCP</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">GCD Sort of an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Graph Connectivity With Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Greatest Common Divisor Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Groups of Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Is Graph Bipartite?</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Largest Component Size by Common Factor</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Last Day Where You Can Still Cross</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Lexicographically Smallest Equivalent String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Longest Consecutive Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Longest Uploaded Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Make Lexicographically Smallest Array by Swapping Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Making A Large Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Making A Large Island</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-41" class="toc-link">Max Area of Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Maximize Spanning Tree Stability with Upgrades</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Maximum Number of Fish in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Maximum Number of Points From Grid Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Maximum Segment Sum After Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Min Cost to Connect All Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Minimize Hamming Distance After Swap Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Minimize Malware Spread</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Minimize Malware Spread II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Minimize Maximum Component Cost</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Minimum Cost Walk in Weighted Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Minimum Number of Visited Cells in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Minimum Score of a Path Between Two Cities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Minimum Spanning Tree - Kruskal&#39;s Algorithm</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-55" class="toc-link">Minimum Time for K Connected Components</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Most Stones Removed with Same Row or Column</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Number of Closed Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Number of Enclaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Number of Good Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Number of Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Number of Operations to Make Network Connected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Number of pairs</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-63" class="toc-link">Number of Provinces</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Number of Ways to Reorder Array to Get Same BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Path Existence Queries in a Graph I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Possible Bipartition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Possible Paths in a Tree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-69" class="toc-link">Power Grid Maintenance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Process Restricted Friend Requests</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Properties Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Rank Transform of a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Reachable Nodes With Restrictions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Reduce the Array</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-75" class="toc-link">Redundant Connection</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Redundant Connection II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Regions Cut By Slashes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Remove Max Number of Edges to Keep Graph Fully Traversable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Satisfiability of Equality Equations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Similar String Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Smallest Missing Genetic Value in Each Subtree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Smallest String With Swaps</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Students and their arrangements &lt;CAST&gt;</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-84" class="toc-link">Subarray With Elements Greater Than Varying Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Surrounded Regions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Swim in Rising Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Tree Trips</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-88" class="toc-link">Undirected Graph Cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-89" class="toc-link">Union-Find</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-90" class="toc-link">Validate Binary Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/account-merge/1" target="_blank" rel="noopener noreferrer">Account Merge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a list&nbsp;of <strong>accounts</strong> of size <strong>n</strong> where each element <strong>accounts [ i ] </strong>is a list&nbsp;of strings, where the first element <strong>account [ i ][ 0 ]&nbsp;</strong> is a<strong> name</strong>, and the rest of the elements are<strong> emails</strong> representing emails of the account.<br />Geek wants you to merge these accounts. Two accounts belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts have the same name.<br />After merging the accounts, return the accounts in the following format: The first element of each account is the name, and the rest of the elements are emails <strong>in</strong> <strong>sorted order</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>: Accounts themselves can be returned in <strong>any order</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 4<br />accounts [ ] =<br />[["John","johnsmith@mail.com","john_newyork@mail.com"],<br />["John","johnsmith@mail.com","john00@mail.com"],<br />["Mary","mary@mail.com"],<br />["John","johnnybravo@mail.com"]]<br /><strong>Output:</strong><br />[["John","john00@mail.com","john_newyork@mail.com", "johnsmith@mail.com"],<br />["Mary","mary@mail.com"],<br />["John","johnnybravo@mail.com"]]<br /><strong>Explanation:</strong><br />The first and second John's are the same person as they have the common email "johnsmith@mail.com". The third John and Mary are different people as none of their email addresses are used by other accounts.We could return these arrays in any order, for example, the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 5<br />accounts [ ] =<br />[["Gabe","Gabe00@m.co","Gabe3@m.co","Gabe1@m.co"],<br />["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],<br />["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],<br />["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],<br />["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]<br /><strong>Output:</strong><br />[["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],<br />["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],<br />["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],<br />["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],<br />["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]<br /><strong>Explanation:</strong><br />We don't have any common emails in any of the users. We just sorted the emails of each person and we return a array of emails.(The details can be returned in any order).</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>accountsMerge</strong><strong>()&nbsp;</strong>which takes a list of lists of strings representing <strong>accounts[][]</strong> as a parameter and returns a list of lists of strings denoting the details after merging.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n*m*logn) - where n is the size of accounts and m is the size of the number of strings for a name.<br /><strong>Expected Auxiliary Space:</strong> O(n*m) - where n is the size of accounts and m is the size of the number of strings for a name.</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &lt;= n &lt;= 1000<br /></span><span style="font-size: 18px;">2 &lt;= accounts[ i ].size&nbsp;&lt;= 10<br /></span><span style="font-size: 18px;">1 &lt;= accounts[ i ][ j ].size &lt;= 30<br /></span><span style="font-size: 18px;">accounts[i][0] consists of English letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/accounts-merge/description" target="_blank" rel="noopener noreferrer">Accounts Merge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p>

<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>

<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]
<strong>Output:</strong> [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]
<strong>Explanation:</strong>
The first and second John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], 
[&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]
<strong>Output:</strong> [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
	<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
	<li><code>accounts[i][0]</code> consists of English letters.</li>
	<li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a list of accounts where each account consists of a list containing the name of the person the account belongs to and some emails that belong to the person. One person is allowed to have multiple accounts, but each email can only belong to one person. Therefore, we can say two accounts must belong to the same person if the accounts have an email in common. Note that we cannot just use the user's name to determine which email addresses belong to the same user since different users may have the same name.</p>
<p>Our goal is, for each person, we want to identify all of the emails that belong to that person. Therefore, every time we find two accounts with an email in common, we will merge the two accounts into one.</p>
<p>Whenever we must work with a set of elements (emails) that are connected (belong to the same user), we should always consider visualizing our input as a graph. In this problem, converting the input into a graph will facilitate the process of &quot;merging&quot; two accounts.</p>
<p>Emails can be represented as nodes, and an edge between nodes will signify that they belong to the same person. Since all of the emails in an account belong to the same person, we can connect all of the emails with edges. Thus, each account can be represented by a connected component. What if two accounts have an email in common? Then we can add an edge between the two connected components, effectively merging them into one connected component.<br />
</br></p>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<p>Here, we will represent emails as nodes, and an edge will signify that two emails are connected and hence belong to the same person. This means that any two emails that are connected by a path of edges must also belong to the same person. Initially, we are given <span class="math inline">\(N\)</span> accounts, where each account's emails make up a connected component.</p>
<p>Our first step should be to ensure that for each account, all of its nodes are connected. Suppose an account has <span class="math inline">\(K\)</span> emails, and we want to connect these emails. Since all emails in an account are connected, we can add an edge between every pair of emails. This will create a complete subgraph and require adding <span class="math inline">\(K \choose 2\)</span> edges. However, do we really need that many edges to keep track of which emails belong to the same account? No, as long as two emails are connected by a path of edges, we know they belong to the same account. So instead of creating a complete subgraph for each account, we can create an acyclic graph using only <span class="math inline">\(K - 1\)</span> edges. Recall that <span class="math inline">\(K - 1\)</span> is the minimum number of edges required to connect <span class="math inline">\(K\)</span> nodes. In this approach, we will connect emails in an account in a <a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">star</a> manner with the first email as the internal node of the star and all other emails as the leaves (as shown below).</p>
<p><img src="../Figures/721/721A.png" alt="fig" /></p>
<p>The beauty of connecting the emails in each account in this manner is that after connecting an email to a second account, that email will have one edge going to an email in the first account and one edge going to an email in the second account.  Thereby automatically merging the two accounts. The below slideshow depicts the merging process for four accounts that belong to two different people.</p>
<p>!?!../Documents/721_Accounts_Merge_A.json:960,720!?! <br></p>
<p>After iterating over each account and connecting the emails as described above, we will have a one or more connected components. Each connected component will represent one person, and the nodes in the connected component are the person's emails. Now our task is to explore each connected component to find all the emails that belong to each person. Since a depth-first search is guaranteed to explore every node in a connected component, we will perform a DFS on each connected component (person) to find all of the connected emails.</p>
<p>To do so, we will iterate over all of the nodes and consider starting a DFS. If the node has already been visited, in an earlier DFS, we will not start a DFS.  Otherwise, perform a DFS traversal over the connected component and store all the visited emails together, as they all belong to one person. Each time we visit an email during a DFS, we will mark it as visited to ensure that we do not search the same connected component more than once. To read more about how DFS can be leveraged to find components you can refer to the first approach <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/solution/">here</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create an adjacency list: For each account add an edge between the first email (<code>accountFirstEmail</code>) and each of the other emails in the account.</li>
<li>Traverse over the accounts; for each account, check if the first email in the account (<code>accountFirstEmail</code>) was already visited.  If so, then do not start a new DFS. Otherwise, perform DFS with this email as the source node.</li>
<li>During each DFS, store the traversed emails in an array <code>mergedAccount</code>, also mark all these emails as visited.</li>
<li>After the DFS traversal is over, sort the emails and add the account name (<code>accountName</code>) at the start of the vector <code>mergedAccount</code>.</li>
<li>Store the vector <code>mergedAccount</code> in the answer list <code>mergedAccounts</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/EAjKzRH9/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here <span class="math inline">\(N\)</span> is the number of accounts and <span class="math inline">\(K\)</span> is the maximum length of an account.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(NK \log{NK})\)</span></p>
<p>In the worst case, all the emails will end up belonging to a single person. The total number of emails will be <span class="math inline">\(N*K\)</span>, and we need to sort these emails. DFS traversal will take <span class="math inline">\(NK\)</span> operations as no email will be traversed more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(NK)\)</span></p>
<p>Building the adjacency list will take <span class="math inline">\(O(NK)\)</span> space. In the end, <code>visited</code> will contain all of the emails hence it will use <span class="math inline">\(O(NK)\)</span> space. Also, the call stack for DFS will use <span class="math inline">\(O(NK)\)</span> space in the worst case.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, Collections.sort() dumps the specified list into an array this will take <span class="math inline">\(O(NK)\)</span> space then Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is <span class="math inline">\(O(\log NK)\)</span>. In C++ <code>sort()</code> function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort with the worst-case space complexity of <span class="math inline">\(O(\log NK)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-disjoint-set-union-dsu">Approach 2: Disjoint Set Union (DSU)</h3>
<p><strong>Intuition</strong></p>
<p>As in the previous approach, the first step is to find which accounts have an email in common and merge them to form a larger connected component. Any problem that involves merging connected components (accounts) is a natural fit for the Disjoint Set Union (DSU) data structure. If you would like to learn more about the DSU data structure (also known as Union-Find), a tutorial is provided in the <a href="https://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/">Graph Explore Card</a>. Since most implementations of DSU use an array to record the root (representative) of each component, we will use integers to represent each component for ease of operability. Therefore, we will give each account a unique ID, and we will map all the emails in the account to the account's ID. We will use a map, <code>emailGroup</code>, to store this information.</p>
<p>We chose the account index to be the identifier for all the emails of an account. We will assign the account index as the group when we get the email for the first time and when we get an email that we have already traversed, we will merge the current account and the group that we have previously stored in <code>emailGroup</code> using union operation.</p>
<p>After traversing over all the accounts, we will find the representative of all the emails which will inform us about their group. Emails with the same representative belong to the same person/group and hence will be stored together. Also, we can retrieve the account name for our final answer using <code>accountList</code> as we have <code>group</code> which is the index in the original accounts list.</p>
<p>!?!../Documents/721_Accounts_Merge_B.json:960,720!?! <br></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Traverse over each account, and for each account, traverse over all of its emails.  If we see an email for the first time, then set the group of the email as the index of the current account in <code>emailGroup</code> .</li>
<li>Otherwise, if the email has already been seen in another account, then we will union the current group (<code>i</code>) and the group the current email belongs to (<code>emailGroup[email]</code>).</li>
<li>After traversing over every account and merging the accounts that share a common email, we will now traverse over every email once more. Each email will be added to a map (<code>components</code>) where the key is the email's representative, and the value is a list of emails with that representative.</li>
<li>Traverse over <code>components</code>, here the keys are the group indices and the value is the list of emails belonging to this group (person). Since the emails must be &quot;in sorted order&quot; we will sort the list of emails for each group. Lastly, we can get the account name using the <code>accountList[group][0]</code>. In accordance with the instructions, we will insert this name at the beginning of the email list.</li>
<li>Store the list created in step 4 in our final result (<code>mergedAccount</code>).</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/cCnGvzFV/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here <span class="math inline">\(N\)</span> is the number of accounts and <span class="math inline">\(K\)</span> is the maximum length of an account.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(NK \log {NK})\)</span></p>
<p>While merging we consider the size of each connected component and we always choose the representative of the larger component to be the new representative of the smaller component, also we have included the path compression so the time complexity for find/union operation is <span class="math inline">\(\alpha({N})\)</span> (Here, <span class="math inline">\(\alpha({N})\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(N\)</span> (approximately <span class="math inline">\( N < 10^{600}\)</span>).</p>
<p>We find the representative of all the emails, hence it will take <span class="math inline">\(O(NK\alpha({N}))\)</span> time. We are also sorting the components and the worst case will be when all emails end up belonging to the same component this will cost <span class="math inline">\(O(NK(\log {NK}))\)</span>.</p>
<p>Hence the total time complexity is <span class="math inline">\(O(NK \cdot \log {NK} + NK \cdot \alpha({N}))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(NK)\)</span></p>
<p>List <code>representative</code>, <code>size</code> store information corresponding to each group so will take <span class="math inline">\(O(N)\)</span> space. All emails get stored in <code>emailGroup</code> and <code>component</code> hence space used is <span class="math inline">\(O(NK)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, Collections.sort() dumps the specified list into an array this will take <span class="math inline">\(O(NK)\)</span> space then Arrays.sort() for primitives is implemented as a variant of quicksort algorithm whose space complexity is <span class="math inline">\(O(\log NK)\)</span>. In C++ <code>sort()</code> function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort with the worst-case space complexity of <span class="math inline">\(O(\log NK)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/avoid-explosion--170647/1" target="_blank" rel="noopener noreferrer">Avoid Explosion</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek is a chemical scientist who is performing an experiment to find an antidote to a poison. The experiment involves mixing some solutions in a flask. Based on the theoretical research Geek has done, he came up with an <strong>n&nbsp;*&nbsp;2</strong> array &#39;<strong>mix</strong>&#39;, where mix[i] = {X, Y} denotes solutions X and Y that needs to be mixed.<br />
<br />
Also, from his past experience, it has been known that <strong>mixing some solutions leads to an explosion</strong> and thereby completely ruining the experiment. The explosive solutions are also provided as a&nbsp;<strong>m * 2</strong> array &#39;<strong>danger</strong>&#39; where danger[i] = {P, Q}&nbsp;denotes that if somehow solutions P and Q get into the same flask it will result in an explosion.</span></p>

<p><span style="font-size:18px">Help the Geek by returning an array &#39;<strong>answer</strong>&#39; of size <strong>n</strong>, where answer[i] = &quot;<strong>Yes</strong>&quot;&nbsp;if it is safe to mix solutions in &#39;mix[i]&#39; or else answer[i] = &quot;<strong>No</strong>&quot;. </span></p>

<p><span style="font-size:18px"><strong>Note:</strong> Geek should follow the order of mixing of solutions as it is in &#39;mix&#39; otherwise the antidote will be ineffective. Also, Geek will not mix the&nbsp;solutions in &#39;mix[i]&#39; once he gets to know that mixing them will result in an explosion. Mixing a solution will effect the other solutions which will appear after it.&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
n = 5, m = 2
mix = {{1, 2}, {2, 3}, {4, 5}, {3, 5}, {2, 4}}
danger = {{1, 3}, {4, 2}}

<strong>Output</strong>:
answer = {&quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;No&quot;}

<strong>Explanation</strong>:
Mixing the first solution(1 and 2) of &#39;mix&#39; do not result in any kind of explosion hence answer[0] is &quot;Yes&quot;, while mixing(2nd solution) 2 and 3 is not allowed because it will result in an explosion as 1 and 3 would be in same solution hence we have returned &quot;No&quot; as the answer for 2nd solution. Mixing the third solution(4 and 5) and 4th solution(3 and 5) of &#39;mix&#39; do not result in any kind of explosion hence answer[2] and answer[3] is &quot;Yes&quot;. While mixing 2 and 4 is not allowed because it will result in an explosion hence we have returned &quot;No&quot; as the answer for it.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
n = 3, m = 2
mix = {{1, 2}, {2, 3}, {1, 3}}
danger = {{1, 2}, {1, 3}}

<strong>Output</strong>:
answer = {&quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;}

<strong>Explanation</strong>:
Mixing solutions 1 and 2 is dangerous hence 
answer[0] = &quot;No&quot;, but solutions 2 and 3 can 
be mixed without any problem therefore answer[1] 
= &quot;Yes&quot;. Again, mixing solutions 1 and 3 is 
dangerous due to which answer[2] = &quot;No&quot;.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong></span></p>

<p><span style="font-size:18px">You don&#39;t need to read input or print anything. Complete the function&nbsp;<strong>avoidExplosion()</strong>&nbsp;which takes the mix array, its size, danger array, and its size as input parameters and&nbsp;returns the result&nbsp;array or list.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity: O(n*m*log(n))<br />
Expected Space Complexity: O(n)</strong></span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span></p>

<p><span style="font-size:18px">0 &lt; n &lt; 1000</span></p>

<p><span style="font-size:18px">0 &lt; m&nbsp;&lt; 1000</span></p>

<p><span style="font-size:18px">1 &lt;= mix[i][0], mix[i][1] &lt;= n</span></p>

<p><span style="font-size:18px">1 &lt;= danger[i][0], danger[i][1] &lt;= n</span></p>

<p><span style="font-size:18px">mix[i][0] != mix[i][1]</span></p>

<p><span style="font-size:18px">danger[i][0] != danger[i][1]</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bricks-falling-when-hit/description" target="_blank" rel="noopener noreferrer">Bricks Falling When Hit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary <code>grid</code>, where each <code>1</code> represents a brick and <code>0</code> represents an empty space. A brick is <strong>stable</strong> if:</p>

<ul>
	<li>It is directly connected to the top of the grid, or</li>
	<li>At least one other brick in its four adjacent cells is <strong>stable</strong>.</li>
</ul>

<p>You are also given an array <code>hits</code>, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location <code>hits[i] = (row<sub>i</sub>, col<sub>i</sub>)</code>. The brick on that location&nbsp;(if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will <strong>fall</strong>. Once a brick falls, it is <strong>immediately</strong> erased from the <code>grid</code> (i.e., it does not land on other stable bricks).</p>

<p>Return <em>an array </em><code>result</code><em>, where each </em><code>result[i]</code><em> is the number of bricks that will <strong>fall</strong> after the </em><code>i<sup>th</sup></code><em> erasure is applied.</em></p>

<p><strong>Note</strong> that an erasure may refer to a location with no brick, and if it does, no bricks drop.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
<strong>Output:</strong> [2]
<strong>Explanation: </strong>Starting with the grid:
[[1,0,0,0],
 [<u>1</u>,1,1,0]]
We erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,<u>1</u>,<u>1</u>,0]]
The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:
[[1,0,0,0],
 [0,0,0,0]]
Hence the result is [2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
<strong>Output:</strong> [0,0]
<strong>Explanation: </strong>Starting with the grid:
[[1,0,0,0],
 [1,<u>1</u>,0,0]]
We erase the underlined brick at (1,1), resulting in the grid:
[[1,0,0,0],
 [1,0,0,0]]
All remaining bricks are still stable, so no bricks fall. The grid remains the same:
[[1,0,0,0],
 [<u>1</u>,0,0,0]]
Next, we erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,0,0,0]]
Once again, all remaining bricks are still stable, so no bricks fall.
Hence the result is [0,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>hits[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i&nbsp;</sub>&lt;= m - 1</code></li>
	<li><code>0 &lt;=&nbsp;y<sub>i</sub> &lt;= n - 1</code></li>
	<li>All <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are unique.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-reverse-time-and-union-find-accepted">Approach #1: Reverse Time and Union-Find [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The problem is about knowing information about the connected components of a graph as we cut vertices.  In particular, we'll like to know the size of the &quot;roof&quot; (component touching the top edge) between each cut.  Here, a cut refers to the erasure of a vertex.</p>
<p>As we may know, a useful data structure for joining connected components is a disjoint set union structure.  The key idea in this problem is that we can use this structure if we work in reverse: instead of looking at the graph as a series of sequential cuts, we'll look at the graph after all the cuts, and reverse each cut.</p>
<p><strong>Algorithm</strong></p>
<p>We'll modify our typical disjoint-set-union structure to include a <code>dsu.size</code> operation, that tells us the size of this component.  The way we do this is whenever we make a component point to a new parent, we'll also send it's size to that parent.</p>
<p>We'll also include <code>dsu.top</code>, which tells us the size of the &quot;roof&quot;, or the component connected to the top edge.  We use an <em>ephemeral</em> &quot;source&quot; node with label <code>R * C</code> where all nodes on the top edge (with row number <code>0</code>) are connected to the source node.</p>
<p>For more information on DSU, please look at <em>Approach #2</em> in the <a href="https://leetcode.com/articles/redundant-connection/">article here</a>.</p>
<p>Next, we'll introduce <code>A</code>, the grid after all the cuts have happened, and initialize our disjoint union structure on the graph induced by <code>A</code> (nodes are grid squares with a brick; edges between 4-directionally adjacent nodes).</p>
<p>After, if we get an cut at <code>(r, c)</code> but the original <code>grid[r][c]</code> was always <code>0</code>, then we couldn't have had a meaningful cut - the number of dropped bricks is <code>0</code>.</p>
<p>Otherwise, we'll look at the size of the new roof after adding this brick at <code>(r, c)</code>, and compare them to find the number of dropped bricks.</p>
<p>Since we were working in reverse time order, we should reverse our working answer to arrive at our final answer.</p>
<p><a href="https://leetcode.com/playground/Lna6PTkh/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N \cdot \alpha(N))\)</span>, where <span class="math inline">\(N = R \cdot C\)</span> is the number of grid squares, and <span class="math inline">\(\alpha\)</span> is the <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse-Ackermann function</a>. We will insert at most <span class="math inline">\(N\)</span> nodes into the disjoint-set data structure which will require <span class="math inline">\(O(N \cdot \alpha(N))\)</span> time.  There will also be at most <span class="math inline">\(Q\)</span> hits where we must add a brick into the disjoint-set data structure which will require <span class="math inline">\(O(Q \cdot \alpha(N))\)</span> time. Since each hit location is unique, <span class="math inline">\(Q\)</span> must be less than or equal to <span class="math inline">\(N\)</span>, so we can simplify the time complexity to <span class="math inline">\(O(N \cdot \alpha(N))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-the-rectangle-corner-is-reachable/description" target="_blank" rel="noopener noreferrer">Check if the Rectangle Corner Is Reachable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">geometry</span> <span class="topic-badge">math</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integers <code>xCorner</code> and <code>yCorner</code>, and a 2D array <code>circles</code>, where <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> denotes a circle with center at <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and radius <code>r<sub>i</sub></code>.</p>

<p>There is a rectangle in the coordinate plane with its bottom left corner at the origin and top right corner at the coordinate <code>(xCorner, yCorner)</code>. You need to check whether there is a path from the bottom left corner to the top right corner such that the <strong>entire path</strong> lies inside the rectangle, <strong>does not</strong> touch or lie inside <strong>any</strong> circle, and touches the rectangle <strong>only</strong> at the two corners.</p>

<p>Return <code>true</code> if such a path exists, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 4, circles = [[2,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png" style="width: 346px; height: 264px;" /></p>

<p>The black curve shows a possible path between <code>(0, 0)</code> and <code>(3, 4)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 3, circles = [[1,1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example1circle.png" style="width: 346px; height: 264px;" /></p>

<p>No path exists from <code>(0, 0)</code> to <code>(3, 3)</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 3, yCorner = 3, circles = [[2,1,1],[1,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/18/example0circle.png" style="width: 346px; height: 264px;" /></p>

<p>No path exists from <code>(0, 0)</code> to <code>(3, 3)</code>.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">xCorner = 4, yCorner = 4, circles = [[5,5,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/rectangles.png" style="width: 346px; height: 264px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= xCorner, yCorner &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= circles.length &lt;= 1000</code></li>
	<li><code>circles[i].length == 3</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Check if There is a Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> <code>grid</code>. Each cell of <code>grid</code> represents a street. The street of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means a street connecting the left cell and the right cell.</li>
	<li><code>2</code> which means a street connecting the upper cell and the lower cell.</li>
	<li><code>3</code> which means a street connecting the left cell and the lower cell.</li>
	<li><code>4</code> which means a street connecting the right cell and the lower cell.</li>
	<li><code>5</code> which means a street connecting the left cell and the upper cell.</li>
	<li><code>6</code> which means a street connecting the right cell and the upper cell.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/main.png" style="width: 450px; height: 708px;" />
<p>You will initially start at the street of the upper-left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code>. <strong>The path should only follow the streets</strong>.</p>

<p><strong>Notice</strong> that you are <strong>not allowed</strong> to change any street.</p>

<p>Return <code>true</code><em> if there is a valid path in the grid or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e1.png" style="width: 455px; height: 311px;" />
<pre>
<strong>Input:</strong> grid = [[2,4,3],[6,5,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e2.png" style="width: 455px; height: 293px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,1],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description" target="_blank" rel="noopener noreferrer">Checking Existence of Edge Length Limited Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An undirected graph of <code>n</code> nodes is defined by <code>edgeList</code>, where <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with distance <code>dis<sub>i</sub></code>. Note that there may be <strong>multiple</strong> edges between two nodes.</p>

<p>Given an array <code>queries</code>, where <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code>, your task is to determine for each <code>queries[j]</code> whether there is a path between <code>p<sub>j</sub></code> and <code>q<sub>j</sub></code><sub> </sub>such that each edge on the path has a distance <strong>strictly less than</strong> <code>limit<sub>j</sub></code> .</p>

<p>Return <em>a <strong>boolean array</strong> </em><code>answer</code><em>, where </em><code>answer.length == queries.length</code> <em>and the </em><code>j<sup>th</sup></code> <em>value of </em><code>answer</code> <em>is </em><code>true</code><em> if there is a path for </em><code>queries[j]</code><em> is </em><code>true</code><em>, and </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/h.png" style="width: 267px; height: 262px;" />
<pre>
<strong>Input:</strong> n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/q.png" style="width: 390px; height: 358px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
<strong>Output:</strong> [true,false]
<strong>Explanation:</strong> The above figure shows the given graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edgeList[i].length == 3</code></li>
	<li><code>queries[j].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>
	<li><code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
	<li>There may be <strong>multiple</strong> edges between two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/1" target="_blank" rel="noopener noreferrer">City With the Smallest Number of Neighbors at a Threshold Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There are <strong>n</strong> cities labeled from 0 to n-1 with <strong>m </strong>edges connecting them. Given the array <strong>edges</strong>&nbsp;where <strong>edges[i] = [from<sub>i&nbsp;</sub>, to<sub>i ,</sub>weight<sub>i</sub>]<sub>&nbsp;</sub></strong>&nbsp;represents a <strong>bidirectional </strong>and <strong>weighted edge </strong>between cities <strong>from<sub>i</sub>&nbsp;</strong>and <strong>to<sub>i</sub></strong>, and given the integer <strong>distanceThreshold</strong>. You need to find out a city with the <strong>smallest number </strong>of cities that are reachable through some path and whose distance is&nbsp;<strong>at most</strong>&nbsp;<strong>Threshold Distance.</strong>&nbsp;If there are multiple such cities, our answer will&nbsp;be the city with the <strong>greatest label</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> The distance of a path connecting cities <em><strong>i</strong></em>&nbsp;and&nbsp;<em><strong>j</strong></em> is equal to the sum of the edge's weights along that path.</span></p>
<p><strong><span style="font-size: 18px;">Examples</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">n = 4, m = 4</span>
<span style="font-size: 18px;">edges = [[0, 1, 3],<br />         [1, 2, 1], <br />         [1, 3, 4],  <br />         [2, 3, 1]]</span>
<span style="font-size: 18px;">distanceThreshold = 4</span>
<strong><span style="font-size: 18px;">Output:<br /></span></strong><span style="font-size: 18px;">3</span>
<strong><span style="font-size: 18px;">Explaination:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid1_1745300064.jpg" width="278" height="278" /><br /></span></strong><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2]&nbsp;
City 1 -&gt; [City 0, City 2, City 3]&nbsp;
City 2 -&gt; [City 0, City 1, City 3]&nbsp;
City 3 -&gt; [City 1, City 2]&nbsp;
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input:&nbsp;</span></strong><span style="font-size: 18px;"><span style="font-size: 18px;"><br />n = 5, m = 6<br />edges = [[0, 1, 2],
         [0, 4, 8],<br />         [1, 2, 3], <br />         [1, 4, 2], <br />         [2, 3, 1],<br />         [3, 4, 1]]<br />distanceThreshold = 2.<br /></span></span><span style="font-size: 18px;"><strong style="font-size: 18px;">Output:<br /></strong><span style="font-size: 18px;">0<br /></span><strong style="font-size: 18px;">Explaination:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/711146/Web/Other/blobid2_1745300084.jpg" width="320" height="320" /><br /><span style="font-size: 18px;">The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1] 
City 1 -&gt; [City 0, City 4] 
City 2 -&gt; [City 3, City 4] 
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.<br /></span></span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>findCity( )&nbsp;</strong>which takes a number of nodes <strong>n, </strong>total number of edges <strong>m</strong>&nbsp;and vector of <strong>edges</strong> and <strong>distanceThreshold</strong>. and return the city with the smallest number of cities that are reachable through some path and whose distance is <strong>at most</strong> Threshold Distance. If there are multiple such cities, return the city with the greatest label.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup> + length(edges)*nlog(n) )</span><br /><span style="font-size: 18px;"><strong>Expected Auxiliary Space:&nbsp;&nbsp;</strong>O(n<sup>3</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&nbsp; &le;&nbsp; n &le;&nbsp; 100<br />1 &lt;= m &lt;= n*(n-1)/2<br />length(edges[i]) == 3<br />0 &lt;= from<sub>i&nbsp;</sub>&lt; to<sub>i</sub>&nbsp;&lt; n<br />1 &lt;= weight<sub>i </sub>distanceThreshold &lt;= 10<sup>4</sup><br />All pairs (from<sub>i</sub>, to<sub>i</sub>) are distinct</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/connected-components-in-an-undirected-graph/1" target="_blank" rel="noopener noreferrer">Connected Components in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an undirected graph with&nbsp;<strong>V&nbsp;</strong>vertices numbered from 0 to V-1 and&nbsp;<strong>E</strong> edges, represented as a 2D array <strong>edges[][]</strong>, where each entry&nbsp;<strong>edges[i] = [u, v]</strong>&nbsp;denotes an edge between vertices&nbsp;<strong>u</strong>&nbsp;and&nbsp;<strong>v</strong>.</span></p>
<p><span style="font-size: 18px;">Your task is to return a list of all connected components. Each connected component should be represented as a list of its vertices, with all components returned in a collection where each component is listed separately.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> You can return the components in any order, driver code will print the components in <strong>sorted </strong>order.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> V = 5, edges[][] = [[0, 1], [2, 1], [3, 4]]
<strong>Output: </strong>[[0, 1, 2], [3, 4]]</span><strong><span style="font-size: 18px;">
Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid1_1744798106.jpg" width="269" height="238" /><br /></span></strong></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 7,<strong> </strong></span><span style="font-size: 18px;">edges[][] <strong>= </strong>[[0, 1], [6, 0], [2, 4], [2, 3], [3, 4]]
<strong>Output: </strong>[[0, 1, 6], [2, 3, 4], [5]]<br /><strong>Explanation:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893290/Web/Other/blobid0_1744797809.jpg" width="360" height="228" /></strong></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1 &le; V &le; 10<sup>5</sup><br />1 &le; edges.size() &le; 10<sup>5</sup><br /></span><span style="font-size: 18px;">0 &lt;= edges[i][0], edges[i][1] &lt; V</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/connecting-the-graph/1" target="_blank" rel="noopener noreferrer">Connecting the graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a graph with <strong>n</strong> vertices (0 to n-1) and <strong>m</strong> edges. </span><span style="font-size: 18px;">You can remove <strong>one</strong> edge from anywhere and add that edge between&nbsp;<strong>any </strong>two vertices in <strong>one </strong>operation. </span><span style="font-size: 18px;">Find the <strong>minimum</strong> number of operations that will be required to connect the graph.<br /></span><span style="font-size: 18px;">If it is not possible to connect the graph, return -1.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong>&nbsp;</span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 4<br />m = 3<br />Edges = [ [0, 1] , [0, 2] , [1, 2] ]<br /><strong>Output:<br /></strong>1<strong><br />Explanation:</strong><br />Remove edge&nbsp;between vertices&nbsp;1 and 2 and add&nbsp;between vertices&nbsp;1 and 3.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 6<br />m = 5<br />Edges = [ [0,1] , [0,2] , [0,3] , [1,2] , [1,3] ]<br /><strong>Output:</strong><br />2<br /><strong>Explanation:</strong><br />Remove edge between (1,2) and(0,3) and add edge between (1,4) and (3,5)</span><br />&nbsp;</pre>
<p><strong>Your Task:<br /></strong><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>Solve()</strong>&nbsp;which takes an integer<strong> n</strong> denoting a number of vertices and a 2d matrix denoting the edges of a graph and returns the<strong> minimum</strong> number of operations to connect a graph.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(m*n)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(m*n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">1&lt;=n&lt;=10<sup>5</sup><br />0&lt;=m&lt;=10<sup>2</sup><br />1&lt;=edge[i][0],edge[i][1]&lt;=n-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/jenny-and-water-7-d0337cc3-ec2c1136/" target="_blank" rel="noopener noreferrer">Connecting the special nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">hard</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a graph of <span class="mathjax-latex">\(N\)</span> nodes. The graph consists of connected components. Some of the connected components contain a special node and each component contains at most one special node. You are requiredÂ to maximize the number of edges in the given graph such that it follows these constraints:Â </p>

<ul>
	<li>No self-loop or multiple edges should be presentÂ </li>
	<li>No connected components with more than one special node should be present</li>
	<li>Each node in the graph should belongÂ toÂ a component withÂ exactly one special node</li>
</ul>

<p>If you add an edge between two nodes that belong to the same component in the graph, then the total cost involvedÂ is <span class="mathjax-latex">\(0\)</span>. Whereas, if you connect two nodes that belong to different components, then the cost is equal to the product of the sizes of both the components.Â </p>

<p>Your task is to maximize the number of new edges in the graph and calculate the minimum cost that will be involved in performing the required task.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>First line: Three integers <span class="mathjax-latex">\(N,\ M,\ and\ K\)</span>Â representing the number of nodes, number of edges, andÂ number of special nodes in the graph respectively</li>
	<li>Next <span class="mathjax-latex">\(M\)</span>Â lines: Two integers <span class="mathjax-latex">\(u\ and\ v\)</span> representing an undirected edge from the node <span class="mathjax-latex">\(u\)</span> to node <span class="mathjax-latex">\(v\)</span>Â </li>
	<li>Next line: An empty line</li>
	<li>Next line: <span class="mathjax-latex">\(K\)</span>Â space-separated integers each representing the special nodes in a connected component</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print the maximumÂ number of new edges that can be added to the graph and the minimum cost of doing so.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 â‰¤ N â‰¤ 10^{5}\)</span></p>

<p><span class="mathjax-latex">\(1 â‰¤ M â‰¤ 2 \times 10^{5}\)</span></p>

<ul>
	<li><span class="mathjax-latex">\(K \leq\)</span> the total number of connected components present in the graph.</li>
	<li>It is guaranteed that for any connected component at most one special node exists.</li>
	<li>The given graph does not contain any self-loopsÂ or multiple edges.</li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The given graph consist of 5 connected components.<span class="mathjax-latex">\( (1, 2, 3), (4, 5, 6, 7), (8), (9, 10), (11, 12)\)</span>.<br>
1 is the special node in <span class="mathjax-latex">\((1, 2, 3)\)</span> and 4 is the special node in <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>.<br>
There is no special nodeÂ in <span class="mathjax-latex">\((8), (9, 10), (11, 12)\)</span>.<br>
<br>
For <span class="mathjax-latex">\((1, 2, 3)\)</span>:-<br>
We can add 1 edge from 2 to 3,Â  cost = 0 (same component).<br>
For <span class="mathjax-latex">\((4, 5, 6, 7)\)</span>:-<br>
We will add 3 edges from 6 to 5, 6 to 7 and 4 to 7. Now we can't add more edges to this component,Â cost = 0 (same component).<br>
For the remaining nodes (without special nodes):-<br>
We will first connect $$8$$ and <span class="mathjax-latex">\((11, 12)\)</span> with cost 2 and 2 edges.<br>
Then <span class="mathjax-latex">\((8, 11, 12)\)</span> and <span class="mathjax-latex">\((9, 10)\)</span> with cost 6 and 6 edges. (product of their sizes).<br>
Now we have all the non special nodes completely connected.<br>
We can now connect all the 5 non special nodes to the componentÂ <span class="mathjax-latex">\((4, 5, 6, 7)\)</span> with cost 20 and 20 edges.<br>
Hence total cost is 28 and maximum number of edges that can be added are 32.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-connected-components-in-lcm-graph/description" target="_blank" rel="noopener noreferrer">Count Connected Components in LCM Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> of size <code>n</code> and a <strong>positive</strong> integer <code>threshold</code>.</p>

<p>There is a graph consisting of <code>n</code> nodes with the&nbsp;<code>i<sup>th</sup></code>&nbsp;node having a value of <code>nums[i]</code>. Two nodes <code>i</code> and <code>j</code> in the graph are connected via an <strong>undirected</strong> edge if <code>lcm(nums[i], nums[j]) &lt;= threshold</code>.</p>

<p>Return the number of <strong>connected components</strong> in this graph.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>The term <code>lcm(a, b)</code> denotes the <strong>least common multiple</strong> of <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,4,8,3,9], threshold = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/31/example0.png" style="width: 250px; height: 251px;" /></p>

<p>&nbsp;</p>

<p>The four connected components are <code>(2, 4)</code>, <code>(3)</code>, <code>(8)</code>, <code>(9)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,4,8,3,9,12], threshold = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/31/example1.png" style="width: 250px; height: 252px;" /></p>

<p>The two connected components are <code>(2, 3, 4, 8, 9)</code>, and <code>(12)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li>All elements of <code>nums</code> are unique.</li>
	<li><code>1 &lt;= threshold &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-islands-with-total-value-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Count Islands With Total Value Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> and a positive integer <code>k</code>. An <strong>island</strong> is a group of <strong>positive</strong> integers (representing land) that are <strong>4-directionally</strong> connected (horizontally or vertically).</p>

<p>The <strong>total value</strong> of an island is the sum of the values of all cells in the island.</p>

<p>Return the number of islands with a total value <strong>divisible by</strong> <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example1griddrawio-1.png" style="width: 200px; height: 200px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,2,1,0,0],[0,5,0,0,5],[0,0,1,0,0],[0,1,4,7,0],[0,2,0,0,8]], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains four islands. The islands highlighted in blue have a total value that is divisible by 5, while the islands highlighted in red do not.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example2griddrawio.png" style="width: 200px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,0,3,0], [0,3,0,3], [3,0,3,0]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains six islands, each with a total value that is divisible by 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-servers-that-communicate/description" target="_blank" rel="noopener noreferrer">Count Servers that Communicate</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a map of a server center, represented as a <code>m * n</code> integer matrix&nbsp;<code>grid</code>, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.<br />
<br />
Return the number of servers&nbsp;that communicate with any other server.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" style="width: 202px; height: 203px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 0
<b>Explanation:</b>&nbsp;No servers can communicate with others.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/11/13/untitled-diagram-4.jpg" style="width: 203px; height: 203px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[1,1]]
<strong>Output:</strong> 3
<b>Explanation:</b>&nbsp;All three servers can communicate with at least one other server.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-1-3.jpg" style="width: 443px; height: 443px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
<strong>Output:</strong> 4
<b>Explanation:</b>&nbsp;The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 250</code></li>
	<li><code>1 &lt;= n &lt;= 250</code></li>
	<li><code>grid[i][j] == 0 or 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid representing a server center in the form of a matrix of size <code>m x n</code>. Each cell of the matrix contains either a <code>1</code>, indicating the presence of a server, or a <code>0</code>, indicating an empty space.</p>
<p>We need to return the number of servers that can communicate with at least one other server. This excludes servers that are isolated, i.e., those that do not share a row or column with any other server.</p>
<p>The first thing to note is that a server can communicate with another server if they are located either in the same row or the same column. Thus, the key observation here is that we only need to check rows and columns to determine if a server is communicable. If thereâ€™s at least one other server in the same row or column, then this server is communicable.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that each cell either contains a server (represented by <code>1</code>) or is empty (represented by <code>0</code>). So, we start by going through each cell to see if there is a server at that position. If the current cell contains a server, we then check if this server can communicate with any other server. If it can, we count it as communicable.</p>
<p>Once we find a server, we check if there is any other server in the same row that can communicate with it. We do this by iterating through all the other cells in the same row. If we find another server in the same row, we can immediately mark it as communicable.</p>
<p>If we do not find any other server in the row, we proceed to check the column. We iterate through all the other rows in the same column to see if there is another server. If a server is found in the same column, we know this server can communicate and is communicable.</p>
<p>As soon as we determine that a server can communicate (either in the same row or column), we increment the total communicable servers count. Once we finish checking the entire grid, we return the count of communicable servers.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in the grid.</p>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will keep track of the count of communicable servers.</p>
</li>
<li>
<p>Traverse through the grid:</p>
<ul>
<li>For each server at position <code>(row, col)</code> where <code>grid[row][col] == 1</code>:
<ul>
<li>Set <code>canCommunicate</code> to <code>false</code>.</li>
<li>Check for communication in the same row:
<ul>
<li>Iterate through each column <code>otherCol</code> in the same row:
<ul>
<li>If <code>otherCol</code> is not equal to <code>col</code> and <code>grid[row][otherCol] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
<li>If no communication was found in the same row, check for communication in the same column:
<ul>
<li>Iterate through each row <code>otherRow</code> in the same column:
<ul>
<li>If <code>otherRow</code> is not equal to <code>row</code> and <code>grid[otherRow][col] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DouY2Fzd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span></p>
<p>The algorithm traverses through each cell in the grid using nested loops, where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). For each cell containing a server (<code>grid[row][col] == 1</code>), it performs two additional checks:</p>
<ol>
<li>It checks the entire row to see if there is another server in the same row. This involves iterating over <span class="math inline">\(n\)</span> columns.</li>
<li>If no server is found in the same row, it checks the entire column to see if there is another server in the same column. This involves iterating over <span class="math inline">\(m\)</span> rows.</li>
</ol>
<p>Since these checks are performed for each server, the worst-case time complexity is <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only maintains a few variables (<code>numRows</code>, <code>numCols</code>, <code>communicableServersCount</code>, <code>canCommunicate</code>, etc.). No additional data structures are used that scale with the input size. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-track-using-two-arrays">Approach 2: Track Using Two Arrays</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To optimize the checking process, the first step is to count how many servers exist in each row and each column before we start checking individual servers.</p>
<p>We donâ€™t need to check the entire row and column every time for every server. Instead, we can track the number of servers in each row and column using two arrays: <code>rowCounts</code> and <code>colCounts</code>. We loop over the grid once, and for each server (<code>grid[row][col] == 1</code>), we increment the count for the corresponding row and column. This precomputes how many servers are present in each row and column.</p>
<p>The advantage of this approach is that we know in advance how many servers are in a given row or column, so when we encounter a server, we can quickly determine if itâ€™s communicable by checking these precomputed values.</p>
<p>Once we have the counts of servers in each row and column, the next task is to identify which servers are communicable. For a server at position <code>(row, col)</code>, we need to check:</p>
<ul>
<li>If the row has more than one server (i.e., <code>rowCounts[row] &gt; 1</code>), which means there are other servers in the same row.</li>
<li>If the column has more than one server (i.e., <code>colCounts[col] &gt; 1</code>), which means there are other servers in the same column.</li>
</ul>
<p>If either condition is true, the server can communicate, and we increment the count of communicable servers.</p>
<p>Once weâ€™ve checked all servers and counted the communicable ones, we simply return the count.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize two arrays, <code>rowCounts</code> and <code>colCounts</code>, of appropriate sizes to keep track of the server counts in each row and column.</p>
</li>
<li>
<p>Count servers in each row and column:</p>
<ul>
<li>Iterate through each row (<code>row</code>), and for each row, iterate through each column (<code>col</code>):
<ul>
<li>If thereâ€™s a server at <code>grid[row][col]</code>, increment the corresponding values in <code>rowCounts[row]</code> and <code>colCounts[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will store the count of servers that can communicate.</p>
</li>
<li>
<p>Count servers that can communicate (i.e., those in the same row or column as another server):</p>
<ul>
<li>Iterate again through each row and column:
<ul>
<li>If thereâ€™s a server at <code>grid[row][col]</code>, check if it can communicate with another server (i.e., if <code>rowCounts[row] &gt; 1</code> or <code>colCounts[col] &gt; 1</code>).</li>
<li>If so, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7NwwDvo6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The first nested loop iterates over each row in the grid to count the number of servers in each row and column. The outer loop runs <span class="math inline">\(m\)</span> times (for each row), and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second nested loop also iterates over each row in the grid to determine if a server can communicate with others in its row or column. This again involves an outer loop running <span class="math inline">\(m\)</span> times and an inner loop running <span class="math inline">\(n\)</span> times, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Since both loops are independent and each has a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional arrays:<br />
- <code>rowCounts</code> of size <span class="math inline">\(n\)</span> (number of columns) to store the count of servers in each column.<br />
- <code>colCounts</code> of size <span class="math inline">\(m\)</span> (number of rows) to store the count of servers in each row.</p>
<p>The space required for these arrays is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-server-grouping">Approach 3: Server Grouping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 2, we were repeatedly scanning the entire row and column for each server to check if there were any other servers for communication. While this method works, it is somewhat redundant since we perform the same checks multiple times. The goal now is to micro-optimize the process.</p>
<p>Instead of directly checking the count of servers in every row and column each time we find a server, we aim to track the necessary information during our first pass so that in the second pass, we can make decisions more quickly. This will reduce some runtime redundancy.</p>
<p>We begin by initializing a <code>colCount</code> array, where each entry tracks the number of servers in that row. By maintaining this count, we can easily find if a server can communicate based on the number of servers in the same row.</p>
<p>In addition to counting the servers in each row and column, we use another array, <code>lastServerInRow</code>, to track the position of the last server in each column. This is crucial because if a column has multiple servers, we donâ€™t need to check the entire column again. Instead, we can focus on whether the last server in a column is part of a communicable set (i.e., a row or column with multiple servers). For example, if <code>lastServerInRow[0]</code> is 3, it means the last server in column 0 is at row 3. If this server can communicate, it indicates that there are other servers in that column, and we can mark it as communicable without needing to scan all rows again.</p>
<p>Now we process each server in the grid by iterating over the rows and columns. For each server we encounter, we:</p>
<ul>
<li>Increment the count for that row in the <code>colCount</code> array.</li>
<li>Track the position of the last server in the <code>lastServerInRow</code> array.</li>
</ul>
<p>Thus, we gather all the necessary information about how many servers are in each row and column and the position of the last server.</p>
<p>After collecting this information, we use the <code>colCount</code> and <code>lastServerInRow</code> arrays to identify communicable servers. For each server in the grid, we check if the count of servers in the same row is greater than 1. If it is, we know that this server can communicate with another server in the same row. Similarly, we check if the serverâ€™s column has more than one server using the <code>lastServerInRow</code> array. If the server is part of a communicable set (i.e., there are other servers in the same row or column), we increase the count of communicable servers.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1267/server_grouping.json:760,532!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>communicableServersCount</code> to 0 to keep track of servers that can communicate.</li>
<li>Initialize <code>colCount</code> to store the count of servers in each row, and <code>lastServerInRow</code> to track the last server in each column.</li>
</ul>
<h5 id="first-pass-count-servers-in-each-row-and-column">First Pass: Count servers in each row and column</h5>
<ol>
<li>Iterate through each row (<code>row</code>):
<ul>
<li>For each row, initialize <code>serverCountInRow</code> to 0 to track the number of servers in that row.</li>
<li>Iterate through each column (<code>col</code>):
<ul>
<li>If a server is found at <code>grid[row][col]</code>, increment <code>serverCountInRow</code>, update <code>colCount[col]</code>, and set <code>lastServerInRow[col]</code> to <code>row</code>.</li>
</ul>
</li>
<li>If the row has more than one server, increment <code>communicableServersCount</code> by the number of servers in the row and set <code>lastServerInRow[col]</code> to -1 (indicating no servers to communicate in that column).</li>
</ul>
</li>
</ol>
<h5 id="second-pass-check-if-servers-can-communicate">Second Pass: Check if servers can communicate</h5>
<ol start="2">
<li>Iterate again through each column (<code>col</code>):
<ul>
<li>If there is a server at <code>lastServerInRow[col]</code> and the count of servers in the corresponding row (<code>colCount[lastServerInRow[col]]</code>) is greater than one, increment <code>communicableServersCount</code> by 1.</li>
</ul>
</li>
</ol>
<ul>
<li>Finally, return <code>communicableServersCount</code>, the total count of servers that can communicate.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/8eyTWJqP/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm performs two passes over the grid. In the first pass, it iterates over each cell in the grid to count the number of servers in each row and column. This involves nested loops where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second pass iterates over the rows to check if servers can communicate based on the counts computed in the first pass. This pass runs in <span class="math inline">\(O(m)\)</span> time. Since <span class="math inline">\(O(m \cdot n)\)</span> dominates <span class="math inline">\(O(m)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional data structures: <code>colCount</code> and <code>lastServerInRow</code>. The <code>colCount</code> array has a size of <span class="math inline">\(n\)</span> (number of columns), and the <code>lastServerInRow</code> array has a size of <span class="math inline">\(m\)</span> (number of rows). Therefore, the space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized">Approach 4: Space Optimized</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of keeping an array to track the position of the last server in each column, we just count the number of servers directly in each row and perform a simple check when a single server is found, leveraging the grid's structure itself.</p>
<p>We start by iterating over each row in the grid. For each row, we count how many servers are present. As we count, we also keep track of the column index of the first server encountered. This is important because if thereâ€™s only one server in the row, we need to check if thereâ€™s any other server in the same column.</p>
<p>Once the row is processed, we check if there are multiple servers in that row. If there are, we conclude that all servers in that row can communicate with each other, so we add the count of servers in that row to the total communicable servers count.</p>
<p>If thereâ€™s exactly one server in the row, we then check all the other rows to see if thereâ€™s any server in the same column as that single server. If such a server exists, then the lone server in that row is communicable, and we add it to the total count.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>cols</code> to the dimensions of the grid, and <code>communicableServersCount</code> to <code>0</code>, which will store the total count of communicable servers.</p>
</li>
<li>
<p>Iterate through each row (<code>rowIndex</code>):</p>
<ul>
<li>
<p>Initialize <code>rowCounts</code> to count the number of servers in the current row, and <code>serverColumnIndex</code> to store the column index of the first server in the row.</p>
</li>
<li>
<p>Count the servers in the current row:</p>
<ul>
<li>Iterate through each column (<code>colIndex</code>):
<ul>
<li>If there's a server (<code>grid[rowIndex][colIndex]</code>), update <code>serverColumnIndex</code> if it is the first server found, and increment <code>rowCounts</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the row has more than one server (<code>rowCounts != 1</code>), meaning servers in the row can communicate. If not, check for a server in the same column (<code>serverColumnIndex</code>) in other rows.</p>
</li>
<li>
<p>If the server can communicate (either because there are multiple servers in the row or another server exists in the same column in another row), add <code>rowCounts</code> to <code>communicableServersCount</code>.</p>
</li>
</ul>
</li>
<li>
<p>After iterating through all rows, return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/89oda5wC/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm iterates over each cell in the grid once to count the number of servers in each row and determine if they can communicate. For each row, it takes <span class="math inline">\(O(n)\)</span> time to count the servers and <span class="math inline">\(O(m)\)</span> time to check if a server in a row can communicate with another server in the same column. Since there are <span class="math inline">\(m\)</span> rows, the total time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>The nested loops and the checks for communication contribute to this time complexity. The outer loop runs <span class="math inline">\(m\)</span> times, and the inner loops run <span class="math inline">\(n\)</span> times and <span class="math inline">\(m\)</span> times respectively, leading to the overall time complexity of <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm does not allocate any additional memory that depends on the size of the input grid. All operations are performed in-place using a fixed number of variables.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-sub-islands/description" target="_blank" rel="noopener noreferrer">Count Sub Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An <strong>island</strong> is a group of <code>1</code>&#39;s connected <strong>4-directionally</strong> (horizontal or vertical). Any cells outside of the grid are considered water cells.</p>

<p>An island in <code>grid2</code> is considered a <strong>sub-island </strong>if there is an island in <code>grid1</code> that contains <strong>all</strong> the cells that make up <strong>this</strong> island in <code>grid2</code>.</p>

<p>Return the <em><strong>number</strong> of islands in </em><code>grid2</code> <em>that are considered <strong>sub-islands</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/test1.png" style="width: 493px; height: 205px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png" style="width: 491px; height: 201px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
<strong>Output:</strong> 2 
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid1.length == grid2.length</code></li>
	<li><code>n == grid1[i].length == grid2[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two binary matrices, <code>grid1</code> and <code>grid2</code>, both of size <code>m x n</code>, where 1 represents land and 0 represents water. An island is a group of connected 1s, connected horizontally or vertically. The task is to find how many islands in <code>grid2</code> are also sub-islands of <code>grid1</code>. An island in <code>grid2</code> is considered a sub-island if every land cell of the island is part of an island in <code>grid1</code>.</p>
<p><img src="../Figures/1905/Slide-1a.png" alt="slide1a" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see all the land cells of the island of <code>grid2</code> lie on one island in grid1.</p>
<p><img src="../Figures/1905/Slide-1b.png" alt="slide1b" /></p>
<br />
<p>Let's consider another island of the <code>grid2</code>, now, is this a sub-island?</p>
<p><img src="../Figures/1905/Slide-1c.png" alt="slide1c" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see two land cells are lying on the water cell, thus this island can't be considered a sub-island.</p>
<p><img src="../Figures/1905/Slide-1d.png" alt="slide1d" /></p>
<br />
<p>The above images hint that; to check whether an island of <code>grid2</code> is a sub-island in <code>grid1</code>, we can start traversing on each land cell of the current island of <code>grid2</code> and for each land cell there should be a land cell in <code>grid1</code> at the same position (at same <code>(x, y)</code> index in grids).</p>
<p>Each grid cell is connected to its adjacent neighbors 4-directionally (horizontal or vertical), this grid problem can be visualized as a graph traversal problem, where each cell is a node and the 4-directions are edges connecting those nodes.</p>
<p><img src="../Figures/1905/Slide-1e.png" alt="slide1e" /></p>
<br />
<p>We will iterate on each cell of the <code>grid2</code>, if the current cell is a land cell we traverse the whole island of <code>grid2</code> containing the current land cell. While traversing over the entire island we keep track if, for each land cell of the island of <code>grid2</code>, the <code>grid1</code> also has a land cell at the respective position using a boolean variable. After iteration on the current island is completed this boolean variable will denote if the island is a sub-island or not.</p>
<br />
<p>The following slideshow will give you an idea about this approach:</p>
<p>!?!../Documents/1905/slideshow1.json:1900,1600!?!</p>
<p>There are different techniques to traverse a graph, in this article we will cover some of them in brief, we assume you already have a good knowledge about them,<br />
if you are new to the graph traversal algorithms we recommend you read the following Leetcode articles before proceeding:</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/">Breadth-First Search</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/3882/">Depth-First Search</a></li>
<li><a href="https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide">Union Find</a></li>
</ul>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Breadth-first search is used to traverse graphs level by level, and in this problem, each cell in the grid represents a node, with 4-directional connections as edges. In this context, each cell in the grid represents a node, and the horizontal and vertical connections between cells are the edges. The goal is to check if an island in <code>grid2</code> is a sub-island of <code>grid1</code>. We start BFS from each unvisited land cell in <code>grid2</code> and verify if all corresponding cells in <code>grid1</code> are also land cells. If we encounter a land cell in <code>grid2</code> where the corresponding cell in <code>grid1</code> is water, the island in <code>grid2</code> is not a sub-island.</p>
<p>We iterate through each cell in <code>grid2</code>, initiating BFS from each unvisited land cell to explore the island. During the traversal, we use a boolean flag <code>isSubIsland</code> to track if all corresponding cells in <code>grid1</code> are land. If the flag remains <code>true</code> after the traversal, we increment our sub-island count.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> which returns a boolean value indicating whether the island of <code>grid2</code> containing cell at position <code>(x, y)</code> is a sub-island in <code>grid1</code> or not. This method will utilize the BFS algorithm to traverse all cells of the island of the <code>grid2</code>:
<ul>
<li>Initialize a variable <code>isSubIsland</code> to <code>true</code>, indicating whether the island of <code>grid2</code> is a sub-island or not.</li>
<li>Initialize a queue, push the starting cell <code>(x, y)</code> in queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the current cell from the queue.</li>
<li>If the cell in <code>grid1</code> at the same position as the current cell of <code>grid2</code> is not a land cell then this island can't be a sub-island so we will mark the <code>isSubIsland</code> flag as <code>false</code>.</li>
<li>Next, we move in all 4 directions one by one using the <code>directions</code> array. If the cell at the next position <code>(nextX, nextY)</code> lies inside the <code>grid2</code>, was not visited earlier, and is also a land cell, then we will traverse on this cell, hence, push it in the queue and mark it as visited.</li>
</ul>
</li>
<li>When we traverse all cells of the current island we return <code>isSubIsland</code>.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as the <code>grid2</code> matrix to mark visited land cells.</li>
<li>Initialize a variable <code>subIslandsCount</code> to <code>0</code>, to count the total number of islands in <code>grid2</code> which are also sub-islands.</li>
<li>Iterate on all cells of the <code>grid2</code> using nested for loop, if the current cell is never visited, is a land cell in <code>grid2</code>, and is a sub-island then increment the <code>subIslandsCount</code> by <code>1</code>.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mVB8kFHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform BFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the queue.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Depth-first search (DFS) explores as far as possible along each branch before backtracking, making it effective for checking if an island in <code>grid2</code> is a sub-island of <code>grid1</code>.</p>
<p>We start by iterating through each cell in <code>grid2</code>. Upon encountering an unvisited land cell, we initiate a DFS to mark all connected land cells as visited. During the traversal, we compare each cell in <code>grid2</code> with the corresponding cell in <code>grid1</code>. If any land cell in <code>grid2</code> maps to a water cell in <code>grid1</code>, the island is disqualified. If the island passes the check, it is counted as a sub-island.</p>
<p>DFS is ideal for this task because it efficiently handles deep, recursive exploration, avoiding the need for additional data structures like a queue.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an array <code>directions</code> for the four movement directions: up, down, left, and right, representing changes in <code>(x, y)</code> coordinates.</li>
<li>Define a helper method <code>isCellLand(x, y, grid)</code> to check if the cell at <code>(x, y)</code> in <code>grid</code> is a land cell.</li>
<li>Define a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> to determine if the island in <code>grid2</code> containing cell <code>(x, y)</code> is a sub-island of <code>grid1</code>. This method uses DFS to:
<ul>
<li>Initialize <code>isSubIsland</code> as <code>true</code>.</li>
<li>Check if the corresponding cell in <code>grid1</code> is land; if not, set <code>isSubIsland</code> to <code>false</code>.</li>
<li>Move in all four directions. For each valid, unvisited land cell in <code>grid2</code>, recursively check if itâ€™s part of a sub-island and update <code>isSubIsland</code> accordingly.</li>
<li>Return <code>isSubIsland</code> after traversing the island.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as <code>grid2</code> to keep track of visited cells.</li>
<li>Initialize <code>subIslandsCount</code> to <code>0</code> to count sub-islands.</li>
<li>Iterate through all cells of <code>grid2</code>. For each unvisited land cell, use <code>isSubIsland</code> to check if it's a sub-island of <code>grid1</code>. Increment <code>subIslandsCount</code> if it is.</li>
<li>Return <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VSRKGot2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform DFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the recursive stack.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-Find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Union-Find, or Disjoint Set Union (DSU), is a data structure that efficiently manages disjoint subsets, supporting quick union and find operations. Itâ€™s well-suited for problems where you need to determine if elements are in the same subset or to merge subsets. The key idea is to treat each island as a separate set and unite these sets based on connectivity.</p>
<p>In the context of this problem, we start by representing each land cell in both grids as a node in a graph. The main challenge is to determine whether an island in <code>grid2</code> is a sub-island of <code>grid1</code>, which means all cells of an island in <code>grid2</code> must also belong to the corresponding island in <code>grid1</code>. To implement this, we can follow these steps:</p>
<p>First, we initialize a Union-Find data structure where each cell initially belongs to its own set. As we iterate through the grid, we union adjacent land cells (cells with value <code>1</code>) in <code>grid2</code>. This results in a partitioning of the grid into distinct islands, where each island is represented by its parent node in the Union-Find structure.</p>
<p>After unionizing all possible cells within each grid, the next step is to compare the islands in <code>grid2</code> with the corresponding islands in <code>grid1</code>. As we discussed in the overview section, for each land cell in <code>grid2</code> there should be a corresponding land cell at the same position in <code>grid1</code> as well. If any land cell in an island of <code>grid2</code> does not have a corresponding land cell in <code>grid1</code>, the entire island containing that land cell is disqualified as a sub-island and we mark the parent cell of that island of <code>grid2</code> as not a sub-island.</p>
<p>Union-Find allows us to efficiently manage and compare these islands by providing quick union operations to group cells and find operations to identify the root of any given cell. Additionally, the process is optimized by two key techniques: path compression and union by rank. Path compression ensures that during the find operation, each node on the path to the root directly connects to the root, making future find operations faster. Union by rank helps to keep the tree representing each set shallow by always attaching the smaller tree under the root of the larger tree during union operations.</p>
<p>By the end of the process, the number of valid sub-islands can be determined by counting how many islands in <code>grid2</code> satisfy the condition of being entirely contained within the corresponding islands in <code>grid1</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a class <code>UnionFind</code> which initialized two arrays <code>rank</code> and <code>parent</code> with size <code>n</code>. Initially rank of all elements is <code>0</code> and the parent is the element itself.
<ul>
<li>Create a method <code>int find(int u)</code>, which returns the <code>parent</code> of element <code>u</code> using the path compression technique.</li>
<li>Create a method <code>void unionSets(int u, int v)</code>, which joins two components of elements <code>u</code> and <code>v</code> into one based on their parent's ranks.</li>
</ul>
</li>
<li>Create a helper method <code>convertToIndex(int x, int y, int totalCols)</code> which converts and returns the 2-dimensional position to a 1-dimensional index.</li>
<li>Initialize a <code>UnionFind</code> object <code>uf</code> with size the same as <code>grid2</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> using nested for loop, and join the adjacent cells to the current land cell if they are also a land cell.</li>
<li>Initialize a boolean array <code>isSubIsland</code> with the size same as <code>grid2</code> initially storing <code>true</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if the respective cell in the <code>grid1</code> isn't a land cell then mark the <code>parent</code> node of the current land cell's island as <code>false</code> in the <code>isSubIsland</code> array.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if <code>isSubIsland</code> for the parent cell is <code>true</code> count the sub-island, i.e. increment <code>subIslandsCount</code> by <code>1</code> and mark it as <code>false</code> to prevent counting it multiple times.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/jhroFs5M/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each land cell of the grid and perform union operations with its adjacent cells. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional object <code>uf</code> and a boolean array <code>isSubIsland</code> of size <span class="math inline">\(m * n\)</span>.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-complete-components/description" target="_blank" rel="noopener noreferrer">Count the Number of Complete Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png" style="width: 671px; height: 270px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before diving into the solution, letâ€™s clarify what a <strong>complete connected component</strong> is. A complete connected component is a set of nodes and edges in a graph (also known as a subgraph) that satisfies the following conditions:</p>
<ul>
<li>It is <strong>connected</strong>, meaning every pair of vertices in the subgraph is reachable through some path, and no vertex connects to another component.</li>
<li>It is <strong>complete</strong>, meaning every vertex in the component has a direct edge to every other vertex. Notice that every complete subgraph is also a connected subgraph, but the reverse is not always true.</li>
</ul>
<p>In simpler terms, we are looking for connected subgraphs that form perfect <a href="https://en.wikipedia.org/wiki/Clique_(graph_theory)">cliques</a> - where each vertex is directly connected to all others within the component.</p>
<p><img src="../Figures/2685/subgraphs.png" alt="types of subgraph" /></p>
<blockquote>
<p>A strong grasp of fundamental graph algorithms like Depth-First Search, Breadth-First Search, and Disjoint Set Union is essential for understanding the solutions ahead. If you need a refresher or want to explore these concepts further, check out the <a href="https://leetcode.com/explore/learn/card/graph/">Graph Explore Card</a>. This resource provides an in-depth look at key graph algorithms, their applications, and a variety of problems to reinforce the underlying patterns.</p>
</blockquote>
<hr />
<h3 id="approach-1-adjacency-list">Approach 1: Adjacency List</h3>
<h4 id="intuition">Intuition</h4>
<p>The most common way to represent a graph is through an adjacency list, where each node points to a list of all the nodes it is directly connected to.</p>
<p>For example, consider a graph where vertices <code>0</code>, <code>1</code>, and <code>2</code> form a complete component. Their adjacency lists would look like this:</p>
<ul>
<li>Vertex <code>0</code>â€™s neighbors: <code>[1, 2]</code></li>
<li>Vertex <code>1</code>â€™s neighbors: <code>[0, 2]</code></li>
<li>Vertex <code>2</code>â€™s neighbors: <code>[0, 1]</code></li>
</ul>
<p>Now, letâ€™s take a moment to include each vertex as its own neighbor. This does not violate any constraints since every node is naturally reachable from itself. After this adjustment, the adjacency lists would look like:</p>
<ul>
<li>Vertex <code>0</code>â€™s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>1</code>â€™s neighbors: <code>[0, 1, 2]</code></li>
<li>Vertex <code>2</code>â€™s neighbors: <code>[0, 1, 2]</code></li>
</ul>
<p>This leads to a key insight: in a complete connected component, every vertex must have the exact same set of neighbors (including itself). This forms a unique &quot;adjacency pattern&quot; that is shared by all vertices in the same component.</p>
<p>Let us create the adjacency list for the graph and include each vertex as a neighbor in its own list. Now, we need to identify all vertices that share the same neighbor pattern.</p>
<p>To do this, we can use a hash map where the key represents a unique neighbor pattern, and the value keeps track of how many times this pattern appears in the graph. However, there may be cases where two neighbor patterns are the same but appear differently in the adjacency list (for example, <code>0: [0, 1, 2]</code> and <code>2: [2, 1, 0]</code>). To ensure they are grouped together, we first sort each neighbor list before adding it to the map.</p>
<p>Next, we go through each entry in the map to count how many unique patterns were collected. But one final check is needed: the size of the adjacency list must match the number of vertices that share this pattern. In other words, the size of the list should be equal to its frequency of occurrence in the map.</p>
<p>Why? Because in a complete component with <code>k</code> vertices, each vertex must have exactly <code>k</code> neighbors (including itself). And exactly <code>k</code> vertices must share this pattern - one for each member of the component.</p>
<p>Finally, we count the number of entries in the map that pass this validation and return this count as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an array of adjacency lists called <code>graph</code> with size <code>n</code>.</li>
<li>a hash map <code>componentFreq</code> to track frequencies of unique adjacency lists.</li>
</ul>
</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Initialize the adjacency list for the current vertex and add the vertex itself (self-loop).</li>
</ul>
</li>
<li>Build the graph by looping through each <code>edge = [u, v]</code> in the <code>edges</code> array:
<ul>
<li>Push <code>v</code> into <code>u</code>'s adjacency list (<code>graph[u]</code>).</li>
<li>Push <code>u</code> into <code>v</code>'s adjacency list (<code>graph[v]</code>).</li>
</ul>
</li>
<li>For each vertex from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Get and sort its list of neighbors.</li>
<li>Increment the frequency count for this specific adjacency pattern in the <code>componentFreq</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Iterate through each entry in the <code>componentFreq</code> map:
<ul>
<li>If the size of the adjacency list equals its frequency count, increment <code>completeCount</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/g4GoucsF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \log n)\)</span></p>
<p>The solution's time complexity stems from several operations. Initializing the adjacency lists requires <span class="math inline">\(O(n)\)</span> time as we create a list for each vertex. When building the adjacency lists from the edges, we spend <span class="math inline">\(O(m)\)</span> time adding each edge to the lists of both vertices it connects.</p>
<p>The most expensive operation comes when we sort each vertex's adjacency list, which costs <span class="math inline">\(O(d_i \log d_i)\)</span> for a vertex with degree <span class="math inline">\(d_i\)</span>. Across all vertices, this sorting accounts for <span class="math inline">\(O(\sum_{i=0}^{n-1} d_i \log d_i)\)</span> time. Since <span class="math inline">\(\sum d_i = 2m\)</span> and the maximum degree is bounded by <span class="math inline">\(n\)</span>, this simplifies to <span class="math inline">\(O(m \log n)\)</span> in the worst case. The final operations of processing vertices and counting complete components take <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is dominated by the sorting step, giving us <span class="math inline">\(O(n + m \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m + S)\)</span></p>
<p>For space complexity, we use memory for the adjacency list array itself, which requires <span class="math inline">\(O(n)\)</span> space. The contents of all adjacency lists collectively require space proportional to the number of edges, contributing <span class="math inline">\(O(m)\)</span> to our space usage.</p>
<p>The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span> .</li>
</ul>
<p>While the hash map stores references to these same adjacency lists, it doesn't significantly increase the asymptotic space complexity. Each unique component pattern may be stored once in the hash map, but the total size of all stored patterns remains bounded by the total size of all adjacency lists, which is <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth-First Search (DFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's now return to traditional graph traversal techniques to solve this problem. Depth-first search (DFS) is particularly well-suited for this task. Starting from an unvisited vertex, DFS explores as far as possible along a branch before backtracking, ensuring that every vertex reachable from the starting point is visited.</p>
<p>But how do we determine if a component is complete? One approach is to check every pair of vertices in the component to see if they share an edge, but this would be inefficient.</p>
<p>Instead, we can take advantage of a key property of complete graphs: in a complete graph with <span class="math inline">\(n\)</span> vertices, there must be exactly <span class="math inline">\(\frac{n \cdot (n-1)}{2}\)</span> unique edges - equal to the number of pairs of nodes in the graph. Since our graph is undirected but our adjacency list counts each edge twice (once from each endpoint), the total edge count from the adjacency lists should be <span class="math inline">\(n \cdot (n-1)\)</span>.</p>
<p>During our DFS traversal, we will track two crucial pieces of information for each component:</p>
<ol>
<li>The number of vertices in the component.</li>
<li>The total number of edges connected to vertices in the component.</li>
</ol>
<p>For each new vertex we visit, we increment the vertex count and add all its edges to the total edge count. Once the traversal is complete, we check if the gathered values match the expected count. We keep track of all components that meet this condition, and after visiting all vertices, we return this count as our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Create a hash set <code>visited</code> to keep track of visited vertices.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Initialize an array <code>componentInfo</code> with two elements to track: <code>[0]</code>: number of vertices and <code>[1]</code>: total edges.</li>
<li>Call the <code>dfs</code> function starting from the current <code>vertex</code>.</li>
<li>Check if the component is complete by comparing the number of edges to <code>vertices * (vertices - 1)</code>.</li>
<li>Increment <code>completeCount</code> if the condition is met.</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper method <code>dfs(curr, graph, visited, componentInfo)</code>:</p>
<ul>
<li>Mark the current vertex as visited.</li>
<li>Increment the vertex count in <code>componentInfo[0]</code>.</li>
<li>Add the number of edges from the current vertex to <code>componentInfo[1]</code>.</li>
<li>Recursively explore all unvisited neighbors of the current vertex.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/keZDcvFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm begins with graph initialization, where populating the adjacency list by processing <span class="math inline">\(m\)</span> edges requires <span class="math inline">\(O(m)\)</span>, since each edge is added to two lists.</p>
<p>The core of the solution is a DFS traversal, which visits each vertex once and explores all edges connected to it. Since each edge is considered at most twice (once from each endpoint), DFS runs in <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Summing these components, the overall time complexity remains <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation requires <span class="math inline">\(O(n)\)</span> for the array and <span class="math inline">\(O(m)\)</span> for the edge storage. The <code>visited</code> set stores at most <span class="math inline">\(O(n)\)</span> vertices, while the recursive DFS calls can create a call stack of size <span class="math inline">\(O(n)\)</span> in the worst case. The <code>componentInfo</code> array uses constant space.</p>
<p>Combining these, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>, dominated by the graph representation and recursion stack.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-breadth-first-search-bfs">Approach 3: Breadth-First Search (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The other quintessential graph traversal algorithm is the Breadth-First Search (BFS), which can also be used to solve this problem.</p>
<p>BFS explores each component using a queue. We maintain a <code>visited</code> array to track which vertices have been visited. When we encounter an unvisited vertex, we add it to the queue and begin exploring its connected component.</p>
<p>Along with the queue, we maintain a list called <code>component</code> to store all vertices belonging to the current component. Once the exploration is complete, we need to verify whether the component is fully connected. For a component with <code>k</code> vertices to be complete, every vertex must have exactly <code>k - 1</code> edges connecting it to the other vertices within the component.</p>
<p>After finishing the BFS traversal for a component, we iterate through the gathered vertices in <code>component</code>. If the size of the component is <code>k</code> and each vertex has exactly <code>k - 1</code> edges, we confirm that it is a complete component and increment our count.</p>
<p>Once all vertices in the graph have been explored, we return this count as our final answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an array of adjacency lists called <code>graph</code> with size <code>n</code> to represent the undirected graph.</li>
<li>Build the graph by looping through each edge in the <code>edges</code> array:
<ul>
<li>Add each vertex to the other's adjacency list.</li>
</ul>
</li>
<li>Create a boolean array <code>visited</code> of size <code>n</code> to track visited vertices.</li>
<li>Initialize a counter variable <code>completeComponents</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Skip if the <code>vertex</code> has already been visited.</li>
<li>Create a list called <code>component</code> to store vertices in the current component.</li>
<li>Initialize a <code>queue</code> and add the current vertex to it.</li>
<li>Mark the current <code>vertex</code> as visited.</li>
<li>Perform BFS:
<ul>
<li>Poll the next vertex from the queue.</li>
<li>Add it to the component list.</li>
<li>Process all unvisited neighbors by adding them to the queue and marking them as visited.</li>
</ul>
</li>
<li>After BFS completes, check if the component is complete:
<ul>
<li>Initialize <code>isComplete</code> as <code>true</code>.</li>
<li>For each <code>node</code> in the component:
<ul>
<li>Check if the number of its neighbors equals <code>component.size - 1</code>.</li>
<li>If not, set <code>isComplete</code> to <code>false</code> and break.</li>
</ul>
</li>
</ul>
</li>
<li>If the component is complete, increment <code>completeComponents</code>.</li>
</ul>
</li>
<li>Return the final value of <code>completeComponents</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RgcCySnK/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The solution first builds an adjacency list representation, which takes <span class="math inline">\(O(n)\)</span> time for initialization and <span class="math inline">\(O(m)\)</span> time to add all edges. Then, for each unvisited vertex, we perform a BFS traversal that visits each vertex and edge exactly once across all components, taking <span class="math inline">\(O(n + m)\)</span> time in total.</p>
<p>For each component found, we check if it's complete by examining the degree of each vertex in the component, which cumulatively takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(n + m)\)</span> space: <span class="math inline">\(O(n)\)</span> for the array of lists and <span class="math inline">\(O(m)\)</span> for storing all edges. The visited array requires <span class="math inline">\(O(n)\)</span> space. The queue used in BFS and the list to store component vertices can each contain at most <span class="math inline">\(O(n)\)</span> vertices.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>A complete connected component has a distinct property: it is a disjoint unit of the graph, meaning it does not share any connections with other parts of the graph. Our task is to identify these disjoint units and check whether their vertices and edges meet the criteria for completeness and connectivity.</p>
<p>One of the most effective ways to find separate groups in a graph is by using the Union-Find algorithm (also known as Disjoint Set Union). This method helps group vertices that belong together. Each group has a representative vertex, known as the leader, which serves as the group's identifier. To determine whether two vertices belong to the same group, we simply check if they share the same leader.</p>
<p>In our Union-Find implementation, we also track the size of each component. Maintaining size is not only useful for optimizing the merging of components - since attaching a smaller component to a larger one is more efficient - but also plays a crucial role in this problem: it tells us exactly how many vertices exist in each component. To verify whether a component is a valid complete connected component, we check if its edge count matches <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>, where <span class="math inline">\(k\)</span> is the number of vertices in the component.</p>
<p>Now, letâ€™s implement our solution. First, we initialize a Union-Find structure and perform the &quot;union&quot; operation for each edge in our input. Since an edge signifies that two vertices belong to the same component, applying &quot;union&quot; to all edges ensures that all vertices are grouped correctly.</p>
<p>Next, we count the number of edges in each component. To do this, we use a hash map that associates each component with its edge count. Since Union-Find assigns each component a unique representative (the root of its tree), we use these representatives as keys in the map.</p>
<p>Finally, we iterate through each group leader and check if the group forms a complete component. A group is complete if its edge count equals <span class="math inline">\(\frac{k \cdot (k - 1)}{2}\)</span>. If it does, we increment our final count. Once all components have been processed, we return the total number of complete components as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Create a <code>UnionFind</code> data structure <code>dsu</code> to track connected components in the graph.</li>
<li>Initialize a hash map <code>edgeCount</code> to track the number of edges in each component.</li>
<li>Loop through each edge in the <code>edges</code> array:
<ul>
<li>Join the two vertices using the <code>union</code> operation.</li>
</ul>
</li>
<li>Loop through the <code>edges</code> again:
<ul>
<li>Find the root of the component containing the first vertex of each edge.</li>
<li>Increment the edge count for that component in the <code>edgeCount</code> map.</li>
</ul>
</li>
<li>Initialize a counter variable <code>completeCount</code> to zero.</li>
<li>Loop through each <code>vertex</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the <code>vertex</code> is a root (representative) of its component:
<ul>
<li>Calculate the expected number of edges for a complete component with that many vertices: <code>(size[vertex] * (size[vertex] - 1)) / 2</code>.</li>
</ul>
</li>
<li>Compare the actual edge count with the expected edge count.
<ul>
<li>If they match, increment <code>completeCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final value of <code>completeCount</code>.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>
<p>Initialize a <code>UnionFind</code> class with two instance variables:</p>
<ul>
<li>An array <code>parent</code> to track the parent of each node.</li>
<li>An array <code>size</code> to track the size of each component.</li>
</ul>
</li>
<li>
<p>In the constructor <code>dsu(n)</code>:</p>
<ul>
<li>Initialize both arrays with size <code>n</code>.</li>
<li>Fill the <code>parent</code> array with <code>-1</code> to indicate each node is its own parent initially.</li>
<li>Fill the <code>size</code> array with <code>1</code> as each node starts in its own single-node component.</li>
</ul>
</li>
<li>
<p>In the <code>find(node)</code> method:</p>
<ul>
<li>Check if the node's parent is <code>-1</code> (indicating it's a root).</li>
<li>If it is a root, return the <code>node</code> itself.</li>
<li>Otherwise, recursively find the root and update the <code>node</code>'s parent (path compression).</li>
</ul>
</li>
<li>
<p>In the <code>union(node1, node2)</code> method:</p>
<ul>
<li>Find the roots of nodes <code>node1</code> and <code>node2</code> using the <code>find</code> method.</li>
<li>If both nodes already belong to the same component (same root), return early.</li>
<li>Apply union-by-size strategy:
<ul>
<li>If the component containing <code>node1</code> is larger:
<ul>
<li>Make <code>root1</code> the parent of <code>root2</code>.</li>
<li>Add the size of <code>root2</code>'s component to <code>root1</code>'s component size.</li>
</ul>
</li>
<li>Otherwise, make <code>root2</code> the parent of <code>root1</code> and alter size accordingly.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/RYozofJc/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices and <span class="math inline">\(m\)</span> be the number of edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m\alpha(n))\)</span></p>
<p>The solution uses a Union-Find data structure with path compression and union by size. Building the Union-Find structure takes <span class="math inline">\(O(n)\)</span> time for initialization. Processing all edges through union operations takes <span class="math inline">\(O(m\alpha(n))\)</span> time, where <span class="math inline">\(\alpha(n)\)</span> is the inverse Ackermann function, which grows extremely slowly and is practically constant.</p>
<p>Counting edges in each component requires iterating through all edges again, taking <span class="math inline">\(O(m)\)</span> time. Finally, checking if each component is complete involves iterating through all vertices once, taking <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n + m\alpha(n))\)</span>, which is essentially linear in practice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The Union-Find data structure uses two arrays of size <span class="math inline">\(n\)</span> for parent pointers and component sizes, requiring <span class="math inline">\(O(n)\)</span> space. The edge count map stores at most <span class="math inline">\(n\)</span> entries (one for each potential component root), requiring <span class="math inline">\(O(n)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description" target="_blank" rel="noopener noreferrer">Count Unreachable Pairs of Nodes in an Undirected Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>Return <em>the <strong>number of pairs</strong> of different nodes that are <strong>unreachable</strong> from each other</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-3.png" style="width: 267px; height: 169px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/05/tc-2.png" style="width: 295px; height: 269px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/couples-holding-hands/description" target="_blank" rel="noopener noreferrer">Couples Holding Hands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> couples sitting in <code>2n</code> seats arranged in a row and want to hold hands.</p>

<p>The people and seats are represented by an integer array <code>row</code> where <code>row[i]</code> is the ID of the person sitting in the <code>i<sup>th</sup></code> seat. The couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2n - 2, 2n - 1)</code>.</p>

<p>Return <em>the minimum number of swaps so that every couple is sitting side by side</em>. A swap consists of choosing any two people, then they stand up and switch seats.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> row = [0,2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We only need to swap the second (row[1]) and third (row[2]) person.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> row = [3,2,0,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All couples are already seated side by side.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2n == row.length</code></li>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>n</code> is even.</li>
	<li><code>0 &lt;= row[i] &lt; 2n</code></li>
	<li>All the elements of <code>row</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detect-cycles-in-2d-grid/description" target="_blank" rel="noopener noreferrer">Detect Cycles in 2D Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D array of characters <code>grid</code> of size <code>m x n</code>, you need to find if there exists any cycle consisting of the <strong>same value</strong> in <code>grid</code>.</p>

<p>A cycle is a path of <strong>length 4 or more</strong> in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the <strong>same value</strong> of the current cell.</p>

<p>Also, you cannot move to the cell that you visited in your last move. For example, the cycle <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> is invalid because from <code>(1, 2)</code> we visited <code>(1, 1)</code> which was the last visited cell.</p>

<p>Return <code>true</code> if any cycle of the same value exists in <code>grid</code>, otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/1.png" style="width: 231px; height: 152px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There are two valid cycles shown in different colors in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/11.png" style="width: 225px; height: 163px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/22.png" style="width: 236px; height: 154px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There is only one valid cycle highlighted in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/2.png" style="width: 229px; height: 157px;" />
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/3.png" style="width: 183px; height: 120px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/detect-cycle-using-dsu/1" target="_blank" rel="noopener noreferrer">Detect Cycle using DSU</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an <strong>undirected graph</strong> with <strong>no self loops</strong> with <strong>V (from 0 to V-1)</strong> nodes and <strong>E</strong> edges, the task is to check if there is any <strong>cycle </strong>in the <strong>undirected graph</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Solve the problem using <strong>disjoint set union (DSU).</strong></span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701410/Web/Other/blobid0_1745299580.jpg" width="303" height="268" /><br /><span style="font-size: 18px;"><strong>Output:</strong><strong>&nbsp;</strong>1
<strong>Explanation: </strong>There is a cycle between 0-&gt;2-&gt;4-&gt;0</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701410/Web/Other/blobid1_1745299616.jpg" width="307" height="272" /><br /><span style="font-size: 18px;"><strong>Output: </strong>0
<strong>Explanation: </strong>The graph doesn't contain any cycle</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anyhting. Your task is to complete the function&nbsp;<strong>detectCycle()&nbsp;</strong>which takes number of vertices in the graph denoting as <strong>V</strong> and adjacency list <strong>adj </strong>and returns <strong>1</strong> if graph contains any <strong>cycle </strong>otherwise returns <strong>0</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(V + E)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(V)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">2 &le; V &le; 10<sup>4<br /></sup></span><span style="font-size: 18px;">1 &le; E &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/description" target="_blank" rel="noopener noreferrer">Divide Nodes Into the Maximum Number of Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes in an <strong>undirected</strong> graph. The nodes are labeled from <code>1</code> to <code>n</code>.</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code> indicates that there is a <strong>bidirectional</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. <strong>Notice</strong> that the given graph may be disconnected.</p>

<p>Divide the nodes of the graph into <code>m</code> groups (<strong>1-indexed</strong>) such that:</p>

<ul>
	<li>Each node in the graph belongs to exactly one group.</li>
	<li>For every pair of nodes in the graph that are connected by an edge <code>[a<sub>i, </sub>b<sub>i</sub>]</code>, if <code>a<sub>i</sub></code> belongs to the group with index <code>x</code>, and <code>b<sub>i</sub></code> belongs to the group with index <code>y</code>, then <code>|y - x| = 1</code>.</li>
</ul>

<p>Return <em>the maximum number of groups (i.e., maximum </em><code>m</code><em>) into which you can divide the nodes</em>. Return <code>-1</code> <em>if it is impossible to group the nodes with the given conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/13/example1.png" style="width: 352px; height: 201px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> As shown in the image we:
- Add node 5 to the first group.
- Add node 1 to the second group.
- Add nodes 2 and 4 to the third group.
- Add nodes 3 and 6 to the fourth group.
We can see that every edge is satisfied.
It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, edges = [[1,2],[2,3],[3,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.
It can be shown that no grouping is possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There is at most one edge between any pair of vertices.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph with <code>n</code> nodes, represented by a 2D array edges, where <code>edges[i] = [u, v]</code> means there is a bidirectional edge between nodes <code>u</code> and <code>v</code>. Our task is to divide the nodes into the largest number of numbered groups (1, 2, 3, ...) such that:</p>
<ul>
<li>Each node belongs to exactly one group.</li>
<li>If there is an edge <code>[u, v]</code>, and <code>u</code> is in group <code>x</code>, then <code>v</code> must be in either group <code>x - 1</code> or <code>x + 1</code>.</li>
</ul>
<p>Sometimes, this kind of split is not possible. For example, consider this graph:</p>
<p><img src="../Figures/2493/2493_impossible_split.png" alt="Impossible Split" /></p>
<p>Here, no valid split exists. In such cases, we return <code>-1</code>.</p>
<p>A key observation is that if itâ€™s possible to divide the nodes into <code>x</code> groups (<code>x &gt; 2</code>), we can also divide them into <code>x - 1</code> groups. Intuitively, this works because the nodes in the first and third groups canâ€™t be directly connected, but they must all connect to nodes in the second group. By combining groups <code>1</code> and <code>3</code>, we get a valid split with <code>x - 1</code> groups.</p>
<p><img src="../Figures/2493/2493_combine_node_groups.png" alt="Combining Node Groups to Get A Valid Split With One Less Group" /></p>
<p>So, to check if a valid split is possible, we just need to see if the graph can be split into two groupsâ€”in other words, whether it is <em>bipartite</em>.</p>
<blockquote>
<p>A graph is <strong>bipartite</strong> when we can divide its nodes into two distinct sets where:</p>
<ul>
<li>All edges connect vertices from one set to vertices in the other set.</li>
<li>No edges exist between vertices within the same set.</li>
</ul>
</blockquote>
<p>Another key detail to consider is that the given graph is not always connected. In this case, we calculate the largest number of groups for each connected part of the graph, and then take the sum of these numbers.</p>
<p>To sum up, the problem boils down to these two steps:</p>
<ol>
<li>Check if the graph is bipartite to see if a valid split exists.</li>
<li>For each connected part of the graph, find the largest number of groups we can divide the nodes into and return their sum.</li>
</ol>
<hr />
<h3 id="approach-1-graph-coloring--longest-shortest-path">Approach 1: Graph Coloring + Longest Shortest Path</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the first part of the problem, note that once we assign a single node to one of the two groups, the rest of the assignments are automatically determined. Nodes directly connected to the first node must go in the second group, their neighbors must return to the first group, and so on.</p>
<p>To check if the graph is bipartite, we &quot;color&quot; the nodes using two colors (one for each group), ensuring that any two connected nodes have different colors. If this coloring fails, the graph is not bipartite, and we can immediately return <code>-1</code>.</p>
<p><img src="../Figures/2493/2493_graph_coloring.png" alt="Impossible Graph Coloring" /></p>
<p>If the graph is bipartite, we calculate the maximum number of groups we can divide the nodes into for each connected component separately. Intuitively, to achieve the largest number of groups, we spread the nodes as far apart as possible. This means that instead of simply assigning a neighboring node to the same group as the one it was previously associated with, we always try to assign it to a new group.</p>
<p>An important observation here is that the maximum number of groups in a component is determined by the longest shortest path between any pair of nodes in that component. This is similar to finding the &quot;height&quot; of the component if it were structured like a tree, with different nodes as potential roots. The longest shortest path essentially tells us how many layers or groups can be created based on the distances between the nodes.</p>
<p>Finally, we repeat this for all connected components in the graph and sum up the results to get the answer.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="isbipartiteadjlist-node-colors-function"><code>isBipartite(adjList, node, colors)</code> function</h5>
<ul>
<li>Iterate over the neighbors of <code>node</code> and attempt to assign them the opposite color of <code>node</code>:
<ul>
<li>If <code>neighbor</code> already has the same color as <code>node</code> (i.e., <code>colors[neighbor] == colors[node]</code>), return <code>false</code>.</li>
<li>If <code>neighbor</code> has already been assigned a color (i.e., <code>colors[neighbor] != -1</code>), skip to the next <code>neighbor</code>.</li>
<li>Assign <code>colors[neighbor] = (colors[node] + 1) % 2</code>.</li>
<li>Recursively call <code>isBipartite(adjList, neighbor, colors)</code> and return <code>false</code> if the call returns <code>false</code>.</li>
</ul>
</li>
<li>If all neighbors are successfully assigned the opposite color without conflicts, return <code>true</code>.</li>
</ul>
<h5 id="getlongestshortestpathadjlist-srcnode-n-function"><code>getLongestShortestPath(adjList, srcNode, n)</code> function</h5>
<ul>
<li>Initialize a queue, <code>nodesQueue</code> and a <code>visited</code> array of size <code>n</code>.</li>
<li>Push<code>srcNode</code> into the queue and mark it as visited.</li>
<li>Initialize <code>distance</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:</li>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, mark it as visited and push it into the <code>nodesQueue</code>.</li>
</ul>
</li>
<li>Increment <code>distance</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>distance</code>.</li>
</ul>
<h5 id="getnumberofgroupsforcomponentadjlist-node-distances-visited-function"><code>getNumberOfGroupsForComponent(adjList, node, distances, visited)</code> function</h5>
<ul>
<li>Initialize <code>maxNumberOfGroups</code> to <code>distances[node]</code>.</li>
<li>Mark the current node as visited.</li>
<li>Explore the rest of the nodes in the component, i.e. for each <code>neighbor</code> of <code>node</code>:
<ul>
<li>If the <code>neighbor</code> is visited, skip it.</li>
<li>Otherwise, set <code>maxNumberOfGroups</code> to the maximum of its current value and <code>getNumberOfComponentsInGroup(adjList, neighbor, distances, visited)</code>.</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create the <code>adjList</code> of the graph.</li>
<li>Create a <code>colors</code> array of size <code>n</code> with all elements initially set to <code>-1</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If the <code>node</code> have not been assigned a color, i.e. (<code>colors[node] == -1</code>):
<ul>
<li>Fix the color of the first node of the component, i.e. set <code>colors[node] = 0</code>.</li>
<li>Call <code>isBipartite(adjList, node, colors)</code> to determine if the current component is bipartite. If not, return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an array <code>distances</code> to store the length of the longest shortest path from any node to any other.</li>
<li>Fill the <code>distances</code> array using the <code>getLongestShortestPath</code> function.</li>
<li>Initialize <code>maxNumberOfGroups</code> to <code>0</code> and a <code>visited</code> array with all elements set to <code>false</code>.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>If <code>node</code> has not been visited:
<ul>
<li>Get the number of groups for its component and add it to the total number of groups, i.e. <code>maxNumberOfGroups += getNumberOfGroupsForComponent(adjList, node, distances, visited)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BbpVEPXV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>To check whether the graph is bipartite, we perform a DFS traversal, assigning a color to each node exactly once and visiting each edge exactly once. Thus, this step has a time complexity of <span class="math inline">\(O(n + m)\)</span>.</p>
<p>Next, calculating the longest shortest path for each node involves <span class="math inline">\(n\)</span> BFS traversals (one for each node as the source), resulting in a time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
<p>Finally, another DFS is performed to compute the sum of the longest shortest paths across all components, which adds an additional <span class="math inline">\(O(n + m)\)</span> to the total.</p>
<p>Overall, the total time complexity is <span class="math inline">\(O(n + m) + O(n \times (n + m)) + O(n + m) = O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Constructing the adjacency list from the list of edges requires <span class="math inline">\(O(n + m)\)</span> space, which is an additional space requirement rather than part of the input itself. Therefore, the total auxiliary space complexity is determined by both the adjacency list and the additional data structures (<code>visited</code>, <code>nodesQueue</code>, <code>colors</code>), all of which take <span class="math inline">\(O(n)\)</span> space. As a result, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs--union-find">Approach 2: BFS + Union-Find</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, instead of checking bipartiteness to find if there is a valid split, we attempt to directly maximize the number of groups the graph can be partitioned into. Let's first consider the strategy for a single component:</p>
<p>We begin by assigning each node in the component to the first group. From there, we attempt to propagate this group assignment to the neighboring nodes, creating a new group for each &quot;layer&quot; of neighbors. This means that nodes at the same distance from the starting node would belong to the same group, while nodes at different distances would belong to different groups.</p>
<p>However, if we ever come across a neighbor that has already been assigned the same group as the current node, it means that it's not possible to partition the graph in the way we're attempting. In that case, the graph is not partitionable, and we return <code>-1</code>.</p>
<p>Once we explore all possible groups for the component by starting the process at each node in the component, we find the maximum number of groups that can be formed. This maximum value will be the largest number of groups we can use to partition the nodes of that particular component.</p>
<p>Finally, to compute the answer for the entire graph, we repeat this process for each connected component, summing the maximum number of groups from all components. To efficiently track the connected nodes and perform the necessary computations, we use the Union-Find data structure, which helps us manage and combine the connected components as we progress through the graph.</p>
<blockquote>
<p>For a more comprehensive understanding of Union-Find / Disjoint Set, check out the <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find/Disjoint Set Explore Card</a>. This resource provides an in-depth look at union-find, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h4 id="getnumberofgroupsadjlist-srcnode-n"><code>getNumberOfGroups(adjList, srcNode, n)</code></h4>
<ul>
<li>Initialize a queue, <code>nodesQueue</code>, and an array, <code>layerSeen</code> of size <code>n</code> with all values set to <code>-1</code>.</li>
<li>Push<code>srcNode</code> into the queue and set <code>layerSeen[srcNode]</code> to <code>0</code>.</li>
<li>Initialize <code>deepestLayer</code> to <code>0</code>.</li>
<li>While the <code>nodesQueue</code> is not empty:
<ul>
<li>Initialize <code>numOfNodesInLayer</code> to the size of the queue.</li>
<li>Process all nodes in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>numOfNodesInLayer - 1</code>:
<ul>
<li>Pop out the first element from the queue as <code>currentNode</code>.</li>
<li>For each <code>neighbor</code> of <code>currentNode</code>:
<ul>
<li>If the <code>neighbor</code> is not visited, i.e. <code>layerSeen[neighbor] == -1</code>:
<ul>
<li>Set <code>layerSeen[neighbor] = deepestLayer + 1</code>.</li>
<li>Push <code>neighbor</code> into the queue.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>If the <code>neighbor</code> is seen in the current layer (<code>deepestLayer</code>), then the split is invalid; return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>deepestLayer</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>deepestLayer</code>.</li>
</ul>
<h5 id="findnode-parent-function"><code>find(node, parent)</code> function</h5>
<ul>
<li>While <code>node</code> is not the root of its subtree, i.e. <code>parent[node] != -1</code>:
<ul>
<li>Set <code>node = parent[node]</code>.</li>
</ul>
</li>
<li>Return <code>node</code>.</li>
</ul>
<h5 id="unionnode1-node2-parent-depth-function"><code>Union(node1, node2, parent, depth)</code> function</h5>
<ul>
<li>Replace <code>node1</code> and <code>node2</code> by the roots of their subtrees, by setting <code>node1 = find(node1, parent)</code> and <code>node2 = find(node2, parent)</code>.</li>
<li>If <code>node1 == node2</code>, the two nodes already belong in the same set, so simply return.</li>
<li>If <code>node1</code> has a smaller depth than <code>node2</code>, swap the two nodes.</li>
<li>Set <code>node1</code> to be the parent of <code>node2</code>.</li>
<li>If the depths of the two nodes are equal, increment <code>depth[node1]</code> by <code>1</code>.</li>
</ul>
<h5 id="in-the-main-magnificentsetsn-edges-function-1">In the main <code>magnificentSets(n, edges)</code> function:</h5>
<ul>
<li>Create a 2D array, <code>adjList</code>.</li>
<li>Initialize two arrays of size <code>n</code>, <code>parent</code>, and <code>depth</code> for the Union-Find. Set the parent of each node to <code>-1</code> and its depth to <code>0</code>.</li>
<li>For each <code>edge = [node1, node2]</code> in <code>edges</code>:
<ul>
<li>Push <code>node1 - 1</code> to <code>adjList[node2 - 1]</code> (transitioning to 0-index).</li>
<li>Push <code>node2 - 1</code> to <code>adjList[node1 - 1]</code>.</li>
<li>Call <code>Union(node1 - 1, node2 - 1, parent, depth)</code>.</li>
</ul>
</li>
<li>Initialize a map, <code>numOfGroupsForComponent</code> to store the greatest number of groups that can be achieved for each component of the graph.</li>
<li>For each <code>node</code> of the graph:
<ul>
<li>Calculate the number of groups the nodes of its component will be split into, if we assign <code>node</code> to the first group: <code>numberOfGroups = getNumberOfGroups(adjList, node, n)</code>.</li>
<li>If <code>numberOfGroups = -1</code>, then a split is impossible for that component, so return <code>-1</code>.</li>
<li>Find the <code>rootNode</code> of <code>node</code>s component, <code>root = find(node, parent)</code>.</li>
<li>Update the greatest number of groups that can be achieved for this component (<code>numOfGroupsForComponent[rootNode]</code>) to the maximum of its current value and <code>numberOfGroups</code>.</li>
</ul>
</li>
<li>Initialize <code>totalNumberOfGroups</code> to <code>0</code>.</li>
<li>For every <code>[rootNode, numberOfGroups]</code> in <code>numOfGroupsForComponent</code>:
<ul>
<li>Add <code>numberOfGroups</code> to <code>totalNumberOfGroups</code>.</li>
</ul>
</li>
<li>Return <code>totalNumberOfGroups</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7q5R733V/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph and <span class="math inline">\(m\)</span> the size of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (n + m))\)</span></p>
<p>We use the Union-Find method to detect the connected components of the graph. Each call to the find function traverses the nodes in the component of the given node until it reaches the root. By using the <code>depth</code> array, we maintain balanced sets, ensuring that the find operation has a time complexity of <span class="math inline">\(O(\log n)\)</span>. As a result, the process of identifying the connected components takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Next, we perform a BFS traversal starting from each node. Since the time complexity of BFS is <span class="math inline">\(O(m + n)\)</span>, the total time for this operation is <span class="math inline">\(O(n \times (m + n))\)</span>.</p>
<p>Since <span class="math inline">\(n \log n = O(n \times (m + n))\)</span>, the overall time complexity is dominated by the BFS traversals, giving us a final time complexity of <span class="math inline">\(O(n \times (n + m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>As in the previous approach, representing the graph using an adjacency list requires <span class="math inline">\(O(n + m)\)</span> space. This is an additional space requirement rather than part of the input itself. The auxiliary space complexity is determined by both the adjacency list and the additional data structures used (<code>parent</code>, <code>depth</code>, <code>numberOfGroupsForComponent</code>), which can grow up to <span class="math inline">\(O(n)\)</span> in size. Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-division/description" target="_blank" rel="noopener noreferrer">Evaluate Division</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>

<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>

<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>

<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>

<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]
<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]
<strong>Explanation:</strong> 
Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>
queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined =&gt; -1.0</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]
<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]
<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 20</code></li>
	<li><code>equations[i].length == 2</code></li>
	<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>
	<li><code>values.length == equations.length</code></li>
	<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>
	<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-people-with-secret/description" target="_blank" rel="noopener noreferrer">Find All People With Secret</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating there are <code>n</code> people numbered from <code>0</code> to <code>n - 1</code>. You are also given a <strong>0-indexed</strong> 2D integer array <code>meetings</code> where <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> indicates that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> have a meeting at <code>time<sub>i</sub></code>. A person may attend <strong>multiple meetings</strong> at the same time. Finally, you are given an integer <code>firstPerson</code>.</p>

<p>Person <code>0</code> has a <strong>secret</strong> and initially shares the secret with a person <code>firstPerson</code> at time <code>0</code>. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person <code>x<sub>i</sub></code> has the secret at <code>time<sub>i</sub></code>, then they will share the secret with person <code>y<sub>i</sub></code>, and vice versa.</p>

<p>The secrets are shared <strong>instantaneously</strong>. That is, a person may receive the secret and share it with people in other meetings within the same time frame.</p>

<p>Return <em>a list of all the people that have the secret after all the meetings have taken place. </em>You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,5]
<strong>Explanation:
</strong>At time 0, person 0 shares the secret with person 1.
At time 5, person 1 shares the secret with person 2.
At time 8, person 2 shares the secret with person 3.
At time 10, person 1 shares the secret with person 5.â€‹â€‹â€‹â€‹
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>Output:</strong> [0,1,3]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 3.
At time 2, neither person 1 nor person 2 know the secret.
At time 3, person 3 shares the secret with person 0 and person 1.
Thus, people 0, 1, and 3 know the secret after all the meetings.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
At time 0, person 0 shares the secret with person 1.
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
Note that person 2 can share the secret at the same time as receiving it.
At time 2, person 3 shares the secret with person 4.
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
	<li><code>meetings[i].length == 3</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem,</p>
<ul>
<li>
<p>We have <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and</p>
</li>
<li>
<p>Initially (at time <code>t = 0</code>), person <code>0</code> and <code>firstPerson</code> know the secret.</p>
</li>
<li>
<p>Multiple <code>meetings</code> take place between people. Each meeting is characterized by an array <code>[x, y, t]</code>, where <code>x</code> and <code>y</code> are the labels of the two people that meet, and <code>t</code> is the time of the meeting. If any one of the two people who meet knows the secret at a time <code>t</code>, then both of them will know the secret instantly at the time <code>t</code>.</p>
<p>More than one meeting can take place at the same time <code>t</code></p>
<p>A person can attend multiple meetings at the same time <code>t</code></p>
<blockquote>
<p>If at a time <code>t</code>, we are given the following meetings:</p>
<ul>
<li><code>x</code> and <code>y</code></li>
<li><code>x</code> and <code>z</code></li>
<li><code>z</code> and <code>w</code></li>
<li><code>a</code> and <code>b</code></li>
</ul>
<p>Then we can deduce that all <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> are in the same meeting at the time <code>t</code>.</p>
</blockquote>
<p>Thus, given fixed time <code>t</code>, meetings evolve as <a href="https://en.wikipedia.org/wiki/Equivalence_relation">Equivalence Relation</a>. Particularly meetings are <a href="https://en.wikipedia.org/wiki/Transitive_relation"><strong>transitive</strong></a> in nature.</p>
<p>It's worth noting that it is <strong>NOT</strong> necessary that all participants of the meeting happening at a time <code>t</code>  are in the same meeting. Meetings can be disjoint even if they are happening at the same time <code>t</code>.</p>
<blockquote>
<p>For example, there are two meetings in the above-mentioned example. In the first meeting, we have <code>(x, y, z, w)</code> and in the second meeting, we have <code>(a, b)</code>. Both meetings are happening at the same time <code>t</code> but they are disjoint.</p>
</blockquote>
</li>
</ul>
<p>We are supposed to find and return the labels of all the people who know the secret after all the meetings have taken place.</p>
<p>The editorial systematically solves the problem using multiple approaches.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given that person <code>0</code> and <code>firstPerson</code> know the secret at time <code>t = 0</code>.</p>
<p>Let's restrict our attention to person <code>0</code> only.<br />
<em>(We may generalize our solution for <code>firstPerson</code> similarly)</em></p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_1.PNG" alt="p0" /></p>
<p><code>0</code> knows the secret at time <code>t = 0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_2.PNG" alt="t0" /></p>
<p>Assume person <code>0</code> takes part in following meetings <code>[0, 1, 3]</code>, <code>[0, 2, 5]</code>, <code>[0, 3, 6]</code>, sorted in ascending order of time.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide1_3.PNG" alt="m0" /></p>
<p>Highlighted meetings take place <strong>after or at time <code>t = 0</code></strong>, the time at which person <code>0</code> learned the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_1.PNG" alt="mt0" /></p>
<p>Hence we can say that all those persons corresponding to highlighted meetings will know the secret at the time of the meeting.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide2_2.PNG" alt="mp0" /></p>
<p>Now let's assume that person <code>1</code> takes part in the following meetings <code>[1, 4, 2]</code>, <code>[1, 9, 4]</code>. There is also a meeting <code>[1, 0, 3]</code>, but it has been processed already.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide3.PNG" alt="m1" /></p>
<p>Out of these two, only one meeting <code>[1, 9, 4]</code> takes place <strong>after or at time <code>t = 3</code></strong>, the time at which person <code>1</code> learned the secret, as per the current state of knowledge. Hence, we can say that only person <code>9</code> will know the secret after meeting <code>1</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide4.PNG" alt="mp1" /></p>
<p>Can we now say that person <code>4</code> will NEVER know the secret?<br />
No, we can't. Person <code>4</code> may know the secret in the future.</p>
<p>Hence, we can draft the following approach:</p>
<ul>
<li>
<p>We will start with person <code>0</code> and person <code>firstPerson</code>. They both know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Process people whom they meet after the time at which they learned the secret. All these people will know the secret at the time of the meeting.</p>
<p>Moreover, they will propagate the secret to people they meet after the time they learn the secret. Hence, process these individuals in the same manner as <code>0</code> and <code>firstPerson</code> were processed, except they learned the secret at a different time.</p>
</li>
<li>
<p>Repeat the above step until we have processed all the meetings.</p>
</li>
</ul>
<blockquote>
<p>We are processing persons in a <strong>level-by-level</strong> manner. Whenever we realize that a person knows the secret, we make sufficient efforts to process all the people whom he/she meets after the time at which he/she learned the secret, since we know that they will ultimately know the secret.</p>
<p><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Breadth First Search (BFS)</strong></a> is a natural choice to explore level by level, usually implemented with the help of the queue.<br />
It is a graph traversal algorithm that explores the neighbor nodes first, before moving to the next level neighbors. If readers are not familiar with the BFS, they are strongly encouraged to dive into our <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/"><strong>Queue Explore Card</strong></a> and <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/"><strong>Graph Explore Card</strong></a></p>
</blockquote>
<p>Readers are encouraged to implement the above approach. It is worth mentioning that in <code>meetings</code> we are given meetings in the form of <code>[x, y, t]</code>. However, we are interested that given <code>x</code>, we should be able to find the <code>(y, t)</code> pair for all the meetings in which <code>x</code> participated. Hence, we should use an appropriate data structure to store the information.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a queue <code>q</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>q</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>q</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the queue.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the queue because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EpvjQ4P4/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a>. In standard Breadth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this we are maintaining the <code>earliest</code> array.</p>
<p>Let's assume we will NOT revisit a node.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>This can be represented in the graph as follows. The green-colored people are those who initially know the secret.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_1.PNG" alt="graph" /></p>
<p>The front of the queue <code>(0, 0)</code> will be processed first. We will process person <code>0</code>, and will add its neighbors to the queue. Hence, <code>(1, 4)</code> will be added to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_2.PNG" alt="q0" /></p>
<p>Next in the queue is <code>(2, 2)</code>. We will process person <code>2</code>. However, all its neighbors are already processed. Hence, we will not add any new person to the queue.<br />
<img src="../Figures/2092/2092_slide_images_used/Slide5_3.PNG" alt="q1" /></p>
<p>Next in the queue is <code>(1, 4)</code>. We will process person <code>1</code>, and due to state information, we will assume that it was informed of the secret at time <code>t = 4</code>. Hence, it can inform the secret only to those people it meets after time <code>t = 4</code>. However, it meets person <code>3</code> at time <code>t = 3</code>, hence we will not add person <code>3</code> to the queue.</p>
<p>Turns out we are incorrect. Person <code>1</code> was informed of the secret at time <code>t = 2</code>, because of meeting <code>[2, 1, 2]</code>. Hence, <code>1</code> can inform the secret to person <code>3</code> at time <code>t = 3</code>.</p>
<p>We are arriving at an incorrect answer because of the incorrect assumption that we will not revisit a node. Hence, we need to revisit a node if we realize that the earliest time at which a person learns the secret decreases.</p>
<blockquote>
<p><strong>Connecting the Dots:</strong> <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> is used for finding shortest path in a graph. It works when the weights of edges are non-negative.</p>
<p>However, we can modify the algorithm to work for graphs where the weights of edges can be negative, but no negative cycle is present. The above algorithm captures the essence of the <strong>modified Dijkstra's algorithm</strong>. The key idea is to revisit a node if we realize that the shortest distance to a node decreases.</p>
<p>However, readers must note that this problem, ideally <strong>cannot</strong> be modeled as the shortest path problem, particularly because meeting time is not the weight of edges. What we have done is to use the idea of modified Dijkstra's algorithm to solve the problem.</p>
</blockquote>
<p>Readers should also note that since the initial queue contains more than one element, the process is often called <strong>Multi-Source BFS</strong></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing <code>q</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are dequeuing one element from <code>q</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the dequeued element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and enqueuing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>q</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In <a href="#approach-1-breadth-first-search">previous approach</a>, we were essentially traversing the graph, keeping in mind the condition that we can visit a node only if we are confident that the person will know the secret at the time of the meeting. After traversal, we were returning indices of all the people who were visited.</p>
<p>The graph can be traversed primarily in two ways:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Queue</a></li>
<li><a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a> using <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/">Stack</a></li>
</ul>
<p>In this approach, let's try to solve the problem using Depth First Search. It can be implemented using Recursion or Stack. It is worth noting that Recursion implicitly uses Call Stack.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create an <code>earliest</code> array of size <code>n</code>. It will store the earliest time at which a person learned the secret as per the current state of knowledge. It will be initialized with <code>INT.MAX</code> for all the people indicating that no one knows the secret.</p>
<p>However, for person <code>0</code> and <code>firstPerson</code>, we will update the <code>earliest</code> array with <code>0</code> since they know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a stack <code>stack</code> to store the people whom we need to process. It will store <code>(person, time of knowing the secret)</code>.</p>
<p>Initially, we will add <code>(0, 0)</code> and <code>(firstPerson, 0)</code> to the stack since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Do the following while the <code>stack</code> is not empty:</p>
<ul>
<li>
<p>Pop the top of <code>stack</code> and store it in <code>(person, time)</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>earliest[nextPerson] &gt; t</code>, then update <code>earliest[nextPerson] = t</code> and add <code>(nextPerson, t)</code> to the stack.</p>
<blockquote>
<p>We are adding <code>(nextPerson, t)</code> to the stack because we have updated <code>earliest[nextPerson]</code> and we need to process all the people whom <code>nextPerson</code> meets after time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>earliest[nextPerson] &gt; t</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>earliest[nextPerson] &lt;= t</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>earliest</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>earliest[i] != INT.MAX</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ctKAU7Bo/shared">code</a></p>
<p><strong>Implementation Note:</strong> The above implementation is slightly different from the standard <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth First Search</a>. In standard Depth First Search, we never process a node twice, and we facilitate this by maintaining a separate <code>visited</code> array.</p>
<p>However, in the above implementation, we may process a node again if we get to know that the earliest time at which a person learns the secret decreases. To facilitate this, we are maintaining the <code>earliest</code> array. We are doing this for the same reason mentioned in <a href="#implementation">previous approach</a>.</p>
<p>Here is the implementation using Recursion.</p>
<p><a href="https://leetcode.com/playground/8yJEFXxD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \cdot (M + N) )\)</span></p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>earliest</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>stack</code>. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(1 + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was pushed because of meeting with some other person. Hence, there will be at most <span class="math inline">\(M + N\)</span> iterations of the <code>while</code> loop.</p>
<p>Thus, the <code>while</code> loop takes <span class="math inline">\(O( (M + N) \cdot M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>earliest</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M + N + (M + N) \cdot M + N)\)</span>, which is <span class="math inline">\(O( M \cdot (M + N) )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>earliest</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>stack</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the stack. It is worth noting that there can be multiple instances of person <code>x</code> in the stack, with multiple times of knowing the secret.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-earliest-informed-first-traversal">Approach 3: Earliest Informed First Traversal</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's revisit the <a href="#approach-1-breadth-first-search">Approach 1</a>, and particularly the test case discussed in <a href="#implementation">Implementation Note</a>.</p>
<pre><code class="language-testcase">4
[[0,1,4],[1,3,3],[2,1,2]]
2
</code></pre>
<p>If we process each node exactly once, then we will arrive at the incorrect answer. The reason was that person <code>1</code> could know the secret through two different meetings.<br />
<strong>(a)</strong> <code>[0, 1, 4]</code>, from person <code>0</code> at time <code>t = 4</code><br />
<strong>(b)</strong> <code>[2, 1, 2]</code>, from person <code>2</code> at time <code>t = 2</code></p>
<p>If we process the meeting <strong>(a)</strong> before meeting <strong>(b)</strong>, then we will arrive at the incorrect answer.</p>
<p>What if we process the meeting <strong>(b)</strong> before meeting <strong>(a)</strong>? Will we arrive at the correct answer?<br />
Yes, we will, at least for this test case.</p>
<p>In general, we must process that person in the queue whose time of knowing the secret is the minimum. We will dequeue the person with the minimum time of knowing the secret. Moreover, <strong>the person should be marked as visited after it is dequeued from the queue (and not when it is enqueued) because the time the person is enqueued might not be the earliest time the person learned the secret, but the time the person is dequeued will be the earliest time a person learned the secret</strong>. This way, we are ensuring that given a person, if he/she learned the secret through multiple meetings, then we will process the earliest meeting first.</p>
<p>For efficiently dequeuing the person with the minimum time of knowing the secret, we may use <a href="https://leetcode.com/explore/learn/card/heap/">Binary Heap</a> with Min Heap property.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/heap/"><strong>Binary Heap</strong></a> is a specialized binary tree-based data structure that is a complete tree that satisfies the heap property.</p>
<p>In a Min-Heap, the key at the root must be minimum among all keys present in the Binary Heap. The same property must be recursively true for all nodes in the Binary Tree. We can pop and push elements in time proportional to the logarithm of the number of elements present in the heap.</p>
</blockquote>
<blockquote>
<p>The approach is similar to <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's algorithm</a> with a notable difference that the weight of edges represents absolute time and not the time difference.</p>
</blockquote>
<p>Readers are encouraged to implement this approach.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create a <code>graph</code> to store the information about <code>meetings</code>. For every person, we store the meeting time and label of the person met.</p>
<p>We can use HashMap to store the information. The key of HashMap will be person, and the value will be a list of <code>(time, person)</code> pairs.</p>
</li>
<li>
<p>Create a priority queue (min-heap) <code>pq</code> to store the people whom we need to process. It will store <code>(time of knowing the secret, person)</code>.</p>
<p>The <code>time of knowing the secret</code> will be used to maintain the Min Heap property. The person with minimum <code>time of knowing the secret</code> will be at the top of the heap.</p>
</li>
<li>
<p>Push <code>(0, 0)</code> and <code>(0, firstPerson)</code> to the queue since both of them know the secret at time <code>t = 0</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> array of size <code>n</code>. It will store if a person is visited or not. Initially, all the people are not visited.</p>
<p>We will mark a person as visited after it is popped from the queue. This will be the earliest time at which a person learns the secret because we are processing the person with the minimum time of knowing the secret.</p>
</li>
<li>
<p>Do the following while the <code>pq</code> is not empty:</p>
<ol>
<li>
<p>Deque the front of <code>pq</code> and store it in <code>(time, person)</code>.</p>
</li>
<li>
<p>If <code>visited[person]</code> is <code>True</code>, then continue to the next iteration of the <code>while</code> loop. We have already processed <code>person</code> at an earlier time, and we don't need to process it again.</p>
</li>
<li>
<p>Mark <code>visited[person]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over neighbors of <code>person</code> using the <code>for</code> loop. Let's say the neighbor is <code>(t, nextPerson)</code>.</p>
<p>If <code>t &gt;= time</code> and <code>visited[nextPerson]</code> is <code>False</code>, then push <code>(t, nextPerson)</code> to the queue.</p>
<blockquote>
<p>We are checking <code>t &gt;= time</code> because the <code>nextPerson</code> can know the secret only if he/she meets <code>person</code> after the <code>time</code> at which <code>person</code> learned the secret.</p>
</blockquote>
<blockquote>
<p>We are checking <code>visited[nextPerson]</code> because we are interested in the earliest time at which <code>nextPerson</code> learned the secret. If <code>visited[nextPerson]</code> is <code>True</code>, then we have already processed <code>nextPerson</code> at an earlier time, and we don't need to process it again.</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Iterate over the <code>visited</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>visited[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/W6xzxQjv/shared">code</a></p>
<p><strong>Implementation Note:</strong> In <code>for</code> loop under <code>while</code>, we are checking every <code>(t, nextPerson)</code> pair of <code>graph[person]</code> to find all those <code>t &gt;= time</code>, where <code>time</code> is earliest time person learned the secret.</p>
<p>However, if <code>graph[person]</code> was sorted in increasing order of <code>t</code>, then instead of starting from the very beginning of <code>graph[person]</code>, we can start from the index where <code>t &gt;= time</code>. This index can be found using <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a> because <code>graph[person]</code> is sorted. This will reduce the number of iterations of the <code>for</code> loop. Readers are encouraged to implement this optimization and comment on their implementation.</p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
<ul>
<li>
<p>Initially, we are creating a <code>graph</code> by processing <code>meetings</code>. This will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we are initializing min-heap <code>pq</code> by enqueuing two people. It will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>visited</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Now there is a <code>while</code> loop.</p>
<ul>
<li>
<p>In each iteration, we are popping one element from <code>pq</code>. It will take <span class="math inline">\(O(\log (N + M))\)</span> time because, at any instance, there can be at most <span class="math inline">\(N + M\)</span> elements in the heap.</p>
</li>
<li>
<p>Then we iterate over neighbors of the popped element using the <code>for</code> loop. There will be at most <span class="math inline">\(M\)</span> neighbors because a person can meet at most <span class="math inline">\(M\)</span> people. In each iteration of the <code>for</code> loop, we are doing some constant time operations of checking conditions and pushing.</p>
<p>Hence, the time complexity of the <code>for</code> loop will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<p>Thus, each iteration of the <code>while</code> loop will take <span class="math inline">\(O(\log (N + M) + M)\)</span>, which is <span class="math inline">\(O(M)\)</span> time.</p>
<p><strong>How many times <code>while</code> loop will run?</strong><br />
In each iteration, one person is processed. The person was enqueued because of meeting with some other person. Hence, there will be at most <span class="math inline">\(N + M\)</span> iterations of the <code>while</code> loop.</p>
<p>However, we will process the <code>for</code> loop only for those neighbors of a person who has not been visited. Hence, the <code>for</code> loop of time complexity <span class="math inline">\(O(M)\)</span> will run for at most <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop.</p>
<ul>
<li>
<p>Thus, for <span class="math inline">\(N\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M) + M )\)</span> time.</p>
</li>
<li>
<p>For <span class="math inline">\(M\)</span> iterations of the <code>while</code> loop, it will take <span class="math inline">\(O( \log (N + M))\)</span> time. The <code>for</code> loop will not run for these iterations.</p>
</li>
</ul>
<p>Thus, <code>while</code> loop takes <span class="math inline">\(O( N \cdot ( \log (N + M) + M )  + M \cdot \log (N + M) )\)</span> time, which is <span class="math inline">\(O( N \cdot \log (N + M) + N \cdot M + \log (N + M) \cdot M )\)</span> time. This can be rearranged as <span class="math inline">\(O(  (N + M) \log (N + M) + N M )\)</span> time.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>visited</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, total time complexity will be <span class="math inline">\(O(M + 1 + N + (N + M) \log (N + M) + N M + N)\)</span>, which is <span class="math inline">\(O( (N + M) \log (N + M) + N M )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>pq</code> may grow upto <span class="math inline">\(O(M + N)\)</span>, because at any instance, there can be at most <span class="math inline">\(M + N\)</span> nodes in the queue. It is worth noting that there can be multiple instances of person <code>x</code> in the queue, with multiple times of knowing the secret.</p>
</li>
<li>
<p>The <code>visited</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-breadth-first-search-on-time-scale">Approach 4: Breadth First Search on Time Scale</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let's minutely analyze an arbitrary meeting <code>[x, y, t]</code>:</p>
<ul>
<li>
<p>If any one of <code>x</code> or <code>y</code> were informed the secret <strong>before or at time <code>t</code></strong>, then both <code>x</code> and <code>y</code> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>This will be true for all participants of all transitive meetings happening at time <code>t</code> as well.</p>
</blockquote>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
</li>
<li>
<p>If none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> were informed the secret <strong>before or at time <code>t</code></strong>, then none of <code>x</code> and <code>y</code> <em>(or as a general case, no participant of transitive meeting)</em> will know the secret at time <code>t</code>.</p>
<blockquote>
<p>However, for disjoint meetings happening at the time <code>t</code>, this may or may not be true. To decide on disjoint meetings, we need to separately analyze each disjoint meeting at the time <code>t</code>.</p>
</blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particularly, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at the time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will not affect meeting <code>[x, y, t]</code>.</p>
</li>
</ul>
<p>From minutely analyzing, we can agree on the fact that processing <code>meetings</code> in ascending order of <code>t</code> will be helpful.<br />
<em>We also incorporated this fact in <a href="#approach-3-earliest-informed-first-traversal">previous approach</a></em>.</p>
<p>Moreover, we should consider all meetings happening at the same time <code>t</code> together.</p>
<p>Assume at a time <code>t</code>, we have <code>[x, y], [y, z], [z, w], [a, b], [c, d], [d, e]</code> meetings taking place. We can form the following three groups of people meeting each other at the time <code>t</code>.</p>
<ul>
<li><code>[x, y, z, w]</code>: If any one of these four knows the secret, then all of them will get to know the secret.</li>
<li><code>[a, b]</code>: If any one of these two knows the secret, then both of them will get to know the secret.</li>
<li><code>[c, d, e]</code>: If any one of these three knows the secret, then all of them will get to know the secret.</li>
</ul>
<p>Thus at every timestamp <code>t</code>, we can do graph traversal to <strong>find all those people to whom the secret can propagate</strong>. The traversal will be started by people who already know the secret at the time <code>t</code>. We need to do so in increasing order of time <code>t</code>.</p>
<p>For traversal, we can do either BFS or DFS. The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
<p>We, in this approach, will use BFS to find the connectedness of the graph at a particular time and leave DFS as an exercise for readers.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a Boolean Array <code>knowsSecret</code> of size <code>n</code>. It will tell if a person knows the secret or not.</p>
<p>Initially, only person <code>0</code> and <code>firstPerson</code> knows the secret. Hence, mark <code>knowsSecret[0]</code> and <code>knowsSecret[firstPerson]</code> as <code>True</code>.</p>
</li>
<li>
<p>Iterate over <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>For each person, save all the people whom he/she meets at the time <code>t</code> in a HashMap <code>meet</code>. The key of HashMap will be person, and value will be a list of people whom he/she meets at the time <code>t</code>.</p>
</li>
<li>
<p>Create a set <code>q</code>. Add to <code>q</code> those people who have some meeting scheduled at time <code>t</code>, and who already know the secret at time <code>t</code>.</p>
<blockquote>
<p>We are using <code>set</code> to avoid redundancy. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
</blockquote>
</li>
<li>
<p>Convert set <code>q</code> to queue <code>q</code> to do BFS.</p>
</li>
<li>
<p>While <code>q</code> is not empty, do the following:</p>
<ul>
<li>
<p>Dequeue the front of <code>q</code> and store it in <code>person</code>.</p>
</li>
<li>
<p>Iterate over all those persons whom <code>person</code> meets at the time <code>t</code>. Let's say the person is <code>nextPerson</code>.</p>
<p>If <code>knowsSecret[nextPerson]</code> is <code>False</code>, then mark <code>knowsSecret[nextPerson]</code> as <code>True</code> and enqueue <code>nextPerson</code> to <code>q</code>.</p>
<p>This is because after meeting <code>person</code> at a time <code>t</code>, <code>nextPerson</code> will know the secret at the time <code>t</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate over the <code>knowsSecret</code> array and return indices of all the people who know the secret. They are identified by the fact that <code>knowsSecret[i]</code> is <code>True</code>.</p>
</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/FGJS7GCK/shared">code</a></p>
<p><strong>Implementation Note:</strong> For every <code>t</code>, the initial queue is created using <code>set</code> to avoid redundancy. We are populating the initial queue using meetings. A person can be in multiple meetings, so to avoid adding the same person multiple times, we are using <code>set</code>.</p>
<p>Afterward, the queue is populated only when the person doesn't know the secret, and as soon as we populate, we mark the person as known. Hence, there won't be redundancy in the queue.</p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N )\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Then we initialize the <code>knowsSecret</code> array of size <span class="math inline">\(N\)</span>. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Then there is a <code>for</code> loop. The number of iterations of the <code>for</code> loop depends on the number of unique meeting times. It will be at most <span class="math inline">\(M\)</span>. Let's narrow our analysis to one iteration of the <code>for</code> loop.</p>
<ul>
<li>
<p>Creating <code>meet</code> and initiating <code>q</code> may vary from <span class="math inline">\(O(1)\)</span> time to <span class="math inline">\(O(M)\)</span> time, depending on the number of meetings happening at the time <code>t</code>. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<p>(<strong>Amortized time complexity</strong> is the time taken per operation averaged over all operations)</p>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time (when a single meeting is happening at the time <code>t</code>), then there may be the next iteration of the <code>for</code> loop. However, it will be limited to <span class="math inline">\(M\)</span> iterations.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If one iteration of creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, then there will be no next iteration of the <code>for</code> loop because all meetings happening will get processed in the current iteration.</li>
</ul>
</blockquote>
<blockquote>
<p>Hence, when creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(1)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(M)\)</span>. When creating <code>meet</code> and initiating <code>q</code> takes <span class="math inline">\(O(M)\)</span> time, the number of <code>for</code> loop iterations will be <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<p>Thus, the amortized time complexity for creating <code>meet</code> and initiating <code>q</code> per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span></p>
</li>
<li>
<p>The BFS may take <span class="math inline">\(O(N)\)</span> time in the worst case because, at any instance, there can be at most <span class="math inline">\(N\)</span> nodes in the queue. However, the amortized time complexity will be <span class="math inline">\(O(1)\)</span>.</p>
<blockquote>
<ul>
<li>If every meeting time has only <span class="math inline">\(2\)</span> participants, then there will be <span class="math inline">\(O(M)\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(2)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(2 \cdot M)\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>If every meeting time has <span class="math inline">\(N\)</span> participants, then there will be <span class="math inline">\(O(\frac{M}{N})\)</span> unique meeting times deciding the number of iterations of the <code>for</code> loop. In each iteration of the <code>for</code> loop, there will be <span class="math inline">\(O(N)\)</span> people in the queue. Hence, the time complexity will be <span class="math inline">\(O(N \cdot \frac{M}{N})\)</span> which is <span class="math inline">\(O(M)\)</span>.</li>
</ul>
</blockquote>
<p>Thus, the amortized time complexity of BFS per iteration of the <code>for</code> loop will be <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Thus, each iteration of the <code>for</code> loop will take amortized <span class="math inline">\(O(1)\)</span> time for creating <code>meet</code>, initiating <code>q</code>, and BFS.</p>
</li>
</ul>
</li>
<li>
<p>Finally, we are iterating over the <code>knowsSecret</code> array to find indices of people who know the secret. It will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M \cdot 1 + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>knowsSecret</code> array will take <span class="math inline">\(O(N)\)</span> space.</p>
</li>
<li>
<p>The <code>meet</code> HashMap will take <span class="math inline">\(O(M)\)</span> space per iteration of <code>for</code> loop. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>The <code>q</code> may grow up to <span class="math inline">\(O(N)\)</span> per iteration of the <code>for</code> loop because any person can be in the queue at most once. After iteration, it will be empty. Hence, the total space complexity will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-union-find-with-reset">Approach 5: Union-Find with Reset</h3>
<h4 id="intuition-4">Intuition</h4>
<p>In the <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>The purpose of traversal is to find the connectedness of the graph at a particular time.</p>
</blockquote>
<p>We initiated traversal from people who already knew the secret at the time <code>t</code>.</p>
<p>Instead of doing traversal, we can use <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union-Find</a> to find the connectedness of the graph at a particular time. For each person taking part in a meeting, we can union the person with the other person taking part in the meeting, and check if they are connected to any person who already knows the secret, one such person being <code>0</code>.</p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find</strong></a>, also known as <strong>Disjoint Set</strong>, is a data structure that keeps track of elements that are split into one or more disjoint sets. It provides near-constant-time operations to add new sets, merge existing sets, and determine whether elements are in the same set.</p>
<p>If readers are not familiar with Union-Find, then they are encouraged to visit <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/"><strong>Union-Find Explore Card</strong></a> to learn about it. It includes the heuristics to optimize the Union-Find data structure.</p>
<ul>
<li><em>union by rank</em> (height) or <em>union by size</em>. We can use either of these.</li>
<li><em>path compression</em></li>
</ul>
<p>We, in this approach, will use <strong>Union by Rank</strong> and <strong>Path Compression</strong> heuristics to optimize the Union-Find data structure.</p>
</blockquote>
<p>Thus, in this approach, we will process meetings in increasing order of time <code>t</code>, and for each meeting <code>[x, y]</code>, we will unite the two persons.</p>
<p>After performing all the unions, we will again visit all <code>[x, y]</code>, and check if any one of them is connected to <code>0</code> or not <em>(if any of them is connected to <code>0</code>, then both of them will be connected to <code>0</code> because we united them)</em>. If yes, then both of them will end up knowing the secret.</p>
<p>At the end, we will return indices of all the people who know the secret.</p>
<p>Is that enough? Let's try to find out through an example.</p>
<pre><code class="language-testcase">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>The <code>meetings</code> are already sorted in increasing order of <code>t</code>. Initially, our graph looks like the following. <code>1</code> is connected to <code>0</code>, because <code>1</code> is the <code>firstPerson</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_1.PNG" alt="t0" /></p>
<p>After meeting <code>[2, 3, 1]</code>, one more connection is added to the graph. However, both of them are not connected to <code>0</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_2.PNG" alt="t1" /></p>
<p>Let's process the next meeting <code>[1, 2, 2]</code>. After this meeting, <code>2</code> will get connected to <code>0</code>, because <code>1</code> is already connected to <code>0</code>. Thus, <code>2</code> will know the secret.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_3.PNG" alt="t2" /></p>
<p>The third meeting <code>[3, 4, 3]</code> will add a connection between <code>3</code> and <code>4</code>.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_4.PNG" alt="t3" /></p>
<p>Now <code>3</code> was already connected to <code>0</code>, but <code>3</code> doesn't know the secret yet. However, it got connected to <code>0</code> because <code>2</code> got connected to <code>0</code> after the second meeting, and <code>3</code> had met <code>2</code> in the first meeting. However, this is incorrect. <code>3</code> technically doesn't know the secret yet.</p>
<p>Hence, it seems connection with <code>0</code> is not enough. We may need to maintain a flag array <code>knowsSecret</code> to mark if a person knows the secret or not, which is indicated by the green color in the above figures.</p>
<p>Let's process further to see if it will work or not!</p>
<p>We have two meetings taking place at time <code>t = 4</code>. Their union is represented by red color in the following figure.</p>
<p><img src="../Figures/2092/2092_slide_images_used/Slide6_5.PNG" alt="t4" /></p>
<p>Now, we will revisit every meeting at time <code>t = 4</code> again. The first one being <code>[5, 4, 4]</code>. Both of them are connected to <code>0</code>, but none of them knows the secret. Hence, we will not mark them as known. However, this is incorrect. Ideally, both of them should know the secret.</p>
<p>If we had visited <code>[5, 0, 4]</code> first, then we would have marked <code>5</code> as known, and then we would have visited <code>[5, 4, 4]</code>, and marked <code>4</code> as known.</p>
<p>However, given the fixed time, we don't have devised any strategy to visit meetings in a particular order.</p>
<p>We can overcome this by doing two passes after uniting, at least for this test case. However, to guarantee it to work every time, we must do as many passes as the number of meetings at that fixed time. This isn't efficient!</p>
<p>Thus, introducing the <code>knowsSecret</code> flag array doesn't seem to lead to an efficient solution.</p>
<p><strong>We need to proceed only with the fact that if a person is connected to <code>0</code>, then he/she knows the secret.</strong></p>
<p>In <a href="#intuition-3">intuition of the previous approach</a>, we noted the following.</p>
<blockquote>
<p>Let's assume that one participant of a transitive meeting gets to know the secret <strong>after time <code>t</code></strong>. It is worth noting that knowing after time <code>t</code> will not affect meetings happening at the time <code>t</code>.</p>
<p>More particulary, if none of <code>x</code> and <code>y</code> knew the secret <strong>before or at time <code>t</code></strong>, and assume one of them gets to know the secret <strong>after time <code>t</code></strong>, then it will have no effect on meeting <code>[x, y, t]</code>.</p>
</blockquote>
<p>Let's focus more on the last sentence of the above quote. If none of them knew the secret, then meeting <code>[x, y, t]</code> will not have any effect on them. To trigger the effect of the meeting, we united <code>x</code> and <code>y</code> using the Union-Find data structure.</p>
<p><strong>What to do to dissolve the effect?</strong><br />
Well, we can do the opposite of uniting them. We can disunite <code>x</code> and <code>y</code> into single components.</p>
<p>Since even after doing all the unions, they weren't able to receive the secret, all the meetings happening at or before the time <code>t</code> were not able to propagate the secret to them. Hence, we can safely disunite them.</p>
<p>Now to disunite them into single components, we just need to reset the initial properties of Union-Find. We need to do this only for these two persons.</p>
<p>After processing all the <code>meetings</code>, all those persons who are connected to <code>0</code> will know the secret.</p>
<p>Here is the animation explaining the approach for the following input.</p>
<pre><code class="language-input">6
[[2, 3, 1], [1, 2, 2], [3, 4, 3], [5, 4, 4], [5, 0, 4]]
1
</code></pre>
<p>!?!../Documents/2092/2092_slideshow_union_find.json:960,540!?!<br />
<br/></p>
<p>It is worth noting that we don't need a separate flag array <code>knowsSecret</code>. Connection with <code>0</code> is enough to conclude that a person knows the secret. That's why the above animation doesn't highlight with green color.</p>
<p>With this intuition, let's discuss the implementable algorithm.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>
<p>Define a class <code>UnionFind</code> to implement the Union-Find data structure.</p>
<p>The <strong>constructor</strong> of <code>UnionFind</code> will take <code>n</code> as input, and initialize <code>parent</code> and <code>rank</code> arrays of size <code>n</code>. The <code>parent</code> array will store the parent of each node, and the <code>rank</code> array will store the rank of each node.</p>
<p>Initially, every node is the parent of itself, and the rank of every node is <code>0</code>.</p>
<p>It will have the following <strong>methods</strong>:</p>
<ul>
<li>
<p><code>find(x)</code>: Find the parent of node <code>x</code>. It will use the <em>Path Compression</em> heuristic.</p>
</li>
<li>
<p><code>unite(x, y)</code>: Unite two nodes <code>x</code> and <code>y</code>. It will use the <em>Union by Rank</em> heuristic.</p>
</li>
<li>
<p><code>connected(x, y)</code>: Check if two nodes <code>x</code> and <code>y</code> are connected or not.</p>
</li>
<li>
<p><code>reset(x)</code>: Reset the initial properties of node <code>x</code>. It will set the parent of node <code>x</code> to <code>x</code>, and the rank of node <code>x</code> to <code>0</code>.</p>
</li>
</ul>
</li>
<li>
<p>Sort <code>meetings</code> in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a HashMap <code>sameTimeMeetings</code> for grouping meetings happening at the same time <code>t</code>. The key of HashMap will be time <code>t</code>, and the value will be a list of <code>(x, y)</code> pairs.</p>
<p>Make sure that <code>sameTimeMeetings</code> remembers the order of insertion, since we are inserting meetings in increasing order of <code>t</code>.</p>
</li>
<li>
<p>Create a <code>graph</code>. It will be an instance of the <code>UnionFind</code> class and will have <code>n</code> nodes.</p>
</li>
<li>
<p>Unite <code>firstPerson</code> with <code>0</code> in <code>graph</code>.</p>
</li>
<li>
<p>Process <code>sameTimeMeetings</code> in increasing order of <code>t</code>. Let's say <code>t</code> is the time.</p>
<ul>
<li>
<p>Unite all two persons taking part in a meeting.</p>
</li>
<li>
<p>If any one of them is connected to <code>0</code>, then both of them will be connected to <code>0</code>.</p>
<p>Similarly, if any one of them is NOT connected to <code>0</code>, then both of them will be NOT connected to <code>0</code>, since they were united among themselves. In this case, we need to reset them.</p>
</li>
</ul>
</li>
<li>
<p>Return indices of all those people who are connected to <code>0</code> in the <code>graph</code>.</p>
</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/b4ZMoceH/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Before analyzing the time complexity, let's first understand the time complexity of Union-Find. If an instance of Union-Find is created with <span class="math inline">\(\text{nodes}\)</span>, then the following are the time complexities of Union-Find methods:</p>
<blockquote>
<ul>
<li><strong>Constructor</strong>: <span class="math inline">\(O(\text{nodes})\)</span>, because we are initializing <code>parent</code> and <code>rank</code> arrays of size <span class="math inline">\(\text{nodes}\)</span>. However, the constructor is called only once.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>find(x)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>unite(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>connected(x, y)</code>: It is amortized <span class="math inline">\(O(1)\)</span> time, because we are using <em>Path Compression</em> and <em>Union by Rank</em> heuristics.</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>In actuality, the time complexity of the above three methods after using <em>Path Compression</em> and <em>Union by Rank</em> heuristics is <span class="math inline">\(O\left( \boldsymbol{\alpha}(\text{nodes}) \right)\)</span> time, where <span class="math inline">\(\boldsymbol{\alpha}\)</span> is <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse Ackermann Function</a>. However, <span class="math inline">\(\boldsymbol{\alpha}(\text{nodes})\)</span> is less than <span class="math inline">\(5\)</span> for all practical purposes. More <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3843/">here</a></p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><code>reset(x)</code>: It is <span class="math inline">\(O(1)\)</span> time because we are just resetting the initial properties of node <code>x</code>.</li>
</ul>
</blockquote>
<p>For analyzing the time complexity of our algorithm, let <span class="math inline">\(N\)</span> be the number of people, and <span class="math inline">\(M\)</span> be the number of meetings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O( M \log M + N)\)</span></p>
<ul>
<li>
<p>Sorting <code>meetings</code> will take <span class="math inline">\(O(M \log M)\)</span> time. This may vary depending on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and takes <span class="math inline">\(O(M \log M)\)</span> time in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a time complexity of <span class="math inline">\(O(M \log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Populating <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> time.</p>
</li>
<li>
<p>Creating <code>graph</code> will take <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Uniting <code>firstPerson</code> with <code>0</code> will take <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Upon looking at the <code>for</code> loop, we can observe that we will process each meeting exactly twice, once for uniting, and once while checking if any one of them is connected to <code>0</code> or not.</p>
<ul>
<li>
<p>For uniting, it will be amortized <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>For checking if any one of them is connected to <code>0</code> or not, it will be amortized <span class="math inline">\(O(1)\)</span> time. Resetting, if required, will be <span class="math inline">\(O(1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity of the <code>for</code> loop will be <span class="math inline">\(O(2 \cdot M \cdot 1)\)</span>, which is <span class="math inline">\(O(M)\)</span>.</p>
</li>
<li>
<p>Finally, we are iterating over the <code>graph</code> to find indices that are connected to <code>0</code>. It will take <span class="math inline">\(O(N \cdot 1)\)</span> time.</p>
</li>
</ul>
<p>Hence, the total time complexity will be <span class="math inline">\(O(M \log M + M + N + M + N)\)</span>, which is <span class="math inline">\(O( M \log M + N )\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<ul>
<li>
<p>We are sorting the <code>meetings</code> array in place. When we sort an array in place, some extra space is used. The space complexity depends on the implementation of the sorting algorithm in the programming language.</p>
<ul>
<li>
<p>In Python3, the <code>sort</code> method sorts a list using the Timsort algorithm, which is a combination of Merge Sort and Insertion Sort and uses <span class="math inline">\(O(M)\)</span> space in the worst case.</p>
</li>
<li>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with worst-case space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
<li>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log M)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>The <code>sameTimeMeetings</code> will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
<li>
<p>The <code>graph</code> will take <span class="math inline">\(O(N)\)</span> space for <code>parent</code> and <code>rank</code> arrays.</p>
</li>
</ul>
<p>Hence, total space complexity will be <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<p>As a challenge, try to implement the <a href="#implementation-4">Union-Find approach</a> <em>without</em> using the <code>sameTimeMeetings</code> HashMap! We perhaps may need some iterators to process all the meetings happening at the same time. Readers can comment their code below.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description" target="_blank" rel="noopener noreferrer">Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">sorting</span> <span class="topic-badge">strongly-connected-component</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a weighted undirected connected graph with <code>n</code>&nbsp;vertices numbered from <code>0</code> to <code>n - 1</code>,&nbsp;and an array <code>edges</code>&nbsp;where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional and weighted edge between nodes&nbsp;<code>a<sub>i</sub></code>&nbsp;and <code>b<sub>i</sub></code>. A minimum spanning tree (MST) is a subset of the graph&#39;s edges that connects all vertices without cycles&nbsp;and with the minimum possible total edge weight.</p>

<p>Find <em>all the critical and pseudo-critical edges in the given graph&#39;s minimum spanning tree (MST)</em>. An MST edge whose deletion from the graph would cause the MST weight to increase is called a&nbsp;<em>critical edge</em>. On&nbsp;the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.</p>

<p>Note that you can return the indices of the edges in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/ex1.png" style="width: 259px; height: 262px;" /></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
<strong>Output:</strong> [[0,1],[2,3,4,5]]
<strong>Explanation:</strong> The figure above describes the graph.
The following figure shows all the possible MSTs:
<img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/msts.png" style="width: 540px; height: 553px;" />
Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/04/ex2.png" style="width: 247px; height: 253px;" /></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
<strong>Output:</strong> [[],[0,1,2,3]]
<strong>Explanation:</strong> We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>
	<li>All pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-if-path-exists-in-graph/description" target="_blank" rel="noopener noreferrer">Find if Path Exists in Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>bi-directional</strong> graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>). The edges in the graph are represented as a 2D integer array <code>edges</code>, where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a bi-directional edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by <strong>at most one</strong> edge, and no vertex has an edge to itself.</p>

<p>You want to determine if there is a <strong>valid path</strong> that exists from vertex <code>source</code> to vertex <code>destination</code>.</p>

<p>Given <code>edges</code> and the integers <code>n</code>, <code>source</code>, and <code>destination</code>, return <code>true</code><em> if there is a <strong>valid path</strong> from </em><code>source</code><em> to </em><code>destination</code><em>, or </em><code>false</code><em> otherwise</em><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png" style="width: 141px; height: 121px;" />
<pre>
<strong>Input:</strong> n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> There are two paths from vertex 0 to vertex 2:
- 0 &rarr; 1 &rarr; 2
- 0 &rarr; 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png" style="width: 281px; height: 141px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no path from vertex 0 to vertex 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>
	<li>There are no duplicate edges.</li>
	<li>There are no self edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-number-of-closed-islands/1" target="_blank" rel="noopener noreferrer">Find number of closed islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <a href="https://www.geeksforgeeks.org/program-to-check-if-a-matrix-is-binary-matrix-or-not/">binary matrix</a> <strong>mat[][]</strong> of dimensions <strong>NxM</strong> such that 1 denotes land and <strong>0</strong> denotes water. Find the number of closed islands in the given matrix.<br />An island is a 4-directional(up,right,down and left) connected part of 1's.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> A closed island is a group of <strong>1s</strong> surrounded by only <strong>0s</strong> on all the boundaries <strong>(except diagonals)</strong>. In simple words, a closed island is an island whose none of the <strong>1s</strong> lie on the edges of the matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 5, M = 8
mat[][] =</span> <span style="font-size: 18px;">{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 0, 1},&nbsp;
           {0, 1, 0, 1, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 1, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output:</strong>
2
<strong>Explanation</strong>:
</span><span style="font-size: 18px;">mat[][] =&nbsp;{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, 0, 1},&nbsp;
           {0, <strong>1</strong>, 0, <strong>1</strong>, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, <strong>1</strong>, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}&nbsp;
There are 2 closed islands. The islands in dark are closed because they are completely surrounded by 0s (water). There are two more islands in the last column of the matrix, but they are not completely surrounded by 0s. Hence they are not closed islands. </span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 3, M = 3
mat[][] = {{1, 0, 0},
           {0, 1, 0},
           {0, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output: <br /></strong></span><span style="font-size: 18px;">1<strong><br />Explanation:<br /></strong>mat[][] = {{1, 0, 0},<br />          {0, <strong>1</strong>, 0},<br />          {0, 0, 1}}<br />There is just a one closed island.</span></pre>
<p><span style="font-size: 18px;"><strong>Your task:</strong></span><br /><span style="font-size: 18px;">You dont need to read input or print anything. Your task is to complete the function <strong>closedIslands()</strong>&nbsp;which takes two integers N and M, and a 2D binary matrix mat as input parameters and returns the number of closed islands.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N*M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N,M &le; 500<br /><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-safest-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Find the Safest Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example1.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example2.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example3.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> representing a city layout where some cells contain thieves and others are empty, and we need to find the maximum safeness factor of all paths from the top-left corner to the bottom-right corner. The safeness factor of a path is defined as the minimum Manhattan distance from any cell in the path to any thief in the <code>grid</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Manhattan distance between two cells is the sum of the absolute differences of their row and column indices.</li>
<li>All the cells in the <code>grid</code> contain either 0 or 1, representing empty cells and cells containing thieves respectively.</li>
<li>You start from the top-left corner <code>(0, 0)</code> and can move to adjacent cells in any of the four directions.</li>
<li>The maximum level of safety one can achieve while traversing from the starting point to the destination is by ensuring the least proximity to any cell containing a thief.</li>
</ol>
<h3 id="approach-1-breadth-first-search--binary-search">Approach 1: Breadth-First Search + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we need to find the safeness factor of a path from the source to the destination, the initial intuition to solve this problem is that we should first find the safeness factors of the cells in the path. The path can span across the entire <code>grid</code>, so we need to find the safeness factors for all the cells in the <code>grid</code>.</p>
<p>One approach to find the safeness factors of the cells would be to iterate over each cell in the <code>grid</code> and find its distance from all the thieves in the <code>grid</code>. We can then pick the smallest distance as the safeness factor for that cell.</p>
<p>However, this brute force approach would have a time complexity of <span class="math inline">\(O(n^4)\)</span>, which would not satisfy the constraints of the problem. Therefore, a more optimized approach is needed.</p>
<p>To optimize the solution, we can leverage the properties of a multi-source breadth-first Search (BFS). Instead of finding the distance of each cell from all the thieves, we can do the opposite: find the distance of all the thieves from each cell.</p>
<blockquote>
<p>Note: A multi-source breadth-first search is a BFS where multiple starting nodes are explored simultaneously. This is an efficient method to find the shortest distances from any of the starting nodes to all reachable nodes in the graph. You can refer to this excellent <strong><a href="https://leetcode.com/problems/rotting-oranges/">problem</a></strong> to gain some practice on multi-source BFS.</p>
</blockquote>
<p>The intuition for this can be,</p>
<ul>
<li>We start by adding all the thief coordinates to a queue as the initial points of exploration.</li>
<li>We then explore the neighboring cells (up, down, left, and right) from all the thieves in one iteration, like ripples spreading outwards from each thief.</li>
<li>As we visit each cell, we mark it with the minimum distance from the nearest thief. This is because the first time a cell is visited, it means that the current thief is the closest one to that cell.</li>
<li>We continue the BFS traversal until all the cells in the <code>grid</code> are marked with their corresponding safeness values.</li>
</ul>
<p>The following slideshow demonstrates how the BFS gradually populates the <code>grid</code> with its minimum distances from a thief.</p>
<p>!?!../Documents/2812/bfs_slideshow.json:412,291!?!</p>
<p>Now that we have the safeness factor of each cell, we need to find the maximum safeness factor for which a path exists from the source cell to the destination cell. This implies that for all safeness values greater than it, no path exists, and at least one path exists for all values less than it. We can visualize these safeness factors as a monotonic sequence on a number line. The values that satisfy the constraints of the problem will be a contiguous series. These will be followed by a series of values that do not satisfy the constraints. We will name this breakpoint the inflection point.</p>
<p>The following slideshow visualizes how we iteratively converge to the location of the inflection point using binary search.</p>
<p>!?!../Documents/2812/bs_slideshow.json:482,160!?!</p>
<p>During the binary search, to determine if a safeness value meets the problem constraints, we employ another breadth-first search (BFS) traversal on the <code>grid</code>. The traversal attempts to find a path where every cell in the path satisfies this minimum safeness value. If such a path is found, it indicates that the given safeness value is a valid solution to the problem.</p>
<p>Thus, to find the maximum safeness factor, we can use binary search to efficiently locate the inflection point in this monotonic sequence. The last &quot;True&quot; value at the inflection point will be the maximum safeness factor for which a path exists.</p>
<p>In summary, the final solution involves two key steps:</p>
<ol>
<li>Perform a breadth-first search to compute the safeness factor for each cell, leveraging the fact that the first time a cell is visited, it represents the minimum distance from the nearest thief.</li>
<li>Apply binary search to find the maximum safeness factor for which a path exists from the source to the destination cell.</li>
</ol>
<p>This approach is more efficient than the initial brute-force solution, as it avoids the need to calculate the distance of each cell from all the thieves. Instead, it focuses on finding the distance of each cell from all the thieves, which can be done more optimally manner using BFS.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
<li>Define <code>isValidSafeness</code> method to check if a path exists with a minimum safeness value.</li>
</ul>
<h5 id="isvalidcell-method"><code>isValidCell</code> Method</h5>
<ol>
<li>Take the <code>grid</code>, row <code>i</code>, and column <code>j</code> as input.</li>
<li>Get the size of the <code>grid</code>, denoted by <code>n</code>.</li>
<li>Check if the cell at (<code>i</code>, <code>j</code>) is within the <code>grid</code> boundaries.</li>
<li>Return <code>true</code> if the cell is valid, <code>false</code> otherwise.</li>
</ol>
<h5 id="isvalidsafeness-method"><code>isValidSafeness</code> Method</h5>
<ol>
<li>
<p>Take the <code>grid</code> and the minimum safeness value as input.</p>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
<li><code>visited</code> as a 2-D array to mark visited cells.</li>
</ul>
</li>
<li>
<p>Check if the source and destination cells satisfy the minimum safeness.</p>
</li>
<li>
<p>Perform a breadth-first search (BFS) to find a valid path:</p>
<ul>
<li>Initialize a queue <code>q</code> to contain the coordinates.</li>
<li>Add the source cell (<code>0</code>, <code>0</code>) to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells in all directions:
<ul>
<li>If the neighboring cell is valid, unvisited and has a safeness value greater than or equal to the minimum safeness value:
<ul>
<li>Mark the cell as visited and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If a valid path is found, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no valid path is found.</p>
</li>
</ol>
<h5 id="signature-function-maximumsafenessfactor">Signature function <code>maximumSafenessFactor</code></h5>
<ol>
<li>
<p>Initialize a queue <code>q</code> to store the positions of thieves.</p>
</li>
<li>
<p>Mark thieves as <code>0</code> and empty cells as <code>-1</code>, and push thieves to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform a binary search for the maximum safeness factor:</p>
<ul>
<li>Initialize <code>start</code> and <code>end</code> variables.</li>
<li>Initialize <code>res</code> to store the maximum safeness value.</li>
<li>Loop through the <code>grid</code> to find the maximum safeness factor and assign it to <code>end</code>.</li>
<li>While <code>start</code> is less than or equal to <code>end</code>:
<ul>
<li>Calculate <code>mid</code>.</li>
<li>Check if a valid safeness exists for <code>mid</code> using <code>isValidSafeness</code> method.</li>
<li>Update <code>res</code> if valid safeness is found.</li>
<li>Update <code>start</code> or <code>end</code> based on the result of <code>isValidSafeness</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum safeness factor <code>res</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3UY5NMSg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The time complexity for the initial BFS is <span class="math inline">\(O(n^2)\)</span>, as each cell in the <span class="math inline">\(n \cdot n\)</span> <code>grid</code> is visited once during the traversal.</p>
<p>The binary search occurs in the range [0, maximum safeness factor possible], where the maximum safeness factor possible is <span class="math inline">\(2 \cdot n\)</span>. The time complexity of the binary search is <span class="math inline">\(O(\log (2 \cdot n))\)</span>, which is equivalent to <span class="math inline">\(O(\log n)\)</span>.</p>
<p>For each iteration of the binary search, a breadth-first Search is conducted to verify validity, which has a time complexity of <span class="math inline">\(O(n^2)\)</span>. Thus, the total time complexity of the binary search portion is <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log n)\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The data structure used in the algorithm is a queue, which takes linear space. Since the total number of cells in the <code>grid</code> is <span class="math inline">\(n^2\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-bfs--greedy">Approach 2: BFS + Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a binary search strategy to find the maximum safeness factor for which a path exists from the source to the destination. While this was an efficient solution, the intuition behind this approach is to directly find the optimal path from the source to the destination by leveraging Dijkstra's algorithm.</p>
<p>Similar to the previous approach, we first need to populate the <code>grid</code> with the safeness values for each cell. The algorithm to achieve this is the same as before, using the breadth-first Search (BFS) technique to compute the distance of each cell from the nearest thief.</p>
<p>The key idea here is to use Dijkstra's single source shortest path algorithm to find the optimal path from the source cell <code>[0, 0]</code> to the destination cell <code>[n-1, n-1]</code>. However, since each cell in the <code>grid</code> already contains its safeness factor, we need to modify Dijkstra's algorithm to find the path with the maximum safeness factor. In our modified Dijkstra's algorithm, we can greedily prioritize cells with a higher safeness factor to append to our path. The safeness factor of the path would be the minimum of the safeness values encountered in that path so far. Once we reach the destination cell, the safeness factor of the path would represent the required maximum safeness factor.</p>
<p>The modified Dijkstra's algorithm works as follows:</p>
<ul>
<li>We start with the source cell <code>[0, 0]</code> in a priority queue, where the priority is based on the highest safeness factor encountered in the path so far.</li>
<li>For efficiency, cells we've explored are marked as -1 in the <code>grid</code> itself.</li>
<li>If the current cell is the destination <code>[n-1, n-1]</code>, the traversal is over, and we return the maximum safeness factor encountered so far.</li>
<li>If the current cell is not the destination, we explore the valid adjacent cells. A cell is considered valid if it is within the <code>grid</code> boundaries and not visited yet (not -1).</li>
<li>For each valid neighbor, we calculate the potential safeness factor considering the current path's safeness and the new cell's distance to thieves. The minimum of these two values becomes the new safeness for the path with the addition of the neighbor.</li>
<li>We add the valid neighbors to the priority queue, prioritizing them based on their safeness factor.</li>
<li>We continue the exploration until we reach the destination cell.</li>
</ul>
<p>The key advantage of this approach is that it directly finds the optimal path from the source to the destination instead of relying on a binary search to find the maximum safeness factor. By using Dijkstra's algorithm, we can ensure that we find the path with the maximum safeness factor, without the need to perform a separate binary search.</p>
<p>Additionally, this approach may be more intuitive for some users, as it closely resembles the problem of finding the shortest path with the maximum weight (safeness factor) on a weighted graph.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define the <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
</ul>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
</ul>
</li>
<li>
<p>Mark thieves as 0 and empty cells as -1 in the <code>grid</code>. Push thieves' coordinates to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize a priority queue <code>pq</code> to prioritize cells with a higher safeness factor. Push the starting cell to <code>pq</code>.</p>
</li>
<li>
<p>Perform BFS to find the path with the maximum safeness factor:</p>
<ul>
<li>While the priority queue <code>pq</code> is not empty:
<ul>
<li>Retrieve the top element <code>curr</code> from <code>pq</code>.</li>
<li>If the destination is reached, return the safeness factor of the path.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and not marked as visited:
<ul>
<li>Update the safeness factor for the path and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no path is found, return -1.</p>
</li>
</ol>
<blockquote>
<p>Note: In the C++ implementation, the elements in the priority queue are stored as <code>[safeness, row, col]</code> to leverage C++'s default comparison capabilities.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UHkVoNQF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2 \cdot \log (n))\)</span></p>
<p>Similar to Approach 1, the time complexity of the initial BFS is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>To find the optimal path, we use Dijkstra's single source shortest path algorithm, which has a time complexity of <span class="math inline">\(O(n^2 \cdot \log (n))\)</span> when implemented in a <code>grid</code> of size <span class="math inline">\(n \cdot n\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log (n))\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log (n))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The two data structures used in this approach are the queue and the priority queue, both of which have a linear space complexity. Since the maximum number of elements that can be present in the queues is <span class="math inline">\(n \cdot n\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-string-with-lcp/description" target="_blank" rel="noopener noreferrer">Find the String with LCP</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We define the <code>lcp</code> matrix of any <strong>0-indexed</strong> string <code>word</code> of <code>n</code> lowercase English letters as an <code>n x n</code> grid such that:</p>

<ul>
	<li><code>lcp[i][j]</code> is equal to the length of the <strong>longest common prefix</strong> between the substrings <code>word[i,n-1]</code> and <code>word[j,n-1]</code>.</li>
</ul>

<p>Given an&nbsp;<code>n x n</code> matrix <code>lcp</code>, return the alphabetically smallest string <code>word</code> that corresponds to <code>lcp</code>. If there is no such string, return an empty string.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>. For example, <code>&quot;aabd&quot;</code> is lexicographically smaller than <code>&quot;aaca&quot;</code> because the first position they differ is at the third letter, and <code>&#39;b&#39;</code> comes before <code>&#39;c&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
<strong>Output:</strong> &quot;abab&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is &quot;abab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
<strong>Output:</strong> &quot;aaaa&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is &quot;aaaa&quot;. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>
	<li><code><font face="monospace">0 &lt;= lcp[i][j] &lt;= n</font></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/gcd-sort-of-an-array/description" target="_blank" rel="noopener noreferrer">GCD Sort of an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>, and you can perform the following operation <strong>any</strong> number of times on <code>nums</code>:</p>

<ul>
	<li>Swap the positions of two elements <code>nums[i]</code> and <code>nums[j]</code> if <code>gcd(nums[i], nums[j]) &gt; 1</code> where <code>gcd(nums[i], nums[j])</code> is the <strong>greatest common divisor</strong> of <code>nums[i]</code> and <code>nums[j]</code>.</li>
</ul>

<p>Return <code>true</code> <em>if it is possible to sort </em><code>nums</code><em> in <strong>non-decreasing</strong> order using the above swap method, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,21,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can sort [7,21,3] by performing the following operations:
- Swap 7 and 21 because gcd(7,21) = 7. nums = [<u><strong>21</strong></u>,<u><strong>7</strong></u>,3]
- Swap 21 and 3 because gcd(21,3) = 3. nums = [<u><strong>3</strong></u>,7,<u><strong>21</strong></u>]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,6,2]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to sort the array because 5 cannot be swapped with any other element.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,5,9,3,15]
<strong>Output:</strong> true
We can sort [10,5,9,3,15] by performing the following operations:
- Swap 10 and 15 because gcd(10,15) = 5. nums = [<u><strong>15</strong></u>,5,9,3,<u><strong>10</strong></u>]
- Swap 15 and 3 because gcd(15,3) = 3. nums = [<u><strong>3</strong></u>,5,9,<u><strong>15</strong></u>,10]
- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,<u><strong>10</strong></u>,<u><strong>15</strong></u>]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/graph-connectivity-with-threshold/description" target="_blank" rel="noopener noreferrer">Graph Connectivity With Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We have <code>n</code> cities labeled from <code>1</code> to <code>n</code>. Two different cities with labels <code>x</code> and <code>y</code> are directly connected by a bidirectional road if and only if <code>x</code> and <code>y</code> share a common divisor <strong>strictly greater</strong> than some <code>threshold</code>. More formally, cities with labels <code>x</code> and <code>y</code> have a road between them if there exists an integer <code>z</code> such that all of the following are true:</p>

<ul>
	<li><code>x % z == 0</code>,</li>
	<li><code>y % z == 0</code>, and</li>
	<li><code>z &gt; threshold</code>.</li>
</ul>

<p>Given the two integers, <code>n</code> and <code>threshold</code>, and an array of <code>queries</code>, you must determine for each <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> if cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> are connected directly or indirectly.&nbsp;(i.e. there is some path between them).</p>

<p>Return <em>an array </em><code>answer</code><em>, where </em><code>answer.length == queries.length</code><em> and </em><code>answer[i]</code><em> is </em><code>true</code><em> if for the </em><code>i<sup>th</sup></code><em> query, there is a path between </em><code>a<sub>i</sub></code><em> and </em><code>b<sub>i</sub></code><em>, or </em><code>answer[i]</code><em> is </em><code>false</code><em> if there is no path.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/09/ex1.jpg" style="width: 382px; height: 181px;" />
<pre>
<strong>Input:</strong> n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
<strong>Output:</strong> [false,false,true]
<strong>Explanation:</strong> The divisors for each number:
1:   1
2:   1, 2
3:   1, <u>3</u>
4:   1, 2, <u>4</u>
5:   1, <u>5</u>
6:   1, 2, <u>3</u>, <u>6</u>
Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the
only ones directly connected. The result of each query:
[1,4]   1 is not connected to 4
[2,5]   2 is not connected to 5
[3,6]   3 is connected to 6 through path 3--6
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/10/tmp.jpg" style="width: 532px; height: 302px;" />
<pre>
<strong>Input:</strong> n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
<strong>Output:</strong> [true,true,true,true,true]
<strong>Explanation:</strong> The divisors for each number are the same as the previous example. However, since the threshold is 0,
all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/17/ex3.jpg" style="width: 282px; height: 282px;" />
<pre>
<strong>Input:</strong> n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
<strong>Output:</strong> [false,false,false,false,false]
<strong>Explanation:</strong> Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.
Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= threshold &lt;= n</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= cities</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/greatest-common-divisor-traversal/description" target="_blank" rel="noopener noreferrer">Greatest Common Divisor Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>, and you are allowed to <strong>traverse</strong> between its indices. You can traverse between index <code>i</code> and index <code>j</code>, <code>i != j</code>, if and only if <code>gcd(nums[i], nums[j]) &gt; 1</code>, where <code>gcd</code> is the <strong>greatest common divisor</strong>.</p>

<p>Your task is to determine if for <strong>every pair</strong> of indices <code>i</code> and <code>j</code> in nums, where <code>i &lt; j</code>, there exists a <strong>sequence of traversals</strong> that can take us from <code>i</code> to <code>j</code>.</p>

<p>Return <code>true</code><em> if it is possible to traverse between all such pairs of indices,</em><em> or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).
To go from index 0 to index 1, we can use the sequence of traversals 0 -&gt; 2 -&gt; 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1.
To go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,9,5]
<strong>Output:</strong> false
<strong>Explanation:</strong> No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,12,8]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem provides an array of integers <code>nums</code> of length <code>n</code>, with <code>1 &lt;= nums[i] &lt;= MAX_VAL = 100000</code>. You can jump between two indices <code>i</code> and <code>j</code> if the gcd (greatest common divisor) between the two values at indices <code>i</code> and <code>j</code> is strictly greater than 1. Determine if every pair of indices can reach each other using any sequence of jumps.<br />
MagentaCobra marked this conversation as resolved.</p>
<hr />
<h3 id="approach-1-creating-a-graph-with-dummy-nodes-and-edges">Approach 1: Creating a graph with dummy nodes and edges</h3>
<h4 id="intuition">Intuition</h4>
<p>First, we should notice that this is a graph problem. The ability to jump between indices <code>i</code> and <code>j</code> is analogous to an edge between nodes <code>i</code> and <code>j</code>. With this in mind, we can restate the problem as a graph problem formally with the following:</p>
<p>Given a graph of <code>n</code> nodes with undirected edges <code>(i, j)</code> if and only if <code>gcd(nums[i], nums[j]) &gt; 1</code>, determine if all nodes are reachable from each other. Note that edges are undirected because <code>gcd(nums[i], nums[j]) = gcd(nums[j], nums[i])</code>.</p>
<p>If all nodes can reach each other, this means that all nodes must be in one connected component. Rather than checking every pair of nodes to see if they can reach each other, it suffices to check if all nodes belong in the same connected component. This is because if more than one component exists in this graph, then two nodes from two different components cannot reach each other.</p>
<p>Unfortunately, this graph can have <code>n(n-1)/2 = O(n^2)</code> edges in the worst case. Imagine if all numbers in the array were even. Then the gcd between any two indices is at least 2, so the graph would be complete and have too many edges. With the goal of creating a graph that is efficient enough to construct in the time limit, let's consider adding some dummy nodes to reduce the number of edges.</p>
<p>In addition to the original <code>n</code> nodes, add a dummy node for each prime number not exceeding <code>MAX_VAL</code> (the max value of <code>nums[i]</code>). Letâ€™s define <code>g_i</code> as a node corresponding to the <code>i</code>th index of <code>nums</code>, and <code>d_p</code> as the dummy node corresponding to prime number <code>p</code>. If <code>nums[i]</code> is divisible by prime factor <code>p</code>, build an edge between <code>g_i</code> and <code>d_p</code>.</p>
<p>Any two original nodes connected in the naive graph will stay connected in this new graph. Likewise, nodes that initially were in different components stay in different components. As a result, we can check if this new graph is connected. This works because <code>gcd(nums[i], nums[j]) &gt; 1</code> is another way of saying that <code>nums[i]</code> and <code>nums[j]</code> share a prime factor, so nodes <code>g_i</code> and <code>g_j</code> will be connected via dummy node <code>d_p</code>, where <code>d_p</code> is any prime factor of <code>gcd(nums[i], nums[j])</code>.</p>
<p>Here is the graph for <code>nums = [6, 8, 3, 15, 4]</code>. For simplicity, only dummy nodes for prime factors 2, 3, and 5 are shown.</p>
<p><img src="../Figures/2709/figure_2709.png" alt="figA" /></p>
<p>Note that in implementation, you can construct the graph slightly differently by creating non-dummy nodes for each value that appears in <code>nums</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Handle the edge cases, if <code>n = 1</code>, return <code>true</code>, if <code>nums[i] = 1</code>, return <code>false</code>.</li>
<li>Create an array of length <code>MAX_VAL</code>, with all elements initialized to <code>false</code>, and use the sieve of Eratosthenes to compute prime factors for all integers 1 to <code>MAX_VAL</code>.</li>
<li>For each element <code>nums[i]</code>, iterate over all its prime factors, and for each prime factor <code>d_i</code> and add an edge between nodes <code>g_i</code> and <code>d_p</code>.</li>
<li>Once constructing the graph, count the number of components.</li>
<li>Return <code>true</code> if the graph has one component, and <code>false</code> otherwise.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MU8SDHcp/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>There are less than <code>MAX_VAL</code> additional dummy nodes, and because any integer at most <code>MAX_VAL</code> will have at most 6 distinct prime factors, the graph will have at most 6<code>n</code> edges. To iterate over all prime factors efficiently, we can consider the harmonic series, or use the sieve of Eratosthenes algorithm to build this graph in <code>O(n log(MAX_VAL))</code> with <code>O(n)</code> memory. Checking the connectivity of this graph can be done with either BFS/DFS or union find, which can be done in <code>O(n)</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n*log(MAX\_VAL))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<p>The time complexity of union find (DSU) can be treated as <code>O(n)</code> only when both path-compression and rank-by-size are applied, which is used in the above solution code.<br />
The time complexity of the Union-Find with path compression and union can be described using Ackermann's function, <span class="math inline">\(A(m, n)\)</span>, in practice, it can be approximated as <span class="math inline">\(O(n)\)</span>.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/groups-of-strings/description" target="_blank" rel="noopener noreferrer">Groups of Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of strings <code>words</code>. Each string consists of <strong>lowercase English letters</strong> only. No letter occurs more than once in any string of <code>words</code>.</p>

<p>Two strings <code>s1</code> and <code>s2</code> are said to be <strong>connected</strong> if the set of letters of <code>s2</code> can be obtained from the set of letters of <code>s1</code> by any <strong>one</strong> of the following operations:</p>

<ul>
	<li>Adding exactly one letter to the set of the letters of <code>s1</code>.</li>
	<li>Deleting exactly one letter from the set of the letters of <code>s1</code>.</li>
	<li>Replacing exactly one letter from the set of the letters of <code>s1</code> with any letter, <strong>including</strong> itself.</li>
</ul>

<p>The array <code>words</code> can be divided into one or more non-intersecting <strong>groups</strong>. A string belongs to a group if any <strong>one</strong> of the following is true:</p>

<ul>
	<li>It is connected to <strong>at least one</strong> other string of the group.</li>
	<li>It is the <strong>only</strong> string present in the group.</li>
</ul>

<p>Note that the strings in <code>words</code> should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.</p>

<p>Return <em>an array</em> <code>ans</code> <em>of size</em> <code>2</code> <em>where:</em></p>

<ul>
	<li><code>ans[0]</code> <em>is the <strong>maximum number</strong> of groups</em> <code>words</code> <em>can be divided into, and</em></li>
	<li><code>ans[1]</code> <em>is the <strong>size of the largest</strong> group</em>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;,&quot;cde&quot;]
<strong>Output:</strong> [2,3]
<strong>Explanation:</strong>
- words[0] can be used to obtain words[1] (by replacing &#39;a&#39; with &#39;b&#39;), and words[2] (by adding &#39;b&#39;). So words[0] is connected to words[1] and words[2].
- words[1] can be used to obtain words[0] (by replacing &#39;b&#39; with &#39;a&#39;), and words[2] (by adding &#39;a&#39;). So words[1] is connected to words[0] and words[2].
- words[2] can be used to obtain words[0] (by deleting &#39;b&#39;), and words[1] (by deleting &#39;a&#39;). So words[2] is connected to words[0] and words[1].
- words[3] is not connected to any string in words.
Thus, words can be divided into 2 groups [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;] and [&quot;cde&quot;]. The size of the largest group is 3.  
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;]
<strong>Output:</strong> [1,3]
<strong>Explanation:</strong>
- words[0] is connected to words[1].
- words[1] is connected to words[0] and words[2].
- words[2] is connected to words[1].
Since all strings are connected to each other, they should be grouped together.
Thus, the size of the largest group is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 26</code></li>
	<li><code>words[i]</code> consists of lowercase English letters only.</li>
	<li>No letter occurs more than once in <code>words[i]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/is-graph-bipartite/description" target="_blank" rel="noopener noreferrer">Is Graph Bipartite?</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p>

<ul>
	<li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li>
	<li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li>
	<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>
	<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>
</ul>

<p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p>

<p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>graph.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= graph[u].length &lt; n</code></li>
	<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>
	<li><code>graph[u]</code>&nbsp;does not contain&nbsp;<code>u</code>.</li>
	<li>All the values of <code>graph[u]</code> are <strong>unique</strong>.</li>
	<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-component-size-by-common-factor/description" target="_blank" rel="noopener noreferrer">Largest Component Size by Common Factor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array of unique positive integers <code>nums</code>. Consider the following graph:</p>

<ul>
	<li>There are <code>nums.length</code> nodes, labeled <code>nums[0]</code> to <code>nums[nums.length - 1]</code>,</li>
	<li>There is an undirected edge between <code>nums[i]</code> and <code>nums[j]</code> if <code>nums[i]</code> and <code>nums[j]</code> share a common factor greater than <code>1</code>.</li>
</ul>

<p>Return <em>the size of the largest connected component in the graph</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/01/ex1.png" style="width: 500px; height: 97px;" />
<pre>
<strong>Input:</strong> nums = [4,6,15,35]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/01/ex2.png" style="width: 500px; height: 85px;" />
<pre>
<strong>Input:</strong> nums = [20,50,9,63]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/01/ex3.png" style="width: 500px; height: 260px;" />
<pre>
<strong>Input:</strong> nums = [2,3,6,7,4,12,21,39]
<strong>Output:</strong> 8
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/last-day-where-you-can-still-cross/description" target="_blank" rel="noopener noreferrer">Last Day Where You Can Still Cross</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>1-based</strong> binary matrix where <code>0</code> represents land and <code>1</code> represents water. You are given integers <code>row</code> and <code>col</code> representing the number of rows and columns in the matrix, respectively.</p>

<p>Initially on day <code>0</code>, the <strong>entire</strong> matrix is <strong>land</strong>. However, each day a new cell becomes flooded with <strong>water</strong>. You are given a <strong>1-based</strong> 2D array <code>cells</code>, where <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents that on the <code>i<sup>th</sup></code> day, the cell on the <code>r<sub>i</sub><sup>th</sup></code> row and <code>c<sub>i</sub><sup>th</sup></code> column (<strong>1-based</strong> coordinates) will be covered with <strong>water</strong> (i.e., changed to <code>1</code>).</p>

<p>You want to find the <strong>last</strong> day that it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells. You can start from <strong>any</strong> cell in the top row and end at <strong>any</strong> cell in the bottom row. You can only travel in the<strong> four</strong> cardinal directions (left, right, up, and down).</p>

<p>Return <em>the <strong>last</strong> day where it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;" />
<pre>
<strong>Input:</strong> row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>cells.length == row * col</code></li>
	<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>
	<li>All the values of <code>cells</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographically-smallest-equivalent-string/description" target="_blank" rel="noopener noreferrer">Lexicographically Smallest Equivalent String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings of the same length <code>s1</code> and <code>s2</code> and a string <code>baseStr</code>.</p>

<p>We say <code>s1[i]</code> and <code>s2[i]</code> are equivalent characters.</p>

<ul>
	<li>For example, if <code>s1 = &quot;abc&quot;</code> and <code>s2 = &quot;cde&quot;</code>, then we have <code>&#39;a&#39; == &#39;c&#39;</code>, <code>&#39;b&#39; == &#39;d&#39;</code>, and <code>&#39;c&#39; == &#39;e&#39;</code>.</li>
</ul>

<p>Equivalent characters follow the usual rules of any equivalence relation:</p>

<ul>
	<li><strong>Reflexivity:</strong> <code>&#39;a&#39; == &#39;a&#39;</code>.</li>
	<li><strong>Symmetry:</strong> <code>&#39;a&#39; == &#39;b&#39;</code> implies <code>&#39;b&#39; == &#39;a&#39;</code>.</li>
	<li><strong>Transitivity:</strong> <code>&#39;a&#39; == &#39;b&#39;</code> and <code>&#39;b&#39; == &#39;c&#39;</code> implies <code>&#39;a&#39; == &#39;c&#39;</code>.</li>
</ul>

<p>For example, given the equivalency information from <code>s1 = &quot;abc&quot;</code> and <code>s2 = &quot;cde&quot;</code>, <code>&quot;acd&quot;</code> and <code>&quot;aab&quot;</code> are equivalent strings of <code>baseStr = &quot;eed&quot;</code>, and <code>&quot;aab&quot;</code> is the lexicographically smallest equivalent string of <code>baseStr</code>.</p>

<p>Return <em>the lexicographically smallest equivalent string of </em><code>baseStr</code><em> by using the equivalency information from </em><code>s1</code><em> and </em><code>s2</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;parker&quot;, s2 = &quot;morris&quot;, baseStr = &quot;parser&quot;
<strong>Output:</strong> &quot;makkek&quot;
<strong>Explanation:</strong> Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].
The characters in each group are equivalent and sorted in lexicographical order.
So the answer is &quot;makkek&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;hello&quot;, s2 = &quot;world&quot;, baseStr = &quot;hold&quot;
<strong>Output:</strong> &quot;hdld&quot;
<strong>Explanation: </strong>Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].
So only the second letter &#39;o&#39; in baseStr is changed to &#39;d&#39;, the answer is &quot;hdld&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;leetcode&quot;, s2 = &quot;programs&quot;, baseStr = &quot;sourcecode&quot;
<strong>Output:</strong> &quot;aauaaaaada&quot;
<strong>Explanation:</strong> We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except &#39;u&#39; and &#39;d&#39; are transformed to &#39;a&#39;, the answer is &quot;aauaaaaada&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s1.length, s2.length, baseStr &lt;= 1000</code></li>
	<li><code>s1.length == s2.length</code></li>
	<li><code>s1</code>, <code>s2</code>, and <code>baseStr</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-consecutive-sequence/description" target="_blank" rel="noopener noreferrer">Longest Consecutive Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>

<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [100,4,200,1,3,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]
<strong>Output:</strong> 9
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,1,2]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-uploaded-prefix/description" target="_blank" rel="noopener noreferrer">Longest Uploaded Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a stream of <code>n</code> videos, each represented by a <strong>distinct</strong> number from <code>1</code> to <code>n</code> that you need to &quot;upload&quot; to a server. You need to implement a data structure that calculates the length of the <strong>longest uploaded prefix</strong> at various points in the upload process.</p>

<p>We consider <code>i</code> to be an uploaded prefix if all videos in the range <code>1</code> to <code>i</code> (<strong>inclusive</strong>) have been uploaded to the server. The longest uploaded prefix is the <strong>maximum </strong>value of <code>i</code> that satisfies this definition.<br />
<br />
Implement the <code>LUPrefix </code>class:</p>

<ul>
	<li><code>LUPrefix(int n)</code> Initializes the object for a stream of <code>n</code> videos.</li>
	<li><code>void upload(int video)</code> Uploads <code>video</code> to the server.</li>
	<li><code>int longest()</code> Returns the length of the <strong>longest uploaded prefix</strong> defined above.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LUPrefix&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;]
[[4], [3], [], [1], [], [2], []]
<strong>Output</strong>
[null, null, 0, null, 1, null, 3]

<strong>Explanation</strong>
LUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.
server.upload(3);                    // Upload video 3.
server.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.
                                     // So, we return 0.
server.upload(1);                    // Upload video 1.
server.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.
server.upload(2);                    // Upload video 2.
server.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= video &lt;= n</code></li>
	<li>All values of <code>video</code> are <strong>distinct</strong>.</li>
	<li>At most <code>2 * 10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>upload</code> and <code>longest</code>.</li>
	<li>At least one call will be made to <code>longest</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/description" target="_blank" rel="noopener noreferrer">Make Lexicographically Smallest Array by Swapping Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code> and a <strong>positive</strong> integer <code>limit</code>.</p>

<p>In one operation, you can choose any two indices <code>i</code> and <code>j</code> and swap <code>nums[i]</code> and <code>nums[j]</code> <strong>if</strong> <code>|nums[i] - nums[j]| &lt;= limit</code>.</p>

<p>Return <em>the <strong>lexicographically smallest array</strong> that can be obtained by performing the operation any number of times</em>.</p>

<p>An array <code>a</code> is lexicographically smaller than an array <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, array <code>a</code> has an element that is less than the corresponding element in <code>b</code>. For example, the array <code>[2,10,3]</code> is lexicographically smaller than the array <code>[10,2,3]</code> because they differ at index <code>0</code> and <code>2 &lt; 10</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,5,3,9,8], limit = 2
<strong>Output:</strong> [1,3,5,8,9]
<strong>Explanation:</strong> Apply the operation 2 times:
- Swap nums[1] with nums[2]. The array becomes [1,3,5,9,8]
- Swap nums[3] with nums[4]. The array becomes [1,3,5,8,9]
We cannot obtain a lexicographically smaller array by applying any more operations.
Note that it may be possible to get the same result by doing different operations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,6,18,2,1], limit = 3
<strong>Output:</strong> [1,6,7,18,1,2]
<strong>Explanation:</strong> Apply the operation 3 times:
- Swap nums[1] with nums[2]. The array becomes [1,6,7,18,2,1]
- Swap nums[0] with nums[4]. The array becomes [2,6,7,18,1,1]
- Swap nums[0] with nums[5]. The array becomes [1,6,7,18,1,2]
We cannot obtain a lexicographically smaller array by applying any more operations.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,28,19,10], limit = 3
<strong>Output:</strong> [1,7,28,19,10]
<strong>Explanation:</strong> [1,7,28,19,10] is the lexicographically smallest array we can obtain because we cannot apply the operation on any two indices.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= limit &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>nums</code> in which we can swap any two elements <code>nums[i]</code> and <code>nums[j]</code> if their absolute difference is less than or equal to <code>limit</code>. We want to find the lexicographically smallest possible array we can make by applying this swap operation an unlimited number of times on <code>nums</code>.</p>
<p>Lexicographical order compares arrays element by element, starting from the leftmost index. For two arrays, the comparison stops as soon as we find an index where the elements differ:</p>
<ul>
<li>The array with the smaller element at this differing index is considered smaller.</li>
<li>If all elements are the same up to the shorter array's length, the shorter array is considered smaller.</li>
</ul>
<p>For the example arrays given in the problem description, <code>[2,10,3]</code> and <code>[10,2,3]</code>, the first elements don't match: <code>2 &lt; 10</code>, so <code>[2,10,3]</code> is lexicographically smaller.</p>
<p>Let's look at another example: For <code>[1, 1, 3, 5]</code> and <code>[1, 1, 2, 7, 9]</code>, the first occurrence in which the elements do not match is at index 2: <code>2 &lt; 3</code> so <code>[1, 1, 2, 7, 9]</code> is lexicographically smaller.</p>
<h3 id="approach-sorting--grouping">Approach: Sorting + Grouping</h3>
<h4 id="intuition">Intuition</h4>
<p>Our goal is to perform valid swap operations on <code>nums</code> so that it is as lexicographically small as possible. After looking at the examples in the overview, we see that to make a lexicographically small array, we would like smaller values to be more towards the front, while larger values are pushed to the back. We will now investigate what sort of rearrangements are possible in order to achieve this ordering.</p>
<p>Consider the array <code>[5, 3, 1]</code> with <code>limit = 2</code>:</p>
<ul>
<li><code>1</code> and <code>3</code> can be swapped because <span class="math inline">\(|3 - 1| = 2 \leq \text{limit}\)</span>.</li>
<li>Similarly, <code>3</code> and <code>5</code> can be swapped because <span class="math inline">\(|5 - 3| = 2 \leq \text{limit}\)</span>.</li>
<li>On the other hand, <code>1</code> and <code>5</code> cannot be swapped directly because <span class="math inline">\(|5 - 1| = 4 > \text{limit}\)</span>.</li>
</ul>
<p>Even though <code>1</code> and <code>5</code> cannot be swapped directly, we notice that they can effectively be swapped through a chain of intermediate swaps where <code>1</code> gets swapped with <code>3</code> and <code>3</code> gets swapped with <code>5</code>:</p>
<p><img src="../Figures/2948/reordering.png" alt="Reordering" /></p>
<p>In other words, this swapping is <strong>transitive</strong>: If <code>a</code> can swap with <code>b</code>, and <code>b</code> can swap with <code>c</code>, then <code>a</code> can effectively be swapped with <code>c</code>. Through this transitive property, we know that all elements in the example array can be swapped with each other (because they all belong in this transitive swapping chain). Because of this, any rearrangement/permutation can also be done. For this problem, we want the elements in increasing order to achieve the smallest lexicographic value, so we know <code>[1, 3, 5]</code> is the lexicographically smallest possible array that can be made.</p>
<p>Now that we know about this transitive property, it would be useful to see which elements in <code>nums</code> can be rearranged together like shown above. Specifically, we want to organize <code>nums</code> into groups, so that all elements in a given group can participate in this transitive chaining and can thus be reordered in our desired increasing order.</p>
<p>To do this, we can first sort <code>nums</code> in increasing order. We can then iterate through each <code>num</code> in <code>nums</code> and compare it to its previous element to see if their absolute difference is within <code>limit</code>. If it is, then <code>num</code> belongs in the same running group. Otherwise, the chain is broken and a new group containing <code>num</code> is created.</p>
<p><img src="../Figures/2948/sorting_and_grouping.png" alt="Sorting and grouping" /></p>
<p>To keep track of groups, we can use a hash map <code>numToGroup</code>, where the key is the element and the value is the group number (the group number can be initialized to 0 and incremented each time a new group is created). Similarly, to keep track of the list of elements comprising each group, we can use another hash map <code>groupToList</code> where the key is the group number and the value is the sorted list of elements belonging to the group.</p>
<p>After this process, we now know what group each element in <code>nums</code> belongs to, and that elements in each group can be freely rearranged:</p>
<p><img src="../Figures/2948/grouping_in_original_input.png" alt="Grouping in original input" /></p>
<p>Once we've grouped the elements, we return to the original array. For each element, we check its group using <code>numToGroup</code> and overwrite it with the next smallest element from that group. This ensures the elements in each group are placed in ascending order, resulting in the smallest possible lexicographic arrangement.</p>
<p><img src="../Figures/2948/final_output.png" alt="Final output" /></p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create a sorted copy of the input array <code>nums</code> called <code>numsSorted</code>.</p>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>currGroup</code> to track the current group index.</li>
<li><code>numToGroup</code>, a map to associate each number with its group.</li>
<li><code>groupToList</code>, a map to associate each group with a list of numbers that belong to it.</li>
</ul>
</li>
<li>
<p>Sort the <code>numsSorted</code> array.</p>
</li>
<li>
<p>Assign the first element of <code>numsSorted</code> to group <code>0</code>:</p>
<ul>
<li>Add the element to <code>groupToList</code> under group <code>0</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the rest of <code>numsSorted</code>:</p>
<ul>
<li>If the difference between the current element and the previous one is greater than <code>limit</code>, increment <code>currGroup</code> (indicating a new group).</li>
<li>Assign the current element to the correct group in <code>numToGroup</code>.</li>
<li>Add the element to the corresponding list in <code>groupToList</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the original <code>nums</code> array:</p>
<ul>
<li>For each element, retrieve its group from <code>numToGroup</code>.</li>
<li>Replace the element with the next element from its corresponding group in <code>groupToList</code>.</li>
</ul>
</li>
<li>
<p>Return the modified <code>nums</code> array, which is now the lexicographically smallest array after applying the group-wise sorting.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TEDHLEBH/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot \log N)\)</span></p>
<p>Sorting <code>nums</code> takes <span class="math inline">\(O(N \cdot \log N)\)</span> time. Iterating through each element in <code>sortedNums</code> and updating our two maps takes <span class="math inline">\(O(N)\)</span> time. Iterating through <code>nums</code> to overwrite its values with the sorted list values in each group takes a total of <span class="math inline">\(O(N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(N \cdot \log N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N + S_N) \approx O(N)\)</span></p>
<p>Both our maps have a space complexity of <span class="math inline">\(N\)</span>. The space complexity used for sorting <code>nums</code> depends on the language of implementation:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log N)\)</span>.<br />
In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log N)\)</span>.<br />
In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(N)\)</span>.</p>
<p>Thus, the total space complexity is <span class="math inline">\(O(N + S_N) \approx O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/making-a-large-island/description" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary matrix <code>grid</code>. You are allowed to change <strong>at most one</strong> <code>0</code> to be <code>1</code>.</p>

<p>Return <em>the size of the largest <strong>island</strong> in</em> <code>grid</code> <em>after applying this operation</em>.</p>

<p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Change one 0 to 1 and connect two 1s, then we get an island with area = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,0]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>Change the 0 to 1 and make the island bigger, only one island with area = 4.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Can&#39;t change any 0 to 1, only one island with area = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-dfs">Approach 1: Using DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a binary matrix where each cell is either <code>0</code> (representing water) or <code>1</code> (representing land) and the ability to flip at most one <code>0</code> to <code>1</code>. Our task is to find the largest island in the matrix, or in other words, the largest group of <code>1</code>s connected with each other either up, down, left, or right (4-directionally) after the flip operation.</p>
<p>At first, we might think of flipping each <code>0</code> to <code>1</code> and then calculating the size of the largest island in the modified matrix. However, this brute-force approach is inefficient, especially for larger grids, as it involves multiple recalculations for each flip, which would lead to Time Limit Exceeded (TLE) error.</p>
<p>Instead of recalculating island sizes for every flip, we can take advantage of the fact that flipping a single <code>0</code> only affects the islands adjacent to it. Specifically, flipping a <code>0</code> merges neighboring islands into one larger island. This insight allows us to efficiently compute the largest island after flipping by precomputing the sizes of all islands first.</p>
<p>Check out the diagram below, where we can see that we can merge two islands into one by flipping a zero in between.</p>
<p><img src="../Figures/827/make_large_island.png" alt="make_large_island" /></p>
<p>We start by traversing the grid and identifying all the islands using Depth-First Search (DFS). During this traversal, we give each island a unique identifier (like a color). At the same time, we also calculate and store the size of each island in a map, where the key is the islandâ€™s unique identifier and the value is its size. This precomputation allows us to avoid recalculating island sizes later.</p>
<blockquote>
<p>For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">DFS Explore Card</a>.</p>
</blockquote>
<p>After labeling the islands and knowing their sizes, we then look at each <code>0</code> in the grid. Flipping a <code>0</code> to <code>1</code> might connect neighboring islands, creating a larger island. For each <code>0</code>, we examine the islands around it and collect their unique identifiers using a set (to avoid counting the same island more than once). We then sum up the sizes of these islands to calculate the size of the new island that would be formed if this <code>0</code> were flipped to <code>1</code>.</p>
<p>As we evaluate each potential flip, we compare the size of the island that would be formed with the largest island weâ€™ve seen so far. This ensures that we find the largest possible island we can form by flipping a single <code>0</code>. We will handle special edge cases (e.g., the grid is full with <code>1</code>s or <code>0</code>s) separately.</p>
<p>This strategy is efficient because the grid is only traversed twice:</p>
<ol>
<li>To label the islands and compute their sizes.</li>
<li>To evaluate the potential island size for each <code>0</code> flip.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<h5 id="exploreisland-helper-function"><code>exploreIsland</code> helper function:</h5>
<ul>
<li>
<p>Define the <code>exploreIsland</code> function which recursively explores an island with the given id <code>islandId</code> starting from the given cell <code>(currentRow, currentColumn)</code>.</p>
</li>
<li>
<p>Check if the current cell is out of bounds, is not part of an island or is already visited (i.e., its value is not <code>1</code>):</p>
<ul>
<li>If so, return <code>0</code>, indicating no land is found at this cell.</li>
</ul>
</li>
<li>
<p>Mark the current cell with the given <code>islandId</code> to indicate it has been visited.</p>
</li>
<li>
<p>Recursively explore the four neighboring cells (up, down, left, right) and accumulate the area of the island:</p>
<ul>
<li>Call <code>exploreIsland</code> for the cell below <code>(currentRow + 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell above <code>(currentRow - 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the right <code>(currentRow, currentColumn + 1)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the left <code>(currentRow, currentColumn - 1)</code>.</li>
</ul>
</li>
<li>
<p>Return the total area of the island (i.e., 1 + the sum of all reachable land cells from the current position).</p>
</li>
</ul>
<h5 id="largestisland-main-function"><code>largestIsland</code> main function:</h5>
<ul>
<li>
<p>Initialize <code>islandSizes</code> to store sizes of islands, and <code>islandId</code> starting at <code>2</code> (to mark islands).</p>
</li>
<li>
<p>Traverse through the grid to mark all islands and calculate their sizes:</p>
<ul>
<li>For each cell in the grid, if the cell contains a land (value <code>1</code>), call <code>exploreIsland()</code> to mark the island and calculate its size.</li>
<li>For each island, store the size in <code>islandSizes</code> using the <code>islandId</code> as the key and increment <code>islandId</code> for the next island.</li>
</ul>
</li>
<li>
<p>Check if there are no islands (empty grid), in which case return 1 (since flipping one <code>0</code> would form a new island).</p>
</li>
<li>
<p>If only one island exists in the entire grid, check if the size of that island is equal to the total grid size:</p>
<ul>
<li>If true, return the size of the island.</li>
<li>Otherwise, return the size of the island + 1 (as we can expand the island by flipping one <code>0</code>).</li>
</ul>
</li>
<li>
<p>Initialize <code>maxIslandSize</code> to 1, which will store the size of the largest island.</p>
</li>
<li>
<p>Traverse through the grid again to try converting each <code>0</code> to a <code>1</code> and calculate the resulting island size:</p>
<ul>
<li>For each <code>0</code>, check its neighboring cells (up, down, left, right) to find which islands are connected to it.</li>
<li>Use a unordered set to store unique neighboring island IDs.</li>
<li>Sum the sizes of all unique neighboring islands and add 1 (to account for the flipped <code>0</code> turning into a <code>1</code>).</li>
<li>Update <code>maxIslandSize</code> with the maximum island size found.</li>
</ul>
</li>
<li>
<p>Return <code>maxIslandSize</code>, the size of the largest island after trying to expand all possible <code>0</code>s.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fqsaoAuS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid to identify and mark islands using a Depth-First Search (DFS) approach. During this process, each cell is visited at most once, ensuring that the DFS traversal contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells, which is a constant-time operation. The use of an unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Thus, the overall time complexity is dominated by the grid traversal and DFS, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the recursion stack used during the DFS traversal and the storage required for the unordered map that keeps track of island sizes. In the worst case, the recursion depth of the DFS can be <span class="math inline">\(O(n \times m)\)</span> if the entire grid forms a single large island. The unordered map stores the sizes of all islands, and in the worst case, the number of islands can be proportional to the number of cells, contributing <span class="math inline">\(O(n \times m)\)</span> to the space complexity.</p>
<p>Furthermore, the unordered set used to store neighboring islands for each <code>0</code> cell has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factors are the recursion stack and the unordered map, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-disjoint-set-union-dsu">Approach 2: Using Disjoint Set Union (DSU)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another way to solve this problem is by using a data structure called <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Disjoint Set Union (DSU)</a>, also known as Union-Find.</p>
<p>In DSU, the main goal is to keep track of groups (or sets) of elements where each set has a representative. The key operations in DSU are:</p>
<ol>
<li><strong>Find</strong>: This operation helps to find the representative (or &quot;leader&quot;) of the set to which an element belongs. If two elements are in the same set, they will have the same representative.</li>
<li><strong>Union</strong>: This operation merges two sets together. If two elements belong to different sets, they are combined into a single set, and the representative of one set becomes the representative of the merged set.</li>
</ol>
<p>The idea behind DSU is that we represent each island as a set, and then we merge islands when we encounter an adjacent land cell. This helps us keep track of which cells belong to which island and how big each island is.</p>
<p>First, we initialize a DSU structure where each land cell is its own representative (each cell is its own island), meaning that  <code>parent[node] = node</code> for every land cell node. We also initialize the <code>islandSize</code> array, where each island starts with a size of 1 (since each island is just one land cell initially). This is represented as <code>islandSize[node] = 1</code>.</p>
<p>As we traverse the grid, whenever we encounter a land cell (<code>1</code>), we check its adjacent cells (up, down, left, right). If an adjacent cell is also land, we union their corresponding sets. This means we merge the two islands (sets) into one larger island. The merging process ensures that the larger island becomes the representative of the merged set, keeping the data structure efficient.</p>
<p>During the merging step, we also update the size of the new island (set) by adding the size of the two merged islands. This is done by maintaining the <code>islandSize</code> array, where <code>islandSize[node]</code> is updated after each union operation.</p>
<p>After the initial union of all adjacent land cells, we then evaluate the potential effect of flipping a <code>0</code> (water) cell to <code>1</code> (land). When flipping a <code>0</code> to <code>1</code>, it will create a new island that merges with its adjacent islands (if any). To calculate the size of the new island formed by flipping a <code>0</code>, we simply look at the neighboring islands (sets) and calculate the size of the combined island. We do this by finding the representatives of the neighboring sets using find operations and summing their sizes.</p>
<p>As we evaluate each potential flip, we keep track of the largest island size encountered. If the grid is already filled with <code>1</code>s or <code>0</code>s, we handle these edge cases accordingly, but the main idea remains to maximize the island size formed by flipping a single <code>0</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="define-the-disjointset-class">Define the <code>DisjointSet</code> class:</h5>
<ul>
<li>
<p>Initialize <code>parent</code> and <code>islandSize</code> arrays:</p>
<ul>
<li><code>parent</code> stores the parent of each node.</li>
<li><code>islandSize</code> stores the size of the connected island for each root.</li>
</ul>
</li>
<li>
<p>Initialize the <code>DisjointSet</code> constructor with <code>n</code> elements:</p>
<ul>
<li>For each node from <code>l</code> to <code>n-1</code>:
<ul>
<li>Set <code>parent[node] = node</code>, meaning each node is initially its own parent.</li>
<li>Set <code>islandSize[node] = 1</code>, indicating each island starts with size 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Implement <code>findRoot</code> function with path compression:</p>
<ul>
<li>If the current node is its own parent, return the node as the root.</li>
<li>Otherwise, recursively find the root of the parent and apply path compression by updating the parent of the node.</li>
</ul>
</li>
<li>
<p>Implement <code>unionNodes(nodeA, nodeB)</code> function to union two sets based on size:</p>
<ul>
<li>Find the roots of both <code>nodeA</code> and <code>nodeB</code> using the <code>findRoot</code> function.</li>
<li>If both nodes are already in the same set (i.e., have the same root), do nothing.</li>
<li>Otherwise, union the sets by size:
<ul>
<li>Attach the smaller island to the larger one:
<ul>
<li>If the island of <code>nodeA</code> is smaller, set <code>parent[rootA] = rootB</code> and update the size of <code>rootB</code>â€™s island.</li>
<li>If the island of <code>nodeB</code> is smaller, set <code>parent[rootB] = rootA</code> and update the size of <code>rootA</code>â€™s island.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="in-the-given-solution-class">In the given <code>Solution</code> class:</h5>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>columns</code> to store the grid's dimensions.</p>
</li>
<li>
<p>Initialize a Disjoint Set Union (DSU) for the entire grid with <code>rows * columns</code> size.</p>
</li>
<li>
<p>Define direction arrays (<code>rowDirections</code>, <code>columnDirections</code>) for traversing up, down, left, and right.</p>
</li>
</ul>
<p>Step 1: Union adjacent <code>1</code>s in the grid:</p>
<ul>
<li>Iterate through each cell in the grid:
<ul>
<li>If the current cell contains <code>1</code>, calculate the flattened 1D index for the current cell, as <code>(columns * currentRow) + currentColumn</code>.</li>
<li>For each of the four possible directions (up, down, left, right), check if the neighbor is within bounds and also contains <code>1</code>.</li>
<li>If the neighbor is valid, flatten the 2D index and use the DSU to union the current cell and the neighbor.</li>
</ul>
</li>
</ul>
<p>Step 2: Calculate the maximum possible island size:</p>
<ul>
<li>Initialize <code>maxIslandSize</code> to store the largest island size and <code>hasZero</code> as a flag to check if there are any zeros in the grid.</li>
<li>Initialize a <code>uniqueRoots</code> set to store the unique roots of neighboring <code>1</code>s for each <code>0</code> in the grid.</li>
<li>Iterate through the grid to find all zeros (<code>0</code> cells):
<ul>
<li>For each <code>0</code>, initialize the <code>currentIslandSize</code> to <code>1</code> (since we are flipping the <code>0</code>).</li>
<li>For each direction (up, down, left, right), check if the neighboring cell contains <code>1</code> and if so, add the root of the neighboring island to <code>uniqueRoots</code>.</li>
<li>Sum the sizes of the unique neighboring islands using their roots.</li>
<li>Update <code>maxIslandSize</code> with the largest island size found.</li>
</ul>
</li>
</ul>
<p>Step 3: Return the result:</p>
<ul>
<li>If there are no zeros in the grid, return the size of the entire grid (i.e., <code>rows * columns</code>).</li>
<li>Otherwise, return <code>maxIslandSize</code>, the largest island size after flipping a zero.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fFCPs4tS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid and we use a Disjoint Set Union (DSU) data structure to union adjacent <code>1</code>s. For each cell, we check its four neighboring cells, which is a constant-time operation. The DSU operations, including <code>findRoot</code> and <code>unionNodes</code>, are nearly constant time due to path compression and union by size optimizations. Thus, the first phase contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells and use the DSU to find the roots of neighboring islands. The unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the grid traversal and DSU operations, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the DSU data structure, which stores the parent and size of each cell. Both the <code>parent</code> and <code>islandSize</code> arrays require <span class="math inline">\(O(n \times m)\)</span> space. Additionally, the unordered set used to store unique roots for neighboring islands has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factor is the DSU data structure, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/making-a-large-island/1" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an<strong> n x n </strong>binary matrix<strong> grid[][]</strong>. You are allowed to change at most one<strong> 0</strong> to <strong>1</strong>.&nbsp;</span><span style="font-size: 18.6667px;">A group of <strong>connected 1s</strong> forms an island. Two 1s are connected if they share one of their sides with each other.</span></p>
<p><span style="font-size: 14pt;">Return the size of the <strong>largest island</strong> in the grid after applying this operation.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,0],[0,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">3</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change any one 0 to 1 and connect two 1s, then we get an island with area = 3.</span></span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,0]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change the only 0 to 1 and make the island bigger, then we get an island with area = 4.</span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Can't change any 0 to 1, only one island possible with area = 4.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraints:</span></strong></p>
<p><span style="font-size: 18.6667px;">1 &lt;= n &lt;= 500<br />0 &lt;= grid[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-area-of-island/description" target="_blank" rel="noopener noreferrer">Max Area of Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>&#39;s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>

<p>Return <em>the maximum <strong>area</strong> of an island in </em><code>grid</code>. If there is no island, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" style="width: 500px; height: 310px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-recursive-accepted">Approach #1: Depth-First Search (Recursive) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We want to know the area of each connected shape in the grid, then take the maximum of these.</p>
<p>If we are on a land square and explore every square connected to it 4-directionally (and recursively squares connected to those squares, and so on), then the total number of squares explored will be the area of that connected shape.</p>
<p>To ensure we don't count squares in a shape more than once, let's use <code>seen</code> to keep track of squares we haven't visited before. It will also prevent us from counting the same shape more than once.</p>
<p><a href="https://leetcode.com/playground/CQGNqDhr/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns.  We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by the call stack during our recursion.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-iterative-accepted">Approach #2: Depth-First Search (Iterative) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can try the same approach using a stack-based, (or &quot;iterative&quot;) depth-first search.</p>
<p>Here, <code>seen</code> will represent squares that have either been visited or are added to our list of squares to visit (<code>stack</code>). For every starting land square that hasn't been visited, we will explore 4-directionally around it, adding land squares that haven't been added to <code>seen</code> to our <code>stack</code>.</p>
<p>On the side, we'll keep a count <code>shape</code> of the total number of squares seen during the exploration of this shape. We'll want the running max of these counts.</p>
<p><a href="https://leetcode.com/playground/khZHhSir/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns. We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by <code>stack</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-spanning-tree-stability-with-upgrades/description" target="_blank" rel="noopener noreferrer">Maximize Spanning Tree Stability with Upgrades</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, representing <code>n</code> nodes numbered from 0 to <code>n - 1</code> and a list of <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code>:</p>

<ul>
	<li><code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</li>
	<li><code>s<sub>i</sub></code> is the strength of the edge.</li>
	<li><code>must<sub>i</sub></code> is an integer (0 or 1). If <code>must<sub>i</sub> == 1</code>, the edge <strong>must</strong> be included in the<strong> </strong><strong>spanning tree</strong>. These edges <strong>cannot</strong> be <strong>upgraded</strong>.</li>
</ul>

<p>You are also given an integer <code>k</code>, the <strong>maximum</strong> number of upgrades you can perform. Each upgrade <strong>doubles</strong> the strength of an edge, and each eligible edge (with <code>must<sub>i</sub> == 0</code>) can be upgraded <strong>at most</strong> once.</p>

<p>The <strong>stability</strong> of a spanning tree is defined as the <strong>minimum</strong> strength score among all edges included in it.</p>

<p>Return the <strong>maximum</strong> possible stability of any valid spanning tree. If it is impossible to connect all nodes, return <code>-1</code>.</p>

<p><strong>Note</strong>: A <strong>spanning tree</strong> of a graph with <code>n</code> nodes is a subset of the edges that connects all nodes together (i.e. the graph is <strong>connected</strong>) <em>without</em> forming any cycles, and uses <strong>exactly</strong> <code>n - 1</code> edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2,1],[1,2,3,0]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Edge <code>[0,1]</code> with strength = 2 must be included in the spanning tree.</li>
	<li>Edge <code>[1,2]</code> is optional and can be upgraded from 3 to 6 using one upgrade.</li>
	<li>The resulting spanning tree includes these two edges with strengths 2 and 6.</li>
	<li>The minimum strength in the spanning tree is 2, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,4,0],[1,2,3,0],[0,2,1,0]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Since all edges are optional and up to <code>k = 2</code> upgrades are allowed.</li>
	<li>Upgrade edges <code>[0,1]</code> from 4 to 8 and <code>[1,2]</code> from 3 to 6.</li>
	<li>The resulting spanning tree includes these two edges with strengths 8 and 6.</li>
	<li>The minimum strength in the tree is 6, which is the maximum possible stability.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,1,1],[1,2,1,1],[2,0,1,1]], k = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>All edges are mandatory and form a cycle, which violates the spanning tree property of acyclicity. Thus, the answer is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, s<sub>i</sub>, must<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= s<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>must<sub>i</sub></code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-fish-in-a-grid/description" target="_blank" rel="noopener noreferrer">Maximum Number of Fish in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>
	<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>
</ul>

<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>

<ul>
	<li>Catch all the fish at cell <code>(r, c)</code>, or</li>
	<li>Move to any adjacent <strong>water</strong> cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>

<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example2.png" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> of size <code>m x n</code>, where each cell <code>(r, c)</code> can either be land or water. The grid is represented by an integer matrix where:</p>
<ul>
<li>A land cell is denoted by <code>0</code>.</li>
<li>A water cell contains a number of fish, indicated by a value greater than <code>0</code>.</li>
</ul>
<p>We need to find the largest number of fish that a fisher can collect by starting at an optimal water cell and moving to connected water cells. The fisher can collect fish from any water cell they start from, and then they can move to any adjacent water cell to continue collecting more fish. The fisher can repeat this operation as many times as needed, moving between connected water cells to collect fish.</p>
<p>This problem is closely related to the &quot;<a href="https://leetcode.com/problems/max-area-of-island/description/">Max Area of Island</a>&quot; problem, which also deals with connected regions in a grid. However, the key difference here is that in this problem, the value in each water cell is not simply <code>1</code>, but rather the number of fish in that cell, which adds an extra layer of complexity.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can think of the grid as a map of a graph, where each water cell is a node connected to other water cells around it, either up, down, left, or right. The water cells are grouped together, forming distinct regions that are separated by land cells. The goal is to find the largest group of connected water cells, which represents the region with the most fish.</p>
<p>To solve this, we can use a <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search (DFS)</a>. DFS works by exploring every connected node (in this case, the water cells) starting from a given cell. When we find a water cell, we start a DFS from that cell. The DFS will look at all neighboring water cells (in all four directions), marking them as visited to ensure we donâ€™t count them again.</p>
<p>As we traverse each connected water region, we also keep a running total of the number of fish in that region. This means that for every new DFS call, we add up all the fish in that group of connected cells.</p>
<p>After exploring all the water cells in one region, we move on to the next unvisited water cell and repeat the process. While doing this, we always track the greatest number of fish encountered in any of the regions. By the time we finish going through the whole grid, we will have found the region with the most fish and that will be our result.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>Initialize <code>m</code> and <code>n</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li>Create a 2D vector <code>visited</code> of size <code>m x n</code> to track visited cells, initialized to <code>false</code>.</li>
<li>Initialize <code>result</code> to <code>0</code>, which will store the maximum fish count from any connected component.</li>
<li>Iterate through each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell is a water cell (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int r, int c)</code></p>
<ol>
<li>If the current cell <code>(r, c)</code>, is out of bounds, is a land cell (<code>grid[r][c] == 0</code>), or, has already been visited (<code>visited[r][c] == true</code>), return <code>0</code>.</li>
<li>Mark the current cell <code>(r, c)</code> as visited by setting <code>visited[r][c] = true</code>.</li>
<li>Recursively calculate the total fish count from all connected water cells:
<ul>
<li>Call <code>countFishes</code> for the cells to the right, left, bottom, and top.</li>
</ul>
</li>
<li>Return the sum of fish in the current cell (<code>grid[r][c]</code>) and the fish counts from all valid neighboring cells.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VHJhrpCk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m x n</code> cells. For each cell, it performs a depth-first search (DFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m x n</code> to track visited cells. Additionally, the depth-first search (DFS) can recurse to explore all connected cells, contributing to the space complexity. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similar to Depth-First Search (DFS), we can also use a <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search (BFS)</a> to explore the grid and find the connected water regions. BFS works by exploring all neighboring cells at the present depth level before moving on to cells at the next level. This means that BFS explores level by level, starting from a water cell and expanding outward to its neighboring water cells.</p>
<p>We start by iterating through the grid and whenever we encounter a water cell that hasn't been visited yet, we initiate a BFS. From that cell, we explore its four neighboring cells (up, down, left, right), checking if they are also water cells and marking them as visited. This continues until all water cells in the current region have been explored.</p>
<p>While performing the BFS, we accumulate the number of fish in the connected region by adding up the values of all the visited water cells. This ensures that we get the total number of fish in that region.</p>
<p>After exploring all neighboring water cells in the current region, we move on to the next unvisited water cell and repeat the BFS process. Throughout the BFS traversal, we keep track of the largest fish count encountered. By the end of the grid traversal, we will have identified the connected water region with the most fish and return that as our result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li><code>result</code> to store the maximum fish count found in any connected component. Initialized to <code>0</code>.</li>
<li><code>visited</code> as a 2D matrix of size <code>numRows x numCols</code> to track visited cells, initialized to <code>false</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the Grid:</p>
<ul>
<li>For each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell contains water (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Result:</p>
<ul>
<li>After iterating through all cells, return the <code>result</code>.</li>
</ul>
</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int row, int col)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the dimensions of the grid.</li>
<li><code>fishCount</code> to accumulate the number of fish in the connected component, initialized to <code>0</code>.</li>
<li><code>q</code> as a queue for BFS traversal starting from the initial cell <code>(row, col)</code>.</li>
</ul>
</li>
<li>
<p>BFS Traversal:</p>
<ul>
<li>Push the initial cell <code>(row, col)</code> onto the queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Dequeue the front element to get current coordinates <code>(row, col)</code>.</li>
<li>Add the fish count from the current cell to <code>fishCount</code>.</li>
<li>Explore all four directions (up, down, left, right) for connected water cells:
<ul>
<li>If the neighboring cell is within bounds, contains water, and hasn't been visited, add it to the queue and mark it as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Fish Count:</p>
<ul>
<li>After exploring all possible connected cells, return <code>fishCount</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/afuZyzJQ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m \cdot n</code> cells. For each cell, it performs a Breadth-first search (BFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m \cdot n</code> to track visited cells. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find-algorithm">Approach 3: Union Find Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving problems based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union-find data structure or merge-find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. More specifically, it allows us to perform two main operations:</p>
<ol>
<li><strong>Find</strong>: This operation helps us determine which set a particular element belongs to. In our case, it will help us check if two water cells are part of the same connected region.</li>
<li><strong>Union</strong>: This operation merges two sets into one. It allows us to combine two connected water cells into the same region.</li>
</ol>
<p>For this problem, we can think of each water cell as an individual set, and the goal is to merge them into larger sets based on their connectivity. As we perform the &quot;Union&quot; operation, we also need to keep track of the total number of fish in each connected component (group of connected water cells).</p>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the maximum sum of fishes among all the connected components formed in the graph with water cells acting as nodes and an edge between directly connected cells.</p>
<p>First, we treat each water cell as its own separate component, initializing a structure to store the number of fish in each component. Initially, each water cell holds its own fish count.</p>
<p>We then iterate over all the cells in the grid. For each water cell, we check its four neighbors (up, down, left, right). If a neighboring cell is also water, we perform a &quot;Union&quot; operation to merge their components, effectively connecting the two cells. As we do this, we update the fish count for the newly merged component by adding the fish counts from both cells.</p>
<p>After merging the cells, we keep track of the maximum fish count encountered in any connected component. This can be done by maintaining a separate array (let's call it <code>fishes</code>) where each entry corresponds to the total fish count of a particular connected component.</p>
<p>At the end of this process, the largest value in the <code>totalFish</code> array will give us the largest sum of fish in any connected component.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ul>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Determine the number of rows (<code>rows</code>) and columns (<code>cols</code>) in the grid.</li>
<li>Compute the total number of cells (<code>totalCells</code>) which is <code>rows * cols</code>.</li>
</ul>
</li>
<li>
<p>Union-Find Initialization:</p>
<ul>
<li>Create arrays <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>:
<ul>
<li><code>parent</code> keeps track of the root for each cell.</li>
<li><code>componentSize</code> tracks the size of the component (number of cells) each root represents.</li>
<li><code>totalFish</code> tracks the total fish count in the connected component represented by each root.</li>
</ul>
</li>
<li>Use <code>iota(parent.begin(), parent.end(), 0)</code> to initialize <code>parent</code> such that each cell is its own parent initially.</li>
</ul>
</li>
<li>
<p>Setting Initial Fish Count:</p>
<ul>
<li>Traverse the grid and populate the <code>totalFish</code> array with the fish count of each cell.</li>
</ul>
</li>
<li>
<p>Union Operation:</p>
<ul>
<li>Use direction vectors <code>dRow</code> and <code>dCol</code> to explore neighboring cells (right, left, down, up).</li>
<li>For each water cell (<code>grid[row][col] &gt; 0</code>), union its connected neighbors using the <code>unionComponents</code> function.</li>
</ul>
</li>
<li>
<p>After processing all cells and merging components, iterate through the <code>totalFish</code> array to find the maximum fish count among all components that have a unique root.</p>
</li>
<li>
<p>Return the maximum fish count found.</p>
</li>
</ul>
<p>Helper Function: <code>unionComponents(vector&lt;int&gt;&amp; parent, vector&lt;int&gt;&amp; componentSize, vector&lt;int&gt;&amp; totalFish, int x, int y)</code></p>
<ul>
<li>
<p>Find the root of <code>x</code>: Use <code>findParent</code> to get the root of component containing <code>x</code>.</p>
</li>
<li>
<p>Find the root of <code>y</code>: Use <code>findParent</code> to get the root of component containing <code>y</code>.</p>
</li>
<li>
<p>Union by size: If the roots are different, attach the smaller tree under the root of the larger tree, ensuring optimization.</p>
</li>
<li>
<p>Update Component Size and Fish Count: After merging, update the size of the new component and the total fish count accordingly.</p>
</li>
</ul>
<p>Helper Function: <code>findParent(vector&lt;int&gt;&amp; parent, int x)</code></p>
<ul>
<li>If <code>parent[x]</code> equals <code>x</code>, then <code>x</code> is its own root. Otherwise, recursively find the parent of <code>parent[x]</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/goJL6dcH/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span></p>
<p>The outer loop iterates over all cells in the grid, which takes <span class="math inline">\(O(n \cdot m)\)</span> time.</p>
<p>For each cell, the algorithm checks its four neighbors (right, left, down, up), which is a constant <span class="math inline">\(O(4)\)</span> operation.</p>
<p>The <code>findParent</code> and <code>unionComponents</code> operations are performed using the Union-Find data structure with path compression and union by size. These operations have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function, which is very small and can be considered almost constant.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses three auxiliary arrays: <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>, each of size <span class="math inline">\(n \cdot m\)</span>.</p>
<p>The space required for these arrays is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Additionally, the recursion stack for the <code>findParent</code> function is bounded by the height of the Union-Find tree, which is <span class="math inline">\(O(\alpha(n \cdot m))\)</span> due to path compression. However, this is negligible compared to the space used by the arrays.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-points-from-grid-queries/description" target="_blank" rel="noopener noreferrer">Maximum Number of Points From Grid Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>

<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>

<ul>
	<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>
	<li>Otherwise, you do not get any points, and you end this process.</li>
</ul>

<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>

<p>Return <em>the resulting array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/image1.png" style="width: 571px; height: 152px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
<strong>Output:</strong> [5,8,1]
<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" />
<pre>
<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> matrix <code>grid</code> and an array of queries, <code>queries</code>. For each query, we attempt to collect as many points as possible while following specific movement rules that dictate how far we can traverse the grid.</p>
<p>For each <code>queries[i]</code>, we begin at the top-left corner of the grid. We are allowed to move in four directions: up, down, left, and right. The primary condition governing movement is the comparison between <code>queries[i]</code> and the value of the current cell:</p>
<ol>
<li>
<p>If <code>queries[i]</code> is strictly greater than the value of the current cell, then:</p>
<ul>
<li>If this is the first time visiting the cell, we earn one point.</li>
<li>We can then move to any of the adjacent cells (if they exist).</li>
</ul>
</li>
<li>
<p>If <code>queries[i]</code> is less than or equal to the value of the current cell, then:</p>
<ul>
<li>We cannot proceed further from this cell.</li>
<li>The process for this query terminates immediately.</li>
</ul>
</li>
</ol>
<p>The final result for <code>queries[i]</code> is the number of unique cells we were able to collect points from.</p>
<blockquote>
<p>Note: Each query starts independently, meaning that the traversal for one query does not affect the traversal for another.</p>
</blockquote>
<p>Another difficult but extremely practical way to phrase this problem is to imagine you're at a buffet, where you can only eat dishes that are under a certain calorie count. Each dish represents a number in the grid, and your queries are your calorie limits. You want to know how many dishes you can indulge in without exceeding your limit. The algorithm helps you quickly determine how many dishes fit your criteria, allowing you to make the most of your buffet experience! Sometimes, the representation of data is more important than the data itself.</p>
<p>To solve this problem, we need a solid understanding of BFS, priority queues, and disjoint union. While we will explain the application of these concepts, we will not go in-depth into their theoretical aspects and their basic structure.</p>
<p>For a deeper understanding of the theory or to learn how the general conceptual implementation works, please check out the following explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS and Priority Queue</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union Find</a></li>
<li><a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a></li>
</ul>
<hr />
<h3 id="approach-1-brute-force-tle">Approach 1: Brute Force (TLE)</h3>
<h4 id="intuition">Intuition</h4>
<p>For each query value, we need to determine how many cells in the grid have a value strictly less than the query while ensuring we only move to adjacent cells. This naturally forms a graph traversal problem where each cell is treated as a node connected to its adjacent cells. Since we are interested in finding all reachable nodes that satisfy a condition, Breadth-First Search (BFS) is a suitable choice. BFS explores all nodes at the current level before moving to the next, ensuring we do not miss any reachable cells that meet the criteria.</p>
<p>For each query, we begin at the <code>(0,0)</code> cell and initialize a queue for BFS traversal. We also maintain a <code>visited</code> boolean matrix to ensure we do not revisit cells. The traversal continues as long as there are unprocessed cells in the queue. At each step, we check if the current cellâ€™s value is greater than or equal to the query value. If it is, we cannot proceed further from this cell. Otherwise, we count the cell as visited, increment our result, and attempt to move to its four adjacent cells (up, down, left, and right). Any adjacent cell that has not been visited and has a value strictly less than the query is added to the queue.</p>
<p>Since each query is independent, we repeat this process for each of them. The final result for each query is the total number of unique cells that we were able to visit while following the movement constraints.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Iterate over each query:</p>
<ul>
<li>
<p>Extract <code>queryValue</code> from <code>queries</code>.</p>
</li>
<li>
<p>Initialize a BFS queue starting from <code>(0,0)</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track visited cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Initialize <code>points</code> to count valid cells.</p>
</li>
<li>
<p>Perform BFS:</p>
<ul>
<li>Get the current queue size to process all elements at this level.</li>
<li>Iterate over the queue:
<ul>
<li>Extract <code>currentRow</code> and <code>currentCol</code> from the front.</li>
<li>If <code>grid[currentRow][currentCol] &gt;= queryValue</code>, skip processing.</li>
<li>Otherwise, increment <code>points</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds, not visited, and value is <code>&lt; queryValue</code>, mark <code>(newRow, newCol)</code> as visited and add it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Store <code>points</code> in <code>result</code> at the corresponding query index.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jtezm3QA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot m)\)</span></p>
<p>The outer loop runs <span class="math inline">\(k\)</span> times, once for each query. In each iteration, a BFS is performed on the grid. In the worst case, the BFS will visit every cell in the grid, which is <span class="math inline">\(n \cdot m\)</span> cells. Therefore, the time complexity for each query is <span class="math inline">\(O(n \cdot m)\)</span>, and for all queries, it becomes <span class="math inline">\(O(k \cdot n \cdot m)\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor, which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by the <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>. This matrix is used to keep track of visited cells during the BFS traversal.</p>
<p>The BFS queue can also hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case (e.g., when all cells are part of the BFS traversal). Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-queries--min-heap-expansion">Approach 2: Sorting Queries + Min-Heap Expansion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we restart the search from the top-left corner for every query, treating each query as an independent problem. This results in a significant amount of redundant work because many queries share overlapping information. If a smaller query has already determined that certain cells are accessible, then a larger query should be able to reuse that information instead of starting from scratch. This suggests that instead of treating each query separately, we can process them in an order that allows us to build on previously discovered results, avoiding unnecessary recomputation.</p>
<p>A natural way to achieve this is to <strong>sort the queries in increasing order</strong> while keeping track of their original indices. By doing this, we ensure that when we process a query, all smaller queries have already been resolved. This allows us to maintain a growing region of accessible cells rather than restarting the search for each query.</p>
<p>To efficiently manage this expanding region, we use a <strong>min-heap (priority queue)</strong>. The heap allows us to always expand from the lowest-value cell first, ensuring that we process cells in the correct order. We begin by inserting the top-left cell <code>(grid[0][0], (0,0))</code> into the heap.</p>
<p>As long as the smallest cell in the heap has a value less than the current query, we remove it from the heap, mark it as visited, and attempt to expand outward by pushing all its unvisited neighbors into the heap. Since the heap maintains the smallest-value cell at the top, this ensures that we always expand the lowest-value region before moving to higher values. If the smallest cell's value is greater than or equal to the current query's value, we store the current count of reachable cells in the answer array and continue expanding with the next query's value as the new threshold.</p>
<p>By the time we process a query, all the cells that could have been visited with smaller query values have already been handled. This allows us to directly store the number of reachable cells without restarting the traversal. Instead of performing redundant BFS searches for each query, we maintain a continuous expansion process, ensuring that each cell is processed only once.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Create a <code>sortedQueries</code> array to store queries along with their original indices.</p>
</li>
<li>
<p>Sort <code>sortedQueries</code> by query values in ascending order.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) to expand cells in increasing order of <code>grid</code> values.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track processed cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Push <code>{grid[0][0], {0, 0}}</code> into <code>minHeap</code> to start expansion.</p>
</li>
<li>
<p>Initialize <code>totalPoints</code> to count valid cells.</p>
</li>
<li>
<p>Iterate over sorted queries:</p>
<ul>
<li>Extract <code>queryValue</code> and <code>queryIndex</code>.</li>
<li>Expand cells while <code>minHeap</code> contains values <code>&lt; queryValue</code>:
<ul>
<li>Pop the smallest <code>cellValue</code> and its position.</li>
<li>Increment <code>totalPoints</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds and not visited, push <code>{grid[newRow][newCol], {newRow, newCol}}</code> into <code>minHeap</code> and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>totalPoints</code> in <code>result</code> at the corresponding query index.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3F8Ff5Ud/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span></p>
<p>The algorithm first sorts the <code>k</code> queries, which takes <span class="math inline">\(O(k \log k)\)</span> time. Then, for each query, it processes cells using a min-heap. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed and pushed into the heap. Each heap operation (push or pop) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, processing all cells takes <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m + k)\)</span></p>
<p>The space complexity is dominated by:</p>
<ol>
<li>The <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The min-heap, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case.</li>
<li>The <code>sortedQueries</code> vector, which stores <code>k</code> pairs of values and indices.</li>
</ol>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m + k)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-priority-queue-with-binary-search">Approach 3: Using Priority Queue with Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we processed queries sequentially and used a min-heap to expand the reachable region in increasing order, allowing us to efficiently determine the number of points collected for each query. In this approach, we will separate the precomputation step from the answer calculation to improve algorithmic clarity.</p>
<p>To implement this, we can preprocess the grid <strong>once</strong> and store the results in a structured way so that queries can be answered in constant or logarithmic time. The key insight is that every cell in the grid has a <strong>minimum value threshold</strong> that must be met in order for it to be reached. If we can determine the smallest query value required to reach each number of points, we can use <strong>binary search</strong> to efficiently answer all queries.</p>
<p>So we will begin by treating this as a shortest-path problem where we want to determine the minimum &quot;effort&quot; required to reach each cell. We can use <strong>Dijkstraâ€™s algorithm</strong> with a min-heap to explore the grid in order of increasing cost. Each cell <code>(i, j)</code> is processed in order of its minimum required value, and we update its neighbors with the maximum value seen along the way. This ensures that we always determine the optimal way to reach a cell.</p>
<p>Thus, our approach will be divided into three key steps:</p>
<ol>
<li>Reformulating the Problem as a Shortest-Path Search</li>
<li>Running Dijkstraâ€™s Algorithm</li>
<li>Answering Queries Using Binary Search</li>
</ol>
<h5 id="step-1-reformulating-the-problem-as-a-shortest-path-search"><strong>Step 1: Reformulating the Problem as a Shortest-Path Search</strong></h5>
<p>Instead of handling each query separately, we treat the grid as a <strong>weighted graph</strong> where each cell <code>(i, j)</code> has a weight equal to <code>grid[i][j]</code>. The goal is to expand outwards from <code>(0,0)</code>, adding cells in increasing order of their values. We need to determine <strong>the minimum effort required to reach each cell</strong>, which means that a Dijkstra-like algorithm is appropriate.</p>
<p>We use a min-heap (priority queue) to always expand the cell with the lowest current value. Each time we expand to a new cell, we record the maximum value encountered along that path. This ensures that we always determine the optimal way to reach a cell before processing its neighbors.</p>
<p>To keep track of how many points can be collected for any given query threshold, we maintain an array <code>thresholdForMaxPoints</code>, where <code>thresholdForMaxPoints[k]</code> stores the <strong>smallest query value</strong> required to collect <code>k</code> points.</p>
<h5 id="step-2-running-dijkstras-algorithm"><strong>Step 2: Running Dijkstraâ€™s Algorithm</strong></h5>
<p>We begin by initializing a min-heap with the starting cell <code>(0,0)</code>, assigning it a value equal to <code>grid[0][0]</code>. This heap will allow us to always expand towards the next reachable cell with the smallest value, ensuring that we process cells in the correct order.</p>
<p>As we expand outward, we repeatedly extract the smallest value from the heap, which represents the next cell to be processed. From there, we attempt to move to the neighboring cells, as long as they are not already visitedâ€” this guarantees that we always find the optimal path to reach it.</p>
<p>For each newly reached cell <code>(i, j)</code>, we compute the minimum threshold required to access it. This is determined by taking the maximum value encountered along the path leading to that cell. In other words, we track the largest value that must be surpassed in order to reach <code>(i, j)</code>.</p>
<p>As we continue expanding, we maintain an array <code>thresholdForMaxPoints</code>, where each entry records the smallest query value required to collect a given number of points. Each time we reach a new cell, we store its threshold in this array, associating it with the number of cells we have accessed so far.</p>
<p>By the end of this process, <code>thresholdForMaxPoints[k]</code> holds the <strong>minimum query value</strong> needed to collect exactly <code>k</code> points.</p>
<h5 id="step-3-answering-queries-using-binary-search"><strong>Step 3: Answering Queries Using Binary Search</strong></h5>
<p>Once we have preprocessed the grid, answering a query reduces to a simple binary search on <code>thresholdForMaxPoints</code>. Since we stored thresholds in increasing order, binary search allows us to determine in <strong>logarithmic time</strong> how many points can be collected for a given query.</p>
<p>For a query <code>threshold</code>, we search for the <strong>largest index <code>k</code></strong> such that <code>thresholdForMaxPoints[k] &lt; threshold</code>. The answer to the query is simply <code>k</code>, the number of points that can be collected.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2503/approach3.json:630,940!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define <code>DIRECTIONS</code> to facilitate movement in four directions.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Get <code>rowCount</code> and <code>colCount</code> from <code>grid</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Create <code>thresholdForMaxPoints</code>, where index <code>i</code> stores the minimum query value required to reach <code>i</code> cells.</p>
</li>
<li>
<p>Create <code>minValueToReach</code>, where <code>minValueToReach[i][j]</code> holds the maximum value encountered to reach <code>(i, j)</code>, initialized to <code>MAX_VALUE</code>.</p>
</li>
<li>
<p>Run Dijkstraâ€™s algorithm:</p>
<ul>
<li>Use <code>minHeap</code> (min-priority queue) to explore cells in increasing order of encountered values.</li>
<li>Start from <code>(0,0)</code>, setting <code>minValueToReach[0][0] = grid[0][0]</code> and pushing it into <code>minHeap</code>.</li>
<li>While <code>minHeap</code> is not empty:
<ul>
<li>Extract the cell with the smallest encountered value.</li>
<li>Store the encountered value in <code>thresholdForMaxPoints[++visitedCells]</code>.</li>
<li>Explore four possible directions:
<ul>
<li>If the adjacent cell <code>(newRow, newCol)</code> is within bounds and unvisited:
<ul>
<li>Update its <code>minValueToReach</code> as the maximum of the value to reach the current cell and  <code>grid[newRow][newCol]</code>.</li>
<li>Push it into <code>minHeap</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Process queries using binary search:</p>
<ul>
<li>For each <code>queries[i]</code>, find the rightmost <code>mid</code> where <code>thresholdForMaxPoints[mid] &lt; threshold</code>.</li>
<li>Initialize <code>left = 0</code>, <code>right = totalCells</code>.</li>
<li>Perform binary search:
<ul>
<li>Compute <code>mid = (left + right + 1) / 2</code>.</li>
<li>If <code>thresholdForMaxPoints[mid] &lt; threshold</code>, move <code>left = mid</code>.</li>
<li>Otherwise, adjust <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Store <code>left</code> in <code>result[i]</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YbXEgeXX/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span></p>
<p>The algorithm uses a min-heap to perform a modified Dijkstra's traversal. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed, and each heap operation (insertion or extraction) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>For each of the <code>k</code> queries, a binary search is performed on the <code>thresholdForMaxPoints</code> array, which has a size of <span class="math inline">\((n \cdot m) + 1\)</span>. Each binary search operation takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(k \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by:</p>
<ul>
<li>The <code>minHeap</code>, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells.</li>
<li>The <code>minValueToReach</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The <code>thresholdForMaxPoints</code> array, which is of size <span class="math inline">\((n \cdot m) + 1\)</span>.</li>
</ul>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of handling queries one by one, we can take a different approach where we process all grid cells first and answer queries afterward. This allows us to efficiently determine the number of reachable points for each query without having to traverse the grid multiple times.</p>
<p>To better understand this approach, let's reiterate our previous observation in a slightly different way. Think about what each query is asking. A query provides a threshold value and asks how many cells in the grid can be reached from the top-left corner <code>(0,0)</code>, while ensuring that all visited cells have values strictly less than this threshold. Instead of iterating over the grid every time a query is given, we can reverse the problem: first process the grid in increasing order of cell values, then efficiently answer all queries using this precomputed information.</p>
<p>To do this, we first extract all the grid cells and sort them in ascending order based on their values. By processing these cells in this order, we can simulate how the reachable area grows as the threshold increases. We maintain a <strong>disjoint set union (Union-Find) data structure</strong> to dynamically merge connected components as we encounter new cells with increasing values.</p>
<p>As we iterate through the sorted grid cells, we add each cell to our Union-Find structure. Whenever we add a cell, we also check its four adjacent neighbors (up, down, left, and right). If a neighbor has already been processed, we merge the current cell with its neighboring cell in the Union-Find structure. This ensures that, at any given moment, all connected components represent regions of the grid where all cells have values strictly less than the current threshold.</p>
<p>At the same time, we also sort the queries in ascending order based on their values. As we process each query, we continue adding cells to our Union-Find structure until the current cell values reach or exceed the query threshold. Once we finish adding all the relevant cells for a query, we determine how many of these cells are reachable from <code>(0,0)</code>. Since the Union-Find structure keeps track of the size of connected components, we can efficiently find the number of reachable cells by checking the size of the component that contains <code>(0,0)</code>.</p>
<p>If the query value is greater than <code>grid[0][0]</code>, then the number of reachable cells is simply the size of the connected component containing <code>(0,0)</code>. Otherwise, no additional cells are reachable, and the answer for this query is <code>0</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>Cell(row, col, value)</code> to represent grid cells and <code>Query(index, value)</code> to store queries with their original indices.</p>
</li>
<li>
<p>Initialize <code>ROW_DIRECTIONS</code> and <code>COL_DIRECTIONS</code> for moving in four directions.</p>
</li>
<li>
<p>Extract <code>rowCount</code> and <code>colCount</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Sort queries:</p>
<ul>
<li>Store each query as a <code>Query</code> object in <code>sortedQueries</code>.</li>
<li>Sort <code>sortedQueries</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Sort grid cells:</p>
<ul>
<li>Store each cell as a <code>Cell</code> object in <code>sortedCells</code>.</li>
<li>Sort <code>sortedCells</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Initialize <code>UnionFind</code> data structure for dynamic connectivity.</p>
</li>
<li>
<p>Process queries:</p>
<ul>
<li>Iterate over <code>sortedQueries</code>, maintaining an index <code>cellIndex</code> to track which cells have been processed.</li>
<li>While <code>sortedCells[cellIndex].value &lt; query.value</code>, mark the cell as processed and merge it with already processed adjacent cells using <code>UnionFind.union()</code>.</li>
<li>Compute the size of the connected component containing <code>(0,0)</code>, storing the result for <code>query.index</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h5 id="unionfind-class"><strong><code>UnionFind</code> Class:</strong></h5>
<ul>
<li>
<p>Define <code>UnionFind</code> class for disjoint set operations.</p>
</li>
<li>
<p>Declare <code>parent</code> array to track the representative of each set.</p>
</li>
<li>
<p>Declare <code>size</code> array to store the size of each set.</p>
</li>
<li>
<p>Constructor (<code>UnionFind(int n)</code>):</p>
<ul>
<li>Initialize <code>parent</code> with <code>-1</code>, indicating each element is its own set.</li>
<li>Initialize <code>size</code> to <code>1</code>, as each set initially has one element.</li>
</ul>
</li>
<li>
<p><code>find(int node)</code>: Implements path compression to optimize lookup.</p>
<ul>
<li>If <code>parent[node]</code> is <code>-1</code>, it is the root and returned.</li>
<li>Otherwise, recursively find the root and apply path compression (<code>parent[node] = find(parent[node])</code>).</li>
</ul>
</li>
<li>
<p><code>union(int nodeA, int nodeB)</code>:</p>
<ul>
<li>Find roots of <code>nodeA</code> and <code>nodeB</code>.</li>
<li>If both nodes share the same root, they are already in the same set, return <code>false</code>.</li>
<li>Otherwise, perform union by size:
<ul>
<li>Attach the smaller tree to the larger tree.</li>
<li>Update <code>size</code> accordingly.</li>
</ul>
</li>
<li>Return <code>true</code> to indicate a successful union.</li>
</ul>
</li>
<li>
<p><code>getSize(int node)</code>:</p>
<ul>
<li>Find the root of <code>node</code> and return the size of its set.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/8CUbzoZh/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span></p>
<p>The time complexity arises from several steps. First, sorting the <code>queries</code> array takes <span class="math inline">\(O(k \log k)\)</span>. Second, sorting the <code>sortedCells</code> array takes <span class="math inline">\(O((n \cdot m) \log (n \cdot m))\)</span>. Finally, processing each query involves iterating through the cells and performing union-find operations.</p>
<p>The union-find operations, with path compression and union by size, have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function (practically constant).</p>
<p>Since we process up to <code>totalCells</code> cells for each query, the total time for all queries is <span class="math inline">\(O(k \cdot \alpha(n \cdot m))\)</span>. Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((n \cdot m) + k)\)</span></p>
<p>The space complexity is dominated by the <code>sortedQueries</code> array, which takes <span class="math inline">\(O(k)\)</span> space, the <code>sortedCells</code> array, which takes <span class="math inline">\(O(n \cdot m)\)</span> space, and the <code>UnionFind</code> data structure, which uses <span class="math inline">\(O(n \cdot m)\)</span> space for the <code>parent</code> and <code>size</code> arrays. Therefore, the overall space complexity is <span class="math inline">\(O((n \cdot m) + k)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-segment-sum-after-removals/description" target="_blank" rel="noopener noreferrer">Maximum Segment Sum After Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums</code> and <code>removeQueries</code>, both of length <code>n</code>. For the <code>i<sup>th</sup></code> query, the element in <code>nums</code> at the index <code>removeQueries[i]</code> is removed, splitting <code>nums</code> into different segments.</p>

<p>A <strong>segment</strong> is a contiguous sequence of <strong>positive</strong> integers in <code>nums</code>. A <strong>segment sum</strong> is the sum of every element in a segment.</p>

<p>Return<em> an integer array </em><code>answer</code><em>, of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>maximum</strong> segment sum after applying the </em><code>i<sup>th</sup></code> <em>removal.</em></p>

<p><strong>Note:</strong> The same index will <strong>not</strong> be removed more than once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
<strong>Output:</strong> [14,7,2,2,0]
<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].
Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].
Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. 
Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. 
Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [14,7,2,2,0].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,11,1], removeQueries = [3,2,1,0]
<strong>Output:</strong> [16,5,3,0]
<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].
Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].
Query 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].
Query 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [16,5,3,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length == removeQueries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>
	<li>All the values of <code>removeQueries</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/min-cost-to-connect-all-points/description" target="_blank" rel="noopener noreferrer">Min Cost to Connect All Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>points</code> representing integer coordinates of some points on a 2D-plane, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>The cost of connecting two points <code>[x<sub>i</sub>, y<sub>i</sub>]</code> and <code>[x<sub>j</sub>, y<sub>j</sub>]</code> is the <strong>manhattan distance</strong> between them: <code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>, where <code>|val|</code> denotes the absolute value of <code>val</code>.</p>

<p>Return <em>the minimum cost to make all points connected.</em> All points are connected if there is <strong>exactly one</strong> simple path between any two points.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/d.png" style="width: 214px; height: 268px;" />
<pre>
<strong>Input:</strong> points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
<strong>Output:</strong> 20
<strong>Explanation:</strong> 
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/c.png" style="width: 214px; height: 268px;" />
We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> points = [[3,12],[-2,5],[-4,1]]
<strong>Output:</strong> 18
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= points.length &lt;= 1000</code></li>
	<li><code>-10<sup>6</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>All pairs <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-hamming-distance-after-swap-operations/description" target="_blank" rel="noopener noreferrer">Minimize Hamming Distance After Swap Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays, <code>source</code> and <code>target</code>, both of length <code>n</code>. You are also given an array <code>allowedSwaps</code> where each <code>allowedSwaps[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you are allowed to swap the elements at index <code>a<sub>i</sub></code> and index <code>b<sub>i</sub></code> <strong>(0-indexed)</strong> of array <code>source</code>. Note that you can swap elements at a specific pair of indices <strong>multiple</strong> times and in <strong>any</strong> order.</p>

<p>The <strong>Hamming distance</strong> of two arrays of the same length, <code>source</code> and <code>target</code>, is the number of positions where the elements are different. Formally, it is the number of indices <code>i</code> for <code>0 &lt;= i &lt;= n-1</code> where <code>source[i] != target[i]</code> <strong>(0-indexed)</strong>.</p>

<p>Return <em>the <strong>minimum Hamming distance</strong> of </em><code>source</code><em> and </em><code>target</code><em> after performing <strong>any</strong> amount of swap operations on array </em><code>source</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> source can be transformed the following way:
- Swap indices 0 and 1: source = [<u>2</u>,<u>1</u>,3,4]
- Swap indices 2 and 3: source = [2,1,<u>4</u>,<u>3</u>]
The Hamming distance of source and target is 1 as they differ in 1 position: index 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are no allowed swaps.
The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == source.length == target.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= source[i], target[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= allowedSwaps.length &lt;= 10<sup>5</sup></code></li>
	<li><code>allowedSwaps[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove <strong>exactly one node</strong> from <code>initial</code>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;= n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<p><strong>Intuition</strong></p>
<p>First, let's color (the nodes of) each component of the graph.  We can do this using a depth first search.</p>
<p>Afterwards, notice that if two nodes in <code>initial</code> have the same color (ie., belong to the same component), then removing them from <code>initial</code> won't decrease <code>M(initial)</code>.  This is because the malware will spread to reach every node in this component no matter what.</p>
<p>So, among nodes with a unique color in <code>initial</code>, we will remove the node with the largest component size.  (If there's a tie, we return the smallest index.  Also, if there aren't any nodes with a unique color, we'll just return the smallest index node.)</p>
<p><strong>Algorithm</strong></p>
<p>This algorithm has a few parts:</p>
<ul>
<li>
<p><strong>Coloring each component:</strong>  For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.</p>
</li>
<li>
<p><strong>Size of each color:</strong>  Count the number of occurrences of each color.</p>
</li>
<li>
<p><strong>Find unique colors:</strong>  Look at the colors of nodes in <code>initial</code> to see which nodes have unique colors.</p>
</li>
<li>
<p><strong>Choose answer:</strong>  For each node with a unique color, find the size of that color.  The largest size is selected, with ties broken by lowest node number.</p>
<ul>
<li>If there is no node with a unique color, the answer is <code>min(initial)</code>.</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/cW9BUkVC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-union-find">Approach 2: Union-Find</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>As in <em>Approach 1</em>, it is clear that we will need to consider components of the graph.  A &quot;Disjoint Set Union&quot; (DSU) data structure is ideal for this.</p>
<p>We will skip the explanation of how a DSU structure is implemented.  Please refer to <a href="https://leetcode.com/problems/redundant-connection/solution/">https://leetcode.com/problems/redundant-connection/solution/</a> for a tutorial on DSU.</p>
<p>To our DSU, we can keep a side count of the size of each component.  Whenever we union two components together, the size of those components are added.</p>
<p>With these details neatly handled by our DSU structure, we can continue in a similar manner to <em>Approach 1</em>: for each node in <code>initial</code> with a unique color, we will consider it as a candidate answer.  If no node in <code>initial</code> have a unique color, then we will take <code>min(initial)</code> as the answer.</p>
<p>Note that for brevity, our <code>DSU</code> implementation does not use union-by-rank.  This makes the asymptotic time complexity larger.</p>
<p><a href="https://leetcode.com/playground/ZQNiCZd5/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>graph</code>, as the graph is given in adjacent matrix form.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-malware-spread-ii/description" target="_blank" rel="noopener noreferrer">Minimize Malware Spread II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p>

<p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p>

<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p>

<p>We will remove <strong>exactly one node</strong> from <code>initial</code>, <strong>completely removing it and any connections from this node to any other node</strong>.</p>

<p>Return the node that, if removed, would minimize <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>Output:</strong> 0
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li>All the integers in <code>initial</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-component-cost/description" target="_blank" rel="noopener noreferrer">Minimize Maximum Component Cost</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="331" data-start="85">You are given an undirected connected graph with <code data-end="137" data-start="134">n</code> nodes labeled from 0 to <code data-end="171" data-start="164">n - 1</code> and a 2D integer array <code data-end="202" data-start="195">edges</code> where <code data-end="234" data-start="209">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> denotes an undirected edge between node <code data-end="279" data-start="275">u<sub>i</sub></code> and node <code data-end="293" data-start="289">v<sub>i</sub></code> with weight <code data-end="310" data-start="306">w<sub>i</sub></code>, and an integer <code data-end="330" data-start="327">k</code>.</p>

<p data-end="461" data-start="333">You are allowed to remove any number of edges from the graph such that the resulting graph has <strong>at most</strong> <code data-end="439" data-start="436">k</code> connected components.</p>

<p data-end="589" data-start="463">The <strong>cost</strong> of a component is defined as the <strong>maximum</strong> edge weight in that component. If a component has no edges, its cost is 0.</p>

<p data-end="760" data-start="661">Return the <strong>minimum</strong> possible value of the <strong>maximum</strong> cost among all components <strong data-end="759" data-start="736">after such removals</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,4],[1,2,3],[1,3,2],[3,4,6]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minimizemaximumm.jpg" style="width: 535px; height: 225px;" /></p>

<ul>
	<li data-end="1070" data-start="1021">Remove the edge between nodes 3 and 4 (weight 6).</li>
	<li data-end="1141" data-start="1073">The resulting components have costs of 0 and 4, so the overall maximum cost is 4.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1,5],[1,2,5],[2,3,5]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/19/minmax2.jpg" style="width: 315px; height: 55px;" /></p>

<ul>
	<li data-end="1315" data-start="1251">No edge can be removed, since allowing only one component (<code>k = 1</code>) requires the graph to stay fully connected.</li>
	<li data-end="1389" data-start="1318">That single component&rsquo;s cost equals its largest edge weight, which is 5.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>The input graph is connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-walk-in-weighted-graph/description" target="_blank" rel="noopener noreferrer">Minimum Cost Walk in Weighted Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected weighted graph with <code>n</code> vertices labeled from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given the integer <code>n</code> and an array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between vertices <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with a weight of <code>w<sub>i</sub></code>.</p>

<p>A walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It&#39;s important to note that a walk may visit the same edge or vertex more than once.</p>

<p>The <strong>cost</strong> of a walk starting at node <code>u</code> and ending at node <code>v</code> is defined as the bitwise <code>AND</code> of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is <code>w<sub>0</sub>, w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>k</sub></code>, then the cost is calculated as <code>w<sub>0</sub> &amp; w<sub>1</sub> &amp; w<sub>2</sub> &amp; ... &amp; w<sub>k</sub></code>, where <code>&amp;</code> denotes the bitwise <code>AND</code> operator.</p>

<p>You are also given a 2D array <code>query</code>, where <code>query[i] = [s<sub>i</sub>, t<sub>i</sub>]</code>. For each query, you need to find the minimum cost of the walk starting at vertex <code>s<sub>i</sub></code> and ending at vertex <code>t<sub>i</sub></code>. If there exists no such walk, the answer is <code>-1</code>.</p>

<p>Return <em>the array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> denotes the <strong>minimum</strong> cost of a walk for query </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example1-1.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 351px; height: 141px;" />
<p>To achieve the cost of 1 in the first query, we need to move on the following edges: <code>0-&gt;1</code> (weight 7), <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 1), <code>1-&gt;3</code> (weight 7).</p>

<p>In the second query, there is no walk between nodes 3 and 4, so the answer is -1.</p>

<p><strong class="example">Example 2:</strong></p>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/31/q4_example2e.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 211px; height: 181px;" />
<p>To achieve the cost of 0 in the first query, we need to move on the following edges: <code>1-&gt;2</code> (weight 1), <code>2-&gt;1</code> (weight 6), <code>1-&gt;2</code> (weight 1).</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>0 &lt;= w<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= query.length &lt;= 10<sup>5</sup></code></li>
	<li><code>query[i].length == 2</code></li>
	<li><code>0 &lt;= s<sub>i</sub>, t<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>s<sub>i</sub> !=&nbsp;t<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an undirected weighted graph, represented by an array <code>edges</code>, where <code>edges[i] = [u, v, w]</code> indicates an edge between vertices <code>u</code> and <code>v</code> with weight <code>w</code>. Additionally, we are given an array <code>queries</code>, where <code>queries[i] = [s, t]</code> represents a pair of nodes in the graph.</p>
<p>For each query, our task is to determine the minimum <em>cost</em> of a <em>walk</em> that starts at node <code>s</code> and ends at node <code>t</code>. If no such walk exists, the answer is <code>-1</code>. Let's first define the two key terms involved in this task:</p>
<ul>
<li>A <em>walk</em> in a graph is a sequence of connected vertices and the edges that connect them. Unlike a path, a walk allows both edges and vertices to be repeated.</li>
<li>The <em>cost</em> of a walk is defined as the bitwise AND of the weights of all edges encountered in the walk.</li>
</ul>
<p>First, recall that the bitwise AND operation compares the bits of all the numbers involved and keeps a bit as <code>1</code> only if it is <code>1</code> in every number; otherwise, the bit becomes <code>0</code>. Now, consider the smallest number in the group. It already has some bits set to <code>0</code>. Since the AND operation can only turn bits off (changing <code>1</code> to <code>0</code>, but never <code>0</code> to <code>1</code>), the result can never have more <code>1</code>s than the smallest number. This means the result is always less than or equal to the smallest number.</p>
<p>In this problem, that tells us that adding more edges to a walk can only keep the cost the same or make it smaller. So, to find the minimum cost, we should try to include as many edges as possible in the walk.</p>
<p>Notice that since <code>w AND w = w</code>, revisiting the same edge multiple times does not change the total cost. This can be useful if we need to backtrack to take a different path, in order to visit more edges.</p>
<hr />
<h3 id="approach-1-disjoint-set-union-find">Approach 1: Disjoint-Set (Union-Find)</h3>
<h4 id="intuition">Intuition</h4>
<p>First, let's determine when the answer to a query is <code>-1</code>. This happens when no walk exists between the two nodes, meaning they belong to different connected components.</p>
<blockquote>
<p>A connected component in an undirected graph is a group of nodes where there is a path between any pair of nodes.</p>
</blockquote>
<p>Now, suppose the two nodes belong to the same connected component. What is the minimum cost of a walk connecting them? As mentioned, the optimal walk includes as many edges as possible. Since revisiting an edge does not affect the total score, we can freely traverse the edges of the component, meaning that we can move back and forth to reach all of them. Therefore, the best way to achieve the lowest cost is to visit every edge in the component.</p>
<p>To efficiently find and process the connected components of the graph, we use the Disjoint Set (Union-Find) data structure. This approach relies on two main operations: Union and Find. Each connected component has a representative node, known as its root, which is returned by the Find operation for any node in the group. When we Union two nodes, we merge their entire groups, as now a path exists between every node in one group and every node in the other. To maintain efficiency, the root of the larger group is chosen as the representative of the merged group. This minimizes the time needed for future Find operations by reducing the number of steps required to reach the current representative.</p>
<blockquote>
<p><strong>Disjoint Set (Union-Find)</strong>: For a more comprehensive understanding of the Disjoint Set data structure, check out the <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Disjoint Set/Union-Find Explore Card</a>. This resource provides an in-depth look at Union-Find, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>Once the nodes are grouped into connected components, we calculate the total cost for each component as the bitwise AND of all its edge weights. In the end, the minimum cost of a walk between any two nodes in the same component will be the same and equal to the component's total cost.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Initialize three arrays of size <code>n</code>:
<ul>
<li><code>parent</code>, with all values set to <code>-1</code>, meaning that each node initially forms its own connected component.</li>
<li><code>depth</code>, with all values initialized to <code>0</code>.</li>
<li><code>componentCost</code>, with all values set to the largest integer (<code>2^32 - 1</code>), which is the neutral value for the AND operation, as it contains only <code>1</code>s in its binary representation.</li>
</ul>
</li>
<li>Construct the connected components of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in <code>edges</code>:
<ul>
<li><code>Union(node1, node2)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate the cost of each component:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in <code>edges</code>:
<ul>
<li>Find the root of the edge's component: <code>root = find(node1)</code>.</li>
<li>Update the component cost by performing a bitwise AND: <code>componentCost[root] &amp;= weight</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an array <code>answer</code> to store the answer for each query.
<ul>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If the two nodes belong to different connected components, i.e. <code>find(start) != find(end)</code>, push <code>-1</code> into <code>answer</code>.</li>
<li>Otherwise:
<ul>
<li>Find the root of their component: <code>root = find(start)</code>.</li>
<li>Push <code>componentCost[root]</code> into <code>answer</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="findnode-function"><code>find(node)</code> function:</h5>
<ul>
<li>If <code>parent[node] = -1</code>, <code>node</code> is the representative of its group, so return <code>node</code>.</li>
<li>Otherwise, return <code>find(parent[node])</code> and store the result in <code>parent[node]</code> (path compression).</li>
</ul>
<h5 id="unionnode1-node2-function"><code>Union(node1, node2)</code> function:</h5>
<ul>
<li>Find the root of each node's component: set <code>root1 = find(node1)</code> and <code>root2 = find(node2)</code>.</li>
<li>If the two nodes already belong to the same component, i.e. <code>root1 == root2</code>, return.</li>
<li>Otherwise, if <code>depth[root1] &lt; depth[root2]</code>, swap the two roots to ensure that <code>root1</code> has greater depth.</li>
<li>Merge the two groups, by setting <code>parent[root2] = root1</code>.</li>
<li>If the groups had the same depth, increment the depth of the merged group by <code>1</code> (<code>depth[root1]++</code>).</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MuYneAW2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + q)\)</span></p>
<p>First, we must account for the time needed for the initialization of the <code>parent</code> and <code>size</code> arrays, which is equal to <span class="math inline">\(O(n)\)</span>. The rest of the program consists of three loops. In the first loop, we iterate over all edges to construct the connected components of the graph. With the union-by-rank and path compression optimizations, both Find and Union operations take <span class="math inline">\(O(1)\)</span> time on average (or <span class="math inline">\(a(n)\)</span> time, where <span class="math inline">\(a\)</span> is the inverse Ackermann function that grows really slowly and is considered practically constant), so the time complexity of this loop is <span class="math inline">\(O(m)\)</span>. In the second loop, we call the Find method and update the component's cost in <span class="math inline">\(O(1)\)</span> time for each iteration, making the time complexity of this loop also <span class="math inline">\(O(m)\)</span>. Finally, we answer each query in <span class="math inline">\(O(1)\)</span> time, as it only involves checking if the two nodes belong to the same component and returning a precomputed value if they do. Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n + m + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create three arrays: <code>parent</code>, <code>depth</code>, and <code>componentCost</code>, each of size <span class="math inline">\(n\)</span>. The <code>answer</code> array is the output of the algorithm and doesn't contribute to the auxiliary space complexity, which is therefore equal to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we use Breadth-First Search (BFS) to find the connected components of the graph and calculate their costs. Each component is assigned a unique ID, allowing us to later check if two nodes belong to the same component and retrieve the precomputed cost.</p>
<p>We start a BFS traversal from each unvisited node, marking it as part of a new component with a unique <code>componentId</code>. During the traversal, we mark every node we visit as part of the current component by setting <code>components[node] = componentId</code>. As we explore, we calculate the component's cost by performing a bitwise AND on the weights of the edges we visit. After finishing the traversal of all nodes and edges in the component, we store the calculated cost in a map, where the key is the <code>componentId</code> and the value is the component's cost.</p>
<p>In the worst caseâ€”when each node forms its own connected componentâ€”we will need exactly <code>n</code> distinct <code>componentId</code> values. By setting the <code>componentId</code> to the number of already explored components (starting at <code>0</code>), we can assign a unique number to each component in the range <code>[0, n - 1]</code>. This allows us to use an array instead of a map to store the component costs, optimizing both runtime and memory usage.</p>
<p>Finally, for each query, we compare the <code>componentId</code> values of the two nodes in the <code>components</code> array. If they have the same ID, indicating they belong to the same component, we return the precomputed cost; otherwise, we return <code>-1</code> to show they are not connected.</p>
<blockquote>
<p><strong>Breadth-First Search</strong>: For a more comprehensive understanding of the Breadth-First Search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries-1">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Construct the adjacency list (<code>adjList</code>) of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in edges:
<ul>
<li>Push <code>[node2, weight]</code> to <code>adjList[node1]</code>.</li>
<li>Push <code>[node1, weight]</code> to <code>adjList[node2]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a <code>visited</code> array of size <code>n</code>.</li>
<li>an array, called <code>components</code> of size <code>n</code>, to store the component ID of the component each node belongs to.</li>
<li>an empty array, called <code>componentCost</code>.</li>
<li><code>componentId</code> to <code>0</code>.</li>
</ul>
</li>
<li>Find the connected components of the graph:
<ul>
<li>For each <code>node</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If <code>node</code> is not visited, meaning that it belongs to a new component:
<ul>
<li>Push the result of <code>getComponentCost(node, adjList, visited, components, componentId)</code> into <code>componentCost</code>.</li>
<li>Increment <code>componentId</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an empty array <code>answer</code> to store the answer to each query.</li>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If <code>components[start] == components[end]</code>, meaning that the two nodes belong to the same component:
<ul>
<li>Push the cost of the component (<code>componentCost[components[start]]</code>) into <code>answer</code>.</li>
</ul>
</li>
<li>Otherwise, the two nodes are not connected, so push <code>-1</code> into <code>answer</code>.</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="getcomponentcostsource-adjlist-visited-components-componentid-function"><code>getComponentCost(source, adjList, visited, components, componentId)</code> function:</h5>
<ul>
<li>Initialize:
<ul>
<li>a queue, called <code>nodesQueue</code>.</li>
<li><code>componentCost</code> to a number where all bits are set to 1 in its binary representation.</li>
</ul>
</li>
<li>Push <code>source</code> into <code>nodesQueue</code> and mark it as visited.</li>
<li>While <code>nodesQueue</code> is not empty:
<ul>
<li>Pop the top node of the queue as <code>node</code>.</li>
<li>Mark that <code>node</code> belongs to this component by setting <code>components[node] = componentId</code>.</li>
<li>For each <code>[neighbor, weight]</code> in <code>adjList[node]</code>:
<ul>
<li>Update the component cost by performing a bitwise AND: <code>componentCost &amp;= weight</code>.</li>
<li>If <code>neighbor</code> is visited, continue.</li>
<li>Otherwise, mark it as visited and push it into the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>componentCost</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZvmjGS6T/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n + q)\)</span></p>
<p>First, we construct the adjacency list of the graph in <span class="math inline">\(O(m)\)</span> time, as we iterate over the edges and process each of them in constant time. Next, we perform a BFS traversal over the graph, which takes <span class="math inline">\(O(n + m)\)</span> time, as each node and edge is visited exactly once. Finally, we answer each query in constant time, as all component costs are already computed. Overall, the time complexity of the algorithm is <span class="math inline">\(O(m + n + q)\)</span>, as the steps are executed sequentially and independently of one another.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list contains exactly <span class="math inline">\(2m\)</span> elements, so it takes up <span class="math inline">\(O(m)\)</span> space. The other data structures we use, including the <code>visited</code>, <code>components</code>, and <code>componentCost</code> arrays, grow linearly with the number of nodes in the graph, contributing <span class="math inline">\(O(n)\)</span> to the algorithm's space complexity. Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-depth-first-search-dfs">Approach 3: Depth-First Search (DFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we will use the same logic as previously, assigning a unique ID to each component and marking all nodes of the component with this ID. However, we will now use a different type of graph traversalâ€”Depth-First Search (DFS)â€”to find the connected components and mark the nodes.</p>
<p>The main difference between the two traversals (BFS and DFS) is that DFS is typically implemented recursively and explores as far along a path as possible before backtracking, while BFS extends paths one layer at a time. In this problem, since we explore the entire graph and visit all nodes and edges exactly once, both DFS and BFS perform equally in terms of time complexity.</p>
<blockquote>
<p><strong>Depth-First Search</strong>: For a more comprehensive understanding of the Depth-First Search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/depth-first-search-in-graph/">DFS Explore Card</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="main-function-minimumcostn-edges-queries-2">Main Function: <code>minimumCost(n, edges, queries)</code></h5>
<ul>
<li>Construct the adjacency list (<code>adjList</code>) of the graph:
<ul>
<li>For each <code>edge = [node1, node2, weight]</code> in edges:
<ul>
<li>Push <code>[node2, weight]</code> to <code>adjList[node1]</code>.</li>
<li>Push <code>[node1, weight]</code> to <code>adjList[node2]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a <code>visited</code> array of size <code>n</code>.</li>
<li>an array, called <code>components</code> of size <code>n</code>, to store the component ID of the component each node belongs to.</li>
<li>an empty array, called <code>componentCost</code>.</li>
<li><code>componentId</code> to <code>0</code>.</li>
</ul>
</li>
<li>Find the connected components of the graph:
<ul>
<li>For each <code>node</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If <code>node</code> is not visited, meaning that it belongs to a new component:
<ul>
<li>Push the result of <code>getComponentCost(node, adjList, visited, components, componentId)</code> into <code>componentCost</code>.</li>
<li>Increment <code>componentId</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize an empty array <code>answer</code>, to store the answer to each query.</li>
<li>For each <code>query = [start, end]</code> in <code>queries</code>:
<ul>
<li>If <code>components[start] == components[end]</code>, meaning that the two nodes belong to the same component:
<ul>
<li>Push the cost of the component (<code>componentCost[components[start]]</code>) into <code>answer</code>.</li>
</ul>
</li>
<li>Otherwise, the two nodes are not connected, so push <code>-1</code> into <code>answer</code>.</li>
</ul>
</li>
<li>Return <code>answer</code>.</li>
</ul>
<h5 id="getcomponentcostnode-adjlist-visited-components-componentid-function"><code>getComponentCost(node, adjList, visited, components, componentId)</code> function:</h5>
<ul>
<li>Set <code>components[node] = componentId</code> to mark the <code>node</code> as part of the current component.</li>
<li>Mark <code>node</code> as visited.</li>
<li>Initialize <code>currentCost</code> to a number where all bits are set to 1 in its binary representation.</li>
<li>For each <code>[neighbor, weight]</code> in <code>adjList[node]</code>:
<ul>
<li>Update the component cost by performing a bitwise AND: <code>currentCost &amp;= weight</code>.</li>
<li>If <code>neighbor</code> is not visited:
<ul>
<li>Recursively explore the rest of the component and accumulate its cost by calling <code>getComponentCost(neighbor, adjList, visited, components, componentId)</code> and update <code>currentCost</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>currentCost</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/7m7LDYei/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the graph, <span class="math inline">\(m\)</span> the number of edges, and <span class="math inline">\(q\)</span> the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n + q)\)</span></p>
<p>Constructing the adjacency list of the graph requires <span class="math inline">\(O(m)\)</span> time, as each edge is processed in constant time. Additionally, the DFS traversal takes <span class="math inline">\(O(m + n)\)</span> time, since each node and each edge is visited exactly once. During the traversal, we calculate and store the costs of the components, so we answer each query in constant time. Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O(m + n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity of the algorithm is determined by the size of the data structures used and the recursion depth. The adjacency list contains two elements for each edge of the graph, taking up <span class="math inline">\(O(m)\)</span> space, while the arrays <code>visited</code>, <code>components</code>, and <code>componentCost</code> have at most <span class="math inline">\(n\)</span> elements, contributing <span class="math inline">\(O(n)\)</span> to the space complexity. Moreover, the recursion depth can grow up to <span class="math inline">\(n\)</span> in the worst case, where all nodes belong to the same connected component and form a list. As a result, the total space complexity of the algorithm is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Number of Visited Cells in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" style="width: 181px; height: 81px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description" target="_blank" rel="noopener noreferrer">Minimum Score of a Path Between Two Cities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are also given a <strong>2D</strong> array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code> indicates that there is a <strong>bidirectional </strong>road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with a distance equal to <code>distance<sub>i</sub></code>. The cities graph is not necessarily connected.</p>

<p>The <strong>score</strong> of a path between two cities is defined as the <strong>minimum </strong>distance of a road in this path.</p>

<p>Return <em>the <strong>minimum </strong>possible score of a path between cities </em><code>1</code><em> and </em><code>n</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A path is a sequence of roads between two cities.</li>
	<li>It is allowed for a path to contain the same road <strong>multiple</strong> times, and you can visit cities <code>1</code> and <code>n</code> multiple times along the path.</li>
	<li>The test cases are generated such that there is <strong>at least</strong> one path between <code>1</code> and <code>n</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph11.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 4. The score of this path is min(9,5) = 5.
It can be shown that no other path has less score.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/12/graph22.png" style="width: 190px; height: 231px;" />
<pre>
<strong>Input:</strong> n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4. The score of this path is min(2,2,4,7) = 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>There are no repeated edges.</li>
	<li>There is at least one path between <code>1</code> and <code>n</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-spanning-tree-kruskals-algorithm/1" target="_blank" rel="noopener noreferrer">Minimum Spanning Tree - Kruskal&#39;s Algorithm</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">greedy</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-family: arial, helvetica, sans-serif;"><span style="font-size: 18.6667px;">Given a weighted, undirected, and connected graph with V vertices and E edges, the task is to find the sum of the weights of the edges in the <strong>Minimum Spanning Tree</strong> (MST) of the graph using <strong>Kruskal's Algorithm</strong>. The graph is represented as an edge list <strong>edges[][]</strong>, where edges[i] = [u, v, w] denotes an undirected edge between <strong>u</strong> and <strong>v </strong>with weight <strong>w</strong>.</span></span></p>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Input:</strong> V = 3, E = 3, edges[][] = [[0, 1, 5], [1, 2, 3], [0, 2, 1]]
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid0_1745301795.jpg" width="279" height="227" /><br /><strong>Output: </strong>4
<strong>Explanation</strong>:
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid1_1745301818.jpg" width="287" height="233" /><br />The Spanning Tree resulting in a weight of 4 is shown above.</span></pre>
<pre><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong style="white-space: normal;">Input: </strong><span style="white-space: normal;">V = 2, E = 1, edges = [[0, 1, 5]]</span></span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"> <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/888914/Web/Other/blobid2_1745301846.jpg" width="279" height="227" /> </span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Output: </strong>5 </span><br /><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;"><strong>Explanation</strong>: Only one Spanning Tree is possible which has a weight of 5.<br /></span></pre>
<p><strong style="font-family: arial, helvetica, sans-serif; font-size: 14pt;">Constraints:<br /></strong><span style="font-size: 14pt; font-family: arial, helvetica, sans-serif;">2 &le; V &le; 1000<br />V-1 &le; E &le; (V*(V-1))/2<br />1 &le; w &le; 1000<br />The graph is connected and doesn't contain self-loops &amp; multiple edges.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-for-k-connected-components/description" target="_blank" rel="noopener noreferrer">Minimum Time for K Connected Components</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> and an undirected graph with <code>n</code> nodes labeled from 0 to <code>n - 1</code>. This is represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> indicates an undirected edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that can be removed at <code>time<sub>i</sub></code>.</p>

<p>You are also given an integer <code>k</code>.</p>

<p>Initially, the graph may be connected or disconnected. Your task is to find the <strong>minimum</strong> time <code>t</code> such that after removing all edges with <code>time &lt;= t</code>, the graph contains <strong>at least</strong> <code>k</code> connected components.</p>

<p>Return the <strong>minimum</strong> time <code>t</code>.</p>

<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022724.png" style="width: 230px; height: 85px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1}</code>.</li>
	<li>At <code>time = 1</code> or <code>2</code>, the graph remains unchanged.</li>
	<li>At <code>time = 3</code>, edge <code>[0, 1]</code> is removed, resulting in <code>k = 2</code> connected components <code>{0}</code>, <code>{1}</code>. Thus, the answer is 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1,2],[1,2,4]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022812.png" style="width: 180px; height: 164px;" /></p>

<ul>
	<li>Initially, there is one connected component <code>{0, 1, 2}</code>.</li>
	<li>At <code>time = 2</code>, edge <code>[0, 1]</code> is removed, resulting in two connected components <code>{0}</code>, <code>{1, 2}</code>.</li>
	<li>At <code>time = 4</code>, edge <code>[1, 2]</code> is removed, resulting in <code>k = 3</code> connected components <code>{0}</code>, <code>{1}</code>, <code>{2}</code>. Thus, the answer is 4.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,2,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/05/31/screenshot-2025-06-01-at-022930.png" style="width: 180px; height: 155px;" /></p>

<ul>
	<li>Since there are already <code>k = 2</code> disconnected components <code>{1}</code>, <code>{0, 2}</code>, no edge removal is needed. Thus, the answer is 0.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-stones-removed-with-same-row-or-column/description" target="_blank" rel="noopener noreferrer">Most Stones Removed with Same Row or Column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On a 2D plane, we place <code>n</code> stones at some integer coordinate points. Each coordinate point may have at most one stone.</p>

<p>A stone can be removed if it shares either <strong>the same row or the same column</strong> as another stone that has not been removed.</p>

<p>Given an array <code>stones</code> of length <code>n</code> where <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of the <code>i<sup>th</sup></code> stone, return <em>the largest possible number of stones that can be removed</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> stones = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li>No two stones are at the same coordinate point.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D plane with <code>n</code> stones placed at integer coordinates, where a stone can be removed only if another stone shares either its row or column. Our task is to determine the maximum number of stones that can be removed from the plane under these conditions.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Two stones are considered &quot;connected&quot; if they share a row or column, but this connection extends beyond just pairs of stones. If stone A is connected to stone B and stone B is connected to stone C, then all three stones form part of the same group, even if A and C donâ€™t directly share a row or column. This concept is akin to connected components in graph theory, where a connected component is a group of nodes where you can reach any node from any other node in the group. Take a look at the illustration below to visualize the components:</p>
<p><img src="../Figures/947_re/components.png" alt="connected components" /></p>
<p>Since every stone in a connected component shares a row or column with at least one other stone, we can remove all but one stone. The remaining stone cannot be removed as it no longer shares coordinates with any other stone, having eliminated all others in its component.</p>
<p>Therefore, if our 2-D plane contains multiple connected components, each can be reduced to a single stone. The maximum number of stones that can be removed can be mathematically expressed as:</p>
<pre><code>Max removable stones = Total stones - Number of connected components
</code></pre>
<details>
  <summary>Proof that in a connected component of stones, we can remove all but one stone.</summary>
<p>Base case: For <span class="math inline">\(n \leq 2\)</span>, the statement is trivially true.</p>
<ul>
<li>For <span class="math inline">\(n = 1\)</span>, we can't remove any stones.</li>
<li>For <span class="math inline">\(n = 2\)</span>, we can remove one stone, leaving the other.</li>
</ul>
<p>Inductive hypothesis: Assume the statement holds for all connected components of size <span class="math inline">\(k\)</span> or less, where <span class="math inline">\(k \geq 2\)</span>.</p>
<p>Inductive step: Consider a connected component <span class="math inline">\(C\)</span> of size <span class="math inline">\(k + 1\)</span>.</p>
<ol>
<li>Choose an arbitrary stone <span class="math inline">\(S\)</span> to keep.</li>
<li>The remaining <span class="math inline">\(k\)</span> stones form <span class="math inline">\(m\)</span> connected sub-components <span class="math inline">\(C_1\)</span>, <span class="math inline">\(C_2\)</span>, ..., <span class="math inline">\(C_m\)</span>, where <span class="math inline">\(1 â‰¤ m â‰¤ k\)</span>.</li>
<li>Let <span class="math inline">\(s_1\)</span>, <span class="math inline">\(s_2\)</span>, ..., <span class="math inline">\(s_m\)</span> be the sizes of these sub-components. We know that: <span class="math inline">\(s_1 + s_2 + ... + s_m = k\)</span></li>
<li>For each sub-component <span class="math inline">\(C_i\)</span>:
<ol>
<li>By the inductive hypothesis, we can remove all but one stone from <span class="math inline">\(C_i\)</span>.</li>
<li>Choose to keep the stone in <span class="math inline">\(C_i\)</span> that is connected to <span class="math inline">\(S\)</span> in the original component <span class="math inline">\(C\)</span>.</li>
</ol>
</li>
<li>After applying step 4 to all sub-components, we have removed: <span class="math inline">\((s_1 - 1) + (s_2 - 1) + ... + (s_m - 1) = (s_1 + s_2 + ... + s_m) - m = k - m\)</span> stones</li>
<li>We are now left with <span class="math inline">\(m + 1\)</span> stones: the <span class="math inline">\(m\)</span> stones we kept from each sub-component, plus our original chosen stone <span class="math inline">\(S\)</span>.</li>
<li>Each of these <span class="math inline">\(m\)</span> stones shares either a row or column with <span class="math inline">\(S\)</span> (by our choice in step 4(ii)). Therefore, we can remove these <span class="math inline">\(m\)</span> stones one by one.</li>
<li>In total, we have removed <span class="math inline">\((k - m) + m = k\)</span> stones, leaving only the originally chosen stone <span class="math inline">\(S\)</span>.</li>
</ol>
<p>Conclusion: By the principle of mathematical induction, we've proved that for any connected component of size <span class="math inline">\(n\)</span>, we can remove <span class="math inline">\(n - 1\)</span> stones, leaving just one stone.</p>
</details>
<br>
<p>So, our implementation boils down to two parts:</p>
<ol>
<li>Represent the stones as a graph.</li>
<li>Count the number of connected components in this graph.</li>
</ol>
<p>For the first part, we can utilize an adjacency list, where for each stone, we maintain a list of all other stones it's connected to (i.e., shares a row or column with).</p>
<p>For the second part, we can apply a graph traversal algorithm, such as Depth-First Search (DFS). We start a DFS from an unvisited stone, marking all reachable stones as visited, and count this as one connected component. We repeat this process until all stones are visited. The number of DFS executions will give us the total number of connected components in the grid, after which we can apply the formula above to determine the maximum number of stones that can be removed.</p>
<blockquote>
<p>Note: While we've discussed using depth-first search to explore each connected component, breadth-first search is an equally valid alternative, offering similar time and space complexities.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Initialize a list of lists <code>adjacencyList</code>  with <code>n</code> empty lists.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>For each stone <code>i</code>, iterate over stones <code>j</code> from <code>i+1</code> to <code>n-1</code>:
<ul>
<li>If <code>stone[i]</code> shares the same row (<code>stones[i][0] == stones[j][0]</code>) or column (<code>stones[i][1] == stones[j][1]</code>) as <code>stone[j]</code>:
<ul>
<li>Add <code>j</code> to the adjacency list of <code>i</code> and <code>i</code> to the adjacency list of <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a variable <code>numOfConnectedComponents</code> to <code>0</code>, to keep track of the number of connected components in the graph.</li>
<li>Create a boolean array <code>visited</code> of length <code>n</code> initialized to <code>false</code>, to track which stones have been visited during the DFS.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>If stone <code>i</code> has not been visited, perform a DFS starting from stone <code>i</code> to visit all stones in the same connected component.</li>
<li>After the DFS completes, increment <code>numOfConnectedComponents</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>n - numOfConnectedComponents</code> as our answer.</li>
</ul>
<p>Helper method <code>depthFirstSearch</code>:</p>
<ul>
<li>Define a method <code>depthFirstSearch</code> with parameters: <code>adjacencyList</code>, <code>visited</code>, and the current <code>stone</code>.</li>
<li>Mark the current <code>stone</code> as visited by setting <code>visited[stone]</code> to <code>true</code>.</li>
<li>For each <code>neighbor</code> of <code>stone</code> in the <code>adjacencyList</code>:
<ul>
<li>If the neighbor has not been visited:
<ul>
<li>Recursively call <code>depthFirstSearch</code> on <code>neighbor</code> to visit all stones in the connected component.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2KezyDco/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The graph is built by iterating over all pairs of stones <code>(i,j)</code> to check if they share the same row or column, resulting in <span class="math inline">\(O(n^2)\)</span> time complexity.</p>
<p>In the worst case, the depth-first search will traverse all nodes and edges. Since each stone can be connected to every other stone, the algorithm can visit all <span class="math inline">\(O(n^2)\)</span> edges across all DFS calls.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(2 \cdot O(n^2) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>In the worst case, any two stones could share the same row or column. So, the <code>adjacencyList</code> could store up to <span class="math inline">\(n^2\)</span> edges, taking <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>The <code>visited</code> array takes an additional linear space.</p>
<p>The recursive DFS call stack can go as deep as the number of stones in a single connected component. In the worst case, this depth could be <span class="math inline">\(n\)</span>, leading to <span class="math inline">\(O(n)\)</span> additional space for the stack.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(2 \cdot O(n) + O(n^2) = O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-disjoint-set-union">Approach 2: Disjoint Set Union</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A Disjoint Set Union (or Union-Find) is an efficient data structure for identifying connected components in a graph. It helps us group elements into disjoint sets, determine which set an element belongs to, and efficiently merge setsâ€”exactly what we need here. If you are unfamiliar with DSU, have a look at this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Explore Card</a> for in-depth explanation.</p>
<p>We begin by treating each stone as a separate set, meaning every stone starts off in its own connected component. Then, we iterate over each pair of stones and merge (union) them if they share a common row or column.</p>
<p>In our Union-Find data structure, we also maintain a <code>count</code>, which keeps track of the total number of separate connected components in the graph. This <code>count</code> is initially set to <code>n</code>, the total number of stones. Each successful union operation indicates that two separate components have merged into one, so we decrement the <code>count</code>.</p>
<p>After processing all possible pairs of stones, the value of <code>n - count</code> gives us the maximum number of stones that can be removed.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Initialize a <code>UnionFind</code> object <code>uf</code> with <code>n</code> as the size.</li>
<li>Iterate over each stone <code>i</code>:
<ul>
<li>For each <code>i</code>, iterate over stones <code>j</code> from <code>i+1</code> to <code>n-1</code>:
<ul>
<li>If stone <code>i</code> shares the same row (<code>stones[i][0] == stones[j][0]</code>) or column (<code>stones[i][1] == stones[j][1]</code>) as stone <code>j</code>:
<ul>
<li>Perform a <code>union</code> operation on <code>i</code> and <code>j</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>n - uf.count</code>.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>Define a class <code>UnionFind</code> with fields: an integer array <code>parent</code> and a variable <code>count</code>.</li>
<li>Override the default constructor:
<ul>
<li>Initialize <code>parent</code> to size <code>n</code> with all elements set to <code>-1</code>.</li>
<li>Set <code>count</code> to <code>n</code>, representing the initial number of connected components.</li>
</ul>
</li>
</ul>
<p>Helper method <code>find(node)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>If the parent of <code>node</code> is <code>-1</code>, return <code>node</code> as it is its own root.</li>
<li>Otherwise, recursively call <code>find</code> on <code>parent[node]</code>, set its result to <code>parent[node]</code> and return it.</li>
</ul>
<p>Helper method <code>union(n1, n2)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>Find the roots of <code>n1</code> and <code>n2</code> using the <code>find</code> method and store it in <code>root1</code> and <code>root2</code>, respectively.</li>
<li>If <code>root1</code> is equal to <code>root2</code>, both stones are already in the same connected component, so return.</li>
<li>If <code>root1</code> and <code>root2</code> are different, merge the two components by setting <code>parent[root1]</code> to <code>root2</code>.</li>
<li>Decrement <code>count</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FFRQ5ohm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha(n))\)</span></p>
<p>Initializing the <code>parent</code> array with <code>-1</code> takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The nested loops iterate through each pair of stones <code>(i, j)</code>. The number of pairs is <span class="math inline">\(\frac{n(n-1)}{2}\)</span>, which is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For each pair, if the stones share the same row or column, the <code>union</code> operation is performed. The <code>union</code> (and subsequent <code>find</code>) operation takes <span class="math inline">\(O(\alpha(n))\)</span>, where <span class="math inline">\(\alpha\)</span> is the <a href="https://www.gabrielnivasch.org/fun/inverse-ackermann">inverse Ackermann function</a>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2 \cdot \alpha(n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The only additional space used by the algorithm is the <code>parent</code> array, which takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-optimized">Approach 3: Disjoint Set Union (Optimized)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The most time-consuming part of our previous algorithms has been iterating through every possible pair of stones, but can we do better?</p>
<p>In our earlier approach, each stone was treated as a distinct entity. In this improved method, we'll break each stone down into two entities: a row index and a column index. Although this effectively doubles the total number of nodes in the graph, it doesn't affect our solution since our goal is to find the number of connected components, not the number of nodes within each component.</p>
<p>When we treat the row and column indices as separate entities, all stones that share the same row or column index become implicitly connected, eliminating the need to manually connect these stones. However, we do need to connect the row and column indices of a stone since they were originally part of the same element.</p>
<p>This optimization condenses our algorithm into a single step: looping through the input array <code>stones</code> and unioning the row and column indices of each element. However, this approach introduces two challenges:</p>
<ol>
<li>
<p>Differentiating Between Row and Column Elements:<br />
If a row and column share the same value, how do we distinguish between them? For instance, consider two stones positioned at (x, y) and (y, z). If we union x with y, and y with z, the Disjoint Set Union (DSU) might incorrectly consider the two stones as connected, which is not necessarily true. To address this, we differentiate between row and column elements by offsetting the column value by a large constant that places it beyond the range of valid row values. We use 10,001 for this purpose, as the range of row indices is [0, 10,000].</p>
</li>
<li>
<p>Counting the Number of Connected Components:<br />
Initially, we assumed the number of connected components was <code>n</code> since each stone was treated as a separate node. However, in this approach, a stone is no longer the basic unit in the graph. While it might seem logical to consider the number of nodes as twice the number of stones, this assumption is incorrect because row and column indices are likely to be repeated among stones and thus will not form separate nodes in the graph.</p>
<p>To accurately track the number of nodes, we maintain a set called <code>uniqueNodes</code>. Before performing a union operation, we check if the nodes (row and column) have been encountered before. If not, these are new nodes in the graph and can initially be considered separate components, so we increment our count. If the union operation is successful, we subsequently decrease the count.</p>
</li>
</ol>
<p>After all operations are complete, the count will store the number of connected components in the graph.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>removeStones</code>:</p>
<ul>
<li>Set <code>n</code> as the length of the input array <code>stones</code>.</li>
<li>Create an instance of the <code>UnionFind</code> class <code>uf</code> with a size of <code>20002</code> to handle the coordinate range.</li>
<li>Loop through each stone <code>i</code> in <code>stones</code>:
<ul>
<li>Call <code>uf.union()</code> to union the x-coordinate (<code>stones[i][0]</code>) and the y-coordinate offset by <code>10001</code> (<code>stones[i][1] + 10001</code>).</li>
</ul>
</li>
<li>Return <code>n - uf.componentCount</code> as our result.</li>
</ul>
<p>Helper class <code>UnionFind</code>:</p>
<ul>
<li>Define a class <code>UnionFind</code> with fields: an integer array <code>parent</code>, a variable <code>componentCount</code>, and a set <code>uniqueNodes</code>.</li>
<li>Override the default constructor:
<ul>
<li>Initialize <code>parent</code> to size <code>n</code> with all elements set to <code>-1</code>.</li>
<li>Set <code>componentCount</code> to <code>0</code> to track the number of connected components.</li>
<li>Initialize <code>uniqueNodes</code> to track which nodes have been processed.</li>
</ul>
</li>
</ul>
<p>Helper method <code>find(node)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>If <code>node</code> is not in <code>uniqueNodes</code>:
<ul>
<li>Increment <code>componentCount</code> and add the node to <code>uniqueNodes</code>.</li>
</ul>
</li>
<li>If the parent of the <code>node</code> is <code>-1</code>:
<ul>
<li>Return <code>node</code> itself as it is its own parent.</li>
</ul>
</li>
<li>Otherwise, recursively call <code>find</code> on <code>parent[node]</code>, set its result to <code>parent[node]</code> and return it.</li>
</ul>
<p>Helper method <code>union(n1, n2)</code> [<code>UnionFind</code>]:</p>
<ul>
<li>Find the root of <code>n1</code> and <code>n2</code> using the <code>find</code> method and store it in <code>root1</code> and <code>root2</code>, respectively.</li>
<li>If the roots are the same, they are already in the same component, so return.</li>
<li>Otherwise, merge the two components by setting <code>parent[root1]</code> to <code>root2</code>.</li>
<li>Decrement <code>componentCount</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/65v9h49d/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>stones</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since the size of the <code>parent</code> array is constant (<code>20002</code>), initializing it takes constant time.</p>
<p>The <code>union</code> operation is called <code>n</code> times, once for each stone. All <code>union</code> and <code>find</code> operations take <span class="math inline">\(O(\alpha(20002)) = O(1)\)</span> time, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + 20002)\)</span></p>
<p>The <code>parent</code> array takes a constant space of <code>20002</code>.</p>
<p>The <code>uniqueNodes</code> set can have at most <span class="math inline">\(2 \cdot n\)</span> elements, corresponding to all unique <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates. The space complexity of this set is <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall space complexity of the approach is <span class="math inline">\(O(n + 20002)\)</span>.</p>
<blockquote>
<p>While constants are typically excluded from complexity analysis, we've included it here due to its substantial size.</p>
</blockquote>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-closed-islands/description" target="_blank" rel="noopener noreferrer">Number of Closed Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D&nbsp;<code>grid</code> consists of <code>0s</code> (land)&nbsp;and <code>1s</code> (water).&nbsp; An <em>island</em> is a maximal 4-directionally connected group of <code><font face="monospace">0</font>s</code> and a <em>closed island</em>&nbsp;is an island <strong>totally</strong>&nbsp;(all left, top, right, bottom) surrounded by <code>1s.</code></p>

<p>Return the number of <em>closed islands</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png" style="width: 240px; height: 120px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Islands in gray are closed because they are completely surrounded by water (group of 1s).</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png" style="width: 160px; height: 80px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1],
&nbsp;              [1,0,0,0,0,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,1,0,1,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D <code>grid</code>. Each cell of <code>grid</code> represents a land or water cell denoted by <code>0</code> and <code>1</code> respectively.</p>
<p>Our task is to return the number of closed islands where a closed island is an island totally (all left, top, right, bottom) surrounded by <code>1s</code>.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem states that an island is formed by connecting all of the '0s' in all four directions (left, top, right, and bottom), which leads us to model the problem as a graph.</p>
<p>We can treat the 2D grid as an undirected graph. A land cell in <code>grid</code> corresponds to a node in such a graph with an undirected edge between horizontally or vertically adjacent land cells.</p>
<p>Let's see what forms an island in such a graph. So, we begin at any node and proceed to its neighbors, i.e., all nodes one edge away. From the nodes 1 edge away, we move to their neighbors, i.e., all the nodes 2 edges away from the starting node, and so on. If we keep traversing until we can't anymore, all the nodes that are visited in this traversal together form an island.</p>
<p>While traversing the island, we look to see if any node in the graph corresponds to a cell at the <code>grid</code>'s boundary. The island does not form a closed island if any node on it is on the <code>grid</code>'s boundary. Otherwise, a closed island is formed if there is no node on the <code>grid</code>'s boundary.</p>
<p>We can use a graph traversal algorithm like breadth-first search (BFS) to traverse over the islands. BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Leetcode Explore Card</a>.</p>
<p>We perform a BFS from every unvisited land cell, treating it as a node. While traversing the island, we check if any node in the island is present on the <code>grid</code>'s boundary. If we have such a node, the island is not a closed island. Otherwise, we have a closed island if we never visit a cell at the <code>grid</code>'s edge. As a result, we add one to our answer variable.</p>
<p>It is important to note that we will not stop the BFS traversal if we come across a node on the boundary. We will perform the complete BFS traversal to cover the entire island so that we can mark all the nodes of the island and not visit any of its nodes again.</p>
<p>Here's a visual step-by-step example:</p>
<p>!?!../Documents/1254/1254_number_of_closed_islands.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a BFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, <code>m</code>, <code>n</code>, <code>grid</code> and <code>visit</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which BFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>We initialize a queue <code>q</code> of pair of integers and push <code>(x, y)</code> into it. We also mark <code>(x, y)</code> as visited.</li>
<li>Create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>While the queue is not empty, we dequeue the first pair <code>(x, y)</code> from the queue and iterate over all its neighbors. If any neighboring cell is not in bounds of <code>grid</code>, it means the current <code>(x, y)</code> cell is present at the boundary of <code>grid</code>. We do not have a closed island, and we mark <code>isClosed = false</code>. For each neighboring cell, we check if it is a land cell or not. If it is a land cell and has not been visited yet, we mark it as visited and push <code>(r, c)</code> into the queue.</li>
<li>After the queue is empty, we return <code>isClosed</code>.</li>
<li>If <code>bfs</code> returns <code>true</code>, we increment <code>count</code> by 1 .</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kUdyBASY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform BFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can be pushed once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The BFS queue takes <span class="math inline">\(O(m \cdot n)\)</span> space in the worst-case because each node is added once.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we have to traverse over <code>grid</code> modeled as a graph to find the closed islands, another method is to use a depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a DFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, and <code>grid</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which DFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>If the cell <code>(x, y)</code> is out of bounds, it means there was a land cell at the boundary of <code>grid</code> whose neighbor is <code>(x, y)</code>. So, we return <code>false</code> to indicate that this island is not closed.</li>
<li>Else if it is a water cell or an already visited cell, we return <code>true</code>.</li>
<li>Otherwise, we visit this cell and mark it as visited. We create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>We then call <code>dfs</code> recursively from each of the neighbors of <code>(x, y)</code>.</li>
<li>If any of the directions leads to a cell in the island at the <code>grid</code> boundary, the island is not closed, and we mark <code>isClosed = false</code>. As discussed above, it is worth noting that in order to mark all the cells of the island, we called <code>dfs</code> individually over each of the four neighbors. We can't simply use <code>dfs(x - 1, y, m, n, grid, visit) &amp;&amp; dfs(x + 1, y, m, n, grid, visit) &amp;&amp; dfs(x, y - 1, m, n, grid, visit) &amp;&amp; dfs(x, y + 1, m, n, grid, visit)</code> because if the first <code>dfs</code> call returns <code>false</code>, the next three <code>dfs</code> calls will not be executed.</li>
<li>If <code>dfs</code> returns <code>true</code>, we increment <code>count</code> by 1.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HsudNnFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform DFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The recursion stack used by <code>dfs</code> can have no more than <span class="math inline">\(O(m \cdot n)\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(m \cdot n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-enclaves/description" target="_blank" rel="noopener noreferrer">Number of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>, where <code>0</code> represents a sea cell and <code>1</code> represents a land cell.</p>

<p>A <strong>move</strong> consists of walking from one land cell to another adjacent (<strong>4-directionally</strong>) land cell or walking off the boundary of the <code>grid</code>.</p>

<p>Return <em>the number of land cells in</em> <code>grid</code> <em>for which we cannot walk off the boundary of the grid in any number of <strong>moves</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All 1s are either on the boundary or can reach the boundary.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-good-paths/description" target="_blank" rel="noopener noreferrer">Number of Good Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a tree (i.e. a connected, undirected graph with no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> edges.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>vals</code> of length <code>n</code> where <code>vals[i]</code> denotes the value of the <code>i<sup>th</sup></code> node. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>

<p>A <strong>good path</strong> is a simple path that satisfies the following conditions:</p>

<ol>
	<li>The starting node and the ending node have the <strong>same</strong> value.</li>
	<li>All nodes between the starting node and the ending node have values <strong>less than or equal to</strong> the starting node (i.e. the starting node&#39;s value should be the maximum value along the path).</li>
</ol>

<p>Return <em>the number of distinct good paths</em>.</p>

<p>Note that a path and its reverse are counted as the <strong>same</strong> path. For example, <code>0 -&gt; 1</code> is considered to be the same as <code>1 -&gt; 0</code>. A single node is also considered as a valid path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png" style="width: 400px; height: 333px;" />
<pre>
<strong>Input:</strong> vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There is 1 additional good path: 1 -&gt; 0 -&gt; 2 -&gt; 4.
(The reverse path 4 -&gt; 2 -&gt; 0 -&gt; 1 is treated as the same as 1 -&gt; 0 -&gt; 2 -&gt; 4.)
Note that 0 -&gt; 2 -&gt; 3 is not a good path because vals[2] &gt; vals[0].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png" style="width: 273px; height: 350px;" />
<pre>
<strong>Input:</strong> vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 5 good paths consisting of a single node.
There are 2 additional good paths: 0 -&gt; 1 and 2 -&gt; 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png" style="width: 100px; height: 88px;" />
<pre>
<strong>Input:</strong> vals = [1], edges = []
<strong>Output:</strong> 1
<strong>Explanation:</strong> The tree consists of only one node, so there is one good path.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == vals.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-islands/description" target="_blank" rel="noopener noreferrer">Number of Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>

<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-operations-to-make-network-connected/description" target="_blank" rel="noopener noreferrer">Number of Operations to Make Network Connected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> computers numbered from <code>0</code> to <code>n - 1</code> connected by ethernet cables <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between computers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any computer can reach any other computer directly or indirectly through the network.</p>

<p>You are given an initial computer network <code>connections</code>. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.</p>

<p>Return <em>the minimum number of times you need to do this in order to make all the computers connected</em>. If it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png" style="width: 500px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 4, connections = [[0,1],[0,2],[1,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Remove cable between computer 1 and 2 and place between computers 1 and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/02/sample_2_1677.png" style="width: 500px; height: 129px;" />
<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are not enough cables.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= connections.length &lt;= min(n * (n - 1) / 2, 10<sup>5</sup>)</code></li>
	<li><code>connections[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated connections.</li>
	<li>No two computers are connected by more than one cable.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-pairs-1645358985/1" target="_blank" rel="noopener noreferrer">Number of pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">The director of your college&nbsp;is&nbsp;planning to send 2 people to the ICPC&nbsp;regionals. He&nbsp;wants them to be from different branches. You will be given a list of pairs of student ids. Each pair is made of students from the same branch. Determine how many pairs of students from different branches they can choose from.</span></p>
<pre><span style="font-size: 18px;"><strong>Example 1:
Input:</strong>
N=5
P=3
pairs[]={{0,1},
         {2,3},
         {0,4}}
<strong>Output:</strong>
6
<strong>Explanation:</strong>
Their are total five studets 0,1,2,3,4.
Students [0,1,4] are from same bracnh while 
[2,3] are from a different one.So we can choose
different pairs like: [0,2],[0,3],[1,2],[1,3],
[4,2],[4,3]</span></pre>
<p>&nbsp;</p>
<pre><span style="font-size: 18px;"><strong>Example 2:
Input:</strong>
N=4 
P=1
pairs[]={{0,2}}
<strong>Output:</strong>
5
<strong>Explanation:</strong>
[0,1],[0,3],[2,1],[2,3] and [1,3] are all possible 
pairs because [0,2],[1] and [3] all belongs to 
different branches.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>numberOfPairs()</strong>&nbsp;which takes the 2d array pairs[], its size P<strong>&nbsp;</strong>and an integer N representing total number of students<strong>&nbsp;</strong>as input parameters&nbsp;and returns the total number of pairs(as explianed in the question).</span>.</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N)<br /><strong>Expected Auxiliary Space:</strong> O(N)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />1&lt;=N&lt;=10<sup>5</sup><br />1&lt;=P&lt;=10<sup>4</sup><br />0&lt;=P[i][0],P[i][1]</span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-provinces/description" target="_blank" rel="noopener noreferrer">Number of Provinces</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>

<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>

<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>

<p>Return <em>the total number of <strong>provinces</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" style="width: 222px; height: 142px;" />
<pre>
<strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n == isConnected.length</code></li>
	<li><code>n == isConnected[i].length</code></li>
	<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>
	<li><code>isConnected[i][i] == 1</code></li>
	<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given <code>n</code> cities, some of which are connected to other cities given by an <code>n x n</code> matrix <code>isConnected</code>. The connectivity is transitive, which means that if city <code>a</code> is directly connected with city <code>b</code> and city <code>b</code> is directly connected with city <code>c</code>, then city <code>a</code> is indirectly connected with city <code>c</code>.</p>
<p>A province is defined as a group of directly or indirectly connected cities with no other cities outside of the group.</p>
<p>Our task is to return the total number of provinces.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that two cities <code>x</code> and <code>y</code> belong to the same province if there is a <strong>path</strong> from city <code>x</code> to city <code>y</code> using the cities that are directly connected.</p>
<p>This leads us to consider the problem in terms of graphs.</p>
<p>Each city can be thought of as a node in a graph. The roads that directly connect the cities are the edges. If there is a path in this graph connecting cities <code>x</code> and <code>y</code>, then <code>x</code> and <code>y</code> are in the same province. Because the graph is undirected, <code>x</code> and <code>y</code> belong to the same province if and only if they are part of the same graph component.</p>
<p><strong>The number of required provinces is the number of connected components formed in such a graph.</strong></p>
<p>To check the number of connected components in a graph, we can use a graph traversal algorithm like depth first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="../Figures/547/547-dfs.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
<p>To figure out how many connected components there are in the graph, we first mark all nodes as unvisited.</p>
<p>We iterate through all the nodes from <code>0</code> to <code>n - 1</code>, checking whether each <code>node</code> has been visited or not. As the graph is undirected, a DFS traversal from <code>node</code> would visit all of the nodes in the component to which <code>node</code> belongs. Whenever we see an unvisited node while looping through all the nodes, it means we have found a new component. We run the DFS traversal from the unvisited node to traverse over all the nodes in the new component, marking all these nodes as visited to avoid counting a component more than once.</p>
<p>The number of connected components in the graph is equal to the number of unvisited nodes we encounter (the number of times we start a DFS traversal) in this process.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a DFS traversal:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We mark <code>node</code> as visited.</li>
<li>We iterate over all the values in <code>isConnected[node]</code> to get the neighbors of <code>node</code>. If <code>isConnected[node][i] == 1</code>, one neighbor of <code>node</code> is <code>i</code> (as we have a direct edge between <code>node</code> and <code>i</code>). For each neighbor <code>i</code> that has not yet been visited, we recursively call <code>dfs</code> with <code>i</code> as the node.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z8EQGch8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, which takes <span class="math inline">\(O(n)\)</span> time because there are <span class="math inline">\(n\)</span> nodes in total. From each <code>node</code>, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node. As a result, it takes a total of <span class="math inline">\(O(n^2)\)</span> time to visit all the nodes and iterate over its edges.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we just have to find the number of connected components in the graph, another method is to use a breadth-first search (BFS).</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="../Figures/547/547-bfs.png" alt="img" /></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">LeetCode Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
<li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph. Initialize it to <code>0</code>.</li>
<li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a BFS traversal:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>node</code>, <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.</li>
<li>We create an integer queue <code>q</code> and push <code>node</code> into it. We also mark <code>node</code> as visited.</li>
<li>We now loop until the queue is empty. The queue's first element, <code>node</code>, is popped out. We iterate over all the neighbors of <code>node</code> where the neighboring nodes are found using <code>isConnected[node]</code>. If any <code>neighbor</code> has not yet been visited, we mark it as visited and push it into the queue.</li>
</ul>
</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i3nKSSz5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. As discussed above, we iterate over all possible edges using <code>isConnected[node]</code> which takes <span class="math inline">\(O(n)\)</span> time for each visited node, resulting in <span class="math inline">\(O(n^2)\)</span> operations in total in the worst-case scenario while visiting all nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The BFS queue takes <span class="math inline">\(O(n)\)</span> because each node is added, and in the worst-case scenario you could have a linear amount of nodes in the queue at once.</li>
<li>The <code>visit</code> array takes <span class="math inline">\(O(n)\)</span> space as well.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving questions based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a unionâ€“find data structure or mergeâ€“find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. It implements two useful operations:</p>
<ol>
<li><code>Find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>Union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the number of connected components formed in the graph with cities acting as nodes and an edge between directly connected cities.</p>
<p>We initialize all nodes as separate components in the union-find data structure. We create a variable called <code>numberOfComponents</code> to count the number of connected components in the graph and initialize it to the number to the nodes.</p>
<p>We iterate over all the edges, decrementing <code>numberOfComponents</code> by <code>1</code> for each edge whenever two different components are merged into a single one using that edge.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an integer variable <code>n</code> which stores the number of cities.</li>
<li>Create an instance of <code>UnionFind</code> of size <code>n</code>.</li>
<li>Create an integer variable <code>numberOfComponents</code> to count the number of connected components in the graph. We initialize it to <code>n</code> as each node initially behaves as a separate component.</li>
<li>We iterate over <code>isConnected</code> using two loops, outer loop running from <code>i = 0</code> to <code>n - 1</code> and an inner loop running from <code>j = i + 1</code> to <code>n - 1</code>. For each pair of directly connected cities <code>i</code> and <code>j</code>, i.e., <code>isConnected[i][j] == 1</code>, we use the <code>find</code> operation to determine which components both of them belong to. If they belong to different components, i.e., <code>find(i)!= find(j)</code>, we perform a <code>union</code> operation on both nodes, combining the two different connected components into a single connected component. We also reduce <code>numberOfComponents</code> by one as we just merged two different components. We don't do anything if <code>i</code> and <code>j</code> already belong to the same component.</li>
<li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/bLutVW9r/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of cities.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<ul>
<li>We need <span class="math inline">\(O(n^2)\)</span> time to iterate over all the values in <code>isConnected</code>.</li>
<li>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm (using path compression with union by rank) is <span class="math inline">\(O(alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>.  Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</li>
<li>Initializing <code>UnionFind</code> takes <span class="math inline">\(O(n)\)</span> time beacuse we are initializing the <code>parent</code> and <code>rank</code> arrays of size <code>n</code> each.</li>
<li>We iterate through every edge and use the <code>find</code> operation to find the component of nodes connected by each edge. It takes <span class="math inline">\(O(1)\)</span> per operation and takes <span class="math inline">\(O(e)\)</span> time for all the <span class="math inline">\(e\)</span> edges. We can have a maximum of <span class="math inline">\(O(n^2)\)</span> edges in between <span class="math inline">\(n\)</span> nodes (each node is connected to other), so it would take <span class="math inline">\(O(n^2)\)</span> time. If nodes from different components are connected by an edge, we also perform <code>union</code> of the nodes, which takes <span class="math inline">\(O(1)\)</span> time per operation. In the worst-case scenario, it may be called <span class="math inline">\(O(n)\)</span> times to connect all the components to form a connected graph with only one component.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We are using the <code>parent</code> and <code>rank</code> arrays, both of which require <span class="math inline">\(O(n)\)</span> space each.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description" target="_blank" rel="noopener noreferrer">Number of Ways to Reorder Array to Get Same BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p>

<ul>
	<li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li>
</ul>

<p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p>

<p>Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/bb.png" style="width: 121px; height: 101px;" />
<pre>
<strong>Input:</strong> nums = [2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex1.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex4.png" style="width: 121px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no other orderings of nums that will yield the same BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All integers in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-recursion">Approach: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>We can make the following conclusions:</p>
<ul>
<li>
<p>The first element of <code>nums</code> always corresponds to the root node of the corresponding BST.</p>
</li>
<li>
<p>According to the definition of a binary search tree (BST), all elements less than the root value belong to the left subtree, while all elements greater than the root value belong to the right subtree (as shown in the figure below). Let's temporarily ignore the specific structure of the left and right subtrees for now.</p>
</li>
</ul>
<p><img src="../Figures/1569/1.png" alt="img" /></p>
<p>Let <code>dfs(nums)</code> denote the number of permutations of <code>nums</code> that result in the same BST as <code>nums</code>. When iterating over the elements of <code>nums[1:]</code>, we can construct two subtrees using the subsequences <code>left_nodes = [1, 2]</code> and <code>right_nodes = [4, 5]</code> by adding each element to either the left or right subtree of the root. As long as the <strong>relative position</strong> of the elements within <code>[1, 2]</code> or <code>[4, 5]</code> remains unchanged, rearranging their positions in <code>nums</code> does not affect the construction of the subtrees.</p>
<blockquote>
<p>It should be noted that maintaining the relative positions of the numbers in each sequence does not necessarily mean that rearranging the order will always result in a different BST. However, this issue will be addressed in the next level of the subproblem, which will be considered in <code>dfs(left_nodes)</code> or <code>dfs(right_nodes)</code> by allowing the order to be changed. In the current level of recursion <code>dfs(nums)</code>, we do not consider the issue of the next level.</p>
</blockquote>
<p><img src="../Figures/1569/6.png" alt="img" /></p>
<p>Therefore, we obtain the following recursive relation:</p>
<p><span class="math display">\[
However, it is important to note that the actual number of valid permutations may exceed the calculated number from above. This is because there are some permutations that do not alter the relative order of the nodes in `left_nodes` and `right_nodes` thus resulting in the same BST.

<br>

For instance, let's consider the original array `[3,4,5,1,2]`. Here, we use `[1, 2]` to construct the left subtree and `[4, 5]` to construct the right subtree. If we only change the positions of `1` and `2` in `nums[1:]` without altering their relative order, the subsequences used to construct the left and right subtree will still be `[1, 2]` and `[4, 5]`, resulting in the same left subtree.


![img](../Figures/1569/2.png)


This implies that we need to adjust the formula by multiplying it with a coefficient ($$P$$) that represents the number of permutations that preserve the relative order of nodes in the two subsequence `left_nodes` and `right_nodes`. This leads to the modified equation:

$$\text{dfs(nums)} = P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$


It is possible to arbitrarily select two cells to hold the nodes of the left subtree, and there are 6 permutations that generate the same `left_nodes` and `right_nodes`. Therefore, we set $$P=6$$ in the above equation.

![img](../Figures/1569/3.png)


In general, for an array of length `m` with `left` nodes in the left subtree, then the number of valid permutations is equal to the number of ways of selecting `k` cells from `m - 1` cells (excluding the first cell that represents the root). This can be expressed using the binomial coefficient formula:

$$C_{m-1}^\text{left} = \binom{m-1}{\text{left}} = \frac{(m-1)!}{\text{left}!(m-1-\text{left})!}$$



<details> <summary>
        <b> &ensp; If you are not aware of the binomial coefficient, let's get a brief idea about it (click to expand) We have hidden this section in order to keep the main content coherent. Our focus is on practical applications rather than on specific implementations and theories. </b> </summary>

<br>

To efficiently compute the binomial coefficients, we can use Pascal's triangle and precompute a table to avoid repetitive calculations. To build this table, we first determine the number of rows we need based on the size of `nums`, denoted as `m`. We create a $$m \times m$$ table to represent the first `m - 1` rows of Pascal's triangle.

The numbers in Pascal's triangle are generated by summing the two numbers directly above it. We initialize the first column and the main diagonal as `1`. We then iterate over the lower-left half of the table, starting from `table[2][1]`, and compute `table[i][j]` as the sum of `table[i - 1][j - 1]` and `table[i - 1][j]`.

![img](../Figures/1569/5.png)

After building the table, we can efficiently compute the value of $$C_n^k$$ by directly looking up `table[n][k]`.

</details>

<br>

Now we can recursively solve this problem by dividing `nums` into two subsequences `left_nodes` (of length `k`) and `right_nodes`, and the number of valid permutations is denoted as 
$$ \text{dfs(nums)} \\= P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)} \\= C_{n}^{k}\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$. 


where $$C_{n}^{k}$$ can be obtained by using the precomputed table we discussed before or built-in functions. We treat the calls to `dfs` on the two subsequences as subproblems, and recursively solve them. The algorithm always selects the first element as the root value, and the size of the input array gradually decreases as the recursion progresses.


If the input array `nums` contains one or two elements, it only has one permutation that constructs the same BST (which is `nums` itself). Thus we have `dfs(nums) = 1` when `nums.length < 3`, which are the base cases.


<br>

Take the picture below as a detailed example.

- For `nums = [5, 1, 8, 3, 7, 9, 4, 2, 6]`, we need to keep the relative order in `[1, 3, 4, 2]` and `[8, 7, 9, 6]` unchanged, there could be $$C_8^4$$ different permutations.

- Now we move on to the left subtree constructed by `[1, 3, 4, 2]`, there is no left subtree for `root = 1` so we have the coefficient as $$C_3^0$$.

- For the right subtree constructed by `[3, 2, 4]`, we have the coefficient as $$C_2^1$$.

and so on.

![img](../Figures/1569/40.png)

Therefore, the number of permutations is equal to the product of all coefficients, which is $$\text{answer} = C_8^4 \cdot C_3^0 \cdot C_3^2 \cdot C_2^1  \cdot 1 \cdot 1 \cdot 1$$. 

Lastly, don't forget to return $$(\text{answer} - 1) \% (10^9 +7)$$ as we don't count the original `nums` as a valid permutation.


<br>

#### Algorithm


1) Define a function `dfs(nums)` as the number of valid permutations.
    - If the size of `nums` is less than 3, meaning there are 0, 1, or 2 nodes, the function returns 1, as there is only one possible permutation in each of these cases.
    - Otherwise, the function selects the first element of `nums` as the value of the root node. It then partitions the remaining elements `nums[1:]` into two subsequences, `left_nodes` and `right_nodes`, representing the values of the nodes in the left and right subtrees, respectively.
    - Let `m` be the size of `nums` and `k` be the size of `left_nodes`. Return the product of `dfs(left_nodes) * dfs(right_nodes)` and $$C_n^k$$.

2) In Java or C++, we need to build a table of Pascal's of size $$m \times m$$, since there are at most $$m - 1$$ nodes in a subtree, 
    - Initialize the first column and the main diagonal of the table to `1`.
    - Iterate over each empty cell in the lower left triangle of `table` from top to bottom and from left to right. Set `table[i][j]` as `table[i - 1][j] + table[i - 1][j - 1]`.

    Return `table[n][k]` if we need to compute $$C_n^k$$.


3) Return `(dfs(nums) - 1) % (1_000_000_007)`.

#### Implementation

[code](https://leetcode.com/playground/NmZAKnGX/shared)


#### Complexity Analysis

Let $$m$$ be the size of `nums`.

* Time complexity: $$O(m^2)$$
    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built, which takes $$O(m^2)$$ time.
    - `dfs(nums)` recursively calls itself to process the left and right subtrees of the current node `nums[0]`. Since the total size of the subtrees decreases by 1 at each level of the recursion, the maximum height of the recursion tree is $$m$$. Thus the total time complexity of the recursive solution is $$O(m^2)$$ because in each call we are doing $$O(m)$$ work creating the subsequences.

    

* Space complexity: $$O(m^2)$$ or $$O(m)$$

    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built.
    - The recursive solution uses the call stack to keep track of the current subtree being processed. The maximum depth of the call stack is equal to the height of the BST constructed from the input array. In the worst case, `nums` may form a degenerate BST (e.g., a sorted array), which has a height of $$m - 1$$, and the stack can hold up to $$m - 1$$ calls, resulting in a space complexity of $$O(m)$$.

<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-existence-queries-in-a-graph-i/description" target="_blank" rel="noopener noreferrer">Path Existence Queries in a Graph I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a graph, labeled from 0 to <code>n - 1</code>.</p>

<p>You are also given an integer array <code>nums</code> of length <code>n</code> sorted in <strong>non-decreasing</strong> order, and an integer <code>maxDiff</code>.</p>

<p>An <strong>undirected </strong>edge exists between nodes <code>i</code> and <code>j</code> if the <strong>absolute</strong> difference between <code>nums[i]</code> and <code>nums[j]</code> is <strong>at most</strong> <code>maxDiff</code> (i.e., <code>|nums[i] - nums[j]| &lt;= maxDiff</code>).</p>

<p>You are also given a 2D integer array <code>queries</code>. For each <code>queries[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>, determine whether there exists a path between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>Return a boolean array <code>answer</code>, where <code>answer[i]</code> is <code>true</code> if there exists a path between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> in the <code>i<sup>th</sup></code> query and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, nums = [1,3], maxDiff = 1, queries = [[0,0],[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[true,false]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Query <code>[0,0]</code>: Node 0 has a trivial path to itself.</li>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |1 - 3| = 2</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[true, false]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, nums = [2,5,6,8], maxDiff = 2, queries = [[0,1],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,false,true,true]</span></p>

<p><strong>Explanation:</strong></p>

<p>The resulting graph is:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/25/screenshot-2025-03-26-at-122249.png" style="width: 300px; height: 170px;" /></p>

<ul>
	<li>Query <code>[0,1]</code>: There is no edge between Node 0 and Node 1 because <code>|nums[0] - nums[1]| = |2 - 5| = 3</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[0,2]</code>: There is no edge between Node 0 and Node 2 because <code>|nums[0] - nums[2]| = |2 - 6| = 4</code>, which is greater than <code>maxDiff</code>.</li>
	<li>Query <code>[1,3]</code>: There is a path between Node 1 and Node 3 through Node 2 since <code>|nums[1] - nums[2]| = |5 - 6| = 1</code> and <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, both of which are within <code>maxDiff</code>.</li>
	<li>Query <code>[2,3]</code>: There is an edge between Node 2 and Node 3 because <code>|nums[2] - nums[3]| = |6 - 8| = 2</code>, which is equal to <code>maxDiff</code>.</li>
	<li>Thus, the final answer after processing all the queries is <code>[false, false, true, true]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
	<li><code>0 &lt;= maxDiff &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-minimum-effort/description" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are a hiker preparing for an upcoming hike. You are given <code>heights</code>, a 2D array of size <code>rows x columns</code>, where <code>heights[row][col]</code> represents the height of cell <code>(row, col)</code>. You are situated in the top-left cell, <code>(0, 0)</code>, and you hope to travel to the bottom-right cell, <code>(rows-1, columns-1)</code> (i.e.,&nbsp;<strong>0-indexed</strong>). You can move <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>, and you wish to find a route that requires the minimum <strong>effort</strong>.</p>

<p>A route&#39;s <strong>effort</strong> is the <strong>maximum absolute difference</strong><strong> </strong>in heights between two consecutive cells of the route.</p>

<p>Return <em>the minimum <strong>effort</strong> required to travel from the top-left cell to the bottom-right cell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex1.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex2.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,3],[3,8,4],[5,3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> This route does not require any effort.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == heights.length</code></li>
	<li><code>columns == heights[i].length</code></li>
	<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
	<li><code>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/possible-bipartition/description" target="_blank" rel="noopener noreferrer">Possible Bipartition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We want to split a group of <code>n</code> people (labeled from <code>1</code> to <code>n</code>) into two groups of <strong>any size</strong>. Each person may dislike some other people, and they should not go into the same group.</p>

<p>Given the integer <code>n</code> and the array <code>dislikes</code> where <code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that the person labeled <code>a<sub>i</sub></code> does not like the person labeled <code>b<sub>i</sub></code>, return <code>true</code> <em>if it is possible to split everyone into two groups in this way</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, dislikes = [[1,2],[1,3],[2,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The first group has [1,4], and the second group has [2,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, dislikes = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We need at least 3 groups to divide them. We cannot put them in two groups.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2000</code></li>
	<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>
	<li><code>dislikes[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n</code></li>
	<li>All the pairs of <code>dislikes</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/possible-paths--141628/1" target="_blank" rel="noopener noreferrer">Possible Paths in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>weighted</strong> tree with <strong>n</strong> nodes and (<strong>n-1</strong>) edges. You are given <strong>q</strong> <strong>queries</strong>. Each query contains a number <strong>x</strong>. For each query, find the number of paths in which the maximum edge weight is less than or equal to <strong>x</strong>. </span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Path from A to B and B to A are considered to be the same.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> <br />n = 3
edges {start, end, weight} = {{1, 2, 1}, {2, 3, 4}}</span>
<span style="font-size: 18px;">q = 1
queries[] = {3}
<strong>Output:</strong> <br />1
<strong>Explanation:</strong>
Query 1: Path from 1 to 2</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> <br />n = 7
</span><span style="font-size: 18px;">edges {start, end, weight} = {{1, 2, 3}, {2, 3, 1}, {2, 4, 9}, {3, 6, 7}, {3, 5, 8}, {5, 7, 4}}
</span><span style="font-size: 18px;">q = 3
queries[] = {1, 3, 5}
<strong>Output:</strong> <br />1 3 4
<strong>Explanation:</strong> </span>
<span style="font-size: 18px;">Query 1: Path from 2 to 3</span>
<span style="font-size: 18px;">Query 2: Path from 1 to 2, 1 to 3, and 2 to 3</span>
<span style="font-size: 18px;">Query 3: Path from 1 to 2, 1 to 3, 2 to 3, and 5 to 7</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task: &nbsp;</strong><br />You don't need to read input or print anything. Complete the function <strong>maximumWeight()</strong>which takes integers <strong>n,</strong>&nbsp;list of&nbsp;<strong>edges</strong> where each edge is given by {start,end,weight}, an integer <strong>q </strong>and a list of q <strong>queries</strong> as input parameters and returns a list of integers denoting the number of possible paths for each query.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(nlogn + qlogn)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(n)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2 &le; n &le; 10<sup>4<br /></sup>1 &le; q &le; 10<sup>4</sup><sup><br /></sup></span><span style="font-size: 18px;">1 </span><span style="font-size: 18px;">&le; edges[i][0], edges[i][1]&nbsp;</span><span style="font-size: 18px;">&le; n<br /></span><span style="font-size: 18px;">edges[i][0] != edges[i][1]<br /></span><span style="font-size: 18px;">0 </span><span style="font-size: 18px;">&le; </span><span style="font-size: 18px;">edges[i][2] </span><span style="font-size: 18px;">&le; 10<sup>5</sup><br />0&nbsp;&le;&nbsp;queries[i] &le; 10<sup>5</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/power-grid-maintenance/description" target="_blank" rel="noopener noreferrer">Power Grid Maintenance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="401" data-start="120">You are given an integer <code data-end="194" data-start="191">c</code> representing <code data-end="211" data-start="208">c</code> power stations, each with a unique identifier <code>id</code> from 1 to <code>c</code> (1â€‘based indexing).</p>

<p data-end="401" data-start="120">These stations are interconnected via <code data-end="295" data-start="292">n</code> <strong>bidirectional</strong> cables, represented by a 2D array <code data-end="357" data-start="344">connections</code>, where each element <code data-end="430" data-start="405">connections[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a connection between station <code>u<sub>i</sub></code> and station <code>v<sub>i</sub></code>. Stations that are directly or indirectly connected form a <strong>power grid</strong>.</p>

<p data-end="626" data-start="586">Initially, <strong>all</strong> stations are online (operational).</p>

<p data-end="720" data-start="628">You are also given a 2D array <code data-end="667" data-start="658">queries</code>, where each query is one of the following <em>two</em> types:</p>

<ul data-end="995" data-start="722">
	<li data-end="921" data-start="722">
	<p data-end="921" data-start="724"><code data-end="732" data-start="724">[1, x]</code>: A maintenance check is requested for station <code data-end="782" data-start="779">x</code>. If station <code>x</code> is online, it resolves the check by itself. If station <code>x</code> is offline, the check is resolved by the operational station with the smallest <code>id</code> in the same <strong>power grid</strong> as <code>x</code>. If <strong>no</strong> <strong>operational</strong> station <em>exists</em> in that grid, return -1.</p>
	</li>
	<li data-end="995" data-start="923">
	<p data-end="995" data-start="925"><code data-end="933" data-start="925">[2, x]</code>: Station <code data-end="946" data-start="943">x</code> goes offline (i.e., it becomes non-operational).</p>
	</li>
</ul>

<p data-end="1106" data-start="997">Return an array of integers representing the results of each query of type <code data-end="1080" data-start="1072">[1, x]</code> in the <strong>order</strong> they appear.</p>

<p data-end="1106" data-start="997"><strong>Note:</strong> The power grid preserves its structure; an offline (nonâ€‘operational) node remains part of its grid and taking it offline does not alter connectivity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/15/powergrid.jpg" style="width: 361px; height: 42px;" /></p>

<ul>
	<li data-end="223" data-start="143">Initially, all stations <code>{1, 2, 3, 4, 5}</code> are online and form a single power grid.</li>
	<li data-end="322" data-start="226">Query <code>[1,3]</code>: Station 3 is online, so the maintenance check is resolved by station 3.</li>
	<li data-end="402" data-start="325">Query <code>[2,1]</code>: Station 1 goes offline. The remaining online stations are <code>{2, 3, 4, 5}</code>.</li>
	<li data-end="557" data-start="405">Query <code>[1,1]</code>: Station 1 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{2, 3, 4, 5}</code>, which is station 2.</li>
	<li data-end="641" data-start="560">Query <code>[2,2]</code>: Station 2 goes offline. The remaining online stations are <code>{3, 4, 5}</code>.</li>
	<li data-end="800" data-start="644">Query <code>[1,2]</code>: Station 2 is offline, so the check is resolved by the operational station with the smallest <code>id</code> among <code>{3, 4, 5}</code>, which is station 3.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">c = 3, connections = [], queries = [[1,1],[2,1],[1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="976" data-start="909">There are no connections, so each station is its own isolated grid.</li>
	<li data-end="1096" data-start="979">Query <code>[1,1]</code>: Station 1 is online in its isolated grid, so the maintenance check is resolved by station 1.</li>
	<li data-end="1135" data-start="1099">Query <code>[2,1]</code>: Station 1 goes offline.</li>
	<li data-end="1237" data-start="1138">Query <code>[1,1]</code>: Station 1 is offline and there are no other stations in its grid, so the result is -1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="155" data-start="139"><code>1 &lt;= c &lt;= 10<sup>5</sup></code></li>
	<li data-end="213" data-start="158"><code>0 &lt;= n == connections.length &lt;= min(10<sup>5</sup>, c * (c - 1) / 2)</code></li>
	<li data-end="244" data-start="216"><code>connections[i].length == 2</code></li>
	<li data-end="295" data-start="247"><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= c</code></li>
	<li data-end="338" data-start="298"><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="374" data-start="341"><code>1 &lt;= queries.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li data-end="401" data-start="377"><code>queries[i].length == 2</code></li>
	<li data-end="436" data-start="404"><code>queries[i][0]</code> is either 1 or 2.</li>
	<li data-end="462" data-start="439"><code>1 &lt;= queries[i][1] &lt;= c</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/process-restricted-friend-requests/description" target="_blank" rel="noopener noreferrer">Process Restricted Friend Requests</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> indicating the number of people in a network. Each person is labeled from <code>0</code> to <code>n - 1</code>.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>restrictions</code>, where <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> means that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> <strong>cannot </strong>become <strong>friends</strong>,<strong> </strong>either <strong>directly</strong> or <strong>indirectly</strong> through other people.</p>

<p>Initially, no one is friends with each other. You are given a list of friend requests as a <strong>0-indexed</strong> 2D integer array <code>requests</code>, where <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> is a friend request between person <code>u<sub>j</sub></code> and person <code>v<sub>j</sub></code>.</p>

<p>A friend request is <strong>successful </strong>if <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> can be <strong>friends</strong>. Each friend request is processed in the given order (i.e., <code>requests[j]</code> occurs before <code>requests[j + 1]</code>), and upon a successful request, <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> <strong>become direct friends</strong> for all future friend requests.</p>

<p>Return <em>a <strong>boolean array</strong> </em><code>result</code>,<em> where each </em><code>result[j]</code><em> is </em><code>true</code><em> if the </em><code>j<sup>th</sup></code><em> friend request is <strong>successful</strong> or </em><code>false</code><em> if it is not</em>.</p>

<p><strong>Note:</strong> If <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> are already direct friends, the request is still <strong>successful</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
<strong>Output:</strong> [true,false]
<strong>Explanation:
</strong>Request 0: Person 0 and person 2 can be friends, so they become direct friends. 
Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
<strong>Output:</strong> [true,false]
<strong>Explanation:
</strong>Request 0: Person 1 and person 2 can be friends, so they become direct friends.
Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
<strong>Output:</strong> [true,false,true,false]
<strong>Explanation:
</strong>Request 0: Person 0 and person 4 can be friends, so they become direct friends.
Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.
Request 2: Person 3 and person 1 can be friends, so they become direct friends.
Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>
	<li><code>restrictions[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
	<li><code>1 &lt;= requests.length &lt;= 1000</code></li>
	<li><code>requests[j].length == 2</code></li>
	<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/properties-graph/description" target="_blank" rel="noopener noreferrer">Properties Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>properties</code> having dimensions <code>n x m</code> and an integer <code>k</code>.</p>

<p>Define a function <code>intersect(a, b)</code> that returns the <strong>number of distinct integers</strong> common to both arrays <code>a</code> and <code>b</code>.</p>

<p>Construct an <strong>undirected</strong> graph where each index <code>i</code> corresponds to <code>properties[i]</code>. There is an edge between node <code>i</code> and node <code>j</code> if and only if <code>intersect(properties[i], properties[j]) &gt;= k</code>, where <code>i</code> and <code>j</code> are in the range <code>[0, n - 1]</code> and <code>i != j</code>.</p>

<p>Return the number of <strong>connected components</strong> in the resulting graph.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2],[1,1],[3,4],[4,5],[5,6],[7,7]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 3 connected components:</p>

<p><img height="171" src="https://assets.leetcode.com/uploads/2025/02/27/image.png" width="279" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,2,3],[2,3,4],[4,3,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The graph formed has 1 connected component:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/02/27/screenshot-from-2025-02-27-23-58-34.png" style="width: 219px; height: 171px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">properties = [[1,1],[1,1]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><code>intersect(properties[0], properties[1]) = 1</code>, which is less than <code>k</code>. This means there is no edge between <code>properties[0]</code> and <code>properties[1]</code> in the graph.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == properties.length &lt;= 100</code></li>
	<li><code>1 &lt;= m == properties[i].length &lt;= 100</code></li>
	<li><code>1 &lt;= properties[i][j] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= m</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rank-transform-of-a-matrix/description" target="_blank" rel="noopener noreferrer">Rank Transform of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return <em>a new matrix </em><code>answer</code><em> where </em><code>answer[row][col]</code><em> is the </em><em><strong>rank</strong> of </em><code>matrix[row][col]</code>.</p>

<p>The <strong>rank</strong> is an <strong>integer</strong> that represents how large an element is compared to other elements. It is calculated using the following rules:</p>

<ul>
	<li>The rank is an integer starting from <code>1</code>.</li>
	<li>If two elements <code>p</code> and <code>q</code> are in the <strong>same row or column</strong>, then:
	<ul>
		<li>If <code>p &lt; q</code> then <code>rank(p) &lt; rank(q)</code></li>
		<li>If <code>p == q</code> then <code>rank(p) == rank(q)</code></li>
		<li>If <code>p &gt; q</code> then <code>rank(p) &gt; rank(q)</code></li>
	</ul>
	</li>
	<li>The <strong>rank</strong> should be as <strong>small</strong> as possible.</li>
</ul>

<p>The test cases are generated so that <code>answer</code> is unique under the given rules.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2],[3,4]]
<strong>Output:</strong> [[1,2],[2,3]]
<strong>Explanation:</strong>
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] &gt; matrix[0][1], matrix[1][1] &gt; matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[7,7],[7,7]]
<strong>Output:</strong> [[1,1],[1,1]]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg" style="width: 601px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
<strong>Output:</strong> [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reachable-nodes-with-restrictions/description" target="_blank" rel="noopener noreferrer">Reachable Nodes With Restrictions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>

<p>You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given an integer array <code>restricted</code> which represents <strong>restricted</strong> nodes.</p>

<p>Return <em>the <strong>maximum</strong> number of nodes you can reach from node </em><code>0</code><em> without visiting a restricted node.</em></p>

<p>Note that node <code>0</code> will <strong>not</strong> be a restricted node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png" style="width: 412px; height: 312px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
	<li><code>1 &lt;= restricted.length &lt; n</code></li>
	<li><code>1 &lt;= restricted[i] &lt; n</code></li>
	<li>All the values of <code>restricted</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/reduce-the-array-2-2a1e3e02/" target="_blank" rel="noopener noreferrer">Reduce the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">minimum spanning tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <span class="mathjax-latex">\(N\)</span> numbers, and you are asked to minimize the total "<span class="mathjax-latex">\(OR \ \ cost\)</span>" incurred when reducing the array to a single number. To achieve this, you need to follow these steps:</p>

<ol>
	<li>Select any two numbers <span class="mathjax-latex">\(P\)</span> and <span class="mathjax-latex">\(Q\)</span> from the array. The cost of selecting these two numbers is <span class="mathjax-latex">\(((P + Q) + (P | Q) - (P &amp; Q))\)</span>, where "|" denotes the bitwise <span class="mathjax-latex">\(OR\)</span> operator, and "&amp;" denotes the bitwise <span class="mathjax-latex">\(AND\)</span> operator.</li>
	<li>
	<p>Choose one of the two numbers you selected in the previous step and remove it from the array. Concatenate the remaining numbers.</p>
	</li>
	<li>
	<p>Repeat the above two steps until the array is reduced to a single number.</p>
	</li>
</ol>

<p>The "<span class="mathjax-latex">\(OR\)</span> <span class="mathjax-latex">\(cost\)</span>" is defined as the bitwise <span class="mathjax-latex">\(OR\)</span> of all the costs incurred in reducing the array to a single number.</p>

<p>&nbsp;</p>

<p><u><strong>Input Format :</strong></u></p>

<p>An integer <span class="mathjax-latex">\(N\)</span> denoting the size of the array</p>

<p><span class="mathjax-latex">\(N\)</span> integers denoting the elements of the array</p>

<p><u><strong>Output Format :</strong></u></p>

<p>Print one integer, the minimum&nbsp;<span class="mathjax-latex">\(OR \ \ cost\)</span></p>

<p><u><strong>Constraints :</strong></u></p>

<p><u><strong><span class="mathjax-latex">\(1 \leq N \leq 10^3\)</span></strong></u></p>

<p><span class="mathjax-latex">\(1 \leq a_i \leq 10^6\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Sure, here's a possible rephrased version of the explanation:</p>

<p>Consider the following example array: [1, 5, 2, 3]. To minimize the total "OR cost," we can follow these steps:</p>

<ol>
	<li>
	<p>Select 1 and 5. Remove 5 from the array, and concatenate the remaining numbers [1, 2, 3]. The cost incurred is&nbsp;<span class="mathjax-latex">\(((1 + 5) + (1 | 5) - (1 &amp; 5)) = 10.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 2. Remove 2 from the array, and concatenate the remaining numbers [1, 3]. The cost incurred is <span class="mathjax-latex">\(((1 + 2) + (1 | 2) - (1 &amp; 2)) = 6.\)</span></p>
	</li>
	<li>
	<p>Select 1 and 3. Remove 1 from the array, and concatenate the remaining numbers [3]. The cost incurred is <span class="mathjax-latex">\(((1 + 3) + (1 | 3) - (1 &amp; 3)) = 6.\)</span></p>
	</li>
</ol>

<p>Thus, the total "OR cost" is the bitwise OR of the individual costs incurred, which is <span class="mathjax-latex">\((10 | 6 | 6)\)</span> = 14. It can be shown that we can never achieve a total cost less than 14 for this particular array.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection/description" target="_blank" rel="noopener noreferrer">Redundant Connection</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>

<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg" style="width: 382px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
<strong>Output:</strong> [1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= edges.length</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>There are no repeated edges.</li>
	<li>The given graph is connected.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a graph consisting of <span class="math inline">\(N\)</span> nodes and <span class="math inline">\(N âˆ’ 1\)</span> edges, which means the graph initially forms a tree. A tree is a special type of graph that is connected (there is a path between any two nodes) and acyclic (it does not contain any cycles). However, a new edge is added to the tree, connecting two nodes that are already part of the graph. This new edge creates a cycle because there are now two distinct paths between some pairs of nodes. As a result, the graph is no longer a tree but a single-cycle graph.</p>
<p>Our goal is to identify the edge that, if removed, will restore the graph to its original state as a tree. Since the tree must be connected and acyclic, removing any edge from the cycle will break the cycle and turn the graph into a tree. However, if there are multiple edges that can be removed to achieve this, we are required to return the edge that appears last in the given list of edges.</p>
<hr />
<h3 id="approach-1-depth-first-search---brute-force">Approach 1: Depth-First Search - Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The key idea is that we can safely discard an edge if it connects two nodes that are already part of the same connected component. In simple terms, this means that if there's already a path between the two nodes (even without the current edge), adding this edge would create a cycle, making it redundant.</p>
<p>To check if a path exists between two nodes, we can use graph traversal techniques such as Depth-First Search (DFS) or Breadth-First Search (BFS). In this approach, we will use DFS to verify whether the two nodes of each edge are already connected. If you're unfamiliar with DFS, you can explore this helpful <a href="https://leetcode.com/explore/featured/card/graph/">DFS guide</a>.</p>
<p>Now, as we go through the edges, we examine each one. For every edge, we use DFS to determine if the two nodes it connects are already part of the same connected component. If a path already exists, that means the nodes are connected, and we can safely discard the edge because it would create a cycle. If thereâ€™s no existing path, we know that the edge is essential for connecting the nodes, so we add it to our graph.</p>
<p>One important thing to remember is that we process the edges in the order they appear in the input list. This ensures that if multiple redundant edges are present, the last one we process will be the one that forms the cycle.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define the function <code>isConnected</code> that takes the source node <code>src</code>, target node <code>target</code>, boolean array <code>visited</code>, and the adjacency list <code>adjList</code>. This returns true if there's a path between <code>src</code> and <code>target</code> with the edges in the list <code>adjList</code> using DFS:
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>Initialize the variable <code>isFound</code> to <code>false</code>, this is going to denote the answer.</li>
<li>Recursively traverse to the unvisited adjacent nodes and check if the <code>target</code> node is found.</li>
<li>Return <code>isFound</code> in the end.</li>
</ul>
</li>
<li>Iterate over the list <code>edges</code> from left to and right and for each <code>edge</code>:
<ul>
<li>Initialize an empty array <code>visited</code> with all indices as <code>false</code>.</li>
<li>Call the method <code>isConnected</code> and if it returns <code>true</code> return <code>edge</code></li>
<li>Otherwise, add the edge to the adjacency list <code>adjList</code>.</li>
</ul>
</li>
<li>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ydw6rbYM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^2)\)</span>.</p>
<p>Iterating over each of the <span class="math inline">\(N\)</span> edges and performing a DFS to check if the nodes are already connected would result in <span class="math inline">\(N \times N\)</span> operations. The time complexity of a DFS is <span class="math inline">\(O(V+E)\)</span>, where <span class="math inline">\(V\)</span> is the number of vertices and <span class="math inline">\(E\)</span> is the number of edges. In this problem, both <span class="math inline">\(V\)</span> and <span class="math inline">\(E\)</span> are equal to <span class="math inline">\(N\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the <code>visited</code> array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls in the DFS, which can be as large as one per node. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search---single-traversal">Approach 2: Depth-First Search - Single Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We cannot remove just any edge from the graph, as doing so might disconnect the graph. The edge we remove must be part of the cycle. If we can identify the edges or nodes involved in the cycle, we can choose to remove the edge that appears last in the input edge list.</p>
<p>To detect the cycle in the graph, we need to identify at least one node that belongs to it. This can be accomplished using DFS while keeping track of the parent of each node, where the parent represents the node from which we reached the current node. If we encounter a node that has already been visited and the node we are coming from is different from its parent, we can conclude that the node is part of the cycle.</p>
<p>Once we identify a node in the cycle, we can backtrack through the parent array to find all the other nodes that are part of the cycle, until we return to the starting node. We will mark all these cycle nodes in an unordered map. Then, we iterate over the edges in reverse order, and if both nodes of an edge are marked in the map, we can discard this edge as it forms the cycle. Finally, we can return this redundant edge.</p>
<p><img src="../Figures/684/684A.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Set <code>cycleStart</code> to <code>-1</code> to mark the start of the cycle.</li>
<li>Create a <code>visited</code> array to keep track of visited nodes.</li>
<li>Create a <code>parent</code> array to store the parent of each node in the DFS traversal.</li>
<li>Initialize an adjacency list <code>adjList</code> to represent the graph.</li>
</ul>
</li>
<li>
<p>Build the Graph:</p>
<ul>
<li>Loop through each edge in the input <code>edges</code> list.</li>
<li>For each edge <code>[u, v]</code>, add <code>v</code> to <code>adjList[u]</code> and <code>u</code> to <code>adjList[v]</code> to make the graph undirected.</li>
</ul>
</li>
<li>
<p>Start a DFS from node <code>0</code> (or any node, as the graph is connected).</p>
<ul>
<li>In the DFS function:
<ul>
<li>Mark the current node as visited.</li>
<li>For each adjacent node, check if it's visited:
<ul>
<li>If not visited, recursively call DFS on the adjacent node, and update its parent.</li>
<li>If the node is visited and its parent is different from the previous one, mark it as <code>cycleStart</code> to identify the cycle.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Track Cycle Nodes:</p>
<ul>
<li>Using the <code>parent</code> array, backtrack from <code>cycleStart</code> to collect all nodes in the cycle.</li>
<li>Store these nodes in the <code>cycleNodes</code> map for quick lookup.</li>
</ul>
</li>
<li>
<p>Identify the Redundant Edge:</p>
<ul>
<li>Iterate through the edges in reverse order.</li>
<li>For each edge, check if both nodes of the edge are in the <code>cycleNodes</code> map:
<ul>
<li>If both nodes are in the cycle, return this edge as the redundant connection.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5URgLFer/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We perform the DFS starting from node <code>0</code> only once, which has a time complexity of <span class="math inline">\(O(N)\)</span>. Then, we iterate over the cycle nodes using the <code>parent</code> array, with a maximum of <span class="math inline">\(N\)</span> iterations if all nodes are part of the cycle. Finally, we iterate over all edges and check the map in <span class="math inline">\(O(1)\)</span> time for each edge. Therefore, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list <code>adjList</code> will store <span class="math inline">\(N\)</span> edges, and the size of the visited array is <span class="math inline">\(N\)</span>. Additionally, space is required for the active stack calls during DFS, which can be as large as one per node. The map <code>cycleNodes</code> can contain at most <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-dsu">Approach 3: Disjoint Set Union (DSU)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Weâ€™re still working with the same core idea as in the first approach: an edge can be discarded if the nodes it connects are already part of the same component. In the previous approach, we used DFS to check if a path existed between the nodes. However, there's an alternative and more efficient way to do this using a data structure called Disjoint Set Union (DSU).</p>
<blockquote>
<p>If you are not familiar with DSU, please go through our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Explore Card</a>. We will not talk about implementation details here and assume you are already familiar with the interface of DSU.</p>
</blockquote>
<p>The idea behind DSU is that each node is in its own a separate set. As we go through the edges, we perform a union operation that merges the sets of the two connected nodes. This helps us track which nodes are in the same component. If, during this process, we encounter an edge where the two nodes are already in the same component (i.e., they share the same representative), we know that adding this edge would create a cycle, so itâ€™s redundant and can be safely discarded.</p>
<p>The great thing about DSU is that it can check whether two nodes are in the same component in nearly constant time, specifically in <span class="math inline">\(O(Î±(N))\)</span>, where <span class="math inline">\(Î±(N)\)</span> is the inverse Ackermann function (which grows extremely slowly). This makes DSU much faster than DFS for this type of problems.</p>
<p>In this approach, we treat each node as its own component at the start. As we process each edge, we perform the union operation to merge the components of the two nodes connected by the edge. If the nodes are in different components, we unite them and update their representatives. If the nodes are already in the same component, weâ€™ve found a redundant edge and return it as the result.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Define DSU (Disjoint Set Union):</p>
<ul>
<li>Initialize two arrays:
<ul>
<li><code>size[]</code> to store the size of each component (starts with 1 for each node).</li>
<li><code>representative[]</code> to track the representative (or root) of each component (initially, each node is its own representative).</li>
<li>Find Operation (<code>find</code>):
<ul>
<li>For each node, find its ultimate representative (root of the component).</li>
<li>Path Compression: During the recursive search, update the representative of each visited node to directly point to the root, speeding up future lookups.</li>
</ul>
</li>
<li>Union Operation (<code>doUnion</code>):
<ul>
<li>Check if the two nodes belong to the same component:</li>
<li>If they already share the same representative, they are part of the same component, so adding this edge would form a cycle. Return <code>false</code>.</li>
<li>If the nodes belong to different components, union them:</li>
<li>Attach the smaller component to the larger one (union by size), ensuring the tree remains balanced to minimize depth.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate Through Edges:</p>
<ul>
<li>Process each edge in the list of edges:
<ul>
<li>Convert the 1-based indices from the input to 0-based for array indexing.</li>
<li>Use <code>doUnion</code> to attempt connecting the nodes of the edge.</li>
<li>If <code>doUnion</code> returns <code>false</code>, it means adding this edge would form a cycle, so return the current edge as the redundant edge.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the input is valid, this part of the code should be unreachable. Return an empty list <code>{}</code> in such cases.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/JWuYpx4d/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes and edges in the given graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot \alpha(N))\)</span></p>
<p>We iterate over all edges, and for each edge, we invoke the <code>doUnion</code> function, which has a time complexity of <span class="math inline">\(O(\alpha(N))\)</span>, given that both union by size and path compression are employed. Consequently, the overall time complexity of the algorithm is <span class="math inline">\(O(N \cdot \alpha(N))\)</span>. It is important to note that <span class="math inline">\(\alpha(N)\)</span> represents the inverse Ackermann function, which grows so slowly that it is often considered asymptotically constant, or <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The list <code>representative</code>, used to store the representatives, and the list <code>size</code>, used to store the size of each component, will each contain <span class="math inline">\(N\)</span> entries. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/redundant-connection-ii/description" target="_blank" rel="noopener noreferrer">Redundant Connection II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>

<p>The given input is a directed graph that started as a rooted tree with <code>n</code> nodes (with distinct values from <code>1</code> to <code>n</code>), with one additional directed edge added. The added edge has two different vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed.</p>

<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u<sub>i</sub>, v<sub>i</sub>]</code> that represents a <b>directed</b> edge connecting nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, where <code>u<sub>i</sub></code> is a parent of child <code>v<sub>i</sub></code>.</p>

<p>Return <em>an edge that can be removed so that the resulting graph is a rooted tree of</em> <code>n</code> <em>nodes</em>. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg" style="width: 222px; height: 382px;" />
<pre>
<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
<strong>Output:</strong> [4,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>3 &lt;= n &lt;= 1000</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Starting from a rooted tree with <code>N-1</code> edges and <code>N</code> vertices, let's enumerate the possibilities for the added &quot;redundant&quot; edge. If there is no loop, then either one vertex must have two parents (or no edge is redundant). If there is a loop, then either one vertex has two parents, or every vertex has one parent.</p>
<p>In the first two cases, there are only two candidates for deleting an edge, and we can try removing the last one and seeing if that works. In the last case, the last edge of the cycle can be removed: for example, when <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>, we want the last edge (by order of occurrence) in the cycle <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> (but not necessarily <code>1-&gt;5</code>).</p>
<p><strong>Algorithm</strong></p>
<p>We'll first construct the underlying graph, keeping track of edges coming from nodes with multiple parents. After, we either have 2 or 0 <code>candidates</code>.</p>
<p>If there are no candidates, then every vertex has one parent, such as in the case <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>. From any node, we walk towards its parent until we revisit a node - then we must be inside the cycle, and any future seen nodes are part of that cycle.  Now we take the last edge that occurs in the cycle.</p>
<p>Otherwise, we'll see if the graph induced by <code>parent</code> is a rooted tree. We again take the <code>root</code> by walking from any node towards the parent until we can't, then we perform a depth-first search on this <code>root</code>. If we visit every node, then removing the last of the two edge candidates is acceptable, and we should.  Otherwise, we should remove the first of the two edge candidates.</p>
<p>In our solution, we use <code>orbit</code> to find the result upon walking from a node <code>x</code> towards its parent repeatedly until you revisit a node or can't walk anymore.  <code>orbit(x).node</code> (or <code>orbit(x)[0]</code> in Python) will be the resulting node, while <code>orbit(x).seen</code> (or <code>orbit(x)[1]</code>) will be all the nodes visited.</p>
<p><a href="https://leetcode.com/playground/GbE4kZpx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> where <span class="math inline">\(N\)</span> is the number of vertices (and also the number of edges) in the graph. We perform a depth-first search.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the graph.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/regions-cut-by-slashes/description" target="_blank" rel="noopener noreferrer">Regions Cut By Slashes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <code>n x n</code> grid is composed of <code>1 x 1</code> squares where each <code>1 x 1</code> square consists of a <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or blank space <code>&#39; &#39;</code>. These characters divide the square into contiguous regions.</p>

<p>Given the grid <code>grid</code> represented as a string array, return <em>the number of regions</em>.</p>

<p>Note that backslash characters are escaped, so a <code>&#39;\&#39;</code> is represented as <code>&#39;\\&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/1.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;/ &quot;]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/2.png" style="width: 200px; height: 198px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;  &quot;]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/4.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot;/\\&quot;,&quot;\\/&quot;]
<strong>Output:</strong> 5
<strong>Explanation: </strong>Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or <code>&#39; &#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Many have found this problem to be a difficult medium problem, so if that is how you are feeling, you are not alone. <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a> is a good starter problem if you find yourself struggling with this one.</p>
<p>We are given an array of strings called <code>grid</code>, which contains three types of characters: forward slash <code>/</code>, backslash <code>\\</code>, and space <code>' '</code>. Each slash divides its cell into two contiguous sections, as shown in the following image:</p>
<p><img src="../Figures/959__re/image_1.png" alt="examples to show how the grid is formed" /></p>
<p>Our objective is to determine the total number of distinct regions formed within the grid as a result of these slash divisions.</p>
<hr />
<h3 id="approach-1-expanded-grid">Approach 1: Expanded Grid</h3>
<h4 id="intuition">Intuition</h4>
<p>When a cell in the grid contains a slash, it effectively divides it into two parts. A forward slash divides the cell into top-left and bottom-right sections, while a backslash divides it into top-right and bottom-left sections. As you can see in Example 2 of the problem, counting the regions directly is challenging since a divided cell does not always lead to an additional region.</p>
<p>To address this, we can magnify the grid by expanding each cell into a <span class="math inline">\(3 \times 3\)</span> sub-grid, with slashes represented by diagonal cells marked as barriers:</p>
<p><img src="../Figures/959__re/image_2.png" alt="" /></p>
<p>This transformation simplifies our task. If we treat the slashes and grid boundaries as water, and the remaining cells as land, the problem becomes analogous to the <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a>.</p>
<p>We can solve this using the <a href="https://en.wikipedia.org/wiki/Flood_fill">flood-fill algorithm</a> to visit each connected region in the grid. We iterate over each cell of the grid and invoke <code>floodfill</code> whenever we encounter an unvisited land cell. The <code>floodfill</code> function explores all reachable land cells from the current cell and marks them as visited.  Then, we continue to iterate over each cell in the grid until we reach the next unvisited cell, which signifies the next land region. The total number of <code>floodfill</code> calls corresponds to the number of regions in the grid, which is our desired answer.</p>
<blockquote>
<p>Note: In our implementation, we use Breadth-First Search (BFS) for the flood-fill algorithm. Alternatively, Depth-First Search (DFS) can also be employed, yielding similar time and space complexities.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize an array <code>DIRECTIONS</code> to specify traversal directions: right, left, down, and up.</li>
</ul>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the original grid.</li>
<li>Create a new 2D array <code>expandedGrid</code> with dimensions three times the original grid size.</li>
<li>Iterate through each cell <code>(i, j)</code> in the original <code>grid</code>:
<ul>
<li>Calculate <code>baseRow</code> and <code>baseCol</code> as three times of <code>i</code> and <code>j</code>.</li>
<li>Check the character in the current cell:
<ul>
<li>If it is a backslash (<code>\\</code>):
<ul>
<li>Mark the cells in the main diagonal <code>(baseRow, baseCol)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol+2)</code> as <code>1</code>.</li>
</ul>
</li>
<li>If it is a forward slash (<code>/</code>):
<ul>
<li>Mark the other diagonal <code>(baseRow, baseCol+2)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol)</code> as <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a counter <code>regionCount</code> to <code>0</code>.</li>
<li>Iterate through each cell <code>(i, j)</code> in <code>expandedGrid</code>:
<ul>
<li>If the cell is unvisited (value <code>0</code>):
<ul>
<li>Call the <code>floodfill</code> method to fill the region.</li>
<li>Increment <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as the total number of distinct regions.</li>
</ul>
<p>Helper method <code>floodfill</code>:</p>
<ul>
<li>Define a method <code>floodfill</code> with parameters: <code>expandedGrid</code> and the <code>row</code> and <code>col</code> indices.</li>
<li>Initialize a queue and add the starting cell <code>(row, col)</code> to it.</li>
<li>Mark the starting cell as visited by setting <code>expandedGrid[row][col]</code> to <code>1</code>.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Dequeue <code>currentCell</code>.</li>
<li>For each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Set <code>newRow</code> as <code>currentCell[0] + direction[0]</code>.</li>
<li>Set <code>newCol</code> as <code>currentCell[1] + direction[1]</code>.</li>
<li>Check if the new cell is valid and unvisited using the <code>isValidCell</code> method:
<ul>
<li>If valid, mark the cell as visited and add it to the <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidCell</code>.</p>
<ul>
<li>Define a method <code>isValidCell</code> with parameters: <code>expandedGrid</code>, <code>row</code>, and <code>col</code>.</li>
<li>Return <code>true</code> if the cell <code>(row, col)</code> is within bounds and unvisited.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MHLtBUxW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm populates the expanded grid by iterating over the original grid, which takes <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>In the worst case, the flood fill algorithm will visit every cell in the expanded grid once. The expanded grid is <span class="math inline">\(3n \times 3n\)</span>, resulting in <span class="math inline">\(O((3n)^2) = O(9n^2) = O(n^2)\)</span> operations.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(2 \cdot O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The expanded grid has dimensions <span class="math inline">\(3n \times 3n\)</span>, which requires <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>In the flood fill algorithm, the queue can store all <span class="math inline">\(9n^2\)</span> cells of the expanded grid in the worst case. This results in a space complexity of <span class="math inline">\(O(9n^2) = O(n^2)\)</span>.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2) + O(n^2) = O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-disjoint-set-union-triangles">Approach 2: Disjoint Set Union (Triangles)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our previous approach involved magnifying each cell into a <span class="math inline">\(3 \times 3\)</span> grid, increasing the number of unit cells by a factor of 9. We can further optimize this process by reconceptualizing how regions are formed and connected. Instead of viewing the grid as squares, let's envision each cell divided into four triangles. This allows for a more precise representation of slashes.</p>
<p><img src="../Figures/959__re/image_3.png" alt="cell divided into four triangles" /></p>
<p>Initially, each triangle is considered its own region. As we traverse the grid, we can group together all triangles not separated by slashes as belonging to one component (region). The total number of these groups will be our required answer.</p>
<p>A widely used data structure for grouping connected components is the Disjoint Set Union (DSU). A DSU assigns each component (a unit triangle) a parent, which is initially itself. To connect or union two components, we assign them to the same parent, meaning units with the same parent belong to the same connected component. To learn more about how the disjoint set union data structure is implemented, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Explore Card</a>.</p>
<p>We iterate over the grid and perform two main types of operations:</p>
<ol>
<li>
<p>Union adjacent components:</p>
<p>Regardless of whether a cell contains a forward slash or backslash, the top triangle of a cell will always connect to the bottom triangle of the cell above it. The same principle applies to the left triangle of a cell and the right triangle of the cell to its left.</p>
<p><img src="../Figures/959__re/image_4.png" alt="connecting top and left cells" /></p>
</li>
<li>
<p>Union intra-cell components:</p>
<p>A slash divides the cell diagonally, allowing us to combine the two adjacent triangles on each side of the diagonal.</p>
</li>
</ol>
<p>We begin with the total number of triangles as our initial region count. Each successful union operation indicates that two distinct components have been merged into one, reducing the total number of regions by one. After processing all cells, the remaining count represents the number of distinct regions.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the <code>grid</code>.</li>
<li>Calculate <code>totalTriangles</code> in the grid as <code>gridSize * gridSize * 4</code>.</li>
<li>Create a <code>parentArray</code> to represent the disjoint sets of triangles and initialize each element to <code>-1</code>.</li>
<li>Initialize <code>regionCount</code> to <code>totalTriangles</code>, assuming each triangle is initially a separate region.</li>
<li>Iterate through each cell of <code>grid</code>:
<ul>
<li>If there is a cell above the current cell, union the bottom triangle of the above cell with the top triangle of the current cell.</li>
<li>If there is a cell to the left of the current cell, union the right triangle of the left cell with the left triangle of the current cell.</li>
<li>If the current cell is not <code>/</code>:
<ul>
<li>Union the top triangle with the right triangle.</li>
<li>Union the bottom triangle with the left triangle.</li>
</ul>
</li>
<li>If the current cell is not <code>\\</code>:
<ul>
<li>Union the top triangle with the left triangle.</li>
<li>Union the bottom triangle with the right triangle.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as our answer.</li>
</ul>
<p>Helper method <code>getTriangleIndex</code>:</p>
<ul>
<li>Define a method <code>getTriangleIndex</code> with parameters: <code>gridSize</code>, the <code>row</code> and <code>col</code> indices, and the <code>triangleNum</code>.</li>
<li>Return <code>(gridSize * row + col) * 4 + triangleNum</code>.</li>
</ul>
<p>Helper method <code>unionTriangles</code>:</p>
<ul>
<li>Define a method <code>unionTriangles</code> with parameters: <code>parentArray</code> and the two indices <code>x</code> and <code>y</code>.</li>
<li>Find <code>parentX</code> and <code>parentY</code> using the <code>findParent</code> method.</li>
<li>If <code>parentX</code> is not equal to <code>parentY</code>:
<ul>
<li>Set <code>parentArray[parentX]</code> to <code>parentY</code> and return <code>1</code>.</li>
</ul>
</li>
<li>Return <code>0</code>.</li>
</ul>
<p>Helper method <code>findParent</code>:</p>
<ul>
<li>Define a method <code>findParent</code> with parameters: <code>parentArray</code> and the index <code>x</code>.</li>
<li>If <code>parentArray[x]</code> is equal to <code>-1</code>:
<ul>
<li><code>x</code> has no parent. Return <code>x</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[x]</code> to the parent of <code>parentArray[x]</code> using <code>findParent</code>. Return <code>parentArray[x]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gejLBoVS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span></p>
<p>Initializing the <code>parentArray</code> takes <span class="math inline">\(O(4 \cdot n^2)\)</span> time.</p>
<p>The main loop iterates over all <span class="math inline">\(n^2\)</span> cells in the grid. In each iteration, it calls the <code>unionTriangles</code> method which includes <code>findPath</code> operations. With path compression, the amortized time complexity of <code>findPath</code> is denoted as <span class="math inline">\(\alpha(n)\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. Thus, the time complexity of the loop comes out to be <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(4 \cdot n^2) + O(n^2 \cdot \alpha (n)) = O(n^2 \cdot \alpha (n))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The only additional data structure used by the algorithm is the <code>parentArray</code>, which takes <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>The recursive <code>find</code> operation can have a call stack of size <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-graph">Approach 3: Disjoint Set Union (Graph)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's shift our perspective and consider slashes as connectors rather than dividers. Imagine each cell as a graph with four vertices at its corners, with slashes acting as edges between these vertices. The following diagram illustrates this concept:</p>
<p><img src="../Figures/959__re/image_5.png" alt="cell as a graph" /></p>
<p>In this paradigm, a slash can be represented as follows:</p>
<ul>
<li>A <code>/</code> slash connects the top-right point of a cell to the bottom-left point.</li>
<li>A <code>\</code> slash connects the top-left point to the bottom-right point.</li>
<li>An empty space doesn't add any new connections.</li>
</ul>
<p>The edges of the grid form the boundaries of the graph, creating an initial region. As we connect vertices (slashes), cycles may form, indicating the creation of new regions within the graph. By tracking the total number of cycles formed while iterating over all slashes, we determine the final count of regions.</p>
<p>To manage connected components, we use a DSU (Disjoint Set Union) data structure. We start by connecting the boundary points as the first region. As we process each cell, we treat each slash as an edge and union the corresponding vertices. If a union operation reveals that the vertices already share the same parent, it indicates a cycle, prompting us to increment our counter.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Initialize variables:
<ul>
<li><code>gridSize</code> to the length of <code>grid</code>.</li>
<li><code>pointsPerSide</code> to <code>gridSize + 1</code>.</li>
<li><code>totalPoints</code> to <code>pointsPerSide * pointsPerSide</code>.</li>
</ul>
</li>
<li>Create an array <code>parentArray</code> to represent the disjoint set, initialized with <code>-1</code>.</li>
<li>Loop over the each point:
<ul>
<li>If the point lies on the border, set its <code>parent</code> to <code>0</code>.</li>
</ul>
</li>
<li>Set <code>parent[0]</code> (top-left corner) to <code>-1</code> to make it the root.</li>
<li>Initialize <code>regionCount</code> to <code>1</code>, accounting for the border region.</li>
<li>Iterate through each cell <code>(i, j)</code> in the <code>grid</code>:
<ul>
<li>If it's a forward slash (<code>/</code>):
<ul>
<li>Calculate the <code>topRight</code> and <code>bottomLeft</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
<li>If it's a backslash (<code>\\</code>):
<ul>
<li>Calculate the <code>topLeft</code> and <code>bottomRight</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>regionCount</code>.</li>
</ul>
<p>Helper method <code>find</code>:</p>
<ul>
<li>Define a method <code>find</code> with parameters: <code>parentArray</code> and the <code>node</code>.</li>
<li>If <code>parentArray[node]</code> is equal to <code>-1</code>:
<ul>
<li><code>node</code> does not have any parent. Return <code>node</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[node]</code> to the parent of <code>parentArray[node]</code> using the <code>find</code> method. Return <code>parentArray[node]</code>.</li>
</ul>
<p>Helper method <code>union</code>:</p>
<ul>
<li>Define a method union with parameters: <code>parentArray</code> and nodes <code>node1</code> and <code>node2</code>.</li>
<li>Set <code>parent1</code> to <code>parent2</code> to the parents of <code>node1</code> and <code>node2</code> respectively.</li>
<li>If <code>parent1</code> is equal to <code>parent2</code>, return <code>1</code>.</li>
<li>Set <code>parentArray[parent2]</code> to <code>parent1</code>.</li>
<li>Return <code>0</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/C84Mt6ZN/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span></p>
<p>Filling the parent array requires <span class="math inline">\(O((n+1) \cdot (n+1))\)</span> time, which can be simplified to <span class="math inline">\(O(n^2)\)</span>. Connecting the border points requires another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>As the algorithm iterates over the grid, it potentially performs two <code>union</code> operations for each cell. The time complexity of a single <code>find</code>/<code>union</code> operation is <span class="math inline">\(O(\alpha (n^2))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. We perform at most <span class="math inline">\(O(n^2)\)</span> union operations, making the complexity of this part <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n^2) + O(n^2 \cdot 2 \alpha (n^2)) = O(n^2 \cdot \alpha (n^2))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm creates an array of size <span class="math inline">\((n+1)^2\)</span>, which is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The recursive call stack for <code>find</code> operation is <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description" target="_blank" rel="noopener noreferrer">Remove Max Number of Edges to Keep Graph Fully Traversable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob have an undirected graph of <code>n</code> nodes and three types of edges:</p>

<ul>
	<li>Type 1: Can be traversed by Alice only.</li>
	<li>Type 2: Can be traversed by Bob only.</li>
	<li>Type 3: Can be traversed by both Alice and Bob.</li>
</ul>

<p>Given an array <code>edges</code> where <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code> represents a bidirectional edge of type <code>type<sub>i</sub></code> between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.</p>

<p>Return <em>the maximum number of edges you can remove, or return</em> <code>-1</code> <em>if Alice and Bob cannot fully traverse the graph.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex1.png" style="width: 179px; height: 191px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
<strong>Output:</strong> 2
<strong>Explanation: </strong>If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex2.png" style="width: 178px; height: 190px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
<strong>Output:</strong> 0
<strong>Explanation: </strong>Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/ex3.png" style="width: 178px; height: 190px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
<strong>Output:</strong> -1
<b>Explanation: </b>In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it&#39;s impossible to make the graph fully traversable.</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, 3 * n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>1 &lt;= type<sub>i</sub> &lt;= 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt;= n</code></li>
	<li>All tuples <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/satisfiability-of-equality-equations/description" target="_blank" rel="noopener noreferrer">Satisfiability of Equality Equations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>equations</code> that represent relationships between variables where each string <code>equations[i]</code> is of length <code>4</code> and takes one of two different forms: <code>&quot;x<sub>i</sub>==y<sub>i</sub>&quot;</code> or <code>&quot;x<sub>i</sub>!=y<sub>i</sub>&quot;</code>.Here, <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>

<p>Return <code>true</code><em> if it is possible to assign integers to variable names so as to satisfy all the given equations, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;a==b&quot;,&quot;b!=a&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;b==a&quot;,&quot;a==b&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> We could assign a = 1 and b = 1 to satisfy both equations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 500</code></li>
	<li><code>equations[i].length == 4</code></li>
	<li><code>equations[i][0]</code> is a lowercase letter.</li>
	<li><code>equations[i][1]</code> is either <code>&#39;=&#39;</code> or <code>&#39;!&#39;</code>.</li>
	<li><code>equations[i][2]</code> is <code>&#39;=&#39;</code>.</li>
	<li><code>equations[i][3]</code> is a lowercase letter.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/similar-string-groups/description" target="_blank" rel="noopener noreferrer">Similar String Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Two strings, <code>X</code> and <code>Y</code>, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string <code>X</code>.</p>

<p>For example, <code>&quot;tars&quot;</code>&nbsp;and <code>&quot;rats&quot;</code>&nbsp;are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>

<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.&nbsp; Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.&nbsp; Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>

<p>We are given a list <code>strs</code> of strings where every string in <code>strs</code> is an anagram of every other string in <code>strs</code>. How many groups are there?</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strs = [&quot;omv&quot;,&quot;ovm&quot;]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strs.length &lt;= 300</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>
	<li><code>strs[i]</code> consists of lowercase letters only.</li>
	<li>All words in <code>strs</code> have the same length and are anagrams of each other.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/description" target="_blank" rel="noopener noreferrer">Smallest Missing Genetic Value in Each Subtree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>family tree</strong> rooted at <code>0</code> consisting of <code>n</code> nodes numbered <code>0</code> to <code>n - 1</code>. You are given a <strong>0-indexed</strong> integer array <code>parents</code>, where <code>parents[i]</code> is the parent for node <code>i</code>. Since node <code>0</code> is the <strong>root</strong>, <code>parents[0] == -1</code>.</p>

<p>There are <code>10<sup>5</sup></code> genetic values, each represented by an integer in the <strong>inclusive</strong> range <code>[1, 10<sup>5</sup>]</code>. You are given a <strong>0-indexed</strong> integer array <code>nums</code>, where <code>nums[i]</code> is a <strong>distinct </strong>genetic value for node <code>i</code>.</p>

<p>Return <em>an array </em><code>ans</code><em> of length </em><code>n</code><em> where </em><code>ans[i]</code><em> is</em> <em>the <strong>smallest</strong> genetic value that is <strong>missing</strong> from the subtree rooted at node</em> <code>i</code>.</p>

<p>The <strong>subtree</strong> rooted at a node <code>x</code> contains node <code>x</code> and all of its <strong>descendant</strong> nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-1.png" style="width: 204px; height: 167px;" />
<pre>
<strong>Input:</strong> parents = [-1,0,0,2], nums = [1,2,3,4]
<strong>Output:</strong> [5,1,1,1]
<strong>Explanation:</strong> The answer for each subtree is calculated as follows:
- 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value.
- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.
- 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value.
- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-2.png" style="width: 247px; height: 168px;" />
<pre>
<strong>Input:</strong> parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
<strong>Output:</strong> [7,1,1,4,2,1]
<strong>Explanation:</strong> The answer for each subtree is calculated as follows:
- 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value.
- 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value.
- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.
- 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value.
- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.
- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
<strong>Output:</strong> [1,1,1,1,1,1,1]
<strong>Explanation:</strong> The value 1 is missing from all the subtrees.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parents.length == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parents[i] &lt;= n - 1</code> for <code>i != 0</code></li>
	<li><code>parents[0] == -1</code></li>
	<li><code>parents</code> represents a valid tree.</li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li>Each <code>nums[i]</code> is distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-string-with-swaps/description" target="_blank" rel="noopener noreferrer">Smallest String With Swaps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, and an array of pairs of indices in the string&nbsp;<code>pairs</code>&nbsp;where&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;indicates 2 indices(0-indexed) of the string.</p>

<p>You can&nbsp;swap the characters at any pair of indices in the given&nbsp;<code>pairs</code>&nbsp;<strong>any number of times</strong>.</p>

<p>Return the&nbsp;lexicographically smallest string that <code>s</code>&nbsp;can be changed to after using the swaps.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]
<strong>Output:</strong> &quot;bacd&quot;
<strong>Explaination:</strong> 
Swap s[0] and s[3], s = &quot;bcad&quot;
Swap s[1] and s[2], s = &quot;bacd&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explaination: </strong>
Swap s[0] and s[3], s = &quot;bcad&quot;
Swap s[0] and s[2], s = &quot;acbd&quot;
Swap s[1] and s[2], s = &quot;abcd&quot;</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cba&quot;, pairs = [[0,1],[1,2]]
<strong>Output:</strong> &quot;abc&quot;
<strong>Explaination: </strong>
Swap s[0] and s[1], s = &quot;bca&quot;
Swap s[1] and s[2], s = &quot;bac&quot;
Swap s[0] and s[1], s = &quot;abc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
	<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
	<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>
	<li><code>s</code>&nbsp;only contains lower case English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/little-shino-and-friends-98204bd8/" target="_blank" rel="noopener noreferrer">Students and their arrangements &lt;CAST&gt;</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">medium</span> <span class="topic-badge">queue</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a long line of students in the mess. Each student has a different roll number. Whenever a student will come in the mess, he will search for his friend from the end of the line. As soon as he finds a friend, he stands behind him else at the end of the line. You are the mess manager. At any moment you can ask the student, who is standing in front of the queue, to come and take the food and go out of the mess.</p>

<p>There are <em>N</em> operations of one of the following types:</p>

<ul>
	<li><span class="mathjax-latex">\(E\; x\)</span>: A student whose roll number is <em>x</em> <span class="mathjax-latex">\((1 \le x \le 10^5)\)</span> will stand in line according to the method mentioned above.</li>
	<li><em>D</em>: You will ask the student, who is standing in front of the line, to come and take the food and go out of the mess. For each of the <span class="mathjax-latex">\(2^{nd}\)</span> type of query, print the roll number of the student, who is standing in front of the line, to come and take the food and go out of the mess.</li>
</ul>

<p><strong>Note:</strong> Friendship is associative i.e. if <em>a</em> is a friend of <em>b</em> and <em>b</em> is a friend of <em>c</em>, then <em>a</em> is a friend of <em>c</em>.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains two space-separated integers, <em>N</em> and <em>M</em> <span class="mathjax-latex">\((1 \le N \le 10^5, 0 \le M \le 10^5)\)</span>, denoting the number of queries and number of friendships respectively.</li>
	<li>Next <em>M</em> lines contain two space separated integers each, <em>a</em> and <em>b</em> <span class="mathjax-latex">\((1 \le a, b \le 10^5)\)</span>, denoting that <em>a</em> is a friend of <em>b</em>.</li>
	<li>Next <em>N</em> lines contain one of the two types of queries.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each of the <span class="mathjax-latex">\(second\)</span> type of query, print the roll number of the student, who is standing in front of the line, to come and take the food and go out of the mess.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>After first operation, student with roll number <em>1</em>, will stand in the front of the queue as the queue is empty initially.</p>

<p><span class="mathjax-latex">\(Q = 1\)</span></p>

<p>After second operation, student with roll number <em>3</em>, will stand behind the first student as there is no other member of the same in the queue.</p>

<p><span class="mathjax-latex">\(Q = 1\)</span> &lt;- <em>3</em></p>

<p>After third operation, student with roll number <em>2</em>, will stand behind his friend (i.e. <em>1</em>) in the queue.</p>

<p><span class="mathjax-latex">\(Q = 1\)</span> &lt;- <em>2</em> &lt;- <em>3</em></p>

<p>After fourth operation, the student with roll number <em>1</em> in the front will come and take the food and go out of the mess.</p>

<p><span class="mathjax-latex">\(Q = 2\)</span> &lt;- <em>3</em></p>

<p>After fifth operation, the student with roll number <em>2</em> in the front will come and take the food and go out of the mess.</p>

<p><span class="mathjax-latex">\(Q = 3\)</span></p>

<p>After sixth operation, the student with roll number <em>3</em> in the front will come and take the food and go out of the mess.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/description" target="_blank" rel="noopener noreferrer">Subarray With Elements Greater Than Varying Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>threshold</code>.</p>

<p>Find any subarray of <code>nums</code> of length <code>k</code> such that <strong>every</strong> element in the subarray is <strong>greater</strong> than <code>threshold / k</code>.</p>

<p>Return<em> the <strong>size</strong> of <strong>any</strong> such subarray</em>. If there is no such subarray, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,3,1], threshold = 6
<strong>Output:</strong> 3
<strong>Explanation:</strong> The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.
Note that this is the only valid subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,6,5,8], threshold = 7
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [8] has a size of 1, and 8 &gt; 7 / 1 = 7. So 1 is returned.
Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. 
Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.
Therefore, 2, 3, 4, or 5 may also be returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/surrounded-regions/description" target="_blank" rel="noopener noreferrer">Surrounded Regions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>board</code> containing <strong>letters</strong> <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>:</p>

<ul>
	<li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li>
	<li><strong>Region</strong>: To form a region <strong>connect every</strong> <code>&#39;O&#39;</code> cell.</li>
	<li><strong>Surround</strong>: The region is surrounded with <code>&#39;X&#39;</code> cells if you can <strong>connect the region </strong>with <code>&#39;X&#39;</code> cells and none of the region cells are on the edge of the <code>board</code>.</li>
</ul>

<p>To capture a <strong>surrounded region</strong>, replace all <code>&#39;O&#39;</code>s with <code>&#39;X&#39;</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 367px; height: 158px;" />
<p>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;]]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swim-in-rising-water/description" target="_blank" rel="noopener noreferrer">Swim in Rising Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>

<p>It starts raining, and water gradually rises over time. At time <code>t</code>, the water level is <code>t</code>, meaning <strong>any</strong> cell with elevation less than equal to <code>t</code> is submerged or reachable.</p>

<p>You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>

<p>Return <em>the minimum time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,2],[1,3]]
<strong>Output:</strong> 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg" style="width: 404px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>
	<li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/tree-journeys-fd9f8f9c/" target="_blank" rel="noopener noreferrer">Tree Trips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">bruteforce</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is going to make <span class="mathjax-latex">\(m\)</span>&nbsp;trips on a <strong>tree</strong>. During each trip he goes from a node, <span class="mathjax-latex">\(x_{i}\)</span>,&nbsp;to another node, <span class="mathjax-latex">\(y_{i}\)</span>, using the simple path between the two nodes.&nbsp;</p>

<p>Alice is jealous of Bob, and doesn't want him to be able to go on any of the <span class="mathjax-latex">\(m\)</span> trips. Before Bob wakes up, Alice plans to remove some edges in the tree, in a way that Bob wouldn't be able to make <strong>any of the <span class="mathjax-latex">\(m\)</span> trips</strong>.&nbsp;</p>

<p>Please, help Alice find out the <strong>minimum </strong>number of edges she should remove from the tree, so Bob cannot make any of the trips.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>INPUT FORMAT</strong></p>

<p>The first line of input contains two integers,&nbsp;<span class="mathjax-latex">\(n\)</span>&nbsp;<span class="mathjax-latex">\((2 &lt;= n &lt;= 15)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;<span class="mathjax-latex">\((1 &lt;= m &lt;= \frac{n(n - 1)}{2})\)</span>&nbsp;- denoting the number of nodes in the tree, and the number of trips Bob wants to make.&nbsp;</p>

<p>The next&nbsp;<span class="mathjax-latex">\(n - 1\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(u_{i} (1 &lt;= u_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(v_{i} (1 &lt;= v_{i} &lt;= n)\)</span>&nbsp;(<span class="mathjax-latex">\(u_{i} &lt; v_{i}\)</span>)&nbsp;- denoting the edges in the tree.&nbsp;</p>

<p>The last&nbsp;<span class="mathjax-latex">\(m\)</span>&nbsp;lines each contain two integers,&nbsp;<span class="mathjax-latex">\(x_{i} (1 &lt;= x_{i} &lt;= n)\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(y_{i} (1 &lt;= y_{i} &lt;= n)\)</span>&nbsp;<span class="mathjax-latex">\((x_{i} \neq y_{i})\)</span>&nbsp;- denoting start and end nodes of the trips Bob wants to make.&nbsp;</p>

<p>&nbsp;</p>

<p><strong>OUTPUT FORMAT</strong></p>

<p>The minimum number of edges Alice should remove from the tree to make the trips impossible.&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the sample input we have a tree with <span class="mathjax-latex">\(4\)</span> edges <span class="mathjax-latex">\((1, 2)\)</span>, <span class="mathjax-latex">\((1, 3)\)</span>, <span class="mathjax-latex">\((1, 4)\)</span> and <span class="mathjax-latex">\((1, 5)\)</span>.</p>

<p>The tree looks like:&nbsp;</p>

<p><img alt="" height="300" src="https://he-s3.s3.amazonaws.com/media/uploads/1bff5952-4c0f-4a7b-a0c2-0aee81416da9.png" width="318"></p>

<p>Bob wants to make the following trips <strong>2 -&gt; 3&nbsp;</strong>and <strong>3 -&gt; 4</strong>.&nbsp;</p>

<p>It is easy to see that if we remove the edge <span class="mathjax-latex">\((1, 3)\)</span>, then he can't make any of those trips. The resulting graphs looks like:&nbsp;</p>

<p><img alt="" height="280" src="https://he-s3.s3.amazonaws.com/media/uploads/216160d7-496e-4da9-a8b5-558d32c189b1.png" width="325"></p>

<p>Hence, the answer for this input is <span class="mathjax-latex">\(1\)</span>.&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1" target="_blank" rel="noopener noreferrer">Undirected Graph Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">Given an <strong>undirected graph </strong>with <strong>V</strong> vertices and<strong> E </strong>edges, represented as a 2D vector <strong>edges[][]</strong>, where each entry <strong>edges[i] = [u, v]</strong> denotes an edge between vertices <strong>u</strong> and <strong>v</strong>, determine whether the graph contains a <strong>cycle </strong>or not. The graph can have multiple component.</span><span style="font-size: 18px;"><img style="font-size: 18px; font-weight: bold;" src="C:\Users\Mukul kumar\Desktop\GFG_PIC.JPG" alt="" /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 4, edges[][] = [[0, 1], [0, 2], [1, 2], [2, 3]]
<strong>Output: </strong>true
<strong>Explanation:</strong> 
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891735/Web/Other/blobid1_1743510240.jpg" width="176" height="158" /> <br /><span style="font-size: 18px;">1 -&gt; 2 -&gt; 0 -&gt; 1 is a cycle.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>V = 4, E = 3, edges[][] = [[0, 1], [1, 2], [2, 3]]</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">false</span><span style="font-size: 18px;">
<strong>Explanation: 
</strong></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/891735/Web/Other/blobid2_1743510254.jpg" width="169" height="153" /> <br /><span style="font-size: 18px;">No cycle in the graph.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1&nbsp;&le; V&nbsp;&le;&nbsp;10<sup>5</sup><br />1 &le; E = edges.size() &le; 10<sup>5</sup><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/union-find/1" target="_blank" rel="noopener noreferrer">Union-Find</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">This problem is to implement disjoint set union. There will be 2 incomplete functions namely union and find. You have to complete these functions.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Union:</strong> Join two subsets into a single set.<br /><strong>isConnected:</strong> Determine which subset a particular element is in. This can be used for determining if two elements are in same subset.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 5
q = 4
Queries = 
Union(1,3)
isConnected(1,2)
Union(1,5)
isConnected(3,5)
<strong>Output:
</strong>0
1<strong>
Explanation: </strong>Initially all nodes 1 2 3 4 5
are not connected.&nbsp;
After <strong>Union(1,3)</strong>, node 1 and 3 will be
connected.
When we do <strong>isConnected(</strong><strong>1,2)</strong>,&nbsp; as node 1
and 2&nbsp;are not connected it will return 0.
After <strong>Union(1,5)</strong>, node 1 and 5&nbsp;will be
connected.
When we do <strong>isConnected(3,5</strong><strong>)</strong>,&nbsp; as node
1 and 3&nbsp;are&nbsp;connected, and node 1 and 5
are connected, hence 3 and 5 are
connected.&nbsp;Thus it will return 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 5
q = 4
Queries = 
Union(1,4)
Union(1,5)
isConnected(2,3)
Union(3,4)
<strong>Output: </strong>0</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You have to complete the function <strong>union_() </strong>which merges the node1 and node2. You will also have to complete the function <strong>isConnected() </strong>which will return whether the two nodes are connected.</span></p>
<p><strong><span style="font-size: 18px;">Note:&nbsp;</span></strong><span style="font-size: 18px;">Both function will contain two arrays&nbsp;<strong>par[] and ranks1[]&nbsp;</strong>along with two nodes. Initially&nbsp;<strong>par[i] = i </strong>and <strong>rank1[i] = 1&nbsp;</strong></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N + Q).<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:&nbsp;</strong><br />1 &lt;= N &lt;= 10<sup>5</sup><br />1&lt;= Q &lt;= 10<sup>5</sup><br />1 &lt;= node1, node2 &lt;= N</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-tree-nodes/description" target="_blank" rel="noopener noreferrer">Validate Binary Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code> where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return <code>true</code> if and only if <strong>all</strong> the given nodes form <strong>exactly one</strong> valid binary tree.</p>

<p>If node <code>i</code> has no left child then <code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child.</p>

<p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png" style="width: 195px; height: 287px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png" style="width: 183px; height: 272px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png" style="width: 82px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 2, leftChild = [1,0], rightChild = [-1,-1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == leftChild.length == rightChild.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before we go into the approaches, let's first talk about what makes a binary tree valid.</p>
<blockquote>
<p>Note that while this is not a formal definition of a binary tree, these rules are sufficient for solving the problem.</p>
</blockquote>
<p><strong>A binary tree must have a root. This is a node with no incoming edges - that is, the root has no parent.</strong></p>
<p><img src="../Figures/1361/1.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p><img src="../Figures/1361/2.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>The tree must be connected - every node must be reachable from one node (the root).</strong></p>
<p><img src="../Figures/1361/3.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>There cannot be a cycle.</strong></p>
<p><img src="../Figures/1361/4.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p>To solve this problem, we can check the nodes given to us against these rules.</p>
<blockquote>
<p>You may notice that some of these rules imply each other. For example, if a binary tree had a root, it would have a cycle only if it was not connected, or there was a node with more than one parent.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
</blockquote>
<p>One way to solve this problem would be to perform a DFS on the tree and check that all the rules are followed. Before we can start a DFS, we need to locate the root. Let's define a function <code>findRoot</code> that helps us find the root.</p>
<p>As mentioned above, the root has no parent - this also means that the root is not the child of any nodes. The input arrays <code>leftChild</code> and <code>rightChild</code> describe all children, so the root would not appear in these arrays. We can simply use a for loop from <code>0</code> to <code>n - 1</code> and for each number, check if it is present in <code>leftChild</code> or <code>rightChild</code>. If it's not present in either, then we can return it as the root. If we don't find any root, we can return <code>-1</code>.</p>
<p>To improve efficiency, we will convert <code>leftChild</code> and <code>rightChild</code> to a set for <span class="math inline">\(O(1)\)</span> checks.</p>
<p><a href="https://leetcode.com/playground/iV5vT2dM/shared">code</a></p>
<p>We will start by obtaining <code>root = findRoot()</code>. If <code>root = -1</code>, there is no node without a parent, and we can immediately return false as the tree is invalid.</p>
<p>Once we have the root, we can start a DFS from it. We will implement the DFS iteratively with a stack. How can we validate the tree? First of all, if we see a node multiple times during the DFS, it means a node has multiple parents (and there could be a cycle). We will use a set <code>seen</code> that keeps track of all the nodes we have seen so far during the traversal. When we move to a <code>child</code>, if <code>child</code> is already in <code>seen</code>, we can immediately return false since we would be visiting <code>child</code> for the second time.</p>
<p>Once the DFS finishes, every node we visited will be in <code>seen</code>. If the tree is connected, then the length of <code>seen</code> will be equal to <code>n</code>. If <code>seen.length != n</code>, it means that some nodes were not visited, and thus the tree must be disconnected. Thus, we can return <code>seen.length == n</code> at the end of the algorithm.</p>
<p>This process is sufficient in validating a binary tree:</p>
<ol>
<li>If a binary tree does not have a root, then <code>findRoot</code> will return <code>-1</code>.</li>
<li>If there is a node with more than one parent, then we will detect it with <code>seen</code>.</li>
<li>If the tree is disconnected, then <code>seen</code> will hold less than <code>n</code> nodes at the end.</li>
<li>If there is a cycle, then we will detect it with <code>seen</code>.</li>
</ol>
<p>Any other scenario we don't explicitly check for will be caught by some other rule. For example, the second rule we stated was:</p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p>You may be thinking: we are explicitly checking the case when a node has multiple parents with <code>seen</code>, but what if there is a node with no parent other than the <code>root</code>? That is, what if there are multiple roots? In that scenario, <code>findRoot</code> would give us the root with the lowest value. We would perform a DFS from there, and never reach any of the other roots. Then at the end, <code>seen</code> would have less than <code>n</code> nodes.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>stack</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the top of the stack as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the stack and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the DFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/W65UxZEa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a DFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>stack</code> and <code>seen</code> during the DFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes an interviewer may ask you to implement both BFS and DFS. This approach is the same as the previous one, except we will use BFS to perform the traversal instead of DFS.</p>
<p>BFS uses a queue instead of a stack. If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>queue</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Pop the front of the queue as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the queue and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the BFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8LE3ZeZN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a BFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once. Note that an efficient queue implementation with <span class="math inline">\(O(1)\)</span> operations is required to achieve this complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code> during the BFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union Find</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a more advanced, but interesting way to approach this problem. We have included it for the sake of completeness. It is unlikely you will be expected to implement this approach in an interview if you have already used one of the previous approaches, so we will not delve into great detail in this approach.</p>
</blockquote>
<p>A disjoint-set data structure (also called a unionâ€“find), is a data structure that stores a collection of disjoint (non-overlapping) sets. Union-find provides us with the following methods:</p>
<ol>
<li><code>find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Leetcode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Initially, all nodes belong to their own subset. We will iterate over all <code>(parent, child)</code> pairs given in <code>leftChild</code> and <code>rightChild</code> and attempt a <code>union</code>. We want to assign the subset of <code>child</code> to the subset of <code>parent</code>. For each call to <code>union(parent, child)</code>, we can see if the tree is invalid with the following checks:</p>
<ol>
<li>If <code>find(child) != child</code>, then <code>child</code> must have been assigned a parent earlier, and thus <code>child</code> has multiple parents.</li>
<li>If <code>parent</code> and <code>child</code> already belong to the same subset, then there must be a directed path from <code>child</code> to <code>parent</code> as <code>parent</code> must have been assigned to the subset of <code>child</code> earlier, and thus there exists a cycle.</li>
</ol>
<p>After performing all <code>union</code> operations successfully between parents and their children, there should only be one component in the union-find data structure. We can track the number of components by subtracting one from the count on each successful <code>union</code> operation, and then check whether the final count of components is equal to 1.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a union-find data structure <code>uf</code> that implements <code>find(node)</code> and <code>union(parent, child)</code>. It should also track the number of <code>components</code>.
<ul>
<li>In <code>union</code>, we return a boolean indicating if the union was successful. A union is unsuccessful if the parent of <code>child</code> is not <code>child</code>, or the parent of <code>parent</code> is <code>child</code>.</li>
<li>If <code>union</code> is successful, we assign the subset of <code>child</code> to the subset of <code>parent</code> and decrement the number of <code>components</code>.</li>
</ul>
</li>
<li>Iterate <code>node</code> from <code>0</code> until <code>n</code>:
<ul>
<li>Iterate over the children of <code>node</code> as <code>child</code>:
<ul>
<li>If <code>child == - 1</code>, ignore it.</li>
<li>Otherwise, perform a <code>union(node, child)</code>. If it returns false, then <code>return false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>uf.components == 1</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: In C++, <code>union</code> is a reserved keyword and cannot be redefined. Therefore, we need to rename the <code>union</code> method, and we call it <code>join</code> here.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/c33bCEGR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm with path compression and union-by rank is <span class="math inline">\(O(\alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>. Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</p>
<p>You may have noticed that we didn't use union-by-rank optimization as in other DSU problems. The reason for this is that the structure of this problem is not like a regular graph. More specifically, if a pair of nodes <code>(parent, child)</code> is considered valid for union, only the eligible tree root node is considered as the new child, and it will always have a rank of 0. Therefore, during the union process, the rank of all nodes will not exceed 1. As for the possibility of nodes having a rank greater than 1, it would be filtered out as required by the problem statement and won't occur. Therefore, we don't need to use union-by-rank in this problem. We encourage readers to build test cases and try them out.</p>
<p>Initializing the <code>UnionFind</code> data structure costs <span class="math inline">\(O(n)\)</span>. Then, we simply iterate over each node once and perform some union-find operations at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>UnionFind</code> data structure keeps a <code>parents</code> array that takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>