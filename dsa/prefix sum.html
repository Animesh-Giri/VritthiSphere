<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>prefix sum - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>prefix sum</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">198</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Ant on the Boundary</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Apply Operations to Make All Array Elements Equal to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Apply Operations to Maximize Frequency Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Best Time to Buy and Sell Stock using Strategy</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Binary Subarrays With Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Build Array Where You Can Find The Maximum Exactly K Comparisons</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Can Make Palindrome from Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Can You Eat Your Favorite Candy on Your Favorite Day?</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Car Pooling</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Change Minimum Characters to Satisfy One of Three Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Check if All the Integers in a Range Are Covered</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Compute Before Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-12" class="toc-link">Construct Product Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Contiguous Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Continuous Subarray Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Corporate Flight Bookings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Count Beautiful Substrings I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Count Beautiful Substrings II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Count Increasing Quadruplets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Count Number of Nice Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Count of Interesting Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Count Partitions with Even Sum Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Count Partitions With Max-Min Difference at Most K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Count Subarrays With Median K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Count Subarrays With Score Less Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Count Submatrices With Equal Frequency of X and Y</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Count Submatrices with Top-Left Element and Sum Less Than k</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Count Substrings That Satisfy K-Constraint II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Count the Hidden Sequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Count the Number of Beautiful Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Count the Number of Houses at a Certain Distance I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Count the Number of Houses at a Certain Distance II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Count Triplets That Can Form Two Arrays of Equal XOR</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Count Vowel Strings in Ranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Delivering Boxes from Storage to Ports</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Describe the Painting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Divide Intervals Into Minimum Number of Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Equal Sum Grid Partition I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Equal Sum Grid Partition II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Find All Good Indices</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Find All Possible Stable Binary Arrays I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Find All Possible Stable Binary Arrays II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Find Good Days to Rob the Bank</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Find Kth Largest XOR Coordinate Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Find Pivot Index</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Find Polygon With the Largest Perimeter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Find the Count of Monotonic Pairs I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Find the Count of Monotonic Pairs II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Find the Highest Altitude</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Find the Longest Substring Containing Vowels in Even Counts</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Find the Middle Index in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Find the Minimum Amount of Time to Brew Potions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Find the N-th Value After K Seconds</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Find the Original Typed String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Find the Pivot Integer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Find the Score of All Prefixes of an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Find the Student that Will Replace the Chalk</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Frequency of the Most Frequent Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Get Biggest Three Rhombus Sums in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Get Equal Substrings Within Budget</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Grid Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Increment Submatrices by One</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Intervals Between Identical Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Jump Game VII</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Largest Magic Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Largest rectangular sub-matrix whose sum is 0</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-66" class="toc-link">Largest Square with Sum at Most K</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-67" class="toc-link">Largest Sum of Averages</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Left and Right Sum Differences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Longest Special Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Longest Special Path II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Longest Subsequence With Limited Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Longest Well-Performing Interval</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Make Array Elements Equal to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Make Sum Divisible by P</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Matrix Block Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Max Consecutive Ones III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Maximize Number of Subsequences in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Maximize Subarrays After Removing One Conflicting Pair</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Maximize the Confusion of an Exam</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Maximize the Minimum Powered City</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Maximum Coins From K Consecutive Bags</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Maximum Difference Between Even and Odd Frequency II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Maximum Frequency After Subarray Operation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Maximum Frequency of an Element After Performing Operations I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Maximum Frequency of an Element After Performing Operations II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Maximum Fruits Harvested After at Most K Steps</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Maximum Good Subarray Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Maximum number of overlapping Intervals</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-90" class="toc-link">Maximum Number of Robots Within Budget</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Maximum Number of Subsequences After One Inserting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Maximum Number of Ways to Partition an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Maximum OR</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Maximum Points You Can Obtain from Cards</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Maximum Population Year</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Maximum Score After Splitting a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Maximum Score From Grid Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Maximum Segment Sum After Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Maximum Strength of K Disjoint Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Maximum Subarray Min-Product</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Maximum subarray sum 2</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-103" class="toc-link">Maximum Subarray Sum With Length Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Maximum Sum Obtained of Any Permutation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Maximum Sum of 3 Non-Overlapping Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Maximum Sum of an Hourglass</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Maximum sum Rectangle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-108" class="toc-link">Maximum Total Beauty of the Gardens</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Maximum Trailing Zeros in a Cornered Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Maximum Value of K Coins From Piles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Maximum White Tiles Covered by a Carpet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Maximum XOR for Each Query</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Max Sum of Rectangle No Larger Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Merge Operations for Minimum Travel Time</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Minimize Maximum of Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Minimum Adjacent Swaps for K Consecutive Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Minimum Amount of Time to Collect Garbage</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Minimum Array Changes to Make Differences Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Minimum Average Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Minimum Cost to Divide Array Into Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Minimum Cost to Make Array Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Minimum Cost to Merge Stones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Minimum K Consecutive Bit Flips</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-124" class="toc-link">Minimum Levels to Gain More Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Minimum Moves to Make Array Complementary</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Minimum Moves to Pick K Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Minimum Number of K Consecutive Bit Flips</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Minimum Number of Operations to Move All Balls to Each Box</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Minimum Operations to Make All Array Elements Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Minimum Operations to Make Binary Array Elements Equal to One I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Minimum Operations to Reduce X to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Minimum Penalty for a Shop</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Minimum Positive Sum Subarray </a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Minimum Size Subarray in Infinite Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Minimum Size Subarray Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Minimum Space Wasted From Packaging</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Minimum Value to Get Positive Step by Step Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Minimum White Tiles After Covering With Carpets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Movement of Robots</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">My Calendar II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">My Calendar III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Number of Flowers in Full Bloom</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Number of Sub-arrays With Odd Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Number of Submatrices That Sum to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Number of submatrix have sum X</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-146" class="toc-link">Number of Ways of Cutting a Pizza</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Number of Ways to Select Buildings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Number of Ways to Split Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Number of Wonderful Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Palindrome Rearrangement Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-151" class="toc-link">Partition Array to Minimize XOR</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Plates Between Candles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Points That Intersect With Cars</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-154" class="toc-link">Power of Heroes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Product of Array Except Self</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">Product of the Last K Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Random Pick with Weight</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Random Point in Non-overlapping Rectangles</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Range Product Queries of Powers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-160" class="toc-link">Range Sum of Sorted Subarray Sums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-161" class="toc-link">Range Sum Query 2D - Immutable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-162" class="toc-link">Range Sum Query - Immutable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-163" class="toc-link">Rearrange Array to Maximize Prefix Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-164" class="toc-link">Removing Minimum Number of Magic Beans</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-165" class="toc-link">Running Sum of 1d Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-166" class="toc-link">Shift Distance Between Two Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-167" class="toc-link">Shifting Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Shifting Letters II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Shortest Subarray with Sum at Least K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Smallest Rotation with Highest Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Sorted GCD Pair Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Special Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-173" class="toc-link">Split Array Largest Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Stamping the Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-175" class="toc-link">Stone Game II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Stone Game VIII</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Subarray Product Less Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Subarray Sum Equals K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Subarray Sums Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-180" class="toc-link">Sum of Absolute Differences in a Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Sum of All Odd Length Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Sum of Distances</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-183" class="toc-link">Sum of Floored Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-184" class="toc-link">Sum of K Subarrays With Length at Least M</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Sum of Total Strength of Wizards</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Sum of Variable Length Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Taking Maximum Energy From the Mystic Dungeon</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Threshold Majority Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Unique Length-3 Palindromic Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-190" class="toc-link">Valid Permutations for DI Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Ways to Make a Fair Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-192" class="toc-link">Ways to Split Array Into Three Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-193" class="toc-link">XOR of numbers</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-194" class="toc-link">XOR Queries of a Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">Zero Array Transformation I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Zero Array Transformation II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-197" class="toc-link">Zero Array Transformation III</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ant-on-the-boundary/description" target="_blank" rel="noopener noreferrer">Ant on the Boundary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An ant is on a boundary. It sometimes goes <strong>left</strong> and sometimes <strong>right</strong>.</p>

<p>You are given an array of <strong>non-zero</strong> integers <code>nums</code>. The ant starts reading <code>nums</code> from the first element of it to its end. At each step, it moves according to the value of the current element:</p>

<ul>
	<li>If <code>nums[i] &lt; 0</code>, it moves <strong>left</strong> by<!-- notionvc: 55fee232-4fc9-445f-952a-f1b979415864 --> <code>-nums[i]</code> units.</li>
	<li>If <code>nums[i] &gt; 0</code>, it moves <strong>right</strong> by <code>nums[i]</code> units.</li>
</ul>

<p>Return <em>the number of times the ant <strong>returns</strong> to the boundary.</em></p>

<p><strong>Notes:</strong></p>

<ul>
	<li>There is an infinite space on both sides of the boundary.</li>
	<li>We check whether the ant is on the boundary only after it has moved <code>|nums[i]|</code> units. In other words, if the ant crosses the boundary during its movement, it does not count.<!-- notionvc: 5ff95338-8634-4d02-a085-1e83c0be6fcd --></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,-5]
<strong>Output:</strong> 1
<strong>Explanation:</strong> After the first step, the ant is 2 steps to the right of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
After the second step, the ant is 5 steps to the right of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
After the third step, the ant is on the boundary.
So the answer is 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,-3,-4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> After the first step, the ant is 3 steps to the right of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
After the second step, the ant is 5 steps to the right of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
After the third step, the ant is 2 steps to the right of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
After the fourth step, the ant is 2 steps to the left of the boundary<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->.
The ant never returned to the boundary, so the answer is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li><code>nums[i] != 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-make-all-array-elements-equal-to-zero/description" target="_blank" rel="noopener noreferrer">Apply Operations to Make All Array Elements Equal to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and a positive integer <code>k</code>.</p>

<p>You can apply the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li>Choose <strong>any</strong> subarray of size <code>k</code> from the array and <strong>decrease</strong> all its elements by <code>1</code>.</li>
</ul>

<p>Return <code>true</code><em> if you can make all the array elements equal to </em><code>0</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,3,1,1,0], k = 3
<strong>Output:</strong> true
<strong>Explanation:</strong> We can do the following operations:
- Choose the subarray [2,2,3]. The resulting array will be nums = [<strong><u>1</u></strong>,<strong><u>1</u></strong>,<strong><u>2</u></strong>,1,1,0].
- Choose the subarray [2,1,1]. The resulting array will be nums = [1,1,<strong><u>1</u></strong>,<strong><u>0</u></strong>,<strong><u>0</u></strong>,0].
- Choose the subarray [1,1,1]. The resulting array will be nums = [<u><strong>0</strong></u>,<u><strong>0</strong></u>,<u><strong>0</strong></u>,0,0,0].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,1], k = 2
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to make all the array elements equal to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-maximize-frequency-score/description" target="_blank" rel="noopener noreferrer">Apply Operations to Maximize Frequency Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>You can perform the following operation on the array <strong>at most</strong> <code>k</code> times:</p>

<ul>
	<li>Choose any index <code>i</code> from the array and <strong>increase</strong> or <strong>decrease</strong> <code>nums[i]</code> by <code>1</code>.</li>
</ul>

<p>The score of the final array is the <strong>frequency</strong> of the most frequent element in the array.</p>

<p>Return <em>the <strong>maximum</strong> score you can achieve</em>.</p>

<p>The frequency of an element is the number of occurences of that element in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,6,4], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations on the array:
- Choose i = 0, and increase the value of nums[0] by 1. The resulting array is [2,2,6,4].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,3].
- Choose i = 3, and decrease the value of nums[3] by 1. The resulting array is [2,2,6,2].
The element 2 is the most frequent in the final array so our score is 3.
It can be shown that we cannot achieve a better score.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,2,4], k = 0
<strong>Output:</strong> 3
<strong>Explanation:</strong> We cannot apply any operations so our score will be the frequency of the most frequent element in the original array, which is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>14</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/description" target="_blank" rel="noopener noreferrer">Best Time to Buy and Sell Stock using Strategy</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>prices</code> and <code>strategy</code>, where:</p>

<ul>
	<li><code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</li>
	<li><code>strategy[i]</code> represents a trading action on the <code>i<sup>th</sup></code> day, where:
	<ul>
		<li><code>-1</code> indicates buying one unit of the stock.</li>
		<li><code>0</code> indicates holding the stock.</li>
		<li><code>1</code> indicates selling one unit of the stock.</li>
	</ul>
	</li>
</ul>

<p>You are also given an <strong>even</strong> integer <code>k</code>, and may perform <strong>at most one</strong> modification to <code>strategy</code>. A modification consists of:</p>

<ul>
	<li>Selecting exactly <code>k</code> <strong>consecutive</strong> elements in <code>strategy</code>.</li>
	<li>Set the <strong>first</strong> <code>k / 2</code> elements to <code>0</code> (hold).</li>
	<li>Set the <strong>last</strong> <code>k / 2</code> elements to <code>1</code> (sell).</li>
</ul>

<p>The <strong>profit</strong> is defined as the <strong>sum</strong> of <code>strategy[i] * prices[i]</code> across all days.</p>

<p>Return the <strong>maximum</strong> possible profit you can achieve.</p>

<p><strong>Note:</strong> There are no constraints on budget or stock ownership, so all buy and sell operations are feasible regardless of past actions.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">prices = [4,2,8], strategy = [-1,0,1], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Modification</th>
			<th style="border: 1px solid black;">Strategy</th>
			<th style="border: 1px solid black;">Profit Calculation</th>
			<th style="border: 1px solid black;">Profit</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">Original</td>
			<td style="border: 1px solid black;">[-1, 0, 1]</td>
			<td style="border: 1px solid black;">(-1 &times; 4) + (0 &times; 2) + (1 &times; 8) = -4 + 0 + 8</td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Modify [0, 1]</td>
			<td style="border: 1px solid black;">[0, 1, 1]</td>
			<td style="border: 1px solid black;">(0 &times; 4) + (1 &times; 2) + (1 &times; 8) = 0 + 2 + 8</td>
			<td style="border: 1px solid black;">10</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Modify [1, 2]</td>
			<td style="border: 1px solid black;">[-1, 0, 1]</td>
			<td style="border: 1px solid black;">(-1 &times; 4) + (0 &times; 2) + (1 &times; 8) = -4 + 0 + 8</td>
			<td style="border: 1px solid black;">4</td>
		</tr>
	</tbody>
</table>

<p>Thus, the maximum possible profit is 10, which is achieved by modifying the subarray <code>[0, 1]</code>â€‹â€‹â€‹â€‹â€‹â€‹â€‹.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">prices = [5,4,3], strategy = [1,1,0], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<div class="example-block">
<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Modification</th>
			<th style="border: 1px solid black;">Strategy</th>
			<th style="border: 1px solid black;">Profit Calculation</th>
			<th style="border: 1px solid black;">Profit</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">Original</td>
			<td style="border: 1px solid black;">[1, 1, 0]</td>
			<td style="border: 1px solid black;">(1 &times; 5) + (1 &times; 4) + (0 &times; 3) = 5 + 4 + 0</td>
			<td style="border: 1px solid black;">9</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Modify [0, 1]</td>
			<td style="border: 1px solid black;">[0, 1, 0]</td>
			<td style="border: 1px solid black;">(0 &times; 5) + (1 &times; 4) + (0 &times; 3) = 0 + 4 + 0</td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">Modify [1, 2]</td>
			<td style="border: 1px solid black;">[1, 0, 1]</td>
			<td style="border: 1px solid black;">(1 &times; 5) + (0 &times; 4) + (1 &times; 3) = 5 + 0 + 3</td>
			<td style="border: 1px solid black;">8</td>
		</tr>
	</tbody>
</table>

<p>Thus, the maximum possible profit is 9, which is achieved without any modification.</p>
</div>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= prices.length == strategy.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>-1 &lt;= strategy[i] &lt;= 1</code></li>
	<li><code>2 &lt;= k &lt;= prices.length</code></li>
	<li><code>k</code> is even</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-subarrays-with-sum/description" target="_blank" rel="noopener noreferrer">Binary Subarrays With Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary array <code>nums</code> and an integer <code>goal</code>, return <em>the number of non-empty <strong>subarrays</strong> with a sum</em> <code>goal</code>.</p>

<p>A <strong>subarray</strong> is a contiguous part of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,1,0,1], goal = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 4 subarrays are bolded and underlined below:
[<u><strong>1,0,1</strong></u>,0,1]
[<u><strong>1,0,1,0</strong></u>,1]
[1,<u><strong>0,1,0,1</strong></u>]
[1,0,<u><strong>1,0,1</strong></u>]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0,0,0], goal = 0
<strong>Output:</strong> 15
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= goal &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary array <code>nums</code> and an integer <code>goal</code>. The task is to find the number of non-empty subarrays in the given binary array where the sum of elements in the subarray equals the specified <code>goal</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The array contains only binary values (0 or 1).</li>
<li>The goal is to find subarrays with a specific sum.</li>
<li>The subarrays should be non-empty and contiguous.</li>
</ol>
<p>Consider the given example with <code>nums = [1,0,1,0,1]</code> and <code>goal = 2</code>:</p>
<p>Output: 4</p>
<p>Explanation: The 4 subarrays are bolded and underlined below:<br />
[<strong>1,0,1</strong>,0,1]<br />
[<strong>1,0,1,0</strong>,1]<br />
[1,<strong>0,1,0,1</strong>]<br />
[1,0,<strong>1,0,1</strong>]</p>
<p>Note that all these subarrays are contiguous parts of the given array, and the count of such subarrays is the output.</p>
<hr />
<h3 id="approach-1-prefix-sum">Approach 1: Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>The task involves identifying contiguous sequences of elements within an array whose sum equals a specific target value. Problems that require sequences of elements to meet criteria often utilize <a href="https://en.wikipedia.org/wiki/Prefix_sum">prefix sums</a>.</p>
<p>We begin by iterating through the array. As we encounter each element, we maintain a running total (current sum). This current sum represents the cumulative addition of all elements encountered so far in the array.</p>
<p>Next, we check if the current sum precisely matches the target value. If it does, we have found a subarray whose elements add up to the goal.</p>
<p>Now consider a scenario where the current sum exceeds the target value. This doesn't necessarily eliminate the possibility of finding a subarray that meets the criteria. We need a method to determine the sum of subarrays that begin after the first index of the original array.</p>
<p>A prefix sum represents the cumulative sum of elements up to a specific point in the array. By subtracting the target value from the current sum, we obtain a new value, called as &quot;prefix sum.&quot; If this value appears earlier in the array, it means a subarray starting later adds up to the target. In simpler terms, a subsequence of these elements adds up to the target sum value.</p>
<p>We can use a map to track the occurrences of prefix sums. If a prefix sum exists in the map, it indicates multiple groups that sum to the target. We update the map by adding the current sum. This ensures we can find any corresponding subarrays that leads to goal.</p>
<p>Refer to the visual slideshow demonstrating the algorithm with the example input [1, 0, 1, 0, 1] and goal = 2.</p>
<p>!?!../Documents/930_fix/prefix_sum_fix.json:1010,510!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize the <code>totalCount</code> variable to keep track of the number of subarrays with the desired sum and the <code>currentSum</code> variable to keep track of the cumulative sum of elements encountered so far.</li>
<li>Initialize a hash table, <code>freq</code>, to store the frequency of encountered prefix sums.</li>
<li>Iterate through the array <code>nums</code>.
<ul>
<li>Add the current element to the <code>currentSum</code> to get the updated running total. If the updated <code>currentSum</code> is equal to the <code>goal</code>, it means a subarray with a sum equal to the goal has been found. Increment <code>totalCount</code> by 1.</li>
<li>Check if the <code>freq</code> map contains a prefix sum <code>currentSum - goal</code>. This <code>currentSum - goal</code> represents the prefix sum of a subarray that, when added to the current element <code>num</code>, could potentially form a subarray with a sum equal to <code>goal</code>.</li>
<li>If <code>freq[currentSum - goal] </code> is in the hash table, it means there exists a subarray with a prefix sum equal to <code>currentSum - goal</code>. In this case:
<ul>
<li>Add the frequency of <code>currentSum - goal</code> (the number of subarrays with that prefix sum) to <code>totalCount</code>. These subarrays, when combined with <code>num</code>, would also result in a subarray with a sum equal to <code>goal</code>.</li>
</ul>
</li>
<li>Update the frequency map by incrementing the frequency count for the current sum.</li>
</ul>
</li>
<li>Return the <code>totalCount</code> variable.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/c6oShGh5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the array once to calculate the prefix sums and update the frequency map.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use an unordered map (<code>freq</code>) to store the frequency of prefix sums. In the worst case, all prefix sums can be distinct, resulting in <span class="math inline">\(n\)</span> unique entries in the map. Therefore, the space required is proportional to the size of the input array.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<h4 id="intuition-1">Intuition</h4>
<p>For a more efficient approach, let's consider aspects of the problem: We must achieve a <code>goal</code> using subarrays. We can't pick elements individually. Problems with these qualities are often solved using the sliding window pattern.</p>
<p>In a standard sliding window approach, once the <code>currentSum</code> reaches the target <code>goal</code>, the typical strategy involves simply moving the left pointer of the window forward to potentially find more subarrays. However, this approach has a critical limitation when applied to binary arrays.</p>
<p>Including a zero element in the subarray won't change the sum. As a result, even if the <code>currentSum</code> reaches the <code>goal</code> initially, we might miss further subarrays that also meet the <code>goal</code> by simply shrinking the window as long as the sum remains equal to the <code>goal</code>. This is because the presence of zeros creates the possibility of combining them with elements encountered later to reach the target sum.</p>
<p>Thus subarrays exceeding the target sum are irrelevant to our objective. We only care about subarrays whose sum is either equal to the <code>goal</code> or less than the <code>goal</code>.</p>
<p>Leveraging this insight, we can directly track the number of subarrays with a sum at most equal to the <code>goal</code>.</p>
<p>After calculating the total count of subarrays with sums less than or equal to the <code>goal</code> using the function<code>slidingWindowAtMost(nums, goal)</code>, we need to isolate the subarrays that strictly meet the target <code>goal</code>.</p>
<p>This can be achieved by subtracting the total count of subarrays with sums less than the <code>goal</code> (<code>slidingWindowAtMost(nums, goal - 1)</code>) from the total count obtained earlier. By subtracting the latter from the former, we remove the subarrays that don't reach the <code>goal</code> and are left with only the subarrays that have a sum exactly equal to the <code>goal</code>.</p>
<p>Refer to the visual slideshow demonstrating the sliding window on <code>slidingWindowAtMost(nums, goal)</code>.</p>
<p>!?!../Documents/930_fix/sliding_window1_fix.json:1010,385!?!</p>
<p>Now, refer to the visual slideshow demonstrating the sliding window on <code>slidingWindowAtMost(nums, goal - 1)</code>.</p>
<p>!?!../Documents/930_fix/sliding_window2_fix.json:1010,380!?!</p>
<p>Now, if we subtract the count from the second slideshow (<code>slidingWindowAtMost(nums, goal - 1)</code>) from the count in the first slideshow (<code>slidingWindowAtMost(nums, goal)</code>), which is 14 - 10, we get 4. Here, 4 represents the number of subarrays with a sum equal to the <code>goal</code>.</p>
<p>The reason for this is that <code>atMost(2)</code> includes all sets of windows whose total sum is equal to 0, 1, and 2, while <code>atMost(1)</code> comprises sets with sums of 0 and 1.</p>
<p>Now, see that the set <code>atMost(2)</code> contains the whole set of <code>atMost(1)</code>. So, when we subtract them, we get the remainderâ€”subarrays that have a sum exactly equal to 2.</p>
<p>Refer to the below Venn diagram for a better understanding.</p>
<p><img src="../Figures/930_fix/BinarySubarraySum-atMostConcept.png" alt="img" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Define the helper function: <code>slidingWindowAtMost(nums, goal)</code>:</strong></p>
<ul>
<li>Initializes variables <code>start</code> (representing the start index of the window), <code>currentSum</code> (representing the sum of elements in the current window), and <code>totalCount</code> (representing the total count of subarrays with a sum less than or equal to the goal) to 0.</li>
<li>Iterate through the array using a sliding window where the <code>end</code> pointer iterates from 0 to the end of the <code>nums</code> array.
<ul>
<li>Within each iteration, add the current element (<code>nums[end]</code>) to <code>currentSum</code>.</li>
<li>Use a <code>while</code> loop to adjust the window from the left side (using the <code>start</code> pointer) as long as <code>currentSum</code> is greater than <code>goal</code>.
<ul>
<li>Subtract the element at the <code>start</code> index from <code>currentSum</code>.</li>
<li>Increment the <code>start</code> pointer to move the window one position to the right.</li>
</ul>
</li>
<li>After adjusting the window, the subarray from <code>start</code> to <code>end</code> has a sum less than or equal to <code>goal</code>, so increment <code>totalCount</code> by the length of the current subarray (<code>end - start + 1</code>).</li>
</ul>
</li>
<li>After iterating through the entire <code>nums</code> array, return <code>totalCount</code>, which holds the total number of subarrays with a sum at most <code>goal.</code></li>
</ul>
<p><strong>In the main function <code>numSubarraysWithSum(nums, goal)</code>:</strong></p>
<ul>
<li>Find the difference by calling <code>slidingWindowAtMost</code> twice, once with the original <code>goal</code> and another time with <code>goal - 1</code>.</li>
<li>Return the difference between these two counts, the exact number of subarrays with a sum equal to <code>goal</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/BC3FyXRm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The function <code>slidingWindowAtMost</code> uses two pointers, <code>start</code> and <code>end</code> to process the elements in the array. Although there is a nested loop, each pointer starts at <span class="math inline">\(0\)</span> and gets incremented at most <span class="math inline">\(n\)</span> times, so each pointer makes just <span class="math inline">\(1\)</span> pass through the array. This means the time complexity of the function <code>slidingWindowAtMost</code> is <span class="math inline">\(O(n)\)</span>.  We call <code>slidingWindowAtMost</code> twice,  resulting in an overall time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> because the algorithm uses a constant amount of space for variables such as <code>start</code>, <code>currentSum</code>, and <code>totalCount</code>. The space required does not depend on the size of the input array.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sliding-window-in-one-pass">Approach 3: Sliding Window in One Pass</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we were finding the answer by calling the sliding window two times. However, we can optimize it to a single pass.</p>
<p>To do this, we track the number of zeros at the <code>start</code> of the current window. Each contiguous sequence of zeros at the <code>start</code> of the window can be considered separately when determining the total number of subarrays that sum up to the <code>goal</code>. That is, we need to increment the <code>totalCount</code> by <code>1 + prefix zeros</code>. This is crucial because each subarray within the window, along with each combination of prefix zeros, contributes to the total count of subarrays that sum up to the <code>goal</code>.</p>
<p>Leading zeros in a window don't affect the sum, but they create opportunities for more subarrays to reach the target <code>goal</code>.</p>
<p>The remaining logic is the same as the previous sliding window approach. We iterate through the array nums using two pointers: <code>start</code> and <code>end</code>, representing the start and end indices of the current window.</p>
<p>If the sum of the current window exceeds the <code>goal</code>, we adjust the window by moving the <code>start</code> pointer forward until the sum is less than or equal to the <code>goal</code>. Along with adjusting the <code>start</code> pointer, we also need to update the prefix zeros count accordingly with the current window. If the <code>start</code> pointer is pointing to 0, we increment the prefix zero count; otherwise, if it's pointing to 1, we reset the prefix zero count to 0.</p>
<p>For example, consider a window represented by the array [0, 0, 1, 1]. In this window, there are 2 leading zeros. This means that the window can sum up to 2 in 2 + 1 = 3 ways.</p>
<p>Refer to the visual slideshow demonstrating the sliding window in one pass:</p>
<p>!?!../Documents/930_fix/sliding_onepass_fix.json:1010,420!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize variables <code>start</code>, <code>prefixZeros</code>, <code>currentSum</code>, and <code>totalCount</code> to 0.</li>
<li>Iterate through the array using the <code>end</code> variable as the end index of the sliding window.
<ul>
<li>Add the current element to the <code>currentSum</code>.</li>
<li>Enter a while loop to shrink the window from the left side if the sum exceeds the <code>goal</code> or if the element at the start of the window is 0.
<ul>
<li>Inside the while loop, check if the element at the start of the window is 1. If it is, reset the <code>prefixZeros</code> count to 0. Otherwise, increment the <code>prefixZeros</code> count.</li>
<li>Then subtract the element at the start of the window from the <code>currentSum</code> and increment the <code>start</code> pointer to move the window.</li>
</ul>
</li>
<li>If the <code>currentSum</code> is equal to the <code>goal</code>, increment the <code>totalCount</code> by 1 plus the <code>prefixZeros</code> count.</li>
</ul>
</li>
<li>Finally, return the <code>totalCount</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/SsiueCRb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The function iterates through the nums array once using a single for loop (<code>end</code> loop).</p>
<p>Inside the loop, the while loop might contract the window, but the total number of iterations within this loop is still bounded by the number of elements in the array (<code>n</code>).</p>
<p>Therefore, the overall time complexity is dominated by the single iteration through the array, resulting in <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> because the algorithm uses a constant amount of space for variables such as <code>start</code>, <code>currentSum</code>, and <code>totalCount</code>. The space required does not depend on the size of the input array.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/description" target="_blank" rel="noopener noreferrer">Build Array Where You Can Find The Maximum Exactly K Comparisons</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three integers <code>n</code>, <code>m</code> and <code>k</code>. Consider the following algorithm to find the maximum element of an array of positive integers:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/04/02/e.png" style="width: 424px; height: 372px;" />
<p>You should build the array arr which has the following properties:</p>

<ul>
	<li><code>arr</code> has exactly <code>n</code> integers.</li>
	<li><code>1 &lt;= arr[i] &lt;= m</code> where <code>(0 &lt;= i &lt; n)</code>.</li>
	<li>After applying the mentioned algorithm to <code>arr</code>, the value <code>search_cost</code> is equal to <code>k</code>.</li>
</ul>

<p>Return <em>the number of ways</em> to build the array <code>arr</code> under the mentioned conditions. As the answer may grow large, the answer <strong>must be</strong> computed modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2, m = 3, k = 1
<strong>Output:</strong> 6
<strong>Explanation:</strong> The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, m = 2, k = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no possible arrays that satisfy the mentioned conditions.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 9, m = 1, k = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>1 &lt;= m &lt;= 100</code></li>
	<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/can-make-palindrome-from-substring/description" target="_blank" rel="noopener noreferrer">Can Make Palindrome from Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and array <code>queries</code> where <code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>, k<sub>i</sub>]</code>. We may rearrange the substring <code>s[left<sub>i</sub>...right<sub>i</sub>]</code> for each query and then choose up to <code>k<sub>i</sub></code> of them to replace with any lowercase English letter.</p>

<p>If the substring is possible to be a palindrome string after the operations above, the result of the query is <code>true</code>. Otherwise, the result is <code>false</code>.</p>

<p>Return a boolean array <code>answer</code> where <code>answer[i]</code> is the result of the <code>i<sup>th</sup></code> query <code>queries[i]</code>.</p>

<p>Note that each letter is counted individually for replacement, so if, for example <code>s[left<sub>i</sub>...right<sub>i</sub>] = &quot;aaa&quot;</code>, and <code>k<sub>i</sub> = 2</code>, we can only replace two of the letters. Also, note that no query modifies the initial string <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example :</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
<strong>Output:</strong> [true,false,false,true,true]
<strong>Explanation:</strong>
queries[0]: substring = &quot;d&quot;, is palidrome.
queries[1]: substring = &quot;bc&quot;, is not palidrome.
queries[2]: substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character.
queries[3]: substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.
queries[4]: substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;lyb&quot;, queries = [[0,1,0],[2,2,1]]
<strong>Output:</strong> [false,true]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>
	<li><code>0 &lt;= k<sub>i</sub> &lt;= s.length</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/description" target="_blank" rel="noopener noreferrer">Can You Eat Your Favorite Candy on Your Favorite Day?</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>(0-indexed)</strong> array of positive integers <code>candiesCount</code> where <code>candiesCount[i]</code> represents the number of candies of the&nbsp;<code>i<sup>th</sup></code>&nbsp;type you have. You are also given a 2D array <code>queries</code> where <code>queries[i] = [favoriteType<sub>i</sub>, favoriteDay<sub>i</sub>, dailyCap<sub>i</sub>]</code>.</p>

<p>You play a game with the following rules:</p>

<ul>
	<li>You start eating candies on day <code><strong>0</strong></code>.</li>
	<li>You <b>cannot</b> eat <strong>any</strong> candy of type <code>i</code> unless you have eaten <strong>all</strong> candies of type <code>i - 1</code>.</li>
	<li>You must eat <strong>at least</strong> <strong>one</strong> candy per day until you have eaten all the candies.</li>
</ul>

<p>Construct a boolean array <code>answer</code> such that <code>answer.length == queries.length</code> and <code>answer[i]</code> is <code>true</code> if you can eat a candy of type <code>favoriteType<sub>i</sub></code> on day <code>favoriteDay<sub>i</sub></code> without eating <strong>more than</strong> <code>dailyCap<sub>i</sub></code> candies on <strong>any</strong> day, and <code>false</code> otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.</p>

<p>Return <em>the constructed array </em><code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]
<strong>Output:</strong> [true,false,true]
<strong>Explanation:</strong>
1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.
2- You can eat at most 4 candies each day.
   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.
   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.
3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]
<strong>Output:</strong> [false,true,true,false,false]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= candiesCount.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= candiesCount[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 3</code></li>
	<li><code>0 &lt;= favoriteType<sub>i</sub> &lt; candiesCount.length</code></li>
	<li><code>0 &lt;= favoriteDay<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= dailyCap<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/car-pooling/description" target="_blank" rel="noopener noreferrer">Car Pooling</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a car with <code>capacity</code> empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).</p>

<p>You are given the integer <code>capacity</code> and an array <code>trips</code> where <code>trips[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> trip has <code>numPassengers<sub>i</sub></code> passengers and the locations to pick them up and drop them off are <code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> respectively. The locations are given as the number of kilometers due east from the car&#39;s initial location.</p>

<p>Return <code>true</code><em> if it is possible to pick up and drop off all passengers for all the given trips, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> trips = [[2,1,5],[3,3,7]], capacity = 4
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> trips = [[2,1,5],[3,3,7]], capacity = 5
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= trips.length &lt;= 1000</code></li>
	<li><code>trips[i].length == 3</code></li>
	<li><code>1 &lt;= numPassengers<sub>i</sub> &lt;= 100</code></li>
	<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt;= 1000</code></li>
	<li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/description" target="_blank" rel="noopener noreferrer">Change Minimum Characters to Satisfy One of Three Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>a</code> and <code>b</code> that consist of lowercase letters. In one operation, you can change any character in <code>a</code> or <code>b</code> to <strong>any lowercase letter</strong>.</p>

<p>Your goal is to satisfy <strong>one</strong> of the following three conditions:</p>

<ul>
	<li><strong>Every</strong> letter in <code>a</code> is <strong>strictly less</strong> than <strong>every</strong> letter in <code>b</code> in the alphabet.</li>
	<li><strong>Every</strong> letter in <code>b</code> is <strong>strictly less</strong> than <strong>every</strong> letter in <code>a</code> in the alphabet.</li>
	<li><strong>Both</strong> <code>a</code> and <code>b</code> consist of <strong>only one</strong> distinct letter.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations needed to achieve your goal.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;aba&quot;, b = &quot;caa&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> Consider the best way to make each condition true:
1) Change b to &quot;ccc&quot; in 2 operations, then every letter in a is less than every letter in b.
2) Change a to &quot;bbb&quot; and b to &quot;aaa&quot; in 3 operations, then every letter in b is less than every letter in a.
3) Change a to &quot;aaa&quot; and b to &quot;aaa&quot; in 2 operations, then a and b consist of one distinct letter.
The best way was done in 2 operations (either condition 1 or condition 3).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;dabadd&quot;, b = &quot;cda&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The best way is to make condition 1 true by changing b to &quot;eee&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
	<li><code>a</code> and <code>b</code> consist only of lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/description" target="_blank" rel="noopener noreferrer">Check if All the Integers in a Range Are Covered</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>ranges</code> and two integers <code>left</code> and <code>right</code>. Each <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represents an <strong>inclusive</strong> interval between <code>start<sub>i</sub></code> and <code>end<sub>i</sub></code>.</p>

<p>Return <code>true</code> <em>if each integer in the inclusive range</em> <code>[left, right]</code> <em>is covered by <strong>at least one</strong> interval in</em> <code>ranges</code>. Return <code>false</code> <em>otherwise</em>.</p>

<p>An integer <code>x</code> is covered by an interval <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> if <code>start<sub>i</sub> &lt;= x &lt;= end<sub>i</sub></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> Every integer between 2 and 5 is covered:
- 2 is covered by the first range.
- 3 and 4 are covered by the second range.
- 5 is covered by the third range.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ranges = [[1,10],[10,20]], left = 21, right = 21
<strong>Output:</strong> false
<strong>Explanation:</strong> 21 is not covered by any range.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= ranges.length &lt;= 50</code></li>
	<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 50</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/compute-before-matrix--170637/1" target="_blank" rel="noopener noreferrer">Compute Before Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">For a given 2D Matrix&nbsp;<strong>before,</strong>&nbsp;the corresponding cell (x, y) of the <strong>after</strong> matrix is calculated as follows:&nbsp;</span></p>

<div style="background:#eee;border:1px solid #ccc;padding:5px 10px;">
<pre>
<span style="font-size:18px">res = 0;
for(i = 0; i &lt;= x; i++){
    for( j = 0; j &lt;= y; j++){              
&nbsp;       res += before(i,j);
    }
}
after(x,y) = res;
</span></pre>
</div>

<p>&nbsp;</p>

<p><span style="font-size:18px">Given an&nbsp;<strong>N*M&nbsp;</strong>2D-Matrix&nbsp;<strong>after,</strong>&nbsp;your task is to find the corresponding&nbsp;<strong>before&nbsp;</strong>matrix for the given matrix.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 2, M = 3
after[][] = {{1, 3, 6},
&nbsp;           {3, 7, 11}}
<strong>Output:</strong>
1 2 3
2 2 1
<strong>Explanation:</strong>
The before matrix for the given after matrix
matrix is {{1, 2, 3}, {2, 2, 1}}.
Reason:
According to the code given in problem,
</span><span style="font-size:18px">after(0,0) = before(0,0) = 1
after(0,1) = before(0,0) + before(0,1)
= 1 + 2 = 3.
after(0, 2) = before(0,0) + before(0, 1)
+ before(0, 2) = 1 + 2 + 3 = 6.
Similarly we can calculate values for every
cell of the after matrix.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>
N = 1, M = 3
after[][] = {{1, 3, 5}}
<strong>Output:</strong>
1 2 2
<strong>Explanation: </strong>
The before matrix for the given after matrix
is {{1, 2, 2}}.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Complete the function <strong>c</strong><strong>omputeBeforeMatrix() </strong>which takes the integers <strong>N</strong>, <strong>M,&nbsp;</strong>and the 2D Matrix&nbsp;<strong>after</strong>&nbsp;as the input parameters, and returns the before matrix of the given after matrix.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N, M, after[i][j]&nbsp; &le;&nbsp; 10<sup>9</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-product-matrix/description" target="_blank" rel="noopener noreferrer">Construct Product Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> 2D integer matrix <code><font face="monospace">grid</font></code><font face="monospace"> </font>of size <code>n * m</code>, we define a <strong>0-indexed</strong> 2D matrix <code>p</code> of size <code>n * m</code> as the <strong>product</strong> matrix of <code>grid</code> if the following condition is met:</p>

<ul>
	<li>Each element <code>p[i][j]</code> is calculated as the product of all elements in <code>grid</code> except for the element <code>grid[i][j]</code>. This product is then taken modulo <code><font face="monospace">12345</font></code>.</li>
</ul>

<p>Return <em>the product matrix of</em> <code><font face="monospace">grid</font></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,2],[3,4]]
<strong>Output:</strong> [[24,12],[8,6]]
<strong>Explanation:</strong> p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24
p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12
p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8
p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6
So the answer is [[24,12],[8,6]].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[12345],[2],[1]]
<strong>Output:</strong> [[2],[0],[0]]
<strong>Explanation:</strong> p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.
p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.
p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.
So the answer is [[2],[0],[0]].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == grid.length&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m == grid[i].length&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= n * m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/contiguous-array/description" target="_blank" rel="noopener noreferrer">Contiguous Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary array <code>nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of </em><code>0</code><em> and </em><code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,1,1,1,1,0,0,0]
<strong>Output:</strong> 6
<strong>Explanation:</strong> [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h3>
<h4 id="algorithm">Algorithm</h4>
<p>The brute force approach is really simple. We consider every possible subarray within the given array and count the number of zeros and ones in each subarray. Then, we find out the maximum size subarray with equal no. of zeros and ones out of them.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/sPZqbexo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. We consider every possible subarray by traversing over the complete array for every start point possible.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Only two variables <span class="math inline">\(zeroes\)</span> and <span class="math inline">\(ones\)</span> are required.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-hash-map-accepted">Approach #2 Using Hash Map [Accepted]</h3>
<h4 id="algorithm-1">Algorithm</h4>
<p>Imagine a <code>count</code> variable, which is used to store the relative number of ones and zeros encountered so far while traversing the array. The <code>count</code> variable is incremented by one for every <span class="math inline">\(\text{1}\)</span> encountered and the same is decremented by one for every <span class="math inline">\(\text{0}\)</span> encountered.</p>
<p>We start traversing the array from the beginning. If at any moment, the <span class="math inline">\(count\)</span> becomes zero, it implies that we've encountered an equal number of zeros and ones from the beginning till the current index of the array(<span class="math inline">\(i\)</span>). Not only this, another point to be noted is that if we encounter the same <span class="math inline">\(count\)</span> twice (for any value, not just 0) while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal <span class="math inline">\(count\)</span> values. The following figure illustrates the observation for the sequence <code>[0 0 1 0 0 0 1 1]</code>:</p>
<p><img src="../Figures/535_Contiguous_Array.PNG" alt="Contiguous_Array" /></p>
<p>In the above figure, the subarrays between (A,B), (B,C), and (A,C) (lying between indices corresponding to <span class="math inline">\(count = -2\)</span>) have an equal number of zeros and ones.</p>
<p>Another point to be noted is that the largest subarray is the one between the points (A, C). Thus, if we keep a track of the indices corresponding to the same <span class="math inline">\(count\)</span> values that lie farthest apart, we can determine the size of the largest subarray with equal no. of zeros and ones easily.</p>
<p>We can use a hash map that maps values of <code>count</code> to the first index where that <code>count</code> was seen. We maintain the value of <code>count</code> and at each index, if we have seen the same value of <code>count</code> before, it means the subarray starting from where we saw that value of <code>count</code> and ending at the current index has an equal number of 0s and 1s. Otherwise, we put <code>count</code> in the map for future iterations.</p>
<p>The following animation depicts the process:</p>
<!--![Contiguous_Array](../Figures/525_Contiguous_Array.gif)-->
<p>!?!../Documents/525_Contiguous_Array.json:1000,563!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DUzWHXUN/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. The entire array is traversed only once.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. Maximum size of the HashMap <span class="math inline">\(map\)</span> will be <span class="math inline">\(\text{n}\)</span>, if all the elements are either 1 or 0.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/continuous-subarray-sum/description" target="_blank" rel="noopener noreferrer">Continuous Subarray Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array nums and an integer k, return <code>true</code> <em>if </em><code>nums</code><em> has a <strong>good subarray</strong> or </em><code>false</code><em> otherwise</em>.</p>

<p>A <strong>good subarray</strong> is a subarray where:</p>

<ul>
	<li>its length is <strong>at least two</strong>, and</li>
	<li>the sum of the elements of the subarray is a multiple of <code>k</code>.</li>
</ul>

<p><strong>Note</strong> that:</p>

<ul>
	<li>A <strong>subarray</strong> is a contiguous part of the array.</li>
	<li>An integer <code>x</code> is a multiple of <code>k</code> if there exists an integer <code>n</code> such that <code>x = n * k</code>. <code>0</code> is <strong>always</strong> a multiple of <code>k</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [23,<u>2,4</u>,6,7], k = 6
<strong>Output:</strong> true
<strong>Explanation:</strong> [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [<u>23,2,6,4,7</u>], k = 6
<strong>Output:</strong> true
<strong>Explanation:</strong> [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [23,2,6,4,7], k = 13
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= sum(nums[i]) &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>1 &lt;= k &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem asks us to determine if there exists a subarray in the given integer array <code>nums</code> where the sum of its elements is divisible by an integer <code>k</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The length of the subarray should be at least two.</li>
<li>The constraints indicate that the problem must be solved in linear or log-linear time complexity, in terms of the size of the given array.</li>
</ol>
<hr />
<h3 id="approach-1-prefix-sum-and-hashing">Approach 1: Prefix Sum and Hashing</h3>
<h4 id="intuition">Intuition</h4>
<p>One brute force approach for this problem can be to find out the sum of all subarrays of the array and check if there exists a subarray with a sum divisible by <code>k</code>. Since the number of subarrays in an array of size <code>n</code> is <code>n * (n - 1) / 2</code>, the time complexity to calculate all possible subarrays is <span class="math inline">\(O(n^2)\)</span>, and calculating the sum for each subarray takes <span class="math inline">\(O(n)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n^3)\)</span>, which will give a Time Limit Exceeded judgment.</p>
<p>Recall that prefix sums are particularly useful to calculate the sum of subarrays. The sum of the subarray starting at the index <code>i + 1</code> and ending at <code>j</code> (inclusive) is computed by <span class="math inline">\(prefix_j - prefix_i\)</span> where <span class="math inline">\(prefix_i\)</span> denotes the prefix sum up to index <code>i</code>. We can find out if there exists a subarray with a sum divisible by <code>k</code>, as shown below:</p>
<p><img src="../Figures/523/Slide1.png" alt="prefix sum formula" /></p>
<p>Since we are only concerned with the modulo of the prefix sum, we start with an integer <code>prefixMod</code> to store the remainder of the <code>prefixSum</code> with <code>k</code> progressively.Â We can find the longest subarray that satisfies the above conditions by calculating the difference between the current index and the first index with the value <code>prefixMod</code>. This is explained with an example shown below:</p>
<p><img src="../Figures/523/Slide2.png" alt="prefix sum formula2" /></p>
<p>A hashmap provides constant lookup and insertion time for the values in the list. Therefore, we initialize a hashmap <code>modSeen</code> with <code>prefixMod</code> as the key and the first index of each value of <code>prefixMod</code> as the value.</p>
<p>We iterate over all the elements from the beginning of <code>nums</code>. We set <code>prefixMod = (prefixMod + nums[i]) % k</code> for each element to find the remainder of the prefix sum when divided by <code>k</code>.</p>
<p>If the key <code>prefixMod</code> exists in the hashmap and the size of the subarray is at least 1, then we can return <code>true</code> as the output. If the key does not exist, we can store the current index in the hashmap with <code>prefixMod</code> as the key.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer <code>prefixMod = 0</code> and a hashmap <code>modSeen</code>. Initialize <code>modSeen[0]</code> with -1 to account for the initial value of prefixMod.</li>
<li>Iterate over all the elements of <code>nums</code>:
<ul>
<li>Compute the <code>prefixMod</code> as <code>prefixMod = (prefixMod + nums[i]) % k</code>.</li>
<li>If <code>prefixMod</code> exists in the hashmap:
<ul>
<li>If the size of the longest subarray with modulo <code>k</code> is at least 2.
<ul>
<li>Return <code>true</code>. Â </li>
</ul>
</li>
</ul>
</li>
<li>If <code>prefixMod</code> doesn't exist in the hashmap:
<ul>
<li>Set <code>modSeen[prefixMod] = i</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>false</code>.</li>
</ol>
<p>!?!../Documents/523/slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8p3J3RiG/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in <code>nums</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>We iterate through the array exactly once. In each iteration, we perform a search operation in the hashmap that takes <span class="math inline">\(O(1)\)</span> time. Therefore, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>In each iteration, we insert a key-value pair in the hashmap. The space complexity is <span class="math inline">\(O(n)\)</span> because the size of the hashmap is proportional to the size of the list after <span class="math inline">\(n\)</span> iterations.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/corporate-flight-bookings/description" target="_blank" rel="noopener noreferrer">Corporate Flight Bookings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> flights that are labeled from <code>1</code> to <code>n</code>.</p>

<p>You are given an array of flight bookings <code>bookings</code>, where <code>bookings[i] = [first<sub>i</sub>, last<sub>i</sub>, seats<sub>i</sub>]</code> represents a booking for flights <code>first<sub>i</sub></code> through <code>last<sub>i</sub></code> (<strong>inclusive</strong>) with <code>seats<sub>i</sub></code> seats reserved for <strong>each flight</strong> in the range.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the total number of seats reserved for flight </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
<strong>Output:</strong> [10,55,45,25,25]
<strong>Explanation:</strong>
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> bookings = [[1,2,10],[2,2,15]], n = 2
<strong>Output:</strong> [10,25]
<strong>Explanation:</strong>
Flight labels:        1   2
Booking 1 reserved:  10  10
Booking 2 reserved:      15
Total seats:         10  25
Hence, answer = [10,25]

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= bookings.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>bookings[i].length == 3</code></li>
	<li><code>1 &lt;= first<sub>i</sub> &lt;= last<sub>i</sub> &lt;= n</code></li>
	<li><code>1 &lt;= seats<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-beautiful-substrings-i/description" target="_blank" rel="noopener noreferrer">Count Beautiful Substrings I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a positive integer <code>k</code>.</p>

<p>Let <code>vowels</code> and <code>consonants</code> be the number of vowels and consonants in a string.</p>

<p>A string is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>vowels == consonants</code>.</li>
	<li><code>(vowels * consonants) % k == 0</code>, in other terms the multiplication of <code>vowels</code> and <code>consonants</code> is divisible by <code>k</code>.</li>
</ul>

<p>Return <em>the number of <strong>non-empty beautiful substrings</strong> in the given string</em> <code>s</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p><strong>Vowel letters</strong> in English are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p><strong>Consonant letters</strong> in English are every letter except vowels.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;baeyh&quot;, k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful substrings in the given string.
- Substring &quot;b<u>aeyh</u>&quot;, vowels = 2 ([&quot;a&quot;,e&quot;]), consonants = 2 ([&quot;y&quot;,&quot;h&quot;]).
You can see that string &quot;aeyh&quot; is beautiful as vowels == consonants and vowels * consonants % k == 0.
- Substring &quot;<u>baey</u>h&quot;, vowels = 2 ([&quot;a&quot;,e&quot;]), consonants = 2 ([&quot;b&quot;,&quot;y&quot;]). 
You can see that string &quot;baey&quot; is beautiful as vowels == consonants and vowels * consonants % k == 0.
It can be shown that there are only 2 beautiful substrings in the given string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abba&quot;, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 beautiful substrings in the given string.
- Substring &quot;<u>ab</u>ba&quot;, vowels = 1 ([&quot;a&quot;]), consonants = 1 ([&quot;b&quot;]). 
- Substring &quot;ab<u>ba</u>&quot;, vowels = 1 ([&quot;a&quot;]), consonants = 1 ([&quot;b&quot;]).
- Substring &quot;<u>abba</u>&quot;, vowels = 2 ([&quot;a&quot;,&quot;a&quot;]), consonants = 2 ([&quot;b&quot;,&quot;b&quot;]).
It can be shown that there are only 3 beautiful substrings in the given string.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcdf&quot;, k = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no beautiful substrings in the given string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>s</code> consists of only English lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-beautiful-substrings-ii/description" target="_blank" rel="noopener noreferrer">Count Beautiful Substrings II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a positive integer <code>k</code>.</p>

<p>Let <code>vowels</code> and <code>consonants</code> be the number of vowels and consonants in a string.</p>

<p>A string is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>vowels == consonants</code>.</li>
	<li><code>(vowels * consonants) % k == 0</code>, in other terms the multiplication of <code>vowels</code> and <code>consonants</code> is divisible by <code>k</code>.</li>
</ul>

<p>Return <em>the number of <strong>non-empty beautiful substrings</strong> in the given string</em> <code>s</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p><strong>Vowel letters</strong> in English are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p><strong>Consonant letters</strong> in English are every letter except vowels.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;baeyh&quot;, k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful substrings in the given string.
- Substring &quot;b<u>aeyh</u>&quot;, vowels = 2 ([&quot;a&quot;,e&quot;]), consonants = 2 ([&quot;y&quot;,&quot;h&quot;]).
You can see that string &quot;aeyh&quot; is beautiful as vowels == consonants and vowels * consonants % k == 0.
- Substring &quot;<u>baey</u>h&quot;, vowels = 2 ([&quot;a&quot;,e&quot;]), consonants = 2 ([&quot;b&quot;,&quot;y&quot;]).
You can see that string &quot;baey&quot; is beautiful as vowels == consonants and vowels * consonants % k == 0.
It can be shown that there are only 2 beautiful substrings in the given string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abba&quot;, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 beautiful substrings in the given string.
- Substring &quot;<u>ab</u>ba&quot;, vowels = 1 ([&quot;a&quot;]), consonants = 1 ([&quot;b&quot;]).
- Substring &quot;ab<u>ba</u>&quot;, vowels = 1 ([&quot;a&quot;]), consonants = 1 ([&quot;b&quot;]).
- Substring &quot;<u>abba</u>&quot;, vowels = 2 ([&quot;a&quot;,&quot;a&quot;]), consonants = 2 ([&quot;b&quot;,&quot;b&quot;]).
It can be shown that there are only 3 beautiful substrings in the given string.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcdf&quot;, k = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no beautiful substrings in the given string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>s</code> consists of only English lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-increasing-quadruplets/description" target="_blank" rel="noopener noreferrer">Count Increasing Quadruplets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> containing all numbers from <code>1</code> to <code>n</code>, return <em>the number of increasing quadruplets</em>.</p>

<p>A quadruplet <code>(i, j, k, l)</code> is increasing if:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>, and</li>
	<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,2,4,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- When i = 0, j = 1, k = 2, and l = 3, nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l].
- When i = 0, j = 1, k = 2, and l = 4, nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]. 
There are no other quadruplets, so we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] &lt; nums[k], we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>4 &lt;= nums.length &lt;= 4000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>. <code>nums</code> is a permutation.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-nice-subarrays/description" target="_blank" rel="noopener noreferrer">Count Number of Nice Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>. A continuous subarray is called <strong>nice</strong> if there are <code>k</code> odd numbers on it.</p>

<p>Return <em>the number of <strong>nice</strong> sub-arrays</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,1,1], k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,6], k = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no odd numbers in the array.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,1,2,2,1,2,2,2], k = 2
<strong>Output:</strong> 16
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hashing">Approach 1: Hashing</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we only need to find the number of subarrays that contain a certain count of odd elements, we can ignore the numerical values of the elements and replace all odd values with <code>1</code> and even values with <code>0</code>.</p>
<p>Now, all we need to do is identify sequences of elements within the array whose sum equals the number of odd elements needed to make a nice array. Solutions that require sequences of elements to meet criteria often utilize prefix sums, also sometimes referred to as cumulative sums.</p>
<p><strong>Note:</strong> If you aren't aware of this concept we recommend you first solve this problem <a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a>.</p>
<p>Utilizing prefix sums simplifies our approach and lets us avoid determining the sum of elements for every new subarray considered. Using the prefix sums approach, we can calculate the sum of elements between two indices, subtracting the prefix sum corresponding to the two indices to obtain the sum directly instead of iterating over the subarray to find the sum.</p>
<p>We'll use this approach to calculate how many odd numbers are between two indices in the array. Let's call the two indices <code>start</code> and <code>end</code>. If the number of odd numbers between <code>start</code> and <code>end</code> equals <code>k</code>, we have found a nice subarray. We will calculate this by finding the difference between the <code>end</code> and <code>start</code> indices.</p>
<p>Based on these thoughts, we use a hashmap to store the prefix sum of indices as keys and their frequency of occurrence as values. Instead of modifying nums, we can apply the modulo 2 operation when storing values in the hashmap.</p>
<p>We traverse the array <code>nums</code> to compute the prefix sum up to each element modulo 2. Each unique sum encountered is recorded in a hashmap. If a sum repeats, we increment its corresponding count in the hashmap. Also, for each sum encountered, we find the number of times <code>sum - k</code> has appeared before, as this count indicates how many subarrays with sum <code>k</code> exist up to the current index. We increase the count by that same amount.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize integers <code>currSum = 0</code>,<code>subarrays = 0</code> and a hashmap <code>prefixSum</code>.</li>
<li>Initialize <code>prefixSum[0]</code> with 1 to account for the initial value of <code>currSum</code>.</li>
<li>Iterate over all the elements of <code>nums</code>:
<ul>
<li>Compute <code>currSum</code> as <code>currSum = currSum + nums[i] % 2</code>.</li>
<li>If <code>currSum - k</code> exists in the hashmap:
<ul>
<li>Increment the value of <code>subarrays</code> with <code>prefixSum[currSum - k]</code>.</li>
</ul>
</li>
<li>Increment <code>prefixSum[currSum]</code> by 1.</li>
</ul>
</li>
<li>Return <code>subarrays</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BfYKRkn4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the array exactly once. In each iteration, we perform insertion and search operations in the hashmap that take <span class="math inline">\(O(1)\)</span> time. Therefore, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In each iteration, we insert a key-value pair in the hashmap. The space complexity is <span class="math inline">\(O(n)\)</span> because the size of the hashmap is proportional to the size of the list after <span class="math inline">\(n\)</span> iterations.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window-using-queue">Approach 2: Sliding Window using Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Since all of the elements in the modified <code>nums</code> array in the previous approach are non-negative, we can also try to use the sliding window approach. This pattern is applicable in scenarios where achieving a goal involves using subarrays, and individual values cannot be selected independently.</p>
<p>The concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements until the conditions are not satisfied. Then, we adjust the window by shrinking it from the left until the condition is met again.</p>
<blockquote>
<p>If the <code>nums</code> array contains any negative numbers, the sliding window approach will not work effectively. This is because when negative numbers are included, extending the window by adding more elements can decrease the sum, complicating the process of determining the optimal subarray. With non-negative numbers, the sum of the elements in the window either increases or stays the same as the window expands, allowing for a straightforward evaluation of subarrays.</p>
</blockquote>
<p>For this problem, we will simulate the process using a queue. A queue is suitable to simulate a sliding window because it efficiently adds and removes elements from both ends. The queue represents all unique windows that contain <code>k</code> odd elements and start and end with an odd element.</p>
<p>Do these windows account for all the subarrays possible in <code>nums</code>? No, because there might be some <code>0</code>s before and after the window that will increase the number of subarrays.</p>
<p>The number of subarrays for a fixed endpoint is given by the number of <code>0</code>s that could be inserted at the beginning of the window plus one (if no <code>0</code>s in the beginning). If we insert any additional <code>0</code>s at the end of this window, the subarrays would increase by this number. See the example below:</p>
<p><img src="../Figures/1248/Slide1.PNG" alt="figA" /></p>
<p>We iterate through the array <code>nums</code>. If we encounter an odd number, we push its index in the <code>oddIndices</code> queue. If the queue size exceeds <code>k</code>, we pop elements from it. If the queue has exactly <code>k</code> odd numbers, we can increment our answer by the number of <code>0</code>s at the beginning of the subarray.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize integers <code>subarrays = 0</code>, <code>lastPopped = -1</code>, <code>initialGap = 0</code> and a queue <code>oddIndices</code>.</li>
<li>Iterate over all the elements of <code>nums</code>:
<ul>
<li>If the current element is odd:
<ul>
<li>Push the current index in <code>oddIndices</code>.</li>
</ul>
</li>
<li>If the size of the queue is greater than <code>k</code>:
<ul>
<li>Store the front of the queue in <code>lastPopped</code>.</li>
<li>Pop the front of the queue.</li>
</ul>
</li>
<li>If size of the queue is <code>k</code>:
<ul>
<li>Set <code>initialGap</code> as the difference between the front of the queue and <code>lastPopped</code>.</li>
<li>Increment <code>subarrays</code> by <code>initialGap</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>subarrays</code>.</li>
</ol>
<p>!?!../Documents/1248/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/JLRzMbwP/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the array exactly once. In each iteration of the array, we perform queue operations such as push, pop, and accessing the front element that takes <span class="math inline">\(O(1)\)</span> time. Therefore, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In each iteration, we perform one push operation in the queue. The space complexity is <span class="math inline">\(O(n)\)</span> because the queue size is proportional to the size of the list after <span class="math inline">\(n\)</span> iterations.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sliding-window-space-optimisation-of-queue-based-approach">Approach 3: Sliding Window (Space Optimisation of queue-based approach)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Is it possible to avoid the queue in the previous approach? We only need the frequency of <code>0</code>s at the start to calculate the answer, so we can optimize the algorithm by calculating this value without using an additional <span class="math inline">\(O(n)\)</span> memory.</p>
<p>While iterating through all possible endpoints of the windows, keep track of the count of odd values using an integer <code>qsize</code>. If <code>qsize</code> reaches <code>k</code>, adjust the <code>start</code> pointer to skip over even values at the beginning of the subarray until an odd value is encountered.</p>
<p>Now, we add the number of even values covered by the <code>start</code> pointer, given by <code>initialGap</code>, to the answer. We will add this value to the answer for every subsequent even value.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize integers <code>subarrays = 0</code>, <code>qsize = 0</code>, <code>initialGap = 0</code> and <code>start = 0</code>.</li>
<li>Iterate over all the elements of <code>nums</code>:
<ul>
<li>If the current element is odd:
<ul>
<li>Increment <code>qsize</code> by 1.</li>
</ul>
</li>
<li>If <code>qsize</code> is equal to <code>k</code>:
<ul>
<li>Set <code>initialGap</code> as 0.</li>
<li>While <code>qsize</code> is <code>k</code>:
<ul>
<li>Decrease <code>qsize</code> by 1 if element at <code>start</code> is odd.</li>
<li>Increment <code>initialGap</code> by 1.</li>
<li>Increment <code>start</code> by 1.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>subarrays</code> by <code>initialGap</code>.</li>
</ul>
</li>
<li>Return <code>subarrays</code>.</li>
</ol>
<p>!?!../Documents/1248/slideshow2.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/aWmfoYRG/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the array exactly once. The <code>start</code> pointer can move at most <code>n</code> steps through all iterations. Therefore, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not allocate any additional auxiliary memory in our algorithm. Therefore, overall space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-sliding-window-subarray-sum-at-most-k">Approach 4: Sliding Window (subarray sum at most k)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Is it possible to find the number of subarrays with sum at most <code>k</code> for an array with non-negative elements? We can use the sliding window approach to do this. However, for this problem, we need to calculate the number of subarrays with a sum exactly <code>k</code> (from Approach 1), not at most <code>k</code>. Observe that if we calculate the number of subarrays with sum at most <code>k</code> and at most <code>k-1</code>, their difference would give us the number of subarrays with sum exactly <code>k</code>.</p>
<p>For a subarray with a fixed <code>end</code> index, let <code>start</code> be the first index where the subarray from <code>start</code> to <code>end</code> contains exactly <code>k</code> odd elements. Any subarray that starts at an index after <code>start</code> and ends at <code>end</code> will contain at most <code>k</code> odd elements.</p>
<p>We iterate over the array <code>nums</code> for all possible values of <code>end</code>. Once we find the <code>start</code> value, the number of subarrays with at most <code>k</code> odd elements is calculated as <code>end - start + 1</code>(window size). We accumulate this value to the final answer across all end values.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Main Function</strong>: <code>numberOfSubarrays(nums, k)</code></p>
<ol>
<li>Return the difference of <code>atMost(nums, k)</code> and <code>atMost(nums, k - 1)</code></li>
</ol>
<p><strong>Function</strong>: <code>atMost(nums, k)</code></p>
<ol>
<li>Initialize integers <code>subarrays = 0</code>, <code>windowSize = 0</code> and <code>start = 0</code>.</li>
<li>Iterate over all the elements of <code>nums</code>:
<ul>
<li>If the current element is odd:
<ul>
<li>Increment <code>windowSize</code> by 1.</li>
</ul>
</li>
<li>While <code>windowSize</code> is greater than <code>k</code>:
<ul>
<li>Decrease <code>windowSize</code> by 1 if the current element is odd.</li>
<li>Increment <code>start</code> by 1.</li>
</ul>
</li>
<li>Increment <code>subarrays</code> with <code>end - start + 1</code>, where <code>end</code> is the current index.</li>
</ul>
</li>
<li>Return <code>subarrays</code>.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/2gAJmrUz/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We call the <code>atMost</code> function 2 times. We iterate through the array exactly once in the function. The <code>start</code> pointer can move atmost <code>n</code> steps through all iterations. Therefore, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span><br />
Â <br />
We do not allocate any additional auxiliary memory in our algorithm. Therefore, overall space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-of-interesting-subarrays/description" target="_blank" rel="noopener noreferrer">Count of Interesting Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>, an integer <code>modulo</code>, and an integer <code>k</code>.</p>

<p>Your task is to find the count of subarrays that are <strong>interesting</strong>.</p>

<p>A <strong>subarray</strong> <code>nums[l..r]</code> is <strong>interesting</strong> if the following condition holds:</p>

<ul>
	<li>Let <code>cnt</code> be the number of indices <code>i</code> in the range <code>[l, r]</code> such that <code>nums[i] % modulo == k</code>. Then, <code>cnt % modulo == k</code>.</li>
</ul>

<p>Return <em>an integer denoting the count of interesting subarrays. </em></p>

<p><span><strong>Note:</strong> A subarray is <em>a contiguous non-empty sequence of elements within an array</em>.</span></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,4], modulo = 2, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example the interesting subarrays are: 
The subarray nums[0..0] which is [3]. 
- There is only one index, i = 0, in the range [0, 0] that satisfies nums[i] % modulo == k. 
- Hence, cnt = 1 and cnt % modulo == k.  
The subarray nums[0..1] which is [3,2].
- There is only one index, i = 0, in the range [0, 1] that satisfies nums[i] % modulo == k.  
- Hence, cnt = 1 and cnt % modulo == k.
The subarray nums[0..2] which is [3,2,4]. 
- There is only one index, i = 0, in the range [0, 2] that satisfies nums[i] % modulo == k. 
- Hence, cnt = 1 and cnt % modulo == k. 
It can be shown that there are no other interesting subarrays. So, the answer is 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,9,6], modulo = 3, k = 0
<strong>Output:</strong> 2
<strong>Explanation: </strong>In this example the interesting subarrays are: 
The subarray nums[0..3] which is [3,1,9,6]. 
- There are three indices, i = 0, 2, 3, in the range [0, 3] that satisfy nums[i] % modulo == k. 
- Hence, cnt = 3 and cnt % modulo == k. 
The subarray nums[1..1] which is [1]. 
- There is no index, i, in the range [1, 1] that satisfies nums[i] % modulo == k. 
- Hence, cnt = 0 and cnt % modulo == k. 
It can be shown that there are no other interesting subarrays. So, the answer is 2.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5 </sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= modulo &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt; modulo</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-prefix-sum">Approach: Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the description, given the array <span class="math inline">\(\textit{nums}\)</span> and integers <span class="math inline">\(\textit{modulo}\)</span> and <span class="math inline">\(k\)</span>, if the element <span class="math inline">\(x\)</span> in the subarray <span class="math inline">\(\textit{nums}[l..r]\)</span> satisfies <span class="math inline">\(x \bmod \textit{modulo} = k\)</span> and appears <span class="math inline">\(\textit{cnt}\)</span> times, then the subarray <span class="math inline">\(\textit{nums}[l..r]\)</span> is called an <strong>interesting subarray</strong> if <span class="math inline">\(\textit{cnt} \bmod \textit{modulo} = k\)</span>.</p>
<p>Since we need to count the number of occurrences of special elements in the array interval, we can consider using prefix sums. We define <span class="math inline">\(\textit{sum}[i]\)</span> as the number of special elements that satisfy <span class="math inline">\(x \bmod \textit{modulo} = k\)</span> in the array <span class="math inline">\(\textit{nums}\)</span> from index <span class="math inline">\(0\)</span> to <span class="math inline">\(i\)</span>. The number of special elements in the subarray <span class="math inline">\(\textit{nums}[l..r]\)</span> is then <span class="math inline">\(\textit{sum}[r] - \textit{sum}[l-1]\)</span>. According to the description, it can be deduced that at this time, in order to satisfy:</p>
<p><span class="math display">\[(\textit{sum}[r] - \textit{sum}[l-1]) \bmod \textit{modulo} = k
\]</span></p>
<p>The transformation of the above equation yields:</p>
<p><span class="math display">\[(\textit{sum}[r]  - k +  \textit{modulo}) \bmod \textit{modulo} = \textit{sum}[l-1] \bmod \textit{modulo}
\]</span></p>
<p>According to the above formula, it can be known that for index <span class="math inline">\(r\)</span>, if there exists an index <span class="math inline">\(l\)</span> such that <span class="math inline">\(l \leq r\)</span>, and which satisfies <span class="math inline">\((\textit{sum}[r] - k + \textit{modulo}) \bmod \textit{modulo} = \textit{sum}[l-1] \bmod \textit{modulo}\)</span>, then the subarray <span class="math inline">\(\textit{nums}[l..r]\)</span> is an <strong>interesting subarray</strong>.</p>
<p>We use a hash table <span class="math inline">\(\textit{cnt}\)</span> to store the number of occurrences of <span class="math inline">\(\textit{sum}[i] \bmod \textit{modulo}\)</span> in the current prefix that has been traversed. Each time we enumerate the index <span class="math inline">\(r\)</span> from small to large, we expect to be able to quickly find the number of &quot;interesting subarrays&quot; with <span class="math inline">\(r\)</span> as the right endpoint, i.e., the number of left boundaries <span class="math inline">\(l\)</span> that satisfy the condition. According to the above inference, it can be known that at this time, it is only necessary to find the number of elements equal to <span class="math inline">\((\textit{sum}[r] - k + \textit{modulo}) \bmod \textit{modulo}\)</span> in the hash table <span class="math inline">\(\textit{cnt}\)</span>, which is the number of elements satisfying the left boundary condition. Add this to the result, and finally return the total accumulated result. To optimize the calculation, the prefix sum of the special elements can be represented by a single variable <span class="math inline">\(\textit{prefix}\)</span> at this time.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MbE3mGux/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>We only need to traverse the array once, and the time required is <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(\min(n, \textit{modulo}))\)</span></li>
</ul>
<p>It is necessary to use a hash map to store the frequency of each element's modulo result in the array. There can be at most <span class="math inline">\(O(\min(n, \textit{modulo}))\)</span> different modulo results, so the required space is <span class="math inline">\(O(\min(n, \textit{modulo}))\)</span>.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-partitions-with-even-sum-difference/description" target="_blank" rel="noopener noreferrer">Count Partitions with Even Sum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code>.</p>

<p>A <strong>partition</strong> is defined as an index <code>i</code> where <code>0 &lt;= i &lt; n - 1</code>, splitting the array into two <strong>non-empty</strong> subarrays such that:</p>

<ul>
	<li>Left subarray contains indices <code>[0, i]</code>.</li>
	<li>Right subarray contains indices <code>[i + 1, n - 1]</code>.</li>
</ul>

<p>Return the number of <strong>partitions</strong> where the <strong>difference</strong> between the <strong>sum</strong> of the left and right subarrays is <strong>even</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [10,10,3,7,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The 4 partitions are:</p>

<ul>
	<li><code>[10]</code>, <code>[10, 3, 7, 6]</code> with a sum difference of <code>10 - 26 = -16</code>, which is even.</li>
	<li><code>[10, 10]</code>, <code>[3, 7, 6]</code> with a sum difference of <code>20 - 16 = 4</code>, which is even.</li>
	<li><code>[10, 10, 3]</code>, <code>[7, 6]</code> with a sum difference of <code>23 - 13 = 10</code>, which is even.</li>
	<li><code>[10, 10, 3, 7]</code>, <code>[6]</code> with a sum difference of <code>30 - 6 = 24</code>, which is even.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No partition results in an even sum difference.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,4,6,8]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>All partitions result in an even sum difference.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-partitions-with-max-min-difference-at-most-k/description" target="_blank" rel="noopener noreferrer">Count Partitions With Max-Min Difference at Most K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>k</code>. Your task is to partition <code>nums</code> into one or more <strong>non-empty</strong> contiguous segments such that in each segment, the difference between its <strong>maximum</strong> and <strong>minimum</strong> elements is <strong>at most</strong> <code>k</code>.</p>

<p>Return the total number of ways to partition <code>nums</code> under this condition.</p>

<p>Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [9,4,1,3,7], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 valid partitions where the difference between the maximum and minimum elements in each segment is at most <code>k = 4</code>:</p>

<ul>
	<li><code>[[9], [4], [1], [3], [7]]</code></li>
	<li><code>[[9], [4], [1], [3, 7]]</code></li>
	<li><code>[[9], [4], [1, 3], [7]]</code></li>
	<li><code>[[9], [4, 1], [3], [7]]</code></li>
	<li><code>[[9], [4, 1], [3, 7]]</code></li>
	<li><code>[[9], [4, 1, 3], [7]]</code></li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,3,4], k = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 2 valid partitions that satisfy the given conditions:</p>

<ul>
	<li><code>[[3], [3], [4]]</code></li>
	<li><code>[[3, 3], [4]]</code></li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-subarrays-with-median-k/description" target="_blank" rel="noopener noreferrer">Count Subarrays With Median K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of size <code>n</code> consisting of <strong>distinct </strong>integers from <code>1</code> to <code>n</code> and a positive integer <code>k</code>.</p>

<p>Return <em>the number of non-empty subarrays in </em><code>nums</code><em> that have a <strong>median</strong> equal to </em><code>k</code>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>The median of an array is the <strong>middle </strong>element after sorting the array in <strong>ascending </strong>order. If the array is of even length, the median is the <strong>left </strong>middle element.

	<ul>
		<li>For example, the median of <code>[2,3,1,4]</code> is <code>2</code>, and the median of <code>[8,4,3,5,1]</code> is <code>4</code>.</li>
	</ul>
	</li>
	<li>A subarray is a contiguous part of an array.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,4,5], k = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1], k = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> [3] is the only subarray that has a median equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], k &lt;= n</code></li>
	<li>The integers in <code>nums</code> are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-subarrays-with-score-less-than-k/description" target="_blank" rel="noopener noreferrer">Count Subarrays With Score Less Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>score</strong> of an array is defined as the <strong>product</strong> of its sum and its length.</p>

<ul>
	<li>For example, the score of <code>[1, 2, 3, 4, 5]</code> is <code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code>.</li>
</ul>

<p>Given a positive integer array <code>nums</code> and an integer <code>k</code>, return <em>the <strong>number of non-empty subarrays</strong> of</em> <code>nums</code> <em>whose score is <strong>strictly less</strong> than</em> <code>k</code>.</p>

<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4,3,5], k = 10
<strong>Output:</strong> 6
<strong>Explanation:</strong>
The 6 subarrays having scores less than 10 are:
- [2] with score 2 * 1 = 2.
- [1] with score 1 * 1 = 1.
- [4] with score 4 * 1 = 4.
- [3] with score 3 * 1 = 3. 
- [5] with score 5 * 1 = 5.
- [2,1] with score (2 + 1) * 2 = 6.
Note that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1], k = 5
<strong>Output:</strong> 5
<strong>Explanation:</strong>
Every subarray except [1,1,1] has a score less than 5.
[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.
Thus, there are 5 subarrays having scores less than 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the definition of array scores in the question, and given that <span class="math inline">\(\textit{nums}\)</span> is an array of positive integers, for a subarray <span class="math inline">\([i, j]\)</span>, as the right endpoint <span class="math inline">\(j\)</span> is fixed, the sum of the subarray decreases and its length shortens with the increase of the left endpoint <span class="math inline">\(i\)</span>, so the score of the subarray monotonically decreases. If the score of the subarray <span class="math inline">\([i, j]\)</span> is less than <span class="math inline">\(k\)</span>, since the score is monotonically decreasing, then the score of the subarray <span class="math inline">\([p, j], i < p \leq j\)</span> is also less than <span class="math inline">\(k\)</span>.</p>
<p>Based on the above properties, we can use the sliding window method to solve the question. Starting from <span class="math inline">\(j = 0\)</span>, enumerate the right endpoint of the subarray and maintain a left endpoint <span class="math inline">\(i\)</span> (initially set to <span class="math inline">\(0\)</span>). For each <span class="math inline">\(j\)</span>:</p>
<ul>
<li>
<p>Expand window: Add <span class="math inline">\(\textit{nums}[j]\)</span> to the subarray sum corresponding to the current window <span class="math inline">\(\textit{total}\)</span>.</p>
</li>
<li>
<p>Shrink window: If the score of the corresponding subarray in the current window, <span class="math inline">\(\textit{total} \times (j - i + 1)\)</span>, is greater than or equal to <span class="math inline">\(k\)</span>, it indicates that the subarray does not meet the requirements, and therefore, the left endpoint <span class="math inline">\(i\)</span> needs to be moved to the right until the score is less than <span class="math inline">\(k\)</span>.</p>
</li>
<li>
<p>Count the number of subarrays: At this moment, the number of subarrays with <span class="math inline">\(j\)</span> as the right endpoint and a score less than <span class="math inline">\(k\)</span> is <span class="math inline">\(j - i + 1\)</span>, and it is accumulated into the final result <span class="math inline">\(\textit{res}\)</span>.</p>
</li>
</ul>
<p>After the enumeration, return the final result <span class="math inline">\(\textit{res}\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5CroPzAm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>We only need to traverse the array once.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<p>Only a few additional variables are needed.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/description" target="_blank" rel="noopener noreferrer">Count Submatrices With Equal Frequency of X and Y</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D character matrix <code>grid</code>, where <code>grid[i][j]</code> is either <code>&#39;X&#39;</code>, <code>&#39;Y&#39;</code>, or <code>&#39;.&#39;</code>, return the number of <span data-keyword="submatrix">submatrices</span> that contain:</p>

<ul>
	<li><code>grid[0][0]</code></li>
	<li>an <strong>equal</strong> frequency of <code>&#39;X&#39;</code> and <code>&#39;Y&#39;</code>.</li>
	<li><strong>at least</strong> one <code>&#39;X&#39;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;X&quot;,&quot;Y&quot;,&quot;.&quot;],[&quot;Y&quot;,&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/06/07/examplems.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 175px; height: 350px;" /></strong></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;Y&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No submatrix has an equal frequency of <code>&#39;X&#39;</code> and <code>&#39;Y&#39;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No submatrix has at least one <code>&#39;X&#39;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 1000</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;X&#39;</code>, <code>&#39;Y&#39;</code>, or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/description" target="_blank" rel="noopener noreferrer">Count Submatrices with Top-Left Element and Sum Less Than k</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer matrix <code>grid</code> and an integer <code>k</code>.</p>

<p>Return <em>the <strong>number</strong> of <span data-keyword="submatrix">submatrices</span> that contain the top-left element of the</em> <code>grid</code>, <em>and have a sum less than or equal to </em><code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/01/example1.png" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> grid = [[7,6,3],[6,6,1]], k = 18
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/01/example21.png" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length </code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 1000 </code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-substrings-that-satisfy-k-constraint-ii/description" target="_blank" rel="noopener noreferrer">Count Substrings That Satisfy K-Constraint II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>binary</strong> string <code>s</code> and an integer <code>k</code>.</p>

<p>You are also given a 2D integer array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>.</p>

<p>A <strong>binary string</strong> satisfies the <strong>k-constraint</strong> if <strong>either</strong> of the following conditions holds:</p>

<ul>
	<li>The number of <code>0</code>&#39;s in the string is at most <code>k</code>.</li>
	<li>The number of <code>1</code>&#39;s in the string is at most <code>k</code>.</li>
</ul>

<p>Return an integer array <code>answer</code>, where <code>answer[i]</code> is the number of <span data-keyword="substring-nonempty">substrings</span> of <code>s[l<sub>i</sub>..r<sub>i</sub>]</code> that satisfy the <strong>k-constraint</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;0001111&quot;, k = 2, queries = [[0,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[26]</span></p>

<p><strong>Explanation:</strong></p>

<p>For the query <code>[0, 6]</code>, all substrings of <code>s[0..6] = &quot;0001111&quot;</code> satisfy the k-constraint except for the substrings <code>s[0..5] = &quot;000111&quot;</code> and <code>s[0..6] = &quot;0001111&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;010101&quot;, k = 1, queries = [[0,5],[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[15,9,3]</span></p>

<p><strong>Explanation:</strong></p>

<p>The substrings of <code>s</code> with a length greater than 3 do not satisfy the k-constraint.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= k &lt;= s.length</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i] == [l<sub>i</sub>, r<sub>i</sub>]</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; s.length</code></li>
	<li>All queries are distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-hidden-sequences/description" target="_blank" rel="noopener noreferrer">Count the Hidden Sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <code>n</code> integers <code>differences</code>, which describes the <strong>differences </strong>between each pair of <strong>consecutive </strong>integers of a <strong>hidden</strong> sequence of length <code>(n + 1)</code>. More formally, call the hidden sequence <code>hidden</code>, then we have that <code>differences[i] = hidden[i + 1] - hidden[i]</code>.</p>

<p>You are further given two integers <code>lower</code> and <code>upper</code> that describe the <strong>inclusive</strong> range of values <code>[lower, upper]</code> that the hidden sequence can contain.</p>

<ul>
	<li>For example, given <code>differences = [1, -3, 4]</code>, <code>lower = 1</code>, <code>upper = 6</code>, the hidden sequence is a sequence of length <code>4</code> whose elements are in between <code>1</code> and <code>6</code> (<strong>inclusive</strong>).

	<ul>
		<li><code>[3, 4, 1, 5]</code> and <code>[4, 5, 2, 6]</code> are possible hidden sequences.</li>
		<li><code>[5, 6, 3, 7]</code> is not possible since it contains an element greater than <code>6</code>.</li>
		<li><code>[1, 2, 3, 4]</code> is not possible since the differences are not correct.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the number of <strong>possible</strong> hidden sequences there are.</em> If there are no possible sequences, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> differences = [1,-3,4], lower = 1, upper = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> The possible hidden sequences are:
- [3, 4, 1, 5]
- [4, 5, 2, 6]
Thus, we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> differences = [3,-4,5,1,-2], lower = -4, upper = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> The possible hidden sequences are:
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
Thus, we return 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> differences = [4,-7,2], lower = 3, upper = 6
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no possible hidden sequences. Thus, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == differences.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= differences[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-determine-the-difference-between-the-hidden-arrays-upper-and-lower-bounds">Approach: Determine the Difference Between the Hidden Array's Upper and Lower Bounds</h3>
<h4 id="intuition">Intuition</h4>
<p>Let <span class="math inline">\(a_0, a_1, \cdots, a_n\)</span> be the final array. We can find that if the array <span class="math inline">\(a\)</span> meets the requirements, then:</p>
<p><span class="math display">\[a_0 + k, a_1 + k, \cdots, a_n + k
\]</span></p>
<p>also meets the requirements. The term &quot;requirement&quot; here refers to the difference between adjacent elements corresponding to the given array <span class="math inline">\(\textit{differences}\)</span>.</p>
<p>We can arbitrarily specify <span class="math inline">\(a_0\)</span>. For convenience, let's directly set <span class="math inline">\(a_0 = 0\)</span>, and then we can restore the array <span class="math inline">\(a_0, a_1, \cdots, a_n\)</span>. If we continue to consider the requirement that all array elements are within the range <span class="math inline">\([\textit{lower}, \textit{upper}]\)</span>, let's denote the smallest element of the array as <span class="math inline">\(a_i\)</span>, and the largest element as <span class="math inline">\(a_j\)</span>. It is obviously necessary to satisfy:</p>
<p><span class="math display">\[\textit{lower} \leq a_i \leq a_j \leq \textit{upper}
\]</span></p>
<p>Then the lower bound of the value of <span class="math inline">\(a_i\)</span> is <span class="math inline">\(\textit{lower}\)</span>, and the upper bound is <span class="math inline">\(\textit{upper} - (a_j - a_i)\)</span>, which means that the maximum value <span class="math inline">\(a_j\)</span> must not exceed <span class="math inline">\(\textit{upper}\)</span>. Here, <span class="math inline">\(a_j - a_i\)</span> is actually unrelated to the actual values of <span class="math inline">\(a_i, a_j\)</span>, and it is equal to:</p>
<p><span class="math display">\[\sum_{k=i}^{j-1} \textit{differences}[k]
\]</span></p>
<p>Therefore, the number of hidden arrays that meet the requirements is <span class="math inline">\(\textit{upper} - (a_j - a_i) - \textit{lower} + 1\)</span>, and after arrangement, we get:</p>
<p><span class="math display">\[(\textit{upper} - \textit{lower}) - (a_j - a_i) + 1
\]</span></p>
<p>In fact, it is the length of the interval of the specified array elements, minus the difference between the maximum and minimum values of the array elements, plus <span class="math inline">\(1\)</span>. We can consider it as the number of positions where a small window of length <span class="math inline">\(a_j - a_i\)</span> can be placed while sliding within a large window of length <span class="math inline">\(\textit{upper} - \textit{lower}\)</span>.</p>
<p>During the process of restoring the array <span class="math inline">\(a\)</span>, we do not need to record the entire array, but only need to record the maximum and minimum values. If at any moment the difference between the maximum and minimum values is greater than <span class="math inline">\(\textit{upper} - \textit{lower}\)</span>, we can directly return <span class="math inline">\(0\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7xSFXU84/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>We only need to traverse the <span class="math inline">\(\textit{differences}\)</span> array once.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<p>Only a few additional variables are needed.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-beautiful-subarrays/description" target="_blank" rel="noopener noreferrer">Count the Number of Beautiful Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one operation, you can:</p>

<ul>
	<li>Choose two different indices <code>i</code> and <code>j</code> such that <code>0 &lt;= i, j &lt; nums.length</code>.</li>
	<li>Choose a non-negative integer <code>k</code> such that the <code>k<sup>th</sup></code> bit (<strong>0-indexed</strong>) in the binary representation of <code>nums[i]</code> and <code>nums[j]</code> is <code>1</code>.</li>
	<li>Subtract <code>2<sup>k</sup></code> from <code>nums[i]</code> and <code>nums[j]</code>.</li>
</ul>

<p>A subarray is <strong>beautiful</strong> if it is possible to make all of its elements equal to <code>0</code> after applying the above operation any number of times (including zero).</p>

<p>Return <em>the number of <strong>beautiful subarrays</strong> in the array</em> <code>nums</code>.</p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p><strong>Note</strong>: Subarrays where all elements are initially 0 are considered beautiful, as no operation is needed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,1,2,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 beautiful subarrays in nums: [4,<u>3,1,2</u>,4] and [<u>4,3,1,2,4</u>].
- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:
  - Choose [<u>3</u>, 1, <u>2</u>] and k = 1. Subtract 2<sup>1</sup> from both numbers. The subarray becomes [1, 1, 0].
  - Choose [<u>1</u>, <u>1</u>, 0] and k = 0. Subtract 2<sup>0</sup> from both numbers. The subarray becomes [0, 0, 0].
- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:
  - Choose [<u>4</u>, 3, 1, 2, <u>4</u>] and k = 2. Subtract 2<sup>2</sup> from both numbers. The subarray becomes [0, 3, 1, 2, 0].
  - Choose [0, <u>3</u>, <u>1</u>, 2, 0] and k = 0. Subtract 2<sup>0</sup> from both numbers. The subarray becomes [0, 2, 0, 2, 0].
  - Choose [0, <u>2</u>, 0, <u>2</u>, 0] and k = 1. Subtract 2<sup>1</sup> from both numbers. The subarray becomes [0, 0, 0, 0, 0].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,10,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no beautiful subarrays in nums.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-i/description" target="_blank" rel="noopener noreferrer">Count the Number of Houses at a Certain Distance I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>

<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>

<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>

<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>

<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example2.png" style="width: 474px; height: 197px;" />
<pre>
<strong>Input:</strong> n = 3, x = 1, y = 3
<strong>Output:</strong> [6,0,0]
<strong>Explanation:</strong> Let&#39;s look at each pair of houses:
- For the pair (1, 2), we can go from house 1 to house 2 directly.
- For the pair (2, 1), we can go from house 2 to house 1 directly.
- For the pair (1, 3), we can go from house 1 to house 3 directly.
- For the pair (3, 1), we can go from house 3 to house 1 directly.
- For the pair (2, 3), we can go from house 2 to house 3 directly.
- For the pair (3, 2), we can go from house 3 to house 2 directly.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example3.png" style="width: 668px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 5, x = 2, y = 4
<strong>Output:</strong> [10,8,2,0,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
- For k == 3, the pairs are (1, 5), and (5, 1).
- For k == 4 and k == 5, there are no pairs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example5.png" style="width: 544px; height: 130px;" />
<pre>
<strong>Input:</strong> n = 4, x = 1, y = 1
<strong>Output:</strong> [6,4,2,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
- For k == 3, the pairs are (1, 4), and (4, 1).
- For k == 4, there are no pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= x, y &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/description" target="_blank" rel="noopener noreferrer">Count the Number of Houses at a Certain Distance II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three <strong>positive</strong> integers <code>n</code>, <code>x</code>, and <code>y</code>.</p>

<p>In a city, there exist houses numbered <code>1</code> to <code>n</code> connected by <code>n</code> streets. There is a street connecting the house numbered <code>i</code> with the house numbered <code>i + 1</code> for all <code>1 &lt;= i &lt;= n - 1</code> . An additional street connects the house numbered <code>x</code> with the house numbered <code>y</code>.</p>

<p>For each <code>k</code>, such that <code>1 &lt;= k &lt;= n</code>, you need to find the number of <strong>pairs of houses</strong> <code>(house<sub>1</sub>, house<sub>2</sub>)</code> such that the <strong>minimum</strong> number of streets that need to be traveled to reach <code>house<sub>2</sub></code> from <code>house<sub>1</sub></code> is <code>k</code>.</p>

<p>Return <em>a <strong>1-indexed</strong> array </em><code>result</code><em> of length </em><code>n</code><em> where </em><code>result[k]</code><em> represents the <strong>total</strong> number of pairs of houses such that the <strong>minimum</strong> streets required to reach one house from the other is </em><code>k</code>.</p>

<p><strong>Note</strong> that <code>x</code> and <code>y</code> can be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example2.png" style="width: 474px; height: 197px;" />
<pre>
<strong>Input:</strong> n = 3, x = 1, y = 3
<strong>Output:</strong> [6,0,0]
<strong>Explanation:</strong> Let&#39;s look at each pair of houses:
- For the pair (1, 2), we can go from house 1 to house 2 directly.
- For the pair (2, 1), we can go from house 2 to house 1 directly.
- For the pair (1, 3), we can go from house 1 to house 3 directly.
- For the pair (3, 1), we can go from house 3 to house 1 directly.
- For the pair (2, 3), we can go from house 2 to house 3 directly.
- For the pair (3, 2), we can go from house 3 to house 2 directly.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example3.png" style="width: 668px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 5, x = 2, y = 4
<strong>Output:</strong> [10,8,2,0,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).
- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).
- For k == 3, the pairs are (1, 5), and (5, 1).
- For k == 4 and k == 5, there are no pairs.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/20/example5.png" style="width: 544px; height: 130px;" />
<pre>
<strong>Input:</strong> n = 4, x = 1, y = 1
<strong>Output:</strong> [6,4,2,0]
<strong>Explanation:</strong> For each distance k the pairs are:
- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).
- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).
- For k == 3, the pairs are (1, 4), and (4, 1).
- For k == 4, there are no pairs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= x, y &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/description" target="_blank" rel="noopener noreferrer">Count Triplets That Can Form Two Arrays of Equal XOR</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code>.</p>

<p>We want to select three indices <code>i</code>, <code>j</code> and <code>k</code> where <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code>.</p>

<p>Let&#39;s define <code>a</code> and <code>b</code> as follows:</p>

<ul>
	<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>
	<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>
</ul>

<p>Note that <strong>^</strong> denotes the <strong>bitwise-xor</strong> operation.</p>

<p>Return <em>the number of triplets</em> (<code>i</code>, <code>j</code> and <code>k</code>) Where <code>a == b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,3,1,6,7]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,1,1,1]
<strong>Output:</strong> 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 300</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find triplets of indices <span class="math inline">\((i, j, k)\)</span> in a given array of integers such that the bitwise <strong>XOR</strong> of elements between indices <code>i</code> and <code>j - 1</code> is equal to the bitwise <strong>XOR</strong> of elements between indices <code>j</code> and <code>k</code>.</p>
<p>Define <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(a = \text{arr}[i] \oplus \text{arr}[i + 1] \oplus \ldots \oplus \text{arr}[j - 1]\)</span></li>
<li><span class="math inline">\(b = \text{arr}[j] \oplus \text{arr}[j + 1] \oplus \ldots \oplus \text{arr}[k]\)</span></li>
</ul>
<p>Where <span class="math inline">\(\oplus\)</span> denotes the bitwise <strong>XOR</strong> operation.</p>
<p>Return the number of triplets <span class="math inline">\((i, j, k)\)</span> where <span class="math inline">\(a == b\)</span>.</p>
<p>Before moving ahead let us discuss a few points about <strong>XOR</strong> operations:</p>
<ol>
<li>
<p><strong>XOR Properties</strong>:</p>
<ul>
<li><strong>XOR</strong> is both associative and commutative, meaning the order in which you <strong>XOR</strong> numbers doesn't matter.</li>
<li><span class="math inline">\(a \oplus a = 0\)</span> and <span class="math inline">\(a \oplus 0 = a\)</span>.</li>
</ul>
</li>
<li>
<p><strong>Equal XOR Condition</strong>:</p>
<ul>
<li>For <span class="math inline">\(a = b\)</span>, this implies:</li>
</ul>
<p><span class="math display">\[- Using the associative property of **XOR**, we can rewrite the combined **XOR** from $i$ to $k$ as:
$$\text{arr}[i] \oplus \text{arr}[i + 1] \oplus \ldots \oplus \text{arr}[j - 1] \oplus \text{arr}[j] \oplus \text{arr}[j + 1] \oplus \ldots \oplus \text{arr}[k] = 0$$
- If we let $X(i, k)$ be the **XOR** of elements from $i$ to $k$:
$$X(i, k) = 0$$
- This means if the total **XOR** from $i$ to $k$ is zero, then any $j$ between $i$ and $k$ (inclusive) create a triplet with $i$ and $k$ that satisfies $a = b$.

\]</span></p>
</li>
<li>
<p><strong>Prefix XOR</strong>:</p>
<ul>
<li>Define <span class="math inline">\(\text{prefix}[x]\)</span> as the <strong>XOR</strong> of all elements from the start up to index <span class="math inline">\(x\)</span>:
<p><span class="math display">\[\text{prefix}[x] = \text{arr}[0] \oplus \text{arr}[1] \oplus \ldots \oplus \text{arr}[x]
\]</span></p>
<ul>
<li>Using this, the problem can be reduced to finding indices where:</li>
</ul>
<p><span class="math display">\[\text{prefix}[i-1] == \text{prefix}[k]
\]</span></p>
<ul>
<li>The reason for this is because:</li>
</ul>
<p><span class="math display">\[\text{prefix}[k] = \text{prefix}[j-1] \oplus (\text{arr}[j] \oplus \text{arr}[j+1] \oplus \ldots \oplus \text{arr}[k])
\]</span></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>If you are not familiar with Bitwise operators, we recommend you read our <strong><a href="https://leetcode.com/explore/learn/card/bit-manipulation/">Bit Manipulation Explore Card</a></strong>.</p>
</blockquote>
<hr />
<h3 id="approach-1-brute-force-with-prefix">Approach 1: Brute Force With Prefix</h3>
<h4 id="intuition">Intuition</h4>
<p>We can exhaustively iterate through every possible triplet <span class="math inline">\((i, j, k)\)</span> and check if the <strong>XOR</strong> of the subarrays <span class="math inline">\((i, j-1)\)</span> and <span class="math inline">\((j, k)\)</span> is equal.</p>
<p>First, we iterate over each possible starting index <code>start</code> of the triplet. For each <code>start</code>, we initialize a variable <code>xorA</code> to store the <strong>XOR</strong> (bitwise exclusive OR) of elements from the <code>start</code> index to the index just before the <code>mid</code> index. We then iterate over each possible <code>mid</code> index, updating <code>xorA</code> by <strong>XOR</strong>ing it with the element at the index just before <code>mid</code>.</p>
<p>Next, for each <code>mid</code> index, we initialize another variable, <code>xorB</code>, to store the <strong>XOR</strong> of elements from the <code>mid</code> index to the end of the array. We iterate over each possible ending index <code>end</code>, starting from <code>mid</code>, updating <code>xorB</code> by <strong>XOR</strong>ing it with the element at the <code>end</code> index.</p>
<p>After computing <code>xorA</code> and <code>xorB</code>, we check if they are equal. If they are, it means that the <strong>XOR</strong> of elements in the first subarray (from <code>start</code> to <code>mid - 1</code>) is equal to the <strong>XOR</strong> of elements in the second subarray (from <code>mid</code> to <code>end</code>). In this case, we have found a valid triplet satisfying the condition, so we increment the result counter.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a result variable <code>count</code> to 0 to store the count of valid triplets.</li>
<li>Iterate over each possible starting index <code>start</code>.
<ul>
<li>Initialize <code>xorA</code> to 0 (<strong>XOR</strong> value for the subarray from <code>start</code> to <code>mid - 1</code>)</li>
<li>Iterate over each possible middle index <code>mid</code>.
<ul>
<li>Update <code>xorA</code> by <strong>XOR</strong>ing it with <code>arr[mid - 1]</code> (including the element at <code>mid - 1</code> in the <strong>XOR</strong> computation).</li>
<li>Initialize <code>xorB</code> to 0 (<strong>XOR</strong> value for the subarray from <code>mid</code> to <code>end</code>).</li>
<li>Iterate over each possible ending index <code>end</code>, starting from <code>mid</code>.
<ul>
<li>Update <code>xorB</code> by <strong>XOR</strong>ing it with <code>arr[end]</code>.</li>
<li>If we find a valid triplet where the <strong>XOR</strong> of the first subarray is equal to the <strong>XOR</strong> of the second subarray(<code>xorA == xorB</code>), increment the count of valid triplets <code>count</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the final count of valid triplets <code>count</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HbbretW3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>There are three nested loops, each iterating over the entire array, resulting in a time complexity of <span class="math inline">\(O(n \cdot n \cdot n) = O(n^3)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a few variables (<code>count</code>, <code>xorA</code>, <code>xorB</code>) to store intermediate results, which take constant space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-nested-prefix-xor">Approach 2: Nested Prefix <strong>XOR</strong></h3>
<h4 id="intuition-1">Intuition</h4>
<p>To improve the time complexity, we can precompute the prefix <strong>XOR</strong> of the array. The prefix <strong>XOR</strong> at an index <code>i</code> is the <strong>XOR</strong> of all elements from the beginning of the array up to (and including) index <code>i</code>.</p>
<p>First, we create a modified copy of the input array and insert 0 at the beginning to facilitate <strong>XOR</strong> operations. We then perform <strong>XOR</strong> operations on consecutive elements in this modified array, effectively storing the prefix <strong>XOR</strong> at each index.</p>
<p>Next, we iterate through the modified array (<code>prefixXOR</code>), considering each possible pair of indices <code>start</code> and <code>end</code>, where <code>start</code> is less than <code>end</code>. We use the equal <strong>XOR</strong> condition mentioned in the overview. If the prefix <strong>XOR</strong> values at indices <code>start</code> and <code>end</code> are equal, it means the <strong>XOR</strong> of elements between <code>start</code> and <code>end</code> (excluding <code>start</code> and <code>end</code>) is 0. In this case, we increment the result counter by the count of valid triplets that can be formed with <code>start</code> as the start index and <code>end</code> as the end index, which is <code>end - start - 1</code>.</p>
<p>By precomputing the prefix <strong>XOR</strong>, we became a little more efficient in counting the triplets without explicitly iterating over all possible triplets.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Create a modified copy <code>prefixXOR</code> of the input array <code>arr</code> to avoid modifying the original array.</li>
<li>Insert 0 at the beginning of the modified array <code>prefixXOR</code> to handle the case when the <strong>XOR</strong> operation is performed on the first element.</li>
<li>Calculate the prefix <strong>XOR</strong> at each position in <code>prefixXOR</code> so that we can reference the precomputed <strong>XOR</strong> of elements from the beginning up to each index.
<ul>
<li>Iterate over <code>prefixXOR</code> starting from index 1.
<ul>
<li>Update <code>prefixXOR[i]</code> by <strong>XOR</strong>ing it with <code>prefixXOR[i - 1]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>count</code> with 0 to store the count of valid triplets.</li>
<li>Iterate over <code>prefixXOR</code> starting from index 0:
<ul>
<li>Now, iterate over <code>prefixXOR</code> starting from <code>start + 1</code>:
<ul>
<li>If <code>prefixXOR[start] == prefixXOR[end]</code> (found a pair of indices <code>start</code> and <code>end</code> where the <strong>XOR</strong> of elements between them is 0)
<ul>
<li>Increment <code>count</code> by <code>end - start - 1</code> (count of valid triplets with <code>start</code> as start and <code>end</code> as end).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the final count of valid triplets <code>count</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/bVmyuRBY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>There are two nested loops, each iterating over the array, resulting in a time complexity of <span class="math inline">\(O(n \cdot n) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create a new array <code>prefixXOR</code> of the same size as the input array, taking <span class="math inline">\(O(n)\)</span> space.</p>
<blockquote>
<p>Note: This approach could be implemented with <span class="math inline">\(O(1)\)</span> space by modifying the original array.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pass-prefix-xor">Approach 3: Two Pass Prefix <strong>XOR</strong></h3>
<h4 id="intuition-2">Intuition</h4>
<p>Building upon the previous approach, we can further optimize the time complexity to <span class="math inline">\(O(n)\)</span> by using two helper data structures: a map <code>countMap</code> to store the count of each <strong>XOR</strong> value encountered, and a map <code>totalMap</code> to store the total sum of indices for each <strong>XOR</strong> value.</p>
<p>The key observation is that for a given <strong>XOR</strong> value <code>x</code>, the contribution of <code>x</code> to the result is the count of occurrences of <code>x</code> multiplied by the number of valid triplets that can be formed with <code>x</code> as the middle <strong>XOR</strong> value. The number of valid triplets can be calculated as <code>(i - 1) - totalSum</code>, where <code>i</code> is the current index, and <code>totalSum</code> is the sum of indices where <code>x</code> occurred previously.</p>
<p>For example, let's say at index <code>i = 5</code>, the <strong>XOR</strong> value <code>x</code> is <code>6</code>. If <code>6</code> occurred previously at indices <code>1</code> and <code>2</code>, then <code>countMap[6] = 2</code> and <code>totalMap[6] = 3</code> (the sum of indices <code>1 + 2</code>). Now, the number of valid triplets at index <code>i = 5</code> is <code>2 X (5 - 1) - 3 = 2 X 4 - 3 = 5</code>. So, the contribution of <code>6</code> to the total count of valid triplets is <code>5</code>. This calculation is performed for each <strong>XOR</strong> value encountered in the array, and the contributions are added up to find the total count of valid triplets.</p>
<details>
<summary>The 5 valid triplets that can be formed with the XOR value `6` at index `5`, considering the previous indices `1` and `2`, are:
</summary>
â€¢ (2, 3, 5) â€¢ (2, 4, 5) â€¢ (2, 5, 5) â€¢ (3, 4, 5) â€¢ (3, 5, 5)
</details>
&nbsp;
<p>We maintain a map <code>countMap</code> with a key-value pair <code>{0: 1}</code> to handle the case when the <strong>XOR</strong> value is 0. Then, we iterate through the array and consider each index <code>i</code>. For the current index <code>i</code>, we calculate the contribution of the current <strong>XOR</strong> value (<code>prefixXOR[i]</code>) to the result by adding <code>countMap[prefixXOR[i]] * (i - 1) - totalMap[prefixXOR[i]]</code> to the result counter.</p>
<p>How did we develop this approach?</p>
<p>We want to find the count of triplets <span class="math inline">\((i, j, k)\)</span> such that the <strong>XOR</strong> of elements from index <span class="math inline">\(i\)</span> to <span class="math inline">\(j-1\)</span> is equal to the <strong>XOR</strong> of elements from index <span class="math inline">\(j\)</span> to <span class="math inline">\(k\)</span>. Let's call this common <strong>XOR</strong> value <span class="math inline">\(x\)</span>.</p>
<p>Now, consider a specific <strong>XOR</strong> value <span class="math inline">\(x\)</span>. We want to find the contribution of <span class="math inline">\(x\)</span> to the total count of triplets. To do this, we need to know two things:</p>
<ol>
<li>The count of occurrences of <span class="math inline">\(x\)</span> in the <code>prefixXOR</code> array. Let's call this <span class="math inline">\(countX\)</span>.</li>
<li>The number of valid triplets that can be formed with <span class="math inline">\(x\)</span> as the middle <strong>XOR</strong> value.</li>
</ol>
<p>For the second part, let's think about what it means for <span class="math inline">\(x\)</span> to be the middle <strong>XOR</strong> value in a triplet <span class="math inline">\((i, j, k)\)</span>. It means that the <strong>XOR</strong> of elements from index <span class="math inline">\(i\)</span> to <span class="math inline">\(j-1\)</span> is <span class="math inline">\(x\)</span>, and the <strong>XOR</strong> of elements from index <span class="math inline">\(j\)</span> to <span class="math inline">\(k\)</span> is also <span class="math inline">\(x\)</span>.</p>
<p>Now, let's choose a specific starting index <span class="math inline">\(i\)</span>. We want to find the number of valid triplets that can be formed with this starting index <span class="math inline">\(i\)</span> and <span class="math inline">\(x\)</span> as the middle <strong>XOR</strong> value. To do this, we need to find the number of possible ending indices <span class="math inline">\(k\)</span> such that the XOR of elements from index <span class="math inline">\(j\)</span> to <span class="math inline">\(k\)</span> is <span class="math inline">\(x\)</span>, where <span class="math inline">\(j\)</span> is the index just after <span class="math inline">\(i\)</span>.</p>
<p>Here's the key observation: if we know the indices where <span class="math inline">\(x\)</span> has occurred previously, we can calculate the number of valid triplets with <span class="math inline">\(i\)</span> as the starting index and <span class="math inline">\(x\)</span> as the middle <strong>XOR</strong> value.</p>
<p>Let's say <span class="math inline">\(x\)</span> has occurred at indices <span class="math inline">\(idx_1\)</span>, <span class="math inline">\(idx_2\)</span>, <span class="math inline">\(idx_3\)</span>, ..., <span class="math inline">\(idx_m\)</span> before the current index <span class="math inline">\(i\)</span>. Then, the number of valid triplets with <span class="math inline">\(i\)</span> as the starting index and <span class="math inline">\(x\)</span> as the middle <strong>XOR</strong> value is:</p>
<p><span class="math inline">\((i - 1) - (idx_1 + idx_2 + ... + idx_m)\)</span></p>
<p>Here's why:</p>
<ul>
<li><span class="math inline">\((i - 1)\)</span> represents the number of possible middle indices <span class="math inline">\(j\)</span> (since <span class="math inline">\(j\)</span> is just after <span class="math inline">\(i\)</span>).</li>
<li><span class="math inline">\(idx_1 + idx_2 + ... + idx_m\)</span> represents the sum of indices where <span class="math inline">\(x\)</span> has occurred previously.</li>
<li>Subtracting this sum from <span class="math inline">\((i - 1)\)</span> gives us the number of valid triplets, because we need to exclude the cases where the middle <strong>XOR</strong> value is <span class="math inline">\(x\)</span>, but the ending <strong>XOR</strong> value is not <span class="math inline">\(x\)</span>.</li>
</ul>
<p>So, the contribution of <span class="math inline">\(x\)</span> to the total count of triplets is:</p>
<p><span class="math inline">\(countX \times (i - 1) - (idx_1 + idx_2 + ... + idx_m)\)</span></p>
<p>This is exactly what the key observation states. By maintaining the count of occurrences of each <strong>XOR</strong> value (<span class="math inline">\(countX\)</span>) and the sum of indices where each <strong>XOR</strong> value has occurred (<span class="math inline">\(totalSum = idx_1 + idx_2 + ... + idx_m\)</span>), we can efficiently calculate the contribution of each <strong>XOR</strong> value to the total count of triplets.</p>
<p>After calculating the contribution, we increment <code>countMap[prefixXOR[i]]</code> to count the occurrences of the current <strong>XOR</strong> value. We also update <code>totalMap[prefixXOR[i]]</code> by adding <code>i</code> to keep track of the total sum of indices for the current <strong>XOR</strong> value.</p>
<p>In summary, we preprocess the array by inserting a 0 at the beginning and computing the prefix <strong>XOR</strong>. Next, we initialize maps to store counts and totals of <strong>XOR</strong> values encountered during the iteration. While iterating through the array, we calculate the contribution of each element to the result count and update the count and total of each <strong>XOR</strong> value encountered. Finally, we return the total count of valid triplets found.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Create a modified copy <code>prefixXOR</code> of the input array <code>arr</code> to avoid modifying the original array.</li>
<li>Insert 0 at the beginning of the modified array <code>prefixXOR</code> to handle the case when the <strong>XOR</strong> operation is performed on the first element.</li>
<li>Calculate the prefix <strong>XOR</strong> of <code>prefixXOR</code> to precompute the <strong>XOR</strong> of elements from the beginning up to each index.
<ul>
<li>Iterate over <code>prefixXOR</code> starting from index 1:
<ul>
<li>Update <code>prefixXOR[i]</code> by <strong>XOR</strong>ing it with <code>prefixXOR[i - 1]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>count</code> with 0 to store the count of valid triplets.</li>
<li>Initialize <code>countMap</code> with <code>{0: 1}</code> to store the count of occurrences of each <strong>XOR</strong> value, initialized with the count of 0 as 1.</li>
<li>Initialize <code>totalMap</code> as an empty map to store the sum of indices where each <strong>XOR</strong> value has occurred.</li>
<li>Iterate over <code>prefixXOR</code>:
<ul>
<li>Calculate the contribution of <code>prefixXOR[i]</code> to <code>count</code> using <code>countMap[prefixXOR[i]]</code> and <code>totalMap[prefixXOR[i]]</code> (based on the count and sum of indices for the current <strong>XOR</strong> value).
<ul>
<li>Update <code>count</code> with the contribution.</li>
</ul>
</li>
<li>Increment <code>countMap[prefixXOR[i]]</code> by updating the count of the current <strong>XOR</strong> value.</li>
<li>Update <code>totalMap[prefixXOR[i]]</code> by adding <code>i</code> to update the sum of indices for the current <strong>XOR</strong> value.</li>
</ul>
</li>
<li>Return the final count of valid triplets <code>count</code>.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1442/approach3.json:975,587!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ihEyhKAi/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>There are two different loops iterating over the array, resulting in a time complexity of <span class="math inline">\(O(2 \cdot n)\)</span>, which can be simplified to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, each element in the array can have a unique <strong>XOR</strong> value, requiring <span class="math inline">\(O(n)\)</span> space to store the counts and totals in the maps.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-one-pass-prefix-xor">Approach 4: One Pass Prefix <strong>XOR</strong></h3>
<h4 id="intuition-3">Intuition</h4>
<p>This approach is a slight variation of the previous one. The main difference is that it combines the prefix <strong>XOR</strong> computation and result calculation in a single pass through the array, whereas the third approach performs these steps separately.</p>
<p>Here we eliminate the need for a separate prefix <strong>XOR</strong> precomputation step. Instead, we maintain a running prefix variable that stores the <strong>XOR</strong> of elements up to the current index. We update this prefix variable as we iterate through the array by <strong>XOR</strong>ing it with the current element: <code>prefix ^= arr[i]</code></p>
<p>By maintaining this running prefix, we can calculate the contribution of the current <strong>XOR</strong> value (prefix) to the result on the fly, without the need for precomputed prefix <strong>XOR</strong> values.</p>
<p>The formula for calculating the contribution remains the same as in the third approach: <code>count += countMap[prefix] * i - totalSum[prefix]</code><br />
The difference is that we use the running prefix value instead of a precomputed prefix <strong>XOR</strong> array.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>count</code> with 0 to store the count of valid triplets.</li>
<li>Initialize <code>prefix</code> with 0 to store the running <strong>XOR</strong> value.</li>
<li>Initialize <code>countMap</code> with <code>{0: 1}</code> to store the count of occurrences of each <strong>XOR</strong> value, initialized with 0 count as 1.</li>
<li>Initialize <code>totalMap</code> as an empty map to store the sum of indices where each <strong>XOR</strong> value has occurred.</li>
<li>Iterate over <code>arr</code>:
<ul>
<li>Update <code>prefix</code> by <strong>XOR</strong>ing it with <code>arr[i]</code> (the running <strong>XOR</strong> value).</li>
<li>Calculate the contribution of <code>prefix</code> to <code>count</code> using <code>countMap[prefix]</code> and <code>totalMap[prefix]</code> (based on the count and sum of indices for the current <strong>XOR</strong> value).
<ul>
<li>Update <code>count</code> with the contribution.</li>
</ul>
</li>
<li>Increment <code>countMap[prefix]</code> by updating the count of the current <strong>XOR</strong> value.</li>
<li>Update <code>totalMap[prefix]</code> by adding <code>i + 1</code> to update the sum of indices for the current <strong>XOR</strong> value.</li>
</ul>
</li>
<li>Return the final count of valid triplets <code>count</code>.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/gZcVdfhV/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>There is only a single loop iterating over the array, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, each element in the array can have a unique <strong>XOR</strong> value, requiring <span class="math inline">\(O(n)\)</span> space to store the counts and totals in the maps.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-vowel-strings-in-ranges/description" target="_blank" rel="noopener noreferrer">Count Vowel Strings in Ranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of strings <code>words</code> and a 2D array of integers <code>queries</code>.</p>

<p>Each query <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> asks us to find the number of strings present at the indices ranging from <code>l<sub>i</sub></code> to <code>r<sub>i</sub></code> (both <strong>inclusive</strong>) of <code>words</code> that start and end with a vowel.</p>

<p>Return <em>an array </em><code>ans</code><em> of size </em><code>queries.length</code><em>, where </em><code>ans[i]</code><em> is the answer to the </em><code>i</code><sup>th</sup><em> query</em>.</p>

<p><strong>Note</strong> that the vowel letters are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;aba&quot;,&quot;bcb&quot;,&quot;ece&quot;,&quot;aa&quot;,&quot;e&quot;], queries = [[0,2],[1,4],[1,1]]
<strong>Output:</strong> [2,3,0]
<strong>Explanation:</strong> The strings starting and ending with a vowel are &quot;aba&quot;, &quot;ece&quot;, &quot;aa&quot; and &quot;e&quot;.
The answer to the query [0,2] is 2 (strings &quot;aba&quot; and &quot;ece&quot;).
to query [1,4] is 3 (strings &quot;ece&quot;, &quot;aa&quot;, &quot;e&quot;).
to query [1,1] is 0.
We return [2,3,0].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;], queries = [[0,2],[0,1],[2,2]]
<strong>Output:</strong> [3,2,1]
<strong>Explanation:</strong> Every string satisfies the conditions, so we return [3,2,1].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 40</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>sum(words[i].length) &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;&nbsp;words.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D <code>queries</code> array where each query specifies a range <code>[l, r]</code> (inclusive). For each query, we need to count how many strings in the <code>words</code> array start and end with a vowel and have an index within the specified range. These strings are referred to as &quot;vowel strings.&quot; In other words, for each query, we need to count the number of vowel strings within the subarray <code>words[l:r]</code>.</p>
<p>We will go through a solution that can perform this count efficiently for all queries.</p>
<h3 id="approach-prefix-sum">Approach: Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute force approach to calculate the answer for each query <code>[l, r]</code> would involve iterating through the subarray <code>words[l:r]</code> and counting how many vowel strings we find. We can use a set to containing all vowels (<code>a, e, i, o, u</code>) to quickly check if a string is a vowel string in constant time, <span class="math inline">\(O(1)\)</span>.</p>
<p>However, this approach is slow as it requires us to iterate through a portion of <code>words</code> for every query. If many queries contain a long range, this will be an expensive operation. Furthermore, a lot of work is repeated since many elements will be visited many times across queries.</p>
<p>For a more optimized approach, we can first perform some precomputations on <code>words</code>. Specifically, we can create a prefix sum array <code>prefixSum</code> to store the cumulative counts of vowel strings in <code>words</code>. <code>prefixSum[i]</code> would contain the total number of vowel strings from the first element of the array up to index <code>i</code> (the prefix array <code>words[0:i]</code>). Populating this <code>prefixSum</code> array would only take one linear scan across <code>words</code> as we maintain a cumulative sum while iterating through <code>words</code>.</p>
<p>Having this <code>prefixSum</code> array will allow us to answer each query very quickly. The key insight here is that the number of vowel strings that fall between a query range <code>[l, r]</code> can be found by subtracting the cumulative sum up to index <code>l-1</code> from the cumulative sum up to index <code>r</code>: <code>prefixSum[r] - prefixSum[l - 1]</code>.</p>
<h5 id="why-subtract-prefixsuml---1">Why subtract <code>prefixSum[l - 1]</code>?</h5>
<p>Note that we look at the lower boundary <code>l - 1</code> instead of <code>l</code> because the range is inclusive. The prefix sum array represents the cumulative count of vowel strings up to each index. By subtracting <code>prefixSum[l - 1]</code>, we ignore all the vowel strings that have appeared before index <code>l</code> in our count and include only those within the range <code>[l, r]</code>.</p>
<p>Let's look at an example:</p>
<ul>
<li>We have <code>prefixSum = [0, 1, 2, 2, 3, 3, 4]</code>.</li>
<li>Our query range is <code>[1, 5]</code>.</li>
</ul>
<p>Taking a look at <code>prefixSum</code>:</p>
<ul>
<li>The total number of vowel strings right before the start of the range is <code>prefixSum[0] = 0</code></li>
<li>The total number of vowel strings right at the end of the range (index 5) is <code>prefixSum[5] = 3</code>.</li>
</ul>
<p>This then means that <code>prefixSum[5] - prefixSum[0]</code> will give us the number of vowel strings that have appeared in the range <code>[1, 5]</code>, yielding an answer of 3 vowel strings.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Declare our answer array <code>ans</code>.</li>
<li>Initialize our set of vowels <code>vowels</code> to contain the vowel list <code>[a, e, i, o, u]</code>.</li>
<li>Declare our prefix sum array <code>prefixSum</code> to store the cumulative sum of vowel words up to each index.</li>
<li>To fill in <code>prefixSum</code>, loop through each word in <code>words</code>:
<ul>
<li>For each word, check if the first and last letter of <code>word</code> is in <code>vowels</code>. If so, we have found a new vowel string so we increment <code>sum++</code>.</li>
<li>Fill in the prefix count: <code>prefixSum[i] = sum</code></li>
</ul>
</li>
<li>Loop through each query in <code>queries</code>:<br />
- Check if the left bound <code>queries[i][0]</code> is 0. If it is, then the answer is simply the cumulative count of vowel strings up to index <code>i</code>: <code>ans[i] = prefixSum[queries[i][1]]</code><br />
- Otherwise, <code>ans[i] = prefixSum[queries[i][1]] - prefixSum[queries[i][0] - 1]</code></li>
<li>Return answer array <code>ans</code> containing answers for all queries.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CRegyC38/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>words</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>Calculating <code>prefixSum</code> array involves iterating through <code>words</code> once, which takes <span class="math inline">\(O(M)\)</span> time. Answering each query takes <span class="math inline">\(O(1)\)</span> time, which means answering all queries takes <span class="math inline">\(O(N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(M + N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>Our only auxiliary data structure is the <code>prefixSum</code> array, which has size <span class="math inline">\(M\)</span>, so the total space complexity is <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delivering-boxes-from-storage-to-ports/description" target="_blank" rel="noopener noreferrer">Delivering Boxes from Storage to Ports</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a <strong>limit</strong> on the <strong>number of boxes</strong> and the <strong>total weight</strong> that it can carry.</p>

<p>You are given an array <code>boxes</code>, where <code>boxes[i] = [ports<sub>â€‹â€‹i</sub>â€‹, weight<sub>i</sub>]</code>, and three integers <code>portsCount</code>, <code>maxBoxes</code>, and <code>maxWeight</code>.</p>

<ul>
	<li><code>ports<sub>â€‹â€‹i</sub></code> is the port where you need to deliver the <code>i<sup>th</sup></code> box and <code>weights<sub>i</sub></code> is the weight of the <code>i<sup>th</sup></code> box.</li>
	<li><code>portsCount</code> is the number of ports.</li>
	<li><code>maxBoxes</code> and <code>maxWeight</code> are the respective box and weight limits of the ship.</li>
</ul>

<p>The boxes need to be delivered <strong>in the order they are given</strong>. The ship will follow these steps:</p>

<ul>
	<li>The ship will take some number of boxes from the <code>boxes</code> queue, not violating the <code>maxBoxes</code> and <code>maxWeight</code> constraints.</li>
	<li>For each loaded box <strong>in order</strong>, the ship will make a <strong>trip</strong> to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no <strong>trip</strong> is needed, and the box can immediately be delivered.</li>
	<li>The ship then makes a return <strong>trip</strong> to storage to take more boxes from the queue.</li>
</ul>

<p>The ship must end at storage after all the boxes have been delivered.</p>

<p>Return <em>the <strong>minimum</strong> number of <strong>trips</strong> the ship needs to make to deliver all boxes to their respective ports.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal strategy is as follows: 
- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.
So the total number of trips is 4.
Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> The optimal strategy is as follows: 
- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.
- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.
- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
<strong>Output:</strong> 6
<strong>Explanation:</strong> The optimal strategy is as follows:
- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.
- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.
- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= ports<sub>â€‹â€‹i</sub> &lt;= portsCount</code></li>
	<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/describe-the-painting/description" target="_blank" rel="noopener noreferrer">Describe the Painting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a <strong>unique</strong> color. You are given a 2D integer array <code>segments</code>, where <code>segments[i] = [start<sub>i</sub>, end<sub>i</sub>, color<sub>i</sub>]</code> represents the <strong>half-closed segment</strong> <code>[start<sub>i</sub>, end<sub>i</sub>)</code> with <code>color<sub>i</sub></code> as the color.</p>

<p>The colors in the overlapping segments of the painting were <strong>mixed</strong> when it was painted. When two or more colors mix, they form a new color that can be represented as a <strong>set</strong> of mixed colors.</p>

<ul>
	<li>For example, if colors <code>2</code>, <code>4</code>, and <code>6</code> are mixed, then the resulting mixed color is <code>{2,4,6}</code>.</li>
</ul>

<p>For the sake of simplicity, you should only output the <strong>sum</strong> of the elements in the set rather than the full set.</p>

<p>You want to <strong>describe</strong> the painting with the <strong>minimum</strong> number of non-overlapping <strong>half-closed segments</strong> of these mixed colors. These segments can be represented by the 2D array <code>painting</code> where <code>painting[j] = [left<sub>j</sub>, right<sub>j</sub>, mix<sub>j</sub>]</code> describes a <strong>half-closed segment</strong> <code>[left<sub>j</sub>, right<sub>j</sub>)</code> with the mixed color <strong>sum</strong> of <code>mix<sub>j</sub></code>.</p>

<ul>
	<li>For example, the painting created with <code>segments = [[1,4,5],[1,7,7]]</code> can be described by <code>painting = [[1,4,12],[4,7,7]]</code> because:

	<ul>
		<li><code>[1,4)</code> is colored <code>{5,7}</code> (with a sum of <code>12</code>) from both the first and second segments.</li>
		<li><code>[4,7)</code> is colored <code>{7}</code> from only the second segment.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the 2D array </em><code>painting</code><em> describing the finished painting (excluding any parts that are <strong>not </strong>painted). You may return the segments in <strong>any order</strong></em>.</p>

<p>A <strong>half-closed segment</strong> <code>[a, b)</code> is the section of the number line between points <code>a</code> and <code>b</code> <strong>including</strong> point <code>a</code> and <strong>not including</strong> point <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/18/1.png" style="width: 529px; height: 241px;" />
<pre>
<strong>Input:</strong> segments = [[1,4,5],[4,7,7],[1,7,9]]
<strong>Output:</strong> [[1,4,14],[4,7,16]]
<strong>Explanation: </strong>The painting can be described as follows:
- [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.
- [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/18/2.png" style="width: 532px; height: 219px;" />
<pre>
<strong>Input:</strong> segments = [[1,7,9],[6,8,15],[8,10,7]]
<strong>Output:</strong> [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
<strong>Explanation: </strong>The painting can be described as follows:
- [1,6) is colored 9 from the first segment.
- [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.
- [7,8) is colored 15 from the second segment.
- [8,10) is colored 7 from the third segment.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/04/c1.png" style="width: 529px; height: 289px;" />
<pre>
<strong>Input:</strong> segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
<strong>Output:</strong> [[1,4,12],[4,7,12]]
<strong>Explanation: </strong>The painting can be described as follows:
- [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.
- [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.
Note that returning a single segment [1,7) is incorrect because the mixed color sets are different.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= segments.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>segments[i].length == 3</code></li>
	<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= color<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li>Each <code>color<sub>i</sub></code> is distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/description" target="_blank" rel="noopener noreferrer">Divide Intervals Into Minimum Number of Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>intervals</code> where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> represents the <strong>inclusive</strong> interval <code>[left<sub>i</sub>, right<sub>i</sub>]</code>.</p>

<p>You have to divide the intervals into one or more <strong>groups</strong> such that each interval is in <strong>exactly</strong> one group, and no two intervals that are in the same group <strong>intersect</strong> each other.</p>

<p>Return <em>the <strong>minimum</strong> number of groups you need to make</em>.</p>

<p>Two intervals <strong>intersect</strong> if there is at least one common number between them. For example, the intervals <code>[1, 5]</code> and <code>[5, 8]</code> intersect.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can divide the intervals into the following groups:
- Group 1: [1, 5], [6, 8].
- Group 2: [2, 3], [5, 10].
- Group 3: [1, 10].
It can be proven that it is not possible to divide the intervals into fewer than 3 groups.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,3],[5,6],[8,10],[11,13]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> None of the intervals overlap, so we can put all of them in one group.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting-or-priority-queue">Approach 1: Sorting or Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem is very similar to  <a href="https://leetcode.com/problems/meeting-rooms-ii/solution/">Meeting Rooms II</a>, and thus the solutions are alike. The problem provides <span class="math inline">\(N\)</span> intervals in the form <code>[start, end]</code>, where both start and end are inclusive. Our goal is to divide the intervals into multiple groups such that each interval belongs to exactly one group and no intervals within the same group overlap. We need to minimize the number of groups created.</p>
<p>Intervals that share a common number must be placed in different groups. For example, given the intervals <code>[3, 7], [5, 6], and [1, 8]</code>, all of these intervals overlap between <code>5</code> and <code>6</code>. Therefore, they must be placed in separate groups. In this case, we would need three groups to ensure no two intervals in the same group overlap.</p>
<p>We can generalize this by stating that if there are <span class="math inline">\(K\)</span> overlapping intervals, we need at least <span class="math inline">\(K\)</span> groups to separate them. Some intervals may not overlap with one or more intervals within the <span class="math inline">\(K\)</span> overlapping ones, and they can be placed into any group where there is no conflict. For example, consider adding two more intervals, <code>[10, 12]</code> and <code>[2, 3]</code>, to the previous set. Despite having five intervals now, we still need only three groups. A valid grouping could be:</p>
<ul>
<li>Group 1: <code>[1, 8], [10, 12]</code></li>
<li>Group 2: <code>[3, 7]</code></li>
<li>Group 3: <code>[5, 6], [2, 3]</code></li>
</ul>
<p>The core of the problem is determining the maximum number of overlapping intervals at any given point. These overlapping intervals define the minimum number of groups required. Once we find the number of intervals that overlap at the same point, we can allocate non-overlapping intervals into existing groups.</p>
<p>To find the maximum number of overlapping intervals, we need to determine how many intervals cover each point in the range. For each interval <code>[start, end]</code>, all numbers between start and end (inclusive) belong to that interval. Then by iterating over each number, we can find out the maximum number of intervals any number has. An interval <code>[start, end]</code> represents that there is an interval for each number between <code>start</code> and <code>end</code> inclusive. Similar to the <a href="https://leetcode.com/problems/meeting-rooms-ii/solution/">Meeting Rooms II</a> solution, we will need to find the number of intervals at each number using the prefix sum. We will mark <code>1</code> at each <code>start</code> point denoting that an interval starts here and mark <code>-1</code> at each of the <code>end + 1</code> points denoting that an interval ends here (as <code>end</code> is inclusive).</p>
<p>To do this efficiently, we can use either a priority queue or a list with sorting. This approach uses the second one where we will create two events for each interval as <code>{start, 1}</code> and <code>{end + 1, -1}</code>  denoting the start and end of an interval. We can then sort this list in ascending order of the point and then by the value. The prefix sum of this list will provide the number of overlapping intervals in each point and we can also track the maximum sum we have achieved so far. This maximum sum can be returned as the minimum number of groups required.</p>
<p><img src="../Figures/2406/2406A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Convert Intervals to Events:
<ul>
<li>For each interval <code>[start, end]</code>, create two events:
<ul>
<li>A start event at <code>start</code> with a value of <code>+1</code> (indicating an interval is starting).</li>
<li>An end event at <code>end + 1</code> with a value of <code>-1</code> (indicating an interval is ending just after right).</li>
</ul>
</li>
</ul>
</li>
<li>Sort Events:
<ul>
<li>Sort the events based on the time (first element of the pair).</li>
<li>If two events occur at the same time, process them in the order of their values (+1 first, -1 second). This ensures correct overlap counting.</li>
</ul>
</li>
<li>Find the prefix sum:
<ul>
<li>Initialize <code>concurrentIntervals</code> to 0. This will track the number of intervals active at any point in time.</li>
<li>Traverse the sorted events:
<ul>
<li>For each event, update <code>concurrentIntervals</code> by adding the value of the event (+1 for start, -1 for end).</li>
<li>Track the maximum value of <code>concurrentIntervals</code> as <code>maxConcurrentIntervals</code> which represents the maximum number of overlapping intervals.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxConcurrentIntervals</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8Qwp7cnE/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>We create two events for each interval, hence the number of events is <span class="math inline">\(2 *N\)</span>. Then we sort these events, which will take <span class="math inline">\(O(N \log N)\)</span>. To find the prefix sum, we iterated over each event to find the maximum sum. Hence, the total time complexity is <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will store the <code>start</code> and <code>end</code> numbers along with an integer to denote the start or end of an interval. For <span class="math inline">\(N\)</span> intervals there will be <span class="math inline">\(2* N\)</span> events. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep-algorithm-with-ordered-container">Approach 2: Line Sweep Algorithm With Ordered Container</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach is similar to the previous one but uses a method called the Line Sweep algorithm. It's useful for solving problems involving intervals.</p>
<p>The Line Sweep algorithm tracks when intervals start and end. For each interval <code>(start, end)</code>, we mark the start by increasing the count at <code>start</code> by <code>1</code> (indicating a new interval starts), and we mark the point <code>end + 1</code> by decreasing its count by <code>1</code> (indicating an interval ends). These changes are stored in a map, which keeps track of how many intervals start or end at each point.</p>
<p>After processing all the intervals, we calculate a running total (prefix sum) over the map. This running total shows how many intervals are active at any given point. The highest value of this total tells us the minimum number of groups needed to avoid overlap.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an ordered map (<code>pointToCount</code>) to track the count of intervals starting or ending at a point.</li>
<li>Populate the map:
<ul>
<li>For each interval <code>[start, end]</code>, increment <code>pointToCount[start]</code> by <code>1</code>.</li>
<li>Decrement <code>pointToCount[end + 1]</code> by <code>1</code>.</li>
</ul>
</li>
<li>Iterate over the sorted entries of the map (automatically sorted by key).
<ul>
<li>Traverse the sorted map, and add the value to <code>concurrentIntervals</code>.</li>
<li>Track the maximum number of overlapping intervals in <code>maxConcurrentIntervals</code>.</li>
</ul>
</li>
<li>Return <code>maxConcurrentIntervals</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/h5VK4QoK/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>We insert the intervals into an ordered map in which insertion takes <span class="math inline">\(O(\log N)\)</span> time, and hence for <span class="math inline">\(N\)</span> insertion the time required would be <span class="math inline">\(O(N \log N)\)</span>. Then we iterate over the <span class="math inline">\(2* N\)</span> entries in the map and find the value for <code>maxConcurrentIntervals</code>. Therefore the total time complexity is equal to  <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will store the <code>start</code> and <code>end</code> numbers along with an integer to denote the start or end of an interval in the map. For <span class="math inline">\(N\)</span> intervals there will be <span class="math inline">\(2* N\)</span> events. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-line-sweep-algorithm-without-ordered-container">Approach 3: Line Sweep Algorithm Without Ordered Container</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The core idea of this approach is the same as the previous one. However, instead of using an ordered map to keep track of interval start and end points, we employ a list or vector to store the counts of intervals starting or ending at each point. Once all intervals have been processed, we avoid sorting the list as done in the earlier approach. Instead, we apply a counting sort technique to efficiently compute the prefix sum.</p>
<p>First, we determine the smallest starting point (<code>rangeStart</code>) and the largest ending point (<code>rangeEnd</code>) across all intervals. These values define the range for our counting sort. We then iterate from <code>rangeStart</code> to <code>rangeEnd</code>, updating the list by adding interval counts, similar to the previous approach, while keeping track of the maximum number of overlapping intervals at any point in the variable <code>maxConcurrentIntervals</code>.</p>
<p>This approach offers a potential advantage over the previous method, particularly in cases where the number of intervals is large but the range of those intervals is relatively small. The time complexity of this approach depends on the interval range rather than the number of intervals, making it more efficient when the value range of the intervals is limited.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Iterate through the intervals to determine the minimum (<code>rangeStart</code>) and maximum (<code>rangeEnd</code>) points.</li>
<li>Create an array <code>pointToCount</code> of size <code>rangeEnd + 2</code> initialized to zero.</li>
<li>Iterate over the intervals:
<ul>
<li>For each interval <code>[start, end]</code>, increment <code>pointToCount[start</code>] to indicate the start of an interval.</li>
<li>Decrement <code>pointToCount[end + 1]</code> to mark the point where the interval ends.</li>
</ul>
</li>
<li>Loop from <code>rangeStart</code> to <code>rangeEnd</code> and maintain a running sum <code>concurrentIntervals</code> of active intervals. Track the maximum number of concurrent intervals as <code>maxConcurrentIntervals</code></li>
<li>Return <code>maxConcurrentIntervals</code></li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/N9ZPeQo4/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals, and <span class="math inline">\(K\)</span> are the numbers between <code>rangeStart</code> and <code>rangeEnd</code></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + K)\)</span></p>
<p>We iterate over the <span class="math inline">\(N\)</span> intervals to find the value of <code>rangeStart</code> and <code>rangeEnd</code>. We again iterated over the intervals to mark the points in the list <code>pointToCount</code>. Then we iterate over the <span class="math inline">\(K\)</span> numbers between <code>rangeStart</code> and <code>rangeEnd</code> to find the <code>maxConcurrentIntervals</code>. Hence the total time complexity is equal to <span class="math inline">\(O(N + K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(K)\)</span></p>
<p>The size of the array <code>pointToCount</code> is <span class="math inline">\(O(K)\)</span> which is the only space requirement. Hence the space complexity is equal to <span class="math inline">\(O(K)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-sum-grid-partition-i/description" target="_blank" rel="noopener noreferrer">Equal Sum Grid Partition I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> of positive integers. Your task is to determine if it is possible to make <strong>either one horizontal or one vertical cut</strong> on the grid such that:</p>

<ul>
	<li>Each of the two resulting sections formed by the cut is <strong>non-empty</strong>.</li>
	<li>The sum of the elements in both sections is <strong>equal</strong>.</li>
</ul>

<p>Return <code>true</code> if such a partition exists; otherwise return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.png" style="width: 200px;" /><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.jpeg" style="width: 200px; height: 200px;" /></p>

<p>A horizontal cut between row 0 and row 1 results in two non-empty sections, each with a sum of 5. Thus, the answer is <code>true</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>No horizontal or vertical cut results in two non-empty sections with equal sums. Thus, the answer is <code>false</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= n == grid[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-sum-grid-partition-ii/description" target="_blank" rel="noopener noreferrer">Equal Sum Grid Partition II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> of positive integers. Your task is to determine if it is possible to make <strong>either one horizontal or one vertical cut</strong> on the grid such that:</p>

<ul>
	<li>Each of the two resulting sections formed by the cut is <strong>non-empty</strong>.</li>
	<li>The sum of elements in both sections is <b>equal</b>, or can be made equal by discounting <strong>at most</strong> one single cell in total (from either section).</li>
	<li>If a cell is discounted, the rest of the section must <strong>remain connected</strong>.</li>
</ul>

<p>Return <code>true</code> if such a partition exists; otherwise, return <code>false</code>.</p>

<p><strong>Note:</strong> A section is <strong>connected</strong> if every cell in it can be reached from any other cell by moving up, down, left, or right through other cells in the section.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.jpeg" style="height: 180px; width: 180px;" /></p>

<ul>
	<li>A horizontal cut after the first row gives sums <code>1 + 4 = 5</code> and <code>2 + 3 = 5</code>, which are equal. Thus, the answer is <code>true</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/01/chatgpt-image-apr-1-2025-at-05_28_12-pm.png" style="height: 180px; width: 180px;" /></p>

<ul>
	<li>A vertical cut after the first column gives sums <code>1 + 3 = 4</code> and <code>2 + 4 = 6</code>.</li>
	<li>By discounting 2 from the right section (<code>6 - 2 = 4</code>), both sections have equal sums and remain connected. Thus, the answer is <code>true</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,4],[2,3,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2025/04/01/chatgpt-image-apr-2-2025-at-02_50_29-am.png" style="height: 180px; width: 180px;" /></strong></p>

<ul>
	<li>A horizontal cut after the first row gives <code>1 + 2 + 4 = 7</code> and <code>2 + 3 + 5 = 10</code>.</li>
	<li>By discounting 3 from the bottom section (<code>10 - 3 = 7</code>), both sections have equal sums, but they do not remain connected as it splits the bottom section into two parts (<code>[2]</code> and <code>[5]</code>). Thus, the answer is <code>false</code>.</li>
</ul>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[4,1,8],[3,2,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>No valid cut exists, so the answer is <code>false</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= n == grid[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-good-indices/description" target="_blank" rel="noopener noreferrer">Find All Good Indices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> and a positive integer <code>k</code>.</p>

<p>We call an index <code>i</code> in the range <code>k &lt;= i &lt; n - k</code> <strong>good</strong> if the following conditions are satisfied:</p>

<ul>
	<li>The <code>k</code> elements that are just <strong>before</strong> the index <code>i</code> are in <strong>non-increasing</strong> order.</li>
	<li>The <code>k</code> elements that are just <strong>after</strong> the index <code>i</code> are in <strong>non-decreasing</strong> order.</li>
</ul>

<p>Return <em>an array of all good indices sorted in <strong>increasing</strong> order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,1,1,3,4,1], k = 2
<strong>Output:</strong> [2,3]
<strong>Explanation:</strong> There are two good indices in the array:
- Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order.
- Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order.
Note that the index 4 is not good because [4,1] is not non-decreasing.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,1,2], k = 2
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no good indices in this array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n / 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-possible-stable-binary-arrays-i/description" target="_blank" rel="noopener noreferrer">Find All Possible Stable Binary Arrays I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given 3 positive integers <code>zero</code>, <code>one</code>, and <code>limit</code>.</p>

<p>A <span data-keyword="binary-array">binary array</span> <code>arr</code> is called <strong>stable</strong> if:</p>

<ul>
	<li>The number of occurrences of 0 in <code>arr</code> is <strong>exactly </strong><code>zero</code>.</li>
	<li>The number of occurrences of 1 in <code>arr</code> is <strong>exactly</strong> <code>one</code>.</li>
	<li>Each <span data-keyword="subarray-nonempty">subarray</span> of <code>arr</code> with a size greater than <code>limit</code> must contain <strong>both </strong>0 and 1.</li>
</ul>

<p>Return the <em>total</em> number of <strong>stable</strong> binary arrays.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 1, one = 1, limit = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The two possible stable binary arrays are <code>[1,0]</code> and <code>[0,1]</code>, as both arrays have a single 0 and a single 1, and no subarray has a length greater than 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 1, one = 2, limit = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible stable binary array is <code>[1,0,1]</code>.</p>

<p>Note that the binary arrays <code>[1,1,0]</code> and <code>[0,1,1]</code> have subarrays of length 2 with identical elements, hence, they are not stable.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 3, one = 3, limit = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong></p>

<p>All the possible stable binary arrays are <code>[0,0,1,0,1,1]</code>, <code>[0,0,1,1,0,1]</code>, <code>[0,1,0,0,1,1]</code>, <code>[0,1,0,1,0,1]</code>, <code>[0,1,0,1,1,0]</code>, <code>[0,1,1,0,0,1]</code>, <code>[0,1,1,0,1,0]</code>, <code>[1,0,0,1,0,1]</code>, <code>[1,0,0,1,1,0]</code>, <code>[1,0,1,0,0,1]</code>, <code>[1,0,1,0,1,0]</code>, <code>[1,0,1,1,0,0]</code>, <code>[1,1,0,0,1,0]</code>, and <code>[1,1,0,1,0,0]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= zero, one, limit &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-possible-stable-binary-arrays-ii/description" target="_blank" rel="noopener noreferrer">Find All Possible Stable Binary Arrays II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given 3 positive integers <code>zero</code>, <code>one</code>, and <code>limit</code>.</p>

<p>A <span data-keyword="binary-array">binary array</span> <code>arr</code> is called <strong>stable</strong> if:</p>

<ul>
	<li>The number of occurrences of 0 in <code>arr</code> is <strong>exactly </strong><code>zero</code>.</li>
	<li>The number of occurrences of 1 in <code>arr</code> is <strong>exactly</strong> <code>one</code>.</li>
	<li>Each <span data-keyword="subarray-nonempty">subarray</span> of <code>arr</code> with a size greater than <code>limit</code> must contain <strong>both </strong>0 and 1.</li>
</ul>

<p>Return the <em>total</em> number of <strong>stable</strong> binary arrays.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 1, one = 1, limit = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The two possible stable binary arrays are <code>[1,0]</code> and <code>[0,1]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 1, one = 2, limit = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible stable binary array is <code>[1,0,1]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">zero = 3, one = 3, limit = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong></p>

<p>All the possible stable binary arrays are <code>[0,0,1,0,1,1]</code>, <code>[0,0,1,1,0,1]</code>, <code>[0,1,0,0,1,1]</code>, <code>[0,1,0,1,0,1]</code>, <code>[0,1,0,1,1,0]</code>, <code>[0,1,1,0,0,1]</code>, <code>[0,1,1,0,1,0]</code>, <code>[1,0,0,1,0,1]</code>, <code>[1,0,0,1,1,0]</code>, <code>[1,0,1,0,0,1]</code>, <code>[1,0,1,0,1,0]</code>, <code>[1,0,1,1,0,0]</code>, <code>[1,1,0,0,1,0]</code>, and <code>[1,1,0,1,0,0]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= zero, one, limit &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-good-days-to-rob-the-bank/description" target="_blank" rel="noopener noreferrer">Find Good Days to Rob the Bank</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You and a gang of thieves are planning on robbing a bank. You are given a <strong>0-indexed</strong> integer array <code>security</code>, where <code>security[i]</code> is the number of guards on duty on the <code>i<sup>th</sup></code> day. The days are numbered starting from <code>0</code>. You are also given an integer <code>time</code>.</p>

<p>The <code>i<sup>th</sup></code> day is a good day to rob the bank if:</p>

<ul>
	<li>There are at least <code>time</code> days before and after the <code>i<sup>th</sup></code> day,</li>
	<li>The number of guards at the bank for the <code>time</code> days <strong>before</strong> <code>i</code> are <strong>non-increasing</strong>, and</li>
	<li>The number of guards at the bank for the <code>time</code> days <strong>after</strong> <code>i</code> are <strong>non-decreasing</strong>.</li>
</ul>

<p>More formally, this means day <code>i</code> is a good day to rob the bank if and only if <code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.</p>

<p>Return <em>a list of <strong>all</strong> days <strong>(0-indexed) </strong>that are good days to rob the bank</em>.<em> The order that the days are returned in does<strong> </strong><strong>not</strong> matter.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> security = [5,3,3,3,5,6,2], time = 2
<strong>Output:</strong> [2,3]
<strong>Explanation:</strong>
On day 2, we have security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4].
On day 3, we have security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5].
No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> security = [1,1,1,1,1], time = 0
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong>
Since time equals 0, every day is a good day to rob the bank, so return every day.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> security = [1,2,3,4,5,6], time = 2
<strong>Output:</strong> []
<strong>Explanation:</strong>
No day has 2 days before it that have a non-increasing number of guards.
Thus, no day is a good day to rob the bank, so return an empty list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= security.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= security[i], time &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-kth-largest-xor-coordinate-value/description" target="_blank" rel="noopener noreferrer">Find Kth Largest XOR Coordinate Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">quickselect</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D <code>matrix</code> of size <code>m x n</code>, consisting of non-negative integers. You are also given an integer <code>k</code>.</p>

<p>The <strong>value</strong> of coordinate <code>(a, b)</code> of the matrix is the XOR of all <code>matrix[i][j]</code> where <code>0 &lt;= i &lt;= a &lt; m</code> and <code>0 &lt;= j &lt;= b &lt; n</code> <strong>(0-indexed)</strong>.</p>

<p>Find the <code>k<sup>th</sup></code> largest value <strong>(1-indexed)</strong> of all the coordinates of <code>matrix</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 1
<strong>Output:</strong> 7
<strong>Explanation:</strong> The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-pivot-index/description" target="_blank" rel="noopener noreferrer">Find Pivot Index</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code>, calculate the <strong>pivot index</strong> of this array.</p>

<p>The <strong>pivot index</strong> is the index where the sum of all the numbers <strong>strictly</strong> to the left of the index is equal to the sum of all the numbers <strong>strictly</strong> to the index&#39;s right.</p>

<p>If the index is on the left edge of the array, then the left sum is <code>0</code> because there are no elements to the left. This also applies to the right edge of the array.</p>

<p>Return <em>the <strong>leftmost pivot index</strong></em>. If no such index exists, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,3,6,5,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong>
There is no index that satisfies the conditions in the problem statement.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as&nbsp;1991:&nbsp;<a href="https://leetcode.com/problems/find-the-middle-index-in-array/" target="_blank">https://leetcode.com/problems/find-the-middle-index-in-array/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-polygon-with-the-largest-perimeter/description" target="_blank" rel="noopener noreferrer">Find Polygon With the Largest Perimeter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code> of length <code>n</code>.</p>

<p>A <strong>polygon</strong> is a closed plane figure that has at least <code>3</code> sides. The <strong>longest side</strong> of a polygon is <strong>smaller</strong> than the sum of its other sides.</p>

<p>Conversely, if you have <code>k</code> (<code>k &gt;= 3</code>) <strong>positive</strong> real numbers <code>a<sub>1</sub></code>, <code>a<sub>2</sub></code>, <code>a<sub>3</sub></code>, ..., <code>a<sub>k</sub></code> where <code>a<sub>1</sub> &lt;= a<sub>2</sub> &lt;= a<sub>3</sub> &lt;= ... &lt;= a<sub>k</sub></code> <strong>and</strong> <code>a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + ... + a<sub>k-1</sub> &gt; a<sub>k</sub></code>, then there <strong>always</strong> exists a polygon with <code>k</code> sides whose lengths are <code>a<sub>1</sub></code>, <code>a<sub>2</sub></code>, <code>a<sub>3</sub></code>, ..., <code>a<sub>k</sub></code>.</p>

<p>The <strong>perimeter</strong> of a polygon is the sum of lengths of its sides.</p>

<p>Return <em>the <strong>largest</strong> possible <strong>perimeter</strong> of a <strong>polygon</strong> whose sides can be formed from</em> <code>nums</code>, <em>or</em> <code>-1</code> <em>if it is not possible to create a polygon</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,5]
<strong>Output:</strong> 15
<strong>Explanation:</strong> The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,12,1,2,5,50,3]
<strong>Output:</strong> 12
<strong>Explanation:</strong> The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
It can be shown that the largest possible perimeter is 12.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,50]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 &gt; 5 + 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem involves finding the largest possible perimeter of a polygon that can be formed using a given array of positive integers, where each integer represents the length of a side of the polygon. The conditions for forming a valid polygon are that it must be a closed plane figure with at least 3 sides, and the length of the longest side must be smaller than the sum of the lengths of the other sides.</p>
<p>In real-life scenarios, this problem can be related to optimization challenges in fields such as manufacturing or construction. For example, in manufacturing, where materials are limited, the problem can be interpreted as finding the most efficient way to use available resources to create a closed structure with a maximal perimeter. The problem highlights the importance of understanding geometric constraints and optimizing resource utilization.</p>
<hr />
<h3 id="approach-sorting">Approach: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem revolves around the construction of polygons from a given array of positive integers. The aim is to determine the largest possible perimeter of a polygon that can be formed using elements from the array and to return -1 if it is not feasible to create a polygon. A polygon, in this context, is defined as a closed plane figure with <strong>at least three sides</strong>, where the length of the longest side is less than the sum of the remaining sides.</p>
<p>To approach this problem intuitively, let's consider the nature of polygons and their side lengths. According to the problem description, a valid polygon consists of sides where the <strong>longest side</strong> is <strong>smaller</strong> than the sum of its other sides.</p>
<blockquote>
<p>Conversely, if you have <code>k (k &gt;= 3)</code> positive real numbers <code>a1, a2, a3, ..., ak</code> where <code>a1 &lt;= a2 &lt;= a3 &lt;= ... &lt;= ak</code> and <code>a1 + a2 + a3 + ... + ak-1 &gt; ak</code>, then there always exists a polygon with <code>k</code> sides whose lengths are <code>a1, a2, a3, ..., ak</code>.</p>
</blockquote>
<p>This concept provides a key insight into how we might construct a valid polygon from the given array of positive integers. The requirement that the largest side must be smaller than the sum of the remaining sides suggests the need to establish an order among the side lengths. In other words, the challenge is to find a systematic way to consider side lengths such that the largest one is positioned last, allowing us to check if it is smaller than the sum of the others.</p>
<p>We can begin by sorting the array, which allows us to consider the elements in ascending order, facilitating a systematic examination of possible side lengths. The sorting operation ensures that we iterate through the array in increasing order of side lengths, so we encounter smaller sides first and the longest side last, which is useful because the longest side should be smaller than the sum of the others.</p>
<p>Now, as we traverse the sorted array, we need to maintain a running sum of the previously encountered elements. This sum represents the cumulative length of the sides that we have already considered. As we move through the array, we evaluate each element in relation to the sum of the previously encountered elements.</p>
<p>The pivotal insight of this algorithm is that if the current element is smaller than the sum of the previous elements, we can form a valid polygon because adding the current element to the sum satisfies the condition that the longest side is smaller than the sum of the others.</p>
<p>Therefore, the algorithm keeps track of the maximum possible perimeter by updating the answer whenever a valid combination of sides is found. This ensures that we always have the largest perimeter encountered so far.</p>
<p>To handle cases where a valid combination of sides to form a polygon is not found, the algorithm initializes the variable <code>ans</code> to -1. The algorithm ensures that if no valid combination is encountered during the iteration through the sorted array, the value of <code>ans</code> remains unchanged. Consequently, upon completion of the loop, the algorithm returns -1, indicating the absence of a feasible polygon with the given array of positive integers.</p>
<p>Based on our current intuition, we can formulate the following solution:</p>
<pre><code>long long largestPerimeter(vector&lt;int&gt;&amp; nums) {
    sort(nums.begin(), nums.end());
    long long previousElementsSum = 0;
    long long ans = -1;
    for (int i = 0; i &lt; nums.size(); i++) {
        if (i &gt;= 2 &amp;&amp; nums[i] &lt; previousElementsSum) {
            ans = nums[i] + previousElementsSum;
        }
        previousElementsSum += nums[i];
    }
    return ans;
}
</code></pre>
<p>The additional check (<code>i &gt;= 2</code>) before updating <code>ans</code> to <code>nums[i]+ previousElementsSum</code> ensures that the polygon under consideration has at least three sides. A closer examination reveals that this condition is, in fact, unnecessary.</p>
<p>The absence of a need to include an additional check for <code>i &gt;= 2</code> in the for loop can be comprehensively understood by considering the initialization of <code>previous_elements_sum</code> and the inherent properties of the sorted array.</p>
<ol>
<li>
<p>On the first iteration, when <code>i = 0</code>, the initial value of <code>previous_elements_sum</code> is set to 0, and the subsequent comparison <code>num &lt; previous_elements_sum</code> evaluates to false, as <code>num</code> is a positive integer. Consequently, the code block within the if statement is bypassed during this iteration.</p>
</li>
<li>
<p>Moving to the second iteration, <code>i = 1</code>, the value of <code>previous_elements_sum</code> assumes the first element of the sorted array (<code>nums[0]</code>). Given that the array is sorted in ascending order, <code>previous_elements_sum</code> is inherently less than or equal to the current element under consideration (<code>num</code>), which is <code>nums[1]</code>. As a result, the condition <code>num &lt; previous_elements_sum</code> remains false during this iteration as well, and the loop proceeds without executing the code block within the if statement.</p>
</li>
</ol>
<p>The sorting of the array and the careful initialization of <code>previous_elements_sum</code> ensure that the condition <code>num &lt; previous_elements_sum</code> is systematically false for the initial iterations of the loop (when <code>i &lt; 2</code>). Therefore, the absence of an extra check for <code>i &gt;= 2</code> is justified, as the logic inherently accounts for the starting points of the loop, streamlining the code without sacrificing correctness.</p>
<p>!?!../Documents/2971/2971-1.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Sort the input array <code>nums</code> in ascending order.</li>
<li>Initialize variables <code>previous_elements_sum</code> to 0 and <code>ans</code> to -1.</li>
<li>Iterate through each element <code>num</code> in the sorted array <code>nums</code>.</li>
<li>Check if the current element <code>num</code> is less than the sum of previous elements. If true, we have encountered a valid combination of sides.</li>
<li>If the current <code>num</code> is a valid side, update <code>ans</code> to the sum of the current <code>num</code> and <code>previous_elements_sum</code>.</li>
<li>Update <code>previous_elements_sum</code> by adding the current element <code>num</code>.</li>
<li>After iterating through all elements, the method returns the largest possible perimeter stored in <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/W2VmDkwJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N\cdot logN)\)</span>. Sorting <code>nums</code> incurs a time complexity of <span class="math inline">\(O(N\cdot logN)\)</span>. Iterating over <code>nums</code> incurs a time complexity of <span class="math inline">\(O(N)\)</span> which can be ignored since <span class="math inline">\(O(N\cdot logN)\)</span> is the dominating term.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span> or <span class="math inline">\(O(\log N)\)</span>. Some extra space is used when we sort an array of size <span class="math inline">\(N\)</span> in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(N)\)</span>.</li>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log N)\)</span>.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log N)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-count-of-monotonic-pairs-i/description" target="_blank" rel="noopener noreferrer">Find the Count of Monotonic Pairs I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code> of length <code>n</code>.</p>

<p>We call a pair of <strong>non-negative</strong> integer arrays <code>(arr1, arr2)</code> <strong>monotonic</strong> if:</p>

<ul>
	<li>The lengths of both arrays are <code>n</code>.</li>
	<li><code>arr1</code> is monotonically <strong>non-decreasing</strong>, in other words, <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code>.</li>
	<li><code>arr2</code> is monotonically <strong>non-increasing</strong>, in other words, <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code>.</li>
	<li><code>arr1[i] + arr2[i] == nums[i]</code> for all <code>0 &lt;= i &lt;= n - 1</code>.</li>
</ul>

<p>Return the count of <strong>monotonic</strong> pairs.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The good pairs are:</p>

<ol>
	<li><code>([0, 1, 1], [2, 2, 1])</code></li>
	<li><code>([0, 1, 2], [2, 2, 0])</code></li>
	<li><code>([0, 2, 2], [2, 1, 0])</code></li>
	<li><code>([1, 2, 2], [1, 1, 0])</code></li>
</ol>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,5,5,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">126</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-count-of-monotonic-pairs-ii/description" target="_blank" rel="noopener noreferrer">Find the Count of Monotonic Pairs II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code> of length <code>n</code>.</p>

<p>We call a pair of <strong>non-negative</strong> integer arrays <code>(arr1, arr2)</code> <strong>monotonic</strong> if:</p>

<ul>
	<li>The lengths of both arrays are <code>n</code>.</li>
	<li><code>arr1</code> is monotonically <strong>non-decreasing</strong>, in other words, <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code>.</li>
	<li><code>arr2</code> is monotonically <strong>non-increasing</strong>, in other words, <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code>.</li>
	<li><code>arr1[i] + arr2[i] == nums[i]</code> for all <code>0 &lt;= i &lt;= n - 1</code>.</li>
</ul>

<p>Return the count of <strong>monotonic</strong> pairs.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The good pairs are:</p>

<ol>
	<li><code>([0, 1, 1], [2, 2, 1])</code></li>
	<li><code>([0, 1, 2], [2, 2, 0])</code></li>
	<li><code>([0, 2, 2], [2, 1, 0])</code></li>
	<li><code>([1, 2, 2], [1, 1, 0])</code></li>
</ol>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,5,5,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">126</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-highest-altitude/description" target="_blank" rel="noopener noreferrer">Find the Highest Altitude</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a biker going on a road trip. The road trip consists of <code>n + 1</code> points at different altitudes. The biker starts his trip on point <code>0</code> with altitude equal <code>0</code>.</p>

<p>You are given an integer array <code>gain</code> of length <code>n</code> where <code>gain[i]</code> is the <strong>net gain in altitude</strong> between points <code>i</code>â€‹â€‹â€‹â€‹â€‹â€‹ and <code>i + 1</code> for all (<code>0 &lt;= i &lt; n)</code>. Return <em>the <strong>highest altitude</strong> of a point.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> gain = [-5,1,5,0,-7]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> gain = [-4,-3,-2,-1,4,3,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == gain.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>-100 &lt;= gain[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-prefix-sum">Approach: Prefix Sum</h3>
<p><strong>Intuition</strong></p>
<p>We start from the altitude <code>0</code> and we have a list of <span class="math inline">\(N\)</span> integers, where each integer represents the gain in altitude at each step (it could be negative as well, which implies a fall in altitude) a biker takes. We need to return the highest altitude of the biker in the complete journey, including the starting point at <code>0</code>.</p>
<p>This can be solved by taking the maximum altitudes at each step in the journey. The altitude at a step can be determined as the altitude at the previous step plus the gain at the current step. Hence, we will start from <code>0</code> and keep adding the gain in altitude to it at each step, and after each addition, we will update the maximum altitude we have seen so far.</p>
<p><img src="../Figures/1732/1732A.png" alt="fig" /></p>
<p>If we observe closely, the altitude at a point is the sum of gains on the left of it, which is nothing but the prefix sum at this index. Therefore, we can find the prefix sum and return the maximum as the highest reached altitude.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the variable <code>currentAltitude</code> to <code>0</code>; this is the current altitude of the biker.</li>
<li>Initialize the variable <code>highestPoint</code> to <code>currentAltitude</code>, as the highest altitude we have seen is <code>0</code>.</li>
<li>Iterate over the gain in altitude in the list <code>gain</code> and add the current gain <code>altitudeGain</code> to the variable <code>currentAltitude</code>.</li>
<li>Update the variable <code>highestPoint</code> as necessary.</li>
<li>Return <code>highestPoint</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/BF9NaW9P/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of integers in the list <code>gain</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>We iterate over every integer in the list <code>gain</code> only once, and hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We only need two variables, <code>currentAltitude</code> and<code>highestPoint</code>; hence the space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/description" target="_blank" rel="noopener noreferrer">Find the Longest Substring Containing Vowels in Even Counts</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the string <code>s</code>, return the size of the longest substring containing each vowel an even number of times. That is, &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39; must appear an even number of times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;eleetminicoworoep&quot;
<strong>Output:</strong> 13
<strong>Explanation: </strong>The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: <strong>e</strong>, <strong>i</strong> and <strong>o</strong> and zero of the vowels: <strong>a</strong> and <strong>u</strong>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcodeisgreat&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The longest substring is &quot;leetc&quot; which contains two e&#39;s.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcbcbc&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> In this case, the given string &quot;bcbcbc&quot; is the longest because all vowels: <strong>a</strong>, <strong>e</strong>, <strong>i</strong>, <strong>o</strong> and <strong>u</strong> appear zero times.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>
	<li><code>s</code>&nbsp;contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-bitmasking">Approach: Bitmasking</h3>
<h4 id="intuition">Intuition</h4>
<p>Given a string <code>s</code>, we need to find the length of the longest substring in which any vowel present must appear an even number of times. A brute force approach would involve iterating through every substring and counting vowels, but this would result in a Time Limit Exceeded (TLE). Instead, we need to think of a more efficient solution, aiming for a linear or log-linear time complexity.</p>
<p>Observe that we don't need to know the exact count of the vowels to solve this problem; we only need to know the parity of each vowel (whether it appears an even or odd number of times). The parity of each vowel can be stored in a boolean or bit, where <code>0</code> means even and <code>1</code> means odd. We need five bits to track the parity of all five vowels (a, e, i, o, u), resulting in 2^5 = 32 possible states.</p>
<p>We can assign the first bit to <code>a</code>, the second to <code>e</code>, and so on. The state of the vowels can be represented as a binary string. For instance, <code>00000</code> means all vowels have even counts, while <code>10000</code> means only <code>a</code> has an odd count.<br />
By converting these binary states to integers, we can assign values to the vowels: <code>a = 1</code>, <code>e = 2</code>, <code>i = 4</code>, <code>o = 8</code>, and <code>u = 16</code>. If both <code>a</code> and <code>i</code> have odd counts, their total value would be <code>1 + 4 = 5</code>. A total value of <code>0</code> means all vowels have even counts.</p>
<p><img src="../Figures/1371/slide1_repub.drawio.png" alt="fig" /></p>
<p>To find substrings with even vowels, we can use the XOR operator to update and track the parity of the vowels. If a vowel appears an even number of times, the result of XOR will be 0; if it appears an odd number of times, the result will be 1.</p>
<p>We compute a running XOR for each vowel as we traverse the string. To check for substrings with even vowels, we consider two cases:</p>
<ol>
<li>If the current XOR value is <code>00000</code> (i.e., all vowels have even counts), the substring from the start of the string to the current position contains even vowels.</li>
<li>If the current XOR value has occurred before, the substring between the first occurrence of that XOR value and the current position also contains even vowels.</li>
</ol>
<p><img src="../Figures/1371/image2_repub.drawio.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer variable <code>prefixXOR</code> and set it to 0.</li>
<li>Initialize a character array <code>characterMap[26]</code> where specific vowel characters <code>('a', 'e', 'i', 'o', 'u')</code> have unique mask values <code>(1, 2, 4, 8, 16)</code>.</li>
<li>Initialize an array <code>mp</code> of size 32, where all elements are set to -1. This will store the index of the first occurrence of each <code>prefixXOR</code> value.</li>
<li>Initialize an integer variable <code>longestSubstring</code> and set it to <code>0</code>.</li>
<li>Iterate through each character in the string <code>s</code>:
<ul>
<li>Update <code>prefixXOR</code> by XORing it with the mask value of the current character (from <code>characterMap</code>).</li>
<li>If the current <code>prefixXOR</code> value is not found in <code>mp</code> and <code>prefixXOR</code> is not 0:
<ul>
<li>Store the current index in <code>mp</code> at the position corresponding to <code>prefixXOR</code>.</li>
</ul>
</li>
<li>Update <code>longestSubstring</code> by comparing it with the difference between the current index and <code>mp[prefixXOR]</code>.</li>
</ul>
</li>
<li>Return <code>longestSubstring</code> as the final result.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/axaQPQM9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the size of the given <code>s</code> string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the string <code>s</code> exactly once. Apart from this, all operations are constant time. Therefore, the total time complexity is given by <span class="math inline">\(O(max(m,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Apart from the <code>characterMap</code> and <code>mp</code> array, no additional space is used to solve the problem. Therefore, the space complexity is given by <span class="math inline">\(O(26) + O(32) â‰ˆ O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-middle-index-in-array/description" target="_blank" rel="noopener noreferrer">Find the Middle Index in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find the <strong>leftmost</strong> <code>middleIndex</code> (i.e., the smallest amongst all the possible ones).</p>

<p>A <code>middleIndex</code> is an index where <code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code>.</p>

<p>If <code>middleIndex == 0</code>, the left side sum is considered to be <code>0</code>. Similarly, if <code>middleIndex == nums.length - 1</code>, the right side sum is considered to be <code>0</code>.</p>

<p>Return <em>the <strong>leftmost</strong> </em><code>middleIndex</code><em> that satisfies the condition, or </em><code>-1</code><em> if there is no such index</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,-1,<u>8</u>,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
The sum of the numbers after index 3 is: 4 = 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,-1,<u>4</u>]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The sum of the numbers before index 2 is: 1 + -1 = 0
The sum of the numbers after index 2 is: 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no valid middleIndex.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as&nbsp;724:&nbsp;<a href="https://leetcode.com/problems/find-pivot-index/" target="_blank">https://leetcode.com/problems/find-pivot-index/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/description" target="_blank" rel="noopener noreferrer">Find the Minimum Amount of Time to Brew Potions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays, <code>skill</code> and <code><font face="monospace">mana</font></code>, of length <code>n</code> and <code>m</code>, respectively.</p>

<p>In a laboratory, <code>n</code> wizards must brew <code>m</code> potions <em>in order</em>. Each potion has a mana capacity <code>mana[j]</code> and <strong>must</strong> pass through <strong>all</strong> the wizards sequentially to be brewed properly. The time taken by the <code>i<sup>th</sup></code> wizard on the <code>j<sup>th</sup></code> potion is <code>time<sub>ij</sub> = skill[i] * mana[j]</code>.</p>

<p>Since the brewing process is delicate, a potion <strong>must</strong> be passed to the next wizard immediately after the current wizard completes their work. This means the timing must be <em>synchronized</em> so that each wizard begins working on a potion <strong>exactly</strong> when it arrives. â€‹</p>

<p>Return the <strong>minimum</strong> amount of time required for the potions to be brewed properly.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">skill = [1,5,2,4], mana = [5,1,4,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">110</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Potion Number</th>
			<th style="border: 1px solid black;">Start time</th>
			<th style="border: 1px solid black;">Wizard 0 done by</th>
			<th style="border: 1px solid black;">Wizard 1 done by</th>
			<th style="border: 1px solid black;">Wizard 2 done by</th>
			<th style="border: 1px solid black;">Wizard 3 done by</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">30</td>
			<td style="border: 1px solid black;">40</td>
			<td style="border: 1px solid black;">60</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">52</td>
			<td style="border: 1px solid black;">53</td>
			<td style="border: 1px solid black;">58</td>
			<td style="border: 1px solid black;">60</td>
			<td style="border: 1px solid black;">64</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">54</td>
			<td style="border: 1px solid black;">58</td>
			<td style="border: 1px solid black;">78</td>
			<td style="border: 1px solid black;">86</td>
			<td style="border: 1px solid black;">102</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">86</td>
			<td style="border: 1px solid black;">88</td>
			<td style="border: 1px solid black;">98</td>
			<td style="border: 1px solid black;">102</td>
			<td style="border: 1px solid black;">110</td>
		</tr>
	</tbody>
</table>

<p>As an example for why wizard 0 cannot start working on the 1<sup>st</sup> potion before time <code>t = 52</code>, consider the case where the wizards started preparing the 1<sup>st</sup> potion at time <code>t = 50</code>. At time <code>t = 58</code>, wizard 2 is done with the 1<sup>st</sup> potion, but wizard 3 will still be working on the 0<sup>th</sup> potion till time <code>t = 60</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">skill = [1,1,1], mana = [1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>Preparation of the 0<sup>th</sup> potion begins at time <code>t = 0</code>, and is completed by time <code>t = 3</code>.</li>
	<li>Preparation of the 1<sup>st</sup> potion begins at time <code>t = 1</code>, and is completed by time <code>t = 4</code>.</li>
	<li>Preparation of the 2<sup>nd</sup> potion begins at time <code>t = 2</code>, and is completed by time <code>t = 5</code>.</li>
</ol>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">skill = [1,2,3,4], mana = [1,2]</span></p>

<p><strong>Output:</strong> 21</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == skill.length</code></li>
	<li><code>m == mana.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 5000</code></li>
	<li><code>1 &lt;= mana[i], skill[i] &lt;= 5000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-n-th-value-after-k-seconds/description" target="_blank" rel="noopener noreferrer">Find the N-th Value After K Seconds</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>n</code> and <code>k</code>.</p>

<p>Initially, you start with an array <code>a</code> of <code>n</code> integers where <code>a[i] = 1</code> for all <code>0 &lt;= i &lt;= n - 1</code>. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, <code>a[0]</code> remains the same, <code>a[1]</code> becomes <code>a[0] + a[1]</code>, <code>a[2]</code> becomes <code>a[0] + a[1] + a[2]</code>, and so on.</p>

<p>Return the <strong>value</strong> of <code>a[n - 1]</code> after <code>k</code> seconds.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">56</span></p>

<p><strong>Explanation:</strong></p>

<table border="1">
	<tbody>
		<tr>
			<th>Second</th>
			<th>State After</th>
		</tr>
		<tr>
			<td>0</td>
			<td>[1,1,1,1]</td>
		</tr>
		<tr>
			<td>1</td>
			<td>[1,2,3,4]</td>
		</tr>
		<tr>
			<td>2</td>
			<td>[1,3,6,10]</td>
		</tr>
		<tr>
			<td>3</td>
			<td>[1,4,10,20]</td>
		</tr>
		<tr>
			<td>4</td>
			<td>[1,5,15,35]</td>
		</tr>
		<tr>
			<td>5</td>
			<td>[1,6,21,56]</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">35</span></p>

<p><strong>Explanation:</strong></p>

<table border="1">
	<tbody>
		<tr>
			<th>Second</th>
			<th>State After</th>
		</tr>
		<tr>
			<td>0</td>
			<td>[1,1,1,1,1]</td>
		</tr>
		<tr>
			<td>1</td>
			<td>[1,2,3,4,5]</td>
		</tr>
		<tr>
			<td>2</td>
			<td>[1,3,6,10,15]</td>
		</tr>
		<tr>
			<td>3</td>
			<td>[1,4,10,20,35]</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-original-typed-string-ii/description" target="_blank" rel="noopener noreferrer">Find the Original Typed String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and <strong>may</strong> press a key for too long, resulting in a character being typed <strong>multiple</strong> times.</p>

<p>You are given a string <code>word</code>, which represents the <strong>final</strong> output displayed on Alice&#39;s screen. You are also given a <strong>positive</strong> integer <code>k</code>.</p>

<p>Return the total number of <em>possible</em> original strings that Alice <em>might</em> have intended to type, if she was trying to type a string of size <strong>at least</strong> <code>k</code>.</p>

<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word = &quot;aabbccdd&quot;, k = 7</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>The possible strings are: <code>&quot;aabbccdd&quot;</code>, <code>&quot;aabbccd&quot;</code>, <code>&quot;aabbcdd&quot;</code>, <code>&quot;aabccdd&quot;</code>, and <code>&quot;abbccdd&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word = &quot;aabbccdd&quot;, k = 8</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible string is <code>&quot;aabbccdd&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word = &quot;aaabbb&quot;, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= k &lt;= 2000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-dynamic-programming--prefix-sum-optimization">Approach: Dynamic Programming + Prefix Sum Optimization</h3>
<h4 id="intuition">Intuition</h4>
<p>To obtain a result with a length of at least <span class="math inline">\(k\)</span>, we can first calculate the total number of valid results of any length, and then subtract the number of results of lengths <span class="math inline">\(1, 2, \cdots, k-1\)</span>.</p>
<p>For any result length, we can use the multiplication principle: if a character appears consecutively <span class="math inline">\(p\)</span> times in the string <span class="math inline">\(\textit{word}\)</span>, then Alice may choose to input it <span class="math inline">\(1, 2, \cdots, p\)</span> times, giving <span class="math inline">\(p\)</span> possible choices. Multiplying all such values of <span class="math inline">\(p\)</span> gives the total number of valid results for all lengths.</p>
<blockquote>
<p>For example, if <span class="math inline">\(\textit{word} = \text{abbcccaa}\)</span>, then the run lengths <span class="math inline">\(p\)</span> are <span class="math inline">\([1, 2, 3, 2]\)</span>, and the total number of results is <span class="math inline">\(1 \times 2 \times 3 \times 2 = 12\)</span>.</p>
</blockquote>
<p>To count the number of results with lengths less than <span class="math inline">\(k\)</span>, we use dynamic programming. First, we record all the <span class="math inline">\(p\)</span> values in a frequency array <span class="math inline">\(\textit{freq}\)</span>, and define <span class="math inline">\(f(i, j)\)</span> as the number of ways to construct a string using the first <span class="math inline">\(i+1\)</span> elements of <span class="math inline">\(\textit{freq}\)</span> such that the total constructed length is <span class="math inline">\(j\)</span>.</p>
<p>For state transitions, we iterate over the number of times the character corresponding to <span class="math inline">\(\textit{freq}[i]\)</span> is used, from <span class="math inline">\(1\)</span> to <span class="math inline">\(\textit{freq}[i]\)</span>. If it's used <span class="math inline">\(j'\)</span> times, then we must construct a string of length <span class="math inline">\(j - j'\)</span> using the first <span class="math inline">\(i\)</span> elements. This leads to the recurrence:</p>
<p><span class="math display">\[f(i, j) = \sum_{j'=1}^{\textit{freq}[i]} f(i-1, j-j')
\]</span></p>
<p>The base case is <span class="math inline">\(f(-1, 0) = 1\)</span>, indicating there is one way to construct the empty string.</p>
<p>If the length of <span class="math inline">\(\textit{freq}\)</span> is already <span class="math inline">\(\geq k\)</span>, we donâ€™t need this dynamic programming calculation, because the total constructed string length will necessarily be at least <span class="math inline">\(k\)</span>.</p>
<p>The above DP has time complexity <span class="math inline">\(O(k^3)\)</span> because we iterate over <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span>, and <span class="math inline">\(j'\)</span> â€” each in <span class="math inline">\(O(k)\)</span> â€” which is too slow when <span class="math inline">\(k = 2000\)</span>.</p>
<p>To optimize, observe that the summation in the recurrence has consecutive indices, so we can precompute prefix sums. Let <span class="math inline">\(g(i-1, j)\)</span> be the prefix sum:</p>
<p><span class="math display">\[g(i-1, j) = \sum_{j'=0}^j f(i-1, j')
\]</span></p>
<p>Then we can compute <span class="math inline">\(f(i, j)\)</span> in <span class="math inline">\(O(1)\)</span> time:</p>
<p><span class="math display">\[f(i, j) = g(i-1, j-1) - g(i-1, j-\textit{freq}[i]-1)
\]</span></p>
<p>This reduces time complexity to <span class="math inline">\(O(k^2)\)</span>.</p>
<p>For space optimization, note that we only need the previous row for state transition, so we can reduce space from <span class="math inline">\(O(k^2)\)</span> to <span class="math inline">\(O(k)\)</span> by using two 1D arrays.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NrdgUoWJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(\textit{words}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + k^2)\)</span>.</p>
<p>We need to traverse the string once, and the subsequent dynamic programming solution requires <span class="math inline">\(O(k^2)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-pivot-integer/description" target="_blank" rel="noopener noreferrer">Find the Pivot Integer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>, find the <strong>pivot integer</strong> <code>x</code> such that:</p>

<ul>
	<li>The sum of all elements between <code>1</code> and <code>x</code> inclusively equals the sum of all elements between <code>x</code> and <code>n</code> inclusively.</li>
</ul>

<p>Return <em>the pivot integer </em><code>x</code>. If no such integer exists, return <code>-1</code>. It is guaranteed that there will be at most one pivot index for the given input.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 8
<strong>Output:</strong> 6
<strong>Explanation:</strong> 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 is the pivot integer since: 1 = 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proved that no such integer exist.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find a pivot integer <code>x</code> in a range from 1 to a positive integer <code>n</code> such that the sum of all elements from 1 to <code>x</code> is equal to the sum of all elements from <code>x</code> to <code>n</code>. If such an integer exists, it should be returned; otherwise, -1 should be returned.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>All numbers in the range are positive.</li>
<li>The pivot is the point in the sequence where the sum on both sides is equal.</li>
<li>The pivot integer is included in the sum of both halves.</li>
</ol>
<p>Consider the given example <code>n = 8</code>:</p>
<p>For <code>x</code> to be a pivot integer, the sum of elements from 1 to <code>x</code> should be equal to the sum from <code>x</code> to <code>n</code>.</p>
<p>[1 + 2 + 3 + 4 + 5 + 6 = 21] and [6 + 7 + 8 = 21].</p>
<p>The pivot integer <code>x</code> for this example is 6, as the sum of elements from 1 to 6 is equal to the sum of elements from 6 to 8.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We can perform multiple iterations, checking each potential pivot value from 1 to <code>n</code>. During this iteration, for each pivot value <code>i</code>, we use nested loops to separately calculate the sum of elements on the left side of the pivot and the right side. The first nested loop iterates from 1 to <code>i</code>, summing up elements on the left side.</p>
<p>The second nested loop iterates from <code>i</code> to <code>n</code>, summing up elements on the right side. After calculating the left and right sums, we can check if they are equal. If yes, it implies that the pivot integer <code>x</code> has been found. Return the pivot value or -1 if no valid pivot exists.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Iterate through possible pivot values from 1 to <code>n</code>.</li>
<li>For each pivot value, initialize variables <code>sumLeft</code> and <code>sumRight</code> to 0.
<ul>
<li>Then, calculate the sum of elements on the left side of the pivot by iterating from 1 to the pivot value and adding each element to <code>sumLeft</code>.</li>
<li>Next, calculate the sum of elements on the right side of the pivot by iterating from the pivot value to <code>n</code> and adding each element to <code>sumRight</code>.</li>
<li>After calculating the left and right sums, check if they are equal. If they are, return the pivot value.</li>
</ul>
</li>
<li>If no pivot is found after iterating through all possible values, return -1.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jBAqTZVP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the sequence from <span class="math inline">\(1\)</span> to <span class="math inline">\(N\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n^2)\)</span> due to the nested loops that iterate through potential pivot values and calculate sums on both sides.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> since the memory usage remains constant regardless of the input size. Only a few variables are used to store sums.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous brute-force approach, we used nested loops to find the pivot value, which is inefficient.</p>
<p>Now, consider a more optimized approach. Instead of iterating over potential pivots first, we directly calculate <code>sumLeft</code> and <code>sumRight</code> while traversing the range. We start with pointers at both ends (<code>leftValue</code> and <code>rightValue</code>) and dynamically adjust the sums as the pointers move towards the center. By doing so, we maintain the sums in real time without the need for an additional nested loop.</p>
<p>We traverse the range until the pointers meet, dynamically adjusting sums based on comparisons. If <code>sumLeft</code> is greater than or equal to <code>sumRight</code>, the sum on the left is ahead, and we must catch up on the right. Hence, we decrement <code>rightValue</code> and add the new element to <code>sumRight</code>. Otherwise, the sum on the right is ahead, so we increment <code>leftValue</code> and add the new element to <code>sumLeft</code>.</p>
<p>Within the loop, we check for a valid pivot. If the sums are equal and the pointers are close enough, we have identified a valid pivot, i.e., <code>sumLeft == sumRight &amp;&amp; leftValue + 1 == rightValue - 1</code>.</p>
<p>Refer to the visual slideshow demonstrating the two pointer approach:</p>
<p>!?!../Documents/2484/two_pointer.json:1005,280!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>leftValue</code> and <code>rightValue</code> to 1 and <code>n</code>, respectively, and <code>sumLeft</code> and <code>sumRight</code> to <code>leftValue</code> and <code>rightValue</code>, respectively.</li>
<li>If <code>n</code> is 1, return <code>n</code> as it is already a valid pivot.</li>
<li>Enter a while loop that continues while <code>leftValue</code> is less than <code>rightValue</code>.
<ul>
<li>Check if <code>sumLeft</code> is less than <code>sumRight</code>. If true, increment <code>leftValue</code> by 1 and add the new value to <code>sumLeft</code>.</li>
<li>If false, decrement <code>rightValue</code> by 1 and add the new value to <code>sumRight</code>.</li>
<li>After adjusting the pointers and sums, check if <code>sumLeft</code> is equal to <code>sumRight</code> and if the pointers are next to each other (<code>leftValue + 1 == rightValue - 1</code>). If this condition is met, it means that <code>leftValue + 1</code> is a valid pivot; thus, return this value.</li>
</ul>
</li>
<li>If the loop exits without finding a pivot, return -1 to indicate that no valid pivot was found.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3kmksa9D/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the sequence from <span class="math inline">\(1\)</span> to <span class="math inline">\(N\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span> due to the loop that iterates through potential pivot values to calculate sums on both sides.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(1)\)</span> since the memory usage remains constant regardless of the input size. Only a few variables are used to store sums.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search">Approach 3: Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To optimize the solution further, we can use the efficiency of <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a> and the <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression sum formula</a>. Using the arithmetic progression sum formula, we can determine the total sum of the entire series.</p>
<p>In this optimization, we perform a check using the expression <code>mid * mid - totalSum = 0</code>. If the result is zero, it implies that the current midpoint is the pivot we are searching for. This is because the quadratic relationship <span class="math inline">\(x^2\)</span> in the cumulative sum means that the pivot is the point where the cumulative sum reaches half of the total sum.</p>
<p>Total Sum: 36<br />
Pivot: 6<br />
<span class="math inline">\( 6 \cdot 6 = 36\)</span></p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>3 + 3</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>The sum to the left of the pivot is 15, and the sum to the right of the pivot is 15. Half of the pivot is 3, which makes each half of the sum 18.<br />
<span class="math inline">\(36 / 2 = 18\)</span></p>
<p>We exploit the monotonically increasing nature of the sequence from 1 to <code>n</code>. The goal is to find the pivot point, which is the integer where the sum of all integers from 1 to that integer equals the sum of the remaining integers from the pivot point to <code>n</code>.</p>
<p>The total sum of the sequence can be calculated using the formula <span class="math inline">\(n \cdot (n + 1) / 2\)</span> (Arithmetic progression sum formula), which is equivalent to  <span class="math inline">\(\frac{n^2 + n}{2}\)</span>.</p>
<p>The main criterion in the binary search is to continually adjust the search space by comparing the midpoint with the total sum. The midpoint divides the search space into two halves. It is squared (<code>mid * mid</code>) and then compared against the total sum. The choice of squaring the midpoint is intentional and aligns with the nature of the sum formula, which involves squaring the number <span class="math inline">\(n\)</span> in the formula <span class="math inline">\(n * (n + 1) / 2\)</span>.</p>
<p>The function <code>f(x) = x * x</code> represents a monotonic increasing function for non-negative values of <code>x</code>. If the square of mid is less than the total sum, it indicates that the cumulative sum is increasing, suggesting that the pivot point hasn't been reached yet.</p>
<p>Refer to the visual slideshow demonstrating the binary search approach:</p>
<p>!?!../Documents/2484/binary_search.json:1000,325!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize the <code>left</code> pointer to <code>1</code> and the <code>right</code> pointer to <code>n</code>  for binary search.</li>
<li>Calculate the <code>totalSum</code> of the sequence using the formula <span class="math inline">\(n \cdot (n + 1) / 2\)</span>.</li>
<li>Perform a binary search by adjusting the <code>left</code> and <code>right</code> bounds based on the difference between the square of the <code>mid</code> and the <code>totalSum</code> until the left pointer is equal to the right pointer.
<ul>
<li>If the difference is negative, this implies that the pivot point must be to the right of the midpoint because the sum of integers increases as you move to the right. In this case, the left bound (<code>left</code>) is adjusted to <code>mid + 1</code>, narrowing the search range to the right side.</li>
<li>If the difference is positive (or equal to 0), this implies that the pivot point must be to the left of the midpoint or possibly at the midpoint itself. In this case, the right bound (<code>right</code>) is adjusted to <code>mid</code>, narrowing the search range to the left side or keeping the midpoint as a potential solution.</li>
</ul>
</li>
<li>Check if the square of the left pointer minus the <code>totalSum</code> is zero, if yes, it means that the left pointer is pointing to the pivot point, as the sum of integers on one side of the pivot is equal to the sum on the other side; otherwise, return -1.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/N89AzoXT/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the sequence from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log n)\)</span></p>
<p>The binary search efficiently narrows down the search space by half in each iteration, leading to a logarithmic time complexity. Other operations, such as calculating the total sum, squaring values, and performing arithmetic operations, have constant time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as the number of variables remains the same regardless of the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-pre-compute-and-cache-in-a-lookup-table">Approach 4: Pre-Compute and Cache in a Lookup Table</h3>
<h4 id="intuition-3">Intuition</h4>
<p>As the input size <code>n</code> increases, the pivot integer <code>x</code> tends to increase, where <code>x</code> is the sum of elements from 1 to <code>x</code> equaling the sum of elements from <code>x</code> to <code>n</code>.</p>
<p>To optimize the process, a precomputation strategy can be used, involving the calculation and storage of pivot values for all possible <code>n</code> in an array called <code>precompute</code>. This precomputation involves calculating the pivot for each <code>n</code> in the range.</p>
<p>After the precomputation, when a specific <code>n</code> is given as a query, the precomputed pivot value can be directly retrieved from the <code>precompute</code> array. This retrieval operation takes constant time, as it merely involves indexing an array.</p>
<p>We will define the <code>precompute</code> array globally as it offers a practical advantage in our code. If we define the precompute array globally, it won't be recomputed each time the function is called in the context of a larger program. A global variable retains its state across different function calls. So, by defining the precompute array globally, we ensure that its values persist throughout the execution of the program, including across multiple test cases. This can significantly improve efficiency, especially when the precompute array involves time-consuming calculations that don't need to be repeated for each test case.</p>
<p>This approach is practical when handling multiple queries involving different <code>n</code> values. It's more efficient because it doesn't redo the pivot calculation every time. But there's a downsideâ€”the first setup takes some time, <span class="math inline">\(O(n)\)</span> where <code>n</code> is the maximum <code>n</code> value. This approach is less efficient when the pivot is needed for only a few <code>n</code> values or when memory is limited.</p>
<p>Despite these considerations, the benefits of this approach become more pronounced in real-world applications where the system deals with diverse and larger datasets. The time it takes to set up might not be as noticeable in the long run, and the benefits of using it become more obvious in larger, practical projects. For example, if you have a big pile of papers and you want to organize them by size, using this method makes the process faster once you've set it up.</p>
<blockquote>
<p>Traditional dynamic programming involves reusing intermediate results (e.g., <code>DP[y]</code> based on <code>DP[x]</code> where <code>x</code> is smaller than <code>y</code>). However, this approach focuses on pre-computing and storing values for efficient retrieval, so it is considered pre-computation and storage in a lookup table rather than dynamic programming.</p>
</blockquote>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize the variable <code>maxValue</code> to 1000, the maximum <code>n</code> value provided by the constraints.</li>
<li>Initialize an array <code>precompute</code> of size <code>maxValue + 1</code> filled with 0 to store precomputed pivot values.</li>
<li>Check if the <code>precompute</code> array is not initialized. If not initialized, iterate from 1 to <code>maxValue</code>.
<ul>
<li>Calculate the <code>sum</code> of integers up to <code>i</code> using the formula <span class="math inline">\(i * (i + 1) / 2\)</span>.</li>
<li>Find the first square number greater than or equal to the <code>sum</code> by incrementing <code>j</code> until <code>j * j</code> is greater than or equal to the <code>sum</code>.</li>
<li>Check if <code>j * j</code> is equal to the <code>sum</code>. If true, it means that the current value of <code>j</code> is the pivot for the given <code>i</code>. Otherwise, set <code>precompute[i]</code> to <code>-1</code>, indicating that no pivot is found for the current <code>i</code>.</li>
</ul>
</li>
<li>Return the pivot value for the input <code>n</code> from the <code>precompute</code> array.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/m3ntGUU7/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the maximum precomputed <span class="math inline">\(n\)</span> value.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m)\)</span></p>
<p>While the time complexity for individual queries is <span class="math inline">\(O(1)\)</span>, the overall complexity is influenced by the precomputation, making it <span class="math inline">\(O(m)\)</span>.</p>
</li>
<li>
<p>Space complexity:  <span class="math inline">\(O(m)\)</span></p>
<p>The space complexity is influenced by the precomputation step, which requires storing an array of size <code>m</code>. Therefore, the space complexity is <span class="math inline">\(O(m)\)</span> .</p>
</li>
</ul>
<hr />
<h3 id="approach-5-using-math">Approach 5: Using Math</h3>
<h4 id="intuition-4">Intuition</h4>
<p>To find the value of <code>x</code> where the sum of elements from 1 to <code>x</code> is equal to the sum of elements from <code>x</code> to <code>n</code>, we can set up the following equation:</p>
<p><span class="math inline">\([ 1 + 2 + ... + x = x + ... + n ]\)</span></p>
<p>Using Arithmetic Progression:</p>
<p><span class="math inline">\([ \frac{x(x + 1)}{2} = \frac{(x + n)(n - x + 1)}{2} ]\)</span></p>
<p>Expanding both sides of the equation:</p>
<p><span class="math inline">\([ \frac{x + x^2}{2} = \frac{nx - x^2 + x + n^2 - nx + n}{2} ]\)</span></p>
<p>Simplifying the equation and solving for x:</p>
<p><span class="math inline">\([ 2x^2 = n^2 + n ]\)</span></p>
<p><span class="math inline">\([ x = \sqrt{\frac{n^2 + n}{2}} ]\)</span></p>
<p>This formula provides the value of <code>x</code> that satisfies the given condition for the sum of elements in an arithmetic progression. It ensures that the sum of elements from 1 to <code>x</code> is equal to the sum of elements from <code>x</code> to <code>n</code>.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>Calculate the total <code>sum</code> of the sequence from 1 to <code>n</code> using the formula <span class="math inline">\((n \cdot (n + 1) / 2)\)</span>, which is equivalent to <span class="math inline">\((n^2 + n) / 2\)</span></li>
<li>Calculate the square root of the total <code>sum</code> and store it in <code>pivot</code>.</li>
<li>Check if the square of the <code>pivot</code> is equal to the total <code>sum</code>.
<ul>
<li>If the square of the <code>pivot</code> is equal to the total <code>sum</code>, return the <code>pivot</code> as the pivot integer <code>x</code>.</li>
<li>If the square of the <code>pivot</code> is not equal to the total <code>sum</code>, return <code>-1</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/ME9trJaw/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The time complexity is constant, because the primary operation, the calculation of the square root (<code>sqrt(sum)</code>), takes a constant amount of time and is not dependent on the input size <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is also constant, as the code uses only a fixed amount of additional space. The variables <code>sum</code> and <code>pivot</code> are constants and do not scale with the input size.</p>
</li>
</ul>
<details><summary><b>Further Thoughts on Space Complexity:</b></summary>
<p>Since the input size (in terms of bits) is bounded by a constant multiple of <span class="math inline">\(\ logn\)</span>, and Newton's method has a time complexity of <span class="math inline">\(O(\ logn)\)</span>, the overall complexity of finding the square root using Newton's method can be considered <span class="math inline">\(O(1)\)</span> for practical inputs. This is because the number of iterations required by Newton's method remains constant for inputs of bounded size. Therefore, for small inputs like the ones typically encountered in practice or like this question, the time complexity of finding the square root can be treated as constant. For inputs with unbounded bounds, the time complexity remains <span class="math inline">\(O(\ logn)\)</span>.</p>
<p>Let's perform a dry run for both <code>n=8</code> and <code>n=1000</code> to determine the exact number of iterations Newton's method requires:</p>
<ol>
<li>
<p><strong>For <span class="math inline">\(n = 8\)</span></strong>:</p>
<ul>
<li>
<p>The sum is <span class="math inline">\(\text{sum} = 8 \times (8 + 1) / 2 = 36\)</span>.</p>
</li>
<li>
<p>Since <span class="math inline">\(\sqrt{36} = 6\)</span>, a reasonable initial guess for the square root is 6, which is already a good approximation.</p>
</li>
<li>
<p>Let's run Newton's method:</p>
<p>Iteration 1: <span class="math inline">\(x_1 = \frac{1}{2} (6 + \frac{36}{6}) = \frac{1}{2} (6 + 6) = 6\)</span></p>
</li>
<li>
<p>The approximation doesn't change significantly because it's already accurate to a satisfactory precision. Therefore, only 1 iteration is required.</p>
</li>
</ul>
</li>
<li>
<p><strong>For <span class="math inline">\(n = 1000\)</span></strong>:</p>
<ul>
<li>
<p>The sum is <span class="math inline">\(\text{sum} = 1000 \times (1000 + 1) / 2 = 500500\)</span>.</p>
</li>
<li>
<p>For a rough initial guess, we can take the square root of the sum or a nearby integer value. Let's use 700 as a starting point since it's close to <span class="math inline">\(\sqrt{500500}\)</span> and likely to converge quickly.</p>
</li>
<li>
<p>Let's run Newton's method:</p>
<p>Iteration 1: <span class="math inline">\(x_1 = \frac{1}{2} (700 + \frac{500500}{700}) \approx \frac{1}{2} (700 + 715) \approx 707.5\)</span></p>
<p>Iteration 2: <span class="math inline">\(x_2 = \frac{1}{2} (707.5 + \frac{500500}{707.5}) \approx \frac{1}{2} (707.5 + 707.11) \approx 707.305\)</span></p>
<p>Iteration 3: <span class="math inline">\(x_3 = \frac{1}{2} (707.305 + \frac{500500}{707.305}) \approx \frac{1}{2} (707.305 + 707.13) \approx 707.217\)</span></p>
<p>Iteration 4: <span class="math inline">\(x_4 = \frac{1}{2} (707.217 + \frac{500500}{707.217}) \approx \frac{1}{2} (707.217 + 707.127) \approx 707.172\)</span></p>
<p>Iteration 5: <span class="math inline">\(x_5 = \frac{1}{2} (707.172 + \frac{500500}{707.172}) \approx \frac{1}{2} (707.172 + 707.165) \approx 707.169\)</span></p>
<p>Iteration 6: <span class="math inline">\(x_6 = \frac{1}{2} (707.169 + \frac{500500}{707.169}) \approx \frac{1}{2} (707.169 + 707.168) \approx 707.169\)</span></p>
</li>
<li>
<p>The approximation stabilizes at around <span class="math inline">\(x = 707.169\)</span>, and further iterations do not significantly change the result. Therefore, 6 iterations are required to converge to a satisfactory result.</p>
</li>
<li>
<p>These estimates that we took are just rough approximations, but they demonstrate that even for significantly different input sizes, the number of iterations required remains relatively small and can be considered constant for practical purposes. For fun you can experiment different rough estimates like maybe the furthest square root thats possible and you will still see the numbers are relatively constant. We strongly recommend checking out this blog on <a href="https://math.stackexchange.com/questions/3665749/analysis-of-binary-search-to-find-square-root-versus-newtons-method-for-example">analysis of binary search to find square root</a>. Many individuals, including those with a background in mathematics or those who have taken certain entrance exams, may have unknowingly utilized Newton's method for finding square roots to obtain the nearest answer from a set of math options.</p>
</li>
<li>
<p>All of the above in-depth reasons are why we have designated the space complexity as O(1) and considered this approach the most optimal.</p>
</li>
</ul>
</li>
</ol>
</details>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-score-of-all-prefixes-of-an-array/description" target="_blank" rel="noopener noreferrer">Find the Score of All Prefixes of an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We define the <strong>conversion array</strong> <code>conver</code> of an array <code>arr</code> as follows:</p>

<ul>
	<li><code>conver[i] = arr[i] + max(arr[0..i])</code> where <code>max(arr[0..i])</code> is the maximum value of <code>arr[j]</code> over <code>0 &lt;= j &lt;= i</code>.</li>
</ul>

<p>We also define the <strong>score</strong> of an array <code>arr</code> as the sum of the values of the conversion array of <code>arr</code>.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n</code><em> where </em><code>ans[i]</code><em> is the score of the prefix</em> <code>nums[0..i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,7,5,10]
<strong>Output:</strong> [4,10,24,36,56]
<strong>Explanation:</strong> 
For the prefix [2], the conversion array is [4] hence the score is 4
For the prefix [2, 3], the conversion array is [4, 6] hence the score is 10
For the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24
For the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36
For the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,4,8,16]
<strong>Output:</strong> [2,4,8,16,32,64]
<strong>Explanation:</strong> 
For the prefix [1], the conversion array is [2] hence the score is 2
For the prefix [1, 1], the conversion array is [2, 2] hence the score is 4
For the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8
For the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16
For the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32
For the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description" target="_blank" rel="noopener noreferrer">Find the Student that Will Replace the Chalk</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> students in a class numbered from <code>0</code> to <code>n - 1</code>. The teacher will give each student a problem starting with the student number <code>0</code>, then the student number <code>1</code>, and so on until the teacher reaches the student number <code>n - 1</code>. After that, the teacher will restart the process, starting with the student number <code>0</code> again.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>chalk</code> and an integer <code>k</code>. There are initially <code>k</code> pieces of chalk. When the student number <code>i</code> is given a problem to solve, they will use <code>chalk[i]</code> pieces of chalk to solve that problem. However, if the current number of chalk pieces is <strong>strictly less</strong> than <code>chalk[i]</code>, then the student number <code>i</code> will be asked to <strong>replace</strong> the chalk.</p>

<p>Return <em>the <strong>index</strong> of the student that will <strong>replace</strong> the chalk pieces</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> chalk = [5,1,5], k = 22
<strong>Output:</strong> 0
<strong>Explanation: </strong>The students go in turns as follows:
- Student number 0 uses 5 chalk, so k = 17.
- Student number 1 uses 1 chalk, so k = 16.
- Student number 2 uses 5 chalk, so k = 11.
- Student number 0 uses 5 chalk, so k = 6.
- Student number 1 uses 1 chalk, so k = 5.
- Student number 2 uses 5 chalk, so k = 0.
Student number 0 does not have enough chalk, so they will have to replace it.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> chalk = [3,4,1,2], k = 25
<strong>Output:</strong> 1
<strong>Explanation: </strong>The students go in turns as follows:
- Student number 0 uses 3 chalk so k = 22.
- Student number 1 uses 4 chalk so k = 18.
- Student number 2 uses 1 chalk so k = 17.
- Student number 3 uses 2 chalk so k = 15.
- Student number 0 uses 3 chalk so k = 12.
- Student number 1 uses 4 chalk so k = 8.
- Student number 2 uses 1 chalk so k = 7.
- Student number 3 uses 2 chalk so k = 5.
- Student number 0 uses 3 chalk so k = 2.
Student number 1 does not have enough chalk, so they will have to replace it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>chalk.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-prefix-sum">Approach 1: Prefix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>In this problem, we have an array <code>chalk</code> of <code>n</code> elements representing the number of chalks used by each student, and an integer <code>k</code> indicating the total number of chalks available. The brute force approach would involve repeatedly subtracting the number of chalks from <code>k</code> until it reaches zero, cycling through the array if necessary. Given that <code>k</code> can be as large as 1,000,000,000, this approach is impractical.</p>
<p>To optimize, observe that the total number of chalks used in one complete cycle through the array is given by <code>sum</code>, the sum of all elements in <code>chalk</code>. If <code>k</code> is less than <code>sum</code>, we will reach zero within the first cycle. If <code>k</code> is greater than <code>sum</code>, after the first cycle, <code>k</code> will be reduced to <code>k - sum</code>, and after subsequent cycles, it will be reduced further. This process continues until <code>k</code> becomes less than <code>sum</code>, which is equivalent to computing <code>k % sum</code>.</p>
<blockquote>
<p>This is because <code>k</code> reduced by multiples of <code>sum</code> will eventually be less than <code>sum</code>, and this final value is equivalent to <code>k % sum</code>.</p>
</blockquote>
<p>We then need to find the first index in the <code>chalk</code> array where the remaining <code>k % sum</code> becomes negative. We do this by maintaining a running prefix sum of <code>chalk</code> elements and iterating through the array to find the index where the prefix sum exceeds <code>k % sum</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer variable <code>sum</code> to 0.</li>
<li>Iterate over the chalk array from 0 to <code>chalk.size() - 1</code>:
<ul>
<li>Add the value at the current index <code>i</code> to <code>sum</code>.</li>
<li>If at any point <code>sum</code> exceeds <code>k</code>, exit the loop.</li>
</ul>
</li>
<li>Calculate <code>k</code> as <code>k % sum</code>, representing the remaining chalk after full rounds.</li>
<li>Iterate over the chalk array again from <code>0</code> to <code>chalk.size() - 1</code>:
<ul>
<li>If <code>k</code> is less than the value at the current index <code>i</code>, return <code>i</code> as the index of the student who will run out of chalk.</li>
<li>Otherwise, subtract the value at <code>chalk[i]</code> from <code>k</code>.</li>
</ul>
</li>
<li>If no student is found within the loop, return <code>0</code> (though this should not be reached given the problem constraints).</li>
</ol>
<p>!?!../Documents/1894/slideshow.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AnvPz9Gu/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>chalk</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>chalk</code> array exactly twice. Apart from this, all operations are performed in constant time. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No additional space is used proportional to the array size <code>n</code>. Therefore, the space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search">Approach 2: Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of iterating through the array to find the first index, we can use binary search. Binary search is ideal here because it quickly narrows down the search space in a sorted array.</p>
<p>We start by defining a predicate function that checks if the prefix sum at a given index is greater than the <code>k modulo sum</code>. This function returns <code>true</code> for indices where the prefix sum exceeds the target and <code>false</code> otherwise. Since the array is sorted based on the prefix sums, <code>true</code> indicates indices with no chalk left, while <code>false</code> indicates indices with some chalk remaining.</p>
<p>Using binary search, we locate the smallest index where the predicate returns <code>true</code>.</p>
<ul>
<li>If the predicate returns <code>true</code>, it means there might be smaller indices with <code>true</code> values, so we adjust the upper bound of the search space to the current index.</li>
<li>If the predicate returns <code>false</code>, it means all <code>true</code> values are beyond the current index, so we adjust the lower bound of the search space to the current index.</li>
</ul>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function - <code>chalkReplacer(chalk, k)</code>:</p>
<ol>
<li>Create an array <code>prefixSum</code> of length <code>n</code>to store prefix sums.</li>
<li>Initialize <code>prefixSum[0]</code> with <code>chalk[0]</code>.</li>
<li>Iterate through the chalk array from index <code>1</code> to <code>n-1</code> and update <code>prefixSum[i]</code> as the sum of <code>prefixSum[i-1]</code> and <code>chalk[i]</code>.</li>
<li>Calculate <code>sum</code> as <code>prefixSum[n-1]</code>, representing the total chalk needed for one full round.</li>
<li>Calculate <code>remainingChalk</code> as <code>k % sum</code>.</li>
<li>Call the helper function <code>binarySearch(prefixSum, remainingChalk)</code> to find the student who will run out of chalk and return the result of binarySearch.</li>
</ol>
<p>Helper Function - <code>binarySearch(arr, remainingChalk)</code></p>
<ol>
<li>Set <code>low</code> to 0 and <code>high</code> to arr.length - 1.</li>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate mid as the average of <code>low</code> and <code>high</code>.</li>
<li>If <code>arr[mid]</code> is less than or equal to <code>remainingChalk</code>, update <code>low to mid + 1</code>.</li>
<li>Otherwise, update <code>high</code> to <code>mid</code>.</li>
</ul>
</li>
<li>Return <code>high</code> as the index of the student who will run out of chalk.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9d8aK7JW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>chalk</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>chalk</code> array once. Apart from this, the binary search operation takes <span class="math inline">\(O(log n)\)</span> time. Therefore, the total time complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We initialize an array <code>prefixSum</code> of size <code>n</code> to store the prefix sums of the <code>chalk</code> array. Apart from this, no additional space is used. Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frequency-of-the-most-frequent-element/description" target="_blank" rel="noopener noreferrer">Frequency of the Most Frequent Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</p>

<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. In one operation, you can choose an index of <code>nums</code> and increment the element at that index by <code>1</code>.</p>

<p>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong> </em><code>k</code><em> operations</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4], k = 5
<strong>Output:</strong> 3<strong>
Explanation:</strong> Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,8,13], k = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,9,6], k = 2
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sliding-window">Approach 1: Sliding Window</h3>
<p><strong>Intuition</strong></p>
<p>In this problem, we want to make as many elements as we can equal using <code>k</code> increments.</p>
<p>Let's say that we choose a number <code>target</code> and want to maximize its frequency. Intuitively, the elements that we would increment would be the elements that are closest to <code>target</code> (and less than <code>target</code>, since we can only increment).</p>
<p>So what number should we choose for <code>target</code>? The optimal <code>target</code> will already exist in the array. Why?</p>
<ul>
<li>Assume <code>target</code> is in <code>nums</code>, but <code>target - 1</code> and <code>target + 1</code> are not in <code>nums</code>. Let's say that we can increment <code>x</code> elements to be equal to <code>target</code> using at most <code>k</code> operations. We will prove that making <code>target - 1</code> or <code>target + 1</code> the most frequent element does not lead to better results.</li>
</ul>
<p><img src="../Figures/1838/1.png" alt="example" /><br />
<br></p>
<ul>
<li>It would be pointless to instead try to make <code>target + 1</code> the most frequent element, since this would cost us <code>x</code> extra operations and we would not improve on our answer. The same goes for even larger elements <code>target + 2</code> and etc.</li>
</ul>
<p><img src="../Figures/1838/2.png" alt="example" /><br />
<br></p>
<ul>
<li>What about <code>target - 1</code>? Compared with making <code>target</code> the most frequent element, we would lose the values representing these <code>target</code>s from our max frequency, but we would save <code>x</code> operations which we could potentially use to increment more than one extra element and thus improve our answer.</li>
</ul>
<p><img src="../Figures/1838/3.png" alt="example" /><br />
<br></p>
<ul>
<li>The above statement is true, but meaningless! Consider the greatest element in <code>nums</code> that is less than <code>target</code>. That is, if we were to sort <code>nums</code>, consider the element that comes right before <code>target</code>. If we were to instead consider this element as the target, we would save more than <code>x</code> operations without negatively affecting the frequency relative to considering <code>target - 1</code>.</li>
</ul>
<p><img src="../Figures/1838/4.png" alt="example" /><br />
<br></p>
<ul>
<li>In summary, for any given number <code>absent</code> that is not in <code>nums</code>, consider the greatest number in <code>nums</code> smaller than <code>absent</code> as <code>smallerTarget</code>. The number of operations to raise some number of elements to <code>smallerTarget</code> will always be less than the number of steps needed to raise them to <code>absent</code>.</li>
<li>Thus, the optimal value of <code>target</code> must exist in <code>nums</code>. We can iterate over <code>nums</code> and consider each element as <code>target</code>.</li>
</ul>
<p>For a given value of <code>target</code>, how can we efficiently check the frequency we could achieve? As we mentioned at the start, we would want to increment elements that are closest to <code>target</code>. As such, we will start by sorting <code>nums</code> so that as we iterate over the elements, we know the elements closest to <code>target</code> are just to the left of <code>target</code>.</p>
<p>Now that <code>nums</code> is sorted, consider the first element to the left of <code>target</code> as <code>smaller</code>. As <code>smaller</code> is the closest element to <code>target</code>, we want to increment it to equal <code>target</code>. This will cost us <code>target - smaller</code> operations. Now, consider the next element to the left as <code>smaller2</code>. Now this is the element closest to <code>target</code>, so we increment it using <code>target - smaller2</code> operations. We continue this process until we run out of operations.</p>
<p>As you can see, the number of operations required is simply the difference between <code>target</code> and the numbers we are incrementing. Let's say that the final frequency of <code>target</code> was <code>4</code>. We would have a sum of <code>4 * target</code>. The number of operations would be this sum minus the sum of the elements before we incremented them. Consider the following example:</p>
<p><img src="../Figures/1838/5.png" alt="example" /><br />
<br></p>
<blockquote>
<p>If you aren't already familiar with the sliding window technique, we highly recommend reading <a href="https://leetcode.com/explore/interview/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/">this free article</a> from LeetCode's official DSA course, where sliding window is explained in detail with multiple examples.</p>
</blockquote>
<p>This brings us to our solution. We will use a sliding window over the sorted <code>nums</code>. For each element <code>nums[right]</code>, we will treat <code>target</code> as this element and try to make every element in our window equal to <code>target</code>.</p>
<p>The size of the window is <code>right - left + 1</code>. That means we would have a final sum of <code>(right - left + 1) * target</code>. If we track the sum of our window in a variable <code>curr</code>, then we can calculate the required operations as <code>(right - left + 1) * target - curr</code>. If it requires more than <code>k</code> operations, we must shrink our window. Like in all sliding window problems, we will use a <code>while</code> loop to shrink our window by incrementing <code>left</code> until <code>k</code> operations are sufficient.</p>
<p>Once the <code>while</code> loop ends, we know that we can make all elements in the window equal to <code>target</code>. We can now update our answer with the current window size. The final answer will be the largest valid window we find after iterating <code>right</code> over the entire input.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>nums</code>.</li>
<li>Initialize the following integers:
<ul>
<li><code>left = 0</code>, the left pointer.</li>
<li><code>ans = 0</code>, the best answer we have seen so far.</li>
<li><code>curr = 0</code>, the sum of the elements currently in our window.</li>
</ul>
</li>
<li>Iterate <code>right</code> over the indices of <code>nums</code>:
<ul>
<li>Consider <code>target = nums[right]</code>.</li>
<li>Add <code>target</code> to <code>curr</code>.</li>
<li>While the size of the window <code>right - left + 1</code> multiplied by <code>target</code>, minus <code>curr</code> is greater than <code>k</code>:
<ul>
<li>Subtract <code>nums[left]</code> from <code>curr</code>.</li>
<li>Increment <code>left</code>.</li>
</ul>
</li>
<li>Update <code>ans</code> with the current window size if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Be careful! Given the constraints, we may run into integer overflow. Use <code>long</code> accordingly in Java and C++ (Python doesn't have overflow).</p>
</blockquote>
<p><a href="https://leetcode.com/playground/3sv7JbQ8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Despite the while loop, each iteration of the for loop is amortized <span class="math inline">\(O(1)\)</span>. The while loop only runs <span class="math inline">\(O(n)\)</span> times across all iterations. This is because each iteration of the while loop increments <code>left</code>. As <code>left</code> can only increase and cannot exceed <code>n</code>, the while loop never performs more than <code>n</code> iterations total. This means the sliding window process runs in <span class="math inline">\(O(n)\)</span>.</p>
<p>However, we need to sort the array, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>We only use a few integer variables, but some space is used to sort.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-advanced-sliding-window">Approach 2: Advanced Sliding Window</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is an extension of the previous one.</p>
</blockquote>
<p>Notice that the only thing we care about is the <strong>length</strong> of the longest window. We don't need to know what the window itself is. As we slide the window over the array, let's say we find a valid window with a length of <code>len</code>. <strong>We no longer care about any windows with lengths less than <code>len</code></strong>, because they could not possibly improve on our answer.</p>
<p>The purpose of the while loop in the previous approach is to shrink the window until it is valid again. In this approach, we will not shrink the window - we will just try to grow it as large as we can.</p>
<p>We will keep the same condition in the while loop that checks if the current window <code>[left, right]</code> is valid, but instead of using a while loop, we will just use an if statement. This means <code>left</code> never increases by more than <code>1</code> per iteration. Because <code>right</code> also increases by <code>1</code> per iteration, if we cannot find a valid window, we will simply be sliding a window with static size across the array.</p>
<p>However, if we add an element <code>nums[right]</code> to the window and the window is valid, then the if statement will not trigger, and <code>left</code> will not be incremented. Thus, we will increase our window size by <code>1</code>. In this scenario, it implies the current window <code>[left, right]</code> is the best window we have seen so far.</p>
<blockquote>
<p>As you can see, it is actually impossible for our window size to decrease, since each iteration increases <code>right</code> by <code>1</code> and <code>left</code> by either <code>0</code> or <code>1</code>.</p>
</blockquote>
<p>Because our window size cannot decrease, it also means that the size of the window always represents the length of the best window we have found so far - analogous to <code>ans</code> from the previous approach.</p>
<p>At the end of the iteration, the size of our window is <code>n - left</code>. We return this as the answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>nums</code>.</li>
<li>Initialize the following integers:
<ul>
<li><code>left = 0</code>, the left pointer.</li>
<li><code>curr = 0</code>, the sum of the elements currently in our window.</li>
</ul>
</li>
<li>Iterate <code>right</code> over the indices of <code>nums</code>:
<ul>
<li>Consider <code>target = nums[right]</code>.</li>
<li>Add <code>target</code> to <code>curr</code>.</li>
<li>If the size of the window <code>right - left + 1</code> multiplied by <code>target</code>, minus <code>curr</code> is greater than <code>k</code>:
<ul>
<li>Subtract <code>nums[left]</code> from <code>curr</code>.</li>
<li>Increment <code>left</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>nums.length - left</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/PxgSPnTe/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>Each iteration of the for loop costs <span class="math inline">\(O(1)\)</span>. This means the sliding window process runs in <span class="math inline">\(O(n)\)</span>.</p>
<p>However, we need to sort the array, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(\log n)\)</span> or <span class="math inline">\(O(n)\)</span></p>
<p>We only use a few integer variables, but some space is used to sort.</p>
<p>The space complexity of the sorting algorithm depends on the implementation of each programming language:</p>
<ul>
<li>In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of <span class="math inline">\(O(\log n)\)</span></li>
<li>In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of <span class="math inline">\(O(n)\)</span></li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-binary-search">Approach 3: Binary Search</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Note: the previous two approaches are the optimal solutions and are sufficient to solve the problem. Here, we will look at another unique way to approach the problem for the sake of completeness.</p>
</blockquote>
<p>Given an index <code>i</code>, if we treat <code>nums[i]</code> as <code>target</code>, we are concerned with how many elements on the left we can take. In the earlier approaches, we used a sliding window. In this approach, we will directly find the left-most index of these elements using binary search.</p>
<p>Let's say that <code>best</code> is the index of the furthest element to the left that we could increment to <code>target = nums[i]</code>. Note that here, <code>best</code> is analogous to what <code>left</code> was after the while loop finished in the first approach. How do we find <code>best</code>?</p>
<p>The value of <code>best</code> must be in the range <code>[0, i]</code>. We will perform a binary search on this range. For a given index <code>mid</code>:</p>
<ul>
<li>The number of elements in the window would be <code>count = i - mid + 1</code>.</li>
<li>Thus, the final sum after making every element in the window equal to <code>target</code> would be <code>finalSum = count * target</code>.</li>
<li>The original sum of the elements is the sum of the elements from index <code>mid</code> to index <code>i</code>. We can use a prefix sum to find this <code>originalSum</code>.</li>
<li>Thus, the number of operations we need is <code>operationsRequired = finalSum - originalSum</code>.</li>
<li>If <code>operationsRequired &gt; k</code>, it's impossible to include the index <code>mid</code>. We update <code>left = mid + 1</code>.</li>
<li>Otherwise, the task is possible and we should look for a better index. We update <code>best = mid</code> and <code>right = mid - 1</code>.</li>
</ul>
<p>Essentially, we are binary searching the left bound from the first approach for a given right bound <code>i</code>. If we pre-process a prefix sum, then for each <code>mid</code>, we have all the necessary information to find <code>operationsRequired</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>check(i)</code>:
<ul>
<li>Initialize the following integers:
<ul>
<li><code>target = nums[i]</code>, the current target.</li>
<li><code>left = 0</code>, the left bound of the binary search.</li>
<li><code>right = i</code>, the right bound of the binary search.</li>
<li><code>best = i</code>, the best (furthest left) index that we can increment to <code>target</code>.</li>
</ul>
</li>
<li>While <code>left &lt;= right</code>
<ul>
<li>Calculate <code>mid = (left + right) / 2</code>.</li>
<li>Calculate <code>count = i - mid + 1</code>.</li>
<li>Calculate <code>finalSum = count * target</code>.</li>
<li>Calculate <code>originalSum = prefix[i] - prefix[mid] + nums[mid]</code>.</li>
<li>Calculate <code>operationsRequired = finalSum - originalSum</code>.</li>
<li>If <code>operationsRequired &gt; k</code>, move <code>left = mid + 1</code>.</li>
<li>Otherwise, update <code>best = mid</code> and <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Return <code>i - best + 1</code>.</li>
</ul>
</li>
<li>Sort <code>nums</code>.</li>
<li>Create a <code>prefix</code> sum of <code>nums</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>Update <code>ans</code> with <code>check(i)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Be careful! Given the constraints, we may run into integer overflow. Use <code>long</code> accordingly in Java and C++ (Python doesn't have overflow).</p>
</blockquote>
<p><a href="https://leetcode.com/playground/RszUgWwH/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>First, we sort <code>nums</code> which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we iterate over the indices of <code>nums</code>. For each of the <span class="math inline">\(O(n)\)</span> indices, we call <code>check</code>, which costs up to <span class="math inline">\(O(\log{}n)\)</span> as its a binary search over the array's elements. The total cost is <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>prefix</code> array uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/description" target="_blank" rel="noopener noreferrer">Get Biggest Three Rhombus Sums in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>â€‹â€‹â€‹.</p>

<p>A <strong>rhombus sum</strong> is the sum of the elements that form <strong>the</strong> <strong>border</strong> of a regular rhombus shape in <code>grid</code>â€‹â€‹â€‹. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each <strong>rhombus sum</strong>:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png" style="width: 385px; height: 385px;" />
<p>Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.</p>

<p>Return <em>the biggest three <strong>distinct rhombus sums</strong> in the </em><code>grid</code><em> in <strong>descending order</strong></em><em>. If there are less than three distinct values, return all of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png" style="width: 360px; height: 361px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
<strong>Output:</strong> [228,216,211]
<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 20 + 3 + 200 + 5 = 228
- Red: 200 + 2 + 10 + 4 = 216
- Green: 5 + 200 + 4 + 2 = 211
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png" style="width: 217px; height: 217px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [20,9,8]
<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 4 + 2 + 6 + 8 = 20
- Red: 9 (area 0 rhombus in the bottom right corner)
- Green: 8 (area 0 rhombus in the bottom middle)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[7,7,7]]
<strong>Output:</strong> [7]
<strong>Explanation:</strong> All three possible rhombus sums are the same, so return [7].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-equal-substrings-within-budget/description" target="_blank" rel="noopener noreferrer">Get Equal Substrings Within Budget</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code> of the same length and an integer <code>maxCost</code>.</p>

<p>You want to change <code>s</code> to <code>t</code>. Changing the <code>i<sup>th</sup></code> character of <code>s</code> to <code>i<sup>th</sup></code> character of <code>t</code> costs <code>|s[i] - t[i]|</code> (i.e., the absolute difference between the ASCII values of the characters).</p>

<p>Return <em>the maximum length of a substring of </em><code>s</code><em> that can be changed to be the same as the corresponding substring of </em><code>t</code><em> with a cost less than or equal to </em><code>maxCost</code>. If there is no substring from <code>s</code> that can be changed to its corresponding substring from <code>t</code>, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> &quot;abc&quot; of s can change to &quot;bcd&quot;.
That costs 3, so the maximum length is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each character in s costs 2 to change to character in t,  so the maximum length is 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> You cannot make any change, so the maximum length is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>t.length == s.length</code></li>
	<li><code>0 &lt;= maxCost &lt;= 10<sup>6</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given two strings, <code>s</code> and <code>t</code>, of the same length, <code>N</code>. In one operation, we can choose an index <code>i</code> and convert the character <code>s[i]</code> to <code>t[i]</code>; the cost of this operation will be <code>|s[i] - t[i]|</code>. We can perform as many operations as we want as long as the total cost of all operations is less than or equal to <code>maxCost</code>. We need to return the maximum length of a substring in <code>s</code> that can be converted to the corresponding substring in <code>t</code>.</p>
<p>The naive way to solve this problem is to generate all substrings of <code>s</code> and their corresponding substring in <code>t</code>. Then, find the cost of converting each substring from <code>s</code> to <code>t</code>. If the cost is less than <code>maxCost</code>, then we can update the maximum length with the current substring length. However, this approach is inefficient as we would need to use nested loops to generate each substring and find the cost, leading to a time complexity of <span class="math inline">\(O(N^3)\)</span>.</p>
<p>The key observation here is that we can only apply one operation at a given index of strings <code>s</code> and <code>t</code>; i.e., we can only convert the character <code>s[i]</code> to <code>t[i]</code> and not any other index of <code>t</code>. If we create a new costs array with the value at the <code>ith</code> index as <code>s[i] - t[i]</code>, then the problem transforms to finding the maximum subarray with a sum less than or equal to <code>maxCost</code>. This is because each index in this new array is the cost of converting the <code>ith</code> character in <code>s</code> to <code>t</code>. Thus, the sum of the subarray is the total cost of converting the substring in <code>s</code> to <code>t</code>.</p>
<p>This is somewhat similar to the problem <a href="https://leetcode.com/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a> that can be solved using a sliding window. The sliding window pattern is applicable when the problem involves achieving a goal using subarrays or substrings, and individual elements cannot be independently selected. The concept behind the sliding window pattern is to maintain a window that meets the condition by continuously expanding from the right. If the condition ceases to be met, we adjust the window by shrinking it from the left until the condition is met again.</p>
<p>To save space, we can apply the sliding window pattern to track the cost of the substrings instead of creating a separate cost array. We use the variable <code>start</code> to track the left end of the window and <code>i</code> to track the right end. The condition is when the cost of the current window is less than or equal to the <code>maxCost</code>.</p>
<p>We can process <code>s</code> using a sliding window. We will keep adding the element on the right to the current cost, <code>currCost</code>. If the <code>currCost</code> becomes more than the <code>maxCost</code>, we will remove the elements from the left end. Then, we can compare the length of the current substring (from the left end <code>start</code> to the current index <code>i</code>) with the maximum length we have found so far and update the variable <code>maxLen</code> accordingly.</p>
<p>!?!../Documents/1208-re/1208_Get_Equal_Substrings_Within_Budget.json:960,720!?! <br></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the variables:</p>
<ul>
<li><code>maxLen</code> to <code>0</code>'; this will be the maximum length of a substring with a cost less than or equal to <code>maxCost</code> we have seen so far.</li>
<li><code>start</code> to <code>0</code>; this is the left end of the current substring.</li>
<li><code>currCost</code> to <code>0</code>; this will be the cost of converting the current window substring in <code>s</code> to <code>t</code>.</li>
</ul>
</li>
<li>
<p>Iterate over the indices from <code>0</code> to <code>N - 1</code> and for each index <code>i</code>:</p>
<ul>
<li>Add the cost to convert <code>s[i]</code> to <code>t[i]</code> to the variable <code>currCost</code></li>
<li>Keep removing the elements from the left end by decrementing the cost required for the character at index <code>start</code> until <code>currCost</code> becomes less than or equal to <code>maxCost</code>.</li>
<li>Compare the length of the current window <code>i - start + 1</code> with the <code>maxLen</code> and update it accordingly.</li>
</ul>
</li>
<li>
<p>Return <code>maxLen</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VT832uwv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the length of the strings <code>s</code> and <code>t</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will process each index of <code>s</code> and <code>t</code> at most twice. This is because we iterate over the character while extending the window from the right side, and again while contracting the window from the left end. Therefore, the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not need any extra space apart from some variables, and hence, the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/grid-game/description" target="_blank" rel="noopener noreferrer">Grid Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D array <code>grid</code> of size <code>2 x n</code>, where <code>grid[r][c]</code> represents the number of points at position <code>(r, c)</code> on the matrix. Two robots are playing a game on this matrix.</p>

<p>Both robots initially start at <code>(0, 0)</code> and want to reach <code>(1, n-1)</code>. Each robot may only move to the <strong>right</strong> (<code>(r, c)</code> to <code>(r, c + 1)</code>) or <strong>down </strong>(<code>(r, c)</code> to <code>(r + 1, c)</code>).</p>

<p>At the start of the game, the <strong>first</strong> robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting all the points from the cells on its path. For all cells <code>(r, c)</code> traversed on the path, <code>grid[r][c]</code> is set to <code>0</code>. Then, the <strong>second</strong> robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting the points on its path. Note that their paths may intersect with one another.</p>

<p>The <strong>first</strong> robot wants to <strong>minimize</strong> the number of points collected by the <strong>second</strong> robot. In contrast, the <strong>second </strong>robot wants to <strong>maximize</strong> the number of points it collects. If both robots play <strong>optimally</strong>, return <em>the <b>number of points</b> collected by the <strong>second</strong> robot.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a1.png" style="width: 388px; height: 103px;" />
<pre>
<strong>Input:</strong> grid = [[2,5,4],[1,5,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a2.png" style="width: 384px; height: 105px;" />
<pre>
<strong>Input:</strong> grid = [[3,3,1],[8,5,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a3.png" style="width: 493px; height: 103px;" />
<pre>
<strong>Input:</strong> grid = [[1,3,1,15],[1,3,3,1]]
<strong>Output:</strong> 7
<strong>Explanation: </strong>The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == 2</code></li>
	<li><code>n == grid[r].length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[r][c] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a matrix <code>grid</code> containing 2 rows and <code>n</code> columns. Each cell contains a value representing the number of points for that cell in the <code>grid</code>. Two robots are playing a game where they are initially positioned at <code>(0, 0)</code> and aim to reach <code>(1, n - 1)</code>.</p>
<p>Each robot can only move right or down in the grid. The task is to compute the points collected by the second robot, given the strategies of both robots.</p>
<p>The challenge is that the first robot moves first, and its goal is to reduce the points available for the second robot. The second robot then takes the best path to collect as many points as possible.</p>
<hr />
<h3 id="approach-prefix-and-suffix-sum">Approach: Prefix and Suffix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>A key observation from the overview is that the number of opportunities the second robot has to move to the bottom row corresponds to the number of columns in the grid. When the first robot collects all the points on its way, it leaves a pattern of <code>0</code>-valued cells behind. The pattern looks like this: there will be some <code>0</code>-valued consecutive cells (possibly none) in the first row, two <code>0</code>-valued cells in the same column where it moves to the bottom row, and the remaining cells in the bottom row are also <code>0</code>-valued. This creates a &quot;cut&quot; through the grid where the first robot has moved, leaving the rest of the grid available for the second robot.</p>
<p><img src="../Figures/2017/Turn_image.png" alt="example" /></p>
<p>Now, consider the choices left for the second robot:</p>
<ul>
<li>
<p>The second robot must now choose how to move, given that parts of the grid are now blocked by the first robot's path. If the second robot moves to the second row at a point further down than where the first robot turned, it will need to collect points from the first row from that point onward. Since the bottom row is already collected, the optimal strategy for the second robot will be to collect points from the remaining cells of the top row before it reaches its target.</p>
</li>
<li>
<p>Alternatively, the second robot could move to the second row at the first column and collect all the points in the second row until it reaches the point where the first robot made its turn.</p>
</li>
</ul>
<p>Refer to the image provided for better understanding:</p>
<p><img src="../Figures/2017/image2.png" alt="example" /></p>
<p>To summarize, we have only two possibilities for the second robot, assuming the first robot moves to the next row at index <code>turnIndex</code>:</p>
<ul>
<li>Option 1: Collect all points in the first row after the point where the first robot moved down.</li>
<li>Option 2: Collect all points in the second row before the point where the first robot moved down.</li>
</ul>
<p>To optimize the second robot's decision-making, we maintain two running sums:</p>
<ul>
<li><code>firstRowSum</code>: The sum of points in the first row, initially set to the sum of all the points in the first row.</li>
<li><code>secondRowSum</code>: The sum of points in the second row, initially set to the sum of all the points in the second row.</li>
</ul>
<p>As we iterate through all possible values for the first robotâ€™s turn (<code>turnIndex</code>), we adjust these sums to reflect the points the second robot can collect based on its own movement strategy. Specifically:</p>
<ol>
<li>For each <code>turnIndex</code>, calculate the sum of points the second robot would collect if it follows <em>Option 1</em> (from the first row after the <code>turnIndex</code>).</li>
<li>Alternatively, calculate the sum if it follows <em>Option 2</em> (from the second row before the <code>turnIndex</code>).</li>
</ol>
<p>Finally, we compute the smallest value among the largest outcomes of these two strategies (because the goal is to reduce the highest possible points the second robot can collect).</p>
<blockquote>
<p>Notice that the problem is not the same as finding the highest number of points the first robot can collect. For example, if <code>grid = [[2, 4, 6], [8, 9, 10]]</code>, the first robot could take the path <code>2 -&gt; 8 -&gt; 9 -&gt; 10</code> to maximize its points, leaving <code>4</code> and <code>6</code> for the second robot. But the better strategy is for the first robot to turn down at index <code>1</code>, leaving either <code>6</code> or <code>8</code> for the second robot, which would then get <code>max(6, 8) = 8</code> points instead of <code>10</code>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>firstRowSum</code> with the sum of all elements in the first row of <code>grid</code>. Initialize <code>secondRowSum</code> as <code>0</code>.</p>
</li>
<li>
<p>Set <code>minimumSum</code> to a very large value (<code>LONG_LONG_MAX</code>).</p>
</li>
<li>
<p>Iterate through the indices of the first row:</p>
<ul>
<li>Subtract the current element of the first row from <code>firstRowSum</code>.</li>
<li>Calculate the maximum value between <code>firstRowSum</code> and <code>secondRowSum</code>; This would be the highest number of points the second robot can get if the first robot turns down at the current index.</li>
<li>Update <code>minimumSum</code> with the smaller value between <code>minimumSum</code> and the calculated maximum.</li>
<li>Add the current element of the second row to <code>secondRowSum</code>.</li>
</ul>
</li>
<li>
<p>Return <code>minimumSum</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4JkwKvH/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through each column of the <code>grid</code> exactly once. For each column, it updates the sums of the first and second rows and computes the minimum of the maximum values. These operations take constant time for each column. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, including variables for <code>firstRowSum</code>, <code>secondRowSum</code>, and <code>minimumSum</code>. No additional data structures proportional to the size of the input are used. Thus, the overall space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increment-submatrices-by-one/description" target="_blank" rel="noopener noreferrer">Increment Submatrices by One</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code>, indicating that we initially have an <code>n x n</code>&nbsp;<strong>0-indexed</strong> integer matrix <code>mat</code> filled with zeroes.</p>

<p>You are also given a 2D integer array <code>query</code>. For each <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code>, you should do the following operation:</p>

<ul>
	<li>Add <code>1</code> to <strong>every element</strong> in the submatrix with the <strong>top left</strong> corner <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> and the <strong>bottom right</strong> corner <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code>. That is, add <code>1</code> to <code>mat[x][y]</code> for all <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> and <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code>.</li>
</ul>

<p>Return<em> the matrix</em> <code>mat</code><em> after performing every query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example11.png" style="width: 531px; height: 121px;" />
<pre>
<strong>Input:</strong> n = 3, queries = [[1,1,2,2],[0,0,1,1]]
<strong>Output:</strong> [[1,1,0],[1,2,1],[0,1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example22.png" style="width: 261px; height: 82px;" />
<pre>
<strong>Input:</strong> n = 2, queries = [[0,0,1,1]]
<strong>Output:</strong> [[1,1],[1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>
	<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intervals-between-identical-elements/description" target="_blank" rel="noopener noreferrer">Intervals Between Identical Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <code>n</code> integers <code>arr</code>.</p>

<p>The <strong>interval</strong> between two elements in <code>arr</code> is defined as the <strong>absolute difference</strong> between their indices. More formally, the <strong>interval</strong> between <code>arr[i]</code> and <code>arr[j]</code> is <code>|i - j|</code>.</p>

<p>Return <em>an array</em> <code>intervals</code> <em>of length</em> <code>n</code> <em>where</em> <code>intervals[i]</code> <em>is <strong>the sum of intervals</strong> between </em><code>arr[i]</code><em> and each element in </em><code>arr</code><em> with the same value as </em><code>arr[i]</code><em>.</em></p>

<p><strong>Note:</strong> <code>|x|</code> is the absolute value of <code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,3,1,2,3,3]
<strong>Output:</strong> [4,2,7,2,4,4,5]
<strong>Explanation:</strong>
- Index 0: Another 2 is found at index 4. |0 - 4| = 4
- Index 1: Another 1 is found at index 3. |1 - 3| = 2
- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7
- Index 3: Another 1 is found at index 1. |3 - 1| = 2
- Index 4: Another 2 is found at index 0. |4 - 0| = 4
- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4
- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,5,10,10]
<strong>Output:</strong> [5,0,3,4]
<strong>Explanation:</strong>
- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5
- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.
- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3
- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/sum-of-distances/description/" target="_blank"> 2615: Sum of Distances.</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/jump-game-vii/description" target="_blank" rel="noopener noreferrer">Jump Game VII</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> binary string <code>s</code> and two integers <code>minJump</code> and <code>maxJump</code>. In the beginning, you are standing at index <code>0</code>, which is equal to <code>&#39;0&#39;</code>. You can move from index <code>i</code> to index <code>j</code> if the following conditions are fulfilled:</p>

<ul>
	<li><code>i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1)</code>, and</li>
	<li><code>s[j] == &#39;0&#39;</code>.</li>
</ul>

<p>Return <code>true</code><i> if you can reach index </i><code>s.length - 1</code><i> in </i><code>s</code><em>, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;<u>0</u>11<u>0</u>1<u>0</u>&quot;, minJump = 2, maxJump = 3
<strong>Output:</strong> true
<strong>Explanation:</strong>
In the first step, move from index 0 to index 3. 
In the second step, move from index 3 to index 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;01101110&quot;, minJump = 2, maxJump = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>s[0] == &#39;0&#39;</code></li>
	<li><code>1 &lt;= minJump &lt;= maxJump &lt; s.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-magic-square/description" target="_blank" rel="noopener noreferrer">Largest Magic Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <code>k x k</code> <strong>magic square</strong> is a <code>k x k</code> grid filled with integers such that every row sum, every column sum, and both diagonal sums are <strong>all equal</strong>. The integers in the magic square <strong>do not have to be distinct</strong>. Every <code>1 x 1</code> grid is trivially a <strong>magic square</strong>.</p>

<p>Given an <code>m x n</code> integer <code>grid</code>, return <em>the <strong>size</strong> (i.e., the side length </em><code>k</code><em>) of the <strong>largest magic square</strong> that can be found within this grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg" style="width: 413px; height: 335px;" />
<pre>
<strong>Input:</strong> grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The largest magic square has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg" style="width: 333px; height: 255px;" />
<pre>
<strong>Input:</strong> grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-rectangular-sub-matrix-whose-sum-is-0/1" target="_blank" rel="noopener noreferrer">Largest rectangular sub-matrix whose sum is 0</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a matrix <strong>mat[][]</strong>. Find the size of the largest sub-matrix whose <strong>sum</strong> is equal to <strong>zero</strong>. The size of a matrix is the product of rows and columns. A sub-matrix is a matrix obtained from the given matrix by deletion of several (possibly, zero or all) rows/columns from the beginning and several (possibly, zero or all) rows/columns from the end.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"><span style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;"><strong>Input: </strong>mat[][] = [[9, 7, 16, 5], [1, -6, -7, 3], [1, 8, 7, 9], [7, -2, 0, 10]] <strong>
Output: </strong>6<strong>
Explanation: <br /></strong></span></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/710026/Web/Other/blobid0_1736762643.png" alt="" width="488" height="432" /></span></pre>
<pre style="font-weight: 400;"><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] =  [[1, 2, 3], [-3, -2, -1], [1, 7, 5]]
<strong>Output:</strong>  6
<strong>Explanation:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/710026/Web/Other/blobid1_1736762643.png" alt="" width="478" height="426" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> mat[][] = [[1, -1], [-1, 1]]
<strong>Output:</strong> 4<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> The largest sub-matrix with sum 0 is </span>[[1, -1], [-1, 1]].</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints</strong>:<br />1 &lt;= mat.size(), mat[0].size() &lt;= 100<br />-1000 &lt;= mat[][] &lt;= 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-square-with-sum-at-most-k/1" target="_blank" rel="noopener noreferrer">Largest Square with Sum at Most K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">mathematical</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a matrix <strong>mat[][]</strong> of size <strong>n*m</strong>&nbsp;and an integer <strong>k</strong>. Find the <strong>maximum </strong>length of a square submatrix having the <strong>sum </strong>of elements less than or equal to <strong>k</strong>. Return <strong>0</strong> if no such square exits.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><span style="font-size: 14pt;"><strong>Input: </strong></span><span style="font-size: 18.6667px;">k = 6,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 14pt;">mat[][]<strong> =</strong> </span><span style="font-size: 18.6667px;">[[1, 1, 1, 1],
          [1, 0, 0, 0],
          [1, 0, 0, 0],
          [1, 0, 0, 0]]<br /></span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">3</span><strong style="font-size: 14pt;"><br />Explanation: </strong><span style="font-size: 14pt;">S</span></span><span style="font-size: 18.6667px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">quare submatrix from (0, 0) to (2, 2) with sum 5 is one of the valid answer.</span></pre>
<pre><span style="font-size: 14pt;"><span style="font-size: 14pt;"><strong>Input: </strong></span><span style="font-size: 18.6667px;">k = 1,<br /></span><span style="font-size: 14pt;">mat[][] = </span><span style="font-size: 18.6667px;">[[2, 2, 2],
          [2, 2, 2],
          [2, 2, 2],
          [2, 2, 2]]</span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">0</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">There is no valid answer.</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &le; n &times; m &le; 10</span><span style="font-size: 14pt;"><sup>6</sup><br />-10<sup>5</sup> &le; mat[i][j] &le; 10<sup>5</sup><br />0 &le; k &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-sum-of-averages/description" target="_blank" rel="noopener noreferrer">Largest Sum of Averages</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You can partition the array into <strong>at most</strong> <code>k</code> non-empty adjacent subarrays. The <strong>score</strong> of a partition is the sum of the averages of each subarray.</p>

<p>Note that the partition must use every integer in <code>nums</code>, and that the score is not necessarily an integer.</p>

<p>Return <em>the maximum <strong>score</strong> you can achieve of all the possible partitions</em>. Answers within <code>10<sup>-6</sup></code> of the actual answer will be accepted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,1,2,3,9], k = 3
<strong>Output:</strong> 20.00000
<strong>Explanation:</strong> 
The best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.
We could have also partitioned nums into [9, 1], [2], [3, 9], for example.
That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 4
<strong>Output:</strong> 20.50000
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The best score partitioning <code>A[i:]</code> into at most <code>K</code> parts depends on answers to paritioning <code>A[j:]</code> (<code>j &gt; i</code>) into less parts.  We can use dynamic programming as the states form a directed acyclic graph.</p>
<p><strong>Algorithm</strong></p>
<p>Let <code>dp(i, k)</code> be the best score partioning <code>A[i:]</code> into at most <code>K</code> parts.</p>
<p>If the first group we partition <code>A[i:]</code> into ends before <code>j</code>, then our candidate partition has score <code>average(i, j) + dp(j, k-1))</code>, where <code>average(i, j) = (A[i] + A[i+1] + ... + A[j-1]) / (j - i)</code> (floating point division).  We take the highest score of these, keeping in mind we don't necessarily need to partition - <code>dp(i, k)</code> can also be just <code>average(i, N)</code>.</p>
<p>In total, our recursion in the general case is <code>dp(i, k) = max(average(i, N), max_{j &gt; i}(average(i, j) + dp(j, k-1)))</code>.</p>
<p>We can calculate <code>average</code> a little bit faster by remembering prefix sums.  If <code>P[x+1] = A[0] + A[1] + ... + A[x]</code>, then <code>average(i, j) = (P[j] - P[i]) / (j - i)</code>.</p>
<p>Our implementation showcases a &quot;bottom-up&quot; style of dp.  Here at loop number <code>k</code> in our outer-most loop, <code>dp[i]</code> represents <code>dp(i, k)</code> from the discussion above, and we are calculating the next layer <code>dp(i, k+1)</code>.  The end of our second loop <code>for i = 0..N-1</code> represents finishing the calculation of the correct value for <code>dp(i, t)</code>, and the inner-most loop performs the calculation <code>max_{j &gt; i}(average(i, j) + dp(j, k))</code>.</p>
<p><a href="https://leetcode.com/playground/EVHLr3KQ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(K * N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>A</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of <code>dp</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/left-and-right-sum-differences/description" target="_blank" rel="noopener noreferrer">Left and Right Sum Differences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code>.</p>

<p>Define two arrays <code>leftSum</code> and <code>rightSum</code> where:</p>

<ul>
	<li><code>leftSum[i]</code> is the sum of elements to the left of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>leftSum[i] = 0</code>.</li>
	<li><code>rightSum[i]</code> is the sum of elements to the right of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>rightSum[i] = 0</code>.</li>
</ul>

<p>Return an integer array <code>answer</code> of size <code>n</code> where <code>answer[i] = |leftSum[i] - rightSum[i]|</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,4,8,3]
<strong>Output:</strong> [15,1,11,22]
<strong>Explanation:</strong> The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-special-path/description" target="_blank" rel="noopener noreferrer">Longest Special Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected tree rooted at node <code>0</code> with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>length<sub>i</sub></code>. You are also given an integer array <code>nums</code>, where <code>nums[i]</code> represents the value at node <code>i</code>.</p>

<p>A <b data-stringify-type="bold">special path</b> is defined as a <b data-stringify-type="bold">downward</b> path from an ancestor node to a descendant node such that all the values of the nodes in that path are <b data-stringify-type="bold">unique</b>.</p>

<p><strong>Note</strong> that a path may start and end at the same node.</p>

<p>Return an array <code data-stringify-type="code">result</code> of size 2, where <code>result[0]</code> is the <b data-stringify-type="bold">length</b> of the <strong>longest</strong> special path, and <code>result[1]</code> is the <b data-stringify-type="bold">minimum</b> number of nodes in all <i data-stringify-type="italic">possible</i> <strong>longest</strong> special paths.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,2],[1,2,3],[1,3,5],[1,4,4],[2,5,6]], nums = [2,1,2,1,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[6,2]</span></p>

<p><strong>Explanation:</strong></p>

<h4>In the image below, nodes are colored by their corresponding values in <code>nums</code></h4>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/02/tree3.jpeg" style="width: 250px; height: 350px;" /></p>

<p>The longest special paths are <code>2 -&gt; 5</code> and <code>0 -&gt; 1 -&gt; 4</code>, both having a length of 6. The minimum number of nodes across all longest special paths is 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[1,0,8]], nums = [2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/02/tree4.jpeg" style="width: 190px; height: 75px;" /></p>

<p>The longest special paths are <code>0</code> and <code>1</code>, both having a length of 0. The minimum number of nodes across all longest special paths is 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style="font-size: 10.8333px;">4</span></sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>3</sup></code></li>
	<li><code>nums.length == n</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The input is generated such that <code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-special-path-ii/description" target="_blank" rel="noopener noreferrer">Longest Special Path II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected tree rooted at node <code>0</code>, with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. This is represented by a 2D array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code> indicates an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with length <code>length<sub>i</sub></code>. You are also given an integer array <code>nums</code>, where <code>nums[i]</code> represents the value at node <code>i</code>.</p>

<p>A <strong>special path</strong> is defined as a <strong>downward</strong> path from an ancestor node to a descendant node in which all node values are <strong>distinct</strong>, except for <strong>at most</strong> one value that may appear twice.</p>

<p>Return an array <code data-stringify-type="code">result</code> of size 2, where <code>result[0]</code> is the <b data-stringify-type="bold">length</b> of the <strong>longest</strong> special path, and <code>result[1]</code> is the <b data-stringify-type="bold">minimum</b> number of nodes in all <i data-stringify-type="italic">possible</i> <strong>longest</strong> special paths.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,1],[1,2,3],[1,3,1],[2,4,6],[4,7,2],[3,5,2],[3,6,5],[6,8,3]], nums = [1,1,0,3,1,2,1,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[9,3]</span></p>

<p><strong>Explanation:</strong></p>

<p>In the image below, nodes are colored by their corresponding values in <code>nums</code>.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/02/18/e1.png" style="width: 190px; height: 270px;" /></p>

<p>The longest special paths are <code>1 -&gt; 2 -&gt; 4</code> and <code>1 -&gt; 3 -&gt; 6 -&gt; 8</code>, both having a length of 9. The minimum number of nodes across all longest special paths is 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[1,0,3],[0,2,4],[0,3,5]], nums = [1,1,0,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[5,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/02/18/e2.png" style="width: 150px; height: 110px;" /></p>

<p>The longest path is <code>0 -&gt; 3</code> consisting of 2 nodes with a length of 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style="font-size: 10.8333px;">4</span></sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>3</sup></code></li>
	<li><code>nums.length == n</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The input is generated such that <code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-subsequence-with-limited-sum/description" target="_blank" rel="noopener noreferrer">Longest Subsequence With Limited Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code>, and an integer array <code>queries</code> of length <code>m</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>m</code><em> where </em><code>answer[i]</code><em> is the <strong>maximum</strong> size of a <strong>subsequence</strong> that you can take from </em><code>nums</code><em> such that the <strong>sum</strong> of its elements is less than or equal to </em><code>queries[i]</code>.</p>

<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,2,1], queries = [3,10,21]
<strong>Output:</strong> [2,3,4]
<strong>Explanation:</strong> We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,5], queries = [1]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-well-performing-interval/description" target="_blank" rel="noopener noreferrer">Longest Well-Performing Interval</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>hours</code>, a list of the number of hours worked per day for a given employee.</p>

<p>A day is considered to be a <em>tiring day</em> if and only if the number of hours worked is (strictly) greater than <code>8</code>.</p>

<p>A <em>well-performing interval</em> is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</p>

<p>Return the length of the longest well-performing interval.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> hours = [9,9,6,0,6,6,9]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The longest well-performing interval is [9,9,6].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> hours = [6,6,6]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= hours.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= hours[i] &lt;= 16</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-array-elements-equal-to-zero/description" target="_blank" rel="noopener noreferrer">Make Array Elements Equal to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>.</p>

<p>Start by selecting a starting position <code>curr</code> such that <code>nums[curr] == 0</code>, and choose a movement <strong>direction</strong> of&nbsp;either left or right.</p>

<p>After that, you repeat the following process:</p>

<ul>
	<li>If <code>curr</code> is out of the range <code>[0, n - 1]</code>, this process ends.</li>
	<li>If <code>nums[curr] == 0</code>, move in the current direction by <strong>incrementing</strong> <code>curr</code> if you are moving right, or <strong>decrementing</strong> <code>curr</code> if you are moving left.</li>
	<li>Else if <code>nums[curr] &gt; 0</code>:
	<ul>
		<li>Decrement <code>nums[curr]</code> by 1.</li>
		<li><strong>Reverse</strong>&nbsp;your movement direction (left becomes right and vice versa).</li>
		<li>Take a step in your new direction.</li>
	</ul>
	</li>
</ul>

<p>A selection of the initial position <code>curr</code> and movement direction is considered <strong>valid</strong> if every element in <code>nums</code> becomes 0 by the end of the process.</p>

<p>Return the number of possible <strong>valid</strong> selections.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,0,2,0,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible valid selections are the following:</p>

<ul>
	<li>Choose <code>curr = 3</code>, and a movement direction to the left.

	<ul>
		<li><code>[1,0,2,<strong><u>0</u></strong>,3] -&gt; [1,0,<strong><u>2</u></strong>,0,3] -&gt; [1,0,1,<strong><u>0</u></strong>,3] -&gt; [1,0,1,0,<strong><u>3</u></strong>] -&gt; [1,0,1,<strong><u>0</u></strong>,2] -&gt; [1,0,<strong><u>1</u></strong>,0,2] -&gt; [1,0,0,<strong><u>0</u></strong>,2] -&gt; [1,0,0,0,<strong><u>2</u></strong>] -&gt; [1,0,0,<strong><u>0</u></strong>,1] -&gt; [1,0,<strong><u>0</u></strong>,0,1] -&gt; [1,<strong><u>0</u></strong>,0,0,1] -&gt; [<strong><u>1</u></strong>,0,0,0,1] -&gt; [0,<strong><u>0</u></strong>,0,0,1] -&gt; [0,0,<strong><u>0</u></strong>,0,1] -&gt; [0,0,0,<strong><u>0</u></strong>,1] -&gt; [0,0,0,0,<strong><u>1</u></strong>] -&gt; [0,0,0,0,0]</code>.</li>
	</ul>
	</li>
	<li>Choose <code>curr = 3</code>, and a movement direction to the right.
	<ul>
		<li><code>[1,0,2,<strong><u>0</u></strong>,3] -&gt; [1,0,2,0,<strong><u>3</u></strong>] -&gt; [1,0,2,<strong><u>0</u></strong>,2] -&gt; [1,0,<strong><u>2</u></strong>,0,2] -&gt; [1,0,1,<strong><u>0</u></strong>,2] -&gt; [1,0,1,0,<strong><u>2</u></strong>] -&gt; [1,0,1,<strong><u>0</u></strong>,1] -&gt; [1,0,<strong><u>1</u></strong>,0,1] -&gt; [1,0,0,<strong><u>0</u></strong>,1] -&gt; [1,0,0,0,<strong><u>1</u></strong>] -&gt; [1,0,0,<strong><u>0</u></strong>,0] -&gt; [1,0,<strong><u>0</u></strong>,0,0] -&gt; [1,<strong><u>0</u></strong>,0,0,0] -&gt; [<strong><u>1</u></strong>,0,0,0,0] -&gt; [0,0,0,0,0].</code></li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4,0,4,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>There are no possible valid selections.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
	<li>There is at least one element <code>i</code> where <code>nums[i] == 0</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-sum-divisible-by-p/description" target="_blank" rel="noopener noreferrer">Make Sum Divisible by P</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of positive integers <code>nums</code>, remove the <strong>smallest</strong> subarray (possibly <strong>empty</strong>) such that the <strong>sum</strong> of the remaining elements is divisible by <code>p</code>. It is <strong>not</strong> allowed to remove the whole array.</p>

<p>Return <em>the length of the smallest subarray that you need to remove, or </em><code>-1</code><em> if it&#39;s impossible</em>.</p>

<p>A <strong>subarray</strong> is defined as a contiguous block of elements in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,2], p = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,3,5,2], p = 9
<strong>Output:</strong> 2
<strong>Explanation:</strong> We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], p = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= p &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach 1: Brute Force (Time Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>Our goal is to remove the smallest subarray so that the sum of the remaining elements is divisible by <code>p</code>.</p>
<p>If the total sum of the array is already divisible by <code>p</code>, there's no need to remove any subarray. However, if the total sum isn't divisible by <code>p</code>, we need to find a subarray to remove. The remainder of the total sum divided by <code>p</code> is the part we want to &quot;eliminate&quot; by removing a subarray whose sum's remainder matches this remainder.</p>
<p>To do this, we can check every possible subarray by starting at each index and calculating the sum of all subarrays that begin at this index. For each subarray, we compute the remaining sum of the elements after removing it. If the remaining sum becomes divisible by <code>p</code>, we record the length of the subarray. We keep track of the smallest such subarray length as we proceed through all possibilities.</p>
<p>This is inefficient because we compute the sum for every subarray, leading to quadratic time complexity. So, this will work for small arrays but will struggle with larger inputs, leading to TLE.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Calculate the size of the input array <code>nums</code> and the total sum of its elements, using <code>long long</code> to avoid overflow.</p>
</li>
<li>
<p>If the <code>totalSum</code> is already divisible by <code>p</code>, return 0 (no subarray needs to be removed).</p>
</li>
<li>
<p>Calculate the <code>target</code> remainder that needs to be removed (i.e., <code>totalSum % p</code>).</p>
</li>
<li>
<p>Initialize <code>minLen</code> to the size of the array <code>n</code> to keep track of the minimum subarray length.</p>
</li>
<li>
<p>Iterate over all possible starting indices of subarrays:</p>
<ul>
<li>For each <code>start</code> index, initialize <code>subSum</code> to 0.</li>
<li>Iterate through all possible ending indices from the <code>start</code> index:
<ul>
<li>Accumulate the sum of the subarray from <code>start</code> to <code>end</code>.</li>
<li>Calculate the <code>remainingSum</code> after removing the current subarray, using <code>(totalSum - subSum) % p</code>.</li>
<li>If <code>remainingSum</code> is 0:
<ul>
<li>Update <code>minLen</code> to the smaller value between <code>minLen</code> and the length of the current subarray (<code>end - start + 1</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After checking all possible subarrays, return:</p>
<ul>
<li><code>-1</code> if no valid subarray was found (i.e., <code>minLen</code> remains equal to <code>n</code>).</li>
<li>Otherwise, return <code>minLen</code> as the length of the smallest subarray that can be removed.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Umbti5bb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The outer loop runs <span class="math inline">\(n\)</span> times, iterating over the starting index of the subarray. The inner loop also runs up to <span class="math inline">\(n\)</span> times for each iteration of the outer loop, as it sums the elements from the starting index to the end. Therefore, the overall time complexity of this nested loop structure results in <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only stores a few variables (like <code>totalSum</code>, <code>target</code>, <code>subSum</code>, and <code>minLen</code>). The space used does not depend on the size of the input array, making the space complexity constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sum-modulo">Approach 2: Prefix Sum Modulo</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We want to reduce the number of subarray checks while still solving the problem correctly. Usually, when we have a problem that involves the summation of a subarray, we resort to prefix sums. This lowers the time complexity of computing subarray summations to <span class="math inline">\(O(1)\)</span>, as <code>sum(i, j) = sum(0, j) - sum(0, i-1)</code>.</p>
<p>We need to remove a subarray such that the sum of the remaining elements is divisible by <code>p</code>. This indicates that the remainder of the sum of the elements, after removing the subarray, must be zero when divided by <code>p</code>. We aim to use this information to find subarrays quickly.</p>
<p>Instead of trying all subarrays, we keep track of the prefix sum as we iterate through the array. For each index, we compute the current prefix sum modulo <code>p</code>. The remainder of the total sum modulo <code>p</code> gives us a &quot;target&quot; remainder we want to eliminate. This is where modular arithmetic becomes useful: if, at some point in our prefix sum, we find that removing a certain portion of the array will leave a sum divisible by <code>p</code>, we have our solution.</p>
<p>To speed this up, we use a hash map to store the earliest occurrence of each remainder (prefix sum modulo <code>p</code>). By doing so, when we encounter the same remainder later on, we know that the subarray between these two occurrences can be removed to make the sum divisible by <code>p</code>. This allows us to find the smallest subarray length in linear time, drastically improving the efficiency of the algorithm.</p>
<p>This is how we construct the formula for the smallest subarray removal:</p>
<p><img src="../Figures/1590/equation.png" alt="Prefix Sum Modulo" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>nums</code> and <code>totalSum</code> to 0.</p>
</li>
<li>
<p>Calculate the total sum and target remainder:</p>
<ul>
<li>Iterate over each element in <code>nums</code> to compute <code>totalSum</code> as the sum of all elements modulo <code>p</code>.</li>
<li>Set <code>target</code> as <code>totalSum % p</code>.</li>
<li>If <code>target</code> is 0, return 0 (the array is already divisible by <code>p</code>).</li>
</ul>
</li>
<li>
<p>Use a hash map to track prefix sums modulo <code>p</code>:</p>
<ul>
<li>Initialize <code>modMap</code> with <code>0</code> mapped to <code>-1</code> to handle cases where the entire prefix is the answer.</li>
<li>Initialize <code>currentSum</code> to 0 and <code>minLen</code> to <code>n</code>.</li>
</ul>
</li>
<li>
<p>Iterate over the array:</p>
<ul>
<li>Update <code>currentSum</code> with the current element, taking modulo <code>p</code>.</li>
<li>Calculate <code>needed</code> as the difference between <code>currentSum</code> and <code>target</code>, adjusted to be positive by adding <code>p</code> and taking modulo <code>p</code>.</li>
<li>Check if <code>needed</code> exists in <code>modMap</code>:
<ul>
<li>If it does, calculate the length of the subarray and update <code>minLen</code> if it's smaller.</li>
</ul>
</li>
<li>Store the current remainder and its index in <code>modMap</code>.</li>
</ul>
</li>
<li>
<p>Return the result:</p>
<ul>
<li>If <code>minLen</code> is still <code>n</code>, return <code>-1</code> (no valid subarray found).</li>
<li>Otherwise, return <code>minLen</code>.</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1590/prefixsum.json:940,605!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/k9ACSshH/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the <code>nums</code> array twice: once to calculate the total sum and again to find the minimum length of the subarray that needs to be removed. Both of these operations take linear time, resulting in an overall time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a hash map (<code>modMap</code>) to store the remainders and their corresponding indices. In the worst case, this hash map could store up to <span class="math inline">\(n\)</span> different remainders (one for each element in the array), leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matrix-block-sum/description" target="_blank" rel="noopener noreferrer">Matrix Block Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>k</code>, return <em>a matrix</em> <code>answer</code> <em>where each</em> <code>answer[i][j]</code> <em>is the sum of all elements</em> <code>mat[r][c]</code> <em>for</em>:</p>

<ul>
	<li><code>i - k &lt;= r &lt;= i + k,</code></li>
	<li><code>j - k &lt;= c &lt;= j + k</code>, and</li>
	<li><code>(r, c)</code> is a valid position in the matrix.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
<strong>Output:</strong> [[12,21,16],[27,45,33],[24,39,28]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
<strong>Output:</strong> [[45,45,45],[45,45,45],[45,45,45]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;mat.length</code></li>
	<li><code>n ==&nbsp;mat[i].length</code></li>
	<li><code>1 &lt;= m, n, k &lt;= 100</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-consecutive-ones-iii/description" target="_blank" rel="noopener noreferrer">Max Consecutive Ones III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array if you can flip at most</em> <code>k</code> <code>0</code>&#39;s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
<strong>Output:</strong> 6
<strong>Explanation:</strong> [1,1,1,0,0,<u><strong>1</strong>,1,1,1,1,<strong>1</strong></u>]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
<strong>Output:</strong> 10
<strong>Explanation:</strong> [0,0,<u>1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1</u>,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>0 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-number-of-subsequences-in-a-string/description" target="_blank" rel="noopener noreferrer">Maximize Number of Subsequences in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>text</code> and another <strong>0-indexed</strong> string <code>pattern</code> of length <code>2</code>, both of which consist of only lowercase English letters.</p>

<p>You can add <strong>either</strong> <code>pattern[0]</code> <strong>or</strong> <code>pattern[1]</code> anywhere in <code>text</code> <strong>exactly once</strong>. Note that the character can be added even at the beginning or at the end of <code>text</code>.</p>

<p>Return <em>the <strong>maximum</strong> number of times</em> <code>pattern</code> <em>can occur as a <strong>subsequence</strong> of the modified </em><code>text</code>.</p>

<p>A <b>subsequence</b> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;abdcdbc&quot;, pattern = &quot;ac&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong>
If we add pattern[0] = &#39;a&#39; in between text[1] and text[2], we get &quot;ab<u><strong>a</strong></u>dcdbc&quot;. Now, the number of times &quot;ac&quot; occurs as a subsequence is 4.
Some other strings which have 4 subsequences &quot;ac&quot; after adding a character to text are &quot;<u><strong>a</strong></u>abdcdbc&quot; and &quot;abd<u><strong>a</strong></u>cdbc&quot;.
However, strings such as &quot;abdc<u><strong>a</strong></u>dbc&quot;, &quot;abd<u><strong>c</strong></u>cdbc&quot;, and &quot;abdcdbc<u><strong>c</strong></u>&quot;, although obtainable, have only 3 subsequences &quot;ac&quot; and are thus suboptimal.
It can be shown that it is not possible to get more than 4 subsequences &quot;ac&quot; by adding only one character.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;aabb&quot;, pattern = &quot;ab&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong>
Some of the strings which can be obtained from text and have 6 subsequences &quot;ab&quot; are &quot;<u><strong>a</strong></u>aabb&quot;, &quot;aa<u><strong>a</strong></u>bb&quot;, and &quot;aab<u><strong>b</strong></u>b&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>
	<li><code>pattern.length == 2</code></li>
	<li><code>text</code> and <code>pattern</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-subarrays-after-removing-one-conflicting-pair/description" target="_blank" rel="noopener noreferrer">Maximize Subarrays After Removing One Conflicting Pair</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> which represents an array <code>nums</code> containing the numbers from 1 to <code>n</code> in order. Additionally, you are given a 2D array <code>conflictingPairs</code>, where <code>conflictingPairs[i] = [a, b]</code> indicates that <code>a</code> and <code>b</code> form a conflicting pair.</p>

<p>Remove <strong>exactly</strong> one element from <code>conflictingPairs</code>. Afterward, count the number of <span data-keyword="subarray-nonempty">non-empty subarrays</span> of <code>nums</code> which do not contain both <code>a</code> and <code>b</code> for any remaining conflicting pair <code>[a, b]</code>.</p>

<p>Return the <strong>maximum</strong> number of subarrays possible after removing <strong>exactly</strong> one conflicting pair.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, conflictingPairs = [[2,3],[1,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Remove <code>[2, 3]</code> from <code>conflictingPairs</code>. Now, <code>conflictingPairs = [[1, 4]]</code>.</li>
	<li>There are 9 subarrays in <code>nums</code> where <code>[1, 4]</code> do not appear together. They are <code>[1]</code>, <code>[2]</code>, <code>[3]</code>, <code>[4]</code>, <code>[1, 2]</code>, <code>[2, 3]</code>, <code>[3, 4]</code>, <code>[1, 2, 3]</code> and <code>[2, 3, 4]</code>.</li>
	<li>The maximum number of subarrays we can achieve after removing one element from <code>conflictingPairs</code> is 9.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, conflictingPairs = [[1,2],[2,5],[3,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Remove <code>[1, 2]</code> from <code>conflictingPairs</code>. Now, <code>conflictingPairs = [[2, 5], [3, 5]]</code>.</li>
	<li>There are 12 subarrays in <code>nums</code> where <code>[2, 5]</code> and <code>[3, 5]</code> do not appear together.</li>
	<li>The maximum number of subarrays we can achieve after removing one element from <code>conflictingPairs</code> is 12.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= conflictingPairs.length &lt;= 2 * n</code></li>
	<li><code>conflictingPairs[i].length == 2</code></li>
	<li><code>1 &lt;= conflictingPairs[i][j] &lt;= n</code></li>
	<li><code>conflictingPairs[i][0] != conflictingPairs[i][1]</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-enumeration">Approach: Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>Consider a simplified version of the problem: calculating the number of valid subarrays that do not contain any conflicting pairs, without deleting any of them.</p>
<p>For the simplified problem, we first enumerate the left endpoint <span class="math inline">\(i\)</span> of the subarray. Then, under the condition that no conflicting pairs are included, we determine the range of valid values for the right endpoint <span class="math inline">\(j\)</span>. For each conflicting pair <span class="math inline">\(\textit{conflictingPairs}[k] = [a_k, b_k]\)</span>, we assume <span class="math inline">\(a_k < b_k\)</span> (if not, we swap their positions). There are two cases:</p>
<ul>
<li>
<p>If <span class="math inline">\(a_k < i\)</span>, then no matter how <span class="math inline">\(j\)</span> is chosen, the subarray will not include both <span class="math inline">\(a_k\)</span> and <span class="math inline">\(b_k\)</span>.</p>
</li>
<li>
<p>If <span class="math inline">\(a_k \ge i\)</span>, then we must have <span class="math inline">\(j < b_k\)</span>.</p>
</li>
</ul>
<p>Based on this, we define <span class="math inline">\(b_1 = \min_{a_k \ge i} b_k\)</span>, and the valid range for <span class="math inline">\(j\)</span> becomes:</p>
<p><span class="math display">\[i \le j \lt \min(b_1, n + 1)
\]</span></p>
<p>Therefore, the number of valid subarrays with left endpoint <span class="math inline">\(i\)</span> is <span class="math inline">\(\min(n + 1, b_1) - i\)</span>.<br />
To compute <span class="math inline">\(b_1\)</span> efficiently, we use arrays <span class="math inline">\(\textit{bMin}_1\)</span> and <span class="math inline">\(\textit{bMin}_2\)</span> to record the smallest and second smallest values of <span class="math inline">\(b\)</span> among all conflicting pairs <span class="math inline">\((a, b)\)</span> where <span class="math inline">\(a < b\)</span>. Then, <span class="math inline">\(b_1\)</span> can be found using the suffix minimum of <span class="math inline">\(\textit{bMin}_1\)</span>.</p>
<p>Now consider the case where we delete exactly one conflicting pair. For a subarray with left endpoint <span class="math inline">\(i\)</span>, the valid range of its right endpoint <span class="math inline">\(j\)</span> is determined by <span class="math inline">\(b_1\)</span>. If the deleted conflicting pair does not involve <span class="math inline">\(b_1\)</span>, then the number of valid subarrays starting at <span class="math inline">\(i\)</span> remains unchanged.</p>
<p>Assume <span class="math inline">\(b_1\)</span> is located at index <span class="math inline">\(i_{b_1}\)</span> in <span class="math inline">\(\textit{bMin}1\)</span>, i.e., <span class="math inline">\(\textit{bMin}1[i{b_1}] = b_1\)</span>. We define <span class="math inline">\(\textit{delCount}[i{b_1}]\)</span> to record the number of additional valid subarrays that can be gained by deleting the conflicting pair associated with <span class="math inline">\(b_1\)</span>.</p>
<p>Let <span class="math inline">\(b_2\)</span> be the second smallest suffix value of <span class="math inline">\(\textit{bMin}_1\)</span> starting at index <span class="math inline">\(i\)</span>. After deleting <span class="math inline">\(b_1\)</span>, the new <span class="math inline">\(b_1'\)</span> becomes <span class="math inline">\(\min(b_2, \textit{bMin}2[i{b_1}])\)</span>. The number of additional valid subarrays gained is:</p>
<p><span class="math display">\[\min(b_1', n + 1) - \min(b_1, n + 1)
\]</span></p>
<p>This value is then added to <span class="math inline">\(\textit{delCount}[i_{b_1}]\)</span>.</p>
<p>Finally, the maximum number of valid subarrays after deleting exactly one conflicting pair is equal to the number of valid subarrays without any deletion, plus the maximum value in <span class="math inline">\(\textit{delCount}\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4u9Vpqc6/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We only need to traverse the array once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We use an array to record the number of valid subarrays added after deleting conflicting pairs.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-confusion-of-an-exam/description" target="_blank" rel="noopener noreferrer">Maximize the Confusion of an Exam</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A teacher is writing a test with <code>n</code> true/false questions, with <code>&#39;T&#39;</code> denoting true and <code>&#39;F&#39;</code> denoting false. He wants to confuse the students by <strong>maximizing</strong> the number of <strong>consecutive</strong> questions with the <strong>same</strong> answer (multiple trues or multiple falses in a row).</p>

<p>You are given a string <code>answerKey</code>, where <code>answerKey[i]</code> is the original answer to the <code>i<sup>th</sup></code> question. In addition, you are given an integer <code>k</code>, the maximum number of times you may perform the following operation:</p>

<ul>
	<li>Change the answer key for any question to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code> (i.e., set <code>answerKey[i]</code> to <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code>).</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of consecutive</em> <code>&#39;T&#39;</code>s or <code>&#39;F&#39;</code>s <em>in the answer key after performing the operation at most</em> <code>k</code> <em>times</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFF&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can replace both the &#39;F&#39;s with &#39;T&#39;s to make answerKey = &quot;<u>TTTT</u>&quot;.
There are four consecutive &#39;T&#39;s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TFFT&quot;, k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can replace the first &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;<u>FFF</u>T&quot;.
Alternatively, we can replace the second &#39;T&#39; with an &#39;F&#39; to make answerKey = &quot;T<u>FFF</u>&quot;.
In both cases, there are three consecutive &#39;F&#39;s.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> answerKey = &quot;TTFTTFTT&quot;, k = 1
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can replace the first &#39;F&#39; to make answerKey = &quot;<u>TTTTT</u>FTT&quot;
Alternatively, we can replace the second &#39;F&#39; to make answerKey = &quot;TTF<u>TTTTT</u>&quot;. 
In both cases, there are five consecutive &#39;T&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == answerKey.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>answerKey[i]</code> is either <code>&#39;T&#39;</code> or <code>&#39;F&#39;</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-the-minimum-powered-city/description" target="_blank" rel="noopener noreferrer">Maximize the Minimum Powered City</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>stations</code> of length <code>n</code>, where <code>stations[i]</code> represents the number of power stations in the <code>i<sup>th</sup></code> city.</p>

<p>Each power station can provide power to every city in a fixed <strong>range</strong>. In other words, if the range is denoted by <code>r</code>, then a power station at city <code>i</code> can provide power to all cities <code>j</code> such that <code>|i - j| &lt;= r</code> and <code>0 &lt;= i, j &lt;= n - 1</code>.</p>

<ul>
	<li>Note that <code>|x|</code> denotes <strong>absolute</strong> value. For example, <code>|7 - 5| = 2</code> and <code>|3 - 10| = 7</code>.</li>
</ul>

<p>The <strong>power</strong> of a city is the total number of power stations it is being provided power from.</p>

<p>The government has sanctioned building <code>k</code> more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.</p>

<p>Given the two integers <code>r</code> and <code>k</code>, return <em>the <strong>maximum possible minimum power</strong> of a city, if the additional power stations are built optimally.</em></p>

<p><strong>Note</strong> that you can build the <code>k</code> power stations in multiple cities.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stations = [1,2,4,5,0], r = 1, k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
One of the optimal ways is to install both the power stations at city 1. 
So stations will become [1,4,4,5,0].
- City 0 is provided by 1 + 4 = 5 power stations.
- City 1 is provided by 1 + 4 + 4 = 9 power stations.
- City 2 is provided by 4 + 4 + 5 = 13 power stations.
- City 3 is provided by 5 + 4 = 9 power stations.
- City 4 is provided by 5 + 0 = 5 power stations.
So the minimum power of a city is 5.
Since it is not possible to obtain a larger power, we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stations = [4,4,4,4], r = 0, k = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
It can be proved that we cannot make the minimum power of a city greater than 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stations.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>
	<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-coins-from-k-consecutive-bags/description" target="_blank" rel="noopener noreferrer">Maximum Coins From K Consecutive Bags</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are an infinite amount of bags on a number line, one bag for each coordinate. Some of these bags contain coins.</p>

<p>You are given a 2D array <code>coins</code>, where <code>coins[i] = [l<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub>]</code> denotes that every bag from <code>l<sub>i</sub></code> to <code>r<sub>i</sub></code> contains <code>c<sub>i</sub></code> coins.</p>

<p>The segments that <code>coins</code> contain are non-overlapping.</p>

<p>You are also given an integer <code>k</code>.</p>

<p>Return the <strong>maximum</strong> amount of coins you can obtain by collecting <code>k</code> consecutive bags.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[8,10,1],[1,3,2],[5,6,4]], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting bags at positions <code>[3, 4, 5, 6]</code> gives the maximum number of coins:&nbsp;<code>2 + 0 + 4 + 4 = 10</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[1,10,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting bags at positions <code>[1, 2]</code> gives the maximum number of coins:&nbsp;<code>3 + 3 = 6</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= coins.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
	<li><code>coins[i] == [l<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub>]</code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= 1000</code></li>
	<li>The given segments are non-overlapping.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii/description" target="_blank" rel="noopener noreferrer">Maximum Difference Between Even and Odd Frequency II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and an integer <code>k</code>. Your task is to find the <strong>maximum</strong> difference between the frequency of <strong>two</strong> characters, <code>freq[a] - freq[b]</code>, in a <span data-keyword="substring">substring</span> <code>subs</code> of <code>s</code>, such that:</p>

<ul>
	<li><code>subs</code> has a size of <strong>at least</strong> <code>k</code>.</li>
	<li>Character <code>a</code> has an <em>odd frequency</em> in <code>subs</code>.</li>
	<li>Character <code>b</code> has a <strong>non-zero</strong> <em>even frequency</em> in <code>subs</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> difference.</p>

<p><strong>Note</strong> that <code>subs</code> can contain more than 2 <strong>distinct</strong> characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;12233&quot;, k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>For the substring <code>&quot;12233&quot;</code>, the frequency of <code>&#39;1&#39;</code> is 1 and the frequency of <code>&#39;3&#39;</code> is 2. The difference is <code>1 - 2 = -1</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;1122211&quot;, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>For the substring <code>&quot;11222&quot;</code>, the frequency of <code>&#39;2&#39;</code> is 3 and the frequency of <code>&#39;1&#39;</code> is 2. The difference is <code>3 - 2 = 1</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;110&quot;, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists only of digits <code>&#39;0&#39;</code> to <code>&#39;4&#39;</code>.</li>
	<li>The input is generated that at least one substring has a character with an even frequency and a character with an odd frequency.</li>
	<li><code>1 &lt;= k &lt;= s.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-enumerate-two-characters--two-pointers">Approach: Enumerate Two Characters + Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the string <span class="math inline">\(s\)</span> only contains digit characters <span class="math inline">\([0, 4]\)</span>, we can first enumerate the characters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> described in the problem, where <span class="math inline">\(a\)</span> must appear an odd number of times, <span class="math inline">\(b\)</span> must appear an even number of times, and <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be different. The parity of the number of occurrences of a character can be represented by a binary bit, where <span class="math inline">\(0\)</span> indicates an even count and <span class="math inline">\(1\)</span> indicates an odd count. We place the parity of <span class="math inline">\(a\)</span>'s occurrences in front and the parity of <span class="math inline">\(b\)</span>'s at the end, resulting in 4 possible cases: <span class="math inline">\([00, 01, 10, 11]\)</span>. The string we are looking for must correspond to the <span class="math inline">\(10\)</span> case.</p>
<p>We consider a two-pointer approach, where the right pointer <span class="math inline">\(\textit{right}\)</span> moves one step at a time, representing the right endpoint of the current substring. As it moves, we update the count of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> up to index <span class="math inline">\(\textit{right}\)</span>, denoted as <span class="math inline">\(\textit{cnt}_a\)</span> and <span class="math inline">\(\textit{cnt}_b\)</span>, and compute the corresponding state:</p>
<p><span class="math display">\[\textit{status}_\textit{right} = (\textit{cnt}_a \bmod 2) \times 2 + (\textit{cnt}_b \bmod 2)
\]</span></p>
<p>At the same time, the left pointer <span class="math inline">\(\textit{left}\)</span> only advances when certain conditions are met. That is, only indices less than or equal to <span class="math inline">\(\textit{left}\)</span> can serve as the left endpoint of a valid substring. We use <span class="math inline">\(\textit{prev}_a\)</span> and <span class="math inline">\(\textit{prev}_b\)</span> to record the count of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> up to index <span class="math inline">\(\textit{left}\)</span>, and move <span class="math inline">\(\textit{left}\)</span> only when both conditions below are satisfied:</p>
<ul>
<li>
<p><span class="math inline">\(\textit{right} - \textit{left} \geq k\)</span>, i.e., the substring length is at least <span class="math inline">\(k\)</span>.</p>
</li>
<li>
<p><span class="math inline">\(\textit{cnt}_b - \textit{prev}_b \geq 2\)</span>, meaning <span class="math inline">\(b\)</span> appears an even number of times in the substring, but zero occurrences must be excluded.</p>
</li>
</ul>
<p>For any such valid <span class="math inline">\(\textit{left}\)</span>, the corresponding result is <span class="math inline">\((\textit{cnt}_a - \textit{cnt}_b) - (\textit{prev}_a - \textit{prev}_b)\)</span>. Therefore, we maintain a length-4 array <span class="math inline">\(\textit{best}\)</span> that keeps track of the minimum value of <span class="math inline">\(\textit{prev}_a - \textit{prev}_b\)</span> for each possible state:</p>
<p><span class="math display">\[\textit{status}_\textit{left} = (\textit{prev}_a \bmod 2) \times 2 + (\textit{prev}_b \bmod 2)
\]</span></p>
<p>We then use <span class="math inline">\(\textit{prev}_a - \textit{prev}b\)</span> to update <span class="math inline">\(\textit{best}[\textit{status}\textit{left}]\)</span>.</p>
<p>After moving the left pointer, we compute the answer for the current right pointer. Since we are looking for substrings with state <span class="math inline">\(10\)</span>, the required left endpoint must have the state <span class="math inline">\(\textit{status}_\textit{right} \oplus (10)_2\)</span>, where <span class="math inline">\(\oplus\)</span> denotes the XOR operation. So the answer becomes:</p>
<p><span class="math display">\[(\textit{cnt}_a - \textit{cnt}_b) - \textit{best}[\textit{status}_\textit{right} \oplus (10)_2]
\]</span></p>
<p>We return the maximum value among all such results as the final answer.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FfHcYdhW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>, and let <span class="math inline">\(|\Sigma|\)</span> denote the size of the character set. Since <span class="math inline">\(s\)</span> contains only the digits <span class="math inline">\([0, 4]\)</span>, we have <span class="math inline">\(|\Sigma| = 5\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n\times|\Sigma|^2)\)</span>.</p>
<p>Enumerating all possible pairs of characters <span class="math inline">\((a, b)\)</span> takes <span class="math inline">\(O(|\Sigma|^2)\)</span> time. For each such pair, we apply a two-pointer approach using <span class="math inline">\(\textit{left}\)</span> and <span class="math inline">\(\textit{right}\)</span> to compute the answer. Each pointer traverses the string at most once, resulting in <span class="math inline">\(O(n)\)</span> time per pair. Hence, the total time complexity is <span class="math inline">\(O(n \times |\Sigma|^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Only a few additional variables are needed.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-after-subarray-operation/description" target="_blank" rel="noopener noreferrer">Maximum Frequency After Subarray Operation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of length <code>n</code>. You are also given an integer <code>k</code>.</p>

<p>You perform the following operation on <code>nums</code> <strong>once</strong>:</p>

<ul>
	<li>Select a <span data-keyword="subarray-nonempty">subarray</span> <code>nums[i..j]</code> where <code>0 &lt;= i &lt;= j &lt;= n - 1</code>.</li>
	<li>Select an integer <code>x</code> and add <code>x</code> to <strong>all</strong> the elements in <code>nums[i..j]</code>.</li>
</ul>

<p>Find the <strong>maximum</strong> frequency of the value <code>k</code> after the operation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4,5,6], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>After adding -5 to <code>nums[2..5]</code>, 1 has a frequency of 2 in <code>[1, 2, -2, -1, 0, 1]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [10,2,3,4,5,5,4,3,2,2], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>After adding 8 to <code>nums[1..9]</code>, 10 has a frequency of 4 in <code>[10, 10, 11, 12, 13, 13, 12, 11, 10, 10]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
	<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/description" target="_blank" rel="noopener noreferrer">Maximum Frequency of an Element After Performing Operations I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>

<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>

<ul>
	<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>
	<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> possible <span data-keyword="frequency-array">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,5], k = 1, numOperations = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>. <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>
	<li>Adding -1 to <code>nums[2]</code>. <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description" target="_blank" rel="noopener noreferrer">Maximum Frequency of an Element After Performing Operations II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and two integers <code>k</code> and <code>numOperations</code>.</p>

<p>You must perform an <strong>operation</strong> <code>numOperations</code> times on <code>nums</code>, where in each operation you:</p>

<ul>
	<li>Select an index <code>i</code> that was <strong>not</strong> selected in any previous operations.</li>
	<li>Add an integer in the range <code>[-k, k]</code> to <code>nums[i]</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> possible <span data-keyword="frequency-array">frequency</span> of any element in <code>nums</code> after performing the <strong>operations</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,5], k = 1, numOperations = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>, after which <code>nums</code> becomes <code>[1, 4, 5]</code>.</li>
	<li>Adding -1 to <code>nums[2]</code>, after which <code>nums</code> becomes <code>[1, 4, 4]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [5,11,20,20], k = 5, numOperations = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can achieve a maximum frequency of two by:</p>

<ul>
	<li>Adding 0 to <code>nums[1]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= numOperations &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description" target="_blank" rel="noopener noreferrer">Maximum Fruits Harvested After at Most K Steps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array <code>fruits</code> where <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> depicts <code>amount<sub>i</sub></code> fruits at the position <code>position<sub>i</sub></code>. <code>fruits</code> is already <strong>sorted</strong> by <code>position<sub>i</sub></code> in <strong>ascending order</strong>, and each <code>position<sub>i</sub></code> is <strong>unique</strong>.</p>

<p>You are also given an integer <code>startPos</code> and an integer <code>k</code>. Initially, you are at the position <code>startPos</code>. From any position, you can either walk to the <strong>left or right</strong>. It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis, and you can walk <strong>at most</strong> <code>k</code> steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.</p>

<p>Return <em>the <strong>maximum total number</strong> of fruits you can harvest</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/1.png" style="width: 472px; height: 115px;" />
<pre>
<strong>Input:</strong> fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
<strong>Output:</strong> 9
<strong>Explanation:</strong> 
The optimal way is to:
- Move right to position 6 and harvest 3 fruits
- Move right to position 8 and harvest 6 fruits
You moved 3 steps and harvested 3 + 6 = 9 fruits in total.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/2.png" style="width: 512px; height: 129px;" />
<pre>
<strong>Input:</strong> fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
<strong>Output:</strong> 14
<strong>Explanation:</strong> 
You can move at most k = 4 steps, so you cannot reach position 0 nor 10.
The optimal way is to:
- Harvest the 7 fruits at the starting position 5
- Move left to position 4 and harvest 1 fruit
- Move right to position 6 and harvest 2 fruits
- Move right to position 7 and harvest 4 fruits
You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/3.png" style="width: 476px; height: 100px;" />
<pre>
<strong>Input:</strong> fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong>
You can move at most k = 2 steps and cannot reach any position with fruits.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>
	<li><code>fruits[i].length == 2</code></li>
	<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> for any <code>i &gt; 0</code>&nbsp;(<strong>0-indexed</strong>)</li>
	<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the fruit positions are already sorted in ascending order, we can efficiently determine how many fruits fall within any interval on the x-axis using binary search. The main challenge is to find the interval of positions that can be reached from <code>startPos</code> using at most <span class="math inline">\(k\)</span> steps, such that the total number of fruits collected is maximized.</p>
<p>We follow a greedy strategy, moving in one direction first and then turning around. This works because fruits can only be picked once, and covering a wider range increases the chance of collecting more fruits.</p>
<p>There are two main movement patterns:</p>
<ul>
<li>Move <span class="math inline">\(x\)</span> steps in one direction, then <span class="math inline">\(k - x\)</span> steps in the opposite direction.</li>
<li>When <span class="math inline">\(x = 0\)</span>, we simply move in one direction for <span class="math inline">\(k\)</span> steps.</li>
</ul>
<p>For each <span class="math inline">\(x\)</span> in the range <span class="math inline">\([0, \left\lfloor \frac{k}{2} \right\rfloor]\)</span>, we consider:</p>
<ol>
<li>Left-first movement: move left <span class="math inline">\(x\)</span> steps, then right <span class="math inline">\((k - x)\)</span> steps. This covers the interval <span class="math inline">\([\textit{startPos} - x, \textit{startPos} + k - 2x]\)</span>.</li>
<li>Right-first movement: move right <span class="math inline">\(x\)</span> steps, then left <span class="math inline">\((k - x)\)</span> steps. This covers the interval <span class="math inline">\([\textit{startPos} - (k - 2x), \textit{startPos} + x]\)</span>.</li>
</ol>
<p>For each of these intervals, we compute the number of fruits using prefix sums and binary search in <span class="math inline">\(O(\log n)\)</span> time. The maximum value across all such intervals gives the answer.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RVS3qU6Q/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{fruits}\)</span>, and let <span class="math inline">\(k\)</span> be the given integer.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + k \log n)\)</span>.</p>
<p>The time complexity for calculating the prefix sum of the array is <span class="math inline">\(O(n)\)</span>, and the time required for each query to find the number of fruits in a range is <span class="math inline">\(O(\log n)\)</span>. Since there are a total of <span class="math inline">\(k\)</span> queries, the overall time complexity is <span class="math inline">\(O(n + k \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We calculate and store the prefix sum of the array, which requires <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can approach the problem from a new perspective. Suppose we fix an interval <span class="math inline">\([ \textit{left}, \textit{right} ]\)</span> (where <code>left</code> and <code>right</code> are <strong>indices</strong> in the <code>fruits</code> array). From the given starting position <code>startPos</code>, how many steps are required to visit all fruit positions within this interval?</p>
<p>There are three cases to consider:</p>
<ul>
<li>
<p><strong>Case 1:</strong> <code>startPos &gt; fruits[right][0]</code><br />
The interval lies entirely to the left of <code>startPos</code>. We need to move left to reach <code>fruits[left][0]</code>.<br />
Steps needed:</p>
<p><span class="math display">\[\textit{startPos} - \textit{fruits[left][0]}
\]</span></p>
</li>
<li>
<p><strong>Case 2:</strong> <code>startPos &lt; fruits[left][0]</code><br />
The interval lies entirely to the right of <code>startPos</code>. We need to move right to reach <code>fruits[right][0]</code>.<br />
Steps needed:</p>
<p><span class="math display">\[\textit{fruits[right][0]} - \textit{startPos}
\]</span></p>
</li>
<li>
<p><strong>Case 3:</strong> <code>startPos</code> is within the interval<br />
There are two ways to visit both ends:</p>
<ul>
<li>
<p>Go left first to <code>fruits[left][0]</code>, then right to <code>fruits[right][0]</code><br />
Steps:</p>
<p><span class="math display">\[\textit{startPos} - \textit{fruits[left][0]} + \textit{fruits[right][0]} - \textit{fruits[left][0]}
\]</span></p>
<ul>
<li>Go right first to <code>fruits[right][0]</code>, then left to <code>fruits[left][0]</code><br />
Steps:</li>
</ul>
<p><span class="math display">\[\textit{fruits[right][0]} - \textit{startPos} + \textit{fruits[right][0]} - \textit{fruits[left][0]}
\]</span></p>
</li>
</ul>
</li>
</ul>
<p>So, in general, the minimum number of steps required to traverse the interval <span class="math inline">\([ \textit{fruits[left][0]}, \textit{fruits[right][0]} ]\)</span> is:</p>
<p><span class="math display">\[\text{step}(left, right) = \textit{fruits[right][0]} - \textit{fruits[left][0]} + \min\left( |\textit{startPos} - \textit{fruits[left][0]}|,\ |\textit{startPos} - \textit{fruits[right][0]}| \right)
\]</span></p>
<p>This expression ensures that we count both the total distance and the shorter leg from <code>startPos</code> to either end.</p>
<p>Now, if we fix <code>right</code> and slide <code>left</code>, we observe:</p>
<ul>
<li>If <code>fruits[left][0] &lt; startPos</code>, decreasing <code>left</code> can decrease the <code>step</code> value.</li>
<li>If <code>fruits[left][0] â‰¥ startPos</code>, decreasing <code>left</code> no longer helps and <code>step</code> stays the same or increases.</li>
</ul>
<p>Thus, for fixed <code>right</code>, the <code>step(left, right)</code> function is non-increasing as long as <code>fruits[left][0] &lt; startPos</code>, and non-decreasing afterward.</p>
<p>Thus, we use a sliding window where both <code>left</code> and <code>right</code> are pointers to intervals in the <code>fruits</code> array. As we move <code>right</code> forward to include more fruits, we check whether the number of steps needed to reach the interval exceeds <code>k</code>. If it does, we increment <code>left</code> to shrink the window until the constraint is satisfied. At each step, we track the sum of fruits in the valid window and update the maximum found so far.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LtqkxpT2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{fruits}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>Each time, we move the right endpoint of the fixed window and then try to move the left endpoint. The right endpoint can move at most <span class="math inline">\(n\)</span> times, and the left endpoint can also move at most <span class="math inline">\(n\)</span> times. Therefore, the time complexity is <span class="math inline">\(O(2n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-good-subarray-sum/description" target="_blank" rel="noopener noreferrer">Maximum Good Subarray Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of length <code>n</code> and a <strong>positive</strong> integer <code>k</code>.</p>

<p>A <span data-keyword="subarray-nonempty">subarray</span> of <code>nums</code> is called <strong>good</strong> if the <strong>absolute difference</strong> between its first and last element is <strong>exactly</strong> <code>k</code>, in other words, the subarray <code>nums[i..j]</code> is good if <code>|nums[i] - nums[j]| == k</code>.</p>

<p>Return <em>the <strong>maximum</strong> sum of a <strong>good</strong> subarray of </em><code>nums</code>. <em>If there are no good subarrays</em><em>, return </em><code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], k = 1
<strong>Output:</strong> 11
<strong>Explanation:</strong> The absolute difference between the first and last element<!-- notionvc: 2a6d66c9-0149-4294-b267-8be9fe252de9 --> must be 1 for a good subarray. All the good subarrays are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum is 11 for the subarray [5,6].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,3,2,4,5], k = 3
<strong>Output:</strong> 11
<strong>Explanation:</strong> The absolute difference between the first and last element<!-- notionvc: 2a6d66c9-0149-4294-b267-8be9fe252de9 --> must be 3 for a good subarray. All the good subarrays are: [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the subarray [2,4,5].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,-2,-3,-4], k = 2
<strong>Output:</strong> -6
<strong>Explanation:</strong> The absolute difference between the first and last element<!-- notionvc: 2a6d66c9-0149-4294-b267-8be9fe252de9 --> must be 2 for a good subarray. All the good subarrays are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for the subarray [-1,-2,-3].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/description" target="_blank" rel="noopener noreferrer">Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> and an integer <code>target</code>, return <em>the maximum number of <strong>non-empty</strong> <strong>non-overlapping</strong> subarrays such that the sum of values in each subarray is equal to</em> <code>target</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1], target = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 non-overlapping subarrays [<strong>1,1</strong>,1,<strong>1,1</strong>] with sum equals to target(2).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,3,5,1,4,2,-9], target = 6
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/intersecting-intervals/1" target="_blank" rel="noopener noreferrer">Maximum number of overlapping Intervals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an array of intervals <strong>arr[][],</strong> where each interval is represented by two integers <strong>[start, end]</strong> (inclusive). Return the <strong>maximum</strong> number of intervals that <strong>overlap</strong> at any point in time.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[][] = [[1, 2], [2, 4], [3, 6]]
<strong>Output: </strong>2
<strong>Explanation:</strong> The maximum overlapping intervals are 2(between (1, 2) and (2, 4) or between (2, 4) and (3, 6))<br /></span> <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/899521/Web/Other/blobid1_1752817303.jpg" width="419" height="169" /></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[][] = [[1, 8], [2, 5], [5, 6], [3, 7]]
<strong>Output: </strong>4
<strong>Explanation: </strong>The maximum overlapping intervals are 4 (between (1, 8), (2, 5), (5, 6) and (3, 7))</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />2&nbsp;</span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le;</span><span style="font-size: 18px;"> arr.size() </span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le;</span><span style="font-size: 18px;">&nbsp;2 * 10</span><sup>4<br /></sup><span style="font-size: 18px;">1&nbsp;</span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le;</span><span style="font-size: 18px;"> arr[i][0] &lt; arr[i][1] </span><span style="background-color: #ffffff; color: #001d35; font-family: 'Google Sans', Arial, sans-serif; font-size: 18px;">&le;</span><span style="font-size: 18px;">&nbsp;4*10</span><sup>6</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-robots-within-budget/description" target="_blank" rel="noopener noreferrer">Maximum Number of Robots Within Budget</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> robots. You are given two <strong>0-indexed</strong> integer arrays, <code>chargeTimes</code> and <code>runningCosts</code>, both of length <code>n</code>. The <code>i<sup>th</sup></code> robot costs <code>chargeTimes[i]</code> units to charge and costs <code>runningCosts[i]</code> units to run. You are also given an integer <code>budget</code>.</p>

<p>The <strong>total cost</strong> of running <code>k</code> chosen robots is equal to <code>max(chargeTimes) + k * sum(runningCosts)</code>, where <code>max(chargeTimes)</code> is the largest charge cost among the <code>k</code> robots and <code>sum(runningCosts)</code> is the sum of running costs among the <code>k</code> robots.</p>

<p>Return<em> the <strong>maximum</strong> number of <strong>consecutive</strong> robots you can run such that the total cost <strong>does not</strong> exceed </em><code>budget</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
It is possible to run all individual and consecutive pairs of robots within budget.
To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 which is less than 25.
It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
<strong>Output:</strong> 0
<strong>Explanation:</strong> No robot can be run that does not exceed the budget, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>chargeTimes.length == runningCosts.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-subsequences-after-one-inserting/description" target="_blank" rel="noopener noreferrer">Maximum Number of Subsequences After One Inserting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of uppercase English letters.</p>

<p>You are allowed to insert <strong>at most one</strong> uppercase English letter at <strong>any</strong> position (including the beginning or end) of the string.</p>

<p>Return the <strong>maximum</strong> number of <code>&quot;LCT&quot;</code> <span data-keyword="subsequence-string-nonempty">subsequences</span> that can be formed in the resulting string after <strong>at most one insertion</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;LMCT&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can insert a <code>&quot;L&quot;</code> at the beginning of the string s to make <code>&quot;LLMCT&quot;</code>, which has 2 subsequences, at indices [0, 3, 4] and [1, 3, 4].</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;LCCT&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>We can insert a <code>&quot;L&quot;</code> at the beginning of the string s to make <code>&quot;LLCCT&quot;</code>, which has 4 subsequences, at indices [0, 2, 4], [0, 3, 4], [1, 2, 4] and [1, 3, 4].</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;L&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>Since it is not possible to obtain the subsequence <code>&quot;LCT&quot;</code> by inserting a single letter, the result is 0.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of uppercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/description" target="_blank" rel="noopener noreferrer">Maximum Number of Ways to Partition an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>. The number of ways to <strong>partition</strong> <code>nums</code> is the number of <code>pivot</code> indices that satisfy both conditions:</p>

<ul>
	<li><code>1 &lt;= pivot &lt; n</code></li>
	<li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>
</ul>

<p>You are also given an integer <code>k</code>. You can choose to change the value of <strong>one</strong> element of <code>nums</code> to <code>k</code>, or to leave the array <strong>unchanged</strong>.</p>

<p>Return <em>the <strong>maximum</strong> possible number of ways to <strong>partition</strong> </em><code>nums</code><em> to satisfy both conditions after changing <strong>at most</strong> one element</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,-1,2], k = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> One optimal approach is to change nums[0] to k. The array becomes [<strong><u>3</u></strong>,-1,2].
There is one way to partition the array:
- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0], k = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The optimal approach is to leave the array unchanged.
There are two ways to partition the array:
- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.
- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
<strong>Output:</strong> 4
<strong>Explanation:</strong> One optimal approach is to change nums[2] to k. The array becomes [22,4,<u><strong>-33</strong></u>,-20,-15,15,-16,7,19,-10,0,-13,-14].
There are four ways to partition the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= k, nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-or/description" target="_blank" rel="noopener noreferrer">Maximum OR</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>k</code>. In an operation, you can choose an element and multiply it by <code>2</code>.</p>

<p>Return <em>the maximum possible value of </em><code>nums[0] | nums[1] | ... | nums[n - 1]</code> <em>that can be obtained after applying the operation on nums at most </em><code>k</code><em> times</em>.</p>

<p>Note that <code>a | b</code> denotes the <strong>bitwise or</strong> between two integers <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [12,9], k = 1
<strong>Output:</strong> 30
<strong>Explanation:</strong> If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,1,2], k = 2
<strong>Output:</strong> 35
<strong>Explanation:</strong> If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-points-you-can-obtain-from-cards/description" target="_blank" rel="noopener noreferrer">Maximum Points You Can Obtain from Cards</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are several cards <strong>arranged in a row</strong>, and each card has an associated number of points. The points are given in the integer array <code>cardPoints</code>.</p>

<p>In one step, you can take one card from the beginning or from the end of the row. You have to take exactly <code>k</code> cards.</p>

<p>Your score is the sum of the points of the cards you have taken.</p>

<p>Given the integer array <code>cardPoints</code> and the integer <code>k</code>, return the <em>maximum score</em> you can obtain.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cardPoints = [1,2,3,4,5,6,1], k = 3
<strong>Output:</strong> 12
<strong>Explanation:</strong> After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cardPoints = [2,2,2], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> Regardless of which two cards you take, your score will always be 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> cardPoints = [9,7,7,9,7,7,9], k = 7
<strong>Output:</strong> 55
<strong>Explanation:</strong> You have to take all the cards. Your score is the sum of points of all cards.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= cardPoints.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= cardPoints[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-population-year/description" target="_blank" rel="noopener noreferrer">Maximum Population Year</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>logs</code> where each <code>logs[i] = [birth<sub>i</sub>, death<sub>i</sub>]</code> indicates the birth and death years of the <code>i<sup>th</sup></code> person.</p>

<p>The <strong>population</strong> of some year <code>x</code> is the number of people alive during that year. The <code>i<sup>th</sup></code> person is counted in year <code>x</code>&#39;s population if <code>x</code> is in the <strong>inclusive</strong> range <code>[birth<sub>i</sub>, death<sub>i</sub> - 1]</code>. Note that the person is <strong>not</strong> counted in the year that they die.</p>

<p>Return <em>the <strong>earliest</strong> year with the <strong>maximum population</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> logs = [[1993,1999],[2000,2010]]
<strong>Output:</strong> 1993
<strong>Explanation:</strong> The maximum population is 1, and 1993 is the earliest year with this population.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> logs = [[1950,1961],[1960,1971],[1970,1981]]
<strong>Output:</strong> 1960
<strong>Explanation:</strong> 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= logs.length &lt;= 100</code></li>
	<li><code>1950 &lt;= birth<sub>i</sub> &lt; death<sub>i</sub> &lt;= 2050</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-after-splitting-a-string/description" target="_blank" rel="noopener noreferrer">Maximum Score After Splitting a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a&nbsp;string <code>s</code>&nbsp;of zeros and ones, <em>return the maximum score after splitting the string into two <strong>non-empty</strong> substrings</em> (i.e. <strong>left</strong> substring and <strong>right</strong> substring).</p>

<p>The score after splitting a string is the number of <strong>zeros</strong> in the <strong>left</strong> substring plus the number of <strong>ones</strong> in the <strong>right</strong> substring.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;011101&quot;
<strong>Output:</strong> 5 
<strong>Explanation:</strong> 
All possible ways of splitting s into two non-empty substrings are:
left = &quot;0&quot; and right = &quot;11101&quot;, score = 1 + 4 = 5 
left = &quot;01&quot; and right = &quot;1101&quot;, score = 1 + 3 = 4 
left = &quot;011&quot; and right = &quot;101&quot;, score = 1 + 2 = 3 
left = &quot;0111&quot; and right = &quot;01&quot;, score = 1 + 1 = 2 
left = &quot;01110&quot; and right = &quot;1&quot;, score = 2 + 1 = 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;00111&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> When left = &quot;00&quot; and right = &quot;111&quot;, we get the maximum score = 2 + 3 = 5
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1111&quot;
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 500</code></li>
	<li>The string <code>s</code> consists of characters <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Intuition</strong></p>
<p>In this problem, we need to make a &quot;split&quot; which involves separating the input into a left part and a right part.</p>
<p>To start, we can check every possible split. We will use an integer <code>i</code> to iterate over the string, where <code>i</code> represents the index of the final character in the left part.</p>
<p>For a given <code>i</code>, we iterate on the indices of <code>s</code> from <code>0</code> to <code>i</code> and count how many times <code>0</code> occurs. We then iterate on the indices from <code>i + 1</code> until the last index and count how many times <code>1</code> occurs. The sum of these counts represents the score for the current split, and we take the maximum of all scores.</p>
<p>Note that we cannot iterate <code>i</code> until the final index, but rather the second last index. If we were to iterate to the final index, the right part would be empty, which is not allowed by the problem.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the answer <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> from <code>0</code> until <code>s.length - 1</code>:
<ul>
<li>Initialize the current score <code>curr = 0</code>.</li>
<li>Iterate <code>j</code> from <code>0</code> to <code>i</code>:
<ul>
<li>If <code>s[j] == '0'</code>, increment <code>curr</code>.</li>
</ul>
</li>
<li>Iterate <code>j</code> from <code>i + 1</code> until <code>s.length</code>:
<ul>
<li>If <code>s[j] == '1'</code>, increment <code>curr</code>.</li>
</ul>
</li>
<li>Update <code>ans</code> with <code>curr</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/BxhALAmW/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We iterate <code>i</code> over <span class="math inline">\(n - 1\)</span> indices. For each iteration, we have two iterations over <code>j</code>, traversing over a total of <span class="math inline">\(n\)</span> indices. Thus, we iterate <span class="math inline">\(O(n \cdot (n - 1)) = O(n^2)\)</span> times.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-count-left-zeros-and-right-ones">Approach 2: Count Left Zeros and Right Ones</h3>
<p><strong>Intuition</strong></p>
<p>We can improve on the previous solution by noticing that between a split at index <code>i</code> and index <code>i + 1</code>, we are only changing one character (more specifically, moving it from the right substring to the left substring), leaving the other characters unchanged. Instead of iterating over the entire string for each split, we only need to check the moved character and calculate the score for the new split based on the previous split.</p>
<p>We start by counting how many times <code>1</code> occurs in <code>s</code>. Let's store this value in a variable <code>ones</code>. We will also have a variable <code>zeros</code> that represents how many <code>0</code> are in the left part. Initially, our variables <code>ones</code> and <code>zeros</code> are set as if the left part is empty and the right part is the entire string.</p>
<p>Now, we iterate <code>i</code> in the same manner as the previous approach: each index <code>i</code> represents the final index of the left part. At each iteration <code>i</code>, we remove <code>s[i]</code> from the right part and add it to the left part.</p>
<p><img src="../Figures/1422/1.png" alt="example" /><br />
<br></p>
<p>There are two possibilities for each index <code>i</code>:</p>
<ul>
<li>If <code>s[i] == '1'</code>: this <code>1</code> was in the right part, but it is now joining the left part. Thus, we lose <code>1</code> score since the right part is losing a <code>1</code>. Decrement <code>ones</code>.</li>
<li>If <code>s[i] == '0'</code>, this <code>0</code> was in the right part, but it is now joining the left part. Thus, we gain <code>1</code> score since the left part is gaining a <code>0</code>. Increment <code>zeros</code>.</li>
</ul>
<p>We update the answer with <code>zeros + ones</code> at each iteration if it is larger.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>ones</code> as the number of times <code>1</code> occurs in <code>s</code>.</li>
<li>Initialize <code>zeros = 0</code> and the answer <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> from <code>0</code> until <code>s.length - 1</code>:
<ul>
<li>If <code>s[i] == '1'</code>, decrement <code>ones</code>.</li>
<li>Otherwise, increment <code>zeros</code>.</li>
<li>Update <code>ans</code> with <code>zeros + ones</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/RbevsbUt/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We start by finding the frequency of <code>1</code>, which costs <span class="math inline">\(O(n)\)</span>. Next, we iterate over the string once, performing <span class="math inline">\(O(1)\)</span> work at each iteration. Thus, our time complexity is <span class="math inline">\(O(2n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-one-pass">Approach 3: One Pass</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we used two passes over the input string: once to calculate <code>ones</code>, and another time to calculate <code>ans</code>. We can further optimize the algorithm to only use one pass!</p>
<p>The answer to our problem is the maximum score for all valid splits, as represented by the following equation:</p>
<p><span class="math display">\[
We can express $$O_R$$ as $$O_T - O_L$$, where $$O_T$$ is the total number of ones in `s`, and $$O_L$$ is the number of ones in the left substring.

Using the above expression, our first equation can be represented as:

$$\text{score} = Z_L + O_T - O_L$$

In the above equation, $$O_T$$ is a constant, we need to find the maximum value of $$Z_L - O_L$$ for all valid splits. Notice that both of these values depend solely on the left substring. Therefore, we don't need to consider the right substring, which saves the need for the first traversal in the previous solution.

In the code, we will use the variable `zeros` to represent $$Z_L$$ and the variables `ones` to represent $$O_L$$. As `zeros - ones` may be negative, we initialize an integer `best` to a very small value, like negative infinity. Here, `best` represents the largest value of `zeros - ones` we have seen so far.

We now iterate `i` in the same manner as the first two approaches: at each iteration, `i` represents the final index of the left part. On each iteration, we are adding `s[i]` to the left part. Thus, if `s[i] = '1'` we increment `ones`, otherwise `s[i] = '0'` and we increment `zeros`. Then, we update `best` with `zeros - ones` if it is larger.

Recall that we don't iterate `i` over the final index since it would mean having an empty right part. Once we are done iterating over `s`, we will check the final index to see if it is a `1`. If it is, we increment `ones`.

The reason we explicitly check the final index for `1` is that we want `ones` to represent $$O_T$$ in the end, but when we calculate `ones`, we don't iterate over the last index, so we need to account for it. Now, we have `best` as the maximum of all $$Z_L - O_L$$ and `ones` represents $$O_T$$, we can return `best + ones` as the answer.

**Algorithm**

1. Initialize `ones = 0`, `zeros = 0`, and `best` to a very small value like negative infinity.
2. Iterate `i` from `0` until `s.length - 1`:
    - If `s[i] == '1'`, increment `ones`.
    - Otherwise, increment `zeros`.
    - Update `best` with `zeros - ones` if it is larger.
3. If the final character of `s` is equal to `'1'`, increment `ones`.
4. Return `best + ones`.

**Implementation**

[code](https://leetcode.com/playground/Q7CXvTeL/shared)

**Complexity Analysis**

Given $$n$$ as the length of `nums`,

* Time complexity: $$O(n)$$

    We make one pass over `nums`, performing $$O(1)$$ work at each iteration.

* Space complexity: $$O(1)$$

    We aren't using any extra space other than a few integers.
    
<br/>

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-from-grid-operations/description" target="_blank" rel="noopener noreferrer">Maximum Score From Grid Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> of size <code>n x n</code>. Initially, all cells of the grid are colored white. In one operation, you can select any cell of indices <code>(i, j)</code>, and color black all the cells of the <code>j<sup>th</sup></code> column starting from the top row down to the <code>i<sup>th</sup></code> row.</p>

<p>The grid score is the sum of all <code>grid[i][j]</code> such that cell <code>(i, j)</code> is white and it has a horizontally adjacent black cell.</p>

<p>Return the <strong>maximum</strong> score that can be achieved after some number of operations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">11</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/05/11/one.png" style="width: 300px; height: 200px;" />
<p>In the first operation, we color all cells in column 1 down to row 3, and in the second operation, we color all cells in column 4 down to the last row. The score of the resulting grid is <code>grid[3][0] + grid[1][2] + grid[3][3]</code> which is equal to 11.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">94</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/05/11/two-1.png" style="width: 300px; height: 200px;" />
<p>We perform operations on 1, 2, and 3 down to rows 1, 4, and 0, respectively. The score of the resulting grid is <code>grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3] + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4]</code> which is equal to 94.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;n == grid.length &lt;= 100</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-segment-sum-after-removals/description" target="_blank" rel="noopener noreferrer">Maximum Segment Sum After Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums</code> and <code>removeQueries</code>, both of length <code>n</code>. For the <code>i<sup>th</sup></code> query, the element in <code>nums</code> at the index <code>removeQueries[i]</code> is removed, splitting <code>nums</code> into different segments.</p>

<p>A <strong>segment</strong> is a contiguous sequence of <strong>positive</strong> integers in <code>nums</code>. A <strong>segment sum</strong> is the sum of every element in a segment.</p>

<p>Return<em> an integer array </em><code>answer</code><em>, of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>maximum</strong> segment sum after applying the </em><code>i<sup>th</sup></code> <em>removal.</em></p>

<p><strong>Note:</strong> The same index will <strong>not</strong> be removed more than once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]
<strong>Output:</strong> [14,7,2,2,0]
<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].
Query 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].
Query 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. 
Query 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. 
Query 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [14,7,2,2,0].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,11,1], removeQueries = [3,2,1,0]
<strong>Output:</strong> [16,5,3,0]
<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:
Query 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].
Query 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].
Query 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].
Query 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.
Finally, we return [16,5,3,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length == removeQueries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>
	<li>All the values of <code>removeQueries</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description" target="_blank" rel="noopener noreferrer">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>threshold</code>, return <em>the maximum side-length of a square with a sum less than or equal to </em><code>threshold</code><em> or return </em><code>0</code><em> if there is no such square</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/05/e1.png" style="width: 335px; height: 186px;" />
<pre>
<strong>Input:</strong> mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum side length of square with sum less than 4 is 2 as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>0 &lt;= mat[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= threshold &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strength-of-k-disjoint-subarrays/description" target="_blank" rel="noopener noreferrer">Maximum Strength of K Disjoint Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> with length <code>n</code>, and a positive <strong>odd</strong> integer <code>k</code>.</p>

<p>Select exactly <b><code>k</code></b> disjoint <span data-keyword="subarray-nonempty">subarrays</span> <b><code>sub<sub>1</sub>, sub<sub>2</sub>, ..., sub<sub>k</sub></code></b> from <code>nums</code> such that the last element of <code>sub<sub>i</sub></code> appears before the first element of <code>sub<sub>{i+1}</sub></code> for all <code>1 &lt;= i &lt;= k-1</code>. The goal is to maximize their combined strength.</p>

<p>The strength of the selected subarrays is defined as:</p>

<p><code>strength = k * sum(sub<sub>1</sub>)- (k - 1) * sum(sub<sub>2</sub>) + (k - 2) * sum(sub<sub>3</sub>) - ... - 2 * sum(sub<sub>{k-1}</sub>) + sum(sub<sub>k</sub>)</code></p>

<p>where <b><code>sum(sub<sub>i</sub>)</code></b> is the sum of the elements in the <code>i</code>-th subarray.</p>

<p>Return the <strong>maximum</strong> possible strength that can be obtained from selecting exactly <b><code>k</code></b> disjoint subarrays from <code>nums</code>.</p>

<p><strong>Note</strong> that the chosen subarrays <strong>don&#39;t</strong> need to cover the entire array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,-1,2], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">22</span></p>

<p><strong>Explanation:</strong></p>

<p>The best possible way to select 3 subarrays is: nums[0..2], nums[3..3], and nums[4..4]. The strength is calculated as follows:</p>

<p><code>strength = 3 * (1 + 2 + 3) - 2 * (-1) + 2 = 22</code></p>

<p>&nbsp;</p>

<p><strong class="example">Example 2:</strong></p>

<p><strong>Input:</strong> <span class="example-io">nums = [12,-2,-2,-2,-2], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">64</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible way to select 5 disjoint subarrays is: nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4]. The strength is calculated as follows:</p>

<p><code>strength = 5 * 12 - 4 * (-2) + 3 * (-2) - 2 * (-2) + (-2) = 64</code></p>

<p><strong class="example">Example 3:</strong></p>

<p><strong>Input:</strong> <span class="example-io">nums = [-1,-2,-3], k = </span>1</p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>The best possible way to select 1 subarray is: nums[0..0]. The strength is -1.</p>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
	<li><code>1 &lt;= n * k &lt;= 10<sup>6</sup></code></li>
	<li><code>k</code> is odd.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-subarray-min-product/description" target="_blank" rel="noopener noreferrer">Maximum Subarray Min-Product</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>min-product</strong> of an array is equal to the <strong>minimum value</strong> in the array <strong>multiplied by</strong> the array&#39;s <strong>sum</strong>.</p>

<ul>
	<li>For example, the array <code>[3,2,5]</code> (minimum value is <code>2</code>) has a min-product of <code>2 * (3+2+5) = 2 * 10 = 20</code>.</li>
</ul>

<p>Given an array of integers <code>nums</code>, return <em>the <strong>maximum min-product</strong> of any <strong>non-empty subarray</strong> of </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Note that the min-product should be maximized <strong>before</strong> performing the modulo operation. Testcases are generated such that the maximum min-product <strong>without</strong> modulo will fit in a <strong>64-bit signed integer</strong>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,<u>2,3,2</u>]
<strong>Output:</strong> 14
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,<u>3,3</u>,1,2]
<strong>Output:</strong> 18
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,<u>5,6,4</u>,2]
<strong>Output:</strong> 60
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-subarray-sum--110820/1" target="_blank" rel="noopener noreferrer">Maximum subarray sum 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">deque</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">set</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an array <strong>arr[]</strong> of integers and two integers <strong>a </strong>and <strong>b</strong>, You have to find the maximum possible <strong>sum </strong>of a contiguous subarray whose length is at least <strong>a </strong>and at most <strong>b</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:&nbsp;</strong>arr[] = [4, 5, -1, -2, 6], a = 2, b = 4</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> 9</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> The subarray [4, 5] has length 2 and sum 9, which is the maximum among all subarrays of length between 2 and 4.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:&nbsp;</strong>arr[] = [-1, 3, -1, -2, 5, 3, -5, 2, 2], a = 3, b = 5</span><br /><span style="font-size: 14pt;"><strong>Output:&nbsp;</strong>8</span><br /><span style="font-size: 14pt;"><strong>Explanation:&nbsp;</strong>The subarray [3, -1, -2, 5, 3] has length 5 and sum 8, which is the maximum among all subarrays of length between 3 and 5.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; arr.size() &le; 10<sup>5<br /></sup>-10<sup>5</sup> &le; arr[i] &le; 10<sup>5<br /></sup>1 &le; a &le; b &le; arr.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Maximum Subarray Sum With Length Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> and an integer <code>k</code>.</p>

<p>Return the <strong>maximum</strong> sum of a <span data-keyword="subarray-nonempty">subarray</span> of <code>nums</code>, such that the size of the subarray is <strong>divisible</strong> by <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>[1, 2]</code> with sum 3 has length equal to 2 which is divisible by 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-1,-2,-3,-4,-5], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">-10</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum sum subarray is <code>[-1, -2, -3, -4]</code> which has length equal to 4 which is divisible by 4.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-5,1,2,-3,4], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum sum subarray is <code>[1, 2, -3, 4]</code> which has length equal to 4 which is divisible by 2.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-obtained-of-any-permutation/description" target="_blank" rel="noopener noreferrer">Maximum Sum Obtained of Any Permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We have an array of integers, <code>nums</code>, and an array of <code>requests</code> where <code>requests[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>. The <code>i<sup>th</sup></code> request asks for the sum of <code>nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>]</code>. Both <code>start<sub>i</sub></code> and <code>end<sub>i</sub></code> are <em>0-indexed</em>.</p>

<p>Return <em>the maximum total sum of all requests <strong>among all permutations</strong> of</em> <code>nums</code>.</p>

<p>Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
<strong>Output:</strong> 19
<strong>Explanation:</strong> One permutation of nums is [2,1,3,4,5] with the following result: 
requests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
requests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3
Total sum: 8 + 3 = 11.
A permutation with a higher total sum is [3,5,4,2,1] with the following result:
requests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
requests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8
Total sum: 11 + 8 = 19, which is the best that you can do.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], requests = [[0,1]]
<strong>Output:</strong> 11
<strong>Explanation:</strong> A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
<strong>Output:</strong> 47
<strong>Explanation:</strong> A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= requests.length &lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>requests[i].length == 2</code></li>
	<li><code>0 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;&nbsp;n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description" target="_blank" rel="noopener noreferrer">Maximum Sum of 3 Non-Overlapping Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, find three non-overlapping subarrays of length <code>k</code> with maximum sum and return them.</p>

<p>Return the result as a list of indices representing the starting position of each interval (<strong>0-indexed</strong>). If there are multiple answers, return the lexicographically smallest one.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,6,7,5,1], k = 2
<strong>Output:</strong> [0,3,5]
<strong>Explanation:</strong> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2,1,2,1,2,1], k = 2
<strong>Output:</strong> [0,2,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>
	<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<h3 id="approach-1-memoization">Approach 1: Memoization</h3>
<h4 id="intuition">Intuition</h4>
<p>At first, we might think of a greedy approach: since all array values are positive, we could just find the three largest <code>k</code>- length subarrays. Unfortunately, this doesn't always work because the subarrays might overlap and, even if we avoid overlaps, we might miss better combinations. For example, taking a smaller subarray sum early on could allow us to pick two much larger subarrays later. This is why a greedy approach fails - we need to balance between local (current subarray) and global (overall) optimization.</p>
<p>To find the optimal subarrays, we need to make a decision at each position in the array:</p>
<ul>
<li>Should we take the <code>k</code>-length subarray starting here?</li>
<li>Or should we skip it and move to the next position?</li>
</ul>
<p>This &quot;take it or leave it&quot; choice is typical in dynamic programming problems, similar to the 0/1 Knapsack Problem. If you are unfamiliar with the 0/1 Knapsack Problem, take a look at this excellent <a href="https://leetcode.com/discuss/study-guide/1152328/01-Knapsack-Problem-and-Dynamic-Programming#:~:text=Statement%3A%20Given%20a%20set%20of,equal%20to%20the%20knapsack's%20capacity.">LeetCode Discuss post ðŸ”—</a>.</p>
<p>Let us try to implement a memoized recursive function which should pick three subarrays such that their total sum is as large as possible. However, it is too slow to calculate the <code>k</code>-length subarray whenever we want to pick a particular index. To optimize this, let's precalculate the sum of the <code>k</code>-length subarray starting at each index. We create an array <code>sums</code> and populate it by maintaining a window of size <code>k</code> that slides through the array, adding the new element and removing the oldest one at each step.</p>
<p>For our recursive function design, which returns the largest total sum after selecting the subarrays, we need to consider two base cases:</p>
<ul>
<li>If weâ€™ve already selected 3 subarrays, return the current sum immediately.</li>
<li>If we've reached the array's end, terminate naturally.</li>
</ul>
<p>At each step, we have two choices:</p>
<ol>
<li>Take the current subarray: Add its sum to the total and jump <code>k</code> positions forward (to avoid overlap).</li>
<li>Skip the current position: Move to the next position and continue looking for subarrays.</li>
</ol>
<p>We take the larger of these two choices, and this forms our recurrence relation.</p>
<p>To keep track of these decisions and avoid recalculating results, we use a 2D array (<code>dp</code>) of size <code>n Ã— 3</code>, where <code>n</code> is the length of the array and <code>3</code> represents the number of subarrays we need to find. Each cell in <code>dp</code> stores the best sum for a specific position and the number of remaining subarrays.</p>
<p>Once weâ€™ve calculated the largest total sum using this DP table, we need to find the starting indices of the subarrays that produce this sum. This is the second phase of the solution: <strong>path reconstruction</strong>.</p>
<p>To do this, we use a Depth-First Search (DFS) to retrace the steps of the DP function. At each step, we decide whether to include the current position or skip it, and we check the <code>dp</code> table to guide our choice.</p>
<ul>
<li>If taking the current position gives the same or a better sum, we add its index to our result.</li>
</ul>
<p>Since all DP states are precomputed, each DFS step is fast. After the DFS completes, the <code>indices</code> list contains the starting indices of the three non-overlapping subarrays. We return this list as our final answer.</p>
<blockquote>
<p>If you are unfamiliar with dynamic programming, check out the <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming Explore Card ðŸ”—</a>. This resource provides an in-depth look at the dynamic programming paradigm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Create a variable <code>n</code> to store the number of possible starting positions for subarrays, calculated as the array length minus <code>k</code> plus 1.</li>
<li>Initialize:
<ul>
<li>an array <code>sums</code> of size <code>n</code> to store sums of all possible <code>k</code>-length subarrays.</li>
<li>a variable <code>windowSum</code> to store the sum of the first <code>k</code> elements.</li>
</ul>
</li>
<li>Store the first window sum in <code>sums[0]</code>.</li>
<li>Use a sliding window technique to calculate the remaining sums:
<ul>
<li>Subtract the leftmost element of the previous window.</li>
<li>Add the rightmost element of the current window.</li>
<li>Store the result in the corresponding position of the <code>sums</code> array.</li>
</ul>
</li>
<li>Initialize a 2D array <code>memo</code> of size <code>n x 4</code> to store dynamic programming states, where <code>memo[i][j]</code> represents the largest sum possible starting from index <code>i</code> with <code>j</code> subarrays remaining.</li>
<li>Initialize an empty list <code>indices</code> to store final result indices.</li>
<li>Call <code>dp</code> to find the optimal sum using dynamic programming.</li>
<li>Call <code>dfs</code> to reconstruct the path and find the starting indices.</li>
<li>Return <code>indices</code> as the required answer.</li>
</ul>
<p>In the <code>dp</code> function:</p>
<ul>
<li>Base case 1: If the remaining subarrays (<code>rem</code>) is 0, return 0 as we've found all required subarrays.</li>
<li>Base case 2: If the current index (<code>idx</code>) exceeds array bounds, return -infinity if we still need subarrays, else return 0.</li>
<li>Check if the current state is already computed by examining <code>memo[idx][rem]</code>. If the value is not -1, return the memoized result.</li>
<li>Calculate the first choice by adding the current subarray sum (<code>sums[idx]</code>) to the result of a recursive call with:
<ul>
<li>Index advanced by <code>k</code> positions (<code>idx + k</code>).</li>
<li>One less subarray remaining (<code>rem - 1</code>).</li>
</ul>
</li>
<li>Calculate the second choice by making a recursive call with:
<ul>
<li>Index advanced by 1 (<code>idx + 1</code>).</li>
<li>Same number of subarrays remaining (<code>rem</code>).</li>
</ul>
</li>
<li>Store the larger of two choices in <code>memo[idx][rem]</code>.</li>
<li>Return the stored largest value.</li>
</ul>
<p>In the <code>dfs</code> function:</p>
<ul>
<li>Base case 1: If the remaining subarrays (<code>rem</code>) is <code>0</code>, return as the solution is complete.</li>
<li>Base case 2: If the current index (<code>idx</code>) exceeds array bounds, return as the path is invalid.</li>
<li>Calculate the largest sum possible by including the current subarray using the same parameters as in the <code>dp</code> function.</li>
<li>Calculate the largest sum possible by skipping the current subarray using the same parameters as in the <code>dp</code> function.</li>
<li>Compare the two possibilities:
<ul>
<li>If including the current subarray gives a greater or equal sum:
<ul>
<li>Add the current index to the solution list.</li>
<li>Make a recursive call with an index advanced by <code>k</code> and one less subarray remaining.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Make a recursive call with the next index and the same number of subarrays.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3svjmRjT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>, <span class="math inline">\(k\)</span> be the length of each subarray and <span class="math inline">\(m\)</span> be the required number of non-overlapping subarrays.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m) \approx O(n)\)</span></p>
<p>The algorithm first computes prefix sums in <span class="math inline">\(O(n)\)</span> time using a sliding window. The <code>dp</code> function fills an <span class="math inline">\(n \times (m + 1)\)</span> memo table, where each state <code>(i, j)</code> is computed once due to memoization. The <code>dfs</code> function reconstructs the solution in <span class="math inline">\(O(m)\)</span> time by tracing the path through the <code>dp</code> table.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n)\)</span> for prefix sums, <span class="math inline">\(O(n \cdot m)\)</span> for DP, and <span class="math inline">\(O(m)\)</span> for DFS, resulting in <span class="math inline">\(O(n \cdot m)\)</span>. With <span class="math inline">\(m\)</span> fixed at 3, this simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m) \approx O(n)\)</span></p>
<p>The algorithm uses an array <code>sums</code> of size <span class="math inline">\(n\)</span> to store subarray sums and a <code>memo</code> table of size <span class="math inline">\(n \times (m + 1)\)</span>, which requires <span class="math inline">\(O(n \cdot m)\)</span> space. The recursion stack depth is limited by <span class="math inline">\(m\)</span>, contributing <span class="math inline">\(O(m)\)</span> to space complexity. The <code>indices</code> list stores <span class="math inline">\(m\)</span> elements.</p>
<p>Thus, the space complexity is dominated by the <code>memo</code> table, resulting in <span class="math inline">\(O(n \cdot m)\)</span>. With <span class="math inline">\(m\)</span> fixed at 3, this simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<blockquote>
<p>Note: While <code>m = 3</code> is fixed in this problem, we've kept it as a variable in the analysis to show how the complexity would scale if <code>m</code> were different.</p>
</blockquote>
<hr />
<h3 id="approach-2-tabulation">Approach 2: Tabulation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our previous top-down dynamic programming approach had two main drawbacks: recursive overhead and complex path reconstruction. Let's develop a more efficient bottom-up approach that eliminates the need for recursive path reconstruction.</p>
<p>Let's shift our insight a bit: instead of thinking about &quot;What choices do we have at each position?&quot;, we can think about &quot;Whatâ€™s the best result we can achieve with a specific number of subarrays up to each position?&quot;.</p>
<p>Notice that at a particular position, if we know the best possible answer for the two subarrays occurring before it, we can easily find the biggest third subarray occurring after it and complete the problem. So, we can build our answer progressively by finding the best arrangements for one subarray first, then using that information to find the best arrangements for two subarrays, and finally for three subarrays.</p>
<p>To make this process faster, we optimize how we calculate subarray sums by using prefix sums. A prefix sum array holds the sum of elements from the start of the array up to each position. This lets us calculate any subarray sum quickly by subtracting two values from the prefix sum array: <code>prefixSum[end] - prefixSum[start]</code>.</p>
<p>Now, let's build the main solution. For each index in the array, weâ€™ll keep track of two things:</p>
<ol>
<li>The best sum possible up to that index, called <code>bestSum</code>.</li>
<li>The starting index that gives us this best sum, called <code>bestIndex</code>.</li>
</ol>
<p>Weâ€™ll calculate these values for 1, 2, and 3 subarrays. To do this, we use a <code>bestIndex</code> matrix of size <span class="math inline">\(4 \times (n + 1)\)</span>, where <code>bestIndex[i][j]</code> gives the best sum achieved up to index <code>j</code> with <code>i</code> subarrays.</p>
<p>We'll loop over each number of subarrays starting from 1. Inside this loop, we loop over each array position and calculate the best possible sum for that position. For each index, the best sum will be one of two options:</p>
<ul>
<li>Option 1: The sum we get by including a subarray that ends at this position.</li>
<li>Option 2: The best sum we had up to the previous index (for the same number of subarrays).</li>
</ul>
<p>To calculate <strong>Option 2</strong>, we simply retrieve the best sum from the previous index for the same subarray count from the <code>bestSum</code> array.</p>
<p>To calculate <strong>Option 1</strong>, we check the sum of the <code>k</code>-length subarray ending at the current position and add it to the best sum we could get with one less subarray, ending at the position <code>index - k</code>. This comes from the <code>bestSum[subarrayCount - 1][index - k]</code>.</p>
<p>If including the current subarray gives us a better sum, we update both <code>bestSum</code> and <code>bestIndex</code> to reflect this. If not, we keep the best values from the previous position. This approach also ensures that we find the lexicographically smallest result, because we only update when we find a strictly better sum.</p>
<p>Once the main loop is done, we'll have the best sum and the corresponding index for the three subarrays. Now, we need to figure out where each of these subarrays starts.</p>
<p>Starting from the end of the array, we use the <code>bestIndex</code> table to trace back the starting index for each subarray. For the third subarray, we check the starting index stored for the best sum with three subarrays. After that, we work backward to find the starting index for the second and first subarrays. Each time we find the start of a subarray, we update <code>currentEnd</code> to be the start of the subarray we just picked. This ensures there is no overlap between subarrays.</p>
<p>At the end of this process, weâ€™ll have the starting indices of the three subarrays that give the largest sum.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a variable <code>n</code> to store the length of the input array <code>nums</code>.</li>
<li>Create a prefix sum array of size <code>n + 1</code>:
<ul>
<li>Populate the prefix sum array by iteratively adding each element to the previous sum.</li>
</ul>
</li>
<li>Create a 2D array:
<ul>
<li><code>bestSum</code> of size <code>4 x (n + 1)</code> to store the largest sums achievable with up to 3 subarrays ending at each position.</li>
<li><code>bestIndex</code> of size <code>4 x (n + 1)</code> to store starting indices of subarrays that give the best sums.</li>
</ul>
</li>
<li>For each possible number of subarrays <code>subarrayCount</code>:
<ul>
<li>For each possible ending position (<code>k * subarrayCount</code> to <code>n</code>):
<ul>
<li>Calculate the current sum by adding the:
<ul>
<li>Sum of the current window (using prefix sum).</li>
<li>Best sum achievable with one less subarray ending before the current window.</li>
</ul>
</li>
<li>If the current sum is greater than the best sum ending at the previous position:
<ul>
<li>Update <code>bestSum</code> at current position with current sum.</li>
<li>Store the starting index of the current window in <code>bestIndex</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Copy <code>bestSum</code> and <code>bestIndex</code> from the previous position to the current position.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Create a <code>result</code> array of size 3 to store the final starting indices.</li>
<li>Initialize <code>currentEnd</code> to point to the end of the array.</li>
<li>For each subarray (counting down from <code>3</code> to <code>1</code>):
<ul>
<li>Store the best starting index for the current subarray count in the <code>result</code> array.</li>
<li>Update <code>currentEnd</code> to point to the start of the just-placed subarray.</li>
</ul>
</li>
<li>Return the <code>result</code> array containing optimal starting indices.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Tf43XcQ3/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>, <span class="math inline">\(k\)</span> be the length of each subarray and <span class="math inline">\(m\)</span> be the required number of non-overlapping subarrays.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m) \approx O(n)\)</span></p>
<p>The algorithm first computes prefix sums in <span class="math inline">\(O(n)\)</span> time by traversing the array once. For each <span class="math inline">\(t\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(m\)</span>, it iterates from position <span class="math inline">\(k \cdot t\)</span> to <span class="math inline">\(n\)</span>, performing constant-time operations at each step. This results in <span class="math inline">\(O(n \cdot m)\)</span> operations due to the nested loops - <span class="math inline">\(m\)</span> outer iterations and approximately <span class="math inline">\(n\)</span> inner iterations. The final backtracking step takes <span class="math inline">\(O(m)\)</span> time. Thus, the overall time complexity is <span class="math inline">\(O(n \cdot m)\)</span>. With <span class="math inline">\(m = 3\)</span>, this simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m) \approx O(n)\)</span></p>
<p>The algorithm uses a prefix sum array of size <span class="math inline">\(n + 1\)</span> to store cumulative sums. It also maintains two 2D arrays <code>bestSum</code> and <code>bestIndex</code>, each of size <span class="math inline">\((m + 1) \times (n + 1)\)</span>, resulting in <span class="math inline">\(O(n \times m)\)</span> space. The <code>result</code> array uses <span class="math inline">\(O(m)\)</span> space. Therefore, the total space complexity is <span class="math inline">\(O(n \times m)\)</span>. Since <span class="math inline">\(m = 3\)</span> in this problem, this reduces to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<blockquote>
<p>Note: While <code>m = 3</code> is fixed in this problem, we've kept it as a variable in the analysis to show how the complexity would scale if <code>m</code> were different.</p>
</blockquote>
<hr />
<h3 id="approach-3-three-pointers">Approach 3: Three Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous two approaches, we focused on finding the best solution for any number of non-overlapping subarrays. However, since our problem only requires finding 3 subarrays, we can use this fact to simplify our approach.</p>
<p>We can break the problem into three parts by <strong>fixing the position of the middle subarray</strong> first. This divides the array into three regions:</p>
<ol>
<li>The left region (before the middle subarray), where we need to find the best left subarray.</li>
<li>The middle subarray itself.</li>
<li>The right region (after the middle subarray), where we need to find the best right subarray.</li>
</ol>
<p>For each possible position of the middle subarray, we can then find the best subarrays in the left and right regions. The highest sum across all possible middle subarray positions will give us the final answer.</p>
<p>However, we need to optimize the way we calculate each subarray on either side while also maintaining information about their starting positions. In previous approaches, we used a prefix sum to precompute subarray sums. We'll now extend that idea further to also precompute the starting positions of the best subarray sums for each index in the array.</p>
<p>To implement this concept, we will create two arrays, <code>leftMaxIndex</code> and <code>rightMaxIndex</code>, to help us track the best subarrays for each segment.</p>
<p>The <code>leftMaxIndex[i]</code> array will store the starting index of the best subarray sum that ends at index <code>i</code>. To calculate this value, we compare the sum of the <code>k</code>-length subarray ending at <code>i</code> with the best sum we've found to the left of <code>i</code>. If the sum before is equal to the sum at index <code>i</code>, we prefer the earlier subarray, as we want the lexicographically smallest index. Similarly, we will build the <code>rightMaxIndex</code> array, where <code>rightMaxIndex[i]</code> will store the starting index of the best subarray sum starting at or after index <code>i</code>.</p>
<p>In the main loop, we will consider <code>k</code>-length subarrays starting from each index in the <code>nums</code> array. For each subarray, we will look up the corresponding <code>leftMaxIndex</code> and <code>rightMaxIndex</code> values, calculate the sum for these subarrays, and store the starting indices of the subarrays that give us the largest sum.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>n</code> to store the length of input array nums.</li>
<li><code>maxSum</code> to store the largest sum possible with three non-overlapping subarrays.</li>
</ul>
</li>
<li>Create a prefix sum array of size <code>n + 1</code> to enable quick calculation of subarray sums.</li>
<li>Populate the prefix sum array by iteratively adding each element to the previous sum.</li>
<li>Create arrays <code>leftMaxIndex</code> and <code>rightMaxIndex</code> to store the best starting index for the left and right subarrays. respectively at each position.</li>
<li>Create a <code>result</code> array of size 3 to store the final starting indices.</li>
<li>Iterate from position <code>k</code> to <code>n - 1</code> to find the best left subarray for each position:
<ul>
<li>Calculate the current subarray sum using prefix sum array.</li>
<li>If current subarray sum is greater than the largest sum we have seen so far:
<ul>
<li>Update <code>leftMaxIndex</code> at current position with the starting index of current subarray.</li>
<li>Update the largest sum seen so far.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Copy the previous best index to current position.</li>
</ul>
</li>
</ul>
</li>
<li>Set the rightmost possible position as initial best right subarray position.</li>
<li>Iterate from position <code>n - k - 1</code> to <code>0</code> to find the best right subarray for each position:
<ul>
<li>Calculate the current subarray sum using prefix sum array.</li>
<li>If current subarray sum is greater than or equal to the largest sum seen so far:
<ul>
<li>Update <code>rightMaxIndex</code> at current position with the starting index of current subarray.</li>
<li>Update the largest sum seen so far.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Copy the next position's best index to current position.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate over all possible middle subarray positions from <code>k</code> to <code>n - 2*k</code>:
<ul>
<li>Get the best left subarray index before current position.</li>
<li>Get the best right subarray index after current position plus <code>k</code>.</li>
<li>Calculate total sum of all three subarrays using prefix sum array.</li>
<li>If total sum is greater than <code>maxSum</code>:
<ul>
<li>Update <code>maxSum</code> with the new largest sum.</li>
<li>Store the three starting indices in the <code>result</code> array.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>result</code> array containing the three optimal starting indices.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oAxWfXoQ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm performs four linear scans. The first scan builds the prefix sum array in <span class="math inline">\(O(n)\)</span> time. The second builds the <code>leftMaxIndex</code> array from left to right in <span class="math inline">\(O(n)\)</span>. The third scan builds the <code>rightMaxIndex</code> array from right to left, also in <span class="math inline">\(O(n)\)</span>. The final scan finds the optimal middle position in <span class="math inline">\(O(n)\)</span>. Since each operation is a sequential linear scan, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses three arrays of size proportional to the input length: the prefix sum array of size <span class="math inline">\(n+1\)</span>, a <code>leftMaxIndex</code> array of size <span class="math inline">\(n\)</span>, and a <code>rightMaxIndex</code> array of size <span class="math inline">\(n\)</span>. Since all auxiliary space usage grow linearly with the input size, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-sliding-window">Approach 4: Sliding Window</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In Approach 2, we built up the solution incrementally: the best two subarrays were derived from the best single subarray, and the best three subarrays were built from the best two. We can extend this concept to create a more optimized solution that doesnâ€™t require storing all possible sums â€” just the best ones at each step.</p>
<p>Imagine a train with three cars, each of length <code>k</code>, moving along a track (our array). The cars must maintain their order and can't overlap:</p>
<pre><code>Initial position:
[Car1][Car2][Car3]------------------
 0    k     2k    

After one move:
-[Car1][Car2][Car3]-----------------
 1    k+1   2k+1  

And so on...
</code></pre>
<p>Each car calculates the sum of the numbers it covers. At each position, Car1 finds the best single-window sum seen so far, Car2 combines its current sum with the best sum from Car1, and Car3 combines its current sum with the best combined sum from Cars 1 and 2.</p>
<p>The main idea in this approach is that we donâ€™t need to try every possible combination of subarrays. Instead, by keeping track of the best results so far at each level - for one subarray, two subarrays, and three subarrays - we can build the solution incrementally. When we reach the end of the <code>nums</code> array, the best result for three subarrays will be our final answer.</p>
<p>We'll first need to set up three sliding windows. We only need to keep track of their starting points, which will be <code>0</code>, <code>k</code>, and <code>2*k</code> respectively. This ensures that the windows never overlap. We'll calculate the sums of the subarrays within these windows and store them in three variables:</p>
<ol>
<li><code>bestSingleSum</code> â€” The best sum for a single subarray.</li>
<li><code>bestDoubleSum</code> â€” The best sum for two non-overlapping subarrays.</li>
<li><code>bestTripleSum</code> â€” The best sum for three non-overlapping subarrays.</li>
</ol>
<p>As the windows slide forward over the array, we update the current sums by subtracting the element that moves out of the window and adding the new element that enters. At each step, we update the â€œbest seen so farâ€ sums in sequence: first <code>bestSingleSum</code>, then <code>bestDoubleSum</code>, and finally <code>bestTripleSum</code>.</p>
<p>Along with updating the sums, we also track the starting indices for these best subarrays, so by the end of the loop, the indices corresponding to <code>bestTripleSum</code> will represent the solution. We return these indices as the final result.</p>
<p>The slideshow below demonstrates the algorithm in action (Consider <code>k = 3</code>):</p>
<p>!?!../Documents/689_re/slideshow.json:1404,702!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a variable <code>bestSingleStart</code> to store the starting index of the best single subarray.</li>
<li>an array <code>bestDoubleStart</code> to store the starting indices of the best two subarrays.</li>
<li>an array <code>bestTripleStart</code> to store the starting indices of the best three subarrays.</li>
</ul>
</li>
<li>Create a variable <code>currentWindowSumSingle</code> to store the sum of the first <code>k</code> elements.
<ul>
<li>Calculate <code>currentWindowSumSingle</code> by adding the first <code>k</code> elements from the input array.</li>
</ul>
</li>
<li>Create a variable <code>currentWindowSumDouble</code> to store the sum of the second window of <code>k</code> elements.
<ul>
<li>Calculate <code>currentWindowSumDouble</code> by adding elements from index <code>k</code> to <code>2*k - 1</code>.</li>
</ul>
</li>
<li>Create a variable <code>currentWindowSumTriple</code> to store the sum of the third window of <code>k</code> elements.
<ul>
<li>Calculate <code>currentWindowSumTriple</code> by adding elements from index <code>2*k</code> to <code>3*k - 1</code>.</li>
</ul>
</li>
<li>Initialize variables <code>bestSingleSum</code>, <code>bestDoubleSum</code> and <code>bestTripleSum</code> to store the largest sum achieved with one, two, and three subarrays, respectively.</li>
<li>Initialize three sliding window pointers: <code>singleStartIndex</code> at <code>1</code>, <code>doubleStartIndex</code> at <code>k + 1</code>, and <code>tripleStartIndex</code> at <code>2*k + 1</code>.</li>
<li>While <code>tripleStartIndex</code> is less than or equal to array length minus <code>k</code>:
<ul>
<li>Update <code>currentWindowSumSingle</code>, <code>currentWindowSumDouble</code>, and <code>currentWindowSumTriple</code> by removing the leftmost element and adding the new rightmost element.</li>
<li>If current <code>currentWindowSumSingle</code> is greater than <code>bestSingleSum</code>:
<ul>
<li>Update <code>bestSingleStart</code> to current <code>singleStartIndex</code>.</li>
<li>Update <code>bestSingleSum</code> to current <code>currentWindowSumSingle</code>.</li>
</ul>
</li>
<li>If the sum of current <code>currentWindowSumDouble</code> and <code>bestSingleSum</code> is greater than <code>bestDoubleSum</code>:
<ul>
<li>Update <code>bestDoubleStart</code> with <code>bestSingleStart</code> and current <code>doubleStartIndex</code>.</li>
<li>Update <code>bestDoubleSum</code> with the new largest sum.</li>
</ul>
</li>
<li>If the sum of current <code>currentWindowSumTriple</code> and <code>bestDoubleSum</code> is greater than <code>bestTripleSum</code>:
<ul>
<li>Update <code>bestTripleStart</code> with <code>bestDoubleStart</code> and current <code>tripleStartIndex</code>.</li>
<li>Update <code>bestTripleSum</code> with the new largest sum.</li>
</ul>
</li>
<li>Increment all three sliding window pointers.</li>
</ul>
</li>
<li>Return <code>bestTripleStart</code> containing the optimal starting indices.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/MB2U2xdH/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + k)\)</span></p>
<p>The algorithm computes three initial window sums, each taking <span class="math inline">\(O(k)\)</span>. It then processes the array with three sliding windows, requiring <span class="math inline">\(O(n)\)</span>. Since all operations are constant-time during the single pass, the total time complexity is <span class="math inline">\(O(n + k)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space regardless of input size. It maintains three arrays of fixed sizes (<code>bestDoubleStart</code> of size <span class="math inline">\(2\)</span> and <code>bestTripleStart</code> of size <span class="math inline">\(3\)</span>) and several single variables. Since none of these space requirements grow with the input size, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-of-an-hourglass/description" target="_blank" rel="noopener noreferrer">Maximum Sum of an Hourglass</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>.</p>

<p>We define an <strong>hourglass</strong> as a part of the matrix with the following form:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/img.jpg" style="width: 243px; height: 243px;" />
<p>Return <em>the <strong>maximum</strong> sum of the elements of an hourglass</em>.</p>

<p><strong>Note</strong> that an hourglass cannot be rotated and must be entirely contained within the matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/1.jpg" style="width: 323px; height: 323px;" />
<pre>
<strong>Input:</strong> grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
<strong>Output:</strong> 30
<strong>Explanation:</strong> The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/2.jpg" style="width: 243px; height: 243px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> 35
<strong>Explanation:</strong> There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>3 &lt;= m, n &lt;= 150</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-sum-rectangle2948/1" target="_blank" rel="noopener noreferrer">Maximum sum Rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">kadane</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2D matrix <strong>mat[][]</strong> with dimensions n&times;m. Find the maximum possible <strong>sum</strong> of any <strong>submatrix </strong>within the given matrix.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]
<strong>Output: </strong>29
<strong>Explanation: </strong>The matrix is as follows and the green rectangle denotes the maximum sum rectangle which is equal to 29.
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/899247/Web/Other/blobid0_1751695089.jpg" width="364" height="225" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[-1, -2], [-3, -4]]
<strong>Output: </strong>-1
<strong>Explanation: </strong>Taking only the first cell is the optimal choice.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 300<br />-1000 &le; mat[i][j] &le; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-beauty-of-the-gardens/description" target="_blank" rel="noopener noreferrer">Maximum Total Beauty of the Gardens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice is a caretaker of <code>n</code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>flowers</code> of size <code>n</code>, where <code>flowers[i]</code> is the number of flowers already planted in the <code>i<sup>th</sup></code> garden. Flowers that are already planted <strong>cannot</strong> be removed. You are then given another integer <code>newFlowers</code>, which is the <strong>maximum</strong> number of flowers that Alice can additionally plant. You are also given the integers <code>target</code>, <code>full</code>, and <code>partial</code>.</p>

<p>A garden is considered <strong>complete</strong> if it has <strong>at least</strong> <code>target</code> flowers. The <strong>total beauty</strong> of the gardens is then determined as the <strong>sum</strong> of the following:</p>

<ul>
	<li>The number of <strong>complete</strong> gardens multiplied by <code>full</code>.</li>
	<li>The <strong>minimum</strong> number of flowers in any of the <strong>incomplete</strong> gardens multiplied by <code>partial</code>. If there are no incomplete gardens, then this value will be <code>0</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> total beauty that Alice can obtain after planting at most </em><code>newFlowers</code><em> flowers.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
<strong>Output:</strong> 14
<strong>Explanation:</strong> Alice can plant
- 2 flowers in the 0<sup>th</sup> garden
- 3 flowers in the 1<sup>st</sup> garden
- 1 flower in the 2<sup>nd</sup> garden
- 1 flower in the 3<sup>rd</sup> garden
The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.
There is 1 garden that is complete.
The minimum number of flowers in the incomplete gardens is 2.
Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.
No other way of planting flowers can obtain a total beauty higher than 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
<strong>Output:</strong> 30
<strong>Explanation:</strong> Alice can plant
- 3 flowers in the 0<sup>th</sup> garden
- 0 flowers in the 1<sup>st</sup> garden
- 0 flowers in the 2<sup>nd</sup> garden
- 2 flowers in the 3<sup>rd</sup> garden
The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.
There are 3 gardens that are complete.
The minimum number of flowers in the incomplete gardens is 4.
Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.
No other way of planting flowers can obtain a total beauty higher than 30.
Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>
	<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/description" target="_blank" rel="noopener noreferrer">Maximum Trailing Zeros in a Cornered Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>grid</code> of size <code>m x n</code>, where each cell contains a positive integer.</p>

<p>A <strong>cornered path</strong> is defined as a set of adjacent cells with <strong>at most</strong> one turn. More specifically, the path should exclusively move either <strong>horizontally</strong> or <strong>vertically</strong> up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the <strong>alternate</strong> direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.</p>

<p>The <strong>product</strong> of a path is defined as the product of all the values in the path.</p>

<p>Return <em>the <strong>maximum</strong> number of <strong>trailing zeros</strong> in the product of a cornered path found in </em><code>grid</code>.</p>

<p>Note:</p>

<ul>
	<li><strong>Horizontal</strong> movement means moving in either the left or right direction.</li>
	<li><strong>Vertical</strong> movement means moving in either the up or down direction.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg" style="width: 577px; height: 190px;" />
<pre>
<strong>Input:</strong> grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The grid on the left shows a valid cornered path.
It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.
It can be shown that this is the maximum trailing zeros in the product of a cornered path.

The grid in the middle is not a cornered path as it has more than one turn.
The grid on the right is not a cornered path as it requires a return to a previously visited cell.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg" style="width: 150px; height: 157px;" />
<pre>
<strong>Input:</strong> grid = [[4,3,2],[7,6,1],[8,8,8]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The grid is shown in the figure above.
There are no cornered paths in the grid that result in a product with a trailing zero.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-value-of-k-coins-from-piles/description" target="_blank" rel="noopener noreferrer">Maximum Value of K Coins From Piles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> <strong>piles</strong> of coins on a table. Each pile consists of a <strong>positive number</strong> of coins of assorted denominations.</p>

<p>In one move, you can choose any coin on <strong>top</strong> of any pile, remove it, and add it to your wallet.</p>

<p>Given a list <code>piles</code>, where <code>piles[i]</code> is a list of integers denoting the composition of the <code>i<sup>th</sup></code> pile from <strong>top to bottom</strong>, and a positive integer <code>k</code>, return <em>the <strong>maximum total value</strong> of coins you can have in your wallet if you choose <strong>exactly</strong></em> <code>k</code> <em>coins optimally</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" style="width: 600px; height: 243px;" />
<pre>
<strong>Input:</strong> piles = [[1,100,3],[7,8,9]], k = 2
<strong>Output:</strong> 101
<strong>Explanation:</strong>
The above diagram shows the different ways we can choose k coins.
The maximum total we can obtain is 101.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
<strong>Output:</strong> 706
<strong>Explanation:
</strong>The maximum total can be obtained if we choose all coins from the last pile.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == piles.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/description" target="_blank" rel="noopener noreferrer">Maximum White Tiles Covered by a Carpet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>tiles</code> where <code>tiles[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> represents that every tile <code>j</code> in the range <code>l<sub>i</sub> &lt;= j &lt;= r<sub>i</sub></code> is colored white.</p>

<p>You are also given an integer <code>carpetLen</code>, the length of a single carpet that can be placed <strong>anywhere</strong>.</p>

<p>Return <em>the <strong>maximum</strong> number of white tiles that can be covered by the carpet</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png" style="width: 644px; height: 158px;" />
<pre>
<strong>Input:</strong> tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
<strong>Output:</strong> 9
<strong>Explanation:</strong> Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png" style="width: 231px; height: 168px;" />
<pre>
<strong>Input:</strong> tiles = [[10,11],[1,1]], carpetLen = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tiles.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>tiles[i].length == 2</code></li>
	<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= carpetLen &lt;= 10<sup>9</sup></code></li>
	<li>The <code>tiles</code> are <strong>non-overlapping</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-xor-for-each-query/description" target="_blank" rel="noopener noreferrer">Maximum XOR for Each Query</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>sorted</strong> array <code>nums</code> of <code>n</code> non-negative integers and an integer <code>maximumBit</code>. You want to perform the following query <code>n</code> <strong>times</strong>:</p>

<ol>
	<li>Find a non-negative integer <code>k &lt; 2<sup>maximumBit</sup></code> such that <code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> is <strong>maximized</strong>. <code>k</code> is the answer to the <code>i<sup>th</sup></code> query.</li>
	<li>Remove the <strong>last </strong>element from the current array <code>nums</code>.</li>
</ol>

<p>Return <em>an array</em> <code>answer</code><em>, where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,1,3], maximumBit = 2
<strong>Output:</strong> [0,3,2,3]
<strong>Explanation</strong>: The queries are answered as follows:
1<sup>st</sup> query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
2<sup>nd</sup> query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
3<sup>rd</sup> query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
4<sup>th</sup> query: nums = [0], k = 3 since 0 XOR 3 = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,4,7], maximumBit = 3
<strong>Output:</strong> [5,2,6,5]
<strong>Explanation</strong>: The queries are answered as follows:
1<sup>st</sup> query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
2<sup>nd</sup> query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
3<sup>rd</sup> query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
4<sup>th</sup> query: nums = [2], k = 5 since 2 XOR 5 = 7.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,2,2,5,7], maximumBit = 3
<strong>Output:</strong> [4,3,6,4,6,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= maximumBit &lt;= 20</code></li>
	<li><code>0 &lt;= nums[i] &lt; 2<sup>maximumBit</sup></code></li>
	<li><code>nums</code>â€‹â€‹â€‹ is sorted in <strong>ascending</strong> order.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, we have to answer <code>n</code> queries. To answer the <code>i</code>-th query, we have to find the <code>k</code> where <code>k</code> has to be less than <span class="math inline">\(2^{\text{maximumBit}}\)</span> and maximizes the <span class="math inline">\(XOR\)</span> product between <code>k</code> and <code>nums[0], nums[1],..., nums[i]</code>. We will explore two approaches that will dive into how to calculate this <code>k</code> efficiently for all queries.</p>
<h3 id="approach-1-prefix-array--bit-masking">Approach 1: Prefix Array + Bit Masking</h3>
<h4 id="intuition">Intuition</h4>
<p>For the <code>i-th</code> query, we need to first calculate the <span class="math inline">\(XOR\)</span> product for the numbers <code>nums[0], nums[1],..., nums[i]</code>. Once we have this XOR value, which we'll call <code>product</code>, we want to find a <code>k</code> that maximizes the result of <code>k XOR product</code>. We first discuss how to find the <code>product</code> for each query efficiently.</p>
<p>To efficiently calculate the initial <code>product</code> for each query, we can save time by precomputing these values. We do this by performing a linear scan through the <code>nums</code> array to build a prefix array called <code>prefixXOR</code>. In this array, <code>prefixXOR[i]</code> will hold the XOR product of all numbers from <code>nums[0]</code> to <code>nums[i]</code>. For any query at index <code>i</code>, we can easily retrieve the <code>product</code> as <code>prefixXOR[i]</code>.</p>
<p>Now that we have the <code>product</code> for each query, our next task is to find a <code>k</code> that will maximize <code>k XOR product</code>. A brute force approach would involve trying all possible bit combinations for <code>k</code>, where there is a total of <span class="math inline">\(2^{\text{maximumBit}}\)</span> bit combinations, and selecting the one that has the highest <code>k XOR product</code> value.</p>
<p>However, due to the constraint on <code>k</code> where <code>k</code> can only have at most <code>maximumBit</code> bits, we know that we can only ever change at most the first <code>maximumBit</code> bits of <code>product</code> when maximizing our value of <code>k XOR product</code>. Specifically, we can achieve the greatest value by choosing a <code>k</code> that will make the first <code>maximumBits</code> bits set to all <code>1</code>s. Because the <span class="math inline">\(XOR\)</span> operator evaluates to 1 when the operands differ (0 and 1, or 1 and 0), we can do this by setting our <code>k</code> as the inverse of the first <code>maximumBits</code> of <code>product</code>. Because each respective bit is different, the XOR between a number and its inverse will lead to all bits being set to 1.</p>
<p>To quickly find this inverse, we create a bitmask called <code>mask</code>. This mask can be generated using the formula <code>mask = (1 &lt;&lt; maximumBit) - 1</code>, which gives us a number where the first <code>maximumBit</code> bits are set to <code>1</code>. Then, to get our desired <code>k</code> for a given <code>product</code>, we can simply compute <code>product XOR mask</code>. Here, if a bit in <code>product</code> is set to 0, its XOR with the respective bit from <code>mask</code> set to 1 will make the resulting bit 1. Similarly, if the bit in <code>product</code> is set to 1, its XOR with the respective bit from <code>mask</code> will make the resulting bit 0. Thus, applying this mask will provide us with the inverse of the first <code>maximumBits</code> of <code>product</code>, which is the value of <code>k</code> that maximizes our result.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Calculate prefix array <code>prefixXOR</code> to store the prefix <code>XOR</code> products for all the queries:
<ul>
<li>Initialize <code>prefixXOR[0]</code> to <code>nums[0]</code></li>
<li>From <code>i = 1</code> to <code>i = nums.length - 1</code>:
<ul>
<li><code>prefixXOR[i] = prefixXOR[i - 1] XOR nums[i]</code></li>
</ul>
</li>
</ul>
</li>
<li>Define our bitmask <code>mask = (1 &lt;&lt; maximumBit) - 1</code></li>
<li>Initialize our answer array <code>ans</code></li>
<li>Answer each query and populate <code>ans</code>:
<ul>
<li>From <code>i = 0</code> to <code>i = nums.length - 1</code>:
<ul>
<li>The current XOR product we're dealing with is <code>product = prefixXOR[-i]</code></li>
<li>Set <code>ans[i]</code> to be <code>product XOR mask</code>, giving us a <code>k</code> that inverts the first <code>maximumBit</code> bits of <code>product</code> to maximize our value <code>product XOR k</code></li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8CLG94ay/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Calculating our prefix array takes <span class="math inline">\(O(n)\)</span> time. Going through all <code>n</code> queries will take <span class="math inline">\(O(n)\)</span> time where the <span class="math inline">\(XOR\)</span> calculation for each query takes constant time. Thus, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Our prefix array has a size of <span class="math inline">\(n\)</span>, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-calculation--bit-masking">Approach 2: Optimized Calculation + Bit Masking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, we used a prefix array to quickly fetch the relevant XOR product for each query. In this approach, we explore a more space-efficient way to do so.</p>
<p>For the first query, we notice that we start with the <span class="math inline">\(XOR\)</span> product that involves all numbers in <code>nums</code>. As we move on to each subsequent query, we calculate a new <span class="math inline">\(XOR\)</span> product that drops the last number in the previous calculation.</p>
<p>To do this, we can start by calculating the initial XOR product, which we'll call<code>firstProduct</code>. This represents the XOR of all numbers in <code>nums</code>. This will give us the starting product used in the first query. Then, for each query <code>i</code>, we can then update <code>firstProduct</code> by removing the <code>i-th</code> last element from our previous calculations. We do this with the expression <code>firstProduct = firstProduct XOR nums[-i]</code>.</p>
<p>The insight here is that when we XOR the same number again, it cancels itself out. This means that by applying the XOR operation to <code>firstProduct</code> with <code>nums[-i]</code>, we effectively remove that element from our calculations. This approach allows us to update the XOR product for each query efficiently without needing to recalculate everything from scratch.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Calculate our initial <span class="math inline">\(XOR\)</span> product:
<ul>
<li><code>xorProduct = 0</code></li>
<li>For each <code>num</code> in <code>nums</code>: <code>xorProduct = xorProduct XOR num</code></li>
</ul>
</li>
<li>Define our bitmask <code>mask = (1 &lt;&lt; maximumBit) - 1</code></li>
<li>Initialize our answer array <code>ans</code></li>
<li>Answer each query and populate <code>ans</code>:
<ul>
<li>From <code>i = 0</code> to <code>i = nums.length - 1</code>:
<ul>
<li>Set <code>ans[i]</code> to be <code>xorProduct XOR mask</code>, giving us a <code>k</code> that inverts the first <code>maximumBit</code> bits of <code>product</code> to maximize our value <code>product XOR k</code></li>
<li>Update <code>xorProduct</code> for the next query by removing the last element: <code>xorProduct = xorProduct XOR nums[-i]</code></li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Kf3i7SsP/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Going through all <code>n</code> queries will take <span class="math inline">\(O(n)\)</span> time where the <span class="math inline">\(XOR\)</span> calculations for each query take constant time. Thus, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not have any auxiliary data structures besides the required <code>ans</code> array, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description" target="_blank" rel="noopener noreferrer">Max Sum of Rectangle No Larger Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix <code>matrix</code> and an integer <code>k</code>, return <em>the max sum of a rectangle in the matrix such that its sum is no larger than</em> <code>k</code>.</p>

<p>It is <strong>guaranteed</strong> that there will be a rectangle with a sum no larger than <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" style="width: 255px; height: 176px;" />
<pre>
<strong>Input:</strong> matrix = [[1,0,1],[0,-2,3]], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[2,2,-1]], k = 3
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> What if the number of rows is much larger than the number of columns?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-operations-for-minimum-travel-time/description" target="_blank" rel="noopener noreferrer">Merge Operations for Minimum Travel Time</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="452" data-start="24">You are given a straight road of length <code>l</code> km, an integer <code>n</code>, an integer <code>k</code><strong data-end="83" data-start="78">, </strong>and <strong>two</strong> integer arrays, <code>position</code> and <code>time</code>, each of length <code>n</code>.</p>

<p data-end="452" data-start="24">The array <code>position</code> lists the positions (in km) of signs in <strong>strictly</strong> increasing order (with <code>position[0] = 0</code> and <code>position[n - 1] = l</code>).</p>

<p data-end="452" data-start="24">Each <code>time[i]</code> represents the time (in minutes) required to travel 1 km between <code>position[i]</code> and <code>position[i + 1]</code>.</p>

<p data-end="593" data-start="454">You <strong>must</strong> perform <strong>exactly</strong> <code>k</code> merge operations. In one merge, you can choose any <strong>two</strong> adjacent signs at indices <code>i</code> and <code>i + 1</code> (with <code>i &gt; 0</code> and <code>i + 1 &lt; n</code>) and:</p>

<ul data-end="701" data-start="595">
	<li data-end="624" data-start="595">Update the sign at index <code>i + 1</code> so that its time becomes <code>time[i] + time[i + 1]</code>.</li>
	<li data-end="624" data-start="595">Remove the sign at index <code>i</code>.</li>
</ul>

<p data-end="846" data-start="703">Return the <strong>minimum</strong> <strong>total</strong> <strong>travel time</strong> (in minutes) to travel from 0 to <code>l</code> after <strong>exactly</strong> <code>k</code> merges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">l = 10, n = 4, k = 1, position = [0,3,8,10], time = [5,8,3,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">62</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="121" data-start="11">
	<p data-end="121" data-start="13">Merge the signs at indices 1 and 2. Remove the sign at index 1, and change the time at index 2 to <code>8 + 3 = 11</code>.</p>
	</li>
	<li data-end="144" data-start="15">After the merge:
	<ul>
		<li data-end="214" data-start="145"><code>position</code> array: <code>[0, 8, 10]</code></li>
		<li data-end="214" data-start="145"><code>time</code> array: <code>[5, 11, 6]</code></li>
		<li data-end="214" data-start="145" style="opacity: 0"> </li>
	</ul>
	</li>
	<li data-end="214" data-start="145">
	<table data-end="386" data-start="231" style="border: 1px solid black;">
		<thead data-end="269" data-start="231">
			<tr data-end="269" data-start="231">
				<th data-end="241" data-start="231" style="border: 1px solid black;">Segment</th>
				<th data-end="252" data-start="241" style="border: 1px solid black;">Distance (km)</th>
				<th data-end="260" data-start="252" style="border: 1px solid black;">Time per km (min)</th>
				<th data-end="269" data-start="260" style="border: 1px solid black;">Segment Travel Time (min)</th>
			</tr>
		</thead>
		<tbody data-end="386" data-start="309">
			<tr data-end="347" data-start="309">
				<td style="border: 1px solid black;">0 &rarr; 8</td>
				<td style="border: 1px solid black;">8</td>
				<td style="border: 1px solid black;">5</td>
				<td style="border: 1px solid black;">8 &times; 5 = 40</td>
			</tr>
			<tr data-end="386" data-start="348">
				<td style="border: 1px solid black;">8 &rarr; 10</td>
				<td style="border: 1px solid black;">2</td>
				<td style="border: 1px solid black;">11</td>
				<td style="border: 1px solid black;">2 &times; 11 = 22</td>
			</tr>
		</tbody>
	</table>
	</li>
	<li data-end="214" data-start="145">Total Travel Time: <code>40 + 22 = 62</code>, which is the minimum possible time after exactly 1 merge.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">l = 5, n = 5, k = 1, position = [0,1,2,3,5], time = [8,3,9,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">34</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li data-end="567" data-start="438">Merge the signs at indices 1 and 2. Remove the sign at index 1, and change the time at index 2 to <code>3 + 9 = 12</code>.</li>
	<li data-end="755" data-start="568">After the merge:
	<ul>
		<li data-end="755" data-start="568"><code>position</code> array: <code>[0, 2, 3, 5]</code></li>
		<li data-end="755" data-start="568"><code>time</code> array: <code>[8, 12, 3, 3]</code></li>
		<li data-end="755" data-start="568" style="opacity: 0"> </li>
	</ul>
	</li>
	<li data-end="755" data-start="568">
	<table data-end="966" data-start="772" style="border: 1px solid black;">
		<thead data-end="810" data-start="772">
			<tr data-end="810" data-start="772">
				<th data-end="782" data-start="772" style="border: 1px solid black;">Segment</th>
				<th data-end="793" data-start="782" style="border: 1px solid black;">Distance (km)</th>
				<th data-end="801" data-start="793" style="border: 1px solid black;">Time per km (min)</th>
				<th data-end="810" data-start="801" style="border: 1px solid black;">Segment Travel Time (min)</th>
			</tr>
		</thead>
		<tbody data-end="966" data-start="850">
			<tr data-end="888" data-start="850">
				<td style="border: 1px solid black;">0 &rarr; 2</td>
				<td style="border: 1px solid black;">2</td>
				<td style="border: 1px solid black;">8</td>
				<td style="border: 1px solid black;">2 &times; 8 = 16</td>
			</tr>
			<tr data-end="927" data-start="889">
				<td style="border: 1px solid black;">2 &rarr; 3</td>
				<td style="border: 1px solid black;">1</td>
				<td style="border: 1px solid black;">12</td>
				<td style="border: 1px solid black;">1 &times; 12 = 12</td>
			</tr>
			<tr data-end="966" data-start="928">
				<td style="border: 1px solid black;">3 &rarr; 5</td>
				<td style="border: 1px solid black;">2</td>
				<td style="border: 1px solid black;">3</td>
				<td style="border: 1px solid black;">2 &times; 3 = 6</td>
			</tr>
		</tbody>
	</table>
	</li>
	<li data-end="755" data-start="568">Total Travel Time: <code>16 + 12 + 6 = 34</code><b>, </b>which is the minimum possible time after exactly 1 merge.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="35" data-start="15"><code>1 &lt;= l &lt;= 10<sup>5</sup></code></li>
	<li data-end="52" data-start="36"><code>2 &lt;= n &lt;= min(l + 1, 50)</code></li>
	<li data-end="81" data-start="53"><code>0 &lt;= k &lt;= min(n - 2, 10)</code></li>
	<li data-end="81" data-start="53"><code>position.length == n</code></li>
	<li data-end="81" data-start="53"><code>position[0] = 0</code> and <code>position[n - 1] = l</code></li>
	<li data-end="200" data-start="80"><code>position</code> is sorted in strictly increasing order.</li>
	<li data-end="81" data-start="53"><code>time.length == n</code></li>
	<li data-end="81" data-start="53"><code>1 &lt;= time[i] &lt;= 100â€‹</code></li>
	<li data-end="81" data-start="53"><code>1 &lt;= sum(time) &lt;= 100</code>â€‹â€‹â€‹â€‹â€‹â€‹</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-of-array/description" target="_blank" rel="noopener noreferrer">Minimize Maximum of Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> comprising of <code>n</code> non-negative integers.</p>

<p>In one operation, you must:</p>

<ul>
	<li>Choose an integer <code>i</code> such that <code>1 &lt;= i &lt; n</code> and <code>nums[i] &gt; 0</code>.</li>
	<li>Decrease <code>nums[i]</code> by 1.</li>
	<li>Increase <code>nums[i - 1]</code> by 1.</li>
</ul>

<p>Return<em> the <strong>minimum</strong> possible value of the <strong>maximum</strong> integer of </em><code>nums</code><em> after performing <strong>any</strong> number of operations</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,7,1,6]
<strong>Output:</strong> 5
<strong>Explanation:</strong>
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,1]
<strong>Output:</strong> 10
<strong>Explanation:</strong>
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/description" target="_blank" rel="noopener noreferrer">Minimum Adjacent Swaps for K Consecutive Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array, <code>nums</code>, and an integer <code>k</code>. <code>nums</code> comprises of only <code>0</code>&#39;s and <code>1</code>&#39;s. In one move, you can choose two <strong>adjacent</strong> indices and swap their values.</p>

<p>Return <em>the <strong>minimum</strong> number of moves required so that </em><code>nums</code><em> has </em><code>k</code><em> <strong>consecutive</strong> </em><code>1</code><em>&#39;s</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,0,1,0,1], k = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> In 1 move, nums could be [1,0,0,0,<u>1</u>,<u>1</u>] and have 2 consecutive 1&#39;s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,0,0,0,0,1,1], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,<u>1</u>,<u>1</u>,<u>1</u>].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,0,1], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums already has 2 consecutive 1&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= k &lt;= sum(nums)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/description" target="_blank" rel="noopener noreferrer">Minimum Amount of Time to Collect Garbage</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of strings <code>garbage</code> where <code>garbage[i]</code> represents the assortment of garbage at the <code>i<sup>th</sup></code> house. <code>garbage[i]</code> consists only of the characters <code>&#39;M&#39;</code>, <code>&#39;P&#39;</code> and <code>&#39;G&#39;</code> representing one unit of metal, paper and glass garbage respectively. Picking up <strong>one</strong> unit of any type of garbage takes <code>1</code> minute.</p>

<p>You are also given a <strong>0-indexed</strong> integer array <code>travel</code> where <code>travel[i]</code> is the number of minutes needed to go from house <code>i</code> to house <code>i + 1</code>.</p>

<p>There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house <code>0</code> and must visit each house <strong>in order</strong>; however, they do <strong>not</strong> need to visit every house.</p>

<p>Only <strong>one</strong> garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks <strong>cannot</strong> do anything.</p>

<p>Return<em> the <strong>minimum</strong> number of minutes needed to pick up all the garbage.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> garbage = [&quot;G&quot;,&quot;P&quot;,&quot;GP&quot;,&quot;GG&quot;], travel = [2,4,3]
<strong>Output:</strong> 21
<strong>Explanation:</strong>
The paper garbage truck:
1. Travels from house 0 to house 1
2. Collects the paper garbage at house 1
3. Travels from house 1 to house 2
4. Collects the paper garbage at house 2
Altogether, it takes 8 minutes to pick up all the paper garbage.
The glass garbage truck:
1. Collects the glass garbage at house 0
2. Travels from house 0 to house 1
3. Travels from house 1 to house 2
4. Collects the glass garbage at house 2
5. Travels from house 2 to house 3
6. Collects the glass garbage at house 3
Altogether, it takes 13 minutes to pick up all the glass garbage.
Since there is no metal garbage, we do not need to consider the metal garbage truck.
Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> garbage = [&quot;MMM&quot;,&quot;PGM&quot;,&quot;GP&quot;], travel = [3,10]
<strong>Output:</strong> 37
<strong>Explanation:</strong>
The metal garbage truck takes 7 minutes to pick up all the metal garbage.
The paper garbage truck takes 15 minutes to pick up all the paper garbage.
The glass garbage truck takes 15 minutes to pick up all the glass garbage.
It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= garbage.length &lt;= 10<sup>5</sup></code></li>
	<li><code>garbage[i]</code> consists of only the letters <code>&#39;M&#39;</code>, <code>&#39;P&#39;</code>, and <code>&#39;G&#39;</code>.</li>
	<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>
	<li><code>travel.length == garbage.length - 1</code></li>
	<li><code>1 &lt;= travel[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hashmap">Approach 1: HashMap</h3>
<p><strong>Intuition</strong></p>
<p>The first observation we can make from the problem statement is that all three trucks will pick up only one type of garbage and hence they all will work independently. In other words, the order of different trucks will not matter. Now, let's try to find the minimum time required for a truck to collect a certain type of garbage (say type <code>M</code>). Since we need to collect all the garbage <code>M</code> and picking one unit of garbage <code>M</code> takes one unit of time, the count of garbage <code>M</code> in all the houses is the minimum amount of time required for the truck to collect this type of garbage.</p>
<p>Now, we need to find the minimum time required for the truck to travel across the houses to reach all the <code>M</code> type garbage. Each truck will start from house <code>0</code>, but it doesn't have to go to each house. Also, the truck can only visit houses in order. So if there is no garbage of type <code>M</code> at the last house the truck doesn't have to go to the last house. This implies that the truck only needs to travel to the last house having that type of garbage. For example, if the truck needs to collect the <code>M</code> type garbage and the houses are <code>[&quot;G&quot;,&quot;P&quot;,&quot;MGP&quot;,&quot;GG&quot;]</code>, then the truck only needs to travel from index <code>0</code> to <code>2</code>.</p>
<p>Therefore, we will find the time required for each truck separately. For each type of garbage, we will find the total count in all the houses (say <code>x</code>) and also find the index of the last house having this garbage (say <code>i</code>). The time to collect this type of garbage will be <code>x + travel[0] + travel[1] + ... + travel[i - 1]</code>, this is because the truck will need to travel all houses from index <code>0</code> to index <code>i </code>, and <code>travel[i - 1]</code> is the time to travel from the house at index <code>i - 1</code> to <code>i</code>. To find the sum of the first <code>i</code> elements in the array <code>travel</code>, we will create a prefix sum array to fetch it in constant time. This array <code>prefixSum</code> will start from index one (<code>prefixSum[0]</code> will be <code>0</code>, since the truck starts from the house <code>0</code>). This way, when we need to find the total time to reach house <code>0</code>, we can find it in <code>prefixSum[0]</code>, and the total time to reach house <code>1</code> will be found in index <code>prefixSum[1]</code>, and so on.</p>
<p><img src="../Figures/2391-re/2391Afix.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize an array <code>prefixSum</code> of the size  <code>travel.length + 1</code>, the <code>$i_{th}$</code> value in this array will store the sum of first <code>i - 1</code> elements in the array <code>travel</code>.</li>
<li>Initialize an empty map <code>garbageLastPos</code> from character to integer, this map will store the last index of the house for the type of garbage equal to the key.</li>
<li>Initialize an empty map <code>garbageCount</code> from character to integer, this map will store the count of the type of garbage represented by the key in all the houses.</li>
<li>Iterate over the array <code>garbage</code> and iterate over each garbage for each house, increment the count in <code>garbageCount</code> and store the index in the map <code>garbageLastPos</code>.</li>
<li>Iterate over each garbage type and for each type (say <code>c</code>) add the <code>garbageCount[c]</code> and <code>prefixSum[garbageLastPos[c]]</code> to the answer variable <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/5c5MypvC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of houses in the array <code>garbage</code>, and <span class="math inline">\(K\)</span> is the maximum length <code>garbage[i]</code>.</p>
<ul>
<li>
<p>Time complexity <span class="math inline">\(O(N * K)\)</span></p>
<p>We first iterate over the array <code>travel</code> to create the <code>prefixSum</code>, the size of <code>travel</code> is <span class="math inline">\(N\)</span> and hence this will take <span class="math inline">\(O(N)\)</span> time. We then iterate over the <code>garbage</code> array and for each string in the array we iterate over each character to store info in the maps <code>garbageLastPos</code> and <code>garbageCount</code>, this operation will take <span class="math inline">\(O(N * K)\)</span> time. In the end, we just iterate over the three garbage types and add the corresponding answer to <code>ans</code>. Hence, the total time complexity is equal to <span class="math inline">\(O(N * K)\)</span></p>
</li>
<li>
<p>Space complexity <span class="math inline">\(O(N)\)</span></p>
<p>We have created an array <code>prefixSum</code> of size <span class="math inline">\(N\)</span>. We also have the maps to store the last position and the count, however, the space required by these maps can be considered constant as the only keys we need are three (<code>M</code>, <code>P</code>, <code>G</code>). Therefore, the total space complexity can be written as <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-2-hashmap-and-in-place-modification">Approach 2: HashMap and In-place Modification</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Note: This approach requires altering of given input which is generally not recommended. This approach has been added for the sake of competition and should be discussed in an interview setting only if asked explicitly.</p>
</blockquote>
<p>Let's try to save some space in our previous approach. Due to the array <code>prefixSum</code> we have incurred <span class="math inline">\(O(N)\)</span> space in our previous approach. To save space here, we can store the prefix sums in the <code>travel</code> array itself instead of creating a new array. This will work because we only need the <code>travel</code> array for the prefix sums and not the individual values. Another optimization that can be done is for the map <code>garbageCount</code>,  where we store the count of each garbage type, however, instead of returning the time to collect each type of garbage, we only need to return the total time to collect all the garbage. Therefore, we can store the total count of all garbage in a variable instead of a map.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create the prefix sum array <code>travel</code> by using the equation <code>travel[i] = travel[i - 1] + travel[i]</code>.</li>
<li>Initialize an empty map <code>garbageLastPos</code> from character to integer, this map will store the last index of the house for the type of garbage equal to the key.</li>
<li>Iterate over the array <code>garbage</code> and iterate over each garbage for each house, store the index in the map <code>garbageLastPos</code> and add the length of <code>garbage[i]</code> to the variable <code>ans</code>.</li>
<li>Iterate over each garbage type and for each type (say <code>c</code>) add the <code>prefixSum[garbageLastPos[c] - 1]</code> to the answer variable <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/bLfbvtbN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of houses in the array <code>garbage</code> and <span class="math inline">\(K\)</span> is the maximum length of garbage in the array <code>garbage</code>.</p>
<ul>
<li>
<p>Time complexity <span class="math inline">\(O(N * K)\)</span></p>
<p>We first iterate over the array <code>travel</code> to create the <code>prefixSum</code>, the size of <code>travel</code> is <span class="math inline">\(N\)</span> and hence this will take <span class="math inline">\(O(N)\)</span> time. We then iterate over the <code>garbage</code> array and for each string in the array we iterate over each character to store info in the maps <code>garbageLastPos</code>, this operation will take <span class="math inline">\(O(N * K)\)</span> time. In the end, we just iterate over the three garbage types and add the corresponding answer to <code>ans</code>. Hence, the total time complexity is equal to <span class="math inline">\(O(N * K)\)</span></p>
</li>
<li>
<p>Space complexity <span class="math inline">\(O(1)\)</span></p>
<p>The only extra space we used is the map to store the last position, however, the space required by this map can be considered constant as the only keys that we need are three (<code>M</code>, <code>P</code>, <code>G</code>). Therefore, the total space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterate-in-reverse">Approach 3: Iterate in Reverse</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we have been traversing in a forward direction, which can lead to a small issue: we do not know if we will encounter a certain type of garbage in the future, and this result will determine whether we need to send a garbage truck for that specific type of garbage to this location.</p>
<p>For example, suppose we start from house <code>i = 1</code> and move to house <code>i = 1</code> without finding any type <code>M</code> garbage. However, at this point, we cannot guarantee that the <code>M</code> garbage truck does not need to travel from <code>i = 0</code> to <code>i = 1</code>. This is because if future houses at index <code>i = 2</code>, <code>i = 3</code>, etc, have garbage <code>M</code>, then we still need the garbage truck <code>M</code> to travel from house <code>i = 0</code> to house <code>i = 1</code>. We rely on a future value to determine whether to keep the current calculated value, hmm, it doesn't seem quite satisfactory.</p>
<p>This inspires us, what if we switch the order of traversal? This way, we can ensure that as long as we do not encounter a certain type of garbage during the reverse traversal process, it means that the garbage truck of that type will never need to travel these distances! This simplifies our calculations!</p>
<p>For example, when we traverse in reverse from <code>i = n - 1</code> to <code>i = 10</code>, and we haven't encountered any type <code>M</code> garbage, it means that garbage truck <code>M</code> doesn't need to visit these houses until we encounter the first house (in reverse order) that has type <code>M</code> garbage. At that point, we can immediately determine that garbage truck <code>M</code> will arrive there and finish its journey, that's it.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize boolean (or int) variables <code>M</code>, <code>P</code>, and <code>G</code> to <code>false</code> (<code>0</code>) to represent the presence of specific type of garbages ('M', 'P', 'G') we have encountered so far.</li>
<li>Initialize the variable <code>ans</code> to the length of the first garbage string in the array since we will collect them after all.</li>
<li>Iterate through the <code>garbage</code> array in reverse order, starting from the last element (at index <code>garbage.length - 1</code>) and moving backwards to the second element (index <code>1</code>). For each step <code>i</code> inside the loop:
<ul>
<li>Update variables <code>M</code>, <code>P</code>, and <code>G</code> based on whether the current <code>garbage[i]</code> contains the characters 'M', 'P', and 'G' respectively.</li>
<li>Multiply <code>travel[i - 1]</code> by the sum of the equivalent integer values of <code>M</code>, <code>P</code>, and <code>G</code> (<code>1</code> if <code>true</code>, <code>0</code> if <code>false</code>). Add this value to <code>ans</code>.</li>
<li>Add the length of <code>garbage[i]</code> to the <code>ans</code>.</li>
</ul>
</li>
<li>After the iteration ends, <code>ans</code> will hold the total amount of time. Return the final <code>ans</code> as the result.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/HZzkg5id/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of houses in the array <code>garbage</code> and <span class="math inline">\(K\)</span> is the maximum length of garbage in the array <code>garbage</code>.</p>
<ul>
<li>
<p>Time complexity <span class="math inline">\(O(N * K)\)</span></p>
<p>We iterate over the array <code>garbage</code> in reverse and for each string in the array, we iterate over each character to and do <span class="math inline">\(O(1)\)</span> work, thus this operation will take <span class="math inline">\(O(N * K)\)</span> time.</p>
</li>
<li>
<p>Space complexity <span class="math inline">\(O(1)\)</span></p>
<p>The only extra space we used is the three variables <code>M</code>, <code>P</code>, and <code>G</code>. Therefore, the total space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-array-changes-to-make-differences-equal/description" target="_blank" rel="noopener noreferrer">Minimum Array Changes to Make Differences Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of size <code>n</code> where <code>n</code> is <strong>even</strong>, and an integer <code>k</code>.</p>

<p>You can perform some changes on the array, where in one change you can replace <strong>any</strong> element in the array with <strong>any</strong> integer in the range from <code>0</code> to <code>k</code>.</p>

<p>You need to perform some changes (possibly none) such that the final array satisfies the following condition:</p>

<ul>
	<li>There exists an integer <code>X</code> such that <code>abs(a[i] - a[n - i - 1]) = X</code> for all <code>(0 &lt;= i &lt; n)</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> number of changes required to satisfy the above condition.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,0,1,2,4,3], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong><br />
We can perform the following changes:</p>

<ul>
	<li>Replace <code>nums[1]</code> by 2. The resulting array is <code>nums = [1,<u><strong>2</strong></u>,1,2,4,3]</code>.</li>
	<li>Replace <code>nums[3]</code> by 3. The resulting array is <code>nums = [1,2,1,<u><strong>3</strong></u>,4,3]</code>.</li>
</ul>

<p>The integer <code>X</code> will be 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,1,2,3,3,6,5,4], k = 6</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong><br />
We can perform the following operations:</p>

<ul>
	<li>Replace <code>nums[3]</code> by 0. The resulting array is <code>nums = [0,1,2,<u><strong>0</strong></u>,3,6,5,4]</code>.</li>
	<li>Replace <code>nums[4]</code> by 4. The resulting array is <code>nums = [0,1,2,0,<strong><u>4</u></strong>,6,5,4]</code>.</li>
</ul>

<p>The integer <code>X</code> will be 4.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>n</code> is even.</li>
	<li><code>0 &lt;= nums[i] &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-average-difference/description" target="_blank" rel="noopener noreferrer">Minimum Average Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p>The <strong>average difference</strong> of the index <code>i</code> is the <strong>absolute</strong> <strong>difference</strong> between the average of the <strong>first</strong> <code>i + 1</code> elements of <code>nums</code> and the average of the <strong>last</strong> <code>n - i - 1</code> elements. Both averages should be <strong>rounded down</strong> to the nearest integer.</p>

<p>Return<em> the index with the <strong>minimum average difference</strong></em>. If there are multiple such indices, return the <strong>smallest</strong> one.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The <strong>absolute difference</strong> of two numbers is the absolute value of their difference.</li>
	<li>The <strong>average</strong> of <code>n</code> elements is the <strong>sum</strong> of the <code>n</code> elements divided (<strong>integer division</strong>) by <code>n</code>.</li>
	<li>The average of <code>0</code> elements is considered to be <code>0</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5,3,9,5,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
The average difference of index 3 is the minimum average difference so return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
The only index is 0 so return 0.
The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-divide-array-into-subarrays/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Divide Array Into Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays, <code>nums</code> and <code>cost</code>, of the same size, and an integer <code>k</code>.</p>

<p>You can divide <code>nums</code> into <span data-keyword="subarray-nonempty">subarrays</span>. The cost of the <code>i<sup>th</sup></code> subarray consisting of elements <code>nums[l..r]</code> is:</p>

<ul>
	<li><code>(nums[0] + nums[1] + ... + nums[r] + k * i) * (cost[l] + cost[l + 1] + ... + cost[r])</code>.</li>
</ul>

<p><strong>Note</strong> that <code>i</code> represents the order of the subarray: 1 for the first subarray, 2 for the second, and so on.</p>

<p>Return the <strong>minimum</strong> total cost possible from any valid division.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,1,4], cost = [4,6,6], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">110</span></p>

<p><strong>Explanation:</strong></p>
The minimum total cost possible can be achieved by dividing <code>nums</code> into subarrays <code>[3, 1]</code> and <code>[4]</code>.

<ul>
	<li>The cost of the first subarray <code>[3,1]</code> is <code>(3 + 1 + 1 * 1) * (4 + 6) = 50</code>.</li>
	<li>The cost of the second subarray <code>[4]</code> is <code>(3 + 1 + 4 + 1 * 2) * 6 = 60</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,8,5,1,14,2,2,12,1], cost = [7,2,8,4,2,2,1,1,2], k = 7</span></p>

<p><strong>Output:</strong> 985</p>

<p><strong>Explanation:</strong></p>
The minimum total cost possible can be achieved by dividing <code>nums</code> into subarrays <code>[4, 8, 5, 1]</code>, <code>[14, 2, 2]</code>, and <code>[12, 1]</code>.

<ul>
	<li>The cost of the first subarray <code>[4, 8, 5, 1]</code> is <code>(4 + 8 + 5 + 1 + 7 * 1) * (7 + 2 + 8 + 4) = 525</code>.</li>
	<li>The cost of the second subarray <code>[14, 2, 2]</code> is <code>(4 + 8 + 5 + 1 + 14 + 2 + 2 + 7 * 2) * (2 + 2 + 1) = 250</code>.</li>
	<li>The cost of the third subarray <code>[12, 1]</code> is <code>(4 + 8 + 5 + 1 + 14 + 2 + 2 + 12 + 1 + 7 * 3) * (1 + 2) = 210</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>cost.length == nums.length</code></li>
	<li><code>1 &lt;= nums[i], cost[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-array-equal/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make Array Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> arrays <code>nums</code> and <code>cost</code> consisting each of <code>n</code> <strong>positive</strong> integers.</p>

<p>You can do the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Increase or decrease <strong>any</strong> element of the array <code>nums</code> by <code>1</code>.</li>
</ul>

<p>The cost of doing one operation on the <code>i<sup>th</sup></code> element is <code>cost[i]</code>.</p>

<p>Return <em>the <strong>minimum</strong> total cost such that all the elements of the array </em><code>nums</code><em> become <strong>equal</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,2], cost = [2,3,1,14]
<strong>Output:</strong> 8
<strong>Explanation:</strong> We can make all the elements equal to 2 in the following way:
- Increase the 0<sup>th</sup> element one time. The cost is 2.
- Decrease the 1<sup><span style="font-size: 10.8333px;">st</span></sup> element one time. The cost is 3.
- Decrease the 2<sup>nd</sup> element three times. The cost is 1 + 1 + 1 = 3.
The total cost is 2 + 3 + 3 = 8.
It can be shown that we cannot make the array equal with a smaller cost.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,2,2], cost = [4,2,8,1,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All the elements are already equal, so no operations are needed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length == cost.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], cost[i] &lt;= 10<sup>6</sup></code></li>
	<li>Test cases are generated in a way that the output doesn&#39;t exceed&nbsp;2<sup>53</sup>-1</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-merge-stones/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Merge Stones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> piles of <code>stones</code> arranged in a row. The <code>i<sup>th</sup></code> pile has <code>stones[i]</code> stones.</p>

<p>A move consists of merging exactly <code>k</code> <strong>consecutive</strong> piles into one pile, and the cost of this move is equal to the total number of stones in these <code>k</code> piles.</p>

<p>Return <em>the minimum cost to merge all piles of stones into one pile</em>. If it is impossible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stones = [3,2,4,1], k = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> We start with [3, 2, 4, 1].
We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
We merge [4, 1] for a cost of 5, and we are left with [5, 5].
We merge [5, 5] for a cost of 10, and we are left with [10].
The total cost was 20, and this is the minimum possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stones = [3,2,4,1], k = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> After any merge operation, there are 2 piles left, and we can&#39;t merge anymore.  So the task is impossible.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> stones = [3,5,1,2,6], k = 3
<strong>Output:</strong> 25
<strong>Explanation:</strong> We start with [3, 5, 1, 2, 6].
We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].
We merge [3, 8, 6] for a cost of 17, and we are left with [17].
The total cost was 25, and this is the minimum possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stones.length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
	<li><code>2 &lt;= k &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimum-number-of-k-consecutive-bit-flips--171650/1" target="_blank" rel="noopener noreferrer">Minimum K Consecutive Bit Flips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmagic</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a binary array <strong>arr[]</strong> and an integer <strong>k</strong>.</span></p>
<p><span style="font-size: 14pt;">A <strong>k-bit flip</strong> involves selecting a contiguous subarray of length <strong>k </strong>from <strong>arr[] </strong>and flipping all its bits - changing every 0 to 1 and every 1 to 0 simultaneously.</span></p>
<p><span style="font-size: 14pt;">Your task is to return the minimum number of k-bit flips needed to eliminate all 0s from the array. If it is impossible to achieve, return -1.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18.6667px;"><strong>Input: </strong>arr[] = [0, 1, 0], k = 1<strong>
Output: </strong>2<strong>
Explanation: </strong>Flip arr[0], then flip arr[2].</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1], k = 2</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> 4 </span><br /><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Explanation:</strong><span style="font-size: 14pt;"> It requires 4 operations to change the whole array with 1.<br />Select subarray [2, 3] and flip all bits resulting array will be [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1]<br /></span>Select subarray [4, 5] and flip all bits resulting array will be [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]<br />Select subarray [5, 6] and flip all bits resulting array will be [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1]<br />Select subarray [6, 7] and flip all bits resulting array will be [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [0, 0, 1, 1, 1, 0, 0], k = 3</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> -1</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> It is not possible to make above array all 1's by performing any number of the steps.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong></span></p>
<p><span style="font-size: 14pt;">1 &lt;= arr.size() &lt;=&nbsp;</span><span style="font-size: 20px;">10</span><sup>5</sup><br /><span style="font-size: 14pt;">1 &lt;= k &lt;= arr.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-levels-to-gain-more-points/description" target="_blank" rel="noopener noreferrer">Minimum Levels to Gain More Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary array <code>possible</code> of length <code>n</code>.</p>

<p>Alice and Bob are playing a game that consists of <code>n</code> levels. Some of the levels in the game are <strong>impossible</strong> to clear while others can <strong>always</strong> be cleared. In particular, if <code>possible[i] == 0</code>, then the <code>i<sup>th</sup></code> level is <strong>impossible</strong> to clear for <strong>both</strong> the players. A player gains <code>1</code> point on clearing a level and loses <code>1</code> point if the player fails to clear it.</p>

<p>At the start of the game, Alice will play some levels in the <strong>given order</strong> starting from the <code>0<sup>th</sup></code> level, after which Bob will play for the rest of the levels.</p>

<p>Alice wants to know the <strong>minimum</strong> number of levels she should play to gain more points than Bob, if both players play optimally to <strong>maximize</strong> their points.</p>

<p>Return <em>the <strong>minimum</strong> number of levels Alice should play to gain more points</em>. <em>If this is <strong>not</strong> possible, return</em> <code>-1</code>.</p>

<p><strong>Note</strong> that each player must play at least <code>1</code> level.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">possible = [1,0,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>Let&#39;s look at all the levels that Alice can play up to:</p>

<ul>
	<li>If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has -1 + 1 - 1 = -1 point.</li>
	<li>If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.</li>
	<li>If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 1 - 1 + 1 = 1 point, while Bob has -1 point.</li>
</ul>

<p>Alice must play a minimum of 1 level to gain more points.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">possible = [1,1,1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>Let&#39;s look at all the levels that Alice can play up to:</p>

<ul>
	<li>If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has 4 points.</li>
	<li>If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 2 points, while Bob has 3 points.</li>
	<li>If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 3 points, while Bob has 2 points.</li>
	<li>If Alice plays till level 3 and Bob plays the rest of the levels, Alice has 4 points, while Bob has 1 point.</li>
</ul>

<p>Alice must play a minimum of 3 levels to gain more points.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">possible = [0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>The only possible way is for both players to play 1 level each. Alice plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Alice can&#39;t gain more points than Bob.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == possible.length &lt;= 10<sup>5</sup></code></li>
	<li><code>possible[i]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-make-array-complementary/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Make Array Complementary</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of <strong>even</strong> length <code>n</code> and an integer <code>limit</code>. In one move, you can replace any integer from <code>nums</code> with another integer between <code>1</code> and <code>limit</code>, inclusive.</p>

<p>The array <code>nums</code> is <strong>complementary</strong> if for all indices <code>i</code> (<strong>0-indexed</strong>), <code>nums[i] + nums[n - 1 - i]</code> equals the same number. For example, the array <code>[1,2,3,4]</code> is complementary because for all indices <code>i</code>, <code>nums[i] + nums[n - 1 - i] = 5</code>.</p>

<p>Return the <em><strong>minimum</strong> number of moves required to make </em><code>nums</code><em> <strong>complementary</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,4,3], limit = 4
<strong>Output:</strong> 1
<strong>Explanation:</strong> In 1 move, you can change nums to [1,2,<u>2</u>,3] (underlined elements are changed).
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,1], limit = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> In 2 moves, you can change nums to [<u>2</u>,2,2,<u>2</u>]. You cannot change any number to 3 since 3 &gt; limit.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1,2], limit = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums is already complementary.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i]&nbsp;&lt;= limit &lt;=&nbsp;10<sup>5</sup></code></li>
	<li><code>n</code> is even.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-pick-k-ones/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Pick K Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary array <code>nums</code> of length <code>n</code>, a <strong>positive</strong> integer <code>k</code> and a <strong>non-negative</strong> integer <code>maxChanges</code>.</p>

<p>Alice plays a game, where the goal is for Alice to pick up <code>k</code> ones from <code>nums</code> using the <strong>minimum</strong> number of <strong>moves</strong>. When the game starts, Alice picks up any index <code>aliceIndex</code> in the range <code>[0, n - 1]</code> and stands there. If <code>nums[aliceIndex] == 1</code> , Alice picks up the one and <code>nums[aliceIndex]</code> becomes <code>0</code>(this <strong>does not</strong> count as a move). After this, Alice can make <strong>any</strong> number of <strong>moves</strong> (<strong>including</strong> <strong>zero</strong>) where in each move Alice must perform <strong>exactly</strong> one of the following actions:</p>

<ul>
	<li>Select any index <code>j != aliceIndex</code> such that <code>nums[j] == 0</code> and set <code>nums[j] = 1</code>. This action can be performed <strong>at</strong> <strong>most</strong> <code>maxChanges</code> times.</li>
	<li>Select any two adjacent indices <code>x</code> and <code>y</code> (<code>|x - y| == 1</code>) such that <code>nums[x] == 1</code>, <code>nums[y] == 0</code>, then swap their values (set <code>nums[y] = 1</code> and <code>nums[x] = 0</code>). If <code>y == aliceIndex</code>, Alice picks up the one after this move and <code>nums[y]</code> becomes <code>0</code>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of moves required by Alice to pick <strong>exactly </strong></em><code>k</code> <em>ones</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">3</span></p>

<p><strong>Explanation:</strong> Alice can pick up <code>3</code> ones in <code>3</code> moves, if Alice performs the following actions in each move when standing at <code>aliceIndex == 1</code>:</p>

<ul>
	<li>At the start of the game Alice picks up the one and <code>nums[1]</code> becomes <code>0</code>. <code>nums</code> becomes <code>[1,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code>.</li>
	<li>Select <code>j == 2</code> and perform an action of the first type. <code>nums</code> becomes <code>[1,<strong><u>0</u></strong>,1,0,0,1,1,0,0,1]</code></li>
	<li>Select <code>x == 2</code> and <code>y == 1</code>, and perform an action of the second type. <code>nums</code> becomes <code>[1,<strong><u>1</u></strong>,0,0,0,1,1,0,0,1]</code>. As <code>y == aliceIndex</code>, Alice picks up the one and <code>nums</code> becomes <code>[1,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code>.</li>
	<li>Select <code>x == 0</code> and <code>y == 1</code>, and perform an action of the second type. <code>nums</code> becomes <code>[0,<strong><u>1</u></strong>,0,0,0,1,1,0,0,1]</code>. As <code>y == aliceIndex</code>, Alice picks up the one and <code>nums</code> becomes <code>[0,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code>.</li>
</ul>

<p>Note that it may be possible for Alice to pick up <code>3</code> ones using some other sequence of <code>3</code> moves.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">nums = [0,0,0,0], k = 2, maxChanges = 3</span></p>

<p><strong>Output: </strong><span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;">4</span></p>

<p><strong>Explanation:</strong> Alice can pick up <code>2</code> ones in <code>4</code> moves, if Alice performs the following actions in each move when standing at <code>aliceIndex == 0</code>:</p>

<ul>
	<li>Select <code>j == 1</code> and perform an action of the first type. <code>nums</code> becomes <code>[<strong><u>0</u></strong>,1,0,0]</code>.</li>
	<li>Select <code>x == 1</code> and <code>y == 0</code>, and perform an action of the second type. <code>nums</code> becomes <code>[<strong><u>1</u></strong>,0,0,0]</code>. As <code>y == aliceIndex</code>, Alice picks up the one and <code>nums</code> becomes <code>[<strong><u>0</u></strong>,0,0,0]</code>.</li>
	<li>Select <code>j == 1</code> again and perform an action of the first type. <code>nums</code> becomes <code>[<strong><u>0</u></strong>,1,0,0]</code>.</li>
	<li>Select <code>x == 1</code> and <code>y == 0</code> again, and perform an action of the second type. <code>nums</code> becomes <code>[<strong><u>1</u></strong>,0,0,0]</code>. As <code>y == aliceIndex</code>, Alice picks up the one and <code>nums</code> becomes <code>[<strong><u>0</u></strong>,0,0,0]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= maxChanges &lt;= 10<sup>5</sup></code></li>
	<li><code>maxChanges + sum(nums) &gt;= k</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description" target="_blank" rel="noopener noreferrer">Minimum Number of K Consecutive Bit Flips</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary array <code>nums</code> and an integer <code>k</code>.</p>

<p>A <strong>k-bit flip</strong> is choosing a <strong>subarray</strong> of length <code>k</code> from <code>nums</code> and simultaneously changing every <code>0</code> in the subarray to <code>1</code>, and every <code>1</code> in the subarray to <code>0</code>.</p>

<p>Return <em>the minimum number of <strong>k-bit flips</strong> required so that there is no </em><code>0</code><em> in the array</em>. If it is not possible, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,0], k = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> Flip nums[0], then flip nums[2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,0], k = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0,1,0,1,1,0], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this question, we will focus more on the applications of <a href="https://leetcode.com/explore/learn/card/bit-manipulation/">bit manipulation</a>, binary flipping, deque, and sliding window rather than their fundamentals. If you are not familiar with these concepts, we recommend reviewing them first.</p>
<p>We are given an array <code>nums</code> consisting only of 0s and 1s. We need to make sure that the <code>nums</code> array has all elements as 1s. We can perform <code>k</code>-bit flips, meaning selecting a contiguous subarray of length <code>k</code> and flipping every 0 to 1 and every 1 to 0 within that subarray.</p>
<p>In the end, we need to return the minimum number of <code>k</code>-bit flips needed to ensure there are no 0s in the array. If not possible, return -1.</p>
<p>Consider example 3 from the problem description:</p>
<pre><code>Input: nums = [0,0,0,1,0,1,1,0], k = 3
Flip nums[0], nums[1], nums[2]: nums becomes [1,1,1,1,0,1,1,0]
Flip nums[4], nums[5], nums[6]: nums becomes [1,1,1,1,1,0,0,0]
Flip nums[5], nums[6], nums[7]: nums becomes [1,1,1,1,1,1,1,1]
Output: 3
</code></pre>
<blockquote>
<p>For brevity, we will represent a series of <code>k</code>-bit flip operations by the starting indices of each flip. For instance, the series of 3-bit flips on subarrays nums[0 ... 2], nums[4 ... 6], and nums[5 ... 7] can be represented as [0, 4, 5]. We will call this the flip sequence.</p>
</blockquote>
<p>Before discussing the approaches, let's review a few fundamental properties of <strong>XOR</strong>, which are essential to understanding the mechanics of <code>k</code>-bit flips and simplifying the problem.</p>
<p>Property 1: Order Invariance</p>
<p>The order in which the flips are applied does not affect the final outcome. For instance, in the given example, whether we flip in the order [0, 4, 5] or [4, 0, 5], the final array will be the same. This means that the solution can be approached by determining the correct indices to flip, regardless of the sequence.</p>
<p>Property 2: Parity Invariance</p>
<p>The number of times an index is flipped determines its final value. If an index is flipped an odd number of times, its value will be inverted; if flipped an even number of times, it will remain unchanged.</p>
<p>Observation:</p>
<p>The problem boils down to finding the minimum flip sequence needed to convert all elements of <code>nums</code> to <code>1</code>.</p>
<p>To tackle this problem, we use the property of order invariance, allowing us to sort the sequence by index in ascending order. Once sorted, we minimize the sequence size using the property of parity invariance.</p>
<p>Due to the parity invariance property, duplicate values in the flip sequence can be removed without affecting the final result. For example, given a sequence like <span class="math inline">\([0, 1, 2, 4, 5, 6, 5, 6, 7]\)</span> (above example 3), we can simplify it to <span class="math inline">\([0, 4, 5]\)</span>, ensuring all indexes are unique and in ascending order.</p>
<p>Thus, every flip sequence <span class="math inline">\(S\)</span> can be simplified to a new sequence <span class="math inline">\(S'\)</span>, where all indexes in <span class="math inline">\(S'\)</span> are unique and sorted in ascending order. As indexes are sorted, subsequent flips with larger indexes cannot alter the value at prior indexes.</p>
<ul>
<li>If <span class="math inline">\(nums[0] = 0\)</span> and 0 is NOT in the flip sequence, <span class="math inline">\(nums[0]\)</span> remains 0 in the final result.</li>
<li>If <span class="math inline">\(nums[0] = 1\)</span> and 0 is in the flip sequence, <span class="math inline">\(nums[0]\)</span> becomes 0 in the final result.</li>
</ul>
<p>For any given index <code>i</code> in <code>nums</code>, one of the following two cases must occur to ensure there are no zeros left in <code>nums</code>:</p>
<ul>
<li>If <span class="math inline">\(nums[i] = 0\)</span>, then <code>i</code> must be present in the flip sequence, and we flip <span class="math inline">\(nums[i], nums[i + 1], \ldots, nums[i + k - 1]\)</span>.</li>
<li>If <span class="math inline">\(nums[i] = 1\)</span>, then <code>i</code> must NOT be in the sequence, and we do not flip <span class="math inline">\(nums[i], nums[i + 1], \ldots, nums[i + k - 1]\)</span>.</li>
</ul>
<p>Let's take example 3 to elaborate on these properties in detail. If the sequence of indexes is changed to <span class="math inline">\(\{0, 1, 1, 4, 4, 4, 5\}\)</span>, what will happen?</p>
<ol>
<li>Flip <span class="math inline">\(nums[0], nums[1], nums[2]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 0, 1, 1, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[1], nums[2], nums[3]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 0, 0, 0, 0, 1, 1, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[1], nums[2], nums[3]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 0, 1, 1, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[4], nums[5], nums[6]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 1, 0, 0, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[4], nums[5], nums[6]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 0, 1, 1, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[4], nums[5], nums[6]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 1, 0, 0, 0]\)</span>.</li>
<li>Flip <span class="math inline">\(nums[5], nums[6], nums[7]\)</span>: <span class="math inline">\(nums\)</span> becomes <span class="math inline">\([1, 1, 1, 1, 1, 1, 1, 1]\)</span>.</li>
</ol>
<p>The final result is the same as the flip sequence <span class="math inline">\(\{0, 4, 5\}\)</span>.</p>
<hr />
<h3 id="approach-1-using-an-auxiliary-array">Approach 1: Using an Auxiliary Array</h3>
<h4 id="intuition">Intuition</h4>
<p>A naive approach to solving this problem is to iterate the array from left to right and flip subarrays whenever a 0 is encountered. This ensures that each 0 is flipped as soon as it is detected, ensuring no 0s remain in the array, assuming the <code>k</code>-grouping is possible. However, due to the problem constraints, this approach is not feasible.</p>
<p>We can optimize the naive approach by using an auxiliary array <code>isFlipped</code> to track the indices where a <code>k</code>-bit flip is needed. The strategy involves iterating through the original array <code>nums</code> while maintaining a variable <code>flipped</code>, which indicates whether the current bit is flipped.</p>
<p>If <code>flipped</code> is 0 and <code>nums[i]</code> is 0, a flip starting at index <code>i</code> is required. Similarly, if <code>flipped</code> is 1 and <code>nums[i]</code> is 1, a flip at <code>nums[i]</code> is needed. The logic ensures that each bit becomes 1. If the bit is 0 and not flipped, we flip it to 1. If the bit is 1 and flipped, we flip it back to 0.</p>
<p>Consider what happens to <code>nums[5]</code> in the example above. Initially, we flip it from 1 to 0, then back from 0 to 1. When we reach <code>i = 5</code> in the loop and find <code>nums[5] = 1</code> with <code>flipped = 1</code>, we must flip <code>nums[5]</code> again. This ensures that the final value of <code>nums[5]</code> is 1, correcting any changes made by previous flips.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Create a boolean array <code>flipped</code> of size <code>nums.size()</code> to keep track of flipped states.</li>
<li>Initialize <code>validFlipsFromPastWindow</code> to 0, representing valid flips within the past window.</li>
<li>Initialize <code>flipCount</code> to 0, representing the total number of flips needed.</li>
<li>Iterate through the <code>nums</code> array from index 0 to <code>nums.size() - 1</code>:
<ul>
<li>If the current index <code>i</code> is greater than or equal to <code>k</code>:
<ul>
<li>If <code>flipped[i - k]</code> is true, decrement <code>validFlipsFromPastWindow</code> (since the flip at <code>i - k</code> is no longer part of the current window).</li>
</ul>
</li>
<li>Check if the current bit <code>nums[i]</code> needs to be flipped:
<ul>
<li>If <code>validFlipsFromPastWindow % 2 == nums[i]</code>:
<ul>
<li>If <code>i + k &gt; nums.size()</code>, return -1 (flipping the window extends beyond the array length).</li>
<li>Increment <code>validFlipsFromPastWindow</code>.</li>
<li>Set <code>flipped[i]</code> to true.</li>
<li>Increment <code>flipCount</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>flipCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/bsrmyzjB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span> because we iterate through the input array once, performing constant-time operations inside the loop.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> because it creates a flipped array of size <span class="math inline">\(n\)</span> to track element states.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-a-deque">Approach 2: Using a Deque</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of using an array of size <code>n</code> to track flipped indices, a more space-efficient approach is to use a deque (double-ended queue) to manage the state of a sliding window of size <code>k</code>.</p>
<p>As we progress through the array, we continuously adjust the deque by discarding indices from its front that no longer belong to the current window. This ensures that the deque only retains indices within the current window, thereby eliminating unnecessary data.</p>
<p>Similar to the previous approach, we determine whether a flip is necessary based on the parity of the deque's size (representing the number of flips so far) compared to the current element's value. If these do not align, a flip operation is performed.</p>
<p><strong>Proof by Contradiction:</strong></p>
<p>The key insight is that the problem has optimal substructure. This means that the optimal solution for the entire array includes optimal solutions for its subarrays.</p>
<p>Suppose there was a better solution that didn't flip immediately upon seeing a 0. This would mean:</p>
<ol>
<li>We skip flipping at position <code>i</code> (where <code>nums[i] = 0</code>).</li>
<li>We flip at some later position <code>j</code> (where <code>j &gt; i</code>).</li>
</ol>
<p>But this can't be better because:</p>
<ul>
<li>We still need to make the same number of flips (or more).</li>
<li>We might run out of array length, making the problem unsolvable.</li>
</ul>
<p>Therefore, the greedy choice of flipping immediately is always optimal.</p>
<p>The Sliding Window:</p>
<p>The sliding window approach ensures that we only consider the relevant flips for each position. This is crucial because:</p>
<ul>
<li>It allows us to &quot;forget&quot; flips that no longer affect the current position.</li>
<li>It ensures we accurately track the state of each element based on all relevant previous flips.</li>
</ul>
<p>In essence, this greedy algorithm works because for this specific problem:</p>
<ol>
<li>Making the best choice right now (flip if needed) never compromises future choices.</li>
<li>These local optimal choices accumulate to form the global optimal solution.</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> with <code>nums.size()</code>.</li>
<li>Create a deque <code>flipQueue</code> to keep track of flips.</li>
<li>Initialize <code>flipped</code> to 0, representing the current flip state.</li>
<li>Initialize <code>result</code> to 0, representing the total number of flips.</li>
<li>Iterate through the <code>nums</code> vector from index 0 to <code>n - 1</code>:
<ul>
<li>If the current index <code>i</code> is greater than or equal to <code>k</code>:
<ul>
<li>XOR <code>flipped</code> with the front element of <code>flipQueue</code>.</li>
<li>Remove the front element from <code>flipQueue</code>.</li>
</ul>
</li>
<li>If <code>flipped == nums[i]</code> (the current bit needs to be flipped):
<ul>
<li>If <code>i + k &gt; n</code>, return -1 (flipping the window extends beyond the array length).</li>
<li>Push 1 to <code>flipQueue</code>.</li>
<li>XOR <code>flipped</code> with 1 (toggle the flipped state).</li>
<li>Increment <code>result</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Push 0 to <code>flipQueue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/995/approach2.json:975,380!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7bhn3dEd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The time complexity is <span class="math inline">\(O(n)\)</span> because we make a single linear pass through the input array, performing constant-time operations inside the loop.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(k)\)</span> because it uses a deque <code>flipQueue</code> to track flips within the window size <code>k</code>, resulting in maximum size <code>k</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-in-constant-space">Approach 3: In Constant Space</h3>
<h4 id="intuition-2">Intuition</h4>
<p>This approach works as a one-pass solution without requiring any additional data structures. The main idea is to maintain a variable <code>currentFlips</code> that represents the number of flips in the current sliding window of size <code>k</code>, to decide whether we need to perform a flip or not.</p>
<p>If <code>currentFlips</code> is even and <code>nums[i]</code> is 0, we need to flip the bit. Similarly, if <code>currentFlips</code> is odd and <code>nums[i]</code> is 1, we also need to flip the bit. We use the parity of <code>currentFlips</code> (whether it's even or odd) to determine if the current bit needs flipping.</p>
<p>To perform a flip, we mark the current bit by setting <code>nums[i]</code> to 2, increment <code>currentFlips</code>, and increase <code>totalFlips</code>. As the window slides, if the element at the start of the previous window (<code>i - k</code>) was flipped (i.e., it was set to 2), we decrement <code>currentFlips</code>.</p>
<p>If flipping the current bit would go beyond the array bounds (i.e., <code>i + k</code> exceeds the array size), we return <code>-1</code> as it is impossible to make all elements 1.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>currentFlips</code> to 0, representing the current number of flips.</li>
<li>Initialize <code>totalFlips</code> to 0, representing the total number of flips.</li>
<li>Iterate through the <code>nums</code> array from index 0 to <code>nums.size() - 1</code>:
<ul>
<li>If the current index <code>i</code> is greater than or equal to <code>k</code> and <code>nums[i - k] == 2</code> (the leftmost element is marked as flipped):
<ul>
<li>Decrement <code>currentFlips</code>.</li>
</ul>
</li>
<li>Check if the current bit <code>nums[i]</code> needs to be flipped:
<ul>
<li>If <code>(currentFlips % 2) == nums[i]</code>:
<ul>
<li>If <code>i + k &gt; nums.size()</code>, return -1 (flipping the window extends beyond the array length).</li>
<li>Set <code>nums[i]</code> to 2 (mark the current bit as flipped).</li>
<li>Increment <code>currentFlips</code>.</li>
<li>Increment <code>totalFlips</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalFlips</code>.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/995/approach3.json:975,510!?!</p>
<blockquote>
<p>Note: We have modified the <code>nums</code> array, but sometimes there are restrictions against changing the input. In such cases, you can restore the original value of <code>nums[i - k]</code> by subtracting 2 (<code>nums[i - k] -= 2;</code>) below the line where we decrement <code>currentFlips--</code>. This way, it will restore its original state before marking it as 2. This technique is a clever way to maintain the original array, but we haven't included it in the following implementation for easier visual understanding.</p>
</blockquote>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/CDpeiWrw/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of input array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the input array once with constant time operations inside the loop (comparisons, increments/decrements, and array access). This results in a linear time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses constant additional space for variables like <code>currentFlips</code> and <code>totalFlips</code>. It doesn't create any data structures that scale with the input size (<code>n</code> or <code>k</code>). Therefore, the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Move All Balls to Each Box</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> boxes. You are given a binary string <code>boxes</code> of length <code>n</code>, where <code>boxes[i]</code> is <code>&#39;0&#39;</code> if the <code>i<sup>th</sup></code> box is <strong>empty</strong>, and <code>&#39;1&#39;</code> if it contains <strong>one</strong> ball.</p>

<p>In one operation, you can move <strong>one</strong> ball from a box to an adjacent box. Box <code>i</code> is adjacent to box <code>j</code> if <code>abs(i - j) == 1</code>. Note that after doing so, there may be more than one ball in some boxes.</p>

<p>Return an array <code>answer</code> of size <code>n</code>, where <code>answer[i]</code> is the <strong>minimum</strong> number of operations needed to move all the balls to the <code>i<sup>th</sup></code> box.</p>

<p>Each <code>answer[i]</code> is calculated considering the <strong>initial</strong> state of the boxes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> boxes = &quot;110&quot;
<strong>Output:</strong> [1,1,3]
<strong>Explanation:</strong> The answer for each box is as follows:
1) First box: you will have to move one ball from the second box to the first box in one operation.
2) Second box: you will have to move one ball from the first box to the second box in one operation.
3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> boxes = &quot;001011&quot;
<strong>Output:</strong> [11,8,5,4,3,4]</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == boxes.length</code></li>
	<li><code>1 &lt;= n &lt;= 2000</code></li>
	<li><code>boxes[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary string called <code>boxes</code>. Each element in this string represents a box:</p>
<ul>
<li><code>0</code> means the box is empty,</li>
<li><code>1</code> means the box contains one ball.</li>
</ul>
<p>In each operation, we can move a ball to any adjacent box (either to the left or right). Multiple balls can be in the same box at the same time, and we need to figure out how many operations are needed to move all balls to each box.</p>
<blockquote>
<p>Note: The calculation of answer for each index is done considering the initial state of the <code>boxes</code> array.</p>
</blockquote>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Given that the number of boxes is bounded by 2000, we can use brute force techniques to solve this problem. This involves calculating the total number of operations for each box individually and storing the results in an array.</p>
<p>First, we go through all the boxes to check if a box contains a ball. If a box has a ball, we then calculate how many operations are needed to move that ball to the current box by iterating through all other boxes. The number of operations needed to move a ball from one box to another is based on the distance between their positions. This is simply the absolute difference between the indices of the two boxes.</p>
<p>Next, we add up the differences for all the balls and keep a running total of the operations required for each box. These totals are stored in an <code>answer</code> array, which holds the result for each box. Finally, after processing all boxes, we return the <code>answer</code> array.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the Result Array:</p>
<ul>
<li>Create an array <code>answer</code> of size equal to the length of the input string <code>boxes</code> and initialize all elements to 0.</li>
</ul>
</li>
<li>
<p>Iterate Through Each Box:</p>
<ul>
<li>Loop through the boxes using an index variable <code>currentBox</code>.</li>
</ul>
</li>
<li>
<p>Check for Balls in the Current Box:</p>
<ul>
<li>If the current box contains a ball (i.e., <code>boxes.charAt(currentBox) == '1'</code>):
<ul>
<li>Iterate through all other boxes using an index variable <code>newPosition</code>.
<ul>
<li>For each box, calculate the distance to the <code>currentBox</code> using the absolute difference <code>Math.abs(newPosition - currentBox)</code>.</li>
<li>Add this distance to <code>answer[newPosition]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the Result:</p>
<ul>
<li>After processing all boxes, return the <code>answer</code> array.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4LUJ7Wre/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>boxes</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm iterates through each box, and for each box containing a ball, it iterates through all other boxes to calculate the distances. This results in a nested loop structure with <span class="math inline">\(n\)</span> iterations for both the outer and inner loops, leading to a total time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use an <code>answer</code> array to store the result. However, since this array is part of the output defined by the problem, it is not considered in the space complexity analysis. Therefore, the overall space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sum-of-left-and-right-moves">Approach 2: Sum of Left and Right Moves</h3>
<h4 id="intuition-1">Intuition</h4>
<p>From the previous approach, observe that a ball can move in only one direction: either left or right. If the target box is to the left of the ball, it will move left. If the target box is to the right of the ball, it will move right. So, for each box, some balls will come from the left side, and others will come from the right side.</p>
<p>To calculate the distances for all the balls coming from the left in just one pass, we use a combined approach within a single loop. As we iterate through the boxes from left to right, we keep track of how many balls weâ€™ve encountered so far using the variable <code>ballsToLeft</code>. Each time we move to the next box, the distance for all the balls weâ€™ve passed increases by one. So, the total number of operations for those balls increases by the number of balls we've encountered up to that point. We also keep track of the cumulative number of moves using the variable <code>movesToLeft</code>.</p>
<p>Similarly, we calculate the distances for the balls coming from the right by iterating through the boxes from right to left. This is achieved using the variable <code>ballsToRight</code> to track how many balls weâ€™ve encountered, and <code>movesToRight</code> to track the cumulative moves. During this reverse pass, we simultaneously calculate and accumulate the number of moves required for balls coming from the right.</p>
<p>In each iteration, we update the <code>answer</code> array by adding the moves calculated from both the left and right sides. The value for each box in <code>answer[i]</code> (for the left pass) and <code>answer[j]</code> (for the right pass) represents the total moves required for balls to reach that box.</p>
<p>At the end of the loop, the <code>answer</code> array will contain the total number of moves for each box, and we return this array.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the length of the <code>boxes</code> string and create an array <code>answer</code> to store the result.</p>
</li>
<li>
<p>Initialize variables <code>ballsToLeft</code>, <code>movesToLeft</code>, <code>ballsToRight</code>, and <code>movesToRight</code> to track the number of balls and the moves required to move balls to the left and right, respectively.</p>
</li>
<li>
<p>Single pass through the string <code>boxes</code>:</p>
<ul>
<li>For each index <code>i</code>:
<ul>
<li>
<p>Left pass (first half of the loop):</p>
<ul>
<li>Add the current number of moves to the left (<code>movesToLeft</code>) to the corresponding index in the <code>answer</code> array.</li>
<li>Update <code>ballsToLeft</code> by adding the number of balls in the current box.</li>
<li>Update <code>movesToLeft</code> by adding <code>ballsToLeft</code> (total balls to the left) to account for the moves required for the next balls.</li>
</ul>
</li>
<li>
<p>Right pass (second half of the loop):</p>
<ul>
<li>Calculate the corresponding index <code>j</code> for the right pass (<code>n - 1 - i</code>).</li>
<li>Add the current number of moves to the right (<code>movesToRight</code>) to the corresponding index in the <code>answer</code> array.</li>
<li>Update <code>ballsToRight</code> by adding the number of balls in the current box.</li>
<li>Update <code>movesToRight</code> by adding <code>ballsToRight</code> (total balls to the right) to account for the moves required for the next balls.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>answer</code> array containing the minimum number of operations for each box.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7kzM6czu/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>boxes</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a single loop that iterates over the string <code>boxes</code> once. Within this loop, it performs constant-time operations such as accessing characters, updating variables, and updating the <code>answer</code> array. Since the loop runs <span class="math inline">\(n\)</span> times, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a few integer variables (<code>ballsToLeft</code>, <code>movesToLeft</code>, <code>ballsToRight</code>, <code>movesToRight</code>), all of which require constant space. Additionally, we use an <code>answer</code> array to store the result. However, since this array is part of the output defined by the problem, it is not considered in the space complexity analysis. Therefore, the overall space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make All Array Elements Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> consisting of positive integers.</p>

<p>You are also given an integer array <code>queries</code> of size <code>m</code>. For the <code>i<sup>th</sup></code> query, you want to make all of the elements of <code>nums</code> equal to<code> queries[i]</code>. You can perform the following operation on the array <strong>any</strong> number of times:</p>

<ul>
	<li><strong>Increase</strong> or <strong>decrease</strong> an element of the array by <code>1</code>.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>queries[i]</code>.</p>

<p><strong>Note</strong> that after each query the array is reset to its original state.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,6,8], queries = [1,5]
<strong>Output:</strong> [14,10]
<strong>Explanation:</strong> For the first query we can do the following operations:
- Decrease nums[0] 2 times, so that nums = [1,1,6,8].
- Decrease nums[2] 5 times, so that nums = [1,1,1,8].
- Decrease nums[3] 7 times, so that nums = [1,1,1,1].
So the total number of operations for the first query is 2 + 5 + 7 = 14.
For the second query we can do the following operations:
- Increase nums[0] 2 times, so that nums = [5,1,6,8].
- Increase nums[1] 4 times, so that nums = [5,5,6,8].
- Decrease nums[2] 1 time, so that nums = [5,5,5,8].
- Decrease nums[3] 3 times, so that nums = [5,5,5,5].
So the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,9,6,3], queries = [10]
<strong>Output:</strong> [20]
<strong>Explanation:</strong> We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make Binary Array Elements Equal to One I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <span data-keyword="binary-array">binary array</span> <code>nums</code>.</p>

<p>You can do the following operation on the array <strong>any</strong> number of times (possibly zero):</p>

<ul>
	<li>Choose <strong>any</strong> 3 <strong>consecutive</strong> elements from the array and <strong>flip</strong> <strong>all</strong> of them.</li>
</ul>

<p><strong>Flipping</strong> an element means changing its value from 0 to 1, and from 1 to 0.</p>

<p>Return the <strong>minimum</strong> number of operations required to make all elements in <code>nums</code> equal to 1. If it is impossible, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,1,1,1,0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong><br />
We can do the following operations:</p>

<ul>
	<li>Choose the elements at indices 0, 1 and 2. The resulting array is <code>nums = [<u><strong>1</strong></u>,<u><strong>0</strong></u>,<u><strong>0</strong></u>,1,0,0]</code>.</li>
	<li>Choose the elements at indices 1, 2 and 3. The resulting array is <code>nums = [1,<u><strong>1</strong></u>,<u><strong>1</strong></u>,<strong><u>0</u></strong>,0,0]</code>.</li>
	<li>Choose the elements at indices 3, 4 and 5. The resulting array is <code>nums = [1,1,1,<strong><u>1</u></strong>,<u><strong>1</strong></u>,<u><strong>1</strong></u>]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong><br />
It is impossible to make all elements equal to 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary array <code>nums</code>, and we need to transform all elements into <code>1</code> using a specific operation. The allowed operation lets us choose any three consecutive elements and flip all of them (changing <code>0</code> to <code>1</code> and <code>1</code> to <code>0</code>). Our task is to determine the minimum number of operations required to turn the entire array into all <code>1</code>s. If it is impossible to achieve this transformation, we return <code>-1</code>.</p>
<p>Since we can only flip three consecutive elements at a time, isolated <code>0</code>s or certain patterns of <code>0</code>s may prevent us from turning everything into <code>1</code>. If the number of <code>0</code>s in certain positions makes it impossible to fully eliminate them using groups of three, the transformation cannot be achieved.</p>
<p>Before discussing the approaches, let's review a fundamental property of XOR:</p>
<h5 id="parity-invariance">Parity Invariance:</h5>
<p>Parity invariance means that the number of times a position is flipped determines its final value. If a position is flipped an odd number of times, its value changes, but if it is flipped an even number of times, it stays the same.</p>
<p>Consider the array <code>[1, 0, 0, 1, 0, 1, 1]</code>. We start by flipping three consecutive elements to try and transform all <code>0</code>s into <code>1</code>s. First, flipping the subarray <code>[0, 0, 1]</code> at indices <code>1...3</code> changes the array to <code>[1, 1, 1, 0, 0, 1, 1]</code>. Then, flipping <code>[0, 0, 1]</code> at indices <code>3...5</code> gives <code>[1, 1, 1, 1, 1, 0, 1]</code>. Finally, flipping <code>[1, 0, 1]</code> at indices <code>4...6</code> results in <code>[1, 1, 1, 1, 0, 1, 0]</code>.</p>
<p>At this point, we see that the <code>0</code>s at positions <code>4</code> and <code>6</code> remain, and there is no way to flip them without also flipping other elements. Since we can only flip three elements at a time, we cannot isolate these <code>0</code>s in a way that allows us to change them to <code>1</code>s. This happens because these positions were flipped an even number of times, so they retained their original value. Because of this <strong>parity constraint</strong>, the transformation is impossible, and we must return <code>-1</code>.</p>
<hr />
<h3 id="approach-1-using-deque">Approach 1: Using Deque</h3>
<h4 id="intuition">Intuition</h4>
<p>The first observation is that if a <code>0</code> appears near the end of the array (specifically within the last two positions), we cannot flip it using a full triplet. This means that if any <code>0</code> is left in the last two places after processing, it is impossible to make the entire array <code>1</code>, so we return <code>-1</code>.</p>
<p>Since a single flip operation affects three elements, each flip we apply has a lasting effect on the next two indices. Instead of modifying the entire array and recomputing values every time, we need a way to keep track of the flips already applied. This is where we introduce a deque to store the indices of past flips. The deque allows us to efficiently determine how many times each index has been flipped by keeping only the flips that are still affecting the current index.</p>
<p>We iterate through the array from left to right. At each index <code>i</code>, we first remove any outdated flips from the deque and those that were applied more than two positions earlier, as they no longer affect <code>i</code>.</p>
<p>Next, we determine whether we need to flip at index <code>i</code>. The second key observation is that the effect of a flip is cumulative: if an index has been flipped an odd number of times, it has effectively changed its value, whereas if it has been flipped an even number of times, it remains the same as its original value. Using this property, we can check:</p>
<p><span class="math inline">\(\text{(original value of nums[i])} + \text{(number of active flips affecting i)} \mod 2\)</span></p>
<ul>
<li>If the result is <code>0</code>, it means that <code>nums[i]</code> is currently <code>0</code>, so we must flip it.</li>
<li>To flip, we check if <code>i + 2</code> is within bounds (since we need a full triplet). If not, we return <code>-1</code>. Otherwise, we record this flip by adding <code>i</code> to the deque and incrementing the operation count.</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>flipQueue</code> as a deque to store indices of flip operations.</p>
</li>
<li>
<p>Initialize <code>count</code> to track the number of operations performed.</p>
</li>
<li>
<p>Iterate through <code>nums</code>:</p>
<ul>
<li>Remove expired flips from the beginning of <code>flipQueue</code> if they are older than 2 indices.</li>
<li>Check if <code>nums[i]</code> needs flipping using <code>(nums[i] + len(flipQueue)) % 2 == 0</code>.</li>
<li>If flipping is needed:
<ul>
<li>If flipping is impossible (i.e., <code>i + 2</code> exceeds array bounds), return <code>-1</code>.</li>
<li>Increment <code>count</code> since a flip operation is performed.</li>
<li>Append <code>i</code> to the end of <code>flipQueue</code> to mark the flip operation.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>count</code>, the minimum number of operations needed.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J3qDTLSY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates over the list once, performing a constant amount of work for each element. For each index <code>i</code>, it checks if the current element needs flipping by considering the number of active flips stored in the <code>flipQueue</code>. This check is done in constant time <span class="math inline">\(O(1)\)</span>. Additionally, the algorithm removes expired flips (those older than 3 indices) from the <code>flipQueue</code> using a <code>while</code> loop. However, each element is added to and removed from the <code>flipQueue</code> at most once, so the total time spent on queue operations across all iterations is <span class="math inline">\(O(n)\)</span>. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a <code>deque</code> (<code>flipQueue</code>) to store the indices of flip operations. In the worst case, the <code>flipQueue</code> can store up to 3 elements (since each flip affects a triplet of elements). Therefore, the space complexity of the <code>flipQueue</code> is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sliding-window">Approach 2: Sliding Window</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a deque to track active flips and determine how many times each index had been flipped. Now, we take a different approach by modifying the array directly as we iterate. The core idea remains the same: flipping three consecutive elements at a time while ensuring that every <code>0</code> gets converted to <code>1</code> in the most efficient way possible.</p>
<p>Instead of maintaining a separate structure to track flips, we will scan the array from left to right and only focus on the last element of each triplet to determine if a flip is needed. This means that for each index <code>i</code>, we check whether <code>nums[i - 2]</code> is still <code>0</code>. If it is, then we must flip the triplet ending at <code>i</code> (<code>nums[i - 2], nums[i - 1], nums[i]</code>).</p>
<p>By flipping in this way, we ensure that every <code>0</code> gets handled at the earliest possible opportunity, preventing any unflippable <code>0</code>s from being left behind. This also ensures that we are using the minimum number of operations because each flip is only applied when absolutely necessary.</p>
<p>We iterate through the array, ensuring that at every position <code>i</code>, we can check the last element of a full triplet (<code>nums[i - 2]</code>). If <code>nums[i - 2]</code> is <code>0</code>, we immediately flip <code>nums[i - 2], nums[i - 1], and nums[i]</code>, and we increase the flip count.</p>
<p>After processing all indices, we check if the entire array has been turned into <code>1</code>s. If the sum equals the length of the array, it means every element is <code>1</code>, so we return the total number of flips. Otherwise, we return <code>-1</code>, indicating that it was impossible to transform the entire array.</p>
<p>The algorithm is visualized below:</p>
<p><img src="../Figures/3191/slidingwindow.png" alt="slidingwindow" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>count</code> to track the number of flip operations.</p>
</li>
<li>
<p>Iterate through <code>nums</code> starting from 2nd element:</p>
<ul>
<li>Check if <code>nums[i - 2]</code> is <code>0</code> (i.e., the triplet starting at <code>i-2</code> needs flipping).
<ul>
<li>If so, increment <code>count</code> since a flip is performed.</li>
<li>Flip elements at indices <code>i - 2</code>, <code>i - 1</code>, and <code>i</code> using XOR.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Compute the <code>sum</code> of <code>nums</code>. If all elements are <code>1</code>, return <code>count</code> as the minimum operations needed.</p>
</li>
<li>
<p>Otherwise, return <code>-1</code> since it's impossible to make all elements <code>1</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p><strong>Interview Tip: In-Place Algorithms</strong><br />
In-place algorithms modify the input directly to save space, but that can sometimes cause issues. There are times when an in-place approach isnâ€™t the best idea, like in these cases:</p>
<ol>
<li>If your algorithm runs in a multi-threaded environment without exclusive access to the array, other threads might need to read it and wonâ€™t expect it to change.</li>
<li>Even in a single-threaded setup, or if you have exclusive access while the algorithm runs, the array might still be needed later or by another thread once the lock is released.</li>
</ol>
<p>In an interview, always check if itâ€™s okay to overwrite the input. If you do, be ready to explain the trade-offs!</p>
</blockquote>
<p><a href="https://leetcode.com/playground/CEsvpqJH/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates over the array once, performing a constant amount of work for each element. Specifically, for each element, it checks if the element at position <code>i - 2</code> is <code>0</code>, and if so, it flips the elements at positions <code>i - 2</code>, <code>i - 1</code>, and <code>i</code>. This flipping operation is done in constant time <span class="math inline">\(O(1)\)</span> per iteration. Since the loop runs for <span class="math inline">\(n\)</span> iterations, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, after the loop, the algorithm computes the sum of the array using a built-in summation operation, which runs in <span class="math inline">\(O(n)\)</span> time. Since this operation is performed once after the loop, it does not affect the asymptotic complexity, which remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space regardless of the input size. The input array <code>nums</code> is modified in place, so no additional space is required for data structures. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<p>The summation operation also does not introduce additional space complexity, as it operates in a single pass without requiring extra storage beyond a single variable.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sliding-window-using-bit-manipulation">Approach 3: Sliding Window Using Bit Manipulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of checking the last element of a triplet (<code>nums[i-2]</code>), here we directly iterate through the array from left to right and flip any <code>0</code> we encounter at <code>nums[i]</code>. Additionally, flipping <code>nums[i]</code> also forces us to flip the next two elements, <code>nums[i + 1]</code> and <code>nums[i + 2]</code>. This ensures that the <code>0</code> at <code>nums[i]</code> is turned into <code>1</code> while maintaining correctness for future elements.</p>
<p>To achieve this, whenever we find a <code>0</code> at <code>nums[i]</code>, we perform the following operation and increase the count of operations:</p>
<ul>
<li>Flip <code>nums[i]</code> (turning it into <code>1</code>).</li>
<li>Flip <code>nums[i + 1]</code> and <code>nums[i+2]</code>.</li>
</ul>
<p>Since we are scanning left to right, we only modify elements that are still <code>0</code> at the moment they are encountered.</p>
<p>Now let's prove the greedy approach via the method of induction.</p>
<h4 id="proof-by-induction">Proof By Induction:</h4>
<p><strong>Base Cases</strong>:</p>
<p>We consider the smallest possible cases explicitly, as these provide the foundation for our inductive proof:</p>
<p>n = 3 (e.g., <code>[0, 0, 0]</code>), n = 4 (e.g., <code>[0, 0, 0, 0]</code>) and n = 5 (e.g., <code>[0, 0, 0, 0, 0]</code>).</p>
<p>We explicitly check all possible cases for <code>n = 3, 4, 5</code> and verify that our algorithm produces the minimum number of flips in all cases. These serve as our base cases.</p>
<p>We require three base cases because our induction step will rely on the fact that when <code>n â‰¥ 6</code>, we must have <code>n - 3 â‰¥ 3</code>.</p>
<p>If we only had a base case for n = 3, the induction step would only allow us to conclude correctness for <span class="math inline">\(n = 6, 9, 12, \dots (i.e., every third number)\)</span>, leaving gaps in between. By proving the cases for <code>n = 3, 4, 5</code>, we ensure the induction step works for all <span class="math inline">\(k \geq 6\)</span>, since every number can now be reached via induction.</p>
<p>Thus, three base cases are necessary so that when we inductively build up, we can confidently say the theorem holds for all <span class="math inline">\(n - 3 \geq 3\)</span>.</p>
<p><strong>Inductive Hypothesis</strong>:<br />
Assume that for some <code>nums</code> of size <code>k - 3</code>, our algorithm performs the minimum number of operations optimally. That is, we have already shown that for any valid <code>nums</code> of size <code>k - 3</code>, our approach leads to the fewest possible flips.</p>
<p>Since we have proved this holds for <code>k - 3 âˆˆ {3,4,5}</code>, we assume it also holds for any general <code>k - 3</code>.</p>
<p><strong>Inductive Step</strong>:<br />
We now extend our proof to an array of size <code>k</code>.</p>
<p>Our algorithm flips elements greedily from left to right, ensuring that <code>nums[0:k - 3]</code> has been fully processed optimally. From our assumed correctness for <code>k - 3</code>, we know that all values in <code>nums[0:k - 3]</code> are <code>1</code>, except possibly <code>nums[k - 5]</code> and <code>nums[k - 4]</code>, since <code>k - 3 &gt; 3</code> ensures these exist.</p>
<p>Now, we consider the last three elements <code>nums[k - 5:k]</code>. We enumerate all possible cases for their values and verify that our greedy strategy of flipping when encountering <code>0</code> remains the most optimal approach.</p>
<p>A key assumption is that if we perform any operation at an index <code>&lt; k - 5</code>, it would change already correct elements in <code>nums[0:k - 5]</code>. Since we have already shown that our solution for <code>nums[0:k - 3]</code> is optimal, such an operation would be redundant or suboptimal.</p>
<p>Therefore, the only way to minimize operations is to follow the same strategy as before i.e., handling <code>nums[k - 5:k]</code> optimally using our greedy approach.</p>
<p>Since the algorithm maintains optimality at every step and does not perform unnecessary operations, the hypothesis extends to size <code>k</code>.</p>
<p><strong>Conclusion</strong>:<br />
Since our base cases hold for <code>n = 3, 4, 5</code>, and we have shown that assuming correctness for <code>k - 3</code> leads to correctness for <code>k</code>, we conclude by mathematical induction that our greedy approach is optimal for all <code>n â‰¥ 3</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>nums</code>.</p>
</li>
<li>
<p>Initialize <code>count</code> to track the number of flip operations.</p>
</li>
<li>
<p>Iterate through <code>nums</code> up to <code>n - 3</code>:</p>
<ul>
<li>If <code>nums[i]</code> is <code>0</code>, perform a triplet flip starting at <code>i</code>:
<ul>
<li>Flip <code>nums[i]</code> to <code>1</code>.</li>
<li>Flip <code>nums[i + 1]</code> (toggle <code>0</code> to <code>1</code> or <code>1</code> to <code>0</code>).</li>
<li>Flip <code>nums[i + 2]</code> (toggle <code>0</code> to <code>1</code> or <code>1</code> to <code>0</code>).</li>
<li>Increment <code>count</code> as a flip operation was performed.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If <code>nums[n - 2]</code> or <code>nums[n - 1]</code> is still <code>0</code>, return <code>-1</code> since making all elements <code>1</code> is impossible.</p>
</li>
<li>
<p>Otherwise, return <code>count</code> as the minimum number of operations needed.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<blockquote>
<p><strong>Interview Tip: In-Place Algorithms</strong><br />
In-place algorithms modify the input directly to save space, but that can sometimes cause issues. There are times when an in-place approach isnâ€™t the best idea, like in these cases:</p>
<ol>
<li>If your algorithm runs in a multi-threaded environment without exclusive access to the array, other threads might need to read it and wonâ€™t expect it to change.</li>
<li>Even in a single-threaded setup, or if you have exclusive access while the algorithm runs, the array might still be needed later or by another thread once the lock is released.</li>
</ol>
<p>In an interview, always check if itâ€™s okay to overwrite the input. If you do, be ready to explain the trade-offs!</p>
</blockquote>
<p><a href="https://leetcode.com/playground/8LREekKX/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates over the array from the first element to the third last element, performing a constant amount of work for each element. Specifically, for each element, it checks if the element is 0, and if so, it flips the current element and the next two elements. This operation is done in constant time <span class="math inline">\(O(1)\)</span> per iteration. Since the loop runs for <span class="math inline">\(n - 2\)</span> iterations, the overall time complexity is <span class="math inline">\(O(n)\)</span>. Therefore, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space regardless of the input size. The only variables used are <code>n</code>, <code>count</code>, and the loop index <code>i</code>, all of which occupy constant space. The input array <code>nums</code> is modified in place, so no additional space is required for data structures. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<p>We suggest solving <a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips">995. Minimum Number of K Consecutive Bit Flips</a>, as it is a more challenging version of <a href="https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i">3191. Minimum Operations to Make Binary Array Elements Equal to One I</a>. The key difference is replacing <code>k = 3</code> with a general <code>k</code>.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Reduce X to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>

<p>Return <em>the <strong>minimum number</strong> of operations to reduce </em><code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it is possible</em><em>, otherwise, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,4,2,3], x = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> The optimal solution is to remove the last two elements to reduce x to zero.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,6,7,8,9], x = 4
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,20,1,1,3], x = 10
<strong>Output:</strong> 5
<strong>Explanation:</strong> The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-penalty-for-a-shop/description" target="_blank" rel="noopener noreferrer">Minimum Penalty for a Shop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the customer visit log of a shop represented by a <strong>0-indexed</strong> string <code>customers</code> consisting only of characters <code>&#39;N&#39;</code> and <code>&#39;Y&#39;</code>:</p>

<ul>
	<li>if the <code>i<sup>th</sup></code> character is <code>&#39;Y&#39;</code>, it means that customers come at the <code>i<sup>th</sup></code> hour</li>
	<li>whereas <code>&#39;N&#39;</code> indicates that no customers come at the <code>i<sup>th</sup></code> hour.</li>
</ul>

<p>If the shop closes at the <code>j<sup>th</sup></code> hour (<code>0 &lt;= j &lt;= n</code>), the <strong>penalty</strong> is calculated as follows:</p>

<ul>
	<li>For every hour when the shop is open and no customers come, the penalty increases by <code>1</code>.</li>
	<li>For every hour when the shop is closed and customers come, the penalty increases by <code>1</code>.</li>
</ul>

<p>Return<em> the <strong>earliest</strong> hour at which the shop must be closed to incur a <strong>minimum</strong> penalty.</em></p>

<p><strong>Note</strong> that if a shop closes at the <code>j<sup>th</sup></code> hour, it means the shop is closed at the hour <code>j</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;YYNY&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
- Closing the shop at the 0<sup>th</sup> hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1<sup>st</sup> hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2<sup>nd</sup> hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3<sup>rd</sup> hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4<sup>th</sup> hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2<sup>nd</sup> or 4<sup>th</sup> hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;NNNNN&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> It is best to close the shop at the 0<sup>th</sup> hour as no customers arrive.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> customers = &quot;YYYY&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> It is best to close the shop at the 4<sup>th</sup> hour as customers arrive at each hour.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>customers</code> consists only of characters <code>&#39;Y&#39;</code> and <code>&#39;N&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
 <div class='video-preview'></div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We can start by considering the brute force approach, attempting to close the shop at every possible hour.</p>
<p><img src="../Figures/2483/1.png" alt="img" /></p>
<p>The calculation of the penalty (closed after a certain number of hours) is divided into two parts:</p>
<ul>
<li>During open hours, every 'N' character contributes to 1 penalty.</li>
<li>During closed hours, every 'Y' character also contributes to 1 penalty.</li>
</ul>
<p>We can calculate the total penalty by traversing <code>customers</code>.</p>
<p><img src="../Figures/2483/2.png" alt="img" /></p>
<p>However, considering the size of <code>customers</code>, this quadratic time complexity approach may exceed the time limit. Therefore, we need to consider a more efficient traversal method.</p>
<hr />
<h3 id="approach-1-two-passes">Approach 1: Two Passes</h3>
<h4 id="intuition">Intuition</h4>
<p>Notice that in two adjacent cases (i.e. closing after the <span class="math inline">\({i-1}^{th}\)</span> hour and closing after the <span class="math inline">\(i^{th}\)</span> hour, which differ by 1 hour), only the status of one hour has changed, where the status has been changed from a closing hour to an open hour. Hence, we can record the overall penalty change by calculating the difference in penalty between two adjacent cases.</p>
<p><img src="../Figures/2483/3.png" alt="img" /></p>
<p>Therefore, let's first calculate the total penalty if we close instantly (after hour 0). Hence, the penalty of closing the shop after <span class="math inline">\(0^{th}\)</span> hour is based on the status of <code>customers[0]</code>:</p>
<ul>
<li>If it is 'Y', it means one penalty from the closed hours is removed, resulting in a decrease of the total penalty by 1.</li>
<li>If it is 'N', it means an additional penalty is added from the open hours, resulting in an increase of the total penalty by 1.</li>
</ul>
<p>Each time we iterate over a new <code>i</code>, we are finding the new penalty if we were to close after <code>i</code> instead of after <code>i - 1</code>.</p>
<p>Please refer to the slides below for a visual representation. The &quot;OPEN&quot; and &quot;CLOSE&quot; in the slides represent the contribution toward the current penalty. &quot;OPEN&quot; means that there are no customers when the store is open, and &quot;CLOSE&quot; means that there are customers when the store is closed.</p>
<p>!?!../Documents/2483/s1.json:601,301!?!</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Iterate over <code>customers</code>, set <code>cur_penalty</code> and <code>min_penalty</code> as the total count of the character <code>Y</code>, which is the penalty if the shop closes at hour 0. Set <code>earliest_hour</code> as 0.</p>
</li>
<li>
<p>Iterate over <code>customers</code>, for the <span class="math inline">\(i^{th}\)</span> character:</p>
<ul>
<li>If <code>customers[i] = 'Y'</code>, decrement <code>cur_penalty</code> by 1. Otherwise, increment <code>cur_penalty</code> by 1.</li>
<li>If <code>cur_penalty &lt; min_penalty</code>, set <code>earliest_hour</code> as <code>i + 1</code>, and set <code>min_penalty</code> as <code>cur_penalty</code>.</li>
</ul>
</li>
<li>
<p>Return <code>earliest_hour</code> once the iteration is complete.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fayr8Lf3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>customers</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The first traversal is used to calculate the total count of 'Y' in <code>customers</code>, which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>In each step of the second traversal, we update <code>cur_penalty</code>, <code>min_penalty</code>, and <code>earliest_hour</code> based on the character <code>customers[i]</code>, which can be done in constant time. Therefore, the second traversal also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update several parameters, <code>cur_penalty</code>, <code>min_penalty</code> and <code>earliest_hour</code>, which takes <span class="math inline">\(O(1)\)</span> space.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-one-pass">Approach 2: One Pass</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we used the first traversal to calculate the count of 'Y', ensuring that each penalty obtained is accurate. However, we don't need the actual penalty values. It is important to note that the problem only requires the <strong>earliest hour</strong> with the lowest penalty. Thus, the only thing that matters is the penalty of the hours relative to each other, and our initial reference point is not significant.</p>
<p><img src="../Figures/2483/4.png" alt="img" /></p>
<p>For convenience, we can directly set <code>cur_penalty</code> to 0, which is equivalent to shifting the curve of the actual penalty vertically. This will not affect the calculation result. Note that we could initialize <code>cur_penalty</code> to any value and the algorithm would still work since the initial reference point is insignificant.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Set <code>cur_penalty</code>, <code>min_penalty</code> and <code>earliest_hour</code> as 0.</p>
</li>
<li>
<p>Iterate over <code>customers</code>, for the <span class="math inline">\(i^{th}\)</span> character:</p>
<ul>
<li>If <code>customers[i] = 'Y'</code>, decrement <code>cur_penalty</code> by 1. Otherwise, increment <code>cur_penalty</code> by 1.</li>
<li>If <code>cur_penalty &lt; min_penalty</code>, set <code>earliest_hour</code> as <code>i + 1</code>, and set <code>min_penalty</code> as <code>cur_penalty</code>.</li>
</ul>
</li>
<li>
<p>Return <code>earliest_hour</code> once the iteration is complete.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Yfiiqoxm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>customers</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>In each step of the traversal, we update <code>cur_penalty</code>, <code>min_penalty</code>, and <code>earliest_hour</code> based on the character <code>customers[i]</code>, which can be done in constant time. Therefore, the traversal takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update several parameters, <code>cur_penalty</code>, <code>min_penalty</code> and <code>earliest_hour</code>, which takes <span class="math inline">\(O(1)\)</span> space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-positive-sum-subarray/description" target="_blank" rel="noopener noreferrer">Minimum Positive Sum Subarray </a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and <strong>two</strong> integers <code>l</code> and <code>r</code>. Your task is to find the <strong>minimum</strong> sum of a <strong>subarray</strong> whose size is between <code>l</code> and <code>r</code> (inclusive) and whose sum is greater than 0.</p>

<p>Return the <strong>minimum</strong> sum of such a subarray. If no such subarray exists, return -1.</p>

<p>A <strong>subarray</strong> is a contiguous <b>non-empty</b> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3, -2, 1, 4], l = 2, r = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarrays of length between <code>l = 2</code> and <code>r = 3</code> where the sum is greater than 0 are:</p>

<ul>
	<li><code>[3, -2]</code> with a sum of 1</li>
	<li><code>[1, 4]</code> with a sum of 5</li>
	<li><code>[3, -2, 1]</code> with a sum of 2</li>
	<li><code>[-2, 1, 4]</code> with a sum of 3</li>
</ul>

<p>Out of these, the subarray <code>[3, -2]</code> has a sum of 1, which is the smallest positive sum. Hence, the answer is 1.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-2, 2, -3, 1], l = 2, r = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no subarray of length between <code>l</code> and <code>r</code> that has a sum greater than 0. So, the answer is -1.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1, 2, 3, 4], l = 2, r = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>[1, 2]</code> has a length of 2 and the minimum sum greater than 0. So, the answer is 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= l &lt;= r &lt;= nums.length</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-size-subarray-in-infinite-array/description" target="_blank" rel="noopener noreferrer">Minimum Size Subarray in Infinite Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> and an integer <code>target</code>.</p>

<p>A <strong>0-indexed</strong> array <code>infinite_nums</code> is generated by infinitely appending the elements of <code>nums</code> to itself.</p>

<p>Return <em>the length of the <strong>shortest</strong> subarray of the array </em><code>infinite_nums</code><em> with a sum equal to </em><code>target</code><em>.</em> If there is no such subarray return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], target = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,2,3], target = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,6,8], target = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
It can be proven that there is no subarray with sum equal to target = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-size-subarray-sum/description" target="_blank" rel="noopener noreferrer">Minimum Size Subarray Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword="subarray-nonempty"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = 4, nums = [1,4,4]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>.</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, our task is to return the minimal length of a subarray whose sum is greater than or equal to <code>target</code>. If there is no such subarray, we have to return <code>0</code>.</p>
<hr />
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>An intuitive technique is to go through all the subarrays one by one and check the sum of each one. If the total of the subarray under consideration is larger than or equal to <code>target</code>, we attempt to update our answer variable by using the minimum of the current answer and the length of this subarray. To get all the subarrays, we can run two loops: the outer loop selects a starting point and the inner loop selects an ending point. This solution, however, will take <span class="math inline">\(O(n^2)\)</span> time, resulting in a time limit exceeded (TLE).</p>
<p>Let's think whether we really need to iterate over all the subarrays.</p>
<p>Given that we only have positive integers, there is no purpose in adding further elements to a subarray if its sum exceeds or equals <code>target</code>. Adding more elements to such a subarray will result in the construction of longer subarrays, which is useless because we have already found a smaller subarray that meets our requirements.</p>
<p>Only if the sum of the current subarray under consideration is smaller than <code>target</code>, we should append elements to the subarray. When the sum of the subarrays exceeds or equals <code>target</code>, we will attempt to update our answer with the length of the current subarray.</p>
<p>We now try to remove the elements from the start and see if we can form a smaller subarray that meets our requirements. We remove the first element from the subarray and check if we still have the total higher than or equal to <code>target</code>. If the total exceeds or equals <code>target</code>, we have a smaller subarray that meets our requirement. As a result, we again try to update our answer with the length of the current subarray and repeat the process of eliminating the first element from the current subarray until the sum no longer exceeds or equals <code>target</code>.</p>
<p>Now after removing elements, if the sum of the subarray is less than <code>target</code>, we have to append more elements to it until the sum becomes larger than or equal to <code>target</code>. We append elements until the sum equals or exceeds <code>target</code>, then try to update our answer variable and repeat the process of eliminating the first element.</p>
<p>The above approach can be efficiently solved using the <strong>sliding window approach</strong>.</p>
<p>If you are not familiar with sliding window, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/">Sliding Window Explore Card</a>.</p>
<p>A sliding window is achieved by using two pointers <code>left</code> and <code>right</code>, which point to the starting and ending indices of the subarray. We set them to a value of <code>0</code>.</p>
<p>To &quot;add&quot; elements to the window, we loop over the array by incrementing <code>right</code>. In this problem, if the sum of the window exceeds or equals <code>target</code>, we try to update our answer and then &quot;remove&quot; elements from the window by incrementing <code>left</code> until the sum is less than <code>target</code> again.</p>
<p>Here's a visual representation of how the approach works:</p>
<p>!?!../Documents/209/209-slides.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create three integer variables <code>left</code>, <code>right</code> and <code>sumOfCurrentWindow</code>. The variables <code>left</code> and <code>right</code> form a subarray by pointing to the starting and ending indices of the current subarray (or window), and <code>sumOfCurrentWindow</code> stores the sum of this window. Initialize all of them with <code>0</code>.</li>
<li>Create another variable <code>res</code> to store the answer to the problem. We initialize it to a large integer value.</li>
<li>We iterate over <code>nums</code> using <code>right</code> starting from <code>right = 0</code> till <code>nums.length - 1</code> incrementing <code>right</code> by <code>1</code> after each iteration. We perform the following inside this iteration:
<ul>
<li>Add element at index <code>right</code> to the current window, incrementing <code>sumOfCurrentWindow</code> by <code>nums[right]</code>.</li>
<li>We check if <code>sumOfCurrentWindow &gt;= target</code>. If so, we have a subarray that satisfies our condition. As a result, we attempt to update our answer variable with the length of this subarray. We perform <code>res = min(res, right - left + 1)</code>. We then remove the first element from this window by reducing <code>sumOfCurrentWindow</code> by <code>nums[left]</code> and incrementing <code>left</code> by <code>1</code>. This step is repeated in an inner loop as long as <code>sumOfCurrentWindow &gt;= target</code>.</li>
<li>The current window's sum is now smaller than <code>target</code>. We need to add more elements to it. As a result, <code>right</code> is incremented by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AX72e7bN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>You may be thinking: there is an inner while loop inside another for loop, isn't the time complexity <span class="math inline">\(O(n^2)\)</span>? The reason it is still <span class="math inline">\(O(n)\)</span> is because the right pointer <code>right</code> can move <span class="math inline">\(n\)</span> times and the left pointer <code>left</code> can move also <span class="math inline">\(n\)</span> times in total. The inner loop is not running <span class="math inline">\(n\)</span> times for each iteration of the outer loop. A sliding window guarantees a maximum of <span class="math inline">\(2n\)</span> window iterations. This is what is referred to as <a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized analysis</a> - even though the worst case for an iteration inside the for loop is <span class="math inline">\(O(n)\)</span>, it averages out to <span class="math inline">\(O(1)\)</span> when you consider the entire runtime of the algorithm.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>We are not using any extra space other than a few integer variables:<code>left</code>, <code>right</code>, <code>sumOfCurrentWindow</code>, and <code>res</code>, which takes up constant space each.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-space-wasted-from-packaging/description" target="_blank" rel="noopener noreferrer">Minimum Space Wasted From Packaging</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> packages that you are trying to place in boxes, <strong>one package in each box</strong>. There are <code>m</code> suppliers that each produce boxes of <strong>different sizes</strong> (with infinite supply). A package can be placed in a box if the size of the package is <strong>less than or equal to</strong> the size of the box.</p>

<p>The package sizes are given as an integer array <code>packages</code>, where <code>packages[i]</code> is the <strong>size</strong> of the <code>i<sup>th</sup></code> package. The suppliers are given as a 2D integer array <code>boxes</code>, where <code>boxes[j]</code> is an array of <strong>box sizes</strong> that the <code>j<sup>th</sup></code> supplier produces.</p>

<p>You want to choose a <strong>single supplier</strong> and use boxes from them such that the <strong>total wasted space </strong>is <strong>minimized</strong>. For each package in a box, we define the space <strong>wasted</strong> to be <code>size of the box - size of the package</code>. The <strong>total wasted space</strong> is the sum of the space wasted in <strong>all</strong> the boxes.</p>

<ul>
	<li>For example, if you have to fit packages with sizes <code>[2,3,5]</code> and the supplier offers boxes of sizes <code>[4,8]</code>, you can fit the packages of size-<code>2</code> and size-<code>3</code> into two boxes of size-<code>4</code> and the package with size-<code>5</code> into a box of size-<code>8</code>. This would result in a waste of <code>(4-2) + (4-3) + (8-5) = 6</code>.</li>
</ul>

<p>Return <em>the <strong>minimum total wasted space</strong> by choosing the box supplier <strong>optimally</strong>, or </em><code>-1</code> <i>if it is <strong>impossible</strong> to fit all the packages inside boxes. </i>Since the answer may be <strong>large</strong>, return it <strong>modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> packages = [2,3,5], boxes = [[4,8],[2,8]]
<strong>Output:</strong> 6
<strong>Explanation</strong>: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.
The total waste is (4-2) + (4-3) + (8-5) = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no box that the package of size 5 can fit in.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
<strong>Output:</strong> 9
<strong>Explanation:</strong> It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.
The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == packages.length</code></li>
	<li><code>m == boxes.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= packages[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= boxes[j].length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= boxes[j][k] &lt;= 10<sup>5</sup></code></li>
	<li><code>sum(boxes[j].length) &lt;= 10<sup>5</sup></code></li>
	<li>The elements in <code>boxes[j]</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/description" target="_blank" rel="noopener noreferrer">Minimum Value to Get Positive Step by Step Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers&nbsp;<code>nums</code>, you start with an initial <strong>positive</strong> value <em>startValue</em><em>.</em></p>

<p>In each iteration, you calculate the step by step sum of <em>startValue</em>&nbsp;plus&nbsp;elements in <code>nums</code>&nbsp;(from left to right).</p>

<p>Return the minimum <strong>positive</strong> value of&nbsp;<em>startValue</em> such that the step by step sum is never less than 1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,2,-3,4,2]
<strong>Output:</strong> 5
<strong>Explanation: </strong>If you choose startValue = 4, in the third iteration your step by step sum is less than 1.
<strong>step by step sum</strong>
<strong>startValue = 4 | startValue = 5 | nums</strong>
  (4 <strong>-3</strong> ) = 1  | (5 <strong>-3</strong> ) = 2    |  -3
  (1 <strong>+2</strong> ) = 3  | (2 <strong>+2</strong> ) = 4    |   2
  (3 <strong>-3</strong> ) = 0  | (4 <strong>-3</strong> ) = 1    |  -3
  (0 <strong>+4</strong> ) = 4  | (1 <strong>+4</strong> ) = 5    |   4
  (4 <strong>+2</strong> ) = 6  | (5 <strong>+2</strong> ) = 7    |   2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Minimum start value should be positive. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,-2,-3]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/description" target="_blank" rel="noopener noreferrer">Minimum White Tiles After Covering With Carpets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed binary</strong> string <code>floor</code>, which represents the colors of tiles on a floor:</p>

<ul>
	<li><code>floor[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>black</strong>.</li>
	<li>On the other hand, <code>floor[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>white</strong>.</li>
</ul>

<p>You are also given <code>numCarpets</code> and <code>carpetLen</code>. You have <code>numCarpets</code> <strong>black</strong> carpets, each of length <code>carpetLen</code> tiles. Cover the tiles with the given carpets such that the number of <strong>white</strong> tiles still visible is <strong>minimum</strong>. Carpets may overlap one another.</p>

<p>Return <em>the <strong>minimum</strong> number of white tiles still visible.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png" style="width: 400px; height: 73px;" />
<pre>
<strong>Input:</strong> floor = &quot;10110101&quot;, numCarpets = 2, carpetLen = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.
No other way of covering the tiles with the carpets can leave less than 2 white tiles visible.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/10/ex2.png" style="width: 353px; height: 123px;" />
<pre>
<strong>Input:</strong> floor = &quot;11111&quot;, numCarpets = 2, carpetLen = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> 
The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.
Note that the carpets are able to overlap one another.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>
	<li><code>floor[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/movement-of-robots/description" target="_blank" rel="noopener noreferrer">Movement of Robots</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">brainteaser</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Some robots are standing on an infinite number line with their initial coordinates given by a <strong>0-indexed</strong> integer array <code>nums</code> and will start moving once given the command to move. The robots will move a unit distance each second.</p>

<p>You are given a string <code>s</code> denoting the direction in which robots will move on command. <code>&#39;L&#39;</code> means the robot will move towards the left side or negative side of the number line, whereas <code>&#39;R&#39;</code> means the robot will move towards the right side or positive side of the number line.</p>

<p>If two robots collide, they will start moving in opposite directions.</p>

<p>Return <em>the sum of distances between all the&nbsp;pairs of robots </em><code>d</code> <em>seconds after&nbsp;the command. </em>Since the sum can be very large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p><b>Note: </b></p>

<ul>
	<li>For two robots at the index <code>i</code> and <code>j</code>, pair <code>(i,j)</code> and pair <code>(j,i)</code> are considered the same pair.</li>
	<li>When robots collide, they <strong>instantly change</strong> their directions without wasting any time.</li>
	<li>Collision happens&nbsp;when two robots share the same place in a&nbsp;moment.
	<ul>
		<li>For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they&#39;ll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.</li>
		<li>For example,&nbsp;if a robot is positioned in 0 going to the right and another is positioned in 1&nbsp;going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,0,2], s = &quot;RLL&quot;, d = 3
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
After 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.
After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.
After 3 seconds, the positions are [-3,-1,1].
The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.
The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.
The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.
The sum of the pairs of all distances = 2 + 4 + 2 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0], s = &quot;RL&quot;, d = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
After 1 second, the positions are [2,-1].
After 2 seconds, the positions are [3,-2].
The distance between the two robots is abs(-2 - 3) = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-2 * 10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>
	<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>
	<li><code>nums.length == s.length&nbsp;</code></li>
	<li><code>s</code> consists of &#39;L&#39; and &#39;R&#39; only</li>
	<li><code>nums[i]</code>&nbsp;will be unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/my-calendar-ii/description" target="_blank" rel="noopener noreferrer">My Calendar II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a <strong>triple booking</strong>.</p>

<p>A <strong>triple booking</strong> happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).</p>

<p>The event can be represented as a pair of integers <code>startTime</code> and <code>endTime</code> that represents a booking on the half-open interval <code>[startTime, endTime)</code>, the range of real numbers <code>x</code> such that <code>startTime &lt;= x &lt; endTime</code>.</p>

<p>Implement the <code>MyCalendarTwo</code> class:</p>

<ul>
	<li><code>MyCalendarTwo()</code> Initializes the calendar object.</li>
	<li><code>boolean book(int startTime, int endTime)</code> Returns <code>true</code> if the event can be added to the calendar successfully without causing a <strong>triple booking</strong>. Otherwise, return <code>false</code> and do not add the event to the calendar.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCalendarTwo&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
<strong>Output</strong>
[null, true, true, true, false, true, true]

<strong>Explanation</strong>
MyCalendarTwo myCalendarTwo = new MyCalendarTwo();
myCalendarTwo.book(10, 20); // return True, The event can be booked. 
myCalendarTwo.book(50, 60); // return True, The event can be booked. 
myCalendarTwo.book(10, 40); // return True, The event can be double booked. 
myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.
myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.
myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>1000</code> calls will be made to <code>book</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-overlapped-intervals">Approach 1: Using Overlapped Intervals</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a set of bookings in the form <code>[start, end)</code>, where <code>start</code> is included, but <code>end</code> is excluded, meaning the booking spans from <code>start</code> to <code>end - 1</code>. The function <code>book(start, end)</code> returns <code>true</code> if the booking can be added without causing a triple booking, and <code>false</code> otherwise. A triple booking occurs when three bookings overlap, such as <code>[[1, 5], [2, 4], [3, 4]]</code>, which all intersect between <code>[3, 4]</code>. The booking is only added if the function returns <code>true</code>.</p>
<p>The key problem is preventing a new booking from overlapping with two existing overlapping bookings, which would create a triple booking. For example, in the list <code>[[3, 10], [4, 8], [10, 15], [20, 25]]</code>, no triple booking occurs despite overlaps. However, adding <code>[5, 7]</code> would overlap with both <code>[[3, 10], [4, 8]]</code>, leading to a triple booking.</p>
<p>To handle this, we track double-overlapping bookings. When <code>book(start, end)</code> is called, we check if the new booking overlaps with any double-overlapped bookings. If it does, we return <code>false</code>; otherwise, we return <code>true</code>, add the booking, and update the double-overlapped list if necessary.</p>
<p>Checking for overlap between two bookings <code>(start1, end1)</code> and <code>(start2, end2)</code> is done by verifying if <code>max(start1, start2) &lt; min(end1, end2)</code>. This condition excludes endpoint overlaps, as the intervals are half-open. If they overlap, the overlap interval is <code>(max(start1, start2), min(end1, end2))</code>, also half-open. This can also be observed in the below figure:</p>
<p><img src="../Figures/731/731_overlapped_intervals.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Class <code>MyCalendarTwo</code> will have two data members, <code>bookings</code> which is the list of all bookings we will get, and <code>overlapBookings</code> a list of double overlapping bookings in the previous list. Initialize both as an empty list.</p>
</li>
<li>
<p>Define the function <code>doesOverlap(start1, end1, start2, end2)</code> which will return <code>true</code> if bookings <code>(start1, end1)</code> and <code>(start2, end2)</code> have an overlap.</p>
</li>
<li>
<p>Define the function <code>getOverlapped(start1, end1, start2, end2)</code> which will return the overlapping part of the bookings <code>(start1, end1)</code> and <code>(start2, end2)</code>.</p>
</li>
<li>
<p>Implement the function <code>book(start, end)</code> as follows:</p>
<ul>
<li>Check if the bookings <code>(start, end)</code> overlap with any booking in the list <code>overlapBookings</code>, if yes we can return <code>false</code> from here.</li>
<li>Iterate over the list <code>bookings</code> and check if <code>(start, end)</code> overlaps with any booking in it. If yes, add the overlapped part in the list <code>overlapBookings</code>.</li>
<li>Add the booking <code>(start, end)</code> to the list <code>booking</code>.</li>
<li>If we reach here, we can return <code>true</code> as no triple booking happened.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EgFDqNK4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the size of the list of <code>bookings</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The time complexity for the <code>book(start, end)</code> function is <span class="math inline">\(O(N)\)</span> because we iterate through the <code>bookings</code> list to check for overlaps and possibly add a new booking. Additionally, we check the <code>overlapBookings</code> list, which tracks overlaps. Since the size of <code>overlapBookings</code> is always smaller than or equal to the size of <code>bookings</code>, the overall time complexity remains <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We maintain two lists: <code>bookings</code> for all the bookings and <code>overlapBookings</code> for the overlapping intervals. The size of <code>overlapBookings</code> can never exceed the size of <code>bookings</code>, so the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep">Approach 2: Line Sweep</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The previous approach works well for the given problem, where we need to avoid triple bookings. However, if the requirements change such as checking for four overlapping bookings, the method becomes less flexible. We'd need to introduce additional lists, for example, to track triple bookings, making the solution harder to maintain and extend.</p>
<p>To address this, we can use a more flexible and standard solution: the <strong>Line Sweep</strong> algorithm. This approach is common for interval-related problems and can easily handle changes, such as checking for four or more overlapping bookings.</p>
<p>The Line Sweep algorithm works by marking when bookings start and end. For each booking <code>(start, end)</code>, we mark the <code>start</code> point by increasing its count by <code>1</code> (indicating a booking begins), and we mark the <code>end</code> point by decreasing its count by <code>1</code> (indicating a booking ends). These marks are stored in a map, which keeps track of the number of bookings starting or ending at each point.</p>
<p>Once all bookings are processed, we compute the prefix sum over the map. The prefix sum at any point tells us how many active bookings overlap at that moment. If the sum at any point exceeds <code>2</code>, it means we have a triple booking. At this point, the function should return <code>false</code> to prevent adding a new booking. If no triple booking is found, the function returns <code>true</code>, and the booking is allowed.</p>
<p>This approach is easily extendible. If we wanted to check for four or more bookings instead of three, we would simply adjust the threshold from <code>2</code> to <code>3</code> when calculating the prefix sum. This flexibility makes the Line Sweep method a more robust solution for variations of the problem.</p>
<p><img src="../Figures/731/731_line_sweep.png" alt="fig" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Class <code>MyCalendarTwo</code> will have two data members, <code>maxOverlappedBooking</code> which is the maximum number of concurrent bookings possible at a time, and <code>bookingCount</code> which is a map from integer to integer with the time point as the key and number of bookings as the value.</p>
</li>
<li>
<p>Initialize <code>maxOverlappedBooking</code> as <code>2</code>, as we need to check for triple booking.</p>
</li>
<li>
<p>Define the function <code>book(start, end)</code> as:</p>
<ul>
<li>Increase the number of bookings for the time <code>start</code> and decrease the number of bookings for <code>end</code> by <code>1</code> in the map <code>bookingCount</code>.</li>
<li>Iterate over each key-value pair in the map in ascending order of keys to find the prefix sum. Add the value in the map to the count <code>overlappedBooking</code>.</li>
<li>If <code>overlappedBooking</code> is more than two, it implies that this is triple booking. Hence, we should return false. Also, we need to revert the changes in the map as this booking shouldn't be added.</li>
<li>If we reach here, it implies no triple booking and hence returns <code>true</code>.</li>
</ul>
</li>
</ol>
<blockquote>
<p>Note: In the provided CPP solution, numbers are erased from a map after insertion if they are deemed unnecessary. However, instead of using <code>iterator erase(iterator first, iterator last)</code>, which operates in <span class="math inline">\(O(1)\)</span> time, we opt for <code>size_type erase(const Key&amp; key)</code>, resulting in <span class="math inline">\(O(log n)\)</span> complexity. A micro optimization would be to obtain iterator positions from the insertion, allowing for direct erasure in constant time.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MGcDSKpz/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the size of the list of <code>bookings</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The time complexity for the <code>book(start, end)</code> function is <span class="math inline">\(O(N)\)</span>. This is because, we iterate over the bookings entries in the map and find the prefix sum. The number of entries would be <span class="math inline">\(O(N)\)</span> and for each of these we can have <span class="math inline">\(3\)</span> operations with <span class="math inline">\(O(\log N)\)</span> complexity. Because once we find out the triple booking, we return from there and hence no more iteration is required. Hence the time complexity for the function <code>book(start, end)</code> becomes <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(N)\)</span> because we store the start and end points of each booking in the map. Each booking requires two entries in the map, so for <span class="math inline">\(N\)</span> bookings, we store <span class="math inline">\(2N\)</span> entries. Therefore, the space complexity is proportional to <span class="math inline">\(N\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/my-calendar-iii/description" target="_blank" rel="noopener noreferrer">My Calendar III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">design</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">segment tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <code>k</code>-booking happens when <code>k</code> events have some non-empty intersection (i.e., there is some time that is common to all <code>k</code> events.)</p>

<p>You are given some events <code>[startTime, endTime)</code>, after each given event, return an integer <code>k</code> representing the maximum <code>k</code>-booking between all the previous events.</p>

<p>Implement the <code>MyCalendarThree</code> class:</p>

<ul>
	<li><code>MyCalendarThree()</code> Initializes the object.</li>
	<li><code>int book(int startTime, int endTime)</code> Returns an integer <code>k</code> representing the largest integer such that there exists a <code>k</code>-booking in the calendar.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyCalendarThree&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
<strong>Output</strong>
[null, 1, 1, 2, 3, 3, 3]

<strong>Explanation</strong>
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // return 1
myCalendarThree.book(50, 60); // return 1
myCalendarThree.book(10, 40); // return 2
myCalendarThree.book(5, 15); // return 3
myCalendarThree.book(5, 10); // return 3
myCalendarThree.book(25, 55); // return 3

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= startTime &lt; endTime &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>400</code> calls will be made to <code>book</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-flowers-in-full-bloom/description" target="_blank" rel="noopener noreferrer">Number of Flowers in Full Bloom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>flowers</code>, where <code>flowers[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> means the <code>i<sup>th</sup></code> flower will be in <strong>full bloom</strong> from <code>start<sub>i</sub></code> to <code>end<sub>i</sub></code> (<strong>inclusive</strong>). You are also given a <strong>0-indexed</strong> integer array <code>people</code> of size <code>n</code>, where <code>people[i]</code> is the time that the <code>i<sup>th</sup></code> person will arrive to see the flowers.</p>

<p>Return <em>an integer array </em><code>answer</code><em> of size </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>number</strong> of flowers that are in full bloom when the </em><code>i<sup>th</sup></code><em> person arrives.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg" style="width: 550px; height: 216px;" />
<pre>
<strong>Input:</strong> flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
<strong>Output:</strong> [1,2,2,2]
<strong>Explanation: </strong>The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg" style="width: 450px; height: 195px;" />
<pre>
<strong>Input:</strong> flowers = [[1,10],[3,3]], people = [3,3,2]
<strong>Output:</strong> [2,2,1]
<strong>Explanation:</strong> The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= flowers.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>flowers[i].length == 2</code></li>
	<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= people[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-heappriority-queue">Approach 1: Heap/Priority Queue</h3>
<p><strong>Intuition</strong></p>
<p>For each <code>person</code> in <code>people</code>, we need to find how many flower ranges <code>[start, end]</code> contain <code>person</code>. An intuitive first step is to sort both input arrays so that we can process both <code>flowers</code> and <code>people</code> in chronological order.</p>
<p>For the first <code>person</code> (in terms of arrival time), we can find all the flowers that have <code>start</code> less than <code>person</code> - these are the flowers that have started blooming before <code>person</code> arrived, and thus <code>person</code> might have a chance of seeing them. Of those flowers, we remove the ones that have <code>end</code> less than <code>person</code> as well, as these are the flowers that have finished blooming, and <code>person</code> missed them. The number of remaining flowers is the answer for the first <code>person</code>. Note that because we sorted <code>people</code>, the flowers we remove here are guaranteed never to be seen again and therefore will not affect anyone else after <code>person</code>.</p>
<p>Let's move to the second <code>person</code>. Once again, we find all the flowers that have <code>start</code> less than <code>person</code>. But do we need to start from scratch? No! Because we are processing both the <code>flowers</code> and <code>people</code> in order, we can start from where we left off with the previous person. More specifically, because the second person's arrival time is greater than or equal to the previous person's, the flowers that bloom before the previous person must also bloom before the second person, so there's no need for us to handle this portion of flowers again. Therefore, we will add all the flowers that have <code>start</code> less than the second <code>person</code>, starting after the last flower we took.</p>
<p>Similarly, the flowers that the previous person missed are definitely also missed by the second person, so there's no need for us to handle this portion of removed flowers again. Once we have taken all the flowers with <code>start</code> less than <code>person</code>, we can simply remove all the flowers that have <code>end</code> less than <code>person</code>. The number of remaining flowers is the answer for the second <code>person</code>.</p>
<p>We can continue this process for each <code>person</code>. To find the flowers with <code>start</code> less than a given <code>person</code>, we can use a pointer <code>i</code> that starts at <code>0</code>. We will move <code>i</code> along the <code>flowers</code> array and never decrement or reset it. This allows us to pick up where we left off for each successive <code>person</code>.</p>
<p>How can we remove the flowers that have <code>end</code> less than a given <code>person</code>? This one is trickier because we can only sort <code>flowers</code> by one dimension. To use the pointer technique we just described, we must sort by the <code>start</code> times. Thus, the <code>end</code> times are not necessarily in order. For example, you could have <code>flowers</code> like this:</p>
<p><code>[2, 9], [3, 6]</code></p>
<p>In this case, using another pointer like <code>j</code> for the end times would not work since <code>9</code> is greater than <code>6</code> but comes earlier in the input.</p>
<p>As we are concerned with the flowers that have earlier end times, we can use a heap/priority queue to keep track of which flowers finish blooming. We will maintain a min <code>heap</code> and push <code>end</code> times of flowers onto this <code>heap</code>. Once we have added all flowers with <code>start</code> less than <code>person</code>, we will pop from the <code>heap</code> as long as the top of it is less than <code>person</code>.</p>
<p>After popping from <code>heap</code>, it will hold the end times of all flowers that <code>person</code> can see. Thus, the answer for <code>person</code> is simply the size of the heap.</p>
<blockquote>
<p>To summarize, we use a pointer <code>i</code> to iterate along <code>flowers</code>. For a given <code>person</code>, we find all the flowers that started blooming before <code>person</code> arrives. We push the <code>end</code> time of these flowers onto a <code>heap</code>. We can then remove all the flowers that finished blooming by popping from the <code>heap</code>, since a min <code>heap</code> efficiently gives us the minimum (earliest) times.</p>
<p>As we sort both input arrays, flowers that we pop from <code>heap</code> will never be seen again by future people.</p>
</blockquote>
<p>A note on implementation: here, we are sorting <code>people</code>, but the problem description asks us for the answer according to the original order. We will use a hash map that maps a <code>person</code> to the number of flowers they see. We will also keep the original order of <code>people</code> by creating a copy of it to sort. Once we have calculated the answer for everyone in the sorted order, we can iterate through the original <code>people</code> and refer to the hash map to build the final answer by restoring their original order.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort <code>flowers</code>. Create a sorted version of <code>people</code> called <code>sortedPeople</code>.</li>
<li>Initialize a hash map <code>dic</code>, a min <code>heap</code>, and an integer <code>i = 0</code>.</li>
<li>Iterate over <code>sortedPeople</code>. For each <code>person</code>:
<ul>
<li>While <code>flowers[i][0] &lt; person</code> (the flower at <code>i</code> already started blooming), push <code>flowers[i][1]</code> (when the flower finishes blooming) to <code>heap</code> and increment <code>i</code>.</li>
<li>While the top of <code>heap</code> (minimum element) is less than <code>person</code>, pop from <code>heap</code>.</li>
<li>Set <code>dic[person]</code> to the size of <code>heap</code>.</li>
</ul>
</li>
<li>Initialize an array <code>ans</code>. Iterate over <code>people</code> and populate <code>ans</code> using <code>dic</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/HZaGN9L3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n + m \cdot (\log{}n + \log{}m))\)</span></p>
<p>We start by sorting both <code>flowers</code> and <code>people</code>. This costs <span class="math inline">\(O(n \cdot \log{}n)\)</span> and <span class="math inline">\(O(m \cdot \log{}m)\)</span> respectively. Next, we perform <span class="math inline">\(O(m)\)</span> iterations. At each iteration, we perform some heap operations. The cost of these operations is dependent on the size of the heap. Our heap cannot exceed a size of <span class="math inline">\(n\)</span>, so these operations cost <span class="math inline">\(O(\log{}n)\)</span>.</p>
<p>There are some other linear time operations that don't affect our time complexity. In total, our time complexity is <span class="math inline">\(O(n \cdot \log{}n + m \cdot (\log{}n + \log{}m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We create an array <code>sortedPeople</code> of length <span class="math inline">\(m\)</span>. <code>dic</code> also grows to a length of <span class="math inline">\(m\)</span>, and <code>heap</code> can grow to a size of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-difference-array--binary-search">Approach 2: Difference Array + Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>There is a technique called difference array that can be used to solve many &quot;range&quot; based problems. The technique involves creating an array <code>difference</code> and iterating over all ranges <code>[start, end]</code>. We perform <code>difference[start]++</code> and <code>difference[end + 1]--</code> for each range.</p>
<p>The idea is that each index of <code>difference</code> represents the <strong>change</strong> in the number of flowers we can see when we cross this index (not the actual number of flowers on this index), with each index representing a unit of time. Thus, we could take a <code>prefix</code> sum of this <code>difference</code> array to find how many flowers can be seen at any given time with <code>prefix[time]</code>.</p>
<blockquote>
<p>Some people also call this technique &quot;line sweep&quot;.</p>
</blockquote>
<p>Unfortunately, if we look at the constraints, we find that values of <code>start, end, people</code> can be up to <span class="math inline">\(10^9\)</span>. It would not be feasible to create an array with such a large size. Thus, we need to use a map structure instead. Like in the previous approach, we still want to process everything chronologically. We will use the following data structures:</p>
<ul>
<li>In Java, we will use <code>TreeMap</code>.</li>
<li>In C++, we will use <code>std::map</code>.</li>
<li>In Python, we will use <code>sortedcontainers.SortedDict</code>.</li>
</ul>
<blockquote>
<p>Note that if you were not allowed to use these structures in an interview, you could still implement this approach using a normal hash map. You would just need to sort the elements in the hash map by key values after you populated it.</p>
</blockquote>
<p>Once we have this data structure <code>difference</code>, we will follow the process described above. We iterate over each <code>flower = [start, end]</code> and increment <code>difference[start]</code> while decrementing <code>difference[end + 1]</code>. The idea is that when we reach <code>start</code>, the number of flowers we see increases by one. When we reach <code>end + 1</code>, the number of flowers we see decreases by one.</p>
<p>We then create a <code>prefix</code> sum of the values in <code>difference</code>. We also need to know what time each value is associated with, so we will create an array <code>positions</code> to go along with our <code>prefix</code> array. Here, <code>prefix[i]</code> is the number of flowers available at time <code>positions[i]</code>.</p>
<p>Finally, we can iterate over <code>people</code> and find the answer for each <code>person</code>. How do we do this? We can perform a binary search over <code>positions</code> to find the index <code>i</code> where <code>person</code> fits. <code>prefix[i]</code> is the answer for this <code>person</code>.</p>
<p>Let's summarize the algorithm with an example:</p>
<p><img src="../Figures/2251/1.png" alt="example" /><br />
<br></p>
<p>Our first step is to populate <code>difference</code>. Each <code>key, value</code> pair in <code>difference</code> represents &quot;at time <code>key</code>, we see a change in <code>value</code> new flowers&quot;. For example, the key value pair of <code>6: -2</code> means that at time <code>6</code>, we see two less flowers.</p>
<p><img src="../Figures/2251/2.png" alt="example" /><br />
<br></p>
<p>Next, we create a <code>prefix</code> sum on the values of difference, as well as an array <code>positions</code> to associate each <code>prefix</code> value with a position in time. Notice that <code>positions</code> is just the keys of <code>difference</code>.</p>
<p><img src="../Figures/2251/3.png" alt="example" /><br />
<br></p>
<p>With these arrays, we can now use binary search to identify how many flowers a given <code>person</code> will see. For example, consider <code>person</code> at time <code>7</code>:</p>
<p><img src="../Figures/2251/4.png" alt="example" /><br />
<br></p>
<p>What about <code>person</code> at time <code>11</code>?</p>
<p><img src="../Figures/2251/5.png" alt="example" /><br />
<br></p>
<p>There are a few more things to consider before we start implementation.</p>
<ol>
<li>What happens if there is a <code>person</code> that arrives before any flower blooms? This may confuse our binary search since the minimum value in <code>positions</code> will be greater than <code>person</code>. We will initialize <code>difference</code> with <code>0: 0</code> to represent at time <code>0</code>, we don't see any new flowers.</li>
<li>Regarding the binary search; how should it be configured? Referencing the above example images, inserting <code>11</code> into the given <code>positions</code> array will put it at index <code>6</code>. However, we need index <code>5</code>. Thus, we need the insertion index minus one. What if the value exists in <code>positions</code>, as is the case with <code>person = 7</code>? To offset the minus one, we will binary search for the rightmost insertion index (<code>bisect_right</code> in Python, <code>upper_bound</code> in C++).</li>
</ol>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a sorted-map data structure <code>difference</code> with <code>0: 0</code>.</li>
<li>Iterate over each <code>flower = [start, end]</code> in <code>flowers</code>:
<ul>
<li>Increment <code>difference[start]</code>.</li>
<li>Decrement <code>difference[end + 1]</code>.</li>
</ul>
</li>
<li>Initialize two arrays, <code>positions</code> and <code>prefix</code>. Iterate over the keys of <code>difference</code>:
<ul>
<li><code>positions</code> contains all the keys in the order they are traversed.</li>
<li><code>prefix</code> contains the prefix sum of the corresponding values.</li>
</ul>
</li>
<li>Initialize the answer array <code>ans</code>. Iterate over each <code>person</code> in <code>people</code>:
<ul>
<li>Perform a right-insertion index binary search on <code>positions</code> with <code>person</code>.</li>
<li>Calculate <code>i</code> as the result of this binary search minus one.</li>
<li>Add <code>prefix[i]</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/fPatgqyF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
<p>Our first loop sets <code>difference</code>, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we calculate the prefix sum, which will cost either <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n \cdot \log{}n)\)</span> depending on your language's implementation. This is because <code>difference</code> will have a size between <span class="math inline">\(n\)</span> and <span class="math inline">\(2n\)</span>.</p>
<p>Finally, we have a loop over <code>people</code>. We perform a binary search that costs <span class="math inline">\(O(\log{}n)\)</span> at each iteration. Thus, we spend <span class="math inline">\(m \cdot \log{}n\)</span> here.</p>
<p>This gives us a final time complexity of <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>difference</code> has a size of <span class="math inline">\(O(n)\)</span>. <code>prefix</code> and <code>positions</code> have the same size as <code>difference</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-simpler-binary-search">Approach 3: Simpler Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we used the concept of a difference array/line sweep to calculate how many flowers are seen at a given time. For each <code>flower = [start, end]</code>, we indicated that at time <code>start</code>, we see one more flower, and at time <code>end + 1</code>, we see one less flower. We identified when a flower started blooming and when it finished blooming.</p>
<p>The idea behind this strategy is that at any given time, <strong>the number of flowers we see is the number of flowers that have already started blooming minus the amount of flowers have finished blooming.</strong></p>
<p>Is there a simpler way to identify at a given time, how many flowers have started blooming, and how many flowers have finished blooming? In the first two approaches, we always associate the <code>start</code> and <code>end</code> of the same flower together for processing, which is more intuitive but can be more complex to handle. What if we separately consider these two sets of times?</p>
<p>We can simply collect all <code>start</code> points in one array <code>starts</code>, sort it, and then perform a binary search. We can do the exact same thing with another array <code>ends</code> for all <code>end</code> points. Take a look at the following example:</p>
<p><img src="../Figures/2251/6.png" alt="example" /><br />
<br></p>
<p>Here, we have collected all <code>start</code> and <code>end</code> times and then sorted them. How many flowers can somebody at time <code>11</code> see?</p>
<p><img src="../Figures/2251/7.png" alt="example" /><br />
<br></p>
<p>As you can see, <code>4</code> flowers have started blooming and <code>2</code> flowers have finished blooming. Thus, <code>4 - 2 = 2</code> flowers can be seen at time <code>11</code>. Because <code>starts</code> and <code>ends</code> is sorted, we can use binary search to quickly identify how many flowers have started and finished blooming for any given time.</p>
<p>Regarding the binary searches: when binary searching on <code>starts</code>, we want to search for the rightmost insertion index. This is because if a <code>person</code> arrives at the same time as a flower starts blooming, we want to include this flower.</p>
<p>Note that a <code>flower = [start, end]</code> stops blooming at <code>end + 1</code>, not <code>end</code>. There are two ways we can handle this. We can either binary search on <code>end</code> for the leftmost insertion index (since we want to include all flowers with <code>end</code> equal to the current time), or we can assemble <code>ends</code> using <code>end + 1</code> for each <code>flower</code>. We will implement the algorithm using the second option in this article.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create two arrays <code>starts</code> and <code>ends</code>.</li>
<li>Iterate over each <code>flower = [start, end]</code> in <code>flowers</code>:
<ul>
<li>Add <code>start</code> to <code>starts</code>.</li>
<li>Add <code>end + 1</code> to <code>ends</code>.</li>
</ul>
</li>
<li>Sort both <code>starts</code> and <code>ends</code>.</li>
<li>Initialize the answer array <code>ans</code> and iterate over each <code>person</code> in <code>people</code>:
<ul>
<li>Perform a binary search on <code>starts</code> for the rightmost insertion index of <code>person</code> to find <code>i</code>.</li>
<li>Perform a binary search on <code>ends</code> for the rightmost insertion index of <code>person</code> to find <code>j</code>.</li>
<li>Add <code>i - j</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/RZab5Q59/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>flowers</code> and <span class="math inline">\(m\)</span> as the length of <code>people</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + m) \cdot \log{n})\)</span></p>
<p>We first create two arrays of length <span class="math inline">\(n\)</span>, <code>starts</code> and <code>ends</code>, then sort them. This costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
<p>Next, we iterate over <code>people</code> and perform two binary searches at each iteration. This costs <span class="math inline">\(O(m \cdot \log{}n)\)</span>.</p>
<p>Thus, our time complexity is <span class="math inline">\(O((n + m) \cdot \log{n})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>starts</code> and <code>ends</code> both have a size of <code>n</code>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-sub-arrays-with-odd-sum/description" target="_blank" rel="noopener noreferrer">Number of Sub-arrays With Odd Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code>, return <em>the number of subarrays with an <strong>odd</strong> sum</em>.</p>

<p>Since the answer can be very large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,3,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,4,6]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4,5,6,7]
<strong>Output:</strong> 16
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers, and our task is to count the number of subarrays whose sums are odd. Since the number of possible subarrays can be large, we return the count modulo <span class="math inline">\(10^9 + 7\)</span>.</p>
<p>A subarray is a contiguous portion of the array, meaning we must consider all possible starting and ending indices. The sum of a subarray is simply the sum of its elements.</p>
<p>For example, given <code>arr = [1,3,5]</code>, the possible subarrays are:</p>
<ul>
<li><code>[1] â†’ sum = 1 (odd)</code></li>
<li><code>[1,3] â†’ sum = 4 (even)</code></li>
<li><code>[1,3,5] â†’ sum = 9 (odd)</code></li>
<li><code>[3] â†’ sum = 3 (odd)</code></li>
<li><code>[3,5] â†’ sum = 8 (even)</code></li>
<li><code>[5] â†’ sum = 5 (odd)</code></li>
</ul>
<p>Here, the subarrays with an odd sum are <code>[1]</code>, <code>[1,3,5]</code>, <code>[3]</code>, and <code>[5]</code>, giving us the answer <code>4</code>.</p>
<p>A sliding window approach is generally useful when dealing with subarrays, but in this case, we cannot use it effectively. The problem requires counting all valid subarrays, not just maintaining a fixed window of size <code>k</code> or optimizing a contiguous segment. Since the valid subarrays are scattered across different positions and lengths, sliding window techniques do not provide any direct optimization here.</p>
<hr />
<h3 id="approach-1-brute-force-tle">Approach 1: Brute Force (TLE)</h3>
<h4 id="intuition">Intuition</h4>
<p>The most direct way to solve this problem is to explicitly generate all possible subarrays and check which ones have an odd sum.</p>
<p>To do this, we iterate over every possible starting index in the array. For each start, we extend the subarray one element at a time, maintaining a running sum as we go. Each time we add a new element to the sum, we check if it is odd. If it is, we increment our count.</p>
<p>Since we check all possible start and end pairs, the number of subarrays we examine is proportional to the square of the array size, leading to a time complexity of <span class="math inline">\(O(n^2)\)</span>. This means that for large arrays, the approach becomes too slow to be practical, leading to a Time Limit Exceeded (TLE) error.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a constant <code>MOD</code> with a value of <span class="math inline">\(10^9 + 7\)</span> to handle large numbers.</p>
</li>
<li>
<p>Initialize <code>n</code> to store the size of the array and <code>count</code> to keep track of the number of subarrays with an odd sum.</p>
</li>
<li>
<p>Iterate over each possible starting index <code>startIndex</code> in the array:</p>
<ul>
<li>
<p>Initialize <code>currentSum</code> to <code>0</code>, which will store the sum of the current subarray.</p>
</li>
<li>
<p>Iterate over each possible ending index <code>endIndex</code>, extending the subarray:</p>
<ul>
<li>Add <code>arr[endIndex]</code> to <code>currentSum</code>.</li>
<li>If <code>currentSum</code> is odd, increment <code>count</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>count % MOD</code> to ensure the result stays within bounds.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4WosmSxk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a nested loop to generate all possible subarrays. The outer loop runs <span class="math inline">\(n\)</span> times, and for each iteration of the outer loop, the inner loop runs up to <span class="math inline">\(n\)</span> times in the worst case. Therefore, the total number of iterations is <span class="math inline">\(n \times n = n^2\)</span>. Each iteration involves a constant amount of work (addition and modulo operation), so the time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space used by the algorithm is constant, as it only uses a few integer variables (<code>count</code>, <code>currentSum</code>, <code>startIndex</code>, <code>endIndex</code>, and <code>MOD</code>). No additional data structures that scale with the input size are used. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The key insight is that we do not need to compute the sum of every subarray explicitly. Instead, we only need to track the counts for the previous index and update them accordingly.</p>
<p>To achieve this, we observe how adding a number affects the parity of a sum:</p>
<ul>
<li>Adding an odd number flips the parity (even sum becomes odd, odd sum becomes even).</li>
<li>Adding an even number preserves the parity (even sum stays even, odd sum stays odd).</li>
</ul>
<p>To implement this efficiently, we use a 2Ã—2 DP table, <code>dp[2][2]</code>, where <code>dp[0][idx]</code> represents the number of subarrays ending at index <code>i</code> with an even sum, and <code>dp[1][idx]</code> represents the number of subarrays ending at index <code>i</code> with an odd sum. As we iterate through the array, we determine the parity of the current element and update these counts accordingly. If the element is odd, it flips the parity of previous subarrays, meaning that the count of new odd subarrays comes from the number of even subarrays from the previous index plus the current element itself. If the element is even, it preserves the parity, meaning that the count of even and odd subarrays remains the same as before, except for the inclusion of the new single-element subarray.</p>
<p>At the end of our iteration, the total number of subarrays with an odd sum is simply the sum of all values in <code>dp[1][idx]</code>, since these represent subarrays that end at various indices and have an odd sum.</p>
<blockquote>
<p>For a more comprehensive understanding of dynamic programming, check out the <a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming Explore Card ðŸ”—</a>.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Define <code>MOD</code> as <code>1e9 + 7</code> for handling large numbers modulo constraint.</p>
</li>
<li>
<p>Initialize <code>n</code> as the size of <code>arr</code>.</p>
</li>
<li>
<p>Use a 2x2 <code>dp</code> array to track counts of even and odd sum subarrays.</p>
</li>
<li>
<p>Initialize <code>count</code> to track the total number of odd sum subarrays.</p>
</li>
<li>
<p>Iterate over <code>arr</code> using index <code>i</code>:</p>
<ul>
<li>Compute <code>idx</code> as <code>i &amp; 1</code> to alternate between 0 and 1 for even/odd index tracking.</li>
<li>Compute <code>parity</code> as <code>arr[i] &amp; 1</code> to determine if the current element is odd (<code>1</code>) or even (<code>0</code>).</li>
<li>If the element is odd, update <code>dp[1][idx]</code> to <code>1 + dp[0][!idx]</code> since an odd element flips the sum parity.</li>
<li>If the element is even, update <code>dp[0][idx]</code> to <code>dp[1][!idx]</code> since an even element maintains the previous sum parity.</li>
<li>Accumulate <code>dp[1][idx]</code> into <code>count</code> since it represents the number of subarrays ending at <code>i</code> with an odd sum.</li>
</ul>
</li>
<li>
<p>Return <code>count</code>, which holds the total count of odd sum subarrays modulo <code>MOD</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/KKHpiikZ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm processes the array in a single pass, iterating through each element exactly once. During each iteration, we perform constant-time operations, including updating the <code>dp</code> table and computing the count of odd-sum subarrays. Since all operations inside the loop are <span class="math inline">\(O(1)\)</span>, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm maintains only a fixed-size <code>dp[2][2]</code> table. Since this table occupies only constant space regardless of <span class="math inline">\(n\)</span>, the overall space complexity is <span class="math inline">\(O(1)\)</span>. All other variables also use constant space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-prefix-sum-with-odd-even-counting">Approach 3: Prefix Sum with Odd-Even Counting</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of computing the sum of every possible subarray from scratch, we can leverage prefix sums to speed things up. The key insight is that the sum of any subarray can be determined by the difference between two prefix sums.</p>
<p>To understand this, consider the prefix sum at an index, which represents the cumulative sum of elements from the start of the array up to that index. The sum of a subarray starting at index <code>i</code> and ending at <code>j</code> is simply the difference between the prefix sum at <code>j</code> and the prefix sum at <code>i - 1</code>. This means that whether a subarray sum is odd or even depends only on the parity (odd/even property) of these two prefix sums.</p>
<p>From this, we can make a crucial observation:</p>
<ul>
<li>If two prefix sums have the same parity (both even or both odd), their difference will be <strong>even</strong>, meaning the subarray sum is even.</li>
<li>If two prefix sums have different parity (one is even, the other is odd), their difference will be <strong>odd</strong>, meaning the subarray sum is odd.</li>
</ul>
<p>This leads to an efficient way to count odd subarrays as we traverse the array. We maintain a cumulative <code>prefixSum</code> while keeping track of how many times we've seen an even or odd prefix sum before the current index. As we process each element:</p>
<ul>
<li>If <code>prefixSum</code> is even, it means the subarray sum from the start to the current index is even. To form an odd subarray, we need to subtract a previously seen <strong>odd</strong> prefix sum. So, we add the count of previously seen odd prefix sums to our answer.</li>
<li>If <code>prefixSum</code> is odd, the subarray sum from the start to the current index is odd. To form another odd subarray, we need to subtract a previously seen <strong>even</strong> prefix sum. So, we add the count of previously seen even prefix sums to our answer.</li>
</ul>
<p>Finally, after each update, we apply the modulo operation to ensure the result stays within the bounds.</p>
<p>The algorithm is visualized below:</p>
<p><img src="../Figures/1524/1524_odd_even_count.png" alt="1524_odd_even_count" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize constants and variables:</p>
<ul>
<li><code>MOD</code> is set to <span class="math inline">\(10^9 + 7\)</span> to handle large results.</li>
<li><code>count</code> is initialized to <code>0</code>, which will store the result.</li>
<li><code>prefixSum</code> is initialized to <code>0</code>, which will hold the running sum of the elements.</li>
<li><code>oddCount</code> is initialized to <code>0</code>, to count the number of subarrays with odd prefix sums.</li>
<li><code>evenCount</code> is initialized to <code>1</code>, since the sum starting at <code>0</code> is even.</li>
</ul>
</li>
<li>
<p>Iterate through each number <code>num</code> in the array <code>arr</code>:</p>
<ul>
<li>Add <code>num</code> to <code>prefixSum</code>.</li>
<li>If <code>prefixSum</code> is even, add <code>oddCount</code> to <code>count</code> and increment <code>evenCount</code> (since the sum is now even).</li>
<li>If <code>prefixSum</code> is odd, add <code>evenCount</code> to <code>count</code> and increment <code>oddCount</code> (since the sum is now odd).</li>
<li>Apply modulo operation <code>count %= MOD</code> to prevent overflow.</li>
</ul>
</li>
<li>
<p>Return the final value of <code>count</code>, which represents the total number of subarrays with odd sums.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NWyLdBoY/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm processes the array in a single pass. For each element in the array, it updates the <code>prefixSum</code>, checks whether the current prefix sum is even or odd, and updates the <code>count</code>, <code>oddCount</code>, and <code>evenCount</code> variables accordingly. Each of these operations takes constant time. Since the loop iterates through the array once, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space. It only maintains a few integer variables (<code>count</code>, <code>prefixSum</code>, <code>oddCount</code>, and <code>evenCount</code>), regardless of the size of the input array. No additional data structures that scale with the input size are used. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-submatrices-that-sum-to-target/description" target="_blank" rel="noopener noreferrer">Number of Submatrices That Sum to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>matrix</code>&nbsp;and a <code>target</code>, return the number of non-empty submatrices that sum to <font face="monospace">target</font>.</p>

<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>

<p>Two submatrices <code>(x1, y1, x2, y2)</code> and <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> are different if they have some coordinate&nbsp;that is different: for example, if <code>x1 != x1&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
<strong>Output:</strong> 4
<strong>Explanation:</strong> The four 1x1 submatrices that only contain 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,-1],[-1,1]], target = 0
<strong>Output:</strong> 5
<strong>Explanation:</strong> The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[904]], target = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
	<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
	<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
	<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-submatrix-have-sum-k/1" target="_blank" rel="noopener noreferrer">Number of submatrix have sum X</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a<strong><em data-start="46" data-end="53">&nbsp;</em></strong>matrix <strong><code data-start="61" data-end="70">mat[][]</code> </strong>of size&nbsp;</span><strong style="font-size: 18.6667px;">n &times; m </strong><span style="font-size: 14pt;">and an integer</span><strong style="font-size: 14pt;"> x</strong><span style="font-size: 14pt;">, find the number of square submatrices whose </span><strong style="font-size: 14pt;">sum </strong><span style="font-size: 14pt;">of elements is equal to <strong>x</strong></span><span style="font-size: 14pt;">.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[2, 4, 7, 8, 10], [3, 1, 1, 1, 1], [9, 11, 1, 2, 1], [12, -17, 1, 1, 1]], x = 10<strong><br />Output: </strong>3<strong><br /><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">Explanation</span>: </strong>The sub-squares whose sum of elements = 10, are colored in the matrix.<strong><br /></strong><img src="https://media.geeksforgeeks.org/wp-content/uploads/20250709104122447377/22.webp" width="403" height="342" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[3, 3, 5, 3], [2, 2, 2, 6], [11, 2, 2, 4]], x = 1<strong><br />Output: </strong>0<strong><br />Explanation: </strong>There is no sub-squares whose sum of elements is 1.</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &le; n, m &le; 100<br />-10<sup>3</sup> &le; mat[i] &le; 10<sup>3<br /></sup>-10<sup>9</sup> &le; x &le;&nbsp;</span><span style="font-size: 18.6667px;">10</span><sup>9</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description" target="_blank" rel="noopener noreferrer">Number of Ways of Cutting a Pizza</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a rectangular pizza represented as a <code>rows x cols</code>&nbsp;matrix containing the following characters: <code>&#39;A&#39;</code> (an apple) and <code>&#39;.&#39;</code> (empty cell) and given the integer <code>k</code>. You have to cut the pizza into <code>k</code> pieces using <code>k-1</code> cuts.&nbsp;</p>

<p>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.</p>

<p><em>Return the number of ways of cutting the pizza such that each piece contains <strong>at least</strong> one apple.&nbsp;</em>Since the answer can be a huge number, return this modulo 10^9 + 7.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png" style="width: 500px; height: 378px;" /></strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 3 
<strong>Explanation:</strong> The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
	<li><code>rows ==&nbsp;pizza.length</code></li>
	<li><code>cols ==&nbsp;pizza[i].length</code></li>
	<li><code>1 &lt;= k &lt;= 10</code></li>
	<li><code>pizza</code> consists of characters <code>&#39;A&#39;</code>&nbsp;and <code>&#39;.&#39;</code> only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-select-buildings/description" target="_blank" rel="noopener noreferrer">Number of Ways to Select Buildings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> binary string <code>s</code> which represents the types of buildings along a street where:</p>

<ul>
	<li><code>s[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> building is an office and</li>
	<li><code>s[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> building is a restaurant.</li>
</ul>

<p>As a city official, you would like to <strong>select</strong> 3 buildings for random inspection. However, to ensure variety, <strong>no two consecutive</strong> buildings out of the <strong>selected</strong> buildings can be of the same type.</p>

<ul>
	<li>For example, given <code>s = &quot;0<u><strong>0</strong></u>1<u><strong>1</strong></u>0<u><strong>1</strong></u>&quot;</code>, we cannot select the <code>1<sup>st</sup></code>, <code>3<sup>rd</sup></code>, and <code>5<sup>th</sup></code> buildings as that would form <code>&quot;0<strong><u>11</u></strong>&quot;</code> which is <strong>not</strong> allowed due to having two consecutive buildings of the same type.</li>
</ul>

<p>Return <em>the <b>number of valid ways</b> to select 3 buildings.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;001101&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The following sets of indices selected are valid:
- [0,2,4] from &quot;<u><strong>0</strong></u>0<strong><u>1</u></strong>1<strong><u>0</u></strong>1&quot; forms &quot;010&quot;
- [0,3,4] from &quot;<u><strong>0</strong></u>01<u><strong>10</strong></u>1&quot; forms &quot;010&quot;
- [1,2,4] from &quot;0<u><strong>01</strong></u>1<u><strong>0</strong></u>1&quot; forms &quot;010&quot;
- [1,3,4] from &quot;0<u><strong>0</strong></u>1<u><strong>10</strong></u>1&quot; forms &quot;010&quot;
- [2,4,5] from &quot;00<u><strong>1</strong></u>1<u><strong>01</strong></u>&quot; forms &quot;101&quot;
- [3,4,5] from &quot;001<u><strong>101</strong></u>&quot; forms &quot;101&quot;
No other selection is valid. Thus, there are 6 total ways.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;11100&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> It can be shown that there are no valid selections.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-split-array/description" target="_blank" rel="noopener noreferrer">Number of Ways to Split Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code>.</p>

<p><code>nums</code> contains a <strong>valid split</strong> at index <code>i</code> if the following are true:</p>

<ul>
	<li>The sum of the first <code>i + 1</code> elements is <strong>greater than or equal to</strong> the sum of the last <code>n - i - 1</code> elements.</li>
	<li>There is <strong>at least one</strong> element to the right of <code>i</code>. That is, <code>0 &lt;= i &lt; n - 1</code>.</li>
</ul>

<p>Return <em>the number of <strong>valid splits</strong> in</em> <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,4,-8,7]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
There are three ways of splitting nums into two non-empty parts:
- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 &gt;= 3, i = 0 is a valid split.
- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 &gt;= -1, i = 1 is a valid split.
- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 &lt; 7, i = 2 is not a valid split.
Thus, the number of valid splits in nums is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
There are two valid splits in nums:
- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 &gt;= 1, i = 1 is a valid split. 
- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 &gt;= 0, i = 2 is a valid split.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-prefix-sum-array">Approach 1: Prefix Sum Array</h3>
<h4 id="intuition">Intuition</h4>
<p>Our task is to count all splits in the array <code>nums</code> where the sum of values before the split is greater than or equal to the sum of values after the split.</p>
<p>The main challenge in this problem lies in efficiently calculating the sums at each split. The brute force approach would involve looping over each value in each section of the split and adding them up to compare. This means determining whether a split is valid would take linear time, making the overall process take quadratic time. Such an approach would be too slow for our requirements.</p>
<p>One way to determine the sum of any section of the array in constant time is by using a prefix sum array.</p>
<p>Each index in the prefix sum array stores the sum of all elements in the array from the start up to that index. For example:</p>
<p>If <code>nums = [2, 3, 5]</code>, the prefix sum array would be <code>[2, 5, 10]</code>.</p>
<ul>
<li><code>prefix[0]</code> = 2 (sum of the first element).</li>
<li><code>prefix[1]</code> = 2 + 3 = 5 (sum of the first two elements).</li>
<li><code>prefix[2]</code> = 2 + 3 + 5 = 10 (sum of all three elements).</li>
</ul>
<p>Using the prefix sum array, we can calculate the sum of any section of the array in constant time. For example, the sum of elements between index <code>start</code> (exclusive) and <code>end</code> (inclusive) is simply <code>prefix[end] - prefix[start]</code>. This avoids recalculating sums repeatedly for different splits.</p>
<p>Now that we understand prefix sums, let's create a prefix sum array <code>prefSum</code>. The first element will be <code>nums[0]</code> since no prefix exists for the <code>0</code>th element. For each subsequent index, we'll add the current value in <code>nums</code> to the prefix sum of the previous element.</p>
<p>With our prefix sum array ready, we can count the valid splits. We'll iterate through each possible split position. At each position, if the sum to the left of the split is greater than or equal to the sum to the right, we'll increment a counter. The final value of this counter will be our answer.</p>
<p>A common question that arises is how to recognize when to use the prefix sum technique. Suppose you're walking along a path, and someone asks how far you are from a point you passed earlier. Instead of counting the steps back, you just subtract the distance from where you are now to the point in question. This is what the prefix sum does. By using it, we can answer multiple queries in constant time, which reduces the computation time from a multiplication factor of <span class="math inline">\(q\)</span> to just addition for each query.</p>
<p>To generalize, when a problem requires answering multiple queries, and each query involves some form of range aggregation where each aggregate builds on the previous one, the prefix sum is often a good fit, such as the sum of a subarray, the product of a range, counting from a range or finding averages.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a variable <code>n</code> to store the length of the input array <code>nums</code>.</li>
<li>an array <code>prefSum</code> of size <code>n</code> to store prefix sums, using <code>long</code> data type to handle large numbers.</li>
</ul>
</li>
<li>Set the first element of <code>prefSum</code> to the first element of <code>nums</code>, as the prefix sum of one element is the element itself.</li>
<li>Iterate from index <code>1</code> to <code>n - 1</code> to build the prefix sum array:
<ul>
<li>Add the current element to the previous prefix sum to get the current prefix sum.</li>
<li>Store this value in <code>prefSum[i]</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>count</code> to <code>0</code> to track the number of valid splits.</li>
<li>Iterate <code>i</code> from <code>0</code> to <code>n - 2</code> to check each possible split position:
<ul>
<li>Calculate <code>leftSum</code> as the prefix sum up to index <code>i</code>.</li>
<li>Calculate <code>rightSum</code> by subtracting the prefix sum up to index <code>i</code> from the total sum (which is stored in <code>prefSum[n-1]</code>).</li>
<li>If <code>leftSum</code> is greater than or equal to <code>rightSum</code>, increment <code>count</code>.</li>
</ul>
</li>
<li>Return the final value of <code>count</code> as the result.</li>
</ul>
<blockquote>
<p>Note: Given the problem constraints where the array elements can be up to <code>10^5</code> and the array length up to <code>10^5</code>, the sum could reach <code>10^10</code> which exceeds integer limits. Therefore, we use <code>long</code> to safely handle these large sums.</p>
</blockquote>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/X9DvHPTJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm has two main loops. The first loop builds the prefix sum array in <span class="math inline">\(O(n)\)</span> time. The second loop iterates through all possible split positions, also taking <span class="math inline">\(O(n)\)</span> time. Since these operations are sequential, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses an additional array <code>prefSum</code> of size <span class="math inline">\(n\)</span> to store the prefix sums. No other data structures that scale with input size are used. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-prefix-and-suffix-sums">Approach 2: Optimized Prefix and Suffix Sums</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we calculated the prefix sum array and then iterated through the array again to check each split. This involves some repetitive work since the sums can be updated dynamically as we process each element. Instead of calculating the prefix sum separately, we can directly track the sums on the left and right sides of the split as we iterate through the array.</p>
<p>To do this, we maintain two variables:</p>
<ul>
<li>
<p><code>leftSum</code>: This keeps track of the sum of elements to the left of the current split position. At the beginning, since no elements are to the left, this is initialized to <code>0</code>.</p>
</li>
<li>
<p><code>rightSum</code>: This keeps track of the sum of elements to the right of the current split position. At the start, this is the total sum of the array, as all elements are initially on the right.</p>
</li>
</ul>
<p>Now, each time we consider a new split position, the current element moves from the right side to the left side. So we update <code>leftSum</code> and add the current element to it. And to update <code>rightSum</code>, we subtract the current element from it.</p>
<p>After updating these variables, we compare <code>leftSum</code> and <code>rightSum</code>. If <code>leftSum</code> is greater than or equal to <code>rightSum</code>, the split is valid, and we increment a counter. And we repeat this until we exhaust the entire array.</p>
<p>The slideshow below demonstrates this algorithm in action:</p>
<p>!?!../Documents/2270/slideshow.json:774,582!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize two variables <code>leftSum</code> and <code>rightSum</code> to <code>0</code> to track the sum of elements on the left and right sides of each split.</li>
<li>Calculate the initial <code>rightSum</code> by iterating through the input array and adding all elements to it, as initially, all elements are on the right side.</li>
<li>Initialize a variable <code>count</code> to <code>0</code> to track the number of valid splits.</li>
<li>Iterate from index <code>0</code> to the length of <code>nums</code> minus 2:
<ul>
<li>Add the current element to <code>leftSum</code> as it moves to the left side.</li>
<li>Subtract the current element from <code>rightSum</code> as it leaves the right side.</li>
<li>If <code>leftSum</code> is greater than or equal to <code>rightSum</code>, increment <code>count</code>.</li>
</ul>
</li>
<li>Return the final value of <code>count</code> as the result.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DQnGTDT9/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm has two main loops. The first loop calculates the initial <code>rightSum</code> by iterating through all elements once in <span class="math inline">\(O(n)\)</span> time. The second loop checks each possible split position, also taking <span class="math inline">\(O(n)\)</span> time. Since these operations are sequential, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses two variables (<code>leftSum</code> and <code>rightSum</code>) regardless of the input size. No additional data structures that scale with input are used. Therefore, the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-wonderful-substrings/description" target="_blank" rel="noopener noreferrer">Number of Wonderful Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>wonderful</strong> string is a string where <strong>at most one</strong> letter appears an <strong>odd</strong> number of times.</p>

<ul>
	<li>For example, <code>&quot;ccjjc&quot;</code> and <code>&quot;abab&quot;</code> are wonderful, but <code>&quot;ab&quot;</code> is not.</li>
</ul>

<p>Given a string <code>word</code> that consists of the first ten lowercase English letters (<code>&#39;a&#39;</code> through <code>&#39;j&#39;</code>), return <em>the <strong>number of wonderful non-empty substrings</strong> in </em><code>word</code><em>. If the same substring appears multiple times in </em><code>word</code><em>, then count <strong>each occurrence</strong> separately.</em></p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;aba&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The four wonderful substrings are underlined below:
- &quot;<u><strong>a</strong></u>ba&quot; -&gt; &quot;a&quot;
- &quot;a<u><strong>b</strong></u>a&quot; -&gt; &quot;b&quot;
- &quot;ab<u><strong>a</strong></u>&quot; -&gt; &quot;a&quot;
- &quot;<u><strong>aba</strong></u>&quot; -&gt; &quot;aba&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;aabb&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> The nine wonderful substrings are underlined below:
- &quot;<strong><u>a</u></strong>abb&quot; -&gt; &quot;a&quot;
- &quot;<u><strong>aa</strong></u>bb&quot; -&gt; &quot;aa&quot;
- &quot;<u><strong>aab</strong></u>b&quot; -&gt; &quot;aab&quot;
- &quot;<u><strong>aabb</strong></u>&quot; -&gt; &quot;aabb&quot;
- &quot;a<u><strong>a</strong></u>bb&quot; -&gt; &quot;a&quot;
- &quot;a<u><strong>abb</strong></u>&quot; -&gt; &quot;abb&quot;
- &quot;aa<u><strong>b</strong></u>b&quot; -&gt; &quot;b&quot;
- &quot;aa<u><strong>bb</strong></u>&quot; -&gt; &quot;bb&quot;
- &quot;aab<u><strong>b</strong></u>&quot; -&gt; &quot;b&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;he&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> The two wonderful substrings are underlined below:
- &quot;<b><u>h</u></b>e&quot; -&gt; &quot;h&quot;
- &quot;h<strong><u>e</u></strong>&quot; -&gt; &quot;e&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word</code> consists of lowercase English letters from <code>&#39;a&#39;</code>&nbsp;to <code>&#39;j&#39;</code>.</li>
</ul></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-count-parity-prefixes">Approach: Count Parity Prefixes</h3>
<h4 id="intuition">Intuition</h4>
<p>There are two types of wonderful strings: those with no letters appearing an odd number of times, and those with exactly one letter appearing an odd number of times. After we find a solution to count the first type of strings, we can adapt it to cover all cases.</p>
<p>The parity of a letter means whether the count of that letter in a word is even or odd. We can find the parity of a letter by taking the frequency of that letter modulo <span class="math inline">\(2\)</span>. Letters with odd frequencies have a parity of <span class="math inline">\(1\)</span>, and letters with even frequencies have a parity of <span class="math inline">\(0\)</span>. For example, the parity of letter &quot;a&quot; in &quot;abccada&quot; is <span class="math inline">\(1\)</span>, whereas the parity of letter &quot;c&quot; is <span class="math inline">\(0\)</span>.</p>
<p>The subtask now is to count the number of substrings with all letters appearing an even number of times. In other words, substrings where the parity of every letter is <span class="math inline">\(0\)</span>. Because there are only <span class="math inline">\(10\)</span> distinct letters the string can consist of, we can use a bitmask of <span class="math inline">\(10\)</span> bits to represent the parities of all letters in a string. The <code>0</code>th (least significant) bit of the mask corresponds to the parity of letter &quot;a&quot;, the <code>1</code>st bit corresponds to letter &quot;b&quot;, and so on.</p>
<p>For example, the parity mask corresponding to string &quot;feffaec&quot; is <span class="math inline">\(100101\)</span>, which equals <span class="math inline">\(37\)</span> in base 10. Letters &quot;a&quot;, &quot;c&quot;, and &quot;f&quot; appear an odd number of times, so their corresponding bits are set to <code>1</code>, and the other letters appear an even number of times, so their bits are set to <code>0</code>. We want to count the number of substrings with a mask of <span class="math inline">\(0\)</span> (if every character appears an even number of times, all bits will be set to <code>0</code>).</p>
<p>For any substring in the input string <code>word</code>, we can represent it as the difference between two prefixes of <code>s</code>. For example, substring <span class="math inline">\([2, 5]\)</span> is the difference between prefix <span class="math inline">\([0, 5]\)</span> and <span class="math inline">\([0, 1]\)</span>. Observe that the substring will equate to a mask of <span class="math inline">\(0\)</span> if and only if the masks of the two prefixes are equal. This is because we can &quot;subtract&quot; the larger prefix from the smaller prefix to create this substring using the <code>^</code> (XOR) operator. The XOR function is equivalent to subtraction under modulo <span class="math inline">\(2\)</span>. All bits are independently calculated in the XOR function, where for each bit, the output is true when there is an odd number of true inputs. This gives us an efficient way to find the difference between the larger and smaller prefixes.</p>
<p>This gives us a linear time way to count strings with all characters appearing an even number of times: maintain the parity mask of the current prefix, and compare it with previous prefixes of the same value in a frequency map. The key is a mask, which corresponds to a prefix of the string, and the value is the frequency of the key mask. To count substrings with all even letters ending at some index <span class="math inline">\(r\)</span>, take the prefix ending at <span class="math inline">\(r\)</span> with parity mask <span class="math inline">\(m\)</span>, and add <code>freq[m]</code> to the answer. The difference of two prefixes with the same bitmask will equal <code>0</code>, which corresponds to strings with all even frequency letters.</p>
<p>Here is an example of how parity masks are calculated for the string &quot;acadac&quot;, which has a mask of <span class="math inline">\(1001\)</span>. The <code>k</code>th letter of the alphabet will flip the <code>k</code>th smallest bit.</p>
<p><img src="../Figures/1915/1915_acadac_revised.png" alt="figA" /></p>
<p>All that's left is to account for the case where exactly one letter appears an odd number of times. For the current prefix mask, we can find its counterpart in the frequency map by iterating through which bit should be flipped. For example, if the current prefix mask is <span class="math inline">\(111\)</span>, and a smaller prefix has mask <span class="math inline">\(101\)</span>, the substring generated by removing the intersection of these two prefixes will equal <span class="math inline">\(010\)</span>, which means only the letter &quot;b&quot; appears an odd number of times.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a frequency table or map. Add the mask <span class="math inline">\(0\)</span> to account for the empty prefix.</li>
<li>Initialize a <code>mask</code> int variable to <span class="math inline">\(0\)</span>.</li>
<li>For each character in <code>word</code>, flip the corresponding bit in <code>mask</code>.</li>
<li>Add the frequency of <code>mask</code> to the answer.</li>
<li>Increment the value associated with key <code>mask</code> by one.</li>
<li>Iterate through each possible character that appears an odd number of times, and add the frequency of <code>mask ^ (1 &lt;&lt; odd_c)</code>, where <code>^</code> is the XOR function.</li>
<li>Return the result when all letters are processed.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/au2V8L5B/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time complexity: <span class="math inline">\(O(NA)\)</span>.</li>
</ul>
<p>The number of distinct characters that can appear in <code>word</code> is defined as <span class="math inline">\(A\)</span>. For each of the <span class="math inline">\(N\)</span> characters in <code>word</code>, we iterate through all possible characters that can be the odd character. Therefore, the time complexity of <span class="math inline">\(O(NA)\)</span>, where <span class="math inline">\(A \leq 10\)</span>, because only letters &quot;a&quot; through &quot;j&quot; will appear.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(N)\)</span>.</li>
</ul>
<p>The frequency map can store up to <span class="math inline">\(N\)</span> key/entry pairs, hence the linear space complexity.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-rearrangement-queries/description" target="_blank" rel="noopener noreferrer">Palindrome Rearrangement Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> having an <strong>even</strong> length <code>n</code>.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array, <code>queries</code>, where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>]</code>.</p>

<p>For each query <code>i</code>, you are allowed to perform the following operations:</p>

<ul>
	<li>Rearrange the characters within the <strong>substring</strong> <code>s[a<sub>i</sub>:b<sub>i</sub>]</code>, where <code>0 &lt;= a<sub>i</sub> &lt;= b<sub>i</sub> &lt; n / 2</code>.</li>
	<li>Rearrange the characters within the <strong>substring</strong> <code>s[c<sub>i</sub>:d<sub>i</sub>]</code>, where <code>n / 2 &lt;= c<sub>i</sub> &lt;= d<sub>i</sub> &lt; n</code>.</li>
</ul>

<p>For each query, your task is to determine whether it is possible to make <code>s</code> a <strong>palindrome</strong> by performing the operations.</p>

<p>Each query is answered <strong>independently</strong> of the others.</p>

<p>Return <em>a <strong>0-indexed</strong> array </em><code>answer</code><em>, where </em><code>answer[i] == true</code><em> if it is possible to make </em><code>s</code><em> a palindrome by performing operations specified by the </em><code>i<sup>th</sup></code><em> query, and </em><code>false</code><em> otherwise.</em></p>

<ul>
	<li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li>
	<li><code>s[x:y]</code> represents the substring consisting of characters from the index <code>x</code> to index <code>y</code> in <code>s</code>, <strong>both inclusive</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabc&quot;, queries = [[1,1,3,5],[0,2,5,5]]
<strong>Output:</strong> [true,true]
<strong>Explanation:</strong> In this example, there are two queries:
In the first query:
- a<sub>0</sub> = 1, b<sub>0</sub> = 1, c<sub>0</sub> = 3, d<sub>0</sub> = 5.
- So, you are allowed to rearrange s[1:1] =&gt; a<u>b</u>cabc and s[3:5] =&gt; abc<u>abc</u>.
- To make s a palindrome, s[3:5] can be rearranged to become =&gt; abc<u>cba</u>.
- Now, s is a palindrome. So, answer[0] = true.
In the second query:
- a<sub>1</sub> = 0, b<sub>1</sub> = 2, c<sub>1</sub> = 5, d<sub>1</sub> = 5.
- So, you are allowed to rearrange s[0:2] =&gt; <u>abc</u>abc and s[5:5] =&gt; abcab<u>c</u>.
- To make s a palindrome, s[0:2] can be rearranged to become =&gt; <u>cba</u>abc.
- Now, s is a palindrome. So, answer[1] = true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abbcdecbba&quot;, queries = [[0,2,7,9]]
<strong>Output:</strong> [false]
<strong>Explanation:</strong> In this example, there is only one query.
a<sub>0</sub> = 0, b<sub>0</sub> = 2, c<sub>0</sub> = 7, d<sub>0</sub> = 9.
So, you are allowed to rearrange s[0:2] =&gt; <u>abb</u>cdecbba and s[7:9] =&gt; abbcdec<u>bba</u>.
It is not possible to make s a palindrome by rearranging these substrings because s[3:6] is not a palindrome.
So, answer[0] = false.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;acbcab&quot;, queries = [[1,2,4,5]]
<strong>Output:</strong> [true]
<strong>Explanation: </strong>In this example, there is only one query.
a<sub>0</sub> = 1, b<sub>0</sub> = 2, c<sub>0</sub> = 4, d<sub>0</sub> = 5.
So, you are allowed to rearrange s[1:2] =&gt; a<u>cb</u>cab and s[4:5] =&gt; acbc<u>ab</u>.
To make s a palindrome s[1:2] can be rearranged to become a<u>bc</u>cab.
Then, s[4:5] can be rearranged to become abcc<u>ba</u>.
Now, s is a palindrome. So, answer[0] = true.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 4</code></li>
	<li><code>a<sub>i</sub> == queries[i][0], b<sub>i</sub> == queries[i][1]</code></li>
	<li><code>c<sub>i</sub> == queries[i][2], d<sub>i</sub> == queries[i][3]</code></li>
	<li><code>0 &lt;= a<sub>i</sub> &lt;= b<sub>i</sub> &lt; n / 2</code></li>
	<li><code>n / 2 &lt;= c<sub>i</sub> &lt;= d<sub>i</sub> &lt; n </code></li>
	<li><code>n</code> is even.</li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-array-to-minimize-xor/description" target="_blank" rel="noopener noreferrer">Partition Array to Minimize XOR</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>Your task is to partition <code>nums</code> into <code>k</code><strong> </strong>non-empty <strong><span data-keyword="subarray-nonempty">subarrays</span></strong>. For each subarray, compute the bitwise <strong>XOR</strong> of all its elements.</p>

<p>Return the <strong>minimum</strong> possible value of the <strong>maximum XOR</strong> among these <code>k</code> subarrays.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal partition is <code>[1]</code> and <code>[2, 3]</code>.</p>

<ul>
	<li>XOR of the first subarray is <code>1</code>.</li>
	<li>XOR of the second subarray is <code>2 XOR 3 = 1</code>.</li>
</ul>

<p>The maximum XOR among the subarrays is 1, which is the minimum possible.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,3,2], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal partition is <code>[2]</code>, <code>[3, 3]</code>, and <code>[2]</code>.</p>

<ul>
	<li>XOR of the first subarray is <code>2</code>.</li>
	<li>XOR of the second subarray is <code>3 XOR 3 = 0</code>.</li>
	<li>XOR of the third subarray is <code>2</code>.</li>
</ul>

<p>The maximum XOR among the subarrays is 2, which is the minimum possible.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,3,1], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal partition is <code>[1, 1]</code> and <code>[2, 3, 1]</code>.</p>

<ul>
	<li>XOR of the first subarray is <code>1 XOR 1 = 0</code>.</li>
	<li>XOR of the second subarray is <code>2 XOR 3 XOR 1 = 0</code>.</li>
</ul>

<p>The maximum XOR among the subarrays is 0, which is the minimum possible.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 250</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/plates-between-candles/description" target="_blank" rel="noopener noreferrer">Plates Between Candles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a long table with a line of plates and candles arranged on top of it. You are given a <strong>0-indexed</strong> string <code>s</code> consisting of characters <code>&#39;*&#39;</code> and <code>&#39;|&#39;</code> only, where a <code>&#39;*&#39;</code> represents a <strong>plate</strong> and a <code>&#39;|&#39;</code> represents a <strong>candle</strong>.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>queries</code> where <code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> denotes the <strong>substring</strong> <code>s[left<sub>i</sub>...right<sub>i</sub>]</code> (<strong>inclusive</strong>). For each query, you need to find the <strong>number</strong> of plates <strong>between candles</strong> that are <strong>in the substring</strong>. A plate is considered <strong>between candles</strong> if there is at least one candle to its left <strong>and</strong> at least one candle to its right <strong>in the substring</strong>.</p>

<ul>
	<li>For example, <code>s = &quot;||**||**|*&quot;</code>, and a query <code>[3, 8]</code> denotes the substring <code>&quot;*||<strong><u>**</u></strong>|&quot;</code>. The number of plates between candles in this substring is <code>2</code>, as each of the two plates has at least one candle <strong>in the substring</strong> to its left <strong>and</strong> right.</li>
</ul>

<p>Return <em>an integer array</em> <code>answer</code> <em>where</em> <code>answer[i]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="ex-1" src="https://assets.leetcode.com/uploads/2021/10/04/ex-1.png" style="width: 400px; height: 134px;" />
<pre>
<strong>Input:</strong> s = &quot;**|**|***|&quot;, queries = [[2,5],[5,9]]
<strong>Output:</strong> [2,3]
<strong>Explanation:</strong>
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="ex-2" src="https://assets.leetcode.com/uploads/2021/10/04/ex-2.png" style="width: 600px; height: 193px;" />
<pre>
<strong>Input:</strong> s = &quot;***|**|*****|**||**|*&quot;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
<strong>Output:</strong> [9,0,0,0,0]
<strong>Explanation:</strong>
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of <code>&#39;*&#39;</code> and <code>&#39;|&#39;</code> characters.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/points-that-intersect-with-cars/description" target="_blank" rel="noopener noreferrer">Points That Intersect With Cars</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>nums</code> representing the coordinates of the cars parking on a number line. For any index <code>i</code>, <code>nums[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> where <code>start<sub>i</sub></code> is the starting point of the <code>i<sup>th</sup></code> car and <code>end<sub>i</sub></code> is the ending point of the <code>i<sup>th</sup></code> car.</p>

<p>Return <em>the number of integer points on the line that are covered with <strong>any part</strong> of a car.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[3,6],[1,5],[4,7]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> All the points from 1 to 7 intersect at least one car, therefore the answer would be 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,3],[5,8]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Points intersecting at least one car are 1, 2, 3, 5, 6, 7, 8. There are a total of 7 points, therefore the answer would be 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>nums[i].length == 2</code></li>
	<li><code><font face="monospace">1 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;= 100</font></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/power-of-heroes/description" target="_blank" rel="noopener noreferrer">Power of Heroes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the strength of some heroes. The<b> power</b> of a group of heroes is defined as follows:</p>

<ul>
	<li>Let <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, ... ,<code>i<sub>k</sub></code> be the indices of the heroes in a group. Then, the power of this group is <code>max(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])<sup>2</sup> * min(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])</code>.</li>
</ul>

<p>Return <em>the sum of the <strong>power</strong> of all <strong>non-empty</strong> groups of heroes possible.</em> Since the sum could be very large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4]
<strong>Output:</strong> 141
<strong>Explanation:</strong> 
1<sup>st</sup>&nbsp;group: [2] has power = 2<sup>2</sup>&nbsp;* 2 = 8.
2<sup>nd</sup>&nbsp;group: [1] has power = 1<sup>2</sup> * 1 = 1. 
3<sup>rd</sup>&nbsp;group: [4] has power = 4<sup>2</sup> * 4 = 64. 
4<sup>th</sup>&nbsp;group: [2,1] has power = 2<sup>2</sup> * 1 = 4. 
5<sup>th</sup>&nbsp;group: [2,4] has power = 4<sup>2</sup> * 2 = 32. 
6<sup>th</sup>&nbsp;group: [1,4] has power = 4<sup>2</sup> * 1 = 16. 
â€‹â€‹â€‹â€‹â€‹â€‹â€‹7<sup>th</sup>&nbsp;group: [2,1,4] has power = 4<sup>2</sup>â€‹â€‹â€‹â€‹â€‹â€‹â€‹ * 1 = 16. 
The sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.

</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/product-of-array-except-self/description" target="_blank" rel="noopener noreferrer">Product of Array Except Self</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>

<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>

<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> [24,12,8,6]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]
<strong>Output:</strong> [0,0,9,0,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
	<li>The input is generated such that <code>answer[i]</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/product-of-the-last-k-numbers/description" target="_blank" rel="noopener noreferrer">Product of the Last K Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design an algorithm that accepts a stream of integers and retrieves the product of the last <code>k</code> integers of the stream.</p>

<p>Implement the <code>ProductOfNumbers</code> class:</p>

<ul>
	<li><code>ProductOfNumbers()</code> Initializes the object with an empty stream.</li>
	<li><code>void add(int num)</code> Appends the integer <code>num</code> to the stream.</li>
	<li><code>int getProduct(int k)</code> Returns the product of the last <code>k</code> numbers in the current list. You can assume that always the current list has at least <code>k</code> numbers.</li>
</ul>

<p>The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.</p>

<p>&nbsp;</p>
<p><strong class="example">Example:</strong></p>

<pre>
<strong>Input</strong>
[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

<strong>Output</strong>
[null,null,null,null,null,null,20,40,0,null,32]

<strong>Explanation</strong>
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= num &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= 4 * 10<sup>4</sup></code></li>
	<li>At most <code>4 * 10<sup>4</sup></code> calls will be made to <code>add</code> and <code>getProduct</code>.</li>
	<li>The product of the stream at any point in time will fit in a <strong>32-bit</strong> integer.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow-up: </strong>Can you implement <strong>both</strong> <code>GetProduct</code> and <code>Add</code> to work in <code>O(1)</code> time complexity instead of <code>O(k)</code> time complexity?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-prefix-product">Approach: Prefix Product</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to implement the <code>ProductOfNumbers</code> class initialized with an empty integer stream that supports two operations:</p>
<ol>
<li><code>add(int num)</code>: Add <code>num</code> to the stream.</li>
<li><code>getProduct(int k)</code>: Return the product of the last <code>k</code> integers in the stream. It's guaranteed that the product of the last <code>k</code> integers would fit into a 32-bit integer.</li>
</ol>
<p>While the problem seems simple, the constraints - especially the potential size of the stream - make it clear that a brute force solution wonâ€™t work. A brute force approach would involve iterating over the last <code>k</code> integers each time a query is made, but this would be inefficient given the constraints of the problem (the stream size and <code>k</code> are both bound by <code>4 * 10^4</code>).</p>
<p>To think of an optimized approach, letâ€™s first consider the <code>add</code> function in which we need to find the sum of the last <code>k</code> integers. A natural solution here is a prefix sum approach. <strong>Prefix sum</strong> refers to an array where each element at index <code>i</code> represents the sum of the elements in the original array from the beginning up to the <code>i</code>-th element. This allows us to efficiently compute the sum of any subarray by subtracting two prefix sums. More specifically, by storing the cumulative sum of all integers up to the current index in an array, we can quickly compute the sum of the last <code>k</code> integers by simply taking the difference between two prefix sums: <code>prefixSum[size] - prefixSum[size - k]</code>. This gives us the sum in constant time.</p>
<p>Now, letâ€™s apply a similar idea for the product. Instead of maintaining a prefix sum, we can maintain a <strong>prefix product</strong> array. This array will store the product of all integers encountered in the stream up to the current index. When we need the product of the last <code>k</code> integers, we can calculate it in constant time using the formula <code>prefixProduct[size] / prefixProduct[size - k]</code>, just like we did for the sum.</p>
<p>But there's one edge case here: the presence of a <code>0</code> in the stream complicates things. If we encounter a <code>0</code>, it nullifies all the products that come after it. For example, if the last <code>k</code> integers include a <code>0</code>, the product of those integers will always be <code>0</code>, regardless of the other numbers. This creates an issue when trying to calculate the product of the last <code>k</code> integers, especially if the <code>0</code> occurred earlier in the stream, long before the last <code>k</code> elements.</p>
<p>To address this, we can reset the <strong>prefix product array</strong> whenever we encounter a <code>0</code>. This ensures that once a <code>0</code> is encountered, the product calculation is reset, and any future products that involve the <code>0</code> will correctly result in <code>0</code>. When the product array is reset, we initialize it with <code>1</code> to start fresh.</p>
<p>Now, when answering a query to return the product of the last <code>k</code> integers, we can check the size of the prefix product array. If the size is less than or equal to <code>k</code>, we know that the last <code>k</code> integers must include a <code>0</code>, so we return <code>0</code>. Otherwise, we simply compute the product using the formula <code>prefixProduct[size] / prefixProduct[size - k]</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Constructor - <code>ProductOfNumbers()</code></p>
<ul>
<li>Initialize the <code>prefixProduct</code> list with <code>{1}</code> to handle multiplication logic without special cases for the initial product.</li>
<li>Set <code>size</code> to <code>0</code> to indicate that the product list is initially empty.</li>
</ul>
<p>Helper Function - <code>add(int num)</code></p>
<ul>
<li>If <code>num == 0</code>:
<ul>
<li>Reset the <code>prefixProduct</code> list to <code>{1}</code>.</li>
<li>Reset <code>size</code> to <code>0</code> to indicate an empty product list.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Append the cumulative product of the current number by multiplying it with the last value in the <code>prefixProduct</code> list.</li>
<li>Increment <code>size</code>.</li>
</ul>
</li>
</ul>
<p>Helper Function - <code>getProduct(int k)</code></p>
<ul>
<li>If <code>k &gt; size</code>:
<ul>
<li>Return <code>0</code> because this implies that a <code>0</code> had appeared within the last <code>k</code> elements, making the product <code>0</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Return the result of dividing <code>prefixProduct[size]</code> by <code>prefixProduct[size - k]</code> to get the product of the last <code>k</code> elements.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kDeYBmvc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements added to the <code>ProductOfNumbers</code> object using the <code>add</code> method, and let <span class="math inline">\(k\)</span> be the parameter passed to the <code>getProduct</code> method.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>add</code> method:</p>
<ul>
<li>When adding a number, the operation involves appending to the <code>prefix_product</code> list and updating the <code>size</code>. If the number is <code>0</code>, the list is reset.</li>
<li>Appending to a list and resetting the list are both <span class="math inline">\(O(1)\)</span> operations.</li>
<li>Therefore, the time complexity of the <code>add</code> method is <span class="math inline">\(O(1)\)</span>.</li>
</ul>
<p><code>getProduct</code> method:</p>
<ul>
<li>
<p>The <code>getProduct</code> method involves a division operation to compute the product of the last <span class="math inline">\(k\)</span> elements.</p>
</li>
<li>
<p>Division and accessing elements in a list are <span class="math inline">\(O(1)\)</span> operations.</p>
</li>
<li>
<p>Therefore, the time complexity of the <code>getProduct</code> method is <span class="math inline">\(O(1)\)</span>.</p>
<p>Therefore the <code>add</code> method runs in <span class="math inline">\(O(1)\)</span> time per operation, and the <code>getProduct</code> method also runs in <span class="math inline">\(O(1)\)</span> time per operation. For <span class="math inline">\(n\)</span> operations, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>prefixProduct</code> list stores the cumulative product of the numbers added. In the worst case, when no <code>0</code> is added, the list grows linearly with the number of elements added. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/random-pick-with-weight/description" target="_blank" rel="noopener noreferrer">Random Pick with Weight</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">randomized</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i<sup>th</sup></code> index.</p>

<p>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.</p>

<ul>
	<li>For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Solution&quot;,&quot;pickIndex&quot;]
[[[1]],[]]
<strong>Output</strong>
[null,0]

<strong>Explanation</strong>
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input</strong>
[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]
[[[1,3]],[],[],[],[],[]]
<strong>Output</strong>
[null,1,1,1,1,0]

<strong>Explanation</strong>
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>pickIndex</code> will be called at most <code>10<sup>4</sup></code> times.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/random-point-in-non-overlapping-rectangles/description" target="_blank" rel="noopener noreferrer">Random Point in Non-overlapping Rectangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">randomized</span> <span class="topic-badge">reservoir-sampling</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of non-overlapping axis-aligned rectangles <code>rects</code> where <code>rects[i] = [a<sub>i</sub>, b<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>]</code> indicates that <code>(a<sub>i</sub>, b<sub>i</sub>)</code> is the bottom-left corner point of the <code>i<sup>th</sup></code> rectangle and <code>(x<sub>i</sub>, y<sub>i</sub>)</code> is the top-right corner point of the <code>i<sup>th</sup></code> rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.</p>

<p>Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.</p>

<p><strong>Note</strong> that an integer point is a point that has integer coordinates.</p>

<p>Implement the <code>Solution</code> class:</p>

<ul>
	<li><code>Solution(int[][] rects)</code> Initializes the object with the given rectangles <code>rects</code>.</li>
	<li><code>int[] pick()</code> Returns a random integer point <code>[u, v]</code> inside the space covered by one of the given rectangles.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg" style="width: 419px; height: 539px;" />
<pre>
<strong>Input</strong>
[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]
[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]
<strong>Output</strong>
[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]

<strong>Explanation</strong>
Solution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);
solution.pick(); // return [1, -2]
solution.pick(); // return [1, -1]
solution.pick(); // return [-1, -2]
solution.pick(); // return [-2, -2]
solution.pick(); // return [0, 0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rects.length &lt;= 100</code></li>
	<li><code>rects[i].length == 4</code></li>
	<li><code>-10<sup>9</sup> &lt;= a<sub>i</sub> &lt; x<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= b<sub>i</sub> &lt; y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>x<sub>i</sub> - a<sub>i</sub> &lt;= 2000</code></li>
	<li><code>y<sub>i</sub> - b<sub>i</sub> &lt;= 2000</code></li>
	<li>All the rectangles do not overlap.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-product-queries-of-powers/description" target="_blank" rel="noopener noreferrer">Range Product Queries of Powers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>, there exists a <strong>0-indexed</strong> array called <code>powers</code>, composed of the <strong>minimum</strong> number of powers of <code>2</code> that sum to <code>n</code>. The array is sorted in <strong>non-decreasing</strong> order, and there is <strong>only one</strong> way to form the array.</p>

<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>queries</code>, where <code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>. Each <code>queries[i]</code> represents a query where you have to find the product of all <code>powers[j]</code> with <code>left<sub>i</sub> &lt;= j &lt;= right<sub>i</sub></code>.</p>

<p>Return<em> an array </em><code>answers</code><em>, equal in length to </em><code>queries</code><em>, where </em><code>answers[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query</em>. Since the answer to the <code>i<sup>th</sup></code> query may be too large, each <code>answers[i]</code> should be returned <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 15, queries = [[0,1],[2,2],[0,3]]
<strong>Output:</strong> [2,4,64]
<strong>Explanation:</strong>
For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size.
Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.
Answer to 2nd query: powers[2] = 4.
Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64.
Each answer modulo 10<sup>9</sup> + 7 yields the same answer, so [2,4,64] is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, queries = [[0,0]]
<strong>Output:</strong> [2]
<strong>Explanation:</strong>
For n = 2, powers = [2].
The answer to the only query is powers[0] = 2. The answer modulo 10<sup>9</sup> + 7 is the same, so [2] is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; powers.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-binary-decomposition--direct-calculation">Approach 1: Binary Decomposition + Direct Calculation</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem description, we need to decompose <span class="math inline">\(n\)</span> into the smallest number of powers of <span class="math inline">\(2\)</span>, which suggests writing <span class="math inline">\(n\)</span> in binary form. If the <span class="math inline">\(k\)</span>-th binary digit from low to high (where <span class="math inline">\(k \geq 0\)</span>) is <span class="math inline">\(1\)</span>, then <span class="math inline">\(2^k\)</span> is included in the decomposition.</p>
<blockquote>
<p>For example, when <span class="math inline">\(n = 11\)</span>, its binary representation is <span class="math inline">\((1011)_2\)</span>, and the <span class="math inline">\(0\)</span>th, <span class="math inline">\(1\)</span>st, and <span class="math inline">\(3\)</span>rd binary digits from low to high are <span class="math inline">\(1\)</span>. So, it is decomposed as <span class="math inline">\([2^0, 2^1, 2^3] = [1, 2, 8]\)</span>.</p>
</blockquote>
<p>After obtaining the decomposition of <span class="math inline">\(n\)</span>, and since the problem guarantees that <span class="math inline">\(n \geq 10^9 < 2^{30} - 1\)</span>, the decomposition array will contain at most <span class="math inline">\(29\)</span> elements. For each query <span class="math inline">\([\textit{left}, \textit{right}]\)</span>, we can directly traverse the corresponding elements in the decomposition array and compute the answer, with the time complexity of a single query being <span class="math inline">\(O(\log n)\)</span>.</p>
<p>Furthermore, since the total number of different queries is at most <span class="math inline">\(\dfrac{29 \times 28}{2} + 29 = 435\)</span>, we can also precompute the answer to each query in advance. This results in a preprocessing time complexity of <span class="math inline">\(O(\log^2 n)\)</span>, reducing the time complexity of each query to <span class="math inline">\(O(1)\)</span> thereafter.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jmE6Txtp/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(q\)</span> be the length of the array <span class="math inline">\(\textit{queries}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(q \times \log n)\)</span></p>
<p>For each query, we need to traverse the binary bits of <span class="math inline">\(n\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log n)\)</span></p>
<p>This is the space required for the binary decomposition of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-decomposition--prefix-product-preprocessing">Approach 2: Binary Decomposition + Prefix Product Preprocessing</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As in the previous approach, the key idea is to decompose the integer <span class="math inline">\(n\)</span> into a list of powers of <span class="math inline">\(2\)</span> based on its binary representation. If the <span class="math inline">\(k\)</span>-th binary digit (starting from the least significant bit) is <span class="math inline">\(1\)</span>, then the power <span class="math inline">\(2^k\)</span> contributes to the decomposition of <span class="math inline">\(n\)</span>.</p>
<blockquote>
<p>For example, for <span class="math inline">\(n = 11\)</span>, we have the binary representation <span class="math inline">\((1011)_2\)</span>. The <span class="math inline">\(0\)</span>th, <span class="math inline">\(1\)</span>st, and <span class="math inline">\(3\)</span>rd bits are <span class="math inline">\(1\)</span>, so <span class="math inline">\(n\)</span> can be represented as <span class="math inline">\([2^0, 2^1, 2^3] = [1, 2, 8]\)</span>.</p>
</blockquote>
<p>Now, instead of calculating the product of elements in each query range on-the-fly like in Approach 1, we can optimize this using precomputation. Since the number of binary digits set to <span class="math inline">\(1\)</span> in <span class="math inline">\(n\)</span> is at most <span class="math inline">\(29\)</span>, we can precompute the product of all subarrays of the decomposition array in advance.</p>
<p>We create a 2D array <code>results</code>, where <code>results[i][j]</code> stores the product of all powers of 2 from index <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> in the <code>bins</code> array. This way, once the precomputation is done, we can answer each query in constant time by directly reading from this table.</p>
<p>This gives us a trade-off:</p>
<ul>
<li>Preprocessing takes <span class="math inline">\(O(\log^2 n)\)</span> time, since for at most 29 elements we compute all <span class="math inline">\(O(\log^2 n)\)</span> subarray products.</li>
<li>Each query takes <span class="math inline">\(O(1)\)</span> time afterward, since we just do a single lookup.</li>
</ul>
<p>This is very efficient when the number of queries is large or the same queries are asked repeatedly.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/kdmWUa5S/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(q\)</span> be the length of the array <span class="math inline">\(\textit{queries}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\log^2 n + q)\)</span></p>
<p>After preprocessing, we don't need to traverse every time when querying.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log^2 n)\)</span></p>
<p>This is the space required to store the preprocessed results.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-of-sorted-subarray-sums/description" target="_blank" rel="noopener noreferrer">Range Sum of Sorted Subarray Sums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the array <code>nums</code> consisting of <code>n</code> positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of <code>n * (n + 1) / 2</code> numbers.</p>

<p><em>Return the sum of the numbers from index </em><code>left</code><em> to index </em><code>right</code> (<strong>indexed from 1</strong>)<em>, inclusive, in the new array. </em>Since the answer can be a huge number return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 5
<strong>Output:</strong> 13 
<strong>Explanation:</strong> All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 3, right = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 10
<strong>Output:</strong> 50
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem requires us to calculate all subarray sums of the given array, store the totals in a new array, sort this new array in non-decreasing order, and then sum the elements between the given <code>left</code> and <code>right</code> indices.</p>
<p>To achieve this, we'll create a new array called <code>storeSubarray</code> to store the sums of each subarray. Once we've iterated through the entire given array to calculate the subarray sums, we'll sort <code>storeSubarray</code> to be in non-decreasing order. Finally, we'll calculate and return the sum of the elements between the given <code>left</code> and <code>right</code> indices of <code>storeSubarray</code>, inclusive.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array given by <code>storeSubarray</code> to store all the subarray sums.</li>
<li>Iterate <code>i</code> through <code>nums</code>:</li>
</ol>
<ul>
<li>Initialize an integer <code>sum</code> with 0, to store the subarray sums starting at <code>i</code>.</li>
<li>Iterate <code>j</code> from <code>i</code> to the end of <code>nums</code>:
<ul>
<li>Increment <code>sum</code> with <code>nums[j]</code>.</li>
<li>Append <code>sum</code> to the <code>storeSubarray</code> array.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Sort <code>storeSubarray</code> in non-decreasing order.</li>
<li>Initialize <code>rangeSum</code> with 0 and mod with 1000000009.</li>
<li>Iterate all elements in <code>storeSubarray</code> between <code>left-1</code> and <code>right-1</code>:</li>
</ol>
<ul>
<li>Add the current value of <code>storeSubarray</code> to rangeSum and take its modulo with <code>mod</code>.</li>
</ul>
<ol start="6">
<li>Return <code>rangeSum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ekg42VMR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> twice to store all the subarray sums. This operation takes <span class="math inline">\(O(n^2)\)</span> time. Then, we sort this array storing all the subarray sums. The time complexity for this operation is <span class="math inline">\(O(n^2\cdot \log n)\)</span>. Iterating all indices between <code>left</code> and <code>right</code> also takes <span class="math inline">\(O(n^2)\)</span> time in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We create a <code>storeSubarray</code> array with size proportional to <span class="math inline">\(O(n^2)\)</span>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can maintain the sorted order of subarray sums using a priority queue, which stores elements in a sorted order using a heap data structure. By inserting all the subarray sums into the priority queue, we ensure that the smallest sums are always easily accessible.</p>
<p>Inserting all subarray sums into the priority queue results in the same time and space complexity as the previous approach, but it's possible to refine this strategy to optimize space complexity.</p>
<p>In our first approach, we created an array to store all possible subarray sums. In this approach, we'll use the priority queue to store pairs. The first element of each pair will represent the sum of the current subarray and the second element will represent the end index of that subarray. We'll initialize the priority queue with pairs representing all one-sized subarrays.</p>
<p>As we process the queue, we repeatedly pop the smallest element, which represents the smallest subarray sum. However, this subarray could be part of a larger subarray. To account for this, we expand the subarray by one element (incrementing the end index), update its sum, and push the updated pair back into the priority queue.</p>
<p>Once we have performed exactly <code>left</code> pop operations, we start accumulating the subarray sums. The process continues until we reach the <code>right</code> pop operation, at which point we return the accumulated sum.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a priority queue <code>pq</code> of pairs, where each pair contains:</p>
<ul>
<li>The value of the current sum of subarray.</li>
<li>The ending index of that subarray.</li>
</ul>
</li>
<li>
<p>The priority queue is ordered by the smallest sums first.</p>
</li>
<li>
<p>Populate the priority queue with the initial values:</p>
<ul>
<li>Iterate through the first <code>n</code> elements of <code>nums</code> and push pairs of each element and its index into the priority queue.</li>
</ul>
</li>
<li>
<p>Initialize <code>ans</code> to 0 to store the result and <code>mod</code> to (10^9 + 7) for the modulo operation.</p>
</li>
<li>
<p>Iterate from <code>1</code> to <code>right</code>:</p>
<ul>
<li>Extract the smallest sum from the priority queue (top of the queue).</li>
<li>If the current index <code>i</code> is greater than or equal to <code>left</code>, add the value of the current pair to <code>ans</code>, taking modulo <code>mod</code> to avoid overflow.</li>
<li>If the index of the extracted pair is less than the last index (<code>n-1</code>):
<ul>
<li>Increment the index.</li>
<li>Update the pair's value by adding the next element to the array <code>nums</code>.</li>
<li>Push the updated pair back into the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>ans</code> as a result.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/deXYG3zj/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> once to store all the one-sized subarray sums. This operation takes <span class="math inline">\(O(n)\)</span> time. Then, we iterate all indices between <code>left</code> and <code>right</code>, performing pop operation in each iteration, which takes <span class="math inline">\(O(n^2 \cdot \log n)\)</span> time total in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2\cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The size of <code>pq</code> never exceeds <code>n</code>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search-and-sliding-window">Approach 3: Binary Search and Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Can we use binary search to solve this problem? We can apply binary search if the search space is sorted. Here, our search space can be defined as the sum of the first <code>k</code> smallest subarray sums. To find the sum of all subarrays in this range, we calculate the difference between this sum at <code>right</code> and <code>left-1</code>.</p>
<p>We will create a binary search function that calculates the sum of the first <code>k</code> smallest subarray sums. The minimum and maximum possible values for this search space are the minimum array value and the total sum of the array, respectively. In our binary search function, for a particular <code>mid</code> value, we calculate the number of subarrays with a sum less than or equal to <code>mid</code>. If this count is greater than <code>k</code>, we need to search in the left part of the search space. Conversely, if it is less than <code>k</code>, we move to the right side.</p>
<p>To find the number of subarrays with a sum less than or equal to <code>mid</code>, we use the sliding window approach. We initialize two pointers, <code>left</code> and <code>right</code>, representing the ends of the window. If the sum of the window exceeds <code>mid</code>, we decrease the size of the window from the left side. We increment the count of windows for every valid <code>left</code> and <code>right</code> pair.</p>
<p>While counting subarrays, we also need to calculate their sum. To do this, we can determine the number of windows an element is part of by calculating <code>right - left + 1</code>. We then multiply the current element by this number and add it to a sum variable. This sum is maintained along with the count in the binary search process.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p><strong>Main function - <code>rangeSum(nums,n,left,right)</code></strong></p>
<ol>
<li>Calculate <code>result</code> as the difference of <code>sumOfFirstK(nums,n,right) - sumOfFirstK(nums,n,left-1)</code>. Return this <code>result</code> after taking modulo with <code>mod</code>.</li>
</ol>
<p><strong><code>sumOfFirstK(nums,n,k)</code></strong></p>
<ol>
<li>Initialize <code>minSum</code> and <code>maxSum</code> with minimum element value in <code>nums</code> and the total sum of <code>nums</code>, respectively.</li>
<li>Initialize <code>left</code> with <code>minSum</code> and <code>right</code> with <code>maxSum</code>.</li>
<li>Iterate while <code>left &lt;= right</code>:
<ul>
<li>Initialize <code>mid</code> as the mean of <code>left</code> and <code>right</code>.</li>
<li>If <code>countAndSum(nums,n,mid)</code>'s count value is greater than or equal to <code>k</code>:
<ul>
<li>Set <code>right</code> as <code>mid - 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>left</code> as <code>mid + 1</code>.</li>
</ul>
</li>
<li>Return the difference of <code>sum</code> and <code>left * (count - k)</code>, where <code>count</code> is the calculated count value.</li>
</ol>
<p><strong><code>countAndSum(nums,n,target)</code></strong></p>
<ol>
<li>Initialize <code>count = 0</code>, <code>currentSum = 0</code>, <code>totalSum = 0</code> and <code>windowSum = 0</code>.</li>
<li>Iterate through <code>nums</code> while <code>j &lt; n</code> and initialize <code>j</code> and <code>i</code> with 0:
<ul>
<li>Add <code>nums[j]</code> to <code>currentSum</code>.</li>
<li>Add <code>nums[j]*(j-i+1)</code> to <code>windowSum</code>.</li>
<li>While <code>currentSum</code> &gt; <code>target</code>:
<ul>
<li>Decrement <code>currentSum</code> from <code>windowSum</code>.</li>
<li>Decrement <code>nums[i]</code> from <code>currentSum</code> and increment <code>i</code>.</li>
</ul>
</li>
<li>Add <code>j-i+1</code> to <code>count</code>.</li>
<li>Add <code>windowSum</code> to <code>totalCount</code>.</li>
</ul>
</li>
<li>Return <code>{count,totalSum}</code>.</li>
</ol>
<p>!?!../Documents/1508/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/SER6g6tf/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size and <code>sum</code> be the total sum of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log sum)\)</span></p>
<p>The total size of the search space is <span class="math inline">\(O(sum)\)</span>. Therefore, time complexity for binary search is <span class="math inline">\(O(\log sum)\)</span>. Inside each binary search operation, the <code>countAndSum</code> function takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log sum)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Apart from some constant sized variables, no additional memory is used. Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-query-2d-immutable/description" target="_blank" rel="noopener noreferrer">Range Sum Query 2D - Immutable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:</p>

<ul>
	<li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>
</ul>

<p>Implement the <code>NumMatrix</code> class:</p>

<ul>
	<li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li>
	<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>
</ul>

<p>You must design an algorithm where <code>sumRegion</code> works on <code>O(1)</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" style="width: 415px; height: 415px;" />
<pre>
<strong>Input</strong>
[&quot;NumMatrix&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
<strong>Output</strong>
[null, 8, 11, 12]

<strong>Explanation</strong>
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>-10<sup>4</sup> &lt;= matrix[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>
	<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRegion</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-query-immutable/description" target="_blank" rel="noopener noreferrer">Range Sum Query - Immutable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>

<ol>
	<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>
</ol>

<p>Implement the <code>NumArray</code> class:</p>

<ul>
	<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
	<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
<strong>Output</strong>
[null, 1, -1, -3]

<strong>Explanation</strong>
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRange</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rearrange-array-to-maximize-prefix-score/description" target="_blank" rel="noopener noreferrer">Rearrange Array to Maximize Prefix Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. You can rearrange the elements of <code>nums</code> to <strong>any order</strong> (including the given order).</p>

<p>Let <code>prefix</code> be the array containing the prefix sums of <code>nums</code> after rearranging it. In other words, <code>prefix[i]</code> is the sum of the elements from <code>0</code> to <code>i</code> in <code>nums</code> after rearranging it. The <strong>score</strong> of <code>nums</code> is the number of positive integers in the array <code>prefix</code>.</p>

<p>Return <em>the maximum score you can achieve</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,-1,0,1,-3,3,-3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
prefix = [2,5,6,5,2,2,-1], so the score is 6.
It can be shown that 6 is the maximum score we can obtain.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-2,-3,0]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Any rearrangement of the array will result in a score of 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/removing-minimum-number-of-magic-beans/description" target="_blank" rel="noopener noreferrer">Removing Minimum Number of Magic Beans</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>beans</code>, where each integer represents the number of magic beans found in a particular magic bag.</p>

<p><strong>Remove</strong> any number of beans (<strong>possibly none</strong>) from each bag such that the number of beans in each remaining <strong>non-empty</strong> bag (still containing <strong>at least one</strong> bean) is <strong>equal</strong>. Once a bean has been removed from a bag, you are <strong>not</strong> allowed to return it to any of the bags.</p>

<p>Return <em>the <strong>minimum</strong> number of magic beans that you have to remove</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> beans = [4,1,6,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
- We remove 1 bean from the bag with only 1 bean.
  This results in the remaining bags: [4,<strong><u>0</u></strong>,6,5]
- Then we remove 2 beans from the bag with 6 beans.
  This results in the remaining bags: [4,0,<strong><u>4</u></strong>,5]
- Then we remove 1 bean from the bag with 5 beans.
  This results in the remaining bags: [4,0,4,<strong><u>4</u></strong>]
We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that remove 4 beans or fewer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> beans = [2,10,3,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong>
- We remove 2 beans from one of the bags with 2 beans.
  This results in the remaining bags: [<u><strong>0</strong></u>,10,3,2]
- Then we remove 2 beans from the other bag with 2 beans.
  This results in the remaining bags: [0,10,3,<u><strong>0</strong></u>]
- Then we remove 3 beans from the bag with 3 beans. 
  This results in the remaining bags: [0,10,<u><strong>0</strong></u>,0]
We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.
There are no other solutions that removes 7 beans or fewer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= beans.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= beans[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/running-sum-of-1d-array/description" target="_blank" rel="noopener noreferrer">Running Sum of 1d Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code>.</p>

<p>Return the running sum of <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> [1,3,6,10]
<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1]
<strong>Output:</strong> [1,2,3,4,5]
<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,2,10,1]
<strong>Output:</strong> [3,4,6,16,17]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shift-distance-between-two-strings/description" target="_blank" rel="noopener noreferrer">Shift Distance Between Two Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code> of the same length, and two integer arrays <code>nextCost</code> and <code>previousCost</code>.</p>

<p>In one operation, you can pick any index <code>i</code> of <code>s</code>, and perform <strong>either one</strong> of the following actions:</p>

<ul>
	<li>Shift <code>s[i]</code> to the next letter in the alphabet. If <code>s[i] == &#39;z&#39;</code>, you should replace it with <code>&#39;a&#39;</code>. This operation costs <code>nextCost[j]</code> where <code>j</code> is the index of <code>s[i]</code> in the alphabet.</li>
	<li>Shift <code>s[i]</code> to the previous letter in the alphabet. If <code>s[i] == &#39;a&#39;</code>, you should replace it with <code>&#39;z&#39;</code>. This operation costs <code>previousCost[j]</code> where <code>j</code> is the index of <code>s[i]</code> in the alphabet.</li>
</ul>

<p>The <strong>shift distance</strong> is the <strong>minimum</strong> total cost of operations required to transform <code>s</code> into <code>t</code>.</p>

<p>Return the <strong>shift distance</strong> from <code>s</code> to <code>t</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abab&quot;, t = &quot;baba&quot;, nextCost = [100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], previousCost = [1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>We choose index <code>i = 0</code> and shift <code>s[0]</code> 25 times to the previous character for a total cost of 1.</li>
	<li>We choose index <code>i = 1</code> and shift <code>s[1]</code> 25 times to the next character for a total cost of 0.</li>
	<li>We choose index <code>i = 2</code> and shift <code>s[2]</code> 25 times to the previous character for a total cost of 1.</li>
	<li>We choose index <code>i = 3</code> and shift <code>s[3]</code> 25 times to the next character for a total cost of 0.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;leet&quot;, t = &quot;code&quot;, nextCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], previousCost = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">31</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>We choose index <code>i = 0</code> and shift <code>s[0]</code> 9 times to the previous character for a total cost of 9.</li>
	<li>We choose index <code>i = 1</code> and shift <code>s[1]</code> 10 times to the next character for a total cost of 10.</li>
	<li>We choose index <code>i = 2</code> and shift <code>s[2]</code> 1 time to the previous character for a total cost of 1.</li>
	<li>We choose index <code>i = 3</code> and shift <code>s[3]</code> 11 times to the next character for a total cost of 11.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length == t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>
	<li><code>nextCost.length == previousCost.length == 26</code></li>
	<li><code>0 &lt;= nextCost[i], previousCost[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shifting-letters/description" target="_blank" rel="noopener noreferrer">Shifting Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of lowercase English letters and an integer array <code>shifts</code> of the same length.</p>

<p>Call the <code>shift()</code> of a letter, the next letter in the alphabet, (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>).</p>

<ul>
	<li>For example, <code>shift(&#39;a&#39;) = &#39;b&#39;</code>, <code>shift(&#39;t&#39;) = &#39;u&#39;</code>, and <code>shift(&#39;z&#39;) = &#39;a&#39;</code>.</li>
</ul>

<p>Now for each <code>shifts[i] = x</code>, we want to shift the first <code>i + 1</code> letters of <code>s</code>, <code>x</code> times.</p>

<p>Return <em>the final string after all such shifts to s are applied</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abc&quot;, shifts = [3,5,9]
<strong>Output:</strong> &quot;rpl&quot;
<strong>Explanation:</strong> We start with &quot;abc&quot;.
After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;.
After shifting the first 2 letters of s by 5, we have &quot;igc&quot;.
After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaa&quot;, shifts = [1,2,3]
<strong>Output:</strong> &quot;gfd&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>shifts.length == s.length</code></li>
	<li><code>0 &lt;= shifts[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-prefix-sum-accepted">Approach #1: Prefix Sum [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Let's ask how many times the <code>i</code>th character is shifted.</p>
<p><strong>Algorithm</strong></p>
<p>The <code>i</code>th character is shifted <code>shifts[i] + shifts[i+1] + ... + shifts[shifts.length - 1]</code> times.  That's because only operations at the <code>i</code>th operation and after, affect the <code>i</code>th character.</p>
<p>Let <code>X</code> be the number of times the current <code>i</code>th character is shifted.  Then the next character <code>i+1</code> is shifted <code>X - shifts[i]</code> times.</p>
<p>For example, if <code>S.length = 4</code> and <code>S[0]</code> is shifted <code>X = shifts[0] + shifts[1] + shifts[2] + shifts[3]</code> times, then <code>S[1]</code> is shifted <code>shifts[1] + shifts[2] + shifts[3]</code> times, <code>S[2]</code> is shifted <code>shifts[2] + shifts[3]</code> times, and so on.</p>
<p>In general, we need to do <code>X -= shifts[i]</code> to maintain the correct value of <code>X</code> as we increment <code>i</code>.</p>
<p><a href="https://leetcode.com/playground/JbgCrRzF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>S</code> (and <code>shifts</code>).</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>, the space needed to output the answer.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shifting-letters-ii/description" target="_blank" rel="noopener noreferrer">Shifting Letters II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of lowercase English letters and a 2D integer array <code>shifts</code> where <code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>. For every <code>i</code>, <strong>shift</strong> the characters in <code>s</code> from the index <code>start<sub>i</sub></code> to the index <code>end<sub>i</sub></code> (<strong>inclusive</strong>) forward if <code>direction<sub>i</sub> = 1</code>, or shift the characters backward if <code>direction<sub>i</sub> = 0</code>.</p>

<p>Shifting a character <strong>forward</strong> means replacing it with the <strong>next</strong> letter in the alphabet (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>). Similarly, shifting a character <strong>backward</strong> means replacing it with the <strong>previous</strong> letter in the alphabet (wrapping around so that <code>&#39;a&#39;</code> becomes <code>&#39;z&#39;</code>).</p>

<p>Return <em>the final string after all such shifts to </em><code>s</code><em> are applied</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]
<strong>Output:</strong> &quot;ace&quot;
<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 1 backward. Now s = &quot;zac&quot;.
Secondly, shift the characters from index 1 to index 2 forward. Now s = &quot;zbd&quot;.
Finally, shift the characters from index 0 to index 2 forward. Now s = &quot;ace&quot;.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]
<strong>Output:</strong> &quot;catz&quot;
<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 0 backward. Now s = &quot;cztz&quot;.
Finally, shift the characters from index 1 to index 1 forward. Now s = &quot;catz&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>shifts[i].length == 3</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>
	<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase English letters and a 2D array <code>shifts</code>, where each entry is a triplet <code>[start, end, direction]</code>. Each shift operation in <code>shifts</code> updates a range of characters <code>[start, end]</code> in the string <code>s</code> in the following way:</p>
<ul>
<li>If <code>direction == 1</code>: Shift each character in the range forward in the alphabet. For example, 'a' becomes 'b', and 'z' wraps around to 'a'.</li>
<li>If <code>direction == 0</code>: Shift each character in the range backward in the alphabet. For example, 'b' becomes 'a', and 'a' wraps around to 'z'.</li>
</ul>
<p>A direct implementation would involve iterating over each range <code>[start, end]</code> for every shift operation and updating the characters in that range individually.<br />
Since applying each shift involves iterating over a substring of <code>s</code>, and this approach has a quadratic time complexity which is inefficient for the problem's constraints.</p>
<p>Instead of applying each shift directly, we can optimize by focusing on the net effect of all shifts on each character. This means that rather than updating the string multiple times for each operation, we calculate how many total shifts each character undergoes. Once the total shifts <code>numberOfShifts</code> for each character have been calculated, we can use the following formula to create the final string in one pass:</p>
<p><span class="math display">\[\begin{aligned}
\text{newChar} = \text{'a'} + (\text{oldChar} - \text{'a'} + \text{numberOfShifts}) \text{ mod } 26.
\end{aligned}
\]</span></p>
<p>Here,</p>
<ul>
<li><span class="math inline">\(\text{oldChar} - \text{'a'}\)</span>: Converts the character to a 0-based index in the range [0, 25] (e.g., 'a' = 0, 'b' = 1, ..., 'z' = 25).</li>
<li><span class="math inline">\(\text{numberOfShifts}\)</span>: Applies the total shifts to the character.</li>
<li><span class="math inline">\(\text{ mod } 26\)</span>: Ensures the result wraps around the alphabet if necessary (e.g., shifting 'z' forward yields 'a').</li>
<li><span class="math inline">\(\text{'a'} + ...\)</span> : Converts the 0-based index back to a character.</li>
</ul>
<p>Calculating the total effect of all shifts on each character is a key step toward optimizing the solution. However, this calculation does not reduce the time complexity compared to the naive approach. This is because it still involves iterating over all the substrings specified by the shifts array and updating a counter for every character in those ranges.</p>
<hr />
<h3 id="approach-difference-array">Approach: Difference Array</h3>
<h4 id="intuition">Intuition</h4>
<p>Building on the idea of cumulative sums, we can use a difference array to handle range updates more efficiently. A difference array helps us record changes in values between consecutive elements rather than updating every element in a range directly.</p>
<p>Instead of keeping track of how many shifts should be applied to each character in the alphabet, weâ€™ll use the difference array to store how many more shifts should be applied to the current character compared to the previous one. This allows us to record changes only at the starting and ending points of shifts, rather than updating each character in the range.</p>
<p>For convenience, a positive shift means that the character must move forward in the alphabet, and a negative shift means that it must move backward.</p>
<p>!?!../Documents/2381/2381_slideshow.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the string <code>s</code>.</li>
<li>Initialize an array of length <code>n</code>, called <code>diffArray</code>, and set all its elements to <code>0</code>.</li>
<li>For every <code>shift = [start, end, direction]</code> in <code>shifts</code>:
<ul>
<li>If <code>direction == 1</code> (shift forward):
<ul>
<li>Increment <code>diffArray[start]</code> by <code>1</code>, indicating that <code>s[start]</code> is shifted forward one more time than the previous character.</li>
<li>If <code>end + 1 &lt; n</code>:
<ul>
<li>Decrement <code>diffArray[end + 1]</code> by <code>1</code>, as the character exactly after the shift range is shifted forward one time less than the previous character.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>direction == 0</code> (shift backward):
<ul>
<li>Decrement <code>diffArray[start]</code> by <code>1</code>, as <code>s[start]</code> is shifted backward one more time than the previous character.</li>
<li>If <code>end + 1 &lt; n</code>:
<ul>
<li>Increment <code>diffArray[end + 1]</code> by <code>1</code>, as the character exactly after the shift range is shifted backward one time less than the previous character.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>numberOfShifts</code> to <code>0</code>.</li>
<li>Initialize a string <code>result</code> of length <code>n</code>.</li>
<li>Iterate over <code>s</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Add <code>diffArray[i]</code> to <code>numberOfShifts</code> and take it <code>mod 26</code>.</li>
<li>If <code>numberOfShifts &lt; 0</code>, increment <code>numberOfShifts</code> by <code>26</code>.</li>
<li>Set <code>result[i]</code> to the shifted character: <code>'a' + (s[i] - 'a' + numberOfShifts) % 26</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dVLVNQj9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code> and <span class="math inline">\(m\)</span> the size of the <code>shifts</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We are iterating over the <code>shifts</code> array to find the difference between the shifts of any two consecutive characters of <code>s</code>. On each iteration, we only perform constant-time operations (accessing and updating two elements of the <code>diffArray</code>) and therefore the initialization of the <code>diffArray</code> requires <span class="math inline">\(O(m)\)</span> time. Then, we create the resulting string with a single pass over the original, which contributes <span class="math inline">\(O(n)\)</span> to the total time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We are using an array of size <code>n</code> to store the differences in the shifts between consecutive characters. We are also creating a new string <code>result</code> of length <code>n</code> to avoid modifying the input directly. These data structures have a size that is linear to the length of the input string and therefore the algorithm requires <span class="math inline">\(O(n)\)</span> extra space.</p>
</li>
</ul>
<hr />
<h5 id="further-thoughts-on-the-editorial">Further Thoughts on the Editorial:</h5>
<p>This problem can also be solved using a Fenwick Tree (also known as a Binary Indexed Tree), a data structure designed for efficiently querying the prefix sum of an array and updating its elements in logarithmic time. Using a Fenwick Tree, we can represent the difference array and handle the range update operations efficiently.</p>
<p>While this approach is more advanced and typically used in harder problems, it provides an alternative perspective on solving the same problem. If you're familiar with Fenwick Trees or want to challenge yourself, you can try implementing this solution for fun or challenge yourself with problems from this list: <a href="https://leetcode.com/problem-list/binary-indexed-tree/">Binary Indexed Tree Problems</a>!</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description" target="_blank" rel="noopener noreferrer">Shortest Subarray with Sum at Least K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the length of the shortest non-empty <strong>subarray</strong> of </em><code>nums</code><em> with a sum of at least </em><code>k</code>. If there is no such <strong>subarray</strong>, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> 1
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [1,2], k = 4
<strong>Output:</strong> -1
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [2,-1,2], k = 3
<strong>Output:</strong> 3
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>nums</code> that contains both positive and negative values, along with an integer <code>k</code>. Our goal is to find the shortest non-empty subarray whose sum is greater than or equal to <code>k</code>.</p>
<p>This problem is very similar to <a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">209. Minimum Size Subarray Sum</a> with one key difference: we have negative values here. We strongly suggest solving the original problem first, as our solution will build upon that approach.</p>
<p>The original problem was solved using a variable-length sliding window, but that approach will no longer work here. Let's take an example to understand why:</p>
<p>Consider <code>nums = [2, -1, 1, 3]</code> and <code>k = 4</code>.</p>
<p>Let's walk through a naive variable-size sliding window approach step by step:</p>
<ol>
<li>Start with window <code>[2]</code>: sum = 2 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1]</code>: sum = 1 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1, 1]</code>: sum = 2 (not <span class="math inline">\(\geq\)</span> 4)</li>
<li>Expand to <code>[2, -1, 1, 3]</code>: sum = 5 (<span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>Now, we try to minimize the window size by shrinking the window from the left.</p>
<ol>
<li>Remove the first element. Window: <code>[-1, 1, 3]</code>: sum = 3 (not <span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>The sliding window now stops because it assumes reducing the window further would only decrease the sum value. However, if it shrinks once more:</p>
<ol start="2">
<li>Remove the second element. Window: <code>[1, 3]</code>: sum = 4 (<span class="math inline">\(\geq\)</span> 4)</li>
</ol>
<p>We find that our condition is satisfied again, and we find our required answer.</p>
<p>The negative value -1 breaks the monotonic sum property that a standard sliding window relies on, making a simple variable-length sliding window approach unreliable.</p>
<hr />
<h3 id="approach-1-priority-queue">Approach 1: Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force approach would be to loop over all subarrays in <code>nums</code> and check if their sums exceed <code>k</code>. The smallest one among them is our answer. However, this approach is too slow for our constraints.</p>
<p>Let's identify the redundancies in the above approach. One major issue is that we keep recalculating the same subarray sums multiple times. We can solve this by creating a prefix sum array, which lets us quickly find the sum of any subarray. Using this array, we can look at each element and find an earlier prefix sum that, when subtracted from our current sum, gives us a value of at least k.</p>
<p>However, searching for the best prefix sum for each index is still too slow. What we really need is a way to quickly find the &quot;best&quot; prefix sum â€“ one with the lowest value that's also closest to our current position.</p>
<p>This is where a heap (also called a priority queue) becomes useful. We can store pairs of [prefix sum, ending index] in the heap, arranged so that the lowest sum is always at the top. This helps us quickly find the best previous sum to use.</p>
<p>Let's loop over the <code>nums</code> array now, keeping track of the running sum in a variable called <code>cumulativeSum</code>. We'll also keep track of our result in the variable <code>shortestSubarrayLength</code>. If the <code>cumulativeSum</code> meets our constraints, we consider it as a potential result. Otherwise, we'll loop over the top elements of the heap while the difference between <code>cumulativeSum</code> and the sum of the top element is <span class="math inline">\(\geq k\)</span>. For each such element, we check if it is the minimum length subarray we've found till now. After checking an element in the heap, it can be discarded since all further sums in the loop will result in longer subarrays (and can never be the answer). Once we've exhausted all valid previous prefix sums, we can add the current sum and the index to the heap.</p>
<p>After the loop completes, we can return <code>cumulativeSum</code> as the required shortest subarray with a sum of at least <code>k</code>.</p>
<p>The algorithm is visualized in the slideshow below:</p>
<p>!?!../Documents/862/slideshow.json:1202,962!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable:
<ul>
<li><code>n</code> to store the length of the input array.</li>
<li><code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
<li><code>cumulativeSum</code> to 0, which will maintain the running sum of elements.</li>
</ul>
</li>
<li>Initialize a min-heap <code>prefixSumHeap</code> to store pairs of cumulative sum and their corresponding indices, with pairs ordered by cumulative sum.</li>
<li>Iterate through each index <code>i</code> from 0 to <code>n-1</code>:
<ul>
<li>Add the current element to <code>cumulativeSum</code>.</li>
<li>If <code>cumulativeSum</code> is greater than or equal to <code>k</code>:
<ul>
<li>Update <code>shortestSubarrayLength</code> with the minimum of itself and <code>i + 1</code>.</li>
</ul>
</li>
<li>While the heap is not empty and the difference between the current <code>cumulativeSum</code> and heap's minimum cumulative sum is greater than or equal to <code>k</code>:
<ul>
<li>Remove the minimum element from the heap and update <code>shortestSubarrayLength</code> with the minimum of itself and (current index - removed element's index)</li>
</ul>
</li>
<li>Add current <code>cumulativeSum</code> and index as a pair to the heap.</li>
</ul>
</li>
<li>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VkJRKMc9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>For each element in <code>nums</code>, we may perform heap operations (push and poll) which take <span class="math inline">\(O(\log n)\)</span> time. In the worst case, at each index, we might need to poll multiple elements from the heap, but each element can only be pushed and popped once throughout the entire process. So, the total number of heap operations across all iterations is bounded by <span class="math inline">\(O(n)\)</span>, each taking <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for the min-heap (<code>prefixSumHeap</code>) which, in the worst case, might need to store all prefix sums and their indices. As each element in the input array corresponds to at most one entry in the heap, the space required is linear with respect to the input size.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack--binary-search">Approach 2: Monotonic Stack + Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also implement this idea of using the &quot;best&quot; prefix sum efficiently using a binary search approach. Instead of a priority queue, let's maintain a stack-like data structure to hold the prefix sums for each index as we iterate over <code>nums</code>. Each element of the stack will hold a pair [prefix sum, index] where we'll maintain the prefix sum monotonically increasing. The monotonically increasing property works because at each step, all prefix sums which are valid candidates to be used to find the shortest sub-array, have to be less than the current running sum.</p>
<p>To make this work, we start by updating the running total for each number in the array. Then, to keep our structure ordered, we remove any entries from the top that are greater than or equal to the current sum. This approach ensures that both the prefix sums and their indices stay in strict increasing order. Once we have this ordering, we can use binary search to efficiently find the rightmost entry where the sum is at least <code>current_sum - k</code>. The difference between our current position and the index we find gives us the length of a valid sub-array. By keeping track of the shortest length we find, weâ€™ll get our answer.</p>
<blockquote>
<p>Note: It's a bit unusual to perform searches within a stack, as we typically only access the top element in a true stack. So while our data structure isn't a classic stack, it behaves similarly to a monotonic stack in this case.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize:</p>
<ul>
<li>a variable <code>n</code> to store the length of the input array.</li>
<li>a list <code>cumulativeSumStack</code> to store pairs of cumulative sums and their corresponding indices, adding an initial pair (0, -1) to handle subarrays starting from index 0.</li>
<li>a variable <code>runningCumulativeSum</code> to 0 to maintain the running sum of elements.</li>
<li>a variable <code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
</ul>
</li>
<li>
<p>Iterate through each index <code>i</code> from 0 to <code>n-1</code>:</p>
<ul>
<li>Add the current element to <code>runningCumulativeSum</code></li>
<li>While the stack is not empty and the current <code>runningCumulativeSum</code> is less than or equal to the last element's cumulative sum:
<ul>
<li>Remove the last element from the stack.</li>
</ul>
</li>
<li>Add current <code>runningCumulativeSum</code> and index as a pair to the stack.</li>
<li>Find the largest index where the cumulative sum is less than or equal to (<code>runningCumulativeSum - k</code>) using binary search</li>
<li>If a valid index is found, update <code>shortestSubarrayLength</code> with the minimum of itself and (current index - found index's value)</li>
</ul>
</li>
<li>
<p>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</p>
</li>
<li>
<p>The binary search helper function:</p>
<ul>
<li>Initialize a left pointer to 0 and a right pointer to the last index.</li>
<li>While the left pointer is less than or equal to the right pointer:
<ul>
<li>Calculate the middle index.</li>
<li>If the middle element's cumulative sum is less than or equal to the target:
<ul>
<li>Move the left pointer to <code>mid</code> + 1.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Move the right pointer to <code>mid</code> - 1.</li>
</ul>
</li>
</ul>
</li>
<li>Return the right pointer as the found index.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fExu3Azx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The algorithm processes each element once in the main loop, which takes <span class="math inline">\(O(n)\)</span> time. For each element, we perform two main operations: maintaining the monotonic property of the stack and binary search. While stack maintenance operations (adding and removing elements) take amortized <span class="math inline">\(O(1)\)</span> time per element since each element can be added and removed at most once, the binary search operation takes <span class="math inline">\(O(\log n)\)</span> time for each element as we search through a list that can grow up to size <span class="math inline">\(n\)</span>.</p>
<p>Thus, the overall time complexity becomes <span class="math inline">\(O(n) + O(n \cdot \log n) = O(n \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space primarily for the <code>cumulativeSumStack</code> list, which stores pairs of cumulative sums and their indices. In the worst case, this list could store all indices if the input array is strictly increasing, leading to <span class="math inline">\(O(n)\)</span> space usage.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-deque">Approach 3: Deque</h3>
<h4 id="intuition-2">Intuition</h4>
<p>If we take a look at our previous approaches, we notice a recurring challenge: we need to find both the smallest sum and the largest index before our current position. This brings us to the questionâ€”can we use a data structure that helps us track both of these elements at the same time?</p>
<p>The answer lies in using a deque, or double-ended queue. A deque allows us to add or remove items from either end, which is perfect for our needs. In this case, our deque will hold the indices of the prefix sums that might serve as the starting point for our target subarray. We also make sure that these sums form a monotonically increasing sequence. This monotonicity is important because if we encounter an earlier prefix sum that is greater than or equal to a later one, that later index will always give us a shorter subarray with an equal or greater sum for any future ending position.</p>
<p>As we iterate through each position, we start by checking if we can find valid subarrays using the indices stored in our deque. We do this by calculating the difference between the current prefix sum and the prefix sum at the front of the deque. If this difference meets or exceeds our target sum, weâ€™ve found a valid subarray. At this point, we update our <code>shortestSubarrayLength</code> and remove that starting index from the deque, since it won't help us find a shorter subarray with any future ending positions.</p>
<p>Next, we need to maintain the monotonicity of our deque. We remove indices from the back of the deque if their prefix sums are greater than or equal to our current prefix sum. This step is crucial because any removed positions would only yield longer subarrays with the same or smaller sums, making them unnecessary for our purposes.</p>
<p>Finally, we add our current index to the back of the deque because it could potentially be the starting point of a valid subarray in the future.</p>
<p>By the time we finish iterating through the array, the variable <code>shortestSubarrayLength</code> will contain the length of the shortest subarray that meets our criteria.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a variable <code>n</code> to store the length of the input array.</li>
<li>an array <code>prefixSums</code> of size <code>n+1</code> to store cumulative sums, where <code>prefixSums[i]</code> will represent the sum of elements from index 0 to <code>i-1</code>.</li>
</ul>
</li>
<li>Calculate prefix sums by iterating from 1 to <code>n</code>:
<ul>
<li>Set <code>prefixSums[i]</code> as the sum of <code>prefixSums[i-1]</code> and <code>nums[i-1]</code></li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a deque <code>candidateIndices</code> to store indices that could form valid subarrays.</li>
<li>a variable <code>shortestSubarrayLength</code> to store the minimum length of a valid subarray, setting it to the maximum possible integer value.</li>
</ul>
</li>
<li>Iterate through each index <code>i</code> from 0 to <code>n</code>:
<ul>
<li>While the deque is not empty and the difference between <code>prefixSums[i]</code> and <code>prefixSums[first element of deque]</code> is greater than or equal to <code>targetSum</code>:
<ul>
<li>Update <code>shortestSubarrayLength</code> with the minimum of itself and (i - first element of deque).</li>
<li>Remove the first element from the deque.</li>
</ul>
</li>
<li>While deque is not empty and <code>prefixSums[i]</code> is less than or equal to <code>prefixSums[last element of deque]</code>:
<ul>
<li>Remove the last element from the deque.</li>
</ul>
</li>
<li>Add current index <code>i</code> to the end of the deque.</li>
</ul>
</li>
<li>Return -1 if <code>shortestSubarrayLength</code> remains unchanged at maximum integer value, otherwise return <code>shortestSubarrayLength</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/AnYT95ak/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm first calculates prefix sums in <span class="math inline">\(O(n)\)</span> time. Then, it processes each index exactly once in the main loop. Within this loop, each index can be added to the deque once and removed at most once from either end of the deque. Since deque operations take <span class="math inline">\(O(1)\)</span> time, the amortized time complexity for all deque operations is <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for two main data structures. First, the prefix sums array requires <span class="math inline">\(O(n+1)\)</span> space to store cumulative sums. Second, the deque of candidate indices, in the worst case, might need to store <span class="math inline">\(O(n)\)</span> indices.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n+1) + O(n) = O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-rotation-with-highest-score/description" target="_blank" rel="noopener noreferrer">Smallest Rotation with Highest Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code>. You can rotate it by a non-negative integer <code>k</code> so that the array becomes <code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]</code>. Afterward, any entries that are less than or equal to their index are worth one point.</p>

<ul>
	<li>For example, if we have <code>nums = [2,4,1,3,0]</code>, and we rotate by <code>k = 2</code>, it becomes <code>[1,3,0,2,4]</code>. This is worth <code>3</code> points because <code>1 &gt; 0</code> [no points], <code>3 &gt; 1</code> [no points], <code>0 &lt;= 2</code> [one point], <code>2 &lt;= 3</code> [one point], <code>4 &lt;= 4</code> [one point].</li>
</ul>

<p>Return <em>the rotation index </em><code>k</code><em> that corresponds to the highest score we can achieve if we rotated </em><code>nums</code><em> by it</em>. If there are multiple answers, return the smallest such index <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,1,4,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Scores for each k are listed below: 
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
So we should choose k = 3, which has the highest score.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,0,2,4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums will always have 3 points no matter how it shifts.
So we will choose the smallest k, which is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sorted-gcd-pair-queries/description" target="_blank" rel="noopener noreferrer">Sorted GCD Pair Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">counting</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an integer array <code>queries</code>.</p>

<p>Let <code>gcdPairs</code> denote an array obtained by calculating the <span data-keyword="gcd-function">GCD</span> of all possible pairs <code>(nums[i], nums[j])</code>, where <code>0 &lt;= i &lt; j &lt; n</code>, and then sorting these values in <strong>ascending</strong> order.</p>

<p>For each query <code>queries[i]</code>, you need to find the element at index <code>queries[i]</code> in <code>gcdPairs</code>.</p>

<p>Return an integer array <code>answer</code>, where <code>answer[i]</code> is the value at <code>gcdPairs[queries[i]]</code> for each query.</p>

<p>The term <code>gcd(a, b)</code> denotes the <strong>greatest common divisor</strong> of <code>a</code> and <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4], queries = [0,2,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [gcd(nums[0], nums[1]), gcd(nums[0], nums[2]), gcd(nums[1], nums[2])] = [1, 2, 1]</code>.</p>

<p>After sorting in ascending order, <code>gcdPairs = [1, 1, 2]</code>.</p>

<p>So, the answer is <code>[gcdPairs[queries[0]], gcdPairs[queries[1]], gcdPairs[queries[2]]] = [1, 2, 2]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,4,2,1], queries = [5,3,1,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,2,1,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs</code> sorted in ascending order is <code>[1, 1, 1, 2, 2, 4]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,2], queries = [0,0]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><code>gcdPairs = [2]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= queries[i] &lt; n * (n - 1) / 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/special-array-ii/description" target="_blank" rel="noopener noreferrer">Special Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An array is considered <strong>special</strong> if every pair of its adjacent elements contains two numbers with different parity.</p>

<p>You are given an array of integer <code>nums</code> and a 2D integer matrix <code>queries</code>, where for <code>queries[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> your task is to check that <span data-keyword="subarray">subarray</span> <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> is <strong>special</strong> or not.</p>

<p>Return an array of booleans <code>answer</code> such that <code>answer[i]</code> is <code>true</code> if <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> is special.<!-- notionvc: e5d6f4e2-d20a-4fbd-9c7f-22fbe52ef730 --></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,4,1,2,6], queries = [[0,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false]</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray is <code>[3,4,1,2,6]</code>. 2 and 6 are both even.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,1,6], queries = [[0,2],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[false,true]</span></p>

<p><strong>Explanation:</strong></p>

<ol>
	<li>The subarray is <code>[4,3,1]</code>. 3 and 1 are both odd. So the answer to this query is <code>false</code>.</li>
	<li>The subarray is <code>[1,6]</code>. There is only one pair: <code>(1,6)</code> and it contains numbers with different parity. So the answer to this query is <code>true</code>.</li>
</ol>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= nums.length - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers <code>nums</code> and a 2D array of queries <code>queries</code>, where each query <code>queries[i] = [from, to]</code> refers to the subarray <code>nums[from ... to]</code>. Our task is to determine if each subarray <code>nums[from ... to]</code> is special. A subarray is considered special if every pair of adjacent elements has different parity â€” that is, the subarray alternates between even and odd elements.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute force solution would involve traversing the entire subarray for each query <code>queries[i]</code> and checking if its elements alternate between even and odd parity. However, this approach is inefficient because traversing all subarrays will be very time-consuming, especially if there are many queries or if the subarrays are large. Also, there would be much repeated work if the queries overlap.</p>
<p>Instead, we can perform some precomputations to solve each query faster. If we perform an initial traversal of <code>nums</code>, we can easily identify the indices of elements that break or violate the special array property. Specifically, we can find the indices of elements <code>nums[i]</code> that have the same parity (even or odd) as its previous element: If <code>nums[i] % 2 == nums[i-1] % 2</code> is true, then <code>nums[i]</code> is a violating element.</p>
<p>After finding these violating indices, we know that any subarray containing any of these indices is not a special array. Conversely, if a subarray contains no violating indices, then it is a special array.</p>
<p>The problem now is to find an efficient way to check if each subarray defined by <code>queries[i] = [start, end]</code> contains any violating indices. Since we can perform our initial traversal of <code>nums</code> from left to right, the violating indices are naturally sorted in ascending order. Because they are sorted, we can perform <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a> on the violating indices to see if any violating indices fall between the range <code>[start + 1, end]</code>. Note that we start our search at <code>start + 1</code> instead of <code>start</code> because the violating indices are defined relative to the element to their left. Therefore, the first element of our subarray (at index <code>start</code>) is never a violating element, and our search should begin at <code>start + 1</code>.</p>
<p>It is also worth noting that there is usually a single target value we would like to find for traditional binary search problems. However, for this problem, we have a target range of <code>[start + 1, end]</code> instead.</p>
<p>Thus, our precomputation allows us to more efficiently evaluate each subarray, leading to an <span class="math inline">\(O(\logn)\)</span> binary search time for each query rather than a <span class="math inline">\(O(n)\)</span> brute force traversal.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a new boolean <code>ans</code> array to hold our answers for all queries.</li>
<li>Create a new list <code>violatingIndices</code> to store all the indices that violate the special array condition in <code>nums</code>.</li>
<li>Iterate through <code>nums</code> and add all the violating indices found to <code>violatingIndices</code>.</li>
<li>Traverse through <code>queries</code> to answer each <code>queries[i]</code>:
<ul>
<li>Initialize variable <code>start</code> to <code>queries[i][0]</code>.</li>
<li>Initialize variable <code>end</code> to <code>queries[i][1]</code>.</li>
<li>Call helper function <code>binarySearch(start + 1, end, violatingIndices)</code> to search through <code>violatingIndices</code> to see if it contains any indices that fall between <code>start</code> and <code>end</code>. Save result to variable <code>foundViolatingIndex</code>.</li>
<li>If <code>foundViolatingIndex == true</code>, then we know the answer to the current query is false. Otherwise, the answer is true..</li>
<li>Save answer in <code>ans[i]</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
<li>Define helper function <code>binarySearch(start, end, violatingIndices)</code>:
<ul>
<li>We initialize our search space to the entire list of violating indices: <code>left = 0</code> and <code>right = violatingIndices.size() - 1</code></li>
<li>While <code>left &lt;= right</code>:
<ul>
<li>Calculate the midpoint: <code>mid = (left + right) / 2</code>.</li>
<li>Access the violating index at that index: <code>violatingIndex = violatingIndices.get(mid)</code>.</li>
<li>If <code>violatingIndex &lt; start</code>, then we want to look at the right half of our search space, so update <code>left = mid + 1</code>.</li>
<li>If <code>violatingIndex &gt; end</code>, then we want to look at the left half of our search space, so update <code>right = mid - 1</code>.</li>
<li>Otherwise, our violating index falls in between <code>start</code> and <code>end</code>, meaning we found one in the subarray. Thus, we return <code>true</code>.</li>
</ul>
</li>
<li>If we reach this point, then we couldn't find any violating indices in the subarray. We return <code>false</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4xjpYCrJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N \cdot \log M)\)</span></p>
<p>Our initial traversal of <code>nums</code> takes <span class="math inline">\(O(M)\)</span> time. Then, the binary search for each query will take <span class="math inline">\(O(\log M)\)</span>. For all <span class="math inline">\(N\)</span> queries, the total time for all searches is <span class="math inline">\(O(N \cdot \log M)\)</span>. Thus, the total time complexity is <span class="math inline">\(O(M + N \cdot \log M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We store the violating indices of <code>nums</code>, which will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sum">Approach 2: Prefix Sum</h3>
<h4 id="intuition-1">Intuition</h4>
<p>For Approach 1, our precomputation involved finding all the violative indices of <code>nums</code>. This allowed us to evaluate each query in logarithmic time.</p>
<p>We will now consider a different precomputation method. We will find the total number of violative indices up to index <code>i</code> in <code>nums</code> for all indices <code>i</code>. In other words, we can create a prefix sum array where <code>prefix[i]</code> contains the total number of violative indices considering <code>nums[0...i]</code>. This can easily be done in linear time by iterating through <code>nums</code> and checking if each element <code>nums[i]</code> has the same parity as the previous element. If it does, then we have found a new violating index <code>i</code>, and our total number of violative indices increases by 1 (<code>prefix[i] = prefix[i - 1] + 1</code>). If it doesn't, then <code>i</code> is not a violating index and we keep our number of violative indices the same as before: <code>prefix[i] = prefix[i - 1]</code></p>
<p>This prefix sum array is convenient because it now allows us to evaluate each query in constant time. Given any query <code>queries[i] = [start, end]</code>, we know that there are no violating indices found in the subarray between indices <code>start</code> and <code>end</code> if <code>prefix[end] - prefix[start] == 0</code>. If this condition is true, then the subarray is considered special. Otherwise, it is not special.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a new boolean <code>ans</code> array to hold our answers for all queries</li>
<li>Initialize a <code>prefix</code> array to contain the prefix sum of the total number of violative indices.</li>
<li>Initialize <code>prefix[0] = 0</code>.</li>
<li>Iterate through <code>nums</code> from <code>i = 1</code> to <code>i = nums.length - 1</code>:
<ul>
<li>If <code>nums[i] % 2 == nums[i - 1] % 2</code> then <code>i</code> is a new violative index, and we can increase the total number by 1: <code>prefix[i] = prefix[i-1] + 1</code></li>
<li>Otherwise, the total stays the same: <code>prefix[i] = prefix[i-1]</code>.</li>
</ul>
</li>
<li>Traverse through <code>queries</code> to answer each <code>queries[i]</code>:
<ul>
<li>Let <code>start = queries[i][0]</code>.</li>
<li>Let <code>end = queries[i][1]</code>.</li>
<li>Fill in <code>ans[i]</code> with <code>prefix[end] - prefix[start] == 0</code>, evaluating if there are no violating indices in the subarray.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/i9Wih4uH/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>Our initial traversal of <code>nums</code> to initialize <code>prefix</code> takes <span class="math inline">\(O(M)\)</span> time. Then, answering each query will took constant time. For all <span class="math inline">\(N\)</span> queries, that will take a total of <span class="math inline">\(O(N)\)</span> time. Thus, the total time complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We maintain a prefix sum array for <code>nums</code>, which will take <span class="math inline">\(O(M)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sliding-window">Approach 3: Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To make the process more fluent, we need a way to precompute information that can help us answer each query in constant time. The key idea is that for any index <code>start</code>, the farthest index we can reach while maintaining alternating parity is independent of the queries themselves. Thus, we can calculate this information beforehand.</p>
<p>We define an array <code>maxReach</code>, where <code>maxReach[start]</code> represents the farthest index that can be reached from <code>start</code> while adhering to the parity condition. To compute this, we iterate through the array and use a pointer <code>end</code> to expand the range as far as possible. Starting with <code>end = start</code>, we increment <code>end</code> as long as the parity of adjacent elements (<code>nums[end]</code> and <code>nums[end + 1]</code>) differs. Once this process is complete for a given <code>start</code>, we know that any range <code>[start, end']</code> with <code>end' &lt;= maxReach[start]</code> satisfies the parity condition.</p>
<p>With this precomputed information, answering queries becomes straightforward. For each query <code>[start, end]</code>, we simply check whether <code>end</code> is within the range of <code>maxReach[start]</code>. If it is, the subarray satisfies the condition; otherwise, it does not.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of the array <code>nums</code> and create a array <code>maxReach</code> of size <code>n</code> to store the maximum reachable index for each starting index.</p>
</li>
<li>
<p>Initialize the last element of <code>maxReach</code>:</p>
<ul>
<li>Set <code>maxReach[n-1]</code> to <code>n-1</code> because the last index can only reach itself.</li>
</ul>
</li>
<li>
<p>Iterate over the array <code>nums</code> from the second-to-last index to the first:</p>
<ul>
<li>If the parity (odd/even) of <code>nums[i]</code> is different from <code>nums[i+1]</code>:
<ul>
<li>Set <code>maxReach[i]</code> to <code>maxReach[i+1]</code> to extend the reachable range.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Set <code>maxReach[i]</code> to <code>i</code>, as it can only reach itself.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Create a array <code>ans</code> of size equal to the number of queries to store the results.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Extract <code>start</code> and <code>end</code> from the query.</li>
<li>Check if the range <code>[start, end]</code> lies within the maximum reachable range stored in <code>maxReach[start]</code>.</li>
<li>Store <code>true</code> if <code>end &lt;= maxReach[start]</code>, otherwise store <code>false</code>.</li>
</ul>
</li>
<li>
<p>Return the array <code>ans</code>, which contains the results for all queries.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/5FwEX5pA/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(M\)</span> be the size of <code>nums</code> and <span class="math inline">\(N\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>First, we go through the <code>nums</code> array to create the <code>maxReach</code> array. This process takes <span class="math inline">\(O(M)\)</span> time.</p>
<p>Next, for each query, we can quickly find the answer using the <code>maxReach</code> array. Since each query is answered in constant time, answering all <span class="math inline">\(N\)</span> queries will take <span class="math inline">\(O(N)\)</span> time.</p>
<p>Combining these two steps, the total time complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We use an array called <code>maxReach</code> to store the maximum reach for each position in the <code>nums</code> array. This array takes up <span class="math inline">\(O(M)\)</span> space.</p>
<p>The <code>ans</code> array, which stores the results for each query, is not included in the space complexity calculation because it is considered part of the output. Therefore, the overall space complexity is <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-array-largest-sum/description" target="_blank" rel="noopener noreferrer">Split Array Largest Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, split <code>nums</code> into <code>k</code> non-empty subarrays such that the largest sum of any subarray is <strong>minimized</strong>.</p>

<p>Return <em>the minimized largest sum of the split</em>.</p>

<p>A <strong>subarray</strong> is a contiguous part of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,2,5,10,8], k = 2
<strong>Output:</strong> 18
<strong>Explanation:</strong> There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], k = 2
<strong>Output:</strong> 9
<strong>Explanation:</strong> There are four ways to split nums into two subarrays.
The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(50, nums.length)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stamping-the-grid/description" target="_blank" rel="noopener noreferrer">Stamping the Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (occupied).</p>

<p>You are then given stamps of size <code>stampHeight x stampWidth</code>. We want to fit the stamps such that they follow the given <strong>restrictions</strong> and <strong>requirements</strong>:</p>

<ol>
	<li>Cover all the <strong>empty</strong> cells.</li>
	<li>Do not cover any of the <strong>occupied</strong> cells.</li>
	<li>We can put as <strong>many</strong> stamps as we want.</li>
	<li>Stamps can <strong>overlap</strong> with each other.</li>
	<li>Stamps are not allowed to be <strong>rotated</strong>.</li>
	<li>Stamps must stay completely <strong>inside</strong> the grid.</li>
</ol>

<p>Return <code>true</code> <em>if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return</em> <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex1.png" style="width: 180px; height: 237px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
<strong>Output:</strong> true
<strong>Explanation:</strong> We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex2.png" style="width: 170px; height: 179px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
<strong>Output:</strong> false 
<strong>Explanation:</strong> There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[r].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>grid[r][c]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stone-game-ii/description" target="_blank" rel="noopener noreferrer">Stone Game II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob continue their games with piles of stones. There are a number of piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>. The objective of the game is to end with the most stones.</p>

<p>Alice and Bob take turns, with Alice starting first.</p>

<p>On each player&#39;s turn, that player can take <strong>all the stones</strong> in the <strong>first</strong> <code>X</code> remaining piles, where <code>1 &lt;= X &lt;= 2M</code>. Then, we set <code>M = max(M, X)</code>. Initially, M = 1.</p>

<p>The game continues until all the stones have been taken.</p>

<p>Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">piles = [2,7,9,4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">10</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get <code>2 + 4 + 4 = 10</code> stones in total.</li>
	<li>If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get <code>2 + 7 = 9</code> stones in total.</li>
</ul>

<p>So we return 10 since it&#39;s larger.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">piles = [1,2,3,4,5,100]</span></p>

<p><strong>Output:</strong> <span class="example-io">104</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= piles.length &lt;= 100</code></li>
	<li><code>1 &lt;= piles[i]&nbsp;&lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stone-game-viii/description" target="_blank" rel="noopener noreferrer">Stone Game VIII</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob take turns playing a game, with <strong>Alice starting first</strong>.</p>

<p>There are <code>n</code> stones arranged in a row. On each player&#39;s turn, while the number of stones is <strong>more than one</strong>, they will do the following:</p>

<ol>
	<li>Choose an integer <code>x &gt; 1</code>, and <strong>remove</strong> the leftmost <code>x</code> stones from the row.</li>
	<li>Add the <strong>sum</strong> of the <strong>removed</strong> stones&#39; values to the player&#39;s score.</li>
	<li>Place a <strong>new stone</strong>, whose value is equal to that sum, on the left side of the row.</li>
</ol>

<p>The game stops when <strong>only</strong> <strong>one</strong> stone is left in the row.</p>

<p>The <strong>score difference</strong> between Alice and Bob is <code>(Alice&#39;s score - Bob&#39;s score)</code>. Alice&#39;s goal is to <strong>maximize</strong> the score difference, and Bob&#39;s goal is the <strong>minimize</strong> the score difference.</p>

<p>Given an integer array <code>stones</code> of length <code>n</code> where <code>stones[i]</code> represents the value of the <code>i<sup>th</sup></code> stone <strong>from the left</strong>, return <em>the <strong>score difference</strong> between Alice and Bob if they both play <strong>optimally</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stones = [-1,2,-3,4,-5]
<strong>Output:</strong> 5
<strong>Explanation:</strong>
- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of
  value 2 on the left. stones = [2,-5].
- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on
  the left. stones = [-3].
The difference between their scores is 2 - (-3) = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stones = [7,-6,5,10,5,-2,-6]
<strong>Output:</strong> 13
<strong>Explanation:</strong>
- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a
  stone of value 13 on the left. stones = [13].
The difference between their scores is 13 - 0 = 13.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> stones = [-10,-12]
<strong>Output:</strong> -22
<strong>Explanation:</strong>
- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her
  score and places a stone of value -22 on the left. stones = [-22].
The difference between their scores is (-22) - 0 = -22.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stones.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-product-less-than-k/description" target="_blank" rel="noopener noreferrer">Subarray Product Less Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than </em><code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [10,5,2,6], k = 100
<strong>Output:</strong> 8
<strong>Explanation:</strong> The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], k = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of integers <code>nums</code> and an integer <code>k</code>; the task is to count the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than <code>k</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The problem requires counting valid subarrays, not returning the actual subarrays.</li>
<li>The values in the <code>nums</code> array are positive.</li>
</ol>
<hr />
<h3 id="approach-1-using-sliding-window">Approach 1: Using Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force method involves finding all the subarrays and then selecting those whose products are less than <code>k</code>. However, this approach becomes costly in terms of time complexity, reaching <span class="math inline">\(O(n^2)\)</span>.</p>
<p>For a more efficient approach, let's use the sliding window pattern. This pattern is applicable when the problem entails achieving a goal using subarrays, and individual elements cannot be independently selected.</p>
<p>The concept behind the sliding window pattern is to maintain a window that continuously expands from the right by adding elements and computing their product until the condition is met. Once the condition is satisfied, we adjust the window by shrinking it from the left until the condition is met again.</p>
<p>As we slide the window across the array, our objective is to identify all subarrays in the <code>nums</code> array where the product of its elements remains less than <code>k</code>. For each right position, if the product of the window's elements from left to right is less than <code>k</code>, adding the element at the right generates new subarrays with products less than <code>k</code>.</p>
<p>The count of such subarrays is determined by the difference <code>right - left + 1</code>, which represents the number of subarrays that end at <code>right</code> and start at any element between <code>right</code> and <code>left</code>, inclusive. In essence, this count encompasses the subarray consisting solely of the current element itself, as well as all possible subarrays extending back to the left boundary of the window (<code>left</code>).</p>
<p>Consider an example window containing elements 3, 4, and 5. If we include 6 in the window, we need to count all possible subarrays that end with 6. These subarrays can be formed by starting at any element within the current window and extending to 6. Therefore, the subarrays would be:</p>
<ul>
<li><code>[6]</code> (subarray consisting only of 6)</li>
<li><code>[5, 6]</code> (subarray starting from 5 and ending at 6)</li>
<li><code>[4, 5, 6]</code> (subarray starting from 4 and ending at 6)</li>
<li><code>[3, 4, 5, 6]</code> (subarray starting from 3 and ending at 6)</li>
</ul>
<p>By calculating <code>right - left + 1</code>, we enumerate all subarrays that end with the current element of the window (<code>nums[right]</code>). This ensures that we count all possible subarrays as we slide the window across the array. As we can observe, adding element 6 to the window created 4 new subarrays.</p>
<p>The crucial insight is that once the product becomes less than <code>k</code>, all possible subarrays formed by selecting subsets of elements within the current window (from left to right) will also have a product strictly less than <code>k</code>.</p>
<p>Hence, whenever the product is valid, we add the current window size (<code>right - left + 1</code>) to the total count of subarrays.</p>
<p>The following slideshow provides a clearer insight into the underlying approach:</p>
<p>!?!../Documents/713/713_Sliding_Window.json:1020,500!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Check if <code>k</code> is less than or equal to 1. In this case, no subarrays can have a product less than <code>k</code>, so return 0.</li>
<li>Initialize the variables <code>totalCount</code> to 0, to store the final count of subarrays with a product less than <code>k</code>, and <code>product</code> to 1, representing the product of elements within the window (initially empty).</li>
<li>Use two pointers, <code>left</code> and <code>right</code>, to define the sliding window. Iterate through the <code>nums</code> array using a for loop until <code>right</code> reaches the end.
<ul>
<li>Inside the loop, multiply the current <code>product</code> by the element at the right pointer (<code>nums[right]</code>). This effectively includes the new element in the window.</li>
<li>While the current <code>product</code> is greater than or equal to <code>k</code>, the window needs to shrink to exclude elements that make the product exceed or equal to <code>k</code>.
<ul>
<li>Divide the <code>product</code> by the element at the left pointer (<code>nums[left]</code>).</li>
<li>Increment <code>left</code> by 1 to move the window one position to the right, effectively excluding the leftmost element.</li>
</ul>
</li>
<li>Update the <code>totalCount</code> by adding the number of valid subarrays with the current window size, which is <code>right - left + 1</code>.</li>
</ul>
</li>
<li>Return the <code>totalCount</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3bqwMaz3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the input array <code>nums</code> using a single for loop. Inside the loop, there are nested operations for shrinking the window, but since <code>left</code> is incremented a total number of <code>n</code> times during the whole array traversal, each element in the array is visited at most twice.</p>
<p>The nested loop terminates when the product becomes less than <code>k</code>, and this can only happen at most <code>n</code> times total (once for each element). Therefore, the overall time complexity is <span class="math inline">\(2n\)</span>, which we describe as <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space for variables like <code>totalCount</code>, <code>product</code>, <code>left</code>, and <code>right</code>. These variables do not depend on the size of the input array. Therefore, the space complexity is considered constant, denoted as <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<blockquote>
<p><strong>Note:</strong> The below approach is generally not anticipated in an interview setting, as many individuals might not be familiar with logarithmic functions, having either forgotten them or not utilized them extensively. So, it's tough for them to come up with this idea on the spot. Moreover, the sliding window approach remains the optimal solution to this problem.</p>
</blockquote>
<h3 id="approach-2-using-binary-search">Approach 2: Using Binary Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p><a href="https://en.wikipedia.org/wiki/Logarithm">Logarithms</a> have the property that the sum of logarithms is exactly equal to the logarithm of the product: <span class="math inline">\(\log(a) + \log(b) = \log(ab)\)</span>. This property allows us to convert the product of elements in a subarray into the sum of the logarithms of those elements.</p>
<p>The motivation for this is that the product of some arbitrary subarray may be way too large (potentially <span class="math inline">\(1000^{50000}\)</span>).</p>
<p>Integer overflow occurs when the result of an arithmetic operation exceeds the maximum value represented by the data type. This can happen when computing the product of elements in a large subarray, as the result can quickly surpass the integer's capacity, leading to incorrect values due to overflow.</p>
<p>To mitigate this, we can convert the product operation into a summation of logarithms. Logarithms allow the representation of large values within a manageable range, minimizing the risk of overflow while maintaining accuracy.</p>
<p>The first step is to transform the problem from finding products to finding sums. This is done by taking the natural logarithm (log) of each element in the array.</p>
<p>Then a prefix sum array (<code>logsPrefixSum</code>) is calculated, where each element is the sum of the logarithms of all elements up to that point in the original array. This will allow us to quickly determine if a subarray's sum of logarithms is less than a certain value. Because the prefix sum is a monotonically increasing array, we can use binary search to find valid subarrays.</p>
<p>For each element in the array, a binary search is performed to find the number of subarrays starting from that element whose sum of logarithms is less than the sum of the logarithms of the current element and <code>log(K)</code>. This is done by comparing the midpoint of the search space with the sum of the logarithms of the current element and <code>log(K)</code>. If the midpoint is too high, the search space is narrowed to the left; otherwise, it's narrowed to the right. The number of subarrays found is added to the total count.</p>
<p>Logarithmic comparisons have an issue due to the finite precision in floating-point number representation. That is, logarithmic functions can lead to very small differences between numbers that should be equal, especially when dealing with large or small values.</p>
<p>The product rule is <span class="math inline">\(\log(a \cdot b) == \log(a) + \log(b)\)</span>, but these expressions may not be evaluated as equivalent due to floating-point representation in the computer. It may be <span class="math inline">\(\log(a \cdot b) > \log(a) + \log(b)\)</span> or <span class="math inline">\(\log(a \cdot b) < \log(a) + \log(b)\)</span> . When we transform <code>x</code> to <code>log(x)</code>, we introduce a possible bug.</p>
<p>To prevent this from causing an issue, we subtract <code>1e-9</code> (which is a very small number, 0.000000001), in the comparison condition as a precautionary measure to handle potential precision issues that might arise due to the nature of logarithmic values. This helps mitigate the effect of these precision errors by providing a small buffer or tolerance in the comparison. Even though logarithmic values tend to spread out differences across a wider range, there can still be cases where very close values need to be distinguished, and small discrepancies can occur due to finite precision.</p>
<p>In essence, it ensures that if <code>logsPrefixSum[mid]</code> is very close to <code>logsPrefixSum[i] + logK</code>, the former will still be considered less than the latter rather than failing the condition due to slight numerical discrepancies.</p>
<p>This kind of adjustment is common in numerical math computations where precision matters, especially in conditional algorithms where small discrepancies could lead to incorrect results or sometimes infinite loops.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Check if <code>k</code> (target product) is 0. If true, return 0 (no subarrays possible).</li>
<li>Calculate the logarithm of <code>k</code> and store it in <code>logK</code>.</li>
<li>Create a vector <code>logsPrefixSum</code> of size <code>nums.size() + 1</code> to store the prefix sum of logarithms of elements in <code>nums</code>.</li>
<li>Calculate the prefix sum by iterating over <code>nums</code> and adding the logarithm of each element to the previous prefix sum. This creates a running sum of logarithms for efficient product calculation later.</li>
<li>Initialize <code>totalCount</code> to 0, which will keep track of the total number of subarrays with a product less than <code>k</code>.</li>
<li>Iterate through <code>logsPrefixSum</code> using a loop with index <code>currIdx</code>. This loop considers each element (<code>nums[currIdx]</code>) as the starting point of a potential subarray.
<ul>
<li>Inside the loop, initialize two variables, <code>low</code> and <code>high</code>, to <code>currIdx + 1</code> and <code>m (nums.size() + 1)</code>, respectively.</li>
<li>Enter a binary search loop to find the first element in <code>logsPrefixSum</code> where the subarray product (based on logarithms) exceeds <code>k</code>.
<ul>
<li>Calculate the middle index <code>mid</code> between <code>low</code> and <code>high</code>.</li>
<li>Compare the prefix sum at <code>mid</code> with the target prefix sum (<code>logsPrefixSum[currIdx] + logK</code>). Here, a small tolerance (<code>-1e-9</code>) is used to handle floating-point precision issues.</li>
<li>If the prefix sum at <code>mid</code> is less than the target, it means the subarray product ending at <code>mid</code> might still be less than <code>k</code>.
<ul>
<li>Move <code>low</code> to <code>mid + 1</code> to search in the right half of the remaining subarray.</li>
</ul>
</li>
<li>Otherwise, the subarray product ending at <code>mid</code> or elements beyond <code>mid</code> might exceed <code>k</code>.
<ul>
<li>Move <code>high</code> to <code>mid</code> to continue searching in the left half for the first exceeding element.</li>
</ul>
</li>
</ul>
</li>
<li>After the binary search loop, the <code>low</code> index points to the first element in <code>logsPrefixSum</code> where the subarray product (based on logarithms) exceeds <code>k</code>. Increment <code>totalCount</code> by the number of elements between <code>currIdx</code> (inclusive) and <code>low</code> (exclusive). This represents the number of valid subarrays ending at <code>currIdx</code> with a product less than <code>k</code>.</li>
</ul>
</li>
<li>Finally, return <code>totalCount</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ja6nxkvo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the length of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log(n))\)</span></p>
<p>The time complexity of the overall algorithm is <span class="math inline">\(O(n \cdot \log(n))\)</span> due to the binary search performed in each iteration of the outer loop.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the list <code>logsPrefixSum</code>, storing logarithmic prefix sums of <code>nums</code>, whose length equals that of <code>nums</code>.</p>
</li>
</ul>
<hr />
<details>
<summary><b>Click Here for Discussion on the Tradeoffs of the Approaches</b></summary>
<ul>
<li>
<p>The sliding window approach is efficient for finding subarrays with a product less than a given value, but it relies on the fact that the integers in the array are positive. This is because when multiplying positive integers, the product will always be positive, and the product of any number of positive integers will also be positive.</p>
</li>
<li>
<p>On the other hand, the binary search approach is more versatile and can handle arrays containing both positive and negative integers with some modifications. This is because it operates on the logarithms of the elements rather than the elements themselves.</p>
</li>
<li>
<p>After transforming the elements into their logarithmic values, the algorithm compares these values to determine the subarrays with a product less than <code>k</code>. However, direct logarithmic values of negative numbers are not defined in the real number scale. Therefore, to handle negative numbers, appropriate shifting of the elements may be necessary to ensure that the logarithmic values used in the algorithm are valid and meaningful.</p>
</li>
</ul>
</details></div>
				</div>
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-sum-equals-k/description" target="_blank" rel="noopener noreferrer">Subarray Sum Equals K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of subarrays whose sum equals to</em> <code>k</code>.</p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,1,1], k = 2
<strong>Output:</strong> 2
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,3], k = 3
<strong>Output:</strong> 2
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>The simplest method is to consider every possible subarray of the given <span class="math inline">\(nums\)</span> array, find the sum of the elements of each of those subarrays and check for the equality of the sum obtained with the given <span class="math inline">\(k\)</span>. Whenever the sum equals <span class="math inline">\(k\)</span>, we can increment the <span class="math inline">\(count\)</span> used to store the required result.</p>
<p><a href="https://leetcode.com/playground/uzdLhWrz/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Considering every possible subarray takes <span class="math inline">\(O(n^2)\)</span> time. For each of the subarray we calculate the sum taking <span class="math inline">\(O(n)\)</span> time in the worst case, taking a total of <span class="math inline">\(O(n^3)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant space is used.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-using-cumulative-sum">Approach 2: Using Cumulative Sum</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of determining the sum of elements every time for every new subarray considered, we can make use of a cumulative sum array , <span class="math inline">\(sum\)</span>. Then, in order to calculate the sum of elements lying between two indices, we can subtract the cumulative sum corresponding to the two indices to obtain the sum directly, instead of iterating over the subarray to obtain the sum.</p>
<p>In this implementation, we make use of a cumulative sum array, <span class="math inline">\(sum\)</span>, such that <span class="math inline">\(sum[i]\)</span> is used to store the cumulative sum of <span class="math inline">\(nums\)</span> array up to the element corresponding to the <span class="math inline">\((i-1)^{th}\)</span> index. Thus, to determine the sum of elements for the subarray <span class="math inline">\(nums[i:j]\)</span>, we can directly use <span class="math inline">\(sum[j+1] - sum[i]\)</span>.</p>
<p><a href="https://leetcode.com/playground/YnknRnC6/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Considering every possible subarray takes <span class="math inline">\(O(n^2)\)</span> time. Finding out the sum of any subarray takes <span class="math inline">\(O(1)\)</span> time after the initial processing of <span class="math inline">\(O(n)\)</span> for creating the cumulative sum array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. Cumulative sum array <span class="math inline">\(sum\)</span> of size <span class="math inline">\(n+1\)</span> is used.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-without-space">Approach 3: Without Space</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of considering all the <span class="math inline">\(start\)</span> and <span class="math inline">\(end\)</span> points and then finding the sum for each subarray corresponding to those points, we can directly find the sum on the go while considering different <span class="math inline">\(end\)</span> points. i.e. We can choose a particular <span class="math inline">\(start\)</span> point and while iterating over the <span class="math inline">\(end\)</span> points, we can add the element corresponding to the <span class="math inline">\(end\)</span> point to the sum formed till now. Whenever the <span class="math inline">\(sum\)</span> equals the required <span class="math inline">\(k\)</span> value, we can update the <span class="math inline">\(count\)</span> value. We do so while iterating over all the <span class="math inline">\(end\)</span> indices possible for every <span class="math inline">\(start\)</span> index. Whenever, we update the <span class="math inline">\(start\)</span> index, we need to reset the <span class="math inline">\(sum\)</span> value to 0.</p>
<p><a href="https://leetcode.com/playground/MGuUEEUy/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. We need to consider every subarray possible.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant space is used.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-using-hashmap">Approach 4: Using Hashmap</h3>
<p><strong>Algorithm</strong></p>
<p>The idea behind this approach is as follows: If the cumulative sum(represented by <span class="math inline">\(sum[i]\)</span> for sum up to <span class="math inline">\(i^{th}\)</span> index) up to two indices is the same, the sum of the elements lying in between those indices is zero. Extending the same thought further, if the cumulative sum up to two indices, say <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is at a difference of <span class="math inline">\(k\)</span> i.e. if <span class="math inline">\(sum[i] - sum[j] = k\)</span>, the sum of elements lying between indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is <span class="math inline">\(k\)</span>.</p>
<p>Based on these thoughts, we make use of a hashmap <span class="math inline">\(map\)</span> which is used to store the cumulative sum up to all the indices possible along with the number of times the same sum occurs. We store the data in the form: <span class="math inline">\((sum_i, no. of occurrences of sum_i)\)</span>. We traverse over the array <span class="math inline">\(nums\)</span> and keep on finding the cumulative sum. Every time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. If the same sum occurs again, we increment the count corresponding to that sum in the hashmap. Further, for every sum encountered, we also determine the number of times the sum <span class="math inline">\(sum-k\)</span> has occurred already, since it will determine the number of times a subarray with sum <span class="math inline">\(k\)</span> has occurred up to the current index. We increment the <span class="math inline">\(count\)</span> by the same amount.</p>
<p>After the complete array has been traversed, the <span class="math inline">\(count\)</span> gives the required result.</p>
<p>The animation below depicts the process.</p>
<p>!?!../Documents/560_Subarray.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/S6xciAtN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. The entire <span class="math inline">\(nums\)</span> array is traversed only once.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. Hashmap <span class="math inline">\(map\)</span> can contain up to <span class="math inline">\(n\)</span> distinct entries in the worst case.</p>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-sums-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Subarray Sums Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of non-empty <strong>subarrays</strong> that have a sum divisible by </em><code>k</code>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,0,-2,-3,1], k = 5
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5], k = 9
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem presents an integer array <code>nums</code> and an integer <code>k</code>. Our task is to find the number of non-empty subarrays that have a sum divisible by <code>k</code>.</p>
<hr />
<h3 id="approach-prefix-sums-and-counting">Approach: Prefix Sums and Counting</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem is based on the concept of using prefix sums to compute the total number of subarrays that are divisible by <code>k</code>. A prefix sum array for <code>nums</code> is another array <code>prefixSum</code> of the same size as <code>nums</code>, such that the value of <code>prefixSum[i]</code> is the sum of all elements of the <code>nums</code> array from index <code>0</code> to index <code>i</code>, i.e., <code>nums[0] + nums[1] + nums[2] + . . . + nums[i]</code>.</p>
<p>The sum of the subarray <code>i + 1</code> to <code>j</code> (inclusive) is computed by <code>prefixSum[j] - prefixSum[i]</code>. Using this, we can count the number of pairs that exist for every pair <code>(i, j)</code> where <code>i &lt; j</code> and <code>(prefixSum[j] - prefix[i]) % k = 0</code>. There are <code>n * (n - 1) / 2</code> pairs for an array of length <code>n</code> (pick any two from <code>n</code>). As a result, while this will provide the correct answer for every test case, it will take <span class="math inline">\(O(n^2)\)</span> time, indicating that the time limit has been exceeded (TLE).</p>
<blockquote>
<p>The character <code>%</code> is the modulo operator.</p>
</blockquote>
<p>Let's try to use the information with respect to the remainders of every prefix sum and try to optimize the above approach.</p>
<p>As stated previously, our task is to determine the number of pairs <code>(i, j)</code> where <code>i &lt; j</code> and <code>(prefixSum[j] - prefix[i]) % k = 0</code>. This equality can only be true if <code>prefixSum[i] % k = prefixSum[j] % k</code>. We will demonstrate this property.</p>
<p>We can express any <code>number</code> as <code>number = divisor Ã— quotient + remainder</code>. For example, <code>13</code> when divided by <code>3</code> can be written as <code>13 = 3 * 4 + 1</code>. So we can express:<br />
a) <code>prefixSum[i]</code> as <code>prefixSum[i] = A * k + R0</code> where <code>A</code> is the quotient and <code>R0</code> is the remainder when divided by <code>k</code>.<br />
b) Similarly, <code>prefixSum[j] = B * k + R1</code> where <code>B</code> is the quotient and <code>R1</code> is the remainder when divided by <code>k</code>.</p>
<p>We can write, <code>prefixSum[j] - prefixSum[i] = k * (B - A) + (R1 - R0)</code>. The first term (<code>k * (B - A)</code>) is divisible by <code>k</code>, so for the entire expression to be divisible by <code>k</code>, <code>R1 - R0</code> must also be divisible by <code>k</code>. This gives us an equation <code>R1 - R0 = C * k</code>, where C is some integer. Rearranging it yields <code>R1 = C * k + R0</code>. Because the values of <code>R0</code> and <code>R1</code> will be between <code>0</code> and <code>k - 1</code>, <code>R1</code> cannot be greater than <code>k</code>. So the only possible value for <code>C</code> is <code>0</code>, leading to <code>R0 = R1</code>, which proves the above property. If <code>C &gt; 0</code>, then the RHS would be at least <code>k</code>, but as stated the LHS (<code>R1</code>) is between <code>0</code> and <code>k - 1</code>.</p>
<p>Here are two visual examples showing the calculations:</p>
<p><img src="../Figures/974/974-1.png" alt="img" /></p>
<p><img src="../Figures/974/974-2.png" alt="img" /></p>
<p>Let's say a subarray ranging from index <code>0</code> to index <code>j</code> has a remainder <code>R</code> when the sum of its elements (prefix sum) is divided by <code>k</code>. Our task now becomes to figure out how many subarrays <code>0..i</code> exist with <code>i &lt; j</code> having the same remainder <code>R</code> when their prefix sum is divided by <code>k</code>. So, we need to maintain the count of remainders while moving in the array.</p>
<p>We start with an integer <code>prefixMod = 0</code> to store the remainder when the sum of the elements of a subarray that start from index <code>0</code> is divided by <code>k</code>. We do not need the prefix sum array, since we only need to maintain the count of each remainder (<code>0</code> to <code>k - 1</code>) so far. To maintain the count of the remainders, we initialize an array <code>modGroups[k]</code>, where <code>modGroups[R]</code> stores the number of times R was the remainder so far.</p>
<p>We iterate over all the elements starting from index <code>0</code>. We set <code>prefixMod = (prefixMod + num[i] % k + k) % k</code> for each element at index <code>i</code> to find the remainder of the sum of the subarray ranging from index <code>0</code> to index <code>i</code> when divided by <code>k</code>. The <code>+ k</code> is needed to handle negative numbers. We can then add the number of subarrays previously seen having the same remainder <code>prefixMod</code> to cancel out the remainder. The total number of these arrays is in <code>modGroups[prefixMod]</code>. In the end, we increment the count of <code>modGroups[R]</code> by one to include the current subarray with the remainder <code>R</code> for future matches.</p>
<p>Till now, we chose some previous subarrays (if they exist) to delete the remainder from the existing array formed till index <code>i</code> when the sum of its elements is divided by <code>k</code>. What if the sum of the elements of the array till index <code>i</code> is divisible by <code>k</code> and we don't need another subarray to delete the remainder?</p>
<p>To count the complete subarray from index <code>0</code> to index <code>i</code>, we also initialize <code>modGroups[0] = 1</code> at the start so that if a complete subarray from index <code>0</code> to the current index is divisible by <code>k</code>, we include the complete array in the count of <code>modGroups[0]</code>. It is set to start with <code>1</code> to cover the complete subarray case. For example, let's assume we are index <code>i</code>. Say, we have previously encountered three subarrays from index <code>0</code> to some index <code>j</code> where <code>j &lt; i</code> that were divisible by 'k'. Now, assume the sum of elements in the array up to index <code>i</code> is also divisible by <code>k</code>. So, we will have <code>4</code> options to form a subarray ending at index <code>i</code> that is divisible by <code>k</code>. Three of these come from choosing the subarrays (resulting in subarray <code>j + 1, .., i</code> that is divisble by <code>k</code>) that were divisble by <code>k</code> and one comes from choosing the complete subarray starting from index <code>0</code> till index <code>i</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer <code>prefixMod = 0</code> to store the remainder when the sum of the elements of a array till the current index when divided by <code>k</code>, and the answer variable <code>result = 0</code> to store the number of subarrays divisible by <code>k</code>.</li>
<li>Initialize an array, <code>modGroups[k]</code> where <code>modGroup[R]</code> stores the number of subarrays encountered with the sum of elements having a remainder <code>R</code> when divided by <code>k</code>. Set <code>modGroups[0] = 1</code>.</li>
<li>Iterate over all the elements of <code>num</code>.
<ul>
<li>For each index <code>i</code>, compute the prefix modulo as <code>prefixMod = (prefixMod + num[i] % k + k) % k</code>. We take modulo twice in <code>(prefixMod + num[i] % k + k) % k</code> to remove negative numbers since <code>num[i]</code> can be a negative number and the sum <code>prefixMod + nums[i] % k</code> can turn out to be negative. To remove the negative number we add <code>k</code> to make it positive and then takes its modulo again with <code>k</code>.</li>
<li>Add the number of subarrays encountered till now that have the same remainder to the result: <code>result = result + modGroups[prefixMod]</code>.</li>
<li>In the end, we include the remainder of the subarray in the modGroups, i.e., <code>modGroups[prefixMod] = modGroups[prefixMod] + 1</code> for future matches.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mkGnoJE9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the length of <code>nums</code> and <span class="math inline">\(k\)</span> is the given integer.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + k)\)</span></p>
<ul>
<li>We require <span class="math inline">\(O(k)\)</span> time to initialize the <code>modGroups</code> array.</li>
<li>We also require <span class="math inline">\(O(n)\)</span> time to iterate over all the elements of the <code>nums</code> array. The computation of the <code>prefixSum</code> and the calculation of the subarrays divisible by <code>k</code> take <span class="math inline">\(O(1)\)</span> time for each index of the array.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span></p>
<ul>
<li>We require <span class="math inline">\(O(k)\)</span> space for the <code>modGroups</code> array.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/description" target="_blank" rel="noopener noreferrer">Sum of Absolute Differences in a Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order.</p>

<p>Build and return <em>an integer array </em><code>result</code><em> with the same length as </em><code>nums</code><em> such that </em><code>result[i]</code><em> is equal to the <strong>summation of absolute differences</strong> between </em><code>nums[i]</code><em> and all the other elements in the array.</em></p>

<p>In other words, <code>result[i]</code> is equal to <code>sum(|nums[i]-nums[j]|)</code> where <code>0 &lt;= j &lt; nums.length</code> and <code>j != i</code> (<strong>0-indexed</strong>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,5]
<strong>Output:</strong> [4,3,5]
<strong>Explanation:</strong> Assuming the arrays are 0-indexed, then
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,6,8,10]
<strong>Output:</strong> [24,15,13,15,21]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums[i + 1] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-prefix-sum">Approach 1: Prefix Sum</h3>
<p><strong>Intuition</strong></p>
<p>Because the input is given sorted, let's try to split the problem into two parts. For a given <code>num</code> at index <code>i</code>, the answer for this index is the sum of:</p>
<ol>
<li>The sum of absolute differences between <code>num</code> and all numbers less than <code>num</code>.</li>
<li>The sum of absolute differences between <code>num</code> and all numbers greater than <code>num</code>.</li>
</ol>
<p>As <code>nums</code> is sorted, we can focus on all indices less than <code>i</code> for the first part and all indices greater than <code>i</code> for the second part. Let's start with the first part with the following example.</p>
<p><img src="../Figures/1685/1.png" alt="example" /><br />
<br></p>
<p>The sum of differences is equivalent to the sum we would have to add to the numbers to make them all equal to <code>8</code>.</p>
<p><img src="../Figures/1685/2.png" alt="example" /><br />
<br></p>
<p>If we made all the numbers equal to <code>8</code>, they would have a sum equal to <code>8</code> times the count of numbers <code>leftCount</code>. In this specific example, they would have a sum of <code>3 * 8 = 24</code>. In general, for an index <code>i</code>, there are <code>i</code> elements less than <code>nums[i]</code>, so we have <code>leftCount = i</code> and these numbers would have a sum of <code>leftCount * nums[i]</code>.</p>
<p>Their current sum is <code>leftSum = 1 + 4 + 6 = 11</code>. Thus, we can find the sum of absolute differences for these elements as <code>leftTotal = 24 - 11 = 13</code>. In general, we have <code>leftTotal = leftCount * nums[i] - leftSum</code>. This makes sense as it is the difference between what the elements would be if they were all equal to <code>nums[i]</code> minus what they currently are, which is precisely what the problem is asking for.</p>
<p>What about the elements on the right?</p>
<p><img src="../Figures/1685/3.png" alt="example" /><br />
<br></p>
<p>We can make use of the same idea - how much would we need to <strong>subtract</strong> from the numbers on the right to make them all equal to <code>8</code>? Note we subtract here instead of adding because the numbers on the right are greater.</p>
<p><img src="../Figures/1685/4.png" alt="example" /><br />
<br></p>
<p>How many elements are on the right? In this example, there are <code>3</code>, so they would have a sum of <code>8 * 3 = 24</code>. In general, for an index <code>i</code>, there are <code>rightCount = n - 1 - i</code> elements on its right, and they would have a sum of <code>rightCount * nums[i]</code> if we reduced them all.</p>
<p>In our example, they currently have a sum of <code>rightSum = 12 + 18 + 21 = 51</code>. Thus, the sum of absolute differences is <code>51 - 24 = 27</code>. In general, we can find the sum of absolute differences as <code>rightTotal = rightSum - rightCount * nums[i]</code>.</p>
<p>Now, we know how to find the answer for each index <code>i</code>. But how do we find <code>leftSum</code> and <code>rightSum</code>? We can make use of prefix sums to find the sum of any subarray in <span class="math inline">\(O(1)\)</span>.</p>
<p>We start by building a prefix sum array <code>prefix</code>, where <code>prefix[i]</code> represents the sum of all elements up to and including index <code>i</code>. Then, we can calculate <code>leftSum = prefix[i] - nums[i]</code> and <code>rightSum = prefix[n - 1] - prefix[i]</code>. Note that this is simply how we are implementing the prefix sum in this article, and you may implement it in whatever way you are most comfortable. The important thing is that we can quickly calculate <code>leftSum</code> and <code>rightSum</code>.</p>
<p>Once we have <code>prefix</code>, we iterate over each index <code>i</code> and use the process we described above to find <code>leftTotal</code> and <code>rightTotal</code>. Then, the answer for index <code>i</code> is simply <code>leftTotal + rightTotal</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Let <code>n</code> be the length of <code>nums</code>.</p>
<ol>
<li>Create a <code>prefix</code> sum of <code>nums</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>Calculate <code>leftSum</code> using <code>prefix</code>.</li>
<li>Calculate <code>rightSum</code> using <code>prefix</code>.</li>
<li>Calculate <code>leftCount = i</code>.</li>
<li>Calculate <code>rightCount = n - 1 - i</code>.</li>
<li>Calculate <code>leftTotal = leftCount * nums[i] - leftSum</code>.</li>
<li>Calculate <code>rightTotal = rightSum - rightCount * nums[i]</code>.</li>
<li>Add <code>leftTotal + rightTotal</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/2EYQjTD3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating <code>prefix</code> requires <span class="math inline">\(O(n)\)</span> time. Then, we iterate over <code>nums</code>, performing <span class="math inline">\(O(1)\)</span> work at each iteration. Thus, we require <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>prefix</code> has a length of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-calculating-prefix-sum-on-the-fly">Approach 2: Calculating Prefix Sum on the Fly</h3>
<p><strong>Intuition</strong></p>
<p>In fact, we do not need the <code>prefix</code> array. As <code>leftSum</code> for any adjacent indices like <code>i</code> and <code>i + 1</code> only differ by one element, we can calculate <code>leftSum</code> on the fly by initializing it to <code>0</code> and simply adding each number we iterate over to it. If we know <code>leftSum</code>, then we can also deduce what <code>rightSum</code> is by taking the <code>totalSum</code> of the array and subtracting <code>leftSum</code> and <code>nums[i]</code> from it. This avoids the need to build a prefix sum array and achieves the same result.</p>
<p>Thus, we will start by finding the <code>totalSum</code>, and then use that to calculate <code>rightSum</code> while calculating <code>leftSum</code> on the fly. Everything else remains the same.</p>
<p><strong>Algorithm</strong></p>
<p>Let <code>n</code> be the length of <code>nums</code>.</p>
<ol>
<li>Initialize <code>totalSum</code> as the sum of <code>nums</code>, <code>leftSum = 0</code>, and the answer list <code>ans</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>Calculate <code>rightSum = totalSum - leftSum - nums[i]</code>.</li>
<li>Calculate <code>leftCount = i</code>.</li>
<li>Calculate <code>rightCount = n - 1 - i</code>.</li>
<li>Calculate <code>leftTotal = leftCount * nums[i] - leftSum</code>.</li>
<li>Calculate <code>rightTotal = rightSum - rightCount * nums[i]</code>.</li>
<li>Add <code>leftTotal + rightTotal</code> to <code>ans</code>.</li>
<li>Add <code>nums[i]</code> to <code>leftSum</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/HTCqfnKM/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating <code>totalSum</code> requires <span class="math inline">\(O(n)\)</span> time. Then, we iterate over <code>nums</code>, performing <span class="math inline">\(O(1)\)</span> work at each iteration. Thus, we require <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer toward the space complexity. Thus, we are only using a few integer variables.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-all-odd-length-subarrays/description" target="_blank" rel="noopener noreferrer">Sum of All Odd Length Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of positive integers <code>arr</code>, return <em>the sum of all possible <strong>odd-length subarrays</strong> of </em><code>arr</code>.</p>

<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,4,2,5,3]
<strong>Output:</strong> 58
<strong>Explanation: </strong>The odd-length subarrays of arr and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2]
<strong>Output:</strong> 3
<b>Explanation: </b>There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,11,12]
<strong>Output:</strong> 66
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 100</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<p>Could you solve this problem in O(n) time complexity?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with brute force, the most intuitive method. We find each of the subarrays one by one, and get the sum of the current subarray if it has an odd length.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize <code>answer = 0</code>.</li>
<li>Iterate over the left index <code>left</code> of subarrays.</li>
<li>For every subarray start at index <code>left</code>, iterate over every index <code>right</code> to fix the end of subarray.</li>
<li>For each subarray <code>(left, right)</code>, if its length is odd:
<ul>
<li>Iterate over this subarray and get its sum <code>current_sum</code>.</li>
<li>Increment <code>answer</code> by <code>current_sum</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fuCh4k27/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<ul>
<li>We have three nested loops, the first loop for the left index <code>left</code>, the second loop for the right index <code>right</code>, and the third loop for the index <code>currentIndex</code> between <code>left</code> and <code>right</code>.</li>
<li>For each odd-length subarray, we need to get its sum and update <code>answer</code> after the third iteration.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n^3)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update two variables:
<ul>
<li><code>current_sum</code> the sum of the current subarray.</li>
<li><code>answer</code>, the sum of all odd-length subarrays.</li>
</ul>
</li>
</ul>
<p>which only takes constant space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-two-loops">Approach 2: Two Loops</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's try a better method to reduce the workload!</p>
<p>For a starting index <code>left</code>, the difference between each of the two adjacent right indices is 1. In other words, if the current subarray is <code>[left, right]</code>, the next subarray (if it exists) is <code>[left, right + 1]</code>. Therefore, we can get the sum of the next subarray by adding <code>arr[right + 1]</code> to the sum of the previous subarray. If the current subarray has an odd length, we can increment <code>answer</code> by its sum, as shown in the picture below.</p>
<p><img src="../Figures/1588/1588-1.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code>answer</code> as 0.</li>
<li>Iterate over <code>left</code>, the left index of the subarray.</li>
<li>For every subarray start at index <code>left</code>, we initialize <code>current_sum = 0</code>. We iterate over index <code>right</code> to fix the end of each subarray, and calculate the sum of this subarray (<code>current_sum</code>) by adding <code>arr[right]</code> to the previous <code>current_sum</code>. If the current subarray has an odd length, we increment <code>answer</code> by <code>current_sum</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MAS6MJz2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>We have two nested loops, the first loop for the left index <code>left</code>, the second loop for the right index <code>right</code>.</li>
<li>For each odd-length subarray, we need to increment <code>answer</code> by its sum which takes constant time.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update two variables:
<ul>
<li><code>current_sum</code> the sum of the current subarray.</li>
<li><code>answer</code>, the sum of all odd-length subarrays.</li>
</ul>
</li>
</ul>
<p>which only takes constant space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-check-the-occurrence-of-each-index">Approach 3: Check the occurrence of each index</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of finding all odd-length subarrays, we can count the number of occurrences of each integer in all odd-length subarrays. For example, if <code>arr[i]</code> has appeared <code>k</code> times, it contributes to the total sum by <code>arr[i] * k</code>.</p>
<p><img src="../Figures/1588/1588-2.png" alt="img" /></p>
<blockquote>
<p>How to calculate the occurrence of each index?</p>
</blockquote>
<p>Let's find the pattern behind this: since the current subarray containing <code>arr[i]</code> has an odd-length, the number of elements without <code>arr[i]</code> must be even, indicating the number of elements to the left and right side of <code>arr[i]</code> must be <strong>both even</strong> or <strong>both odd</strong>, as shown in the picture below.</p>
<p><img src="../Figures/1588/1588-3.png" alt="img" /></p>
<p>Therefore, we are looking for:</p>
<ul>
<li><code>odd_left</code>, the number of odd-length subarrays starting from <code>i</code> on <code>i</code>'s left.</li>
<li><code>odd_right</code>, the number of odd-length subarrays starting from <code>i</code> on <code>i</code>'s right.</li>
<li><code>even_left</code>, the number of even-length subarrays starting from <code>i</code> on <code>i</code>'s left.</li>
<li><code>even_right</code>, the number of even-length subarrays starting from <code>i</code> on <code>i</code>'s right.</li>
</ul>
<p>Notice that:</p>
<ul>
<li>There are <code>i + 1</code> such subarrays to its left where <code>(i + 1) / 2</code> of them have odd-length and the rest have even-length.s</li>
<li>There are <code>n - 1 - i</code> such subarrays to its right where <code>(n - i) / 2</code> of them have odd-length and the rest have even-length.</li>
</ul>
<p><img src="../Figures/1588/1588-4.png" alt="img" /></p>
<p>Once we find all the four numbers above, we can calculate the occurrence of <code>arr[i]</code> in odd-length arrays as <code>odd_left * odd_right + even_left * even_right</code>.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>answer</code> as 0.</p>
</li>
<li>
<p>Iterate over <code>arr</code>, calculate the occurrence of each index <code>i</code>:</p>
<ul>
<li><code>odd_left = left / 2 + 1</code></li>
<li><code>odd_right = (n - i - 1) / 2 + 1</code></li>
<li><code>even_left = (i + 1) / 2</code></li>
<li><code>even_right = (n - i) / 2</code></li>
</ul>
<p>Add the current element <code>arr[i]</code> <code>(odd_left * odd_right + even_left * even_right)</code> times in <code>answer</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ejv4pvhc/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only need one iteration over <code>arr</code>.</li>
<li>At each step <code>i</code>, we need to calculate the occurrence of <code>arr[i]</code> in all the odd-length subarrays, it takes constant time.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update one variable <code>answer</code>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-distances/description" target="_blank" rel="noopener noreferrer">Sum of Distances</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. There exists an array <code>arr</code> of length <code>nums.length</code>, where <code>arr[i]</code> is the sum of <code>|i - j|</code> over all <code>j</code> such that <code>nums[j] == nums[i]</code> and <code>j != i</code>. If there is no such <code>j</code>, set <code>arr[i]</code> to be <code>0</code>.</p>

<p>Return <em>the array </em><code>arr</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,1,2]
<strong>Output:</strong> [5,0,3,4,0]
<strong>Explanation:</strong> 
When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. 
When i = 1, arr[1] = 0 because there is no other index with value 3.
When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. 
When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. 
When i = 4, arr[4] = 0 because there is no other index with value 2. 

</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,5,3]
<strong>Output:</strong> [0,0,0]
<strong>Explanation:</strong> Since each element in nums is distinct, arr[i] = 0 for all i.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/intervals-between-identical-elements/description/" target="_blank"> 2121: Intervals Between Identical Elements.</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-floored-pairs/description" target="_blank" rel="noopener noreferrer">Sum of Floored Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return the sum of <code>floor(nums[i] / nums[j])</code> for all pairs of indices <code>0 &lt;= i, j &lt; nums.length</code> in the array. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>The <code>floor()</code> function returns the integer part of the division.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,5,9]
<strong>Output:</strong> 10
<strong>Explanation:</strong>
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
We calculate the floor of the division for every pair of indices in the array then sum them up.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,7,7,7,7,7,7]
<strong>Output:</strong> 49
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-k-subarrays-with-length-at-least-m/description" target="_blank" rel="noopener noreferrer">Sum of K Subarrays With Length at Least M</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and two integers, <code>k</code> and <code>m</code>.</p>

<p>Return the <strong>maximum</strong> sum of <code>k</code> non-overlapping <span data-keyword="subarray">subarrays</span> of <code>nums</code>, where each subarray has a length of <strong>at least</strong> <code>m</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,-1,3,3,4], k = 2, m = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal choice is:</p>

<ul>
	<li>Subarray <code>nums[3..5]</code> with sum <code>3 + 3 + 4 = 10</code> (length is <code>3 &gt;= m</code>).</li>
	<li>Subarray <code>nums[0..1]</code> with sum <code>1 + 2 = 3</code> (length is <code>2 &gt;= m</code>).</li>
</ul>

<p>The total sum is <code>10 + 3 = 13</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-10,3,-1,-2], k = 4, m = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">-10</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal choice is choosing each element as a subarray. The output is <code>(-10) + 3 + (-1) + (-2) = -10</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= floor(nums.length / m)</code></li>
	<li><code>1 &lt;= m &lt;= 3</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-total-strength-of-wizards/description" target="_blank" rel="noopener noreferrer">Sum of Total Strength of Wizards</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>As the ruler of a kingdom, you have an army of wizards at your command.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>strength</code>, where <code>strength[i]</code> denotes the strength of the <code>i<sup>th</sup></code> wizard. For a <strong>contiguous</strong> group of wizards (i.e. the wizards&#39; strengths form a <strong>subarray</strong> of <code>strength</code>), the <strong>total strength</strong> is defined as the <strong>product</strong> of the following two values:</p>

<ul>
	<li>The strength of the <strong>weakest</strong> wizard in the group.</li>
	<li>The <strong>total</strong> of all the individual strengths of the wizards in the group.</li>
</ul>

<p>Return <em>the <strong>sum</strong> of the total strengths of <strong>all</strong> contiguous groups of wizards</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strength = [1,3,1,2]
<strong>Output:</strong> 44
<strong>Explanation:</strong> The following are all the contiguous groups of wizards:
- [1] from [<u><strong>1</strong></u>,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,<u><strong>3</strong></u>,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,<u><strong>1</strong></u>,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,<u><strong>2</strong></u>] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [<u><strong>1,3</strong></u>,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,<u><strong>3,1</strong></u>,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,<u><strong>1,2</strong></u>] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [<u><strong>1,3,1</strong></u>,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,<u><strong>3,1,2</strong></u>] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [<u><strong>1,3,1,2</strong></u>] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strength = [5,4,6]
<strong>Output:</strong> 213
<strong>Explanation:</strong> The following are all the contiguous groups of wizards: 
- [5] from [<u><strong>5</strong></u>,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,<u><strong>4</strong></u>,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,<u><strong>6</strong></u>] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [<u><strong>5,4</strong></u>,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,<u><strong>4,6</strong></u>] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [<u><strong>5,4,6</strong></u>] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-variable-length-subarrays/description" target="_blank" rel="noopener noreferrer">Sum of Variable Length Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of size <code>n</code>. For <strong>each</strong> index <code>i</code> where <code>0 &lt;= i &lt; n</code>, define a <span data-keyword="subarray-nonempty">subarray</span> <code>nums[start ... i]</code> where <code>start = max(0, i - nums[i])</code>.</p>

<p>Return the total sum of all elements from the subarray defined for each index in the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">11</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">i</th>
			<th style="border: 1px solid black;">Subarray</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>nums[0] = [2]</code></td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>nums[0 ... 1] = [2, 3]</code></td>
			<td style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;"><code>nums[1 ... 2] = [3, 1]</code></td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Total Sum</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">11</td>
		</tr>
	</tbody>
</table>

<p>The total sum is 11. Hence, 11 is the output.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,1,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">i</th>
			<th style="border: 1px solid black;">Subarray</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;"><code>nums[0] = [3]</code></td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;"><code>nums[0 ... 1] = [3, 1]</code></td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;"><code>nums[1 ... 2] = [1, 1]</code></td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;"><code>nums[1 ... 3] = [1, 1, 2]</code></td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Total Sum</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">13</td>
		</tr>
	</tbody>
</table>

<p>The total sum is 13. Hence, 13 is the output.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/taking-maximum-energy-from-the-mystic-dungeon/description" target="_blank" rel="noopener noreferrer">Taking Maximum Energy From the Mystic Dungeon</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a mystic dungeon, <code>n</code> magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.</p>

<p>You have been cursed in such a way that after absorbing energy from magician <code>i</code>, you will be instantly transported to magician <code>(i + k)</code>. This process will be repeated until you reach the magician where <code>(i + k)</code> does not exist.</p>

<p>In other words, you will choose a starting point and then teleport with <code>k</code> jumps until you reach the end of the magicians&#39; sequence, <strong>absorbing all the energy</strong> during the journey.</p>

<p>You are given an array <code>energy</code> and an integer <code>k</code>. Return the <strong>maximum</strong> possible energy you can gain.</p>

<p><strong>Note</strong> that when you are reach a magician, you <em>must</em> take energy from them, whether it is negative or positive energy.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> energy = [5,2,-10,-5,1], k = 3</span></p>

<p><strong>Output:</strong><span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> 3</span></p>

<p><strong>Explanation:</strong> We can gain a total energy of 3 by starting from magician 1 absorbing 2 + 1 = 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong><span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> energy = [-2,-3,-1], k = 2</span></p>

<p><strong>Output:</strong><span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
"> -1</span></p>

<p><strong>Explanation:</strong> We can gain a total energy of -1 by starting from magician 2.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= energy.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-1000 &lt;= energy[i] &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= energy.length - 1</code></li>
</ul>

<p>&nbsp;</p>
â€‹â€‹â€‹â€‹â€‹â€‹</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/threshold-majority-queries/description" target="_blank" rel="noopener noreferrer">Threshold Majority Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and an array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code>.</p>

<p>Return an array of integers <code data-end="33" data-start="28">ans</code> where <code data-end="48" data-start="40">ans[i]</code> is equal to the element in the subarray <code data-end="102" data-start="89">nums[l<sub>i</sub>...r<sub>i</sub>]</code> that appears <strong>at least</strong> <code data-end="137" data-start="125">threshold<sub>i</sub></code> times, selecting the element with the <strong>highest</strong> frequency (choosing the <strong>smallest</strong> in case of a tie), or -1 if no such element <em>exists</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,1,1], queries = [[0,5,4],[0,3,3],[2,3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,-1,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 5, 4]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2, 1, 1]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 4, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 3, 3]</td>
			<td align="left" style="border: 1px solid black;">[1, 1, 2, 2]</td>
			<td align="left" style="border: 1px solid black;">3</td>
			<td align="left" style="border: 1px solid black;">1 &rarr; 2, 2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">-1</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,2,3,2,3,2,3], queries = [[0,6,4],[1,5,2],[2,4,1],[3,3,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,3,2]</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="left" style="border: 1px solid black;">Query</th>
			<th align="left" style="border: 1px solid black;">Sub-array</th>
			<th align="left" style="border: 1px solid black;">Threshold</th>
			<th align="left" style="border: 1px solid black;">Frequency table</th>
			<th align="left" style="border: 1px solid black;">Answer</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="left" style="border: 1px solid black;">[0, 6, 4]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3, 2, 3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">4</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 4, 2 &rarr; 3</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[1, 5, 2]</td>
			<td align="left" style="border: 1px solid black;">[2, 3, 2, 3, 2]</td>
			<td align="left" style="border: 1px solid black;">2</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 3, 3 &rarr; 2</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[2, 4, 1]</td>
			<td align="left" style="border: 1px solid black;">[3, 2, 3]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">3 &rarr; 2, 2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td align="left" style="border: 1px solid black;">[3, 3, 1]</td>
			<td align="left" style="border: 1px solid black;">[2]</td>
			<td align="left" style="border: 1px solid black;">1</td>
			<td align="left" style="border: 1px solid black;">2 &rarr; 1</td>
			<td align="left" style="border: 1px solid black;">2</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="51" data-start="19"><code data-end="49" data-start="19">1 &lt;= nums.length == n &lt;= 10<sup>4</sup></code></li>
	<li data-end="82" data-start="54"><code data-end="80" data-start="54">1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li data-end="120" data-start="85"><code data-end="118" data-start="85">1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="195" data-start="123"><code data-end="193" data-is-only-node="" data-start="155">queries[i] = [l<sub>i</sub>, r<sub>i</sub>, threshold<sub>i</sub>]</code></li>
	<li data-end="221" data-start="198"><code data-end="219" data-start="198">0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; n</code></li>
	<li data-end="259" data-is-last-node="" data-start="224"><code data-end="259" data-is-last-node="" data-start="224">1 &lt;= threshold<sub>i</sub> &lt;= r<sub>i</sub> - l<sub>i</sub> + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-length-3-palindromic-subsequences/description" target="_blank" rel="noopener noreferrer">Unique Length-3 Palindromic Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the number of <strong>unique palindromes of length three</strong> that are a <strong>subsequence</strong> of </em><code>s</code>.</p>

<p>Note that even if there are multiple ways to obtain the same subsequence, it is still only counted <strong>once</strong>.</p>

<p>A <strong>palindrome</strong> is a string that reads the same forwards and backwards.</p>

<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>

<ul>
	<li>For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabca&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 palindromic subsequences of length 3 are:
- &quot;aba&quot; (subsequence of &quot;<u>a</u>a<u>b</u>c<u>a</u>&quot;)
- &quot;aaa&quot; (subsequence of &quot;<u>aa</u>bc<u>a</u>&quot;)
- &quot;aca&quot; (subsequence of &quot;<u>a</u>ab<u>ca</u>&quot;)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;adc&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no palindromic subsequences of length 3 in &quot;adc&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bbcbaba&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 4 palindromic subsequences of length 3 are:
- &quot;bbb&quot; (subsequence of &quot;<u>bb</u>c<u>b</u>aba&quot;)
- &quot;bcb&quot; (subsequence of &quot;<u>b</u>b<u>cb</u>aba&quot;)
- &quot;bab&quot; (subsequence of &quot;<u>b</u>bcb<u>ab</u>a&quot;)
- &quot;aba&quot; (subsequence of &quot;bbcb<u>aba</u>&quot;)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-count-letters-in-between">Approach 1: Count Letters In-Between</h3>
<p><strong>Intuition</strong></p>
<p>There is only one possible form a palindrome with length 3 can take. The first and last character must be the same, and the character in the middle can be anything (including the same character as the first/last character).</p>
<p>The important thing to notice here is that the first and last characters must be the same. To solve this problem, we can focus on each letter of the alphabet <code>letter</code> and treat it as the first and last character. Then, we find how many characters we can put in between them to form a palindrome.</p>
<p>There may be many occurrences of a given <code>letter</code> in <code>s</code>. Which ones should we choose? We should choose the first occurrence of <code>letter</code> in <code>s</code> to be the first character in our palindrome, and the last occurrence of <code>letter</code> in <code>s</code> to be the last character in our palindrome. Why?</p>
<p>The problem wants us to find subsequences - so when we look for a character to put as the middle character in the palindrome, this character must also be in between our two occurrences in <code>s</code>. Thus, by choosing the first and last occurrence, we are maximizing the number of characters in between, and thus maximizing the number of potential palindromes we could form.</p>
<p>For each <strong>unique</strong> <code>letter</code> in <code>s</code>, we find <code>i</code> as the first index where <code>letter</code> occurs and <code>j</code> as the final index where <code>letter</code> occurs. Next, we look at all the characters between indices <code>i</code> and <code>j</code> (the range of <code>[i + 1, j - 1]</code>) and count how many <strong>unique</strong> letters there are. Each of these unique letters can form a palindrome by being between two <code>letter</code>.</p>
<p><img src="../Figures/1930/1.png" alt="example" /><br />
<br></p>
<p>How do we find the count of <strong>unique</strong> letters? We will use a hash set since hash sets do not record duplicates. We iterate over each index <code>k</code> between <code>i</code> and <code>j</code> and add <code>s[k]</code> to our hash set <code>between</code>. Once finished, we can add the size of <code>between</code> to our answer. We repeat this process for every unique <code>letter</code> that appears in <code>s</code>. We can also use a hash set to find all the unique letters that appear in <code>s</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create <code>letters</code>, a hash set of all letters in <code>s</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate over each <code>letter</code> in <code>letters</code>:
<ul>
<li>Calculate <code>i</code> as the first index in which <code>letter</code> appears in <code>s</code> and <code>j</code> as the final index in which <code>letter</code> appears in <code>s</code>:
<ul>
<li>Initialize <code>i = -1</code> and <code>j = 0</code>. Iterate over each index <code>k</code> in <code>s</code>. If <code>s[k] = letter</code>, set <code>i = k</code> if <code>i = -1</code>, and set <code>j = k</code>.</li>
</ul>
</li>
<li>Initialize a hash set <code>between</code>.</li>
<li>Iterate <code>k</code> over the indices between <code>i</code> and <code>j</code>:
<ul>
<li>Add <code>s[k]</code> to <code>between</code>.</li>
</ul>
</li>
<li>Add the length of <code>between</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/EPN9jFyU/shared">code</a></p>
<blockquote>
<p>Bonus Python 1-liner:</p>
</blockquote>
<p><a href="https://leetcode.com/playground/U7FsvHWw/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To create <code>letters</code>, we use <span class="math inline">\(O(n)\)</span> time to iterate over <code>s</code>.</p>
<p>Next, we iterate over each <code>letter</code> in <code>letters</code>. Because <code>s</code> only contains lowercase letters of the English alphabet, there will be no more than 26 iterations.</p>
<p>At each iteration, we iterate over <code>s</code> to find <code>i</code> and <code>j</code>, which costs <span class="math inline">\(O(n)\)</span>. Next, we iterate between <code>i</code> and <code>j</code>, which could cost <span class="math inline">\(O(n)\)</span> in the worst-case scenario.</p>
<p>Overall, each iteration costs <span class="math inline">\(O(n)\)</span>. This gives us a time complexity of <span class="math inline">\(O(26n) = O(n)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p><code>letters</code> and <code>between</code> cannot grow beyond a size of 26, since <code>s</code> only contains letters of the English alphabet.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-pre-compute-first-and-last-indices">Approach 2: Pre-Compute First and Last Indices</h3>
<p><strong>Intuition</strong></p>
<p>We can slightly optimize the previous approach by pre-computing the indices <code>i</code> and <code>j</code> for each <code>letter</code>.</p>
<p>In the first approach, it costs <span class="math inline">\(O(n)\)</span> to calculate <code>i</code> and <code>j</code>. While this does not affect the time complexity, it does add a large constant factor to our runtime. In this approach, we will spend <span class="math inline">\(O(n)\)</span> once, then be able to retrieve <code>i</code> and <code>j</code> for every letter in <span class="math inline">\(O(1)\)</span>.</p>
<p>Let <code>first</code> be an array of length <code>26</code>, where <code>first[c]</code> represents the first index the character <code>c</code> appears in <code>s</code>. Similarly, let <code>last</code> be an array of length <code>26</code>, where <code>last[c]</code> represents the last index the character <code>c</code> appears in <code>s</code>. Because we need integer indices, we will map each character to its position in the alphabet.</p>
<ul>
<li><code>'a' = 0</code>.</li>
<li><code>'b' = 1</code>.</li>
<li>...</li>
<li><code>'z' = 25</code>.</li>
</ul>
<p>We will calculate the arrays <code>first</code> and <code>last</code> prior to calculating the answer. To indicate if a letter appears in <code>s</code> at all, we will initialize <code>first</code> to have values of <code>-1</code>, which would be overridden if a letter appears in <code>s</code>.</p>
<blockquote>
<p>To calculate <code>first</code> and <code>last</code>, we use a similar process from the previous approach. We iterate over <code>s</code> and for each <code>s[i]</code>, if <code>first[s[i]] = -1</code>, we set <code>first[s[i]] = i</code>. We always set <code>last[s[i]] = i</code>.</p>
</blockquote>
<p>Once we have <code>first</code> and <code>last</code>, we can iterate over each position in the alphabet <code>i</code>. We first check if this character appears in <code>s</code> at all, which we can do by checking if <code>first[i] = -1</code>. If <code>i</code> appears in <code>s</code>, we reference <code>first[i]</code> and <code>last[i]</code> to get the first and last indices.</p>
<p>We then perform the same process from the previous approach - declare a hash set <code>between</code>, iterate between the first and last indices, add each character to <code>between</code>, and finally add the length of <code>between</code> to our answer.</p>
<p>We repeat this process for each position <code>i</code> in the alphabet from <code>0</code> until <code>26</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>first</code> and <code>last</code> as arrays of length <code>26</code> with values <code>-1</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>s</code>:
<ul>
<li>Calculate the current alphabet position as <code>curr = s[i] - 'a'</code>.</li>
<li>If <code>first[curr] = -1</code>, set <code>first[curr] = i</code>.</li>
<li>Set <code>last[curr] = i</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate over each alphabet position <code>i</code> from <code>0</code> until <code>26</code>:
<ul>
<li>If <code>first[i] = -1</code>, continue to the next iteration.</li>
<li>Initialize a hash set <code>between</code>.</li>
<li>Iterate <code>j</code> over the indices between <code>first[i]</code> and <code>last[i]</code>:
<ul>
<li>Add <code>s[j]</code> to <code>between</code>.</li>
</ul>
</li>
<li>Add the length of <code>between</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/bDZ8r9vd/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>First, we calculate <code>first</code> and <code>last</code> by iterating over <code>s</code>, which costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, we iterate over 26 alphabet positions. At each iteration, we iterate <code>j</code> over some indices, which in the worst-case scenario would cost <span class="math inline">\(O(n)\)</span>. Overall, each of the 26 iterations cost <span class="math inline">\(O(n)\)</span>, giving us a time complexity of <span class="math inline">\(O(26n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p><code>first</code>, <code>last</code>, and <code>between</code> all use constant space since <code>s</code> only contains letters in the English alphabet.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-permutations-for-di-sequence/description" target="_blank" rel="noopener noreferrer">Valid Permutations for DI Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">prefix sum</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of length <code>n</code> where <code>s[i]</code> is either:</p>

<ul>
	<li><code>&#39;D&#39;</code> means decreasing, or</li>
	<li><code>&#39;I&#39;</code> means increasing.</li>
</ul>

<p>A permutation <code>perm</code> of <code>n + 1</code> integers of all the integers in the range <code>[0, n]</code> is called a <strong>valid permutation</strong> if for all valid <code>i</code>:</p>

<ul>
	<li>If <code>s[i] == &#39;D&#39;</code>, then <code>perm[i] &gt; perm[i + 1]</code>, and</li>
	<li>If <code>s[i] == &#39;I&#39;</code>, then <code>perm[i] &lt; perm[i + 1]</code>.</li>
</ul>

<p>Return <em>the number of <strong>valid permutations</strong> </em><code>perm</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;DID&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> The 5 valid permutations of (0, 1, 2, 3) are:
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;D&quot;
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length</code></li>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>s[i]</code> is either <code>&#39;I&#39;</code> or <code>&#39;D&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ways-to-make-a-fair-array/description" target="_blank" rel="noopener noreferrer">Ways to Make a Fair Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array&nbsp;<code>nums</code>. You can choose <strong>exactly one</strong> index (<strong>0-indexed</strong>) and remove the element. Notice that the index of the elements may change after the removal.</p>

<p>For example, if <code>nums = [6,1,7,4,1]</code>:</p>

<ul>
	<li>Choosing to remove index <code>1</code> results in <code>nums = [6,7,4,1]</code>.</li>
	<li>Choosing to remove index <code>2</code> results in <code>nums = [6,1,4,1]</code>.</li>
	<li>Choosing to remove index <code>4</code> results in <code>nums = [6,1,7,4]</code>.</li>
</ul>

<p>An array is <strong>fair</strong> if the sum of the odd-indexed values equals the sum of the even-indexed values.</p>

<p>Return the <em><strong>number</strong> of indices that you could choose such that after the removal, </em><code>nums</code><em> </em><em>is <strong>fair</strong>. </em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,6,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
Remove index 0: [1,6,4] -&gt; Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.
Remove index 1: [2,6,4] -&gt; Even sum: 2 + 4 = 6. Odd sum: 6. Fair.
Remove index 2: [2,1,4] -&gt; Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.
Remove index 3: [2,1,6] -&gt; Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.
There is 1 index that you can remove to make nums fair.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong>&nbsp;You can remove any index and the remaining array is fair.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong>&nbsp;You cannot make a fair array after removing any index.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ways-to-split-array-into-three-subarrays/description" target="_blank" rel="noopener noreferrer">Ways to Split Array Into Three Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A split of an integer array is <strong>good</strong> if:</p>

<ul>
	<li>The array is split into three <strong>non-empty</strong> contiguous subarrays - named <code>left</code>, <code>mid</code>, <code>right</code> respectively from left to right.</li>
	<li>The sum of the elements in <code>left</code> is less than or equal to the sum of the elements in <code>mid</code>, and the sum of the elements in <code>mid</code> is less than or equal to the sum of the elements in <code>right</code>.</li>
</ul>

<p>Given <code>nums</code>, an array of <strong>non-negative</strong> integers, return <em>the number of <strong>good</strong> ways to split</em> <code>nums</code>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only good way to split nums is [1] [1] [1].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,2,5,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no good way to split nums.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/yasser-and-xor-c7c23323/" target="_blank" rel="noopener noreferrer">XOR of numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array $$a$$ of $$n$$ numbers and $$q$$ queries. In each query, $$l$$, $$r$$ find $$XOR$$ of all $$n$$ numbers except the range $$[l, r]$$.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains two integers $$n$$&nbsp;denoting the number of elements and $$q$$ denoting the number of test cases.</li>
	<li>The second line of each test case&nbsp;contains&nbsp;$$n$$&nbsp;space-separated integers.</li>
	<li>The next $$q$$ lines contain two integers $$l$$ and $$r$$.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case, print the answer as described in the problem statement.</p>

<p><strong>Example</strong>&nbsp;</p>

<p>Let the array $$a$$ be $$[1, 2, 3, 4]$$ and you are given a query $$(2, 3)$$, then print the $${XOR}$$ of all the array $$a$$ without the range $$[2, 3]$$.</p>

<p>Hence, the answer will be $$1 $${XOR}$$ 4$$.&nbsp;</p>

<p><strong>Constraints</strong></p>

<p>$$1 \le&nbsp; &nbsp;n&nbsp; \le&nbsp; 10^5$$</p>

<p>$$1 \le&nbsp; &nbsp;q&nbsp; &nbsp; \le&nbsp; {10^5}$$</p>

<p>$$1 \le&nbsp; a_i&nbsp; \le {10^9}$$</p>

<p>$$1 \le&nbsp; l, r&nbsp; \le&nbsp; n$$</p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the first test case, the XOR of the array without the numbers in the range $$[2, 3]$$. So, compute XOR of $${1, 4, 5}$$ it equals to $$0$$.</p>

<p>&nbsp;</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/xor-queries-of-a-subarray/description" target="_blank" rel="noopener noreferrer">XOR Queries of a Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>arr</code> of positive integers. You are also given the array <code>queries</code> where <code>queries[i] = [left<sub>i, </sub>right<sub>i</sub>]</code>.</p>

<p>For each query <code>i</code> compute the <strong>XOR</strong> of elements from <code>left<sub>i</sub></code> to <code>right<sub>i</sub></code> (that is, <code>arr[left<sub>i</sub>] XOR arr[left<sub>i</sub> + 1] XOR ... XOR arr[right<sub>i</sub>]</code> ).</p>

<p>Return an array <code>answer</code> where <code>answer[i]</code> is the answer to the <code>i<sup>th</sup></code> query.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
<strong>Output:</strong> [2,7,14,8] 
<strong>Explanation:</strong> 
The binary representation of the elements in the array are:
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
The XOR values for queries are:
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]
<strong>Output:</strong> [8,0,4,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length, queries.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; arr.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of positive integers and a list of queries. For each query <code>[lefti, righti]</code>, we need to compute the XOR of all elements from index <code>lefti</code> to index <code>righti</code> in the array and return the results in the order in which the queries are given.</p>
<p>First, let's review a few key concepts to provide more context and better understand the following approaches.</p>
<h5 id="xor-operator-">XOR Operator (<code>^</code>):</h5>
<p>The <code>XOR</code> (exclusive <code>OR</code>) operator is a bitwise operator that compares each bit of two operands. The result is <code>1</code> if the bits differ, and <code>0</code> if they are the same. Hereâ€™s a truth table for the <code>XOR</code> operator:</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A ^ B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Properties:</p>
<ul>
<li><code>A ^ A = 0</code> (any number XORed with itself is <code>0</code>)</li>
<li><code>A ^ 0 = A</code> (XORing with <code>0</code> leaves the number unchanged)</li>
<li><code>A ^ B = B ^ A</code> (order doesnâ€™t matter)</li>
<li><code>(A ^ B) ^ C = A ^ (B ^ C)</code> (grouping doesnâ€™t matter)</li>
<li><code>(A ^ B) ^ B = A</code> (XORing twice cancels out)</li>
</ul>
<hr />
<h3 id="approach-1-iterative-approach">Approach 1: Iterative Approach</h3>
<h4 id="intuition">Intuition</h4>
<p>Given a range of indices in the query, the most straightforward approach is to compute the XOR for each element between the specified indices. To do this, we loop through the subarray defined by the query's <code>left</code> and <code>right</code> indices and compute the XOR of all the elements in that range.</p>
<p>This approach directly follows the problem's instructions by manually performing XOR on all elements between the <code>left</code> and <code>right</code> indices. However, it becomes inefficient when the array or the number of queries grows large. Each query requires a full pass over the subarray, and if many queries overlap, we end up recalculating the same XOR values repeatedly.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize an empty array <code>result</code> to store the results of each query.</li>
<li>For each query <code>q</code>:
<ul>
<li>Initialize <code>xorSum</code> to 0.</li>
<li>Calculate the XOR for the range <code>[q[0], q[1]]</code>:
<ul>
<li>Iterate through the elements from index <code>q[0]</code> to index <code>q[1]</code> in the array <code>arr</code>.</li>
<li>Update <code>xorSum</code> with the XOR of the current element.</li>
</ul>
</li>
</ul>
</li>
<li>Append <code>xorSum</code> to the <code>result</code> array after processing each query.</li>
<li>Return the <code>result</code> array containing the XOR results for all queries.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: This Python solution will result in a Time Limit Exceeded (TLE) error due to the brute-force nature of the approach and Python's inherent slower execution speed.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/aXxN48su/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements in <code>arr</code> and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot n)\)</span></p>
<p>For each query, we iterate through the range <code>[left, right]</code> in the <code>arr</code> to compute the XOR. Given that <code>q</code> is the number of queries and each query can potentially cover up to <code>n</code> elements, the worst-case time complexity is <span class="math inline">\(O(q \cdot n)\)</span>. This can be quite slow if both <code>q</code> and <code>n</code> are large.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because we are using only a few extra variables for calculations and storing results in the output array. The space required does not grow with the input size, except for the result storage, which is proportional to the number of queries. Since the result storage is a requirement of the problem statement, we will not count it towards the space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-xor-array">Approach 2: Prefix XOR Array</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To reduce redundant calculations, we can use an array for quick lookups when we need the XOR value of a particular segment. Specifically, each entry at index <code>i</code> in our array holds the XOR of all elements from the start of the original array up to index <code>i</code>. This cumulative XOR allows us to easily compute the XOR of any segment of the array. This concept is known as a prefix array,</p>
<p>We start by initializing the prefix XOR array. The first element is set to the first element of the original array. For each subsequent index, we compute the XOR of the previous element in the prefix XOR array with the current element from the original array. This step constructs the prefix XOR array in one pass.</p>
<p>With the prefix XOR array ready, we can quickly answer any query. For a query that asks for the XOR from index <code>left</code> to <code>right</code>, we use:</p>
<p><span class="math display">\[
Here, `prefixXOR[right + 1]` gives the XOR of elements from the start up to `right`, and `prefixXOR[left]` gives the XOR from the start up to `left - 1`. XORing these two values gives the result for the subarray from `left` to `right`.

When we XOR `prefixXOR[right + 1]` with `prefixXOR[left]`, we effectively remove the XOR of elements from the start to left - 1 from the XOR of elements from the start to right.

Assume the array is $[a, b, c, d, e]$.

\]</span></p>
<p>\text{prefixXOR}[0] = 0 \quad (\text{XOR of elements before the start})</p>
<p><span class="math display">\[\]</span></p>
<p>\text{prefixXOR}[1] = a</p>
<p><span class="math display">\[\]</span></p>
<p>\text{prefixXOR}[2] = a \oplus b</p>
<p><span class="math display">\[\]</span></p>
<p>\text{prefixXOR}[3] = a \oplus b \oplus c</p>
<p><span class="math display">\[\]</span></p>
<p>\text{prefixXOR}[4] = a \oplus b \oplus c \oplus d</p>
<p><span class="math display">\[\]</span></p>
<p>\text{prefixXOR}[5] = a \oplus b \oplus c \oplus d \oplus e</p>
<p><span class="math display">\[
To query the XOR from index 1 to 3:

\]</span></p>
<p>\text{prefixXOR}[4] = a \oplus b \oplus c \oplus d</p>
<p><span class="math display">\[
\]</span></p>
<p>\text{prefixXOR}[1] = a</p>
<p><span class="math display">\[
XORing these:

\]</span></p>
<p>\text{prefixXOR}[4] \oplus \text{prefixXOR}[1] = (a \oplus b \oplus c \oplus d) \oplus a = b \oplus c \oplus d</p>
<p><span class="math display">\[
This gives the XOR of elements from index 1 to 3.

So using $\text{prefixXOR}[ \text{right} + 1 ] \oplus \text{prefixXOR}[ \text{left} ]$ isolates the XOR of the desired subarray.

The algorithm is visualized below:

!?!../Documents/1310/xor.json:980,570!?!

#### Algorithm

- Initialize the `prefixXOR` array of size `n + 1` with all elements set to `0`.

- Build the `prefixXOR` array:
  - Iterate through each element `arr[i]`:
    - Compute `prefixXOR[i + 1]` as `prefixXOR[i] ^ arr[i]` (XOR current element with previous prefix XOR value).

- Initialize the `result` array to store the results of queries.

- Process each query:
  - For each query `q` with range `[q[0], q[1]]`:
    - Compute the XOR of the subarray from index `q[0]` to `q[1]` using `prefixXOR[q[1] + 1] ^ prefixXOR[q[0]]`.
    - Add the result to the `result` array.

- Return the `result` array containing the XOR results for all queries.

#### Implementation

[code](https://leetcode.com/playground/8kvdTrpv/shared)

#### Complexity Analysis

Let $n$ be the number of elements in `arr` and $q$ be the number of queries.

- Time Complexity: $O(n + q)$
  
  We first compute the prefix XOR array in $O(n)$ time. Each query is then resolved in constant time $O(1)$ using the prefix XOR array. Thus, the total time complexity is $O(n + q)$.

- Space Complexity: $O(n)$
  
  The space complexity is $O(n)$ due to the additional prefix XOR array of size $n + 1$.

---

### Approach 3: In place Prefix XOR

#### Intuition

Instead of creating a separate prefix XOR array, we can modify the original array in place to store the prefix XOR values directly. This reduces memory usage by ensuring that each element at index `i` in the array now holds the XOR of all elements from the start of the array up to `i`.

When a query is made, we can still compute the XOR for any subarray using the same logic as in the prefix XOR array approach, but now we do it without needing a separate XOR array. We can achieve this because the solution relies on the modified array.

> It is strongly advised to check with your interviewer on whether you are allowed to modify the input. Some interviewers appreciate the idea if you provide solid reasoning, but otherwise, avoid using the in-place prefix XOR. Good interviewers are interested in discussing a solution that you are leading.

#### Algorithm

- Initialize an empty array `result` to store the results of each query.

- Convert `arr` into a prefix XOR array in-place:
  - Iterate through `arr` starting from index 1:
    - Update each element by XOR-ing it with the previous element (`arr[i] ^= arr[i - 1]`).

- Resolve each query using the prefix XOR array:
  - For each query `q`:
    - If the start index `q[0]` is greater than 0:
      - Compute the `XOR` result for the subarray from `q[0]` to `q[1]` using `arr[q[0] - 1] ^ arr[q[1]]`.
    - Otherwise:
      - Directly use `arr[q[1]]` as the result for the query.

- Append the computed result for each query to the `result` array.

- Return the `result` array containing the results of all queries.

#### Implementation

[code](https://leetcode.com/playground/E4Cb3obC/shared)

#### Complexity Analysis

Let $n$ be the number of elements in `arr` and $q$ be the number of queries.

- Time Complexity: $O(n + q)$
  
  The time complexity is the same as the prefix XOR array approach. We first convert the `arr` into an in-place prefix XOR array in $O(n)$ time. Each query is then resolved in constant time $O(1)$, leading to an overall time complexity of $O(n + q)$.

- Space Complexity: $O(1)$

  The space complexity is constant because the in-place prefix XOR modification does not require extra space beyond what is needed to store the results.

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zero-array-transformation-i/description" target="_blank" rel="noopener noreferrer">Zero Array Transformation I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and a 2D array <code>queries</code>, where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>.</p>

<p>For each <code>queries[i]</code>:</p>

<ul>
	<li>Select a <span data-keyword="subset">subset</span> of indices within the range <code>[l<sub>i</sub>, r<sub>i</sub>]</code> in <code>nums</code>.</li>
	<li>Decrement the values at the selected indices by 1.</li>
</ul>

<p>A <strong>Zero Array</strong> is an array where all elements are equal to 0.</p>

<p>Return <code>true</code> if it is <em>possible</em> to transform <code>nums</code> into a <strong>Zero Array </strong>after processing all the queries sequentially, otherwise return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,0,1], queries = [[0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0:</strong>

	<ul>
		<li>Select the subset of indices as <code>[0, 2]</code> and decrement the values at these indices by 1.</li>
		<li>The array will become <code>[0, 0, 0]</code>, which is a Zero Array.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,2,1], queries = [[1,3],[0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0:</strong>

	<ul>
		<li>Select the subset of indices as <code>[1, 2, 3]</code> and decrement the values at these indices by 1.</li>
		<li>The array will become <code>[4, 2, 1, 0]</code>.</li>
	</ul>
	</li>
	<li><strong>For i = 1:</strong>
	<ul>
		<li>Select the subset of indices as <code>[0, 1, 2]</code> and decrement the values at these indices by 1.</li>
		<li>The array will become <code>[3, 1, 0, 0]</code>, which is not a Zero Array.</li>
	</ul>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-difference-array">Approach: Difference Array</h3>
<h4 id="intuition">Intuition</h4>
<p>We count the maximum number of operations that can be performed at each position using a difference array. Construct the difference array <code>deltaArray</code> with a length of <code>n + 1</code> (where <code>n</code> is the length of the array <code>nums</code>), which is used to record the increment for each query on the number of operations.</p>
<p>For each query interval <code>[left, right]</code>, increment <code>deltaArray[left]</code> by <code>+1</code>, indicating an increase in the operation count starting from <code>left</code>. Decrement <code>deltaArray[right + 1]</code> by <code>-1</code>, indicating that the operation count returns to its original value after <code>right + 1</code>.</p>
<p>Next, perform a prefix sum accumulation on the difference array <code>deltaArray</code> to obtain the total operation count at each position in the array, storing these counts in <code>operationCounts</code>. Traverse the <code>nums</code> array and the <code>operationCounts</code> array, comparing the actual operation counts (<code>operations</code>) at each position to see if they meet the minimum number of operations (<code>target</code>) required for zeroing. If all positions meet <code>operations &gt;= target</code>, return <code>true</code>; otherwise, return <code>false</code>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/iN556nLp/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <span class="math inline">\(\textit{nums}\)</span> and <span class="math inline">\(m\)</span> be the length of <span class="math inline">\(\textit{queries}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>.</p>
<p>We need <span class="math inline">\(O(m)\)</span> time to construct the difference array, followed by checking all <span class="math inline">\(O(n)\)</span> positions.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We need <span class="math inline">\(O(n)\)</span> space to store the difference array.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zero-array-transformation-ii/description" target="_blank" rel="noopener noreferrer">Zero Array Transformation II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and a 2D array <code>queries</code> where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>, val<sub>i</sub>]</code>.</p>

<p>Each <code>queries[i]</code> represents the following action on <code>nums</code>:</p>

<ul>
	<li>Decrement the value at each index in the range <code>[l<sub>i</sub>, r<sub>i</sub>]</code> in <code>nums</code> by <strong>at most</strong> <code>val<sub>i</sub></code>.</li>
	<li>The amount by which each value is decremented<!-- notionvc: b232c9d9-a32d-448c-85b8-b637de593c11 --> can be chosen <strong>independently</strong> for each index.</li>
</ul>

<p>A <strong>Zero Array</strong> is an array with all its elements equal to 0.</p>

<p>Return the <strong>minimum</strong> possible <strong>non-negative</strong> value of <code>k</code>, such that after processing the first <code>k</code> queries in <strong>sequence</strong>, <code>nums</code> becomes a <strong>Zero Array</strong>. If no such <code>k</code> exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,0,2], queries = [[0,2,1],[0,2,1],[1,1,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0 (l = 0, r = 2, val = 1):</strong>

	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 0, 1]</code> respectively.</li>
		<li>The array will become <code>[1, 0, 1]</code>.</li>
	</ul>
	</li>
	<li><strong>For i = 1 (l = 0, r = 2, val = 1):</strong>
	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 0, 1]</code> respectively.</li>
		<li>The array will become <code>[0, 0, 0]</code>, which is a Zero Array. Therefore, the minimum value of <code>k</code> is 2.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,3,2,1], queries = [[1,3,2],[0,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li><strong>For i = 0 (l = 1, r = 3, val = 2):</strong>

	<ul>
		<li>Decrement values at indices <code>[1, 2, 3]</code> by <code>[2, 2, 1]</code> respectively.</li>
		<li>The array will become <code>[4, 1, 0, 0]</code>.</li>
	</ul>
	</li>
	<li><strong>For i = 1 (l = 0, r = 2, val<span style="font-size: 13.3333px;"> </span>= 1):</strong>
	<ul>
		<li>Decrement values at indices <code>[0, 1, 2]</code> by <code>[1, 1, 0]</code> respectively.</li>
		<li>The array will become <code>[3, 0, 0, 0]</code>, which is not a Zero Array.</li>
	</ul>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 3</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; nums.length</code></li>
	<li><code>1 &lt;= val<sub>i</sub> &lt;= 5</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>nums</code> of length <code>n</code>, and a list of queries that are each in the form <code>[left, right, val]</code>. For a given range <code>[left, right]</code>, we can decrease each element in that range by at most <code>val</code>. Our task is to determine the earliest query that allows us to turn <code>nums</code> into an array of all zeroes. If it's not possible, we return <code>-1</code>.</p>
<p>We can look at an example of the queries being processed:</p>
<p>!?!../Documents/3356/slideshow1.json:960,540!?!</p>
<p>From this example, we can see that there are two main operations that will occur:</p>
<ol>
<li>Iterating through each element in <code>queries</code>.</li>
<li>Applying the range and value of each query to <code>nums</code>.</li>
</ol>
<p>We need to assess how to optimally handle both operations to find the earliest value of <code>k</code> to reach a zero array.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>A simple approach would be to iterate through each query, applying the updates directly to <code>nums</code> and checking whether all elements have become zero. However, given the constraints where both <code>nums</code> and <code>queries</code> can be as large as <span class="math inline">\(10^5\)</span>, this approach is too slow. Each query might require traversing the entire array, leading to an impractical time complexity.</p>
<p>To optimize this, we need a more efficient way to apply queries to <code>nums</code>. Instead of modifying each element individually, we can take advantage of a <strong>difference array</strong>. This technique allows us to apply a range update in constant time. The key idea is to store the changes at the boundaries of the range rather than updating every element inside it. For a query <span class="math inline">\([ \text{left}, \text{right}, \text{val} ]\)</span>, we add <code>val</code> at index <code>left</code>, and subtract <code>val</code> at index <code>right + 1</code>. When we later compute the prefix sum of this difference array, it reconstructs the actual values efficiently. This way, instead of updating <code>nums</code> repeatedly, we can process all queries in an optimized manner and then traverse <code>nums</code> just once to check if all elements have become zero.</p>
<p>Let's look at how the difference array can be applied to this problem:</p>
<p>!?!../Documents/3356/slideshow2.json:960,540!?!</p>
<p>Now that we optimized how we apply queries, the next step is to determine how many queries we actually need. Instead of processing all queries one by one, we can use <strong>binary search</strong> to quickly determine the minimum number of queries required to achieve the zero array. We start by setting two pointers: <code>left = 0</code> and <code>right = len(queries)</code>, representing the search range. The middle index, <code>mid = (left + right) / 2</code>, represents the number of queries we will attempt to apply. We update <code>nums</code> using only the first <code>mid</code> queries, compute the final state using the prefix sum of the difference array, and check if <code>nums</code> is now a zero array.</p>
<p>If it is possible to achieve a zero array with <code>mid</code> queries, we reduce our search range by setting <code>right = mid - 1</code>, since we might be able to do it with even fewer queries. Otherwise, we increase our search range by setting <code>left = mid + 1</code>, since we need more queries to reach the desired state. This binary search ensures that instead of checking every possible number of queries linearly <span class="math inline">\(O(N)\)</span>, we find the answer in <span class="math inline">\(O(\log N)\)</span> time.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define a function <code>canFormZeroArray</code>, which takes the parameters <code>nums</code>, <code>queries</code>, and integer <code>k</code> and returns a boolean value:</p>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>sum</code> to <code>0</code> to track the cumulative sum of updates added to a given index.</li>
<li><code>differenceArray</code> as a vector of integers of size <code>n + 1</code> to apply range updates</li>
</ul>
</li>
<li>Iterate through the first <code>k</code> elements of <code>queries</code>:
<ul>
<li>Initialize <code>start</code>, <code>end</code>, and <code>val</code> to the respective values of the current query.</li>
<li>Increment <code>differenceArray[start]</code> by <code>val</code> to update the start of the range.</li>
<li>Decrement <code>differenceArray[end + 1]</code> by <code>val</code> to update the end of the range.</li>
</ul>
</li>
<li>Iterate through <code>nums</code>. For each index, <code>numIndex</code>:
<ul>
<li>Increment <code>sum</code> by <code>differenceArray[numIndex]</code>;</li>
<li>If <code>sum</code> is less than <code>nums[numIndex]</code>, return <code>false</code>, indicating that a zero array cannot be formed after the first <code>k</code> queries.</li>
</ul>
</li>
<li>Return <code>true</code>, meaning a zero array was formed after <code>k</code> queries.</li>
</ul>
</li>
<li>
<p>Define <code>minZeroArray</code>:</p>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>left</code> to <code>0</code>.</li>
<li><code>right</code> to the size of <code>queries</code>.</li>
</ul>
</li>
<li>If a zero array cannot be formed at <code>right</code>, return <code>-1</code>, since that means we processed all the queries without reaching a zero array.</li>
<li>Perform binary search on <code>queries</code>. While <code>left</code> is less than or equal to <code>right</code>:
<ul>
<li>Initialize <code>middle</code> to half of the current search interval (<code>left + (right - left) / 2</code>).</li>
<li>If <code>canFormZeroArray</code> returns <code>false</code> when we pass <code>middle</code> as the <code>k</code> parameter, set <code>right</code> to <code>middle - 1</code>.</li>
<li>Else, set <code>left</code> to <code>middle + 1</code>.</li>
</ul>
</li>
<li>Return <code>left</code>, which is the earliest query that a zero array can be formed.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/XkQaAdC4/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of array <code>nums</code> and <span class="math inline">\(M\)</span> be the size of array <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(log(M) \cdot (N + M))\)</span></p>
<p>We perform a binary search on <code>queries</code>, which repeatedly divides the search space in half at each step, leading to a time complexity of <span class="math inline">\(log(M)\)</span>.</p>
<p>In each iteration of the binary search, we first iterate through the first <code>k</code> elements in <code>queries</code>. In the worst case, we have to iterate through each element when <code>k</code> is the size of <code>queries</code>, leading to a time complexity of <span class="math inline">\(O(M)\)</span>.</p>
<p>From there, we iterate through each element of <code>nums</code> until one of the elements exceeds the value of <code>sum</code>. In the worst case, we have to iterate through each element in <code>nums</code> when this doesn't occur, leading to a time complexity of <span class="math inline">\(O(N)\)</span>.</p>
<p>As a result, each iteration of the binary search has a time complexity of <span class="math inline">\(O(N + M)\)</span>. Combining each iteration leads to a final time complexity of <span class="math inline">\(O(log(M) \cdot (N + M))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is based on the array <code>differenceArray</code>. Here, <code>differenceArray</code> is set to hold elements from the range <code>[0, N + 1]</code> to track all the changes in <code>nums</code>. As a result, this creates a space complexity of <span class="math inline">\(O(N + 1)\)</span>, which can be simplified to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep">Approach 2: Line Sweep</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we used binary search to determine how many queries were needed to turn <code>nums</code> into a zero array. This allowed us to efficiently process a subset of <code>queries</code>, applying them to a <strong>difference array</strong>, and then checking if <code>nums</code> had become all zeros. While this was an improvement over a naive approach, there was still an inefficiency: we were iterating over <code>queries</code> twice: once for binary search and again while applying updates.</p>
<p>To optimize further, we can change our perspective on how we traverse the data. Instead of iterating through <code>queries</code>, we can iterate directly through <code>nums</code>, using it as the main loop. This means that as we process each element in <code>nums</code>, we dynamically apply only the necessary queries at the right moment. The key challenge, then, is finding an efficient way to apply queries while moving through <code>nums</code>.</p>
<p>This is where a line sweep approach comes into play. Line sweeping is a technique that processes an array incrementally, maintaining only the relevant updates at each step. Instead of processing all queries upfront, we maintain an <strong>active set of queries</strong> and update <code>nums</code> only when necessary. Here, the <strong>difference array</strong> helps us track how <code>nums</code> is being modified, while <code>queries</code> provide the updates at specific points.</p>
<p>We start at index <code>0</code> of <code>nums</code> and check if it can be turned into <code>0</code> with the queries we have processed so far. If it cannot be zeroed out, we process additional queries to apply their effects. The key observation is that at any index <code>i</code> in <code>nums</code>, a query <code>[left, right, val]</code> can fall into three possible cases:</p>
<ol>
<li>If <code>i &lt; left</code>, the query affects a later part of <code>nums</code>, so we store it for later processing.</li>
<li>If <code>left â‰¤ i â‰¤ right</code>, the query is immediately relevant and should be applied.</li>
<li>If <code>right &lt; i</code>, the query is no longer useful for the current index and can be ignored.</li>
</ol>
<p>For example, if we're at index <code>4</code> in <code>nums</code> and the current query accesses the range <code>[0,2]</code>, we do not need to process that query and can simply move on to the next query.</p>
<p>Otherwise, we continue to the next element of <code>nums</code>. We repeat this process until we reach the end of either <code>nums</code> or <code>queries</code>, where we then return either <code>k</code> or <code>-1</code>, respectively.</p>
<p>Through this process, we only have to iterate through both <code>nums</code> and <code>queries</code> at most once each while skipping over unnecessary queries.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of <code>nums</code>.</li>
<li><code>sum</code> to <code>0</code> to track the cumulative sum of updates applied up to a given index</li>
<li><code>k</code> to <code>0</code> to represent the number of queries used.</li>
<li><code>differenceArray</code> as a vector of integers set to size <code>n + 1</code> to apply range updates.</li>
</ul>
</li>
<li>Iterate through <code>nums</code>. For each <code>index</code>:
<ul>
<li>If <code>sum + differenceArray[index]</code> is less than <code>nums[index]</code>, meaning more operations need to be applied at the current index:
<ul>
<li>Increase <code>k</code> by <code>1</code>.</li>
<li>If <code>k</code> is greater than the size of <code>queries</code>, return <code>-1</code>, since we processed all the queries without reaching a zero array.</li>
<li>Initialize <code>left</code>, <code>right</code>, and <code>val</code> to the respective values of the current query.</li>
<li>If <code>right</code> is greater than or equal to <code>index</code>:
<ul>
<li>Increment <code>differenceArray[max(left, index)]</code> by <code>val</code> to update the start of the range.</li>
<li>Decrement <code>differenceArray[right + 1]</code> by <code>val</code> to update the end of the range.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>sum</code> by <code>differenceArray[index]</code>.</li>
</ul>
</li>
<li>Return <code>k</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nYxo3uqw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code> and <span class="math inline">\(M\)</span> be the size of <code>queries</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + M)\)</span></p>
<p>We iterate through each element of <code>nums</code> at most once. Within this loop, we loop through each element of <code>queries</code> at most once.</p>
<p>The program returns a value and ends when we reach the end of either of these arrays. In the worst case, we iterate through each element in <code>nums</code> and <code>queries</code> once before returning a value. As a result, this leads to a time complexity of <span class="math inline">\(O(N + M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is based on the array <code>differenceArray</code>. Here, <code>differenceArray</code> is set to hold elements from the range <code>[0, N + 1]</code> to track all the changes in <code>nums</code>. As a result, this creates a space complexity of <span class="math inline">\(O(N + 1)\)</span>, which can be simplified to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zero-array-transformation-iii/description" target="_blank" rel="noopener noreferrer">Zero Array Transformation III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of length <code>n</code> and a 2D array <code>queries</code> where <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>.</p>

<p>Each <code>queries[i]</code> represents the following action on <code>nums</code>:</p>

<ul>
	<li>Decrement the value at each index in the range <code>[l<sub>i</sub>, r<sub>i</sub>]</code> in <code>nums</code> by <strong>at most</strong><strong> </strong>1.</li>
	<li>The amount by which the value is decremented can be chosen <strong>independently</strong> for each index.</li>
</ul>

<p>A <strong>Zero Array</strong> is an array with all its elements equal to 0.</p>

<p>Return the <strong>maximum </strong>number of elements that can be removed from <code>queries</code>, such that <code>nums</code> can still be converted to a <strong>zero array</strong> using the <em>remaining</em> queries. If it is not possible to convert <code>nums</code> to a <strong>zero array</strong>, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,0,2], queries = [[0,2],[0,2],[1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>After removing <code>queries[2]</code>, <code>nums</code> can still be converted to a zero array.</p>

<ul>
	<li>Using <code>queries[0]</code>, decrement <code>nums[0]</code> and <code>nums[2]</code> by 1 and <code>nums[1]</code> by 0.</li>
	<li>Using <code>queries[1]</code>, decrement <code>nums[0]</code> and <code>nums[2]</code> by 1 and <code>nums[1]</code> by 0.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We can remove <code>queries[2]</code> and <code>queries[3]</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4], queries = [[0,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p><code>nums</code> cannot be converted to a zero array even after using all the queries.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-greedy--priority-queue">Approach: Greedy + Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>First, we consider the element at index <span class="math inline">\(0\)</span> in <span class="math inline">\(\textit{nums}\)</span>. If <span class="math inline">\(\textit{nums}[0] > 0\)</span>, we must find at least <span class="math inline">\(\textit{nums}[0]\)</span> elements in <span class="math inline">\(\textit{queries}\)</span> with left endpoints of <span class="math inline">\(0\)</span> to retain so that <span class="math inline">\(\textit{nums}[0]\)</span> can be reduced to <span class="math inline">\(0\)</span>. Now, which elements of <span class="math inline">\(\textit{nums}[0]\)</span> should we choose? Greedily, we should select those with the largest right endpoints. After this selection, we move on to <span class="math inline">\(\textit{nums}[1]\)</span>. The elements selected in the previous step may not include index <span class="math inline">\(1\)</span>, and we need to remove them. This can be accomplished using the difference array <span class="math inline">\(\textit{deltaArray}\)</span>.</p>
<p>At this point, the cumulative number of operations may not be enough to reduce <span class="math inline">\(\textit{nums}[1]\)</span> to <span class="math inline">\(0\)</span>, and we need to select elements from <span class="math inline">\(\textit{queries}\)</span>, similar to the previous step. We can select the elements with the largest right endpoints from the portion of unselected elements whose left endpoints are <span class="math inline">\(\leq 1\)</span> until the number of operations satisfies the condition to reduce <span class="math inline">\(\textit{nums}[1]\)</span> to <span class="math inline">\(0\)</span>. This calculation can be efficiently handled using a priority queue (or <span class="math inline">\(\textit{heap}\)</span>).</p>
<p>As we traverse <span class="math inline">\(\textit{nums}\)</span>, we continuously insert the right endpoints of the <span class="math inline">\(\textit{queries}\)</span> corresponding to the left endpoints into the <span class="math inline">\(\textit{heap}\)</span>. When the number of operations is insufficient, we keep extracting the largest right endpoint from the <span class="math inline">\(\textit{heap}\)</span> until the required number of operations is met. After completing the traversal, the size of the <span class="math inline">\(\textit{heap}\)</span> represents the number of <span class="math inline">\(\textit{queries}\)</span> that can be deleted.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dMuyWYij/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <span class="math inline">\(\textit{nums}\)</span> and <span class="math inline">\(m\)</span> be the length of <span class="math inline">\(\textit{queries}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m \times \log{m})\)</span>.</p>
<p>Sorting the <span class="math inline">\(\textit{queries}\)</span> takes <span class="math inline">\(O(m \log{m})\)</span> time. Each insertion and deletion from the priority queue (which tracks the endpoints) requires <span class="math inline">\(O(\log{m})\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span>.</p>
<p>We need to store both the difference array and the priority queue, which require <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(m)\)</span> space, respectively.</p>
</li>
</ul>
</div>
				</div>
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>