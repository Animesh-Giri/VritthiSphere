<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rolling hash - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>rolling hash</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">25</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Check If a String Contains All Binary Codes of Size K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Count Cells in Overlapping Horizontal and Vertical Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Count Prefix and Suffix Pairs I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Count Prefix and Suffix Pairs II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Distinct Echo Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Find Beautiful Indices in the Given Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Find Beautiful Indices in the Given Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Find Substring With Given Hash Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">K Divisible Elements Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Longest Chunked Palindrome Decomposition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Longest Common Subpath</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Longest Duplicate Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Longest Happy Prefix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Maximum Deletions on a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Maximum Length of Repeated Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Maximum Product of the Length of Two Palindromic Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Minimum Number of Valid Strings to Form Target I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Minimum Number of Valid Strings to Form Target II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Minimum Time to Revert Word to Initial State I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Minimum Time to Revert Word to Initial State II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Number of Subarrays That Match a Pattern I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Number of Subarrays That Match a Pattern II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Repeated DNA Sequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Shortest Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Sum of Scores of Built Strings</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description" target="_blank" rel="noopener noreferrer">Check If a String Contains All Binary Codes of Size K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary string <code>s</code> and an integer <code>k</code>, return <code>true</code> <em>if every binary code of length</em> <code>k</code> <em>is a substring of</em> <code>s</code>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;00110110&quot;, k = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> The binary codes of length 2 are &quot;00&quot;, &quot;01&quot;, &quot;10&quot; and &quot;11&quot;. They can be all found as substrings at indices 0, 1, 3 and 2 respectively.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0110&quot;, k = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> The binary codes of length 1 are &quot;0&quot; and &quot;1&quot;, it is clear that both exist as a substring. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0110&quot;, k = 2
<strong>Output:</strong> false
<strong>Explanation:</strong> The binary code &quot;00&quot; is of length 2 and does not exist in the array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= k &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-cells-in-overlapping-horizontal-and-vertical-substrings/description" target="_blank" rel="noopener noreferrer">Count Cells in Overlapping Horizontal and Vertical Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">matrix</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of characters and a string <code>pattern</code>.</p>

<p>A <strong data-end="264" data-start="240">horizontal substring</strong> is a contiguous sequence of characters read from left to right. If the end of a row is reached before the substring is complete, it wraps to the first column of the next row and continues as needed. You do <strong>not</strong> wrap from the bottom row back to the top.</p>

<p>A <strong data-end="484" data-start="462">vertical substring</strong> is a contiguous sequence of characters read from top to bottom. If the bottom of a column is reached before the substring is complete, it wraps to the first row of the next column and continues as needed. You do <strong>not</strong> wrap from the last column back to the first.</p>

<p>Count the number of cells in the matrix that satisfy the following condition:</p>

<ul>
	<li>The cell must be part of <strong>at least</strong> one horizontal substring and <strong>at least</strong> one vertical substring, where <strong>both</strong> substrings are equal to the given <code>pattern</code>.</li>
</ul>

<p>Return the count of these cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridtwosubstringsdrawio.png" style="width: 150px; height: 187px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;abaca&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The pattern <code>&quot;abaca&quot;</code> appears once as a horizontal substring (colored blue) and once as a vertical substring (colored red), intersecting at one cell (colored purple).</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridexample2fixeddrawio.png" style="width: 150px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;aba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The cells colored above are all part of at least one horizontal and one vertical substring matching the pattern <code>&quot;aba&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;]], pattern = &quot;a&quot;</span></p>

<p><strong>Output:</strong> 1</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= pattern.length &lt;= m * n</code></li>
	<li><code>grid</code> and <code>pattern</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-i/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i, j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 50</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to count pairs of words where one word is both a prefix and a suffix of the other. A prefix of a string is a part of the string that appears at the start, and a suffix is a part of the string that appears at the end. For example, in the word <code>&quot;ababa&quot;</code>, <code>&quot;aba&quot;</code> is both a prefix and a suffix.</p>
<p>A simple logical solution is to use a brute-force approach, which involves comparing all pairs of words and checking if one word is a prefix and a suffix of the other.</p>
<blockquote>
<p>To check if one string is a prefix or suffix of another, we can use specific built-in functions in different programming languages:</p>
<ul>
<li>In C++, the <code>find</code> function checks if a string appears at the start, and <code>rfind</code> checks if it appears at the end.</li>
<li>In Java and Python3, the <code>startsWith</code> method verifies if a string appears at the start, and the <code>endsWith</code> method checks if it appears at the end.</li>
</ul>
</blockquote>
<p>To implement this, we loop through all pairs of words (<code>i</code>, <code>j</code>) and:</p>
<ul>
<li>For each pair, if <code>str1</code> is longer than <code>str2</code>, we skip that pair because <code>str1</code> cannot be a prefix or suffix of a smaller string.</li>
<li>If <code>str1</code> is both a prefix and a suffix of <code>str2</code>, we increment our count.</li>
</ul>
<p>We repeat this process until we exhaust all possibilities.</p>
<p>This works well for small inputs but becomes inefficient for larger input sizes because of the repeated checks for each pair of words.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of the list of words and <code>count</code> as <code>0</code> to track prefix-suffix pairs.</p>
</li>
<li>
<p>Iterate over all pairs of words:</p>
<ul>
<li>For each word at index <code>i</code>, iterate over all words at index <code>j</code> where <code>j &gt; i</code>.</li>
</ul>
</li>
<li>
<p>For each pair of words (<code>word1</code> and <code>word2</code>):</p>
<ul>
<li>Skip the pair if the length of <code>word1</code> is greater than the length of <code>word2</code>.</li>
<li>Check if <code>word1</code> is both a prefix and a suffix of <code>word2</code>:
<ul>
<li>Verify if <code>word2</code> starts with <code>word1</code>.</li>
<li>Verify if <code>word2</code> ends with <code>word1</code>.</li>
</ul>
</li>
<li>If both conditions are satisfied, increment <code>count</code>.</li>
</ul>
</li>
<li>
<p>Return <code>count</code> as the total number of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5w2vLK3F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(n - i - 1\)</span> times for each iteration of the outer loop. For each pair of elements, the algorithm performs two operations:</p>
<ol>
<li>A prefix check using a substring search.</li>
<li>A suffix check using a reverse substring search.</li>
</ol>
<p>Both operations take <span class="math inline">\(O(m)\)</span> time in the worst case, where <span class="math inline">\(m\)</span> is the length of the element being processed. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm uses a fixed amount of extra space, regardless of the input size. The only additional space used is for the loop variables and the <code>count</code> variable, which do not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dual-trie">Approach 2: Dual Trie</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The main challenge in the brute force approach is repeatedly checking for prefixes and suffixes for each word pair. This brings us to the idea of improving efficiency by using a Trie, a data structure that helps with fast prefix matching.</p>
<h5 id="what-is-a-trie">What is a Trie?</h5>
<p>A Trie is a tree-like structure where each node represents a character. When we insert words into a Trie, common prefixes are shared, allowing for efficient prefix lookups. For example, if we store <code>&quot;bat&quot;</code> and <code>&quot;ball&quot;</code>, the Trie would look like this:</p>
<pre><code>      (root)
       |
       b
       |
       a
      / \
     t   l
          \
           l
</code></pre>
<p>Notice how <code>&quot;b&quot;</code> and <code>&quot;a&quot;</code> are shared to save space.</p>
<p>Tries are useful in everyday examples like autocomplete, dictionaries, and word games:</p>
<ul>
<li>Autocomplete: When you type &quot;ca&quot; on your phone, it suggests words like &quot;cat&quot;, &quot;car&quot;, or &quot;can&quot;. It does this by looking up all the words that start with &quot;ca&quot; in a Trie.</li>
<li>Dictionaries: If you’re searching for words that begin with &quot;app&quot;, a Trie quickly finds options like &quot;apple&quot;, &quot;apply&quot;, and &quot;application&quot; without going through the whole list.</li>
<li>Word Games: In games like Scrabble or Boggle, Tries help check if a word is real or suggest possible words from your letters. Some puzzles, like Sudoku, use them too.</li>
</ul>
<p>When inserting a word into the prefix Trie, we are essentially storing all possible prefixes of that word. For example, if the word is <code>&quot;abzdcabz&quot;</code>, we add the following prefixes to the Trie: [<code>&quot;a&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;abz&quot;</code>, <code>&quot;abzd&quot;</code>, <code>&quot;abzdc&quot;</code>, <code>&quot;abzdca&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdcabz&quot;</code>]. This allows us to quickly determine if any other word starts with the same prefix.</p>
<p>For suffixes, rather than directly storing and checking suffixes (which would require reversing and checking repeatedly for every comparison), we use a trick to convert them to a prefix Trie:</p>
<ol>
<li>Reverse the word.</li>
<li>Insert the reversed word into a separate Trie.</li>
</ol>
<p>By treating the reversed word as a prefix, the suffix-checking problem is reduced to a prefix-matching problem. This allows us to use the same Trie structure for both tasks.</p>
<p>With both the prefix Trie and the suffix Trie set up, we can efficiently check for valid word pairs:</p>
<ul>
<li>For a given word <code>word[i]</code>, use the prefix Trie to check if another word shares the same prefix.</li>
<li>Use the suffix Trie to check if another word shares the same suffix (by checking the reversed version of the word).</li>
</ul>
<p>Let's check if <code>&quot;abz&quot;</code> is both a prefix and a suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>First, we insert the string <code>&quot;abzdcabz&quot;</code> into a prefix Trie. This allows us to check if any prefix of a word matches the start of <code>&quot;abzdcabz&quot;</code>. Next, we reverse the string to <code>&quot;zbacdzba&quot;</code> and insert this reversed version into a suffix Trie. This enables us to check if any prefix of a word matches the reversed suffix of <code>&quot;abzdcabz&quot;</code>.</p>
<p>In this way:</p>
<ul>
<li>The prefix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;abzdcabz&quot;</code>, <code>&quot;abzdcab&quot;</code>, <code>&quot;abzdc&quot;</code>, and so on.</li>
<li>The suffix Trie for <code>&quot;abzdcabz&quot;</code> stores <code>&quot;zbacdzba&quot;</code>, <code>&quot;zbacdzb&quot;</code>, <code>&quot;zbacdz&quot;</code>, and so on.</li>
</ul>
<p>Now, we check each previous word (where <code>j &lt; i</code>). For instance, let's consider <code>&quot;abz&quot;</code> as a previous word.</p>
<p>To verify, we check whether <code>&quot;abz&quot;</code> is a prefix in the prefix Trie and whether <code>&quot;zba&quot;</code> (the reverse of <code>&quot;abz&quot;</code>) is a prefix in the suffix Trie.</p>
<p>In this case:</p>
<ul>
<li><code>&quot;abz&quot;</code> is a prefix of <code>&quot;abzdcabz&quot;</code>, and</li>
<li><code>&quot;zba&quot;</code> (the reversed <code>&quot;abz&quot;</code>) is a prefix of <code>&quot;zbacdzba&quot;</code>, the reversed string of <code>&quot;abzdcabz&quot;</code>.</li>
</ul>
<p>Thus, we count this pair as valid.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/3042/trie.json:805,355!?!</p>
<blockquote>
<p>For a more comprehensive understanding of tries, check out the <a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card 🔗</a>. This resource provides an in-depth look at the trie data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="trie-initialization">Trie Initialization:</h5>
<ul>
<li>Define a <code>Node</code> class that represents each node in the Trie. Each node contains an array <code>links[26]</code> to represent links to <code>26</code> lowercase letters (<code>a</code> - <code>z</code>).</li>
<li>Provide functions:
<ul>
<li><code>contains(c)</code>: Check if a link for character <code>c</code> exists.</li>
<li><code>put(c, node)</code>: Insert a new node for character <code>c</code>.</li>
<li><code>next(c)</code>: Get the next node for character <code>c</code>.</li>
</ul>
</li>
</ul>
<h5 id="trie-insertions--prefix-search">Trie Insertions / Prefix Search:</h5>
<ul>
<li>
<p>Define a <code>Trie</code> class which contains a root node and provides the function <code>insert(word)</code> to insert a word into the Trie and <code>startsWith(prefix)</code> for prefix search:</p>
</li>
<li>
<p><code>insert(word)</code> function:</p>
<ul>
<li>For each character in the word, check if it already exists as a link from the current node. If not, create a new node.</li>
<li>Move to the next node for each character until the entire word is inserted.</li>
</ul>
</li>
<li>
<p><code>startsWith(prefix)</code> function:</p>
<ul>
<li>Traverse the Trie from the root, following the links for each character in the prefix.</li>
<li>If a character link does not exist, return <code>false</code>, indicating the prefix doesn't exist in the Trie.</li>
<li>If the traversal finishes successfully, return <code>true</code>, indicating the prefix exists.</li>
</ul>
</li>
</ul>
<h5 id="main-algorithm-countprefixsuffixpairs">Main Algorithm (countPrefixSuffixPairs):</h5>
<ul>
<li>
<p>Initialize a counter <code>count</code> to 0.</p>
</li>
<li>
<p>For each word in <code>words</code>, do the following:</p>
<ul>
<li>Create two Tries: <code>prefixTrie</code> for storing prefixes of the word and <code>suffixTrie</code> for storing reversed suffixes.</li>
<li>Insert the word into <code>prefixTrie</code> and its reversed version into <code>suffixTrie</code>.</li>
</ul>
</li>
<li>
<p>For each word <code>words[j]</code> (where <code>j &lt; i</code>), check the following:</p>
<ul>
<li>If the length of <code>words[j]</code> is greater than <code>words[i]</code>, skip to the next <code>j</code>.</li>
<li>Extract the prefix <code>prefixWord</code> from <code>words[j]</code> and reverse it to get <code>revPrefixWord</code>.</li>
<li>Check if <code>prefixWord</code> exists in the <code>prefixTrie</code> and <code>revPrefixWord</code> exists in the <code>suffixTrie</code>:
<ul>
<li>If both are true, increment the <code>count</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>count</code> of prefix-suffix pairs.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/egLL23Vb/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of words in the input array <code>words</code>, and let <span class="math inline">\(m\)</span> be the average length of the words.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The algorithm involves a nested loop where the outer loop runs <span class="math inline">\(n\)</span> times and the inner loop runs <span class="math inline">\(i\)</span> times for each iteration of the outer loop. For each pair of words, the <code>insert</code> and <code>startsWith</code> operations are performed on the Trie. The <code>insert</code> operation takes <span class="math inline">\(O(m)\)</span> time, and the <code>startsWith</code> operation also takes <span class="math inline">\(O(m)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is determined by the space used by the Tries. Each Trie can store up to <span class="math inline">\(m\)</span> nodes (one for each character in the word), and since there are <span class="math inline">\(n\)</span> words, the total space required for the Tries is <span class="math inline">\(O(n \cdot m)\)</span>. Additionally, the algorithm uses a constant amount of extra space for variables and temporary storage, but this is dominated by the space used by the Tries.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-prefix-and-suffix-pairs-ii/description" target="_blank" rel="noopener noreferrer">Count Prefix and Suffix Pairs II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string array <code>words</code>.</p>

<p>Let&#39;s define a <strong>boolean</strong> function <code>isPrefixAndSuffix</code> that takes two strings, <code>str1</code> and <code>str2</code>:</p>

<ul>
	<li><code>isPrefixAndSuffix(str1, str2)</code> returns <code>true</code> if <code>str1</code> is <strong>both</strong> a <span data-keyword="string-prefix">prefix</span> and a <span data-keyword="string-suffix">suffix</span> of <code>str2</code>, and <code>false</code> otherwise.</li>
</ul>

<p>For example, <code>isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;)</code> is <code>true</code> because <code>&quot;aba&quot;</code> is a prefix of <code>&quot;ababa&quot;</code> and also a suffix, but <code>isPrefixAndSuffix(&quot;abc&quot;, &quot;abcd&quot;)</code> is <code>false</code>.</p>

<p>Return <em>an integer denoting the <strong>number</strong> of index pairs </em><code>(i<em>, </em>j)</code><em> such that </em><code>i &lt; j</code><em>, and </em><code>isPrefixAndSuffix(words[i], words[j])</code><em> is </em><code>true</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;aba&quot;,&quot;ababa&quot;,&quot;aa&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;a&quot;, &quot;aba&quot;) is true.
i = 0 and j = 2 because isPrefixAndSuffix(&quot;a&quot;, &quot;ababa&quot;) is true.
i = 0 and j = 3 because isPrefixAndSuffix(&quot;a&quot;, &quot;aa&quot;) is true.
i = 1 and j = 2 because isPrefixAndSuffix(&quot;aba&quot;, &quot;ababa&quot;) is true.
Therefore, the answer is 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;pa&quot;,&quot;papa&quot;,&quot;ma&quot;,&quot;mama&quot;]
<strong>Output:</strong> 2
<strong>Explanation:</strong> In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(&quot;pa&quot;, &quot;papa&quot;) is true.
i = 2 and j = 3 because isPrefixAndSuffix(&quot;ma&quot;, &quot;mama&quot;) is true.
Therefore, the answer is 2.  </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abab&quot;,&quot;ab&quot;]
<strong>Output:</strong> 0
<strong>Explanation: </strong>In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(&quot;abab&quot;, &quot;ab&quot;) is false.
Therefore, the answer is 0.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li>The sum of the lengths of all <code>words[i]</code> does not exceed <code>5 * 10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distinct-echo-substrings/description" target="_blank" rel="noopener noreferrer">Distinct Echo Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Return the number of <strong>distinct</strong> non-empty substrings of <code>text</code>&nbsp;that can be written as the concatenation of some string with itself (i.e. it can be written as <code>a + a</code>&nbsp;where <code>a</code> is some string).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;abcabcabc&quot;
<strong>Output:</strong> 3
<b>Explanation: </b>The 3 substrings are &quot;abcabc&quot;, &quot;bcabca&quot; and &quot;cabcab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;leetcodeleetcode&quot;
<strong>Output:</strong> 2
<b>Explanation: </b>The 2 substrings are &quot;ee&quot; and &quot;leetcodeleetcode&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 2000</code></li>
	<li><code>text</code>&nbsp;has only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 10</code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-substring-with-given-hash-value/description" target="_blank" rel="noopener noreferrer">Find Substring With Given Hash Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The hash of a <strong>0-indexed</strong> string <code>s</code> of length <code>k</code>, given integers <code>p</code> and <code>m</code>, is computed using the following function:</p>

<ul>
	<li><code>hash(s, p, m) = (val(s[0]) * p<sup>0</sup> + val(s[1]) * p<sup>1</sup> + ... + val(s[k-1]) * p<sup>k-1</sup>) mod m</code>.</li>
</ul>

<p>Where <code>val(s[i])</code> represents the index of <code>s[i]</code> in the alphabet from <code>val(&#39;a&#39;) = 1</code> to <code>val(&#39;z&#39;) = 26</code>.</p>

<p>You are given a string <code>s</code> and the integers <code>power</code>, <code>modulo</code>, <code>k</code>, and <code>hashValue.</code> Return <code>sub</code>,<em> the <strong>first</strong> <strong>substring</strong> of </em><code>s</code><em> of length </em><code>k</code><em> such that </em><code>hash(sub, power, modulo) == hashValue</code>.</p>

<p>The test cases will be generated such that an answer always <strong>exists</strong>.</p>

<p>A <b>substring</b> is a contiguous non-empty sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, power = 7, modulo = 20, k = 2, hashValue = 0
<strong>Output:</strong> &quot;ee&quot;
<strong>Explanation:</strong> The hash of &quot;ee&quot; can be computed to be hash(&quot;ee&quot;, 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. 
&quot;ee&quot; is the first substring of length 2 with hashValue 0. Hence, we return &quot;ee&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;fbxzaad&quot;, power = 31, modulo = 100, k = 3, hashValue = 32
<strong>Output:</strong> &quot;fbx&quot;
<strong>Explanation:</strong> The hash of &quot;fbx&quot; can be computed to be hash(&quot;fbx&quot;, 31, 100) = (6 * 1 + 2 * 31 + 24 * 31<sup>2</sup>) mod 100 = 23132 mod 100 = 32. 
The hash of &quot;bxz&quot; can be computed to be hash(&quot;bxz&quot;, 31, 100) = (2 * 1 + 24 * 31 + 26 * 31<sup>2</sup>) mod 100 = 25732 mod 100 = 32. 
&quot;fbx&quot; is the first substring of length 3 with hashValue 32. Hence, we return &quot;fbx&quot;.
Note that &quot;bxz&quot; also has a hash of 32 but it appears later than &quot;fbx&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= power, modulo &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= hashValue &lt; modulo</code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
	<li>The test cases are generated such that an answer always <strong>exists</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-divisible-elements-subarrays/description" target="_blank" rel="noopener noreferrer">K Divisible Elements Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and two integers <code>k</code> and <code>p</code>, return <em>the number of <strong>distinct subarrays,</strong> which have <strong>at most</strong></em> <code>k</code> <em>elements </em>that are <em>divisible by</em> <code>p</code>.</p>

<p>Two arrays <code>nums1</code> and <code>nums2</code> are said to be <strong>distinct</strong> if:</p>

<ul>
	<li>They are of <strong>different</strong> lengths, or</li>
	<li>There exists <strong>at least</strong> one index <code>i</code> where <code>nums1[i] != nums2[i]</code>.</li>
</ul>

<p>A <strong>subarray</strong> is defined as a <strong>non-empty</strong> contiguous sequence of elements in an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [<u><strong>2</strong></u>,3,3,<u><strong>2</strong></u>,<u><strong>2</strong></u>], k = 2, p = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The elements at indices 0, 3, and 4 are divisible by p = 2.
The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:
[2], [2,3], [2,3,3], [2,3,3,2], [3], [3,3], [3,3,2], [3,3,2,2], [3,2], [3,2,2], and [2,2].
Note that the subarrays [2] and [3] occur more than once in nums, but they should each be counted only once.
The subarray [2,3,3,2,2] should not be counted because it has 3 elements that are divisible by 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 4, p = 1
<strong>Output:</strong> 10
<strong>Explanation:</strong>
All element of nums are divisible by p = 1.
Also, every subarray of nums will have at most 4 elements that are divisible by 1.
Since all subarrays are distinct, the total number of subarrays satisfying all the constraints is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 200</code></li>
	<li><code>1 &lt;= nums[i], p &lt;= 200</code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<p>Can you solve this problem in O(n<sup>2</sup>) time complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-chunked-palindrome-decomposition/description" target="_blank" rel="noopener noreferrer">Longest Chunked Palindrome Decomposition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>text</code>. You should split it to k substrings <code>(subtext<sub>1</sub>, subtext<sub>2</sub>, ..., subtext<sub>k</sub>)</code> such that:</p>

<ul>
	<li><code>subtext<sub>i</sub></code> is a <strong>non-empty</strong> string.</li>
	<li>The concatenation of all the substrings is equal to <code>text</code> (i.e., <code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code>).</li>
	<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code> for all valid values of <code>i</code> (i.e., <code>1 &lt;= i &lt;= k</code>).</li>
</ul>

<p>Return the largest possible value of <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;merchant&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can split the string on &quot;(merchant)&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;antaprezatepzapreanta&quot;
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can split the string on &quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 1000</code></li>
	<li><code>text</code> consists only of lowercase English characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-common-subpath/description" target="_blank" rel="noopener noreferrer">Longest Common Subpath</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a country of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. In this country, there is a road connecting <b>every pair</b> of cities.</p>

<p>There are <code>m</code> friends numbered from <code>0</code> to <code>m - 1</code> who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city <strong>more than once</strong>, but the same city will not be listed consecutively.</p>

<p>Given an integer <code>n</code> and a 2D integer array <code>paths</code> where <code>paths[i]</code> is an integer array representing the path of the <code>i<sup>th</sup></code> friend, return <em>the length of the <strong>longest common subpath</strong> that is shared by <strong>every</strong> friend&#39;s path, or </em><code>0</code><em> if there is no common subpath at all</em>.</p>

<p>A <strong>subpath</strong> of a path is a contiguous sequence of cities within that path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 5, paths = [[0,1,<u>2,3</u>,4],
                       [<u>2,3</u>,4],
                       [4,0,1,<u>2,3</u>]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest common subpath is [2,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, paths = [[0],[1],[2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no common subpath shared by the three paths.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 5, paths = [[<u>0</u>,1,2,3,4],
                       [4,3,2,1,<u>0</u>]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>m == paths.length</code></li>
	<li><code>2 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>sum(paths[i].length) &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= paths[i][j] &lt; n</code></li>
	<li>The same city is not listed multiple times consecutively in <code>paths[i]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-duplicate-substring/description" target="_blank" rel="noopener noreferrer">Longest Duplicate Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, consider all <em>duplicated substrings</em>: (contiguous) substrings of s that occur 2 or more times.&nbsp;The occurrences&nbsp;may overlap.</p>

<p>Return <strong>any</strong> duplicated&nbsp;substring that has the longest possible length.&nbsp;If <code>s</code> does not have a duplicated substring, the answer is <code>&quot;&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "banana"
<strong>Output:</strong> "ana"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcd"
<strong>Output:</strong> ""
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-happy-prefix/description" target="_blank" rel="noopener noreferrer">Longest Happy Prefix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A string is called a <strong>happy prefix</strong> if is a <strong>non-empty</strong> prefix which is also a suffix (excluding itself).</p>

<p>Given a string <code>s</code>, return <em>the <strong>longest happy prefix</strong> of</em> <code>s</code>. Return an empty string <code>&quot;&quot;</code> if no such prefix exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;level&quot;
<strong>Output:</strong> &quot;l&quot;
<strong>Explanation:</strong> s contains 4 prefix excluding itself (&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;), and suffix (&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;). The largest prefix which is also suffix is given by &quot;l&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababab&quot;
<strong>Output:</strong> &quot;abab&quot;
<strong>Explanation:</strong> &quot;abab&quot; is the largest prefix which is also suffix. They can overlap in the original string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-deletions-on-a-string/description" target="_blank" rel="noopener noreferrer">Maximum Deletions on a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting of only lowercase English letters. In one operation, you can:</p>

<ul>
	<li>Delete <strong>the entire string</strong> <code>s</code>, or</li>
	<li>Delete the <strong>first</strong> <code>i</code> letters of <code>s</code> if the first <code>i</code> letters of <code>s</code> are <strong>equal</strong> to the following <code>i</code> letters in <code>s</code>, for any <code>i</code> in the range <code>1 &lt;= i &lt;= s.length / 2</code>.</li>
</ul>

<p>For example, if <code>s = &quot;ababc&quot;</code>, then in one operation, you could delete the first two letters of <code>s</code> to get <code>&quot;abc&quot;</code>, since the first two letters of <code>s</code> and the following two letters of <code>s</code> are both equal to <code>&quot;ab&quot;</code>.</p>

<p>Return <em>the <strong>maximum</strong> number of operations needed to delete all of </em><code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcdabc&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- Delete the first 3 letters (&quot;abc&quot;) since the next 3 letters are equal. Now, s = &quot;abcdabc&quot;.
- Delete all the letters.
We used 2 operations so return 2. It can be proven that 2 is the maximum number of operations needed.
Note that in the second operation we cannot delete &quot;abc&quot; again because the next occurrence of &quot;abc&quot; does not happen in the next 3 letters.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaabaab&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong>
- Delete the first letter (&quot;a&quot;) since the next letter is equal. Now, s = &quot;aabaab&quot;.
- Delete the first 3 letters (&quot;aab&quot;) since the next 3 letters are equal. Now, s = &quot;aab&quot;.
- Delete the first letter (&quot;a&quot;) since the next letter is equal. Now, s = &quot;ab&quot;.
- Delete all the letters.
We used 4 operations so return 4. It can be proven that 4 is the maximum number of operations needed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaaaa&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> In each operation, we can delete the first letter of s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 4000</code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-length-of-repeated-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Length of Repeated Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The repeated subarray with maximum length is [0,0,0,0,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-brute-force-with-initial-character-map-time-limit-exceeded">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>In a typical brute force, for all starting indices <code>i</code> of <code>A</code> and <code>j</code> of <code>B</code>, we will check for the longest matching subarray <code>A[i: i+k] == B[j: j+k]</code> of length <code>k</code>. This would look roughly like the following pseudocode:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> [<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">..</span> A<span style="color:#000;font-weight:bold">.</span>length <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]:
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> [<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">..</span> B<span style="color:#000;font-weight:bold">.</span>length <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>]:
</span></span><span style="display:flex;"><span>        k <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> (A[i <span style="color:#000;font-weight:bold">+</span> k] <span style="color:#000;font-weight:bold">==</span> B[j <span style="color:#000;font-weight:bold">+</span> k]): k <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span> <span style="color:#998;font-style:italic">#and i + k &lt; A.length etc.</span>
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">max</span>(ans, k)
</span></span></code></pre><p>Our insight is that in typical cases, most of the time <code>A[i] != B[j]</code>.  We could instead keep a hashmap <code>Bstarts[A[i]] = all j such that B[j] == A[i]</code>, and only loop through those in our <code>j</code> loop.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        Bstarts <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>defaultdict(<span style="color:#0086b3">list</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> j, y <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(B):
</span></span><span style="display:flex;"><span>            Bstarts[y]<span style="color:#000;font-weight:bold">.</span>append(j)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i, x <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(A):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> Bstarts[x]:
</span></span><span style="display:flex;"><span>                k <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">while</span> i <span style="color:#000;font-weight:bold">+</span> k <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">and</span> j <span style="color:#000;font-weight:bold">+</span> k <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">and</span> A[i <span style="color:#000;font-weight:bold">+</span> k] <span style="color:#000;font-weight:bold">==</span> B[j <span style="color:#000;font-weight:bold">+</span> k]:
</span></span><span style="display:flex;"><span>                    k <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">max</span>(ans, k)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        Map<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">,</span> ArrayList<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> Bstarts <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashMap<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">&lt;</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> j<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">computeIfAbsent</span><span style="color:#000;font-weight:bold">(</span>B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">],</span> x <span style="color:#000;font-weight:bold">-&gt;</span> <span style="color:#000;font-weight:bold">new</span> ArrayList<span style="color:#000;font-weight:bold">()).</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>j<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">containsKey</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j<span style="color:#000;font-weight:bold">:</span> Bstarts<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> k <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">+</span>k <span style="color:#000;font-weight:bold">&lt;</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> j<span style="color:#000;font-weight:bold">+</span>k <span style="color:#000;font-weight:bold">&lt;</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">+</span>k<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">+</span>k<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    k<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">max</span><span style="color:#000;font-weight:bold">(</span>ans<span style="color:#000;font-weight:bold">,</span> k<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M*N*\min(M, N))\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>. The worst case is when all the elements are equal.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the space used by <code>Bstarts</code> (Of course, we could amend our algorithm to make this <span class="math inline">\(O(\min(M, N))\)</span>).</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search-with-naive-check-time-limit-exceeded">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</h3>
<p><strong>Intuition</strong></p>
<p>If there is a length <code>k</code> subarray common to <code>A</code> and <code>B</code>, then there is a length <code>j &lt;= k</code> subarray as well.</p>
<p>Let <code>check(length)</code> be the answer to the question &quot;Is there a subarray with <code>length</code> length, common to <code>A</code> and <code>B</code>?&quot;  This is a function with a range that must take the form <code>[True, True, ..., True, False, False, ..., False]</code> with at least one <code>True</code>.  We can binary search on this function.</p>
<p><strong>Algorithm</strong></p>
<p>Focusing on the binary search, our invariant is that <code>check(hi)</code> will always be <code>False</code>. We'll start with <code>hi = min(len(A), len(B)) + 1</code>, clearly <code>check(hi) is False</code>.</p>
<p>Now we perform our check in the midpoint <code>mi</code> of <code>lo</code> and <code>hi</code>. When it is possible, then <code>lo = mi + 1</code>, and when it isn't, <code>hi = mi</code>. This maintains the invariant. At the end of our binary search, <code>hi == lo</code> and <code>lo</code> is the lowest value such that <code>check(lo) is False</code>, so we want <code>lo - 1</code>.</p>
<p>As for the check itself, we can naively check whether any <code>A[i:i+k] == B[j:j+k]</code> using set structures.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">check</span>(length):
</span></span><span style="display:flex;"><span>            seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>(<span style="color:#0086b3">tuple</span>(A[i:i<span style="color:#000;font-weight:bold">+</span>length]) 
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">-</span> length <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">any</span>(<span style="color:#0086b3">tuple</span>(B[j:j<span style="color:#000;font-weight:bold">+</span>length]) <span style="color:#000;font-weight:bold">in</span> seen 
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">-</span> length <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        lo, hi <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, <span style="color:#0086b3">min</span>(<span style="color:#0086b3">len</span>(A), <span style="color:#0086b3">len</span>(B)) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> lo <span style="color:#000;font-weight:bold">&lt;</span> hi:
</span></span><span style="display:flex;"><span>            mi <span style="color:#000;font-weight:bold">=</span> (lo <span style="color:#000;font-weight:bold">+</span> hi) <span style="color:#000;font-weight:bold">//</span> <span style="color:#099">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> check(mi):
</span></span><span style="display:flex;"><span>                lo <span style="color:#000;font-weight:bold">=</span> mi <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                hi <span style="color:#000;font-weight:bold">=</span> mi
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> lo <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">check</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> length<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        Set<span style="color:#000;font-weight:bold">&lt;</span>String<span style="color:#000;font-weight:bold">&gt;</span> seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">+</span> length <span style="color:#000;font-weight:bold">&lt;=</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            seen<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toString</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">copyOfRange</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">,</span> i<span style="color:#000;font-weight:bold">,</span> i<span style="color:#000;font-weight:bold">+</span>length<span style="color:#000;font-weight:bold">)));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">+</span> length <span style="color:#000;font-weight:bold">&lt;=</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>j<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>seen<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toString</span><span style="color:#000;font-weight:bold">(</span>Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">copyOfRange</span><span style="color:#000;font-weight:bold">(</span>B<span style="color:#000;font-weight:bold">,</span> j<span style="color:#000;font-weight:bold">,</span> j<span style="color:#000;font-weight:bold">+</span>length<span style="color:#000;font-weight:bold">))))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">false</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> lo <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> hi <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">,</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>lo <span style="color:#000;font-weight:bold">&lt;</span> hi<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> mi <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">(</span>lo <span style="color:#000;font-weight:bold">+</span> hi<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">/</span> 2<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>check<span style="color:#000;font-weight:bold">(</span>mi<span style="color:#000;font-weight:bold">,</span> A<span style="color:#000;font-weight:bold">,</span> B<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                lo <span style="color:#000;font-weight:bold">=</span> mi <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span> hi <span style="color:#000;font-weight:bold">=</span> mi<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> lo <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((M + N) * \min(M, N) * \log{(\min(M, N))})\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>. The log factor comes from the binary search. The complexity of our naive check of a given <span class="math inline">\(\text{length}\)</span> is <span class="math inline">\(O((M+N) * \text{length})\)</span>, as we will create the <code>seen</code> strings with complexity <span class="math inline">\(O(M * \text{length})\)</span>, then search for them with complexity <span class="math inline">\(O(N * \text{length})\)</span>, and our total complexity when performing our <code>check</code> is the addition of these two.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M^2)\)</span>, the space used by <code>seen</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-accepted">Approach #3: Dynamic Programming [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Since a common subarray of <code>A</code> and <code>B</code> must start at some <code>A[i]</code> and <code>B[j]</code>, let <code>dp[i][j]</code> be the longest common prefix of <code>A[i:]</code> and <code>B[j:]</code>. Whenever <code>A[i] == B[j]</code>, we know <code>dp[i][j] = dp[i+1][j+1] + 1</code>.  Also, the answer is <code>max(dp[i][j])</code> over all <code>i, j</code>.</p>
<p>We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in <code>dp</code> for any larger <code>i, j</code>.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">findLength</span>(<span style="color:#999">self</span>, A, B):
</span></span><span style="display:flex;"><span>        memo <span style="color:#000;font-weight:bold">=</span> [[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">*</span> (<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>) <span style="color:#000;font-weight:bold">for</span> _ <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>)]
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(A) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(<span style="color:#0086b3">len</span>(B) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> A[i] <span style="color:#000;font-weight:bold">==</span> B[j]:
</span></span><span style="display:flex;"><span>                    memo[i][j] <span style="color:#000;font-weight:bold">=</span> memo[i <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>][j <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">max</span>(<span style="color:#0086b3">max</span>(row) <span style="color:#000;font-weight:bold">for</span> row <span style="color:#000;font-weight:bold">in</span> memo)
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">findLength</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> A<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> B<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[][]</span> memo <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[</span>A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">][</span>B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> A<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">--</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> B<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">;</span> j <span style="color:#000;font-weight:bold">&gt;=</span> 0<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">--</span>j<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>A<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> B<span style="color:#000;font-weight:bold">[</span>j<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>ans <span style="color:#000;font-weight:bold">&lt;</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">])</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                        ans <span style="color:#000;font-weight:bold">=</span> memo<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">][</span>j<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M*N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>A, B</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M*N)\)</span>, the space used by <code>dp</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-binary-search-with-rolling-hash-accepted">Approach #4: Binary Search with Rolling Hash [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>As in <em>Approach #2</em>, we will binary search for the answer.  However, we will use a <em>rolling hash</em> (Rabin-Karp algorithm) to store hashes in our set structure.</p>
<p><strong>Algorithm</strong></p>
<p>For some prime <span class="math inline">\(p\)</span>, consider the following function modulo some prime modulus <span class="math inline">\(\mathcal{M}\)</span>:</p>
<p><span class="math display">\[
Notably, $$\text{hash}(S[1:] + x) = \frac{(\text{hash}(S) - S[0])}{p} + p^{n-1} x$$. This shows we can get the hash of all $$A[i:i+\text{guess}]$$ in linear time.  We will also use the fact that $$p^{-1} = p^{\mathcal{M}-2} \mod \mathcal{M}$$.

For every `i >= length - 1`, we will want to record the hash of `A[i-length+1], A[i-length+2], ..., A[i]`. After, we will truncate the first element by `h = (h - A[i - (length - 1)]) * Pinv % MOD` to get ready to add the next element.

To make our algorithm airtight, we also make a naive check when our work with rolling hashes says that we have found a match.

```python
class Solution(object):
    def findLength(self, A, B):
        P, MOD = 113, 10**9 + 7
        Pinv = pow(P, MOD - 2, MOD)
        def check(guess):
            def rolling(A, length):
                if length == 0:
                    yield 0, 0
                    return

                h, power = 0, 1
                for i, x in enumerate(A):
                    h = (h + x * power) % MOD
                    if i < length - 1:
                        power = (power * P) % MOD
                    else:
                        yield h, i - (length - 1)
                        h = (h - A[i - (length - 1)]) * Pinv % MOD

            hashes = collections.defaultdict(list)
            for ha, start in rolling(A, guess):
                hashes[ha].append(start)
            for ha, start in rolling(B, guess):
                iarr = hashes.get(ha, [])
                if any(A[i: i + guess] == B[start: start + guess] for i in iarr):
                    return True
            return False

        lo, hi = 0, min(len(A), len(B)) + 1
        while lo < hi:
            mi = (lo + hi) // 2
            if check(mi):
                lo = mi + 1
            else:
                hi = mi
        return lo - 1
```

**Java**
```java
import java.math.BigInteger;

class Solution {
    int P = 113;
    int MOD = 1_000_000_007;
    int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();

    private int[] rolling(int[] source, int length) {
        int[] ans = new int[source.length - length + 1];
        long h = 0, power = 1;
        if (length == 0) {
            return and;
        }
        for (int i = 0; i < source.length; ++i) {
            h = (h + source[i] * power) % MOD;
            if (i < length - 1) {
                power = (power * P) % MOD;
            } else {
                ans[i - (length - 1)] = (int) h;
                h = (h - source[i - (length - 1)]) * Pinv % MOD;
                if (h < 0) h += MOD;
            }
        }
        return ans;
    }

    private boolean check(int guess, int[] A, int[] B) {
        Map<Integer, List<Integer>> hashes = new HashMap();
        int k = 0;
        for (int x: rolling(A, guess)) {
            hashes.computeIfAbsent(x, z -> new ArrayList()).add(k++);
        }
        int j = 0;
        for (int x: rolling(B, guess)) {
            for (int i: hashes.getOrDefault(x, new ArrayList<Integer>()))
                if (Arrays.equals(Arrays.copyOfRange(A, i, i+guess),
                                  Arrays.copyOfRange(B, j, j+guess))) {
                    return true;
                }
            j++;
        }
        return false;
    }

    public int findLength(int[] A, int[] B) {
        int lo = 0, hi = Math.min(A.length, B.length) + 1;
        while (lo < hi) {
            int mi = (lo + hi) / 2;
            if (check(mi, A, B)) {
                lo = mi + 1;
            }
            else hi = mi;
        }
        return lo - 1;
    }
}
```

**Complexity Analysis**

* Time Complexity: $$O((M+N) * \log{(\min(M, N))})$$, where $$M, N$$ are the lengths of `A, B`. The log factor contributed by the binary search while creating the rolling hashes is $$O(M + N)$$. The checks for duplicate hashes are $$O(1)$$. If we perform a naive check to make sure our answer is correct, it adds a factor of $$O(\min(M, N))$$ to our cost of `check`, which keeps the complexity the same.

* Space Complexity: $$O(M)$$, the space used to store `hashes` and the subarrays in our final naive check.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/description" target="_blank" rel="noopener noreferrer">Maximum Product of the Length of Two Palindromic Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> and are tasked with finding two <strong>non-intersecting palindromic </strong>substrings of <strong>odd</strong> length such that the product of their lengths is maximized.</p>

<p>More formally, you want to choose four integers <code>i</code>, <code>j</code>, <code>k</code>, <code>l</code> such that <code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code> and both the substrings <code>s[i...j]</code> and <code>s[k...l]</code> are palindromes and have odd lengths. <code>s[i...j]</code> denotes a substring from index <code>i</code> to index <code>j</code> <strong>inclusive</strong>.</p>

<p>Return <em>the <strong>maximum</strong> possible product of the lengths of the two non-intersecting palindromic substrings.</em></p>

<p>A <strong>palindrome</strong> is a string that is the same forward and backward. A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababbb&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> Substrings &quot;aba&quot; and &quot;bbb&quot; are palindromes with odd length. product = 3 * 3 = 9.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;zaaaxbbby&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong> Substrings &quot;aaa&quot; and &quot;bbb&quot; are palindromes with odd length. product = 3 * 3 = 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>3</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>3</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-valid-strings-to-form-target-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Valid Strings to Form Target II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code> and a string <code>target</code>.</p>

<p>A string <code>x</code> is called <strong>valid</strong> if <code>x</code> is a <span data-keyword="string-prefix">prefix</span> of <strong>any</strong> string in <code>words</code>.</p>

<p>Return the <strong>minimum</strong> number of <strong>valid</strong> strings that can be <em>concatenated</em> to form <code>target</code>. If it is <strong>not</strong> possible to form <code>target</code>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abc&quot;,&quot;aaaaa&quot;,&quot;bcdef&quot;], target = &quot;aabcdabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 2 of <code>words[1]</code>, i.e. <code>&quot;aa&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[2]</code>, i.e. <code>&quot;bcd&quot;</code>.</li>
	<li>Prefix of length 3 of <code>words[0]</code>, i.e. <code>&quot;abc&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abababab&quot;,&quot;ab&quot;], target = &quot;ababaababa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The target string can be formed by concatenating:</p>

<ul>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
	<li>Prefix of length 5 of <code>words[0]</code>, i.e. <code>&quot;ababa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;abcdef&quot;], target = &quot;xyz&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The input is generated such that <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>target</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-i/description" target="_blank" rel="noopener noreferrer">Minimum Time to Revert Word to Initial State I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>word</code> and an integer <code>k</code>.</p>

<p>At every second, you must perform the following operations:</p>

<ul>
	<li>Remove the first <code>k</code> characters of <code>word</code>.</li>
	<li>Add any <code>k</code> characters to the end of <code>word</code>.</li>
</ul>

<p><strong>Note</strong> that you do not necessarily need to add the same characters that you removed. However, you must perform <strong>both</strong> operations at every second.</p>

<p>Return <em>the <strong>minimum</strong> time greater than zero required for</em> <code>word</code> <em>to revert to its <strong>initial</strong> state</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;aba&quot; from the prefix of word, and add characters &quot;bac&quot; to the end of word. Thus, word becomes equal to &quot;cababac&quot;.
At the 2nd second, we remove characters &quot;cab&quot; from the prefix of word, and add &quot;aba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 4
<strong>Output:</strong> 1
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;abac&quot; from the prefix of word, and add characters &quot;caba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcbabcd&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.
After 4 seconds, word becomes equal to &quot;abcbabcd&quot; and reverts to its initial state.
It can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 50 </code></li>
	<li><code>1 &lt;= k &lt;= word.length</code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-revert-word-to-initial-state-ii/description" target="_blank" rel="noopener noreferrer">Minimum Time to Revert Word to Initial State II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>word</code> and an integer <code>k</code>.</p>

<p>At every second, you must perform the following operations:</p>

<ul>
	<li>Remove the first <code>k</code> characters of <code>word</code>.</li>
	<li>Add any <code>k</code> characters to the end of <code>word</code>.</li>
</ul>

<p><strong>Note</strong> that you do not necessarily need to add the same characters that you removed. However, you must perform <strong>both</strong> operations at every second.</p>

<p>Return <em>the <strong>minimum</strong> time greater than zero required for</em> <code>word</code> <em>to revert to its <strong>initial</strong> state</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;aba&quot; from the prefix of word, and add characters &quot;bac&quot; to the end of word. Thus, word becomes equal to &quot;cababac&quot;.
At the 2nd second, we remove characters &quot;cab&quot; from the prefix of word, and add &quot;aba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abacaba&quot;, k = 4
<strong>Output:</strong> 1
<strong>Explanation:</strong> At the 1st second, we remove characters &quot;abac&quot; from the prefix of word, and add characters &quot;caba&quot; to the end of word. Thus, word becomes equal to &quot;abacaba&quot; and reverts to its initial state.
It can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcbabcd&quot;, k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.
After 4 seconds, word becomes equal to &quot;abcbabcd&quot; and reverts to its initial state.
It can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= word.length</code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description" target="_blank" rel="noopener noreferrer">Number of Subarrays That Match a Pattern I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code>, and a <strong>0-indexed</strong> integer array <code>pattern</code> of size <code>m</code> consisting of integers <code>-1</code>, <code>0</code>, and <code>1</code>.</p>

<p>A <span data-keyword="subarray">subarray</span> <code>nums[i..j]</code> of size <code>m + 1</code> is said to match the <code>pattern</code> if the following conditions hold for each element <code>pattern[k]</code>:</p>

<ul>
	<li><code>nums[i + k + 1] &gt; nums[i + k]</code> if <code>pattern[k] == 1</code>.</li>
	<li><code>nums[i + k + 1] == nums[i + k]</code> if <code>pattern[k] == 0</code>.</li>
	<li><code>nums[i + k + 1] &lt; nums[i + k]</code> if <code>pattern[k] == -1</code>.</li>
</ul>

<p>Return <em>the<strong> count</strong> of subarrays in</em> <code>nums</code> <em>that match the</em> <code>pattern</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], pattern = [1,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == pattern.length &lt; n</code></li>
	<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-that-match-a-pattern-ii/description" target="_blank" rel="noopener noreferrer">Number of Subarrays That Match a Pattern II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code>, and a <strong>0-indexed</strong> integer array <code>pattern</code> of size <code>m</code> consisting of integers <code>-1</code>, <code>0</code>, and <code>1</code>.</p>

<p>A <span data-keyword="subarray">subarray</span> <code>nums[i..j]</code> of size <code>m + 1</code> is said to match the <code>pattern</code> if the following conditions hold for each element <code>pattern[k]</code>:</p>

<ul>
	<li><code>nums[i + k + 1] &gt; nums[i + k]</code> if <code>pattern[k] == 1</code>.</li>
	<li><code>nums[i + k + 1] == nums[i + k]</code> if <code>pattern[k] == 0</code>.</li>
	<li><code>nums[i + k + 1] &lt; nums[i + k]</code> if <code>pattern[k] == -1</code>.</li>
</ul>

<p>Return <em>the<strong> count</strong> of subarrays in</em> <code>nums</code> <em>that match the</em> <code>pattern</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6], pattern = [1,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
<strong>Output:</strong> 2
<strong>Explanation: </strong>Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= m == pattern.length &lt; n</code></li>
	<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/repeated-dna-sequences/description" target="_blank" rel="noopener noreferrer">Repeated DNA Sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>

<ul>
	<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>
</ul>

<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>

<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
<strong>Output:</strong> ["AAAAACCCCC","CCCCCAAAAA"]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "AAAAAAAAAAAAA"
<strong>Output:</strong> ["AAAAAAAAAA"]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-palindrome/description" target="_blank" rel="noopener noreferrer">Shortest Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword="palindrome-string">palindrome</span> by adding characters in front of it.</p>

<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "aacecaaa"
<strong>Output:</strong> "aaacecaaa"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcd"
<strong>Output:</strong> "dcbabcd"
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code>. Our task is to build the smallest palindrome by adding characters to the beginning of <code>s</code>.</p>
<p>To solve this, we can reframe the problem as finding the longest palindromic substring that starts from the index <code>0</code>. Once we know the length of this substring, we can create the shortest palindrome by appending the reverse of the remaining part of the string to the original string to make <code>s</code> a complete palindrome.</p>
<p>For instance, consider the string <code>s = &quot;aacecaaa&quot;</code>. Here, the longest palindromic prefix is <code>&quot;aacecaa&quot;</code>(starts at index <code>0</code>). The remaining part of the string is just the last <code>&quot;a&quot;</code>. To create the smallest palindrome, we reverse this remaining part and add it to the front of the original string, resulting in <code>&quot;aaacecaaa&quot;</code>, which is a palindrome.</p>
<p>Another example is <code>s = &quot;abcd&quot;</code>, where the longest palindromic prefix is just the first character <code>&quot;a&quot;</code>. The remaining part, <code>&quot;bcd&quot;</code>, is not a palindrome. By reversing <code>&quot;bcd&quot;</code> and adding it to the start, we get <code>&quot;dcbabcd&quot;</code>, which is the smallest palindrome that can be formed from the original string. This way, we can find the shortest palindrome by adding only the necessary characters to the front of the string.</p>
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>As we know, a palindrome reads the same forwards and backwards. Therefore, the challenge is to identify the longest prefix of the original string that can be extended to a full palindrome by only adding characters at the start.</p>
<p>First, we need to find out which part of the string is already a palindrome. So, we check the original string and see how much of it matches the end of its reversed version. This helps us figure out the longest palindromic prefix.</p>
<p>To do this, we look at different prefixes of the original string and compare them to suffixes of the reversed string. If a prefix matches a suffix of the reversed string, it’s part of a palindrome.</p>
<p>Once we find the longest palindromic prefix, we need to reverse the rest of the string (the part not included in the prefix) and add this reversed part to the start of the original string. This gives us the shortest possible palindrome.</p>
<p>For example: Let’s take the string <code>&quot;abcbabcab&quot;</code>. We reverse the string to get <code>&quot;bacbabcba&quot;</code>. By comparing prefixes of <code>&quot;abcbabcab&quot;</code> with suffixes of <code>&quot;bacbabcba&quot;</code>, we find that the longest prefix <code>&quot;abcba&quot;</code> matches with the suffix <code>&quot;abcba&quot;</code> in the reversed string. This is a palindrome.</p>
<p>To form the shortest palindrome, we then need to reverse the remaining part of the original string that doesn’t overlap with this prefix. In our example, the remaining part is <code>&quot;bcab&quot;</code>. Reversing <code>&quot;bcab&quot;</code> gives us <code>&quot;bacb&quot;</code>. Adding this to the start of the original string results in <code>&quot;bacbabcbabcab&quot;</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>length</code> with the length of the string <code>s</code>.</p>
</li>
<li>
<p>Reverse the string <code>s</code> to get <code>reversedString</code>.</p>
</li>
<li>
<p>Iterate through the string from <code>0</code> to <code>length - 1</code>:</p>
<ul>
<li>For each index <code>i</code>, check if the substring <code>s.substring(0, length - i)</code> (i.e., the prefix of <code>s</code> up to <code>length - i</code>) is equal to the substring <code>reversedString.substring(i)</code> (i.e., the suffix of <code>reversedString</code> starting from <code>i</code>).</li>
<li>If they are equal, it means the prefix of <code>s</code> is a palindrome:
<ul>
<li>Return the concatenation of <code>reversedString.substring(0, i)</code> (i.e., the characters in <code>reversedString</code> before <code>i</code>) and the original string <code>s</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no valid prefix is found that satisfies the condition, return an empty string <code>&quot;&quot;</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p><strong>Note:</strong> The C++ code gives MLE because <code>std::string</code> allocates fresh heap memory every time you call <code>substr</code>, which consumes a lot of memory. Repeated allocations quickly exceed the memory limit.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/E4fU8VG9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <span class="math inline">\(s\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The reversal of the string <code>s</code> involves traversing the string once, which has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>In the loop, for each iteration, we check if the substring of length <span class="math inline">\(n - i\)</span> of <code>s</code> matches the substring of length <span class="math inline">\(n - i\)</span> of the reversed string. Each check involves string operations that are linear in the length of the substring being compared. Thus, for each iteration <span class="math inline">\(i\)</span>, the comparison is <span class="math inline">\(O(n - i)\)</span>. Since <span class="math inline">\(i\)</span> ranges from 0 to <span class="math inline">\(n - 1\)</span>, the total time complexity of the palindrome check part can be expressed as the sum of comparisons of decreasing lengths. This sum is roughly <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Combining these operations, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating the reversed string involves additional space proportional to the length of the input string, i.e., <span class="math inline">\(O(n)\)</span>.</p>
<p>The substring operations in the <code>for</code> loop do not require additional space proportional to the length of the string but do create new string objects temporarily, which is still <span class="math inline">\(O(n)\)</span> space for each substring.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we observe that we need to identify the longest palindromic prefix of a string. To do this, we can now use a method involving two pointers. This method is a bit more efficient compared to checking every possible substring, which would take longer.</p>
<p>Let's consider an example string: <code>&quot;abcbabcaba&quot;</code>. We use two pointers, <code>left</code> and <code>right</code>. We start by setting <code>left</code> to <code>0</code>. Then, we move the <code>right</code> pointer from the end of the string to the beginning. Each time the characters at <code>left</code> and <code>right</code> match, we increment <code>left</code>.</p>
<p>By following this process, we narrow our search to the substring from the beginning of the string up to <code>left</code>. This substring will always include the longest palindromic prefix.</p>
<ul>
<li>If the entire string were a perfect palindrome, the <code>left</code> pointer would move through the entire length of the string, reaching the end (<code>n</code> times).</li>
<li>If the string isn’t a perfect palindrome, the <code>left</code> pointer will still move forward by the length of the palindromic part at the beginning.</li>
</ul>
<p>Therefore, while the substring <span class="math inline">\([0, \text{left})\)</span> may not always be the tightest fit, it will always contain the longest palindromic prefix.</p>
<p>The best-case scenario for this algorithm is when the entire string is a palindrome. In this case, the <code>left</code> pointer will reach the end of the string quickly. The worst-case scenario is when the string is something like <code>&quot;aababababababa&quot;</code>. Here, <code>left</code> initially becomes <code>12</code>, meaning we need to recheck the substring <span class="math inline">\([0, 12)\)</span>. As we continue, <code>left</code> might decrease to <code>10</code>, and so on. In this worst-case scenario, the substring is reduced by only a few elements at each step, making the total number of steps proportional to the length of the string, or <span class="math inline">\(O(n)\)</span>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>If the string <code>s</code> is empty, return <code>s</code> immediately.</p>
</li>
<li>
<p>Find the longest palindromic prefix:</p>
<ul>
<li>Initialize <code>left</code> to 0.</li>
<li>Iterate <code>right</code> from the end of the string (<code>length - 1</code>) to the start (0):
<ul>
<li>If the character at <code>right</code> matches the character at <code>left</code>:
<ul>
<li>Increment <code>left</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If <code>left</code> equals the length of the string, <code>s</code> is already a palindrome, so return <code>s</code>.</p>
</li>
<li>
<p>Extract the suffix that is not part of the palindromic prefix:</p>
<ul>
<li>Create <code>nonPalindromeSuffix</code> as the substring from <code>left</code> to the end of <code>s</code>.</li>
<li>Reverse <code>nonPalindromeSuffix</code> to create <code>reverseSuffix</code>.</li>
</ul>
</li>
<li>
<p>Form the shortest palindrome:</p>
<ul>
<li>Recursively call <code>shortestPalindrome</code> on the substring from the start to <code>left</code> (i.e., <code>s.substring(0, left)</code>).</li>
<li>Concatenate <code>reverseSuffix</code>, the result of the recursive call, and <code>nonPalindromeSuffix</code>.</li>
</ul>
</li>
<li>
<p>Return the concatenated result as the shortest palindrome.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9HivdNx6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>Each iteration of the <code>shortestPalindrome</code> function operates on a substring of size <code>n</code>. In the worst-case scenario, where the string is not a palindrome and we must continually reduce its size, the function might need to be called up to <code>n/2</code> times.</p>
<p>The time complexity <span class="math inline">\(T(n)\)</span> represents the total time taken by the algorithm. At each step, the algorithm processes a substring and then works with a smaller substring by removing two characters. This can be expressed as <span class="math inline">\(T(n) = T(n-2) + O(n)\)</span>, where <span class="math inline">\(O(n)\)</span> is the time taken to process the substring of size <code>n</code>.</p>
<p>Summing up all the steps, we get:<br />
<span class="math inline">\(T(n) = O(n) + O(n-2) + O(n-4) + \ldots + O(1)\)</span></p>
<p>This sum of terms approximates to <span class="math inline">\(O(n^2)\)</span> because it is an arithmetic series where the number of terms grows linearly with <code>n</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is linear, <span class="math inline">\(O(n)\)</span>, due to the space needed to store the reversed suffix and other temporary variables.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-kmp-knuth-morris-pratt-algorithm">Approach 3: KMP (Knuth-Morris-Pratt) Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The KMP algorithm is used for pattern matching within strings. The KMP algorithm computes prefix functions to identify substrings that match specific patterns. In our case, we use this efficiency to compute the longest palindromic prefix. We construct a combined string of the original string, a special delimiter, and the reversed original string. By applying KMP, we can determine the longest prefix of the original string that matches a suffix of the reversed string.</p>
<p>First, we construct a new string by concatenating the original string, a delimiter (such as <code>&quot;#&quot;</code>), and the reversed original string. This combined string looks like <code>&quot;original#reversed&quot;</code>. The delimiter <code>&quot;#&quot;</code> is crucial because it ensures that we are only comparing the original string with its reversed version, and not inadvertently matching parts of the reversed string with itself.</p>
<p>To proceed, we calculate the prefix function for this combined string. The prefix function or partial match table is an array where each element at index <code>i</code> indicates the length of the longest prefix of the substring ending at <code>i</code> which is also a suffix. This helps us identify the longest segment where the prefix of the original string matches a suffix in the reversed string. The purpose is to identify how much of the original string matches a suffix of the reversed string.</p>
</br>
<p>For example: We construct a combined string using the original string <code>s</code>, a delimiter <code>&quot;#&quot;</code>, and the reversed version of <code>s</code>. This combined string helps us find the longest palindromic prefix by applying the KMP algorithm. For the string <code>&quot;aacecaaa&quot;</code>, the reversed string is <code>&quot;aaacecaa&quot;</code>. Thus, the combined string becomes <code>&quot;aacecaaa#aaacecaa&quot;</code>.</p>
<p>The prefix function helps us determine the length of the longest prefix of the original string that can be matched by a suffix of the reversed string. For the combined string <code>&quot;aacecaaa#aaacecaa&quot;</code>, the prefix function will reveal that the longest palindromic prefix of <code>&quot;aacecaaa&quot;</code> is <code>&quot;aacecaa&quot;</code>.</p>
<p>To create the shortest palindrome, we need to prepend characters to the original string. Specifically, we reverse the portion of the original string that extends beyond the longest palindromic prefix and prepend it. In this case, the part of the original string that extends beyond <code>&quot;aacecaa&quot;</code> is <code>&quot;a&quot;</code>. Reversing <code>&quot;a&quot;</code> gives <code>&quot;a&quot;</code>, so we prepend <code>&quot;a&quot;</code> to <code>&quot;aacecaaa&quot;</code> and the result is <code>&quot;aaacecaaa&quot;</code>.</p>
</br>
</br>
<p>The algorithm to generate the prefix table is described below:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>prefixTable<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> n<span style="color:#000;font-weight:bold">;</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> length <span style="color:#000;font-weight:bold">=</span> prefixTable<span style="color:#000;font-weight:bold">[</span>i <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>length <span style="color:#000;font-weight:bold">&gt;</span> 0 <span style="color:#000;font-weight:bold">&amp;&amp;</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">!=</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>length<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        length <span style="color:#000;font-weight:bold">=</span> prefixTable<span style="color:#000;font-weight:bold">[</span>length <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">==</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>length<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        length<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    prefixTable<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> length<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><ul>
<li>Begin by setting <code>prefixTable[0] = 0</code> since there is no proper prefix for the first character.</li>
<li>Next, iterate over <code>i</code> from 1 to <code>n - 1</code>:
<ul>
<li>Set <code>length = prefixTable[i - 1]</code>, which represents the longest prefix length for the substring up to the previous character.</li>
<li>While <code>length &gt; 0</code> and the character at position <code>i</code> doesn't match the character at position <code>length</code>, set <code>length = prefixTable[length - 1]</code>. This step is essential when we encounter a mismatch, and we attempt to match a shorter prefix, which is the value of <code>prefixTable[length - 1]</code>, until either we find a match or <code>length</code> becomes 0.</li>
<li>If <code>s.charAt(i) == s.charAt(length)</code>, we increment <code>length</code> by 1 (extend the matching prefix).</li>
<li>Finally, set <code>prefixTable[i] = length</code>.</li>
</ul>
</li>
</ul>
<p>The lookup table generation is as illustrated below:</p>
<p><img src="../Figures/214/shortest_palindrome_KMP.png" alt="KMP" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p><code>shortestPalindrome</code> function:</p>
<ul>
<li>Create <code>reversedString</code> by reversing the input string <code>s</code>.</li>
<li>Concatenate <code>s</code>, a separator <code>#</code>, and <code>reversedString</code> to form <code>combinedString</code>.</li>
<li>Call <code>buildPrefixTable(combinedString)</code> to compute the prefix table for <code>combinedString</code>.</li>
<li>Extract the length of the longest palindromic prefix from the last value in the prefix table (<code>prefixTable[combinedString.length() - 1]</code>).</li>
<li>Compute <code>suffix</code> by taking the substring of <code>s</code> starting from the length of the longest palindromic prefix.</li>
<li>Reverse <code>suffix</code> and prepend it to <code>s</code> to form and return the shortest palindrome.</li>
</ul>
</li>
<li>
<p><code>buildPrefixTable</code> function:</p>
<ul>
<li>Initialize <code>prefixTable</code> with the same length as the input string <code>s</code> and set <code>length</code> to <code>0</code>.</li>
<li>Iterate over <code>s</code> from index <code>1</code> to the end:
<ul>
<li>While <code>length</code> is greater than <code>0</code> and the current character does not match the character at the current length, update <code>length</code> to the value at <code>prefixTable[length - 1]</code>.</li>
<li>If the current character matches the character at <code>length</code>, increment <code>length</code>.</li>
<li>Set <code>prefixTable[i]</code> to the current <code>length</code>.</li>
</ul>
</li>
<li>Return the <code>prefixTable</code>.</li>
</ul>
</li>
<li>
<p>The result is the shortest palindrome string formed by appending the reversed suffix of <code>s</code> to <code>s</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/HcMZySw4/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Creating the reversed string requires a pass through the original string, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Concatenating <code>s</code>, <code>#</code>, and <code>reversedString</code> takes <span class="math inline">\(O(n)\)</span> time, as concatenating strings of length <span class="math inline">\(n\)</span> is linear in the length of the strings.</p>
<p>Constructing the prefix table involves iterating over the combined string of length <span class="math inline">\(2n + 1\)</span>. The <code>buildPrefixTable</code> method runs in <span class="math inline">\(O(m)\)</span> time, where <span class="math inline">\(m\)</span> is the length of the combined string. In this case, <span class="math inline">\(m = 2n + 1\)</span>, so the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Extracting the suffix and reversing it are both <span class="math inline">\(O(n)\)</span> operations.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>reversedString</code> and <code>combinedString</code> each use <span class="math inline">\(O(n)\)</span> space.</p>
<p>The <code>prefixTable</code> array has a size of <span class="math inline">\(2n + 1\)</span>, which is <span class="math inline">\(O(n)\)</span>. Other variables used (such as <code>length</code> and indices) use <span class="math inline">\(O(1)\)</span> space.</p>
<p>Combining these, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-rolling-hash-based-algorithm">Approach 4: Rolling Hash Based Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The rolling hash approach uses hash functions to efficiently compare different substrings of the original string with those of the reversed string. Hashing helps determine if a substring matches another by comparing hash values rather than individual characters.</p>
<p>Rolling hashes were designed to handle substring matching and comparison problems by allowing incremental updates to hash values as we slide through the string. This reduces the number of comparisons needed by comparing hash values instead of actual substrings.</p>
<p>To start, we compute hash values for all prefixes of the original string and all suffixes of the reversed string using a rolling hash function. The rolling hash function allows us to update the hash values incrementally, which speeds up the computation compared to recalculating hashes from scratch.</p>
<p>Next, we compare the hash values of the prefixes from the original string with the hash values of the suffixes from the reversed string. When the hash values match, it indicates that the corresponding substrings are identical. This helps us find the longest palindromic prefix.</p>
<p>For example: Suppose our string is <code>&quot;aacecaaa&quot;</code>. We calculate hash values for the prefixes of <code>&quot;aacecaaa&quot;</code> and the suffixes of its reverse, <code>&quot;aaacecaa&quot;</code>. The hash comparisons reveal that the longest palindromic prefix is <code>&quot;aacecaaa&quot;</code>. We then reverse the remaining part of the string (<code>&quot;a&quot;</code>), yielding <code>&quot;a&quot;</code>. Prepending this reversed part to the original string gives <code>&quot;aaacecaaa&quot;</code>.</p>
<br/>
<h5 id="hash-calculation-details">Hash Calculation Details:</h5>
<p>To give you a clearer idea of how the hashing is calculated, let's see this:</p>
<p>We initialize two hash values: one for the original string and one for its reversed version. Let’s use base <code>29</code> and a large prime modulus <span class="math inline">\(10^9 + 7\)</span> for hashing. We also initialize a variable to keep track of powers of the base.</p>
<p>We iterate through each character of the original string and compute its hash. Suppose we start with the hash value <code>0</code> and process characters one by one:</p>
<br/>
<p><span class="math display">\[
$$\text{Update hash:}$$

$$\text{hash} = (\text{hash} \times \text{base} + \text{character\_value}) \% \text{mod}$$

$$\text{Suppose } \text{character\_value} \text{ for } 'a' \text{ is } 1.$$

$$\text{hash} = (0 \times 29 + 1) \%  1000000007 = 1$$

<br/>

$$\text{Character } 'a':$$

$$\text{Update hash:}$$

$$\text{hash} = (1 \times 29 + 1) \% 1000000007 = 30$$

<br/>

Continue this for all characters. After processing `"aacecaaa"`, let’s assume the final hash is `23456789` for this substring.

We do a similar hash calculation for the reversed string `"aaacecaa"`. We compute the hash values for each prefix of the reversed string. Let’s assume the final hash of the reversed string is `34567890`.

To compare substrings, we use a rolling hash. As we move the window of comparison along the combined string, we update the hash values based on the new and old characters entering and exiting the window. If the hash of a prefix of the original string matches the hash of a suffix of the reversed string, that prefix is palindromic. Now the comparison shows that the longest prefix of `"aacecaaa"` that matches a suffix of `"aaacecaa"` is `"aacecaa"`. This tells us that `"aacecaa"` is a palindromic segment. Now we identify the remaining part of the original string that extends beyond the palindromic prefix. For `"aacecaaa"`, the remaining part is `"a"`.

So we reverse the remaining part (`"a"`) to get `"a"`, and prepend this reversed part to the original string.

Thus the shortest palindrome is `"aaacecaaa"`.

#### Algorithm

- Initialize hash parameters:
  - Set `hashBase` to 29 and `modValue` to $10^9 + 7$.
  - Initialize `forwardHash` and `reverseHash` to 0.
  - Initialize `powerValue` to 1.
  - Initialize `palindromeEndIndex` to -1.

- Iterate over each character `currentChar` in the string `s`:
  - Update `forwardHash` to include the current character:
    - Compute `forwardHash` as `(forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue`.
  - Update `reverseHash` to include the current character:
    - Compute `reverseHash` as `(reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue`.
  - Update `powerValue` for the next character:
    - Compute `powerValue` as `(powerValue * hashBase) % modValue`.
  - If `forwardHash` matches `reverseHash`, update `palindromeEndIndex` to the current index `i`.

- After the loop, find the suffix that follows the longest palindromic prefix:
  - Extract the suffix from the string `s` starting from `palindromeEndIndex + 1` to the end.
  - Reverse the suffix to prepare for prepending.

- Concatenate the reversed suffix to the original string `s` and return the result:
  - Return `reversedSuffix + s`.

#### Implementation

[code](https://leetcode.com/playground/cdGm2VjV/shared)

#### Complexity Analysis

Let $n$ be the length of the input string.

- Time complexity: $O(n)$

    The algorithm performs a single pass over the input string to compute rolling hashes and determine the longest palindromic prefix, resulting in $O(n)$ time complexity. This pass involves constant-time operations for each character, including hash updates and power calculations. After this, we perform an additional pass to reverse the suffix, which is also $O(n)$. The total time complexity remains $O(n)$.

- Space complexity: $O(n)$

    The space complexity is determined by the space used for the reversed suffix and the additional string manipulations. The space required for the forward and reverse hash values, power value, and palindrome end index is constant and does not scale with input size. However, storing the reversed suffix and the final result string both require $O(n)$ space. Thus, the space complexity is $O(n)$.

---

### Approach 5: Manacher's Algorithm

#### Intuition

> Note: This algorithm goes beyond what's typically expected in coding interviews. It's more for those who are curious and eager to explore advanced algorithms, simply out of personal interest or a desire to deepen their understanding of data structures and algorithms. If you're someone who loves learning new concepts beyond interview prep, this approach might be for you! Sometimes this is the only algorithm that can give you an $O(n)$ runtime.

</br>

Developed to address the problem of finding palindromic substrings efficiently, Manacher’s algorithm preprocesses the string to handle both even and odd-length palindromes uniformly. By inserting special characters between each character of the original string, it computes the radius of the longest palindromic substring centered at each position.

To handle palindromes of both even and odd lengths uniformly, the algorithm transforms the original string by inserting special characters (e.g., `"#"`) between every character and at the boundaries. This way, every palindrome can be treated as if it’s surrounded by characters, making it easier to apply the same expansion logic for all cases.

For example, the string `"aacecaaa"` is transformed into `"^#a#a#c#e#c#a#a#a#$"`. Here, `^` and `$` are boundary markers that help avoid out-of-bound errors. `#` helps to treat the string uniformly, making every palindrome appear with a single center.

Manacher’s algorithm maintains an array `P` where `P[i]` denotes the radius of the longest palindromic substring centered at the position `i` in the transformed string.

</br>

We divide Manacher's algorithm into three steps to achieve linear time complexity:

1. Center and Right Boundary: We track the center `C` and right boundary `R` of the rightmost palindrome found so far. For each position `i`, we check if it falls within the current right boundary. If it does, we use previously computed information to estimate the length of the palindrome centered at `i`.

2. Mirror Property: If a position `i` is within the right boundary of a known palindrome, we can infer the length of the palindrome centered at `i` from its mirrored position relative to the current center `C`. This way we reduce the need for direct expansion by leveraging previously computed palindromes to quickly estimate lengths.

3. Expand Around Center: For positions where the estimated palindrome length based on the mirror property is not accurate, we perform direct expansion to find the exact length of the palindrome centered at `i`. We update the center and right boundary if the newly found palindrome extends beyond the current right boundary.

</br>

After computing the array `P`, we can determine the longest palindromic prefix of the original string. The longest palindromic substring in the transformed string that corresponds to a prefix of the original string gives us the longest palindromic prefix.

To form the shortest palindrome, identify the part of the original string that does not contribute to this longest palindromic prefix. Reverse this non-matching segment and prepend it to the original string.

With the string `"aacecaaa"`, after preprocessing to `"#a#a#c#e#c#a#a#a#"`, Manacher’s algorithm identifies `"aacecaaa"` as the longest palindromic prefix. Reversing the remaining part (`"a"`) and prepending it results in `"aaacecaaa"`.

We highly recommend solving the [longest palindromic substring problem using Manacher’s algorithm](https://leetcode.com/problems/longest-palindromic-substring/editorial/). It is extremely efficient and ideal for solving palindrome-related problems.

This algorithm is complex, so review various sources to gain a better understanding. It's normal if you don’t grasp it right away, so give yourself time.

#### Algorithm

- `shortestPalindrome` function:
  - If the input string `s` is null or empty, return `s` immediately.
  - Preprocess the string `s` by calling `preprocessString(s)` to handle edge cases and simplify palindrome detection.
    - `preprocessString` function:
      - Initialize a string with a starting character `^`.
      - Append a `#` followed by each character in `s` to string.
      - Append a trailing `#` and a dollar sign to complete the modified string.
      - Return the modified string which includes special boundary characters.
  - Initialize an integer array `palindromeRadiusArray` to store the radius of the palindrome centered at each character in the modified string.
  - Initialize `center` and `rightBoundary` to track the center and right boundary of the current longest palindrome found.
  - Initialize `maxPalindromeLength` to track the length of the longest palindrome that touches the start of the string.

  - Iterate through each character `i` in the modified string (excluding the boundary characters):
    - Calculate the `mirrorIndex` as `2 * center - i` to utilize previously computed palindromes.
    - If `rightBoundary` is greater than `i`, update `palindromeRadiusArray[i]` to the minimum of the remaining length to the `rightBoundary` or the radius of the palindrome at `mirrorIndex`.
    - Expand around the center `i` while the characters match and update `palindromeRadiusArray[i]` accordingly.
    - If the expanded palindrome extends beyond `rightBoundary`, update `center` and `rightBoundary` to the new values.
    - If the palindrome touches the start of the string (`i - palindromeRadiusArray[i] == 1`), update `maxPalindromeLength` with the maximum length found.

  - Extract the suffix of the original string starting from `maxPalindromeLength` and reverse it.
  - Concatenate the reversed suffix with the original string and return the result.

#### Implementation

[code](https://leetcode.com/playground/ZT8yYNFz/shared)

#### Complexity Analysis

Let $n$ be the length of the input string.

- Time complexity: $O(n)$

    The `preprocessString` method adds boundaries and separators to the input string. This takes linear time, $O(n)$, where $n$ is the length of the input string.

    The core algorithm iterates through the characters of the modified string once. The expansion step and the updates of the center and right boundary each take constant time in the average case for each character. Thus, this step has a time complexity of $O(m)$, where $m$ is the length of the modified string.

    Since the length of the modified string is $2n + 1 \, (\text{for separators}) + 2 \, (\text{for boundaries}) = 2n + 3$ , the time complexity of Manacher's algorithm is $O(n)$.

    Constructing the result involves reversing the suffix of the original string and concatenating it with the original string, both of which take linear time, $O(n)$.

    Combining these steps, the total time complexity is $O(n)$.

- Space complexity: $O(n)$

    The space used to store the modified string is proportional to its length, which is $2n + 3$. Therefore, the space complexity for storing this string is $O(n)$.

    The `palindromeRadiusArray` is used to store the radius of palindromes for each character in the modified string, which is $O(m)$. Since $m$ is $2n + 3$, the space complexity for this array is $O(n)$.

    The additional space used for temporary variables, and other operations is constant, $O(1)$.

    Combining these factors, the total space complexity is $O(n)$.

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-scores-of-built-strings/description" target="_blank" rel="noopener noreferrer">Sum of Scores of Built Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">suffix array</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are <strong>building</strong> a string <code>s</code> of length <code>n</code> <strong>one</strong> character at a time, <strong>prepending</strong> each new character to the <strong>front</strong> of the string. The strings are labeled from <code>1</code> to <code>n</code>, where the string with length <code>i</code> is labeled <code>s<sub>i</sub></code>.</p>

<ul>
	<li>For example, for <code>s = &quot;abaca&quot;</code>, <code>s<sub>1</sub> == &quot;a&quot;</code>, <code>s<sub>2</sub> == &quot;ca&quot;</code>, <code>s<sub>3</sub> == &quot;aca&quot;</code>, etc.</li>
</ul>

<p>The <strong>score</strong> of <code>s<sub>i</sub></code> is the length of the <strong>longest common prefix</strong> between <code>s<sub>i</sub></code> and <code>s<sub>n</sub></code> (Note that <code>s == s<sub>n</sub></code>).</p>

<p>Given the final string <code>s</code>, return<em> the <strong>sum</strong> of the <strong>score</strong> of every </em><code>s<sub>i</sub></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babab&quot;
<strong>Output:</strong> 9
<strong>Explanation:</strong>
For s<sub>1</sub> == &quot;b&quot;, the longest common prefix is &quot;b&quot; which has a score of 1.
For s<sub>2</sub> == &quot;ab&quot;, there is no common prefix so the score is 0.
For s<sub>3</sub> == &quot;bab&quot;, the longest common prefix is &quot;bab&quot; which has a score of 3.
For s<sub>4</sub> == &quot;abab&quot;, there is no common prefix so the score is 0.
For s<sub>5</sub> == &quot;babab&quot;, the longest common prefix is &quot;babab&quot; which has a score of 5.
The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;azbazbzaz&quot;
<strong>Output:</strong> 14
<strong>Explanation:</strong> 
For s<sub>2</sub> == &quot;az&quot;, the longest common prefix is &quot;az&quot; which has a score of 2.
For s<sub>6</sub> == &quot;azbzaz&quot;, the longest common prefix is &quot;azb&quot; which has a score of 3.
For s<sub>9</sub> == &quot;azbazbzaz&quot;, the longest common prefix is &quot;azbazbzaz&quot; which has a score of 9.
For all other s<sub>i</sub>, the score is 0.
The sum of the scores is 2 + 3 + 9 = 14, so we return 14.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>