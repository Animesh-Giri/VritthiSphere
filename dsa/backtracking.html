<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>backtracking - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>backtracking</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">136</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">24 Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">A binary palindrome</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-2" class="toc-link">Additive Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">All Palindromic Partitions</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-4" class="toc-link">All Paths From Source to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">All Unique Permutations of an array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-6" class="toc-link">Ambiguous Coordinates</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Beautiful Arrangement</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Binary Tree Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Binary Watch</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Black and White</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-11" class="toc-link">Brace Expansion II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Circular Permutation in Binary Representation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Closest Dessert Cost</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Coins and Game</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Combinations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Combination Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Combination Sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-18" class="toc-link">Combination Sum II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Combination Sum II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-20" class="toc-link">Combination Sum III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Construct Smallest Number From DI String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Construct the Lexicographically Largest Valid Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Count Number of Maximum Bitwise-OR Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Count Numbers with Unique Digits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Count the array</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-26" class="toc-link">Decode the string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-27" class="toc-link">Distribute Repeating Integers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Divisor Game</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-29" class="toc-link">Expression Add Operators</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Expression Add Operators</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Fair Distribution of Cookies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Find all possible paths from top to bottom</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-33" class="toc-link">Find Kth permutation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-34" class="toc-link">Find Minimum Time to Finish All Jobs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Find the Punishment Number of an Integer</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Find the String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-37" class="toc-link">Find Unique Binary String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">GCD Strings</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-39" class="toc-link">Generate Binary Strings Without Adjacent Zeros</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Generate IP Addresses</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-41" class="toc-link">Generate Parentheses</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-42" class="toc-link">Generate Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Gray Code</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Hamiltonian Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Iterator for Combination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Largest number in K swaps</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-47" class="toc-link">Largest Sum Cycle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-48" class="toc-link">Largest Time for Given Digits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Letter Case Permutation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Letter Combinations of a Phone Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Letter Tile Possibilities</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Longest Possible Route in a Matrix with Hurdles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-53" class="toc-link">Longest Subsequence Repeated k Times</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Matchsticks to Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Maximize Score After N Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Maximum Compatibility Score Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Maximum Good People Based on Statements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Maximum Length of a Concatenated String with Unique Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Maximum Number of Achievable Transfer Requests</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Maximum Path Quality of a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Maximum Points in an Archery Competition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Maximum Product of the Length of Two Palindromic Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Maximum Rows Covered by Columns</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Maximum Score Words Formed by Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Maximum Split of Positive Even Integers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Maximum Strength of a Group</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">M-Coloring Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-68" class="toc-link">Minimum Number of Work Sessions to Finish the Tasks</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Minimum Time to Break Locks I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Movement in arrays</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-71" class="toc-link">Nearby Squares</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-72" class="toc-link">Next Greater Numerically Balanced Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Next Special Palindrome Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Non-decreasing Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">N-Queen Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-76" class="toc-link">N-Queens</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">N-Queens</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-78" class="toc-link">N-Queens II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Number of divisors</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-80" class="toc-link">Number of paths in a matrix with k coins</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-81" class="toc-link">Number of Squareful Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Number of Valid Move Combinations On Chessboard</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Numbers With Same Consecutive Differences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Palindrome Partitioning</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Partition array to k subsets</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-86" class="toc-link">Partition String Into Minimum Beautiful Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Partition to K Equal Sum Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Path Sum II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Path with Maximum Gold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Permutations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Permutations II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Permutations of a String</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-93" class="toc-link">Permutation with Spaces</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-94" class="toc-link">Possible Words From Phone Digits</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-95" class="toc-link">Print all LCS sequences</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-96" class="toc-link">Prison Break</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-97" class="toc-link">Probability of a Two Boxes Having The Same Number of Distinct Balls</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Rat in a Maze Problem - I</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-99" class="toc-link">Rat Maze With Multiple Jumps</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-100" class="toc-link">Remove Invalid Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Restore IP Addresses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Shopping Offers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Sliding Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Smallest Divisible Digit Product II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Smallest String Starting From Leaf</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Solve the Sudoku</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-107" class="toc-link">Special series</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-108" class="toc-link">Split Array into Fibonacci Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Split a String Into the Max Number of Unique Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Splitting a String Into Descending Consecutive Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Stickers to Spell Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Subsets</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-114" class="toc-link">Subsets II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Sudoku Solver</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Sum of All Subset XOR Totals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Sum-string</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-118" class="toc-link">Target Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">The k-th Lexicographical String of All Happy Strings of Length n</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">The Number of Beautiful Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Three arrays</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-122" class="toc-link">Tiling a Rectangle with the Fewest Squares</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Unique Binary Search Trees II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Unique partitions</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-125" class="toc-link">Unique Paths III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Unique Subsets</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-127" class="toc-link">Verbal Arithmetic Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Word Boggle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-129" class="toc-link">Word Break - 2</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-130" class="toc-link">Word Break II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Word Ladder II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Word Search</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Word Search</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-134" class="toc-link">Word Search II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Word Search II</a> <span class="toc-platform">GeeksForGeeks</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/24-game/description" target="_blank" rel="noopener noreferrer">24 Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>cards</code> of length <code>4</code>. You have four cards, each containing a number in the range <code>[1, 9]</code>. You should arrange the numbers on these cards in a mathematical expression using the operators <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> and the parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> to get the value 24.</p>

<p>You are restricted with the following rules:</p>

<ul>
	<li>The division operator <code>&#39;/&#39;</code> represents real division, not integer division.

	<ul>
		<li>For example, <code>4 / (1 - 2 / 3) = 4 / (1 / 3) = 12</code>.</li>
	</ul>
	</li>
	<li>Every operation done is between two numbers. In particular, we cannot use <code>&#39;-&#39;</code> as a unary operator.
	<ul>
		<li>For example, if <code>cards = [1, 1, 1, 1]</code>, the expression <code>&quot;-1 - 1 - 1 - 1&quot;</code> is <strong>not allowed</strong>.</li>
	</ul>
	</li>
	<li>You cannot concatenate numbers together
	<ul>
		<li>For example, if <code>cards = [1, 2, 1, 2]</code>, the expression <code>&quot;12 + 12&quot;</code> is not valid.</li>
	</ul>
	</li>
</ul>

<p>Return <code>true</code> if you can get such expression that evaluates to <code>24</code>, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cards = [4,1,8,7]
<strong>Output:</strong> true
<strong>Explanation:</strong> (8-4) * (7-1) = 24
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cards = [1,2,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>cards.length == 4</code></li>
	<li><code>1 &lt;= cards[i] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/binary-palindrome-4-035e5ad6/" target="_blank" rel="noopener noreferrer">A binary palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">c++</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a number $$N$$. In one operation, you&nbsp;can either increase the value of $$N$$ by <em>1</em> or decrease the value of $$N$$ by <em>1</em>.</p>

<p>Determine the minimum number of operations required (possibly zero) to convert number $$N$$ to a number $$P$$ such that binary representation of $$P$$ is a palindrome.</p>

<p><em><strong>Note</strong></em>: A binary representation is said to be a palindrome if it reads the same from left-right and right-left.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains an integer $$T$$&nbsp;denoting the number of test cases.</li>
	<li>For each test case, the first line contains an integer $$N$$.</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case in a new line, print the minimum number of operations required.&nbsp;</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le T \le 10^5 \\ 0 \le N \le 2 \times 10^9\)</span></p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><strong>For first test case</strong></p>

<ul>
	<li>If we decrease the value of <em>N</em> by <em>1</em>. Then <em>N = 5</em>, whose binary representation is <em>101 </em>which is a palindrome.</li>
	<li>Hence, minimum <em>1</em> operation is required.</li>
</ul>

<p><strong>For second test case</strong></p>

<ul>
	<li><em>N = 9</em>, has binary representation <em>1001</em> which is a palindrome.</li>
	<li>Hence, <em>0</em> operations is required.</li>
</ul></div>
				</div>
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/additive-number/description" target="_blank" rel="noopener noreferrer">Additive Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <strong>additive number</strong> is a string whose digits can form an <strong>additive sequence</strong>.</p>

<p>A valid <strong>additive sequence</strong> should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>

<p>Given a string containing only digits, return <code>true</code> if it is an <strong>additive number</strong> or <code>false</code> otherwise.</p>

<p><strong>Note:</strong> Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> &quot;112358&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> 
The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> &quot;199100199&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> 
The additive sequence is: 1, 99, 100, 199.&nbsp;
1 + 99 = 100, 99 + 100 = 199
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num.length &lt;= 35</code></li>
	<li><code>num</code> consists only of digits.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> How would you handle overflow for very large input integers?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-all-possible-palindromic-partitions-of-a-string/1" target="_blank" rel="noopener noreferrer">All Palindromic Partitions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">palindrome</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong>, find all possible ways to partition it such that every substring in the partition is a palindrome.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s =<strong> </strong>"geeks"<br /></span><span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">[[</span></span><span style="font-size: 18px;">g, e, e, k, s], [g, ee, k, s]]</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Explanation:</span> </strong><span style="font-size: 14pt;">[</span></span><span style="font-size: 14pt;">g, e, e, k, s] and [g, ee, k, s] are the only partitions of "geeks" where each substring is a palindrome.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s =<strong> </strong>"abcba"</span>
<span style="font-size: 18px;"><strong>Output: </strong></span><span style="font-size: 18px;">[[a, b, c, b, a], [a, bcb, a], [abcba]]<br /><strong>Explanation: </strong></span><span style="font-size: 14pt;">[a, b, c, b, a], [a, bcb, a] and [abcba] are the only partitions of "abcba" where each substring is a palindrome.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; s.size() &le; 20</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-paths-from-source-to-target/description" target="_blank" rel="noopener noreferrer">All Paths From Source to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a directed acyclic graph (<strong>DAG</strong>) of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, find all possible paths from node <code>0</code> to node <code>n - 1</code> and return them in <strong>any order</strong>.</p>

<p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code> (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[3],[3],[]]
<strong>Output:</strong> [[0,1,3],[0,2,3]]
<strong>Explanation:</strong> There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" style="width: 423px; height: 301px;" />
<pre>
<strong>Input:</strong> graph = [[4,3,1],[3,2,4],[3],[4],[]]
<strong>Output:</strong> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>2 &lt;= n &lt;= 15</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; n</code></li>
	<li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li>
	<li>All the elements of <code>graph[i]</code> are <strong>unique</strong>.</li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/all-unique-permutations-of-an-array/1" target="_blank" rel="noopener noreferrer">All Unique Permutations of an array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]&nbsp;</strong>of length&nbsp;<strong>n.&nbsp;</strong>Find all possible&nbsp;<strong>distinct permutations&nbsp;</strong>of the array in&nbsp;<strong>sorted order</strong>. A sequence&nbsp;<strong>A&nbsp;</strong>is greater than sequence&nbsp;<strong>B</strong>&nbsp;if there is an index&nbsp;<strong>i&nbsp;</strong>for which&nbsp;<strong>A<sub>j</sub>&nbsp;= B<sub>j</sub></strong>&nbsp;for all&nbsp;<strong>j&lt;i&nbsp;</strong>and&nbsp;</span><strong><span style="font-size: 18px;">A</span><sub>i</sub><span style="font-size: 18px;">&nbsp;&gt; B</span><sub>i</sub></strong>.</p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [1, 3, 3]
<strong>Output</strong>: [[1, 3, 3], [3, 1, 3], [3, 3, 1]]
<strong>Explanation</strong>: These are the only possible distinct permutations for the given array.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [4, 5]
<strong>Output</strong>: [[4, 5], [5, 4]]<br /><strong>Explanation:</strong> These are the only possible distinct permutations for the given array.
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; n &le; 9</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ambiguous-coordinates/description" target="_blank" rel="noopener noreferrer">Ambiguous Coordinates</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We had some 2-dimensional coordinates, like <code>&quot;(1, 3)&quot;</code> or <code>&quot;(2, 0.5)&quot;</code>. Then, we removed all commas, decimal points, and spaces and ended up with the string s.</p>

<ul>
	<li>For example, <code>&quot;(1, 3)&quot;</code> becomes <code>s = &quot;(13)&quot;</code> and <code>&quot;(2, 0.5)&quot;</code> becomes <code>s = &quot;(205)&quot;</code>.</li>
</ul>

<p>Return <em>a list of strings representing all possibilities for what our original coordinates could have been</em>.</p>

<p>Our original representation never had extraneous zeroes, so we never started with numbers like <code>&quot;00&quot;</code>, <code>&quot;0.0&quot;</code>, <code>&quot;0.00&quot;</code>, <code>&quot;1.0&quot;</code>, <code>&quot;001&quot;</code>, <code>&quot;00.01&quot;</code>, or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like <code>&quot;.1&quot;</code>.</p>

<p>The final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(123)&quot;
<strong>Output:</strong> [&quot;(1, 2.3)&quot;,&quot;(1, 23)&quot;,&quot;(1.2, 3)&quot;,&quot;(12, 3)&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(0123)&quot;
<strong>Output:</strong> [&quot;(0, 1.23)&quot;,&quot;(0, 12.3)&quot;,&quot;(0, 123)&quot;,&quot;(0.1, 2.3)&quot;,&quot;(0.1, 23)&quot;,&quot;(0.12, 3)&quot;]
<strong>Explanation:</strong> 0.0, 00, 0001 or 00.01 are not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(00011)&quot;
<strong>Output:</strong> [&quot;(0, 0.011)&quot;,&quot;(0.001, 1)&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>4 &lt;= s.length &lt;= 12</code></li>
	<li><code>s[0] == &#39;(&#39;</code> and <code>s[s.length - 1] == &#39;)&#39;</code>.</li>
	<li>The rest of <code>s</code> are digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-arrangement/description" target="_blank" rel="noopener noreferrer">Beautiful Arrangement</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Suppose you have <code>n</code> integers labeled <code>1</code> through <code>n</code>. A permutation of those <code>n</code> integers <code>perm</code> (<strong>1-indexed</strong>) is considered a <strong>beautiful arrangement</strong> if for every <code>i</code> (<code>1 &lt;= i &lt;= n</code>), <strong>either</strong> of the following is true:</p>

<ul>
	<li><code>perm[i]</code> is divisible by <code>i</code>.</li>
	<li><code>i</code> is divisible by <code>perm[i]</code>.</li>
</ul>

<p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of the <strong>beautiful arrangements</strong> that you can construct</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<b>Explanation:</b> 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h3>
<h4 id="algorithm">Algorithm</h4>
<p>In the brute force method, we can find out all the arrays that can be formed using the numbers from 1 to N(by creating every possible permutation of the given elements). Then, we iterate over all the elements of every permutation generated and check for the required conditions of divisibility.</p>
<p>In order to generate all the possible pairings, we make use of a function <code>permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p>
<p>To do so, <code>permute</code> takes the index of the current element <span class="math inline">\(current_index\)</span> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>
<p>Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p>
<p>!?!../Documents/561_Array.json:1000,563!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5cbz54de/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n!)\)</span>. A total of <span class="math inline">\(n!\)</span> permutations will be generated for an array of length <span class="math inline">\(n\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of the recursion tree can go upto <span class="math inline">\(n\)</span>. <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h3>
<h4 id="algorithm-1">Algorithm</h4>
<p>In the brute force approach, we create the full array for every permutation and then check the array for the given divisibilty conditions. But this method can be optimized to a great extent. To do so, we can keep checking the elements while being added to the permutation array at every step for the divisibility condition and  can stop creating it any further as soon as we find out the element just added to the permutation violates the divisiblity condition.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/D4dVJwn7/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(k)\)</span>. <span class="math inline">\(k\)</span> refers to the number of valid permutations.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of recursion tree can go upto <span class="math inline">\(n\)</span>. Further, <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is used, where, <span class="math inline">\(n\)</span> is the given number.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</h3>
<h4 id="algorithm-2">Algorithm</h4>
<p>The idea behind this approach is simple. We try to create all the permutations of numbers from 1 to N. We can fix one number at a particular position and check for the divisibility criteria of that number at the particular position. But, we need to keep a track of the numbers which have already been considered earlier so that they aren't reconsidered while generating the permutations. If the current<br />
number doesn't satisfy the divisibility criteria, we can leave all the permutations that can be generated with that number at the particular position. This helps to prune the search space of the permutations to a great extent. We do so by trying to place each of the numbers at each position.</p>
<p>We make use of a visited array of size <span class="math inline">\(N\)</span>. Here, <span class="math inline">\(visited[i]\)</span> refers to the <span class="math inline">\(i^{th}\)</span> number being already placed/not placed in the array being formed till now(True indicates that the number has already been placed).</p>
<p>We make use of a <code>calculate</code> function, which puts all the numbers pending numbers from 1 to N(i.e. not placed till now in the array), indicated by a <span class="math inline">\(False\)</span> at the corresponding <span class="math inline">\(visited[i]\)</span> position, and tries to create all the permutations with those numbers starting from the <span class="math inline">\(pos\)</span> index onwards in the current array. While putting the <span class="math inline">\(pos^{th}\)</span> number, we check whether the <span class="math inline">\(i^{th}\)</span> number satisfies the divisibility criteria on the go i.e. we continue forward with creating the permutations with the number <span class="math inline">\(i\)</span> at the <span class="math inline">\(pos^{th}\)</span> position only if the number <span class="math inline">\(i\)</span> and <span class="math inline">\(pos\)</span> satisfy the given criteria. Otherwise, we continue with putting the next numbers at the same position and keep on generating the permutations.</p>
<p>Look at the animation below for a better understanding of the methodology:</p>
<p>!?!../Documents/526_Beautiful.json:1000,563!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/EVQebXTW/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(k)\)</span>. <span class="math inline">\(k\)</span> refers to the number of valid permutations.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(visited\)</span> array of size <span class="math inline">\(n\)</span> is used. The depth of recursion tree will also go upto <span class="math inline">\(n\)</span>. Here, <span class="math inline">\(n\)</span> refers to the given integer <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-paths/description" target="_blank" rel="noopener noreferrer">Binary Tree Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>

<p>A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" style="width: 207px; height: 293px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,5]
<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [&quot;1&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-watch/description" target="_blank" rel="noopener noreferrer">Binary Watch</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent&nbsp;the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>

<ul>
	<li>For example, the below binary watch reads <code>&quot;4:51&quot;</code>.</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg" style="width: 500px; height: 500px;" /></p>

<p>Given an integer <code>turnedOn</code> which represents the number of LEDs that are currently on (ignoring the PM), return <em>all possible times the watch could represent</em>. You may return the answer in <strong>any order</strong>.</p>

<p>The hour must not contain a leading zero.</p>

<ul>
	<li>For example, <code>&quot;01:00&quot;</code> is not valid. It should be <code>&quot;1:00&quot;</code>.</li>
</ul>

<p>The minute must&nbsp;consist of two digits and may contain a leading zero.</p>

<ul>
	<li>For example, <code>&quot;10:2&quot;</code> is not valid. It should be <code>&quot;10:02&quot;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> turnedOn = 1
<strong>Output:</strong> ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> turnedOn = 9
<strong>Output:</strong> []
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= turnedOn &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/black-and-white-1587115620/1" target="_blank" rel="noopener noreferrer">Black and White</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given&nbsp;the chessboard dimensions. Find out the number of ways we can place a black and a white Knight on this chessboard such that they cannot attack each other.</span></p>

<p><span style="font-size:18px"><strong>Note:</strong><br />
The knights have to be placed on different squares. A knight can move two squares horizontally and one square vertically (L shaped), or two squares vertically and one square horizontally (L shaped). The knights attack each other if one can reach the other in one move.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:
</span></strong><span style="font-size:18px">N = 2, M = 2
<strong>Output: </strong>12 
<strong>Explanation</strong>: There are 12 ways we can place a black and a white Knight on this chessboard such that they cannot attack each other.</span>

</pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:
</span></strong><span style="font-size:18px">N = 2, M = 3
<strong>Output: </strong>26
<strong>Explanation</strong>: There are 26 ways we can place a black and a white Knight on this chessboard such that they cannot attack each other.</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Your task is to complete the function <strong>numOfWays()&nbsp;</strong>which takes the chessboard dimensions N and M as inputs and returns the number of ways we can place 2 Knights on this chessboard such that they cannot attack each other. Since this number can be very large, return it modulo 10<sup>9</sup>+7.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(N*M).<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">1 &lt;= N&nbsp;* M &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/brace-expansion-ii/description" target="_blank" rel="noopener noreferrer">Brace Expansion II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Under the grammar given below, strings can represent a set of lowercase words. Let&nbsp;<code>R(expr)</code>&nbsp;denote the set of words the expression represents.</p>

<p>The grammar can best be understood through simple examples:</p>

<ul>
	<li>Single letters represent a singleton set containing that word.
	<ul>
		<li><code>R(&quot;a&quot;) = {&quot;a&quot;}</code></li>
		<li><code>R(&quot;w&quot;) = {&quot;w&quot;}</code></li>
	</ul>
	</li>
	<li>When we take a comma-delimited list of two or more expressions, we take the union of possibilities.
	<ul>
		<li><code>R(&quot;{a,b,c}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code></li>
		<li><code>R(&quot;{{a,b},{b,c}}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code> (notice the final set only contains each word at most once)</li>
	</ul>
	</li>
	<li>When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.
	<ul>
		<li><code>R(&quot;{a,b}{c,d}&quot;) = {&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;}</code></li>
		<li><code>R(&quot;a{b,c}{d,e}f{g,h}&quot;) = {&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;}</code></li>
	</ul>
	</li>
</ul>

<p>Formally, the three rules for our grammar:</p>

<ul>
	<li>For every lowercase letter <code>x</code>, we have <code>R(x) = {x}</code>.</li>
	<li>For expressions <code>e<sub>1</sub>, e<sub>2</sub>, ... , e<sub>k</sub></code> with <code>k &gt;= 2</code>, we have <code>R({e<sub>1</sub>, e<sub>2</sub>, ...}) = R(e<sub>1</sub>) &cup; R(e<sub>2</sub>) &cup; ...</code></li>
	<li>For expressions <code>e<sub>1</sub></code> and <code>e<sub>2</sub></code>, we have <code>R(e<sub>1</sub> + e<sub>2</sub>) = {a + b for (a, b) in R(e<sub>1</sub>) &times; R(e<sub>2</sub>)}</code>, where <code>+</code> denotes concatenation, and <code>&times;</code> denotes the cartesian product.</li>
</ul>

<p>Given an expression representing a set of words under the given grammar, return <em>the sorted list of words that the expression represents</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{a,b}{c,{d,e}}&quot;
<strong>Output:</strong> [&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;{{a,z},a{b,c},{ab,z}}&quot;
<strong>Output:</strong> [&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]
<strong>Explanation:</strong> Each distinct word is written only once in the final answer.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 60</code></li>
	<li><code>expression[i]</code> consists of <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;,&#39;</code>or lowercase English letters.</li>
	<li>The given&nbsp;<code>expression</code>&nbsp;represents a set of words based on the grammar given in the description.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/circular-permutation-in-binary-representation/description" target="_blank" rel="noopener noreferrer">Circular Permutation in Binary Representation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given 2 integers <code>n</code> and <code>start</code>. Your task is return <strong>any</strong> permutation <code>p</code>&nbsp;of <code>(0,1,2.....,2^n -1) </code>such that :</p>

<ul>
	<li><code>p[0] = start</code></li>
	<li><code>p[i]</code> and <code>p[i+1]</code>&nbsp;differ by only one bit in their binary representation.</li>
	<li><code>p[0]</code> and <code>p[2^n -1]</code>&nbsp;must also differ by only one bit in their binary representation.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2, start = 3
<strong>Output:</strong> [3,2,0,1]
<strong>Explanation:</strong> The binary representation of the permutation is (11,10,00,01). 
All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3, start = 2
<strong>Output:</strong> [2,6,7,5,4,0,1,3]
<strong>Explanation:</strong> The binary representation of the permutation is (010,110,111,101,100,000,001,011).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 16</code></li>
	<li><code>0 &lt;= start&nbsp;&lt;&nbsp;2 ^ n</code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-dessert-cost/description" target="_blank" rel="noopener noreferrer">Closest Dessert Cost</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You would like to make dessert and are preparing to buy the ingredients. You have <code>n</code> ice cream base flavors and <code>m</code> types of toppings to choose from. You must follow these rules when making your dessert:</p>

<ul>
	<li>There must be <strong>exactly one</strong> ice cream base.</li>
	<li>You can add <strong>one or more</strong> types of topping or have no toppings at all.</li>
	<li>There are <strong>at most two</strong> of <strong>each type</strong> of topping.</li>
</ul>

<p>You are given three inputs:</p>

<ul>
	<li><code>baseCosts</code>, an integer array of length <code>n</code>, where each <code>baseCosts[i]</code> represents the price of the <code>i<sup>th</sup></code> ice cream base flavor.</li>
	<li><code>toppingCosts</code>, an integer array of length <code>m</code>, where each <code>toppingCosts[i]</code> is the price of <strong>one</strong> of the <code>i<sup>th</sup></code> topping.</li>
	<li><code>target</code>, an integer representing your target price for dessert.</li>
</ul>

<p>You want to make a dessert with a total cost as close to <code>target</code> as possible.</p>

<p>Return <em>the closest possible cost of the dessert to </em><code>target</code>. If there are multiple, return <em>the <strong>lower</strong> one.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> baseCosts = [1,7], toppingCosts = [3,4], target = 10
<strong>Output:</strong> 10
<strong>Explanation:</strong> Consider the following combination (all 0-indexed):
- Choose base 1: cost 7
- Take 1 of topping 0: cost 1 x 3 = 3
- Take 0 of topping 1: cost 0 x 4 = 0
Total: 7 + 3 + 0 = 10.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
<strong>Output:</strong> 17
<strong>Explanation:</strong> Consider the following combination (all 0-indexed):
- Choose base 1: cost 3
- Take 1 of topping 0: cost 1 x 4 = 4
- Take 2 of topping 1: cost 2 x 5 = 10
- Take 0 of topping 2: cost 0 x 100 = 0
Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> baseCosts = [3,10], toppingCosts = [2,5], target = 9
<strong>Output:</strong> 8
<strong>Explanation:</strong> It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == baseCosts.length</code></li>
	<li><code>m == toppingCosts.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10</code></li>
	<li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/coins-and-game4529/1" target="_blank" rel="noopener noreferrer">Coins and Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">gametheory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">There are N coins and K people. Each of them can propose a method of distribution of the coins amongst themselves when their chance comes and a vote will occur in favour or against his distribution method between all those members. The person proposing that method of distribution wins the vote if he gets equal or more votes in favour&nbsp;than in against his proposal else he loses. Loosing he would be eliminated and then the next member will now propose his method of distribution amongst the remaining members.</span></p>

<p><span style="font-size:18px">Each person while proposing his method of distribution wants to get the maximum number of coins as well as win the vote.</span></p>

<p><span style="font-size:18px">Each person is smart and knows all the possibilities that may occur from their vote and will cast their vote&nbsp;accordingly.</span></p>

<p><span style="font-size:18px">The first proposal will always be given by 1 if he loses will be followed by 2 and so on (till the Kth person).</span></p>

<p><span style="font-size:18px">In the distribution of the 1<sup>st</sup> person print the amount of coins each of K people is proposed to get so that he wins the vote.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>:
N = 100 and K = 2
<strong>Output:</strong>&nbsp;100 0
<strong>Explanation</strong>:
To get the maximum coins the 1<sup>st</sup> person will propose the 
distribution 100,0 when the vote occurs he will obviously
vote for himself and the second person against him. 
The result of the vote will be 1-1 which means he will 
survive (tie here means victory) the vote.
</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 100 and K = 1
<strong>Output: </strong>100
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>coinsGame()</strong>&nbsp;which takes the integer N and an integer K&nbsp;as input parameters and returns the&nbsp;K space-separated Integers denoting the distribution proposed by the 1<sup>st</sup> person.<br />
<br />
<strong>Expected Time Complexity:</strong> O(K)<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span></p>

<p><span style="font-size:18px">1&lt;=N&lt;=10<sup>9</sup></span></p>

<p><span style="font-size:18px">1&lt;=K&lt;=10<sup>4</sup></span></p>

<p><span style="font-size:18px">N&gt;=K</span></p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/combinations/description" target="_blank" rel="noopener noreferrer">Combinations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>

<p>You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4, k = 2
<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 1
<strong>Output:</strong> [[1]]
<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/combination-sum/description" target="_blank" rel="noopener noreferrer">Combination Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>

<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword="frequency-array">frequency</span> of at least one of the chosen numbers is different.</p>

<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2,3,6,7], target = 7
<strong>Output:</strong> [[2,2,3],[7]]
<strong>Explanation:</strong>
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2,3,5], target = 8
<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2], target = 1
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
	<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
	<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>
	<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/combination-sum-1587115620/1" target="_blank" rel="noopener noreferrer">Combination Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[]</strong> and a <strong>target</strong>, your task is to find all <strong>unique </strong>combinations in the array where the sum is equal to target. The same number may be chosen from the array <strong>any </strong>number of times to make target.</span></p>
<p><span style="font-size: 18px;">You can return your answer in <strong>any </strong>order.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [2, 4, 6, 8], target = 8
<strong>Output: </strong>[[2 2 2 2] [2 2 4] [2 6] [4 4] [8]]<br /><strong>Explanation:</strong> Total number of possible combinations are 5.</span>
</pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [2, 7, 6, 5], target = 16
<strong>Output: </strong>[[2 2 2 2 2 2 2 2] [2 2 2 2 2 6] [2 2 2 5 5] [2 2 5 7] [2 2 6 6] [2 7 7] [5 5 6]]<br /><strong>Explanation:</strong> Total number of possible combinations are 7.
</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [6, 5, 7], target = 8
<strong>Output: </strong>[]<br /><strong>Explanation:</strong> There are no possible combinantions such that target sum is 8.</span></pre>
<p><span style="font-size: 18px;"><strong style="font-size: 18px;">Constraints:</strong><br /><span style="font-size: 18px;">1 &lt;= arr.size() &lt;= 30</span><br /><span style="font-size: 18px;">2 &lt;= arr[i] &lt;= 40</span><br /><span style="font-size: 18px;">2 &lt;= target &lt;= 40</span><br /><span style="font-size: 18px;">All arr[i] are <strong>distinct</strong>.</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/combination-sum-ii/description" target="_blank" rel="noopener noreferrer">Combination Sum II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>

<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>

<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8
<strong>Output:</strong> 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5
<strong>Output:</strong> 
[
[1,2,2],
[5]
]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>
	<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>
	<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This is one of the problems in the series of combination sums. All these problems can be solved with the same backtracking algorithm.</p>
<p>We recommend trying these similar problems before tackling this one: <a href="https://leetcode.com/problems/combination-sum/description/">Combination Sum</a> and <a href="https://leetcode.com/problems/combination-sum-iii/description/">Combination Sum III</a>, which are arguably easier and one can tweak the solution a bit to solve this problem.</p>
<p>We also listed some follow-up problems at the end of the article if you are interested in exploring the bactracking algorithm further.</p>
<hr />
<h3 id="approach-backtracking">Approach: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>In this problem, we need to generate unique combinations with the given sum value. In the worst case, we might need to generate the sum of all combinations in the array. Backtracking can be effectively used to generate all the possible combinations recursively. Backtracking incrementally builds candidates to the solutions and abandons a candidate (backtracks) as soon as it determines that this candidate can't lead to a final solution. For example, in the given problem, we can discard the candidate solution when it exceeds the sum value, provided the array contains non-negative values. Refer to this <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">backtracking explore card</a> to read more about backtracking.</p>
<p>Using backtracking, we could incrementally build the combinations. When we find the current combination is not valid, we backtrack and try another option. For the first option, we add the current array element to the current combination array and move this combination to the next index recursively. Similarly, for the second option, we remove the element from the current combination array and move this combination to the next index. Therefore, for every index, we explored two possibilities of including and excluding that value and calculated the combination sum of the maintained combination array. If the desired sum is reached, we can append the list to the answer list. To demonstrate the idea, we showcase how it works with a concrete example in the following tree:</p>
<p><img src="../Figures/40/40.png" alt="fig" /></p>
<p>Are there any optimizations to reduce the backtracking calls? Since we need to return unique combinations, we can group equal values of the array together. The simplest way to group all elements together is by sorting them. Now, suppose the frequency of an element is <code>freq</code>, and you need to make backtracking calls for all its possible frequencies between <code>0</code> and <code>freq</code>, then we can simply pick them from the beginning of its group in the sorted array.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create a list <code>list</code> to store all the unique combinations that sum up to the target.</p>
</li>
<li>
<p>Sort the <code>candidates</code> array to handle duplicates and facilitate the backtracking process.</p>
</li>
<li>
<p>Call the <code>backtrack</code> function with the following parameters:</p>
<ul>
<li><code>answer</code>: List to store the final combinations.</li>
<li><code>tempList</code>: Temporary list to store the current combination.</li>
<li><code>candidates</code>: Input array of numbers.</li>
<li><code>totalLeft</code>: Remaining sum to reach the target.</li>
<li><code>index</code>: Starting index for the current recursion.</li>
</ul>
</li>
<li>
<p>Within the <code>backtrack</code> function:</p>
<ul>
<li>If <code>totalLeft</code> is less than 0, return immediately (invalid path).</li>
<li>If <code>totalLeft</code> equals 0:
<ul>
<li>Add a copy of <code>tempList</code> to <code>answer</code> (valid combination found).</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Iterate over <code>candidates</code> starting from <code>index</code>:
<ul>
<li>Skip duplicate numbers by checking if <code>candidates[i] == candidates[i - 1]</code> for <code>i &gt; index</code>.</li>
<li>Add <code>candidates[i]</code> to <code>tempList</code>.</li>
<li>Recursively call <code>backtrack</code> with:
<ul>
<li>Updated <code>totalLeft</code> reduced by <code>candidates[i]</code>.</li>
<li>Updated <code>index</code> as <code>i + 1</code> to avoid reusing the same element.</li>
</ul>
</li>
<li>Remove the last element from <code>tempList</code> to backtrack and explore other possibilities.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>list</code> containing all unique combinations after the recursive calls complete.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/SGfPMJBF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of <span class="math inline">\(candidates\)</span> in the array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^N)\)</span></p>
<p>In the worst case, our algorithm will exhaust all possible combinations from the input array. Again, in the worst case, let us assume that each number is unique. The number of combinations for an array of size <span class="math inline">\(N\)</span> would be <span class="math inline">\(2^N\)</span>, i.e. each number is included or excluded in a combination.</p>
<p>Additionally, it takes <span class="math inline">\(O(N)\)</span> time to build a counter table out of the input array.</p>
<p>Therefore, the overall time complexity of the algorithm is dominated by the backtracking process, which is <span class="math inline">\(O(2^N)\)</span>.</p>
<p>You must think about how the solution passes the test cases when the value of <span class="math inline">\(N\)</span> goes up to 100. <a href="https://en.wikipedia.org/wiki/Decision_tree_pruning">Pruning</a> is the process of writing some additional conditions within our recursion code that help us to reduce the size of our recursion trees by removing redundant sections. For example, in this problem, the maximum value of any <code>candidates</code> element is given by 50, whereas the maximum <code>target</code> value is 30. So, we can stop the recursion when the value of candidates exceeds the <code>target</code> value. Sorting the array is another way to prune the recursion tree. Checkout the image for an explanation:</p>
<p><img src="../Figures/40/image.png" alt="fig" /></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We first create a <code>tempList</code>, which in the worst case will consume <span class="math inline">\(O(N)\)</span> space to keep track of the combinations. In addition, we apply recursion in the algorithm, which will incur additional memory consumption in the function call stack. In the worst case, the stack will pile up to <span class="math inline">\(O(N)\)</span> space.</p>
<p>To sum up, the overall space complexity of the algorithm is <span class="math inline">\(O(N)\)</span>.</p>
<p>Note: we did not take into account the space needed to hold the final results of the combination in the above analysis.</p>
</li>
</ul>
<hr />
<p>Here are a series of problems you can solve, with some tweaks of the backtracking algorithm presented in this article.</p>
<p><a href="https://leetcode.com/problems/subsets/description/">Subsets</a><br />
<a href="https://leetcode.com/problems/subsets-ii/description/">Subsets II</a><br />
<a href="https://leetcode.com/problems/permutations/description/">Permutations</a><br />
<a href="https://leetcode.com/problems/permutations-ii/description/">Permutations II</a><br />
<a href="https://leetcode.com/problems/combinations/description/">Combinations</a><br />
<a href="https://leetcode.com/problems/combination-sum/description/">Combination Sum</a><br />
<a href="https://leetcode.com/problems/combination-sum-iii/description/">Combination Sum III</a><br />
<a href="https://leetcode.com/problems/palindrome-partitioning/description/">Palindrome Partition</a></p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/combination-sum-ii-1664263832/1" target="_blank" rel="noopener noreferrer">Combination Sum II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;and a&nbsp;<strong>target</strong>, your task is to find all&nbsp;<strong>unique&nbsp;</strong>combinations in the array where the sum is equal to target.&nbsp;</span><span style="font-size: 18px;">Each number in arr[] may only be used <strong>once </strong>in the combination.</span></p>
<p><span style="font-size: 18px;">You can return your answer in&nbsp;<strong>any&nbsp;</strong>order.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> </span><span style="font-size: 18px;">arr[] = [1, 2, 3, 3, 5], target =7</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">[[1, 3, 3], [2, 5]]</span>
<strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Total number of possible combinations are 2.</span></pre>
<pre><span style="font-size: 18px;"><strong><span style="font-size: 18px;">Input:</span> </strong></span><span style="font-size: 18px;">arr[] = [5, 10, 15, 20, 25, 30], target = 30</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">[[5, 10, 15], [5, 25], [10, 20], [30]]</span>
<strong><span style="font-size: 18px;">Explanation: </span></strong><span style="font-size: 18px;">Total number of possible combinations are 4.<br /></span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">arr[] = [6, 5, 7], target = 8
<strong>Output: </strong>[]<br /><strong>Explanation:</strong> There are no possible combinantions such that target sum is 8.</span></pre>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong><br /><span style="font-size: 18px;">1 &lt;= arr.size() &lt;= 100<br />1 &lt;= arr[i] &lt;= 50<br />1 &lt;= target &lt;= 30</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/combination-sum-iii/description" target="_blank" rel="noopener noreferrer">Combination Sum III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>

<ul>
	<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
	<li>Each number is used <strong>at most once</strong>.</li>
</ul>

<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> k = 3, n = 7
<strong>Output:</strong> [[1,2,4]]
<strong>Explanation:</strong>
1 + 2 + 4 = 7
There are no other valid combinations.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 3, n = 9
<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]
<strong>Explanation:</strong>
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> k = 4, n = 1
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= 9</code></li>
	<li><code>1 &lt;= n &lt;= 60</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-smallest-number-from-di-string/description" target="_blank" rel="noopener noreferrer">Construct Smallest Number From DI String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>pattern</code> of length <code>n</code> consisting of the characters <code>&#39;I&#39;</code> meaning <strong>increasing</strong> and <code>&#39;D&#39;</code> meaning <strong>decreasing</strong>.</p>

<p>A <strong>0-indexed</strong> string <code>num</code> of length <code>n + 1</code> is created using the following conditions:</p>

<ul>
	<li><code>num</code> consists of the digits <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code>, where each digit is used <strong>at most</strong> once.</li>
	<li>If <code>pattern[i] == &#39;I&#39;</code>, then <code>num[i] &lt; num[i + 1]</code>.</li>
	<li>If <code>pattern[i] == &#39;D&#39;</code>, then <code>num[i] &gt; num[i + 1]</code>.</li>
</ul>

<p>Return <em>the lexicographically <strong>smallest</strong> possible string </em><code>num</code><em> that meets the conditions.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> pattern = &quot;IIIDIDDD&quot;
<strong>Output:</strong> &quot;123549876&quot;
<strong>Explanation:
</strong>At indices 0, 1, 2, and 4 we must have that num[i] &lt; num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] &gt; num[i+1].
Some possible values of num are &quot;245639871&quot;, &quot;135749862&quot;, and &quot;123849765&quot;.
It can be proven that &quot;123549876&quot; is the smallest possible num that meets the conditions.
Note that &quot;123414321&quot; is not possible because the digit &#39;1&#39; is used more than once.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pattern = &quot;DDD&quot;
<strong>Output:</strong> &quot;4321&quot;
<strong>Explanation:</strong>
Some possible values of num are &quot;9876&quot;, &quot;7321&quot;, and &quot;8742&quot;.
It can be proven that &quot;4321&quot; is the smallest possible num that meets the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length &lt;= 8</code></li>
	<li><code>pattern</code> consists of only the letters <code>&#39;I&#39;</code> and <code>&#39;D&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string pattern consisting of the characters <code>'I'</code> (increasing) and <code>'D'</code>. We need to construct and return in the form of a string the lexicographically smallest number that satisfies certain conditions determined by the pattern.</p>
<blockquote>
<p>The term &quot;lexicographically smallest&quot; refers to the smallest possible sequence of numbers when compared as strings. This means we need to prioritize smaller numbers in the earlier positions when constructing the sequence.</p>
</blockquote>
<p>To break down the problem, let's first understand the requirements. The pattern is a string of length <code>n</code>, where each character dictates the relationship between consecutive digits in the number. The primary goal is to satisfy the following conditions:</p>
<ul>
<li>If <code>pattern[i] == 'I'</code>, then the digit at position <code>i</code> in the number should be smaller than the digit at position <code>i + 1</code>.</li>
<li>If <code>pattern[i] == 'D'</code>, then the digit at position <code>i</code> should be larger than the digit at position <code>i + 1</code>.</li>
</ul>
<p>In other words, this means:</p>
<ul>
<li>At positions where the pattern has <code>'I'</code>, the number must increase.</li>
<li>At positions where the pattern has <code>'D'</code>, the number must decrease.</li>
</ul>
<p>The resulting number, <code>num</code>, has a length of <code>n + 1</code> because it includes one more digit than the pattern. Additionally, the digits used in the number must be distinct, ranging from <code>'1'</code> to <code>'9'</code>, meaning that each digit can appear at most once.</p>
<p>Consider the input pattern <code>&quot;IIIDIDDD&quot;</code>. One valid number that satisfies this pattern is <code>&quot;123549876&quot;</code>. Here's why:</p>
<ul>
<li>For the first three <code>'I'</code>s, the numbers must increase: <code>1 &lt; 2 &lt; 3 &lt; 5</code>.</li>
<li>At position 3, we hit a <code>'D'</code>, so the numbers must decrease: <code>5 &gt; 4</code>.</li>
<li>Then, we have another <code>'I'</code> (position 4), so the number at position 4 must be smaller than the one at position 5: <code>4 &lt; 9</code>.</li>
<li>The rest of the pattern requires a decreasing sequence at positions 5, 6, 7 and 8: <code>9 &gt; 8 &gt; 7 &gt; 6</code>.</li>
</ul>
<p>The number <code>&quot;123549876&quot;</code> is the smallest possible number that adheres to this pattern. Notably, each digit is used only once, and the number is constructed in lexicographically smallest order.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>A straightforward way to solve this problem is to generate all possible arrangements of the digits '1' to '9' and check whether any of them matches the given pattern. Since the constraints are quite small, this brute-force approach will work within the allowed time.</p>
<p>The first step is to determine whether a given sequence of numbers satisfies the pattern. To do this, we define a <code>check</code> function. This function iterates through the pattern and verifies whether each character in the pattern is correctly reflected in the corresponding numbers. If the character is <code>'I'</code>, the number at that position must be smaller than the next one, and if the character is <code>'D'</code>, the number must be greater than the next one. If at any point the sequence does not match the pattern, we return <code>false</code>. Otherwise, if the entire sequence follows the pattern correctly, we return <code>true</code>.</p>
<p>Once we can check if a sequence is valid, the next step is to generate every possible sequence and pick the smallest one that works. We start by creating a sequence of numbers from 1 to <code>n + 1</code> (where <code>n</code> is the length of the pattern) in increasing order. This gives us a unique set of numbers to work with.</p>
<p>To explore all possible orders of these numbers, we can use a built-in function, which systematically generates the next lexicographically greater arrangement of the sequence. For each permutation, we use the <code>check</code> function to verify whether it follows the given pattern. The first valid permutation that satisfies the pattern is our answer, since permutations are generated in lexicographical order, ensuring that the first valid sequence found is also the smallest one.</p>
<h4 id="algorithm">Algorithm</h4>
<h5 id="check-function-pattern-validation"><code>check</code> Function (Pattern Validation):</h5>
<ul>
<li>The <code>check</code> function verifies if the given sequence matches the pattern of <code>'I'</code> (Increasing) and <code>'D'</code> (Decreasing).</li>
<li>For each character in the pattern:
<ul>
<li>If the pattern character is <code>'I'</code>, ensure that the corresponding number in the sequence is in increasing order (<code>sequence[patternIndex] &lt; sequence[patternIndex + 1]</code>).</li>
<li>If the pattern character is <code>'D'</code>, ensure that the corresponding number in the sequence is in decreasing order (<code>sequence[patternIndex] &gt; sequence[patternIndex + 1]</code>).</li>
</ul>
</li>
<li>If any mismatch is found between the sequence and the pattern, return <code>false</code>.</li>
<li>If the sequence matches the pattern for all characters, return <code>true</code>.</li>
</ul>
<h5 id="smallestnumber-function"><code>smallestNumber</code> Function:</h5>
<ul>
<li>Given a pattern string, the <code>smallestNumber</code> function returns the smallest lexicographically valid sequence that matches the pattern.</li>
<li>Initialize a string <code>sequence</code> by creating a sequence of numbers from 1 to <code>n + 1</code>, where <code>n</code> is the length of the pattern.</li>
<li>Convert the sequence into a string by appending numbers (1 through <code>n + 1</code>) to the string <code>sequence</code>.</li>
<li>Generate the initial <code>permutation</code> of the sequence.</li>
<li>Use the <code>next_permutation</code> function to generate successive permutations of the sequence.</li>
<li>Keep generating permutations until a permutation that satisfies the pattern (checked using the <code>check</code> function) is found.</li>
<li>Once a valid permutation is found, return it.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/d24iGeGd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n! \cdot n^2)\)</span></p>
<p>The algorithm generates all possible permutations of the sequence of numbers from 1 to <span class="math inline">\(n + 1\)</span>. The number of permutations of a sequence of length <span class="math inline">\(n + 1\)</span> is <span class="math inline">\((n + 1)!\)</span>, which is <span class="math inline">\(O(n! \cdot n)\)</span>. For each permutation, the algorithm checks if it matches the given pattern using the <code>check</code> function. The <code>check</code> function iterates through the permutation and the pattern, performing comparisons, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Since there are <span class="math inline">\(O(n! \cdot n)\)</span> permutations and each check takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n! \cdot n^2)\)</span>. This is because the algorithm may need to check all permutations in the worst case before finding the correct one.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a string <code>sequence</code> to store the initial sequence of numbers from 1 to <span class="math inline">\(n + 1\)</span>, which requires <span class="math inline">\(O(n)\)</span> space. Additionally, it uses a string <code>permutation</code> to store the current permutation being checked, which also requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>The <code>check</code> function uses constant extra space for comparisons, and the built-in function operates in-place, requiring no additional space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, dominated by the storage of the <code>sequence</code> and <code>permutation</code> strings.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimization-with-bit-masking">Approach 2: Optimization with Bit Masking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A different way to construct the smallest valid number is to use bit masking to track which digits have already been used, rather than generating and checking every single permutation like we did in the first approach. By representing the digits 1 to 9 as individual bits in an integer, we can quickly check whether a digit is available.</p>
<p>To construct the number, we start with an empty sequence and recursively attempt to place digits while ensuring that they satisfy the given pattern. The core idea is to define a recursive function that keeps track of three things: (1) the current position in the pattern, (2) a bitmask representing which digits have already been used, and (3) the number being formed. Initially, we start at position 0 with an empty number and aim to fill all positions while maintaining the constraints imposed by the pattern.</p>
<p>At each step, we loop through digits from 1 to 9 and check two conditions before placing a digit:</p>
<ol>
<li><strong>Is the digit already used?</strong> The bitmask helps here â€” we can efficiently check whether a digit is available by inspecting its corresponding bit.</li>
<li><strong>Does the digit follow the pattern constraint?</strong> If the previous character in the pattern is <code>'I'</code>, the current digit must be greater than the last one placed. If it's <code>'D'</code>, the current digit must be smaller.</li>
</ol>
<p>If a digit satisfies both conditions, we make a recursive call to the next position, appending this digit to our number. We also update the bitmask to mark this digit as used, ensuring it won't be selected again. Since our goal is to find the lexicographically smallest number, we explore digits in increasing order, ensuring that the first valid solution we find is also the smallest.</p>
<p>The recursion proceeds until we have placed all required digits. Once a complete sequence is formed, we compare it with the smallest valid number found so far and continue searching for a better (smaller) result if possible.</p>
<p>The recursion terminates when all positions have been filled (i.e., when <code>currentPosition</code> exceeds the length of the pattern). At this point, we have successfully constructed a valid number, which we return as the final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="findsmallestnumber-function"><code>findSmallestNumber</code> Function:</h5>
<ul>
<li>
<p>This recursive function finds the smallest number that satisfies the given pattern.</p>
</li>
<li>
<p>Base Case: If the current position exceeds the pattern length, return the current number (<code>currentNum</code>).</p>
</li>
<li>
<p>Initialize <code>result</code> as some max value to track the smallest valid number.</p>
</li>
<li>
<p>Retrieve the last digit of the current number (<code>lastDigit</code>).</p>
</li>
<li>
<p>Determine if the next digit should be larger or smaller based on the previous character in the pattern:</p>
<ul>
<li>If <code>currentPosition == 0</code> or the previous pattern character is <code>'I'</code>, the next digit should be larger.</li>
<li>Otherwise, the next digit should be smaller.</li>
</ul>
</li>
<li>
<p>For each possible digit from 1 to 9:</p>
<ul>
<li>Check if the digit has already been used by checking the <code>usedDigitsMask</code>.</li>
<li>Ensure the digit follows the pattern (greater or smaller than the last digit based on the pattern).</li>
<li>If valid, recursively call <code>findSmallestNumber</code> with the updated parameters:
<ul>
<li>Move to the next position in the pattern.</li>
<li>Mark the current digit as used by updating the <code>usedDigitsMask</code>.</li>
<li>Update the <code>currentNum</code> by appending the current digit.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Once the recursive function completes and finds the smallest valid number, return the result.</p>
</li>
</ul>
<h5 id="smallestnumber-function-1">smallestNumber Function:</h5>
<ul>
<li>The main function converts the result of <code>findSmallestNumber</code> to a string and returns it.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Yv4o8XZd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(9^n)\)</span></p>
<p>The algorithm uses a recursive approach to explore all possible combinations of digits (from 1 to 9) that satisfy the given pattern. At each step, it tries all unused digits (up to 9 choices) and recursively checks if they fit the pattern. In the worst case, the recursion depth is <span class="math inline">\(n + 1\)</span> (one level for each character in the pattern plus one for the base case), and at each level, there are up to 9 choices.</p>
<p>This results in an exponential number of recursive calls, leading to a time complexity of <span class="math inline">\(O(9^n)\)</span>. This is because the recursion tree has a branching factor of 9 and a depth of <span class="math inline">\(n + 1\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the recursion stack. In the worst case, the recursion depth is <span class="math inline">\(n + 1\)</span>, which means the stack can grow up to <span class="math inline">\(O(n)\)</span> levels deep. Additionally, the algorithm uses a few auxiliary variables like <code>currentPosition</code>, <code>usedDigitsMask</code>, and <code>currentNum</code>, which occupy constant space.</p>
<p>The <code>usedDigitsMask</code> is an integer used to track which digits have been used, and it does not grow with the input size. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, primarily due to the recursion stack.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-regulated-brute-force-via-recursion">Approach 3: Regulated Brute Force via Recursion</h3>
<h4 id="intuition-2">Intuition</h4>
<p>A key observation is how the digits must be arranged based on the given pattern. When we see an <code>'I'</code>, the numbers should be in increasing order, which is straightforward to handle. However, when we encounter a <code>'D'</code>, the numbers should be in decreasing order, which introduces complexity.</p>
<p>If the pattern consists only of <code>'I'</code> characters, the solution is simple. For example, with the pattern <code>&quot;III&quot;</code>, the answer would be <code>&quot;1234&quot;</code> â€” we just place the smallest available number at each step in sequential order. This is because each <code>'I'</code> ensures that the next number must be greater than the previous one, so we can directly append numbers in increasing order.</p>
<p>However, when we introduce <code>'D'</code> into the pattern, we must be more careful. A <code>'D'</code> means that the current number must be larger than the next one, and we canâ€™t just keep adding numbers sequentially as we did for <code>'I'</code>. The challenge is that when we see a <code>'D'</code>, we don't immediately know how many consecutive <code>'D'</code> characters will follow, which affects how we assign numbers.</p>
<p>To resolve this, when we encounter a <code>'D'</code>, instead of placing a number at that position immediately, we delay the decision. We keep processing the pattern recursively until we reach an <code>'I'</code> or the end of the pattern. Once weâ€™ve fully processed all future indices, we &quot;unwind&quot; the recursion and start placing numbers in reverse order. This ensures that the numbers corresponding to the <code>'D'</code> positions are placed in descending order, maintaining the correct decreasing relationship.</p>
<p>To keep track of how many positions we have assigned a digit to, we introduce a variable <code>currentCount</code>. Clearly, the next available digit at any point is <code>currentCount + 1</code>.</p>
<p>For an <code>'I'</code>, we can simply place the next available number and move forward. The recursive relation in this case follows a natural increasing order: we call the helper function for the next index and proceed normally leading to <code>buildSequence(currentIndex = currentIndex + 1, currentCount = currentIndex + 1, patternArray, result)</code>.</p>
<p>However, for a <code>'D'</code>, we defer placement and allow recursion to handle future numbers first. By the time we return from the recursive calls, we are guaranteed to place the correct larger number first, followed by smaller ones, satisfying the <code>'D'</code> condition. As we skip assigning a digit to the current position, we simply move to the next index without incrementing the <code>currentCount</code>: <code>buildSequence(currentIndex = currentIndex + 1, currentCount, patternArray, result)</code>.</p>
<p>For example, consider the pattern <code>&quot;IIIDIDDD&quot;</code>. The first three <code>'I'</code> characters result in <code>&quot;1234&quot;</code>, following a simple increasing sequence. However, once we reach <code>'D'</code>, we stop placing numbers immediately and let recursion take control. After unwinding, we correctly place <code>&quot;5&quot;</code> before <code>&quot;4&quot;</code>, then continue the <code>'D'</code> sequence properly, resulting in <code>&quot;123549876&quot;</code>.</p>
<p>Since numbers are appended at the bottom of the recursion stack, the final sequence is initially built in reverse order. To get the correct lexicographical order, we reverse the string at the end.</p>
<blockquote>
<p>For a more comprehensive understanding of recursion, check out the <a href="https://leetcode.com/explore/learn/card/recursion-i/">Recursion Explore Card ðŸ”—</a>. This resource provides an in-depth look at recursion, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>result</code> as an empty string.</p>
</li>
<li>
<p>Call <code>buildSequence</code> recursively with <code>currentIndex = 0</code> and <code>currentCount = 0</code> to construct the sequence.</p>
</li>
<li>
<p>Reverse <code>result</code> after recursion completes.</p>
</li>
<li>
<p>Return <code>result</code> as the final smallest number.</p>
</li>
<li>
<p>In <code>buildSequence</code>:</p>
<ul>
<li>If <code>currentIndex</code> is not at the end of <code>pattern</code>:
<ul>
<li>If <code>pattern[currentIndex]</code> is 'I', increment <code>currentCount</code> and recurse with the next index.</li>
<li>If <code>pattern[currentIndex]</code> is 'D', recurse without incrementing <code>currentCount</code> and recurse with the next index.</li>
</ul>
</li>
<li>Append <code>currentCount + 1</code> to <code>result</code> to construct the sequence in reverse order.</li>
<li>Return <code>currentCount + 1</code> to propagate the correct value upward in recursion.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RPnzTqTC/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a recursive approach to build the sequence based on the pattern. Each recursive call processes one character of the pattern, and the recursion depth is at most <span class="math inline">\(n + 1\)</span> (one level for each character in the pattern plus one for the base case). Since each recursive call performs a constant amount of work (appending to the <code>result</code> and updating the count), the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the final reversal of the <code>result</code> takes <span class="math inline">\(O(n)\)</span> time, but this is a single operation and does not change the overall linear time complexity. Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the recursion stack and the <code>result</code>. The recursion stack can grow up to <span class="math inline">\(n + 1\)</span> levels deep, requiring <span class="math inline">\(O(n)\)</span> space. The <code>result</code> also grows linearly with the input size, storing up to <span class="math inline">\(n + 1\)</span> characters, which requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>currentIndex</code> and <code>currentCount</code>, which occupy constant space. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>, primarily due to the recursion stack and the <code>result</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-stack">Approach 4: Using Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The problems that are solved via recursion can almost always be solved using a stack as well. The reason is that recursion inherently uses a call stack to keep track of function calls, storing the current state before diving deeper into the problem. Each recursive call pushes a new frame onto the call stack, which holds the functionâ€™s local variables and execution context. When the base case is reached, the function calls start returning, effectively unwinding the stack in a last-in, first-out (LIFO) manner.</p>
<p>In this case, the core idea is to use a stack to manage the order in which numbers are appended. The stack helps handle consecutive <code>'D'</code> characters efficiently by delaying their placement, ensuring that numbers in a decreasing sequence are correctly placed in the smallest lexicographical order.</p>
<p>More specifically, we iterate through the pattern while pushing numbers onto the stack. Every time we see a <code>'D'</code>, we push the current number onto the stack and continue, delaying its placement in the result. This is because a <code>'D'</code> means the next number should be smaller than the current one, so we must delay placing the numbers to ensure that they appear in decreasing order when finally appended.</p>
<p>When we encounter an <code>'I'</code> or reach the end of the pattern, we know that all numbers stored in the stack must now be placed in the result to maintain the correct order. At this point, we start popping from the stack, appending each number to the result before moving forward. This guarantees that any numbers stored due to a sequence of <code>'D'</code> characters appear in descending order, ensuring the smallest valid number.</p>
<p>For example, given the pattern <code>&quot;IDID&quot;</code>, we start by pushing <code>1</code> onto the stack because we always push the next number. Since the first character is <code>'I'</code>, we immediately pop from the stack and append <code>1</code> to the result. Then we push <code>2</code> and, seeing the next <code>'D'</code>, we push <code>3</code> instead of immediately appending. The <code>'I'</code> that follows tells us it's time to pop and append the numbers, so <code>3</code> and then <code>2</code> are added to the result, maintaining the required decreasing order. The process continues in this manner, ensuring that the number we build respects the pattern while remaining lexicographically smallest.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty string <code>result</code> to store the final smallest number.</p>
</li>
<li>
<p>Use a <code>stack</code> named <code>numStack</code> to manage digits based on the pattern.</p>
</li>
<li>
<p>Iterate through the <code>pattern</code>:</p>
<ul>
<li>Push <code>index + 1</code> onto <code>numStack</code>, ensuring numbers are pushed in increasing order.</li>
<li>If at the end of the pattern or the current character is <code>'I'</code>:
<ul>
<li>Pop all elements from <code>numStack</code> and append them to <code>result</code>, ensuring that decreasing sequences are handled before moving to the next increasing sequence.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code> as the smallest number following the given pattern.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/4qKnP7Fr/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the <code>pattern</code> string once, processing each character exactly once. In each iteration, we push at most one number onto the stack, contributing <span class="math inline">\(O(n)\)</span> operations in total. Additionally, whenever we encounter <code>'I'</code> or reach the end, we pop all elements from the stack. Since each number is pushed and popped exactly once, this also contributes <span class="math inline">\(O(n)\)</span>. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The extra space usage comes from the <code>stack</code>, which, in the worst case, holds all numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n+1\)</span>. This happens when the entire <code>pattern</code> consists of <code>'D'</code> characters, causing all numbers to be pushed before any are popped. Thus, the worst-case space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-greedy-approach-with-sliding-window-reversal">Approach 5: Greedy Approach with Sliding Window Reversal</h3>
<h4 id="intuition-4">Intuition</h4>
<p>A more structured approach to constructing the smallest number that fits the given pattern is to use a <strong>greedy strategy with a sliding window reversal technique</strong>. Instead of constructing the number from scratch, we begin with a baseline sequence of consecutive numbers (e.g., <code>123456789</code> for a pattern of length <code>n</code>). This ensures that we always start with the smallest possible number and then modify it as needed to satisfy the given pattern.</p>
<p>The idea is to use two pointers: <code>currentIndex</code>, which traverses the pattern, and <code>previousIndex</code>, which marks the start of the segment that needs to be reversed after we encounter a <code>'D'</code> (Decreasing) character. Whenever we find an <code>'I'</code> (Increasing) or reach the end of the pattern, we reverse the segment between <code>previousIndex</code> and <code>currentIndex</code> to ensure that the digits follow the required decreasing order.</p>
<p>For each character in the pattern:</p>
<ul>
<li>If the current character is <code>'I'</code>, no modification is required because the sequence already maintains increasing order.</li>
<li>If the current character is <code>'D'</code>, we continue moving until we find an <code>'I'</code> or reach the end of the pattern. Once we find an <code>'I'</code> or exhaust the pattern, we reverse the substring from <code>previousIndex</code> to <code>currentIndex</code> to create the required decreasing order.</li>
</ul>
<p>Consider an example where the pattern is <code>&quot;DDI&quot;</code>:</p>
<ol>
<li>We initialize our sequence as <code>&quot;1234&quot;</code>, since the pattern length is 3.</li>
<li>The first character is <code>'D'</code>, so we continue scanning until we reach an <code>'I'</code>. Once we reach the <code>'I'</code>, we reverse the first three elements (<code>&quot;123&quot; â†’ &quot;321&quot;</code>).</li>
<li>Since the final character is <code>'I'</code>, no further modifications are needed, and we append the last digit as is.</li>
<li>The final result is <code>&quot;3214&quot;</code>.</li>
</ol>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>
<p>Initialize a string called <code>result</code> to store the final result.</p>
</li>
<li>
<p>Iterate through the <code>pattern</code>:</p>
<ul>
<li>
<p>Use <code>currentIndex</code> to traverse the pattern and <code>previousIndex</code> to mark the start of the substring that may need to be reversed.</p>
</li>
<li>
<p>Append the value <code>1 + currentIndex</code> to <code>result</code>.</p>
</li>
<li>
<p>When necessary, reverse the substring starting from <code>previousIndex</code>:</p>
<ul>
<li>If <code>currentIndex</code> reaches the end of the pattern or the current character in the pattern is <code>'I'</code>:
<ul>
<li>Create a temporary string (<code>temp</code>) and reverse the substring starting from <code>previousIndex</code> to <code>currentIndex</code>.</li>
<li>Update <code>result</code> by concatenating the part before <code>previousIndex</code> and the reversed substring from <code>previousIndex</code> onward.</li>
<li>Update <code>previousIndex</code> to <code>currentIndex + 1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the final <code>result</code> as a string.</p>
</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/Amx83eMt/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the input string <code>pattern</code> once, which takes <span class="math inline">\(O(n)\)</span> time. During each iteration, when the character is 'I' or the end of the string is reached, the algorithm reverses a contiguous segment of the <code>result</code> string. While reversing a substring of length <span class="math inline">\(k\)</span> takes <span class="math inline">\(O(k)\)</span> time, each position in the array is reversed at most once throughout the entire process.</p>
<p>Since each element participates in at most one reversal, the total number of operations across all reversals is at most <span class="math inline">\(O(n)\)</span>. Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses an extra string <code>result</code> to store the intermediate and final result, which grows linearly with the input size, requiring <span class="math inline">\(O(n)\)</span> space. Additionally, a temporary extra string named <code>temp</code> is used during substring reversal, which also requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>currentIndex</code> and <code>previousIndex</code>, which occupy constant space. Thus, the dominant space usage comes from the extra strings, making the overall space complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-6-optimized-greedy-approach-with-precomputed-d-segments">Approach 6: Optimized Greedy Approach with Precomputed 'D' Segments</h3>
<h4 id="intuition-5">Intuition</h4>
<p>The previous approach used a sliding window reversal to handle decreasing sequences efficiently. An alternate strategy would involve precomputing the number of consecutive <code>'D'</code>s at each position. This allows us to directly determine the correct digit placement without the need for explicit reversal operations.</p>
<p>Instead of modifying an existing sequence as we traverse the pattern, we first scan the pattern <strong>backward</strong> to compute an array <code>arrD[i]</code>, where each entry represents the number of consecutive <code>'D'</code>s that appear after the corresponding position. This precomputed information allows us to determine the exact digit that should be placed in each position without needing to reverse segments manually.</p>
<p>As we build the answer, we maintain two key values:</p>
<ol>
<li><code>maxSoFar</code>: The largest number assigned so far.</li>
<li><code>currMax</code>: A helper variable to ensure that subsequent digits are placed in proper increasing order, preventing conflicts between previously placed numbers.</li>
</ol>
<p>When encountering an <code>'I'</code>, we simply assign the smallest available number, which is <code>maxSoFar + 1</code>. However, when encountering a <code>'D'</code>, we need to ensure that the digits form a descending order. To achieve this, we use <code>arrD[i]</code> to determine how far the descending sequence extends. Instead of constructing the decreasing sequence step by step, we calculate the correct number directly:</p>
<p><span class="math inline">\(\text{digit} = 1 + \text{maxSoFar} + \text{arrD}[i]\)</span></p>
<p>This formula ensures that:</p>
<ul>
<li>The assigned number is large enough to maintain the required descending order.</li>
<li>The sequence remains lexicographically minimal by assigning the smallest possible numbers that satisfy the constraints.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2375_fix/optimized_greedy_fix.json:1120,475!?!</p>
<h4 id="algorithm-5">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>patternLength</code> to the length of the input <code>pattern</code>.</p>
</li>
<li>
<p>Initialize <code>maxSoFar</code> and <code>currMax</code> to 0, which will keep track of the largest digits used so far.</p>
</li>
<li>
<p>Initialize a vector <code>arrD</code> of size <code>patternLength + 1</code> to store the lengths of decreasing subsequences in the pattern.</p>
</li>
<li>
<p>Calculate the lengths of decreasing subsequences in the pattern:</p>
<ul>
<li>Iterate backward through the <code>pattern</code>:
<ul>
<li>If the current character is <code>'D'</code>, calculate the length of the decreasing subsequence starting from the current index as <code>arrD[patternIndex + 1] + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize an empty string <code>result</code> to build the final result.</p>
</li>
<li>
<p>Build the result string based on the pattern:</p>
<ul>
<li>Iterate through each position in the pattern:
<ul>
<li>If the current character is <code>'I'</code>, increment <code>maxSoFar</code>, append it to <code>result</code>, and update <code>maxSoFar</code>, as the maximum of its current value and <code>currMax</code>.</li>
<li>If the current character is <code>'D'</code>, calculate the appropriate digit from <code>maxSoFar</code> and <code>arrD[position]</code>, append it to <code>result</code>, and update <code>currMax</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the <code>result</code>, which represents the smallest number satisfying the pattern.</p>
</li>
</ul>
<h4 id="implementation-5">Implementation</h4>
<p><a href="https://leetcode.com/playground/XLhyzwNC/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>pattern</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm processes the input string <code>pattern</code> in two main steps. First, it performs a backward traversal to compute the lengths of decreasing subsequences. This step iterates through the string once, taking <span class="math inline">\(O(n)\)</span> time. Second, it performs a forward traversal to construct the result string based on the computed subsequence lengths. This step also iterates through the string once, taking <span class="math inline">\(O(n)\)</span> time. Since both steps are linear and independent, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the use of built-in functions and string concatenation (<code>+=</code>) does not increase the time complexity beyond <span class="math inline">\(O(n)\)</span>, as these operations are either constant time or linear in the context of this algorithm. Thus, the total time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses additional space for two main purposes. First, it stores the lengths of decreasing subsequences in an array <code>arrD</code>, which requires <span class="math inline">\(O(n)\)</span> space. Second, it constructs the result string, which also grows linearly with the input size, requiring <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these, the algorithm uses a few auxiliary variables like <code>maxSoFar</code>, <code>currMax</code>, and <code>temp</code>, which occupy constant space. Therefore, the dominant space usage comes from the array <code>arrD</code> and the result string, making the overall space complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/description" target="_blank" rel="noopener noreferrer">Construct the Lexicographically Largest Valid Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, find a sequence with elements in the range <code>[1, n]</code> that satisfies all of the following:</p>

<ul>
	<li>The integer <code>1</code> occurs once in the sequence.</li>
	<li>Each integer between <code>2</code> and <code>n</code> occurs twice in the sequence.</li>
	<li>For every integer <code>i</code> between <code>2</code> and <code>n</code>, the <strong>distance</strong> between the two occurrences of <code>i</code> is exactly <code>i</code>.</li>
</ul>

<p>The <strong>distance</strong> between two numbers on the sequence, <code>a[i]</code> and <code>a[j]</code>, is the absolute difference of their indices, <code>|j - i|</code>.</p>

<p>Return <em>the <strong>lexicographically largest</strong> sequence</em><em>. It is guaranteed that under the given constraints, there is always a solution. </em></p>

<p>A sequence <code>a</code> is lexicographically larger than a sequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, sequence <code>a</code> has a number greater than the corresponding number in <code>b</code>. For example, <code>[0,1,9,0]</code> is lexicographically larger than <code>[0,1,5,6]</code> because the first position they differ is at the third number, and <code>9</code> is greater than <code>5</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [3,1,2,3,2]
<strong>Explanation:</strong> [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5
<strong>Output:</strong> [5,3,1,4,3,5,2,4,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, we need to find the lexicographically largest sequence that satisfies all of these conditions:</p>
<ul>
<li>The integer <code>1</code> occurs once in the sequence.</li>
<li>All other integers from <code>2</code> to <code>n</code> occur exactly twice, and the distance between these occurrences is equal to the value of this integer.</li>
</ul>
<p>The distance between two integers is defined as the difference in the indices of both the integers. For example: in the array <code>nums = [1,2,3,1,2]</code>, the distance between both occurences of 1 is given by 3.</p>
<blockquote>
<p>A sequence <code>a</code> is lexicographically larger than a sequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, sequence <code>a</code> has a number greater than the corresponding number in <code>b</code>. For example, <code>[0,1,9,0]</code> is lexicographically larger than <code>[0,1,5,6]</code> because the first position they differ is at the third number, and 9 is greater than 5.</p>
</blockquote>
<hr />
<h3 id="approach-backtracking">Approach: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>Observe the lexicographically largest sequences for smaller values of <code>n</code>:</p>
<ul>
<li>For <code>n = 1</code>: <code>[1]</code></li>
<li>For <code>n = 2</code>: <code>[2, 1, 2]</code></li>
<li>For <code>n = 3</code>: <code>[3, 1, 2, 3, 2]</code></li>
<li>For <code>n = 4</code>: <code>[4, 2, 3, 2, 4, 3, 1]</code></li>
</ul>
<p>Identifying an intuitive pattern for these sequences is challenging. Given that <code>n</code> lies in the range <code>1 &lt;= n &lt;= 20</code>, we can generate all possible valid sequences and find the lexicographically largest among them using backtracking. We'll use a recursive boolean function to determine whether the current sequence is valid. If it's not, we can terminate the recursive process early.</p>
<p>Let's represent the recursive function as <code>bool findLargestSequence(currentIndex, resultSequence, isNumberUsed, targetNumber)</code>, where we start with an empty sequence <code>resultSequence</code> and assign values from <code>1</code> to <code>n</code> one by one at the <code>currentIndex</code>. However, since we want to find the lexicographically maximum sequence, we can start assigning the values from <code>n</code> to <code>1</code>, in decreasing order. This would help us assign greater values at the beginning of the list. Therefore, the first valid list created would be the lexicographically greatest one.</p>
<p>The base case occurs when <code>currentIndex</code> reaches the end of the sequence, signaling that a valid solution has been constructed. We return <code>true</code> and save the current sequence as the answer.</p>
<p>We will try to place all the values from <code>n</code> to <code>1</code> at the <code>currentIndex</code>. If the value to be assigned, <code>numberToPlace</code>, is not <code>1</code>, we must assign this value at an index located <code>numberToPlace</code> positions away to create a valid sequence. If that position, given by <code>numberToPlace + currentIndex</code>, already contains a value, the current sequence is invalid, and we cannot assign the current value to this index. So we move to the next possible value for <code>numberToPlace</code> and check if it can be assigned to the current index. For <code>numberToPlace = 1</code>, we can proceed directly to the next index.</p>
<p>After assigning <code>numberToPlace</code>, we recursively attempt to fill subsequent positions by passing the modified sequence and incrementing the <code>currentIndex</code> in the recursive state. However, backtracking requires that we undo the assignments at both <code>currentIndex</code> and <code>currentIndex + numberToPlace</code> to explore other valid sequences. So we unassign the values at both these indices and repeat the process for other values of <code>numberToPlace</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Recursive Helper Function <code>findLexicographicallyLargestSequence(currentIndex, resultSequence, isNumberUsed, targetNumber)</code>:</p>
<ul>
<li>If <code>currentIndex</code> equals the size of <code>resultSequence</code>, return <code>true</code> as the sequence is fully constructed.</li>
<li>If <code>resultSequence[currentIndex]</code> is not zero, recursively call the function for <code>currentIndex + 1</code>.</li>
<li>Loop through numbers from <code>targetNumber</code> down to <code>1</code> to ensure a lexicographically largest result.
<ul>
<li>If <code>isNumberUsed[numberToPlace] == true</code>, continue to the next number.</li>
<li>Mark the number as used by setting <code>isNumberUsed[numberToPlace] = true</code>.</li>
<li>Place <code>numberToPlace</code> at <code>currentIndex</code> in <code>resultSequence</code>.</li>
<li>If <code>numberToPlace == 1</code>, directly move to the next index and recursively call the function. If the recursion returns <code>true</code>, return <code>true</code>.</li>
<li>For larger numbers, check if <code>currentIndex + numberToPlace</code> is a valid index and that position is empty. If valid:
<ul>
<li>Place <code>numberToPlace</code> at <code>currentIndex + numberToPlace</code>.</li>
<li>Recursively call the function and return <code>true</code> if the recursion succeeds.</li>
<li>Undo the placement at <code>currentIndex + numberToPlace</code> for backtracking.</li>
</ul>
</li>
<li>Undo the current placement and mark <code>numberToPlace</code> as unused.</li>
</ul>
</li>
<li>Return <code>false</code> if no valid placement is found.</li>
</ul>
<p>Main Function:</p>
<ul>
<li>Initialize <code>resultSequence</code> as a vector of size <code>2 * targetNumber - 1</code>, filled with zeros, to store the final sequence.</li>
<li>Create a boolean vector <code>isNumberUsed</code> of size <code>targetNumber + 1</code>, initialized to <code>false</code>, to track the numbers already placed in the sequence.</li>
<li>Call the recursive helper function <code>findLexicographicallyLargestSequence(0, resultSequence, isNumberUsed, targetNumber)</code> to construct the sequence.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QHtdmgDi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the target number.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n!)\)</span></p>
<p>The recursive function generates permutations by exploring all possible ways to arrange a set of numbers. For a given target number <code>n</code>, the function places each number from <code>n</code> down to 1 at every valid index in the sequence. Since there are <code>n</code> possible choices for the first number, <code>n-1</code> choices for the second, and so on, the total number of possible arrangements is the factorial of <code>n</code>, denoted as <span class="math inline">\(O(n!)\)</span>. This is because each recursive call explores a new possibility by reducing the problem size by 1 until all positions are filled, creating a tree-like structure with <code>n!</code> leaves at the deepest level.</p>
<p>However, while the theoretical time complexity is <span class="math inline">\(O(n!)\)</span>, the actual runtime is often much lower in practice. This is due to early pruning of invalid states during the backtracking process. The algorithm can stop as soon as it finds the lexicographically largest valid permutation or an invalid permutation, avoiding further exploration of unnecessary branches. This reduces the number of recursive calls significantly, as many permutations are discarded without fully exploring their subtrees.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursion depth is bounded by <code>n</code> due to backtracking. Additional space is required for the <code>resultSequence</code> and <code>isNumberUsed</code> lists, both of size <span class="math inline">\(O(n)\)</span>. Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/description" target="_blank" rel="noopener noreferrer">Count Number of Maximum Bitwise-OR Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, find the <strong>maximum</strong> possible <strong>bitwise OR</strong> of a subset of <code>nums</code> and return <em>the <strong>number of different non-empty subsets</strong> with the maximum bitwise OR</em>.</p>

<p>An array <code>a</code> is a <strong>subset</strong> of an array <code>b</code> if <code>a</code> can be obtained from <code>b</code> by deleting some (possibly zero) elements of <code>b</code>. Two subsets are considered <strong>different</strong> if the indices of the elements chosen are different.</p>

<p>The bitwise OR of an array <code>a</code> is equal to <code>a[0] <strong>OR</strong> a[1] <strong>OR</strong> ... <strong>OR</strong> a[a.length - 1]</code> (<strong>0-indexed</strong>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:
- [3]
- [3,1]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong> All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 2<sup>3</sup> - 1 = 7 total subsets.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,5]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 16</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The key insight here is that the maximum OR value will always be the result of OR-ing all the numbers in the array. Why? Because OR is an operation that only adds bits, it never removes them. So including more numbers can only increase (or keep the same) the OR value, never decrease it.</p>
<p>For example, consider 3 numbers: 1 (001), 4 (100), and 2 (010).</p>
<p>ORing the three numbers means we look at the bits in each position and combine them using the OR operation to get the resultant bit. Notice that the resultant bit will be 0 only when all the bits at that position are 0, otherwise, it will always be 1. This means that the worst-case scenario is that the bit remains the same, and in all other cases, the bit increases in value.</p>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>To count all subsets of <code>nums</code> that yield the maximum OR value, we can generate all possible subsets recursively. For each number, we choose either to include it in the subset or exclude it.</p>
<p>In the recursion, we first check if we've reached the end of the array. If so, we compare the accumulated OR value with the precomputed maximum OR value. If they match, we have a valid subset and return 1.</p>
<p>If we haven't reached the end, we proceed by making two recursive calls: one excluding the current number and another including it. The total count of valid subsets is the sum of these two results.</p>
<p>The main function initiates this recursive process from the start of the array, and the final result gives the total count of subsets with the maximum OR value.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable <code>maxOrValue</code> to 0.</p>
</li>
<li>
<p>Iterate through each number <code>num</code> in the input array <code>nums</code>.</p>
<ul>
<li>Update <code>maxOrValue</code> by performing a bitwise OR operation with <code>num</code>.</li>
</ul>
</li>
<li>
<p>Call the recursive function <code>countSubsets</code> with initial parameters: <code>nums</code>, index 0, current OR value 0, and the target OR value <code>maxOrValue</code>. Return its result as the answer.</p>
</li>
<li>
<p>Define a function <code>countSubsets</code> with parameters: the <code>nums</code> array, <code>index</code>, <code>currentOr</code>, and <code>targetOr</code>.</p>
<ul>
<li>Check if <code>index</code> has reached the end of the array.
<ul>
<li>If so, return 1 if <code>currentOr</code> equals <code>targetOr</code>, otherwise return 0.</li>
</ul>
</li>
<li>Recursively call <code>countSubsets</code> without including the current number, incrementing the index. Store the result in a variable <code>countWithout</code>.</li>
<li>Recursively call <code>countSubsets</code> including the current number, incrementing the index, and updating the current OR value. Store the result in a variable <code>countWith</code>.</li>
<li>Return the sum of <code>countWithout</code> and <code>countWith</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/nJLGxbWk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The initial loop to find <code>maxOrValue</code> takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The main complexity comes from the recursive <code>countSubsets</code> function, which generates all possible subsets of the input array. For each element, the algorithm makes two choices, leading to a total of <span class="math inline">\(2^n\)</span> subsets. Each recursive call does <span class="math inline">\(O(1)\)</span> work (bitwise OR operation and comparisons).</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, the recursive call stack goes <span class="math inline">\(n\)</span> levels deep. Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-memoization">Approach 2: Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Consider this example with <code>nums = [3, 1, 2, 4]</code>. During recursion, we might encounter two similar states:</p>
<ol>
<li>Subset 1: <code>[3, 1]</code> with <code>index = 2</code></li>
<li>Subset 2: <code>[3]</code> with <code>index = 2</code></li>
</ol>
<p>In both cases, the accumulated OR value and the current index are the same, which is known as an overlapping sub-problem.</p>
<p>Memoization helps eliminate repeated calculations by storing the results of sub-problems the first time they're encountered. Each recursive state can be uniquely identified by the OR value up to that point and the current array index. To store these results, we use a 2D <code>memo</code> array.</p>
<p>At each recursion step, we first check if the current state exists in <code>memo</code>. If it does, we return the stored value. Otherwise, we calculate the result and store it in <code>memo</code> for future reference.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable:</p>
<ul>
<li><code>n</code> to the length of <code>nums</code>.</li>
<li><code>maxOrValue</code> to 0.</li>
</ul>
</li>
<li>
<p>Iterate through each number in the input array <code>nums</code>:</p>
<ul>
<li>Update <code>maxOrValue</code> by performing a bitwise OR operation with the current number.</li>
</ul>
</li>
<li>
<p>Create a 2D array <code>memo</code> of size <code>n * (maxOrValue + 1)</code> to store intermediate results.</p>
</li>
<li>
<p>Call the recursive function <code>countSubsetsRecursive</code> with initial parameters: <code>nums</code>, <code>index</code> 0, <code>currentOr</code> value 0, the <code>targetOr</code> value <code>maxOrValue</code>, and the memoization array <code>memo</code>. Return the result as our answer.</p>
</li>
<li>
<p>Define a function <code>countSubsetsRecursive</code> with parameters: the <code>nums</code> array, <code>index</code>, <code>currentOr</code>, <code>targetOr</code>, and the dp array <code>memo</code>.</p>
<ul>
<li>Check if the current <code>index</code> has reached the end of the array:
<ul>
<li>If so, return 1 if the current OR value equals the target OR value, otherwise, return 0.</li>
</ul>
</li>
<li>If the result for the current state (<code>index</code>, <code>currentOr</code>) is already memoized, return it.</li>
<li>Recursively call <code>countSubsetsRecursive</code> without including the current number, incrementing the index. Store the result in a variable <code>countWithout</code>.</li>
<li>Recursively call <code>countSubsetsRecursive</code> including the current number, incrementing the index, and updating the current OR value. Store the result in a variable <code>countWith</code>.</li>
<li>The sum of <code>countWithout</code> and <code>countWith</code> is our result. Store it in the <code>memo</code> and return it.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ih3tZMvY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code> and <span class="math inline">\(\text{maxOrValue}\)</span> be the maximum possible OR value.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \text{maxOrValue})\)</span></p>
<p>Like the previous approach, the initial loop to find <code>maxOrValue</code> takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Each state of the <code>countSubsetsRecursive</code> function is defined by two parameters: the current index (<span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>) and the current OR value (<span class="math inline">\(0\)</span> to <span class="math inline">\(\text{maxOrValue}\)</span>). So, there are <span class="math inline">\(n \cdot (\text{maxOrValue} + 1)\)</span> possible states. Since each state is computed at most once, the time complexity of the function is <span class="math inline">\(O(n \cdot \text{maxOrValue})\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n) + O(n \cdot \text{maxOrValue}) = O(n \cdot \text{maxOrValue})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot \text{maxOrValue})\)</span></p>
<p>The memoization array has a space complexity of <span class="math inline">\(O(n \cdot \text{maxOrValue})\)</span>. The recursive call stack can go up to depth <span class="math inline">\(n\)</span> in the worst case.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(n \cdot \text{maxOrValue}) + O(n) = O(n \cdot \text{maxOrValue})\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-bit-manipulation">Approach 3: Bit Manipulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>A subset of the array <code>nums</code> can be represented by a boolean array, where each value indicates whether the corresponding element in <code>nums</code> is included. For instance, if the 3rd index is <code>true</code>, it means the 3rd element is part of the subset.</p>
<p>With a maximum length of <code>nums</code> capped at 16, we can simplify this by using the binary representation of an integer, where a set <code>i</code>th bit indicates the inclusion of the <code>i</code>th element of <code>nums</code> in the subset. To understand this better, have a look at the below illustration:</p>
<p><img src="../Figures/2044/mask.png" alt="bitmask example" /></p>
<blockquote>
<p>Note that the indexing direction in the mask is reversed to represent how we count positions: in an array, we count from left to right, but in a number, we count from right to left.</p>
</blockquote>
<p>We'll then iterate over all possible subsets of <code>nums</code> by considering integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^n - 1\)</span>, each representing a unique subset. For each subset, we calculate the OR value by performing a bitwise OR on elements corresponding to set bits in the integer. If this OR value matches the maximum OR value (calculated beforehand), we increment a counter. By the end, this counter gives the number of subsets that reach the maximum bitwise OR value.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a variable <code>maxOrValue</code> to 0.</li>
<li>Iterate through each number in the input array <code>nums</code>:
<ul>
<li>Find <code>maxOrValue</code> by performing a bitwise OR operation with each number.</li>
</ul>
</li>
<li>Calculate the total number of possible subsets by left-shifting 1 by the length of <code>nums</code>, and store it in <code>totalSubsets</code>.</li>
<li>Initialize a variable <code>subsetsWithMaxOr</code> to 0 to count subsets with maximum OR value.</li>
<li>Iterate through all possible subset combinations, from 0 to <code>totalSubsets - 1</code>:
<ul>
<li>Initialize <code>currentOrValue</code> to 0 for each subset.</li>
<li>Iterate through each index <code>i</code> of the input array <code>nums</code>:
<ul>
<li>If the <code>i</code>-th bit of the current subset mask is set:
<ul>
<li>Perform a bitwise OR of <code>currentOrValue</code> with the <code>i</code>-th element of <code>nums</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>currentOrValue</code> is equal to <code>maxOrValue</code>.
<ul>
<li>Increment <code>subsetsWithMaxOr</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final count stored in <code>subsetsWithMaxOr</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/LPq938EL/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The initial calculation of <code>maxOrValue</code> takes linear time.</p>
<p>The main loop iterates over all <span class="math inline">\(2^n\)</span> subsets. For each subset, the inner loop iterates through all <span class="math inline">\(n\)</span> elements. So, the loops take <span class="math inline">\(O(n \cdot 2^n)\)</span> time, in total.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n) + O(n \cdot 2^n) = O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Except for a few variables, the algorithm does not use any additional space. Thus, the space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-bit-manipulation--dynamic-programming">Approach 4: Bit Manipulation + Dynamic Programming</h3>
<h4 id="intuition-3">Intuition</h4>
<p>If we replace the OR operation with addition, this problem resembles the classic <a href="https://leetcode.com/discuss/study-guide/1152328/01-Knapsack-Problem-and-Dynamic-Programming">Knapsack Problem</a>, a well-known dynamic programming challenge.</p>
<p>We create a <code>dp</code> array of size <span class="math inline">\(2^{17}\)</span>, where <code>dp[i]</code> represents the number of subsets with a cumulative OR value of <code>i</code>. The base case is <code>dp[0] = 1</code>, since the only subset with an OR value of 0 is the empty subset. We also track the maximum cumulative OR found during the process with a variable <code>max</code>, initially set to 0.</p>
<details>
<summary>Why use such a large size?</summary>
<p>The largest possible element in <code>nums</code> is <span class="math inline">\(10^5\)</span>, which requires 17 bits. Thus, the maximum OR value would set all 17 bits, making the maximum possible OR value <span class="math inline">\(2^{17} - 1\)</span>. To accommodate every possible OR result, we need an array of size <span class="math inline">\(2^{17}\)</span> (or <code>1&lt;&lt;17</code>).</p>
</details>
<br>
<p>To fill <code>dp</code>, we iterate over <code>nums</code>. For each value in <code>nums</code>, we OR it with all the possible subset OR values we might have achieved till now. This is basically all the values between 0 and <code>max</code>. So, we iterate a variable <code>i</code> from <code>max</code> to <code>0</code> backward, and add the count of subsets in <code>dp[i]</code> to <code>dp[i | num]</code>. The backward iteration prevents double counting. If we went forward, we might update a value and then use that updated value in the same iteration, leading to incorrect counts.</p>
<p>By the end, <code>max</code> holds the maximum OR value, and <code>dp[max]</code> gives the number of subsets achieving this maximum OR.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a variable <code>max</code> to 0 to track the current maximum OR value.</li>
<li>Create an array <code>dp</code> of size <span class="math inline">\(2^{17}\)</span> to store counts of subsets for each possible OR value.</li>
<li>Set <code>dp[0]</code> to 1, representing the empty subset.</li>
<li>Iterate through each number <code>num</code> in the input array <code>nums</code>:
<ul>
<li>Iterate <code>i</code> backward from <code>max</code> to 0:
<ul>
<li>Calculate a new OR value by performing a bitwise OR of the current value <code>i</code> with <code>num</code>.</li>
<li>Add the count of subsets for the current OR value (<code>dp[i]</code>) to the count for the new OR value (<code>dp[i | num]</code>).</li>
</ul>
</li>
<li>Update <code>max</code> by performing a bitwise OR with the current <code>num</code>.</li>
</ul>
</li>
<li>Return the value stored in <code>dp[max]</code>, representing the count of subsets with the maximum OR value.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/RNes2kRu/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>nums</code>, and <span class="math inline">\(\text{max}\)</span> be the maximum possible OR value.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \text{max})\)</span></p>
<p>The outer loop iterates through each entry in the <code>nums</code> array, taking linear time. The inner loop iterates from <span class="math inline">\(\text{max}\)</span> to <span class="math inline">\(0\)</span>. Thus, the time complexity of the algorithm is <span class="math inline">\(O(n \cdot \text{max})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^{17})\)</span></p>
<p>The <code>dp</code> array is set up with a constant size of <span class="math inline">\(2^{17}\)</span>. While this implies that the complexity is constant, we are including it in the space complexity due to its significant size.</p>
<p>The algorithm uses no other data structures which scale with input size. Thus, the space complexity is <span class="math inline">\(O(2^{17})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-numbers-with-unique-digits/description" target="_blank" rel="noopener noreferrer">Count Numbers with Unique Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return the count of all numbers with unique digits, <code>x</code>, where <code>0 &lt;= x &lt; 10<sup>n</sup></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 91
<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 &le; x &lt; 100, excluding 11,22,33,44,55,66,77,88,99
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 0
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/count-array-b31ab1e9/" target="_blank" rel="noopener noreferrer">Count the array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">c++</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer&nbsp;<span class="mathjax-latex">\(P\)</span>.</p>

<p>Also, you are given&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp;queries of the following type:</p>

<ul>
	<li><span class="mathjax-latex">\(N\)</span>: Determine the count of distinct arrays of size&nbsp;<span class="mathjax-latex">\(\le N\)</span>&nbsp;and&nbsp;<span class="mathjax-latex">\(\ge 1\)</span>&nbsp;such that:

	<ul>
		<li>Each array element is a prime number</li>
		<li>Product of the value of all the array elements is&nbsp;<span class="mathjax-latex">\(\le P\)</span></li>
		<li>Array formed is palindromic</li>
	</ul>
	</li>
</ul>

<p><strong>Note</strong></p>

<ul>
	<li>Two arrays are said to be distinct if there exists at least one index where the value of element present in both the arrays is different.</li>
	<li>An array is said to be palindromic if it reads same from the left to right and right to left direction.</li>
	<li>Since&nbsp;the count can be very large, print the output in modulo&nbsp;<span class="mathjax-latex">\(10^9 + 7\)</span>.</li>
	<li>Assume <span class="mathjax-latex">\(1\)</span>&nbsp;based indexing.</li>
</ul>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains an integer&nbsp;<span class="mathjax-latex">\(P\)</span>.</li>
	<li>The second line contains an integer&nbsp;<span class="mathjax-latex">\(Q\)</span>.</li>
	<li>The next&nbsp;line contains&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp;space-separated integers that denotes&nbsp;the value of&nbsp;<span class="mathjax-latex">\(N\)</span>&nbsp;for each query.</li>
</ul>

<p><strong>Output format</strong></p>

<p>Print&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp;space-separated integers denoting the result for&nbsp;<span class="mathjax-latex">\(Q\)</span>&nbsp;queries.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le N \le 10^9 \\ 1 \le P \le 10^6 \\ 1 \le Q \le 10^5\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><strong>For Query 1:</strong></p>

<ul>
	<li><span class="mathjax-latex">\(N = 3\)</span></li>
	<li>Following are the arrays which satisfy the conditions:
	<ul>
		<li><span class="mathjax-latex">\([2]\)</span></li>
		<li><span class="mathjax-latex">\([3]\)</span></li>
		<li><span class="mathjax-latex">\([5]\)</span></li>
		<li><span class="mathjax-latex">\([7]\)</span></li>
		<li><span class="mathjax-latex">\([2, 2]\)</span></li>
		<li><span class="mathjax-latex">\([3,3]\)</span></li>
		<li><span class="mathjax-latex">\([2,2,2]\)</span></li>
	</ul>
	</li>
</ul>

<p><strong>For Query 2:</strong></p>

<ul>
	<li><span class="mathjax-latex">\(N = 4\)</span></li>
	<li>Following are the arrays which satisfy the conditions:
	<ul>
		<li><span class="mathjax-latex">\([2]\)</span></li>
		<li><span class="mathjax-latex">\([3]\)</span></li>
		<li><span class="mathjax-latex">\([5]\)</span></li>
		<li><span class="mathjax-latex">\([7]\)</span></li>
		<li><span class="mathjax-latex">\([2, 2]\)</span></li>
		<li><span class="mathjax-latex">\([3,3]\)</span></li>
		<li><span class="mathjax-latex">\([2,2,2]\)</span></li>
	</ul>
	</li>
</ul>

<p>Â </p></div>
				</div>
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/decode-the-string2444/1" target="_blank" rel="noopener noreferrer">Decode the string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an encoded string&nbsp;<strong>s</strong>, the task is to decode it.&nbsp;</span><span style="font-size: 18px;">The encoding rule is :</span></p>
<ul>
<li><span style="font-size: 18px;"><strong>k[encodedString],</strong>&nbsp;where the&nbsp;<strong>encodedString</strong>&nbsp;inside the square brackets is being repeated exactly&nbsp;<strong>k</strong>&nbsp;times. Note that&nbsp;<strong>k</strong>&nbsp;is guaranteed to be a positive integer, and encodedString contains only lowercase english alphabets.<br /></span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong></span><span style="font-size: 18px;">The test cases are generated so that the length of the output string will never exceed&nbsp;</span><span style="font-size: 18px;">10</span><sup>5</sup><span style="font-size: 18px;">&nbsp;.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "1[b]"
<strong>Output:</strong> "b"
<strong>Explanation:</strong> "b" is present only one time.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s = "3[b2[ca]]"
<strong>Output:</strong> "bcacabcacabcaca"
<strong>Explanation:<br /></strong>1. Inner substring &ldquo;2[ca]&rdquo; breakdown into &ldquo;caca&rdquo;.<br />2. Now, new string becomes &ldquo;3[bcaca]&rdquo;
3. Similarly &ldquo;3[bcaca]&rdquo; becomes &ldquo;bcacabcacabcaca &rdquo; which is final result.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; |s| &le; 10<sup>5</sup>&nbsp;<br />1 &lt;= k &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distribute-repeating-integers/description" target="_blank" rel="noopener noreferrer">Distribute Repeating Integers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>n</code> integers, <code>nums</code>, where there are at most <code>50</code> unique values in the array. You are also given an array of <code>m</code> customer order quantities, <code>quantity</code>, where <code>quantity[i]</code> is the amount of integers the <code>i<sup>th</sup></code> customer ordered. Determine if it is possible to distribute <code>nums</code> such that:</p>

<ul>
	<li>The <code>i<sup>th</sup></code> customer gets <strong>exactly</strong> <code>quantity[i]</code> integers,</li>
	<li>The integers the <code>i<sup>th</sup></code> customer gets are <strong>all equal</strong>, and</li>
	<li>Every customer is satisfied.</li>
</ul>

<p>Return <code>true</code><em> if it is possible to distribute </em><code>nums</code><em> according to the above conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], quantity = [2]
<strong>Output:</strong> false
<strong>Explanation:</strong> The 0<sup>th</sup> customer cannot be given two different integers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,3], quantity = [2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [3,3]. The integers [1,2] are not used.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2,2], quantity = [2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The 0<sup>th</sup> customer is given [1,1], and the 1st customer is given [2,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>m == quantity.length</code></li>
	<li><code>1 &lt;= m &lt;= 10</code></li>
	<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>
	<li>There are at most <code>50</code> unique values in <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/divisor-game-1664432414/1" target="_blank" rel="noopener noreferrer">Divisor Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Alice and Bob take turns playing a game, with Alice starting first.<br />Initially, there is a number <strong>n</strong> on the chalkboard. On each player's turn, that player makes a move consisting of:</span></p>
<ul>
<li><span style="font-size: 18px;">Choosing any <strong>x</strong> with <strong>0 &lt; x &lt; n</strong>&nbsp; and <strong>n % x == 0</strong>.</span></li>
<li><span style="font-size: 18px;">Replacing the number <strong>n</strong> on the chalkboard with <strong>n - x</strong>.</span></li>
</ul>
<p><span style="font-size: 18px;">Also, if a player cannot make a move, they lose the game.<br />Return <strong>true</strong> if and only if Alice wins the game,&nbsp;assuming both players play <strong>optimally.</strong></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 2<br /><strong>Output: </strong>True<br /><strong>Explanation:</strong>&nbsp;Alice chooses 1, and Bob has no more moves.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre style="background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px; --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: #222426; --darkreader-inline-border-top: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446;"><span style="font-size: 18px;"><strong>Input:</strong><br />n = 3<br /><strong>Output:&nbsp;</strong>False<br /><strong>Explanation:</strong>&nbsp;Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>divisorGame()</strong>&nbsp;which takes an integer&nbsp;<strong>n </strong>as a parameter and returns true if Alice wins the game.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(1)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/expression-add-operators/1" target="_blank" rel="noopener noreferrer">Expression Add Operators</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong> that contains only digits (0-9) and an integer <strong>target</strong>, return <strong>all possible</strong> strings by inserting the binary operator <strong>' + '</strong>, <strong>' - '</strong>, or&nbsp;<strong>' * '</strong> between the digits of <strong>s</strong> such that the resultant expression evaluates to the <strong>target</strong> value. </span><span style="font-size: 18px;">If no such expression is possible, return an <strong>empty list</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note</strong>:</span></p>
<ol>
<li><span style="font-size: 18px;"><strong> </strong>Operands in the returned expressions&nbsp;<strong>should not</strong> contain leading zeros. For example, 2 + 03 is not allowed whereas 20 + 3 is fine. </span></li>
<li><span style="font-size: 18px;">It is <strong>allowed</strong> to not insert any of the operators.</span></li>
<li><span style="font-size: 18px;">Driver code will print the final list of strings in <strong>lexicographically smallest order</strong>.</span></li>
</ol>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre style="--darkreader-inline-bgcolor: #222426; --darkreader-inline-bgimage: initial; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-top: #3e4446; background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px;"><span style="font-size: 18px;"><strong>Input: </strong>s = "124", target = 9<br /><strong>Output:&nbsp;</strong>["1+2*4"]<br /><strong>Explanation:</strong> The valid expression that evaluate to 9 is 1 + 2 * 4</span></pre>
<pre style="--darkreader-inline-bgcolor: #222426; --darkreader-inline-bgimage: initial; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-top: #3e4446; background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px;"><span style="font-size: 18px;"><strong>Input:&nbsp;</strong>s = "125", target = 7<br /><strong>Output:&nbsp;</strong>["1*2+5", "12-5"]<br /><strong>Explanation:</strong> The two valid expressions that evaluate to 7 are 1 * 2 + 5 and 12 - 5.</span></pre>
<pre style="--darkreader-inline-bgcolor: #222426; --darkreader-inline-bgimage: initial; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-top: #3e4446; background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px;"><span style="font-size: 18px;"><strong>Input: </strong>s = "12", target = 12<br /><strong>Output:</strong> ["12"]&nbsp;<br /><strong>Explanation:</strong> s itself matches the target. No other expressions are possible.</span></pre>
<pre style="--darkreader-inline-bgcolor: #222426; --darkreader-inline-bgimage: initial; --darkreader-inline-border-bottom: #3e4446; --darkreader-inline-border-left: #3e4446; --darkreader-inline-border-right: #3e4446; --darkreader-inline-border-top: #3e4446; background: #eeeeee; border: 1px solid #cccccc; padding: 5px 10px;"><span style="font-size: 18px;"><strong>Input: </strong>s = "987612", target = 200<br /><strong>Output:</strong> []<br /><strong>Explanation:</strong> There are no expressions that can be created from "987612" to evaluate to 200.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; s.size() &le; 10<br />s consists of only digits.<br />-2<sup>31&nbsp;</sup>&le;&nbsp;target&nbsp;&le;&nbsp;2<sup>31</sup>-1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/expression-add-operators/description" target="_blank" rel="noopener noreferrer">Expression Add Operators</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>

<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>

<p><strong>Note</strong> that a number can contain multiple digits.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;123&quot;, target = 6
<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]
<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;232&quot;, target = 8
<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]
<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num.length &lt;= 10</code></li>
	<li><code>num</code> consists of only digits.</li>
	<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<p><strong>Intuition</strong></p>
<p>Let us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators:</p>
<ul>
<li><code>+</code> Addition,</li>
<li><code>-</code> Subtraction or</li>
<li><code>*</code> Multiplication</li>
</ul>
<p>We have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to <em>place the operators between digits</em> so that the question becomes clearer.</p>
<p>Let's say we are given the following set of digits <code>&quot;123456789&quot;</code> and the target value given to us is <code>45</code>. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.</p>
<pre>
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3
1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51
1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45
</pre>
<p>These are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators.</p>
<p>By looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target.</p>
<p>Since the question explicitly states that we are given binary operators, this means that each of the operator would require two operands.</p>
<blockquote>
<p>We can consider each of our digits as an operand.</p>
</blockquote>
<p>This means that between every pair of digits we can have any of the three operators i.e. <span class="math inline">\(+\)</span>, <span class="math inline">\(-\)</span> or <span class="math inline">\(\times\)</span>.</p>
<p>If you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are <code>&quot;105&quot;</code> and the target value is <code>5</code>. For this particular example, there are two expressions given to us and they are <code>1*0+5</code> and <code>10-5</code>.</p>
<p>The second expression is something that you need to look out for before getting to solve this question because this complicates things a bit.</p>
<p>It would have been an easier question to solve if we just had to consider those expressions that simply had <em>digits as operands</em>.</p>
<p>But, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits <code>&quot;123456&quot;</code> and target <code>30</code>.</p>
<pre>
1 * 23 - 4 + 5 + 6 = 30
12 - 3 * 4 + 5 * 6 = 30
1 - 23 - 4 + 56 = 30
</pre>
<p>So this means that although the number of operators are defined for us i.e. 3 different binary operators, but the number of operands are <strong>not really well defined for us</strong>.</p>
<p>This is a big portion of the original problem that we need to address in our solution.</p>
<p>Since we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression,</p>
<blockquote>
<p>We try out all of the options.</p>
</blockquote>
<p>This means once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands.</p>
<p>From an implementation perspective, what would an operand imply with respect to our original string?</p>
<blockquote>
<p>An operand would be an integer formed from a substring of our original string.</p>
</blockquote>
<p>Let's look at two different array partitions for the given string <code>&quot;123456789&quot;</code></p>
<center>
<img src="../Figures/282/282_Expression_Add_Operators_Diag_1.png" height="300"></center>
<p>Since we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits.</p>
<p>There is a very simple way of incorporating this into our algorithm. Right now, at every point in the algorithm, we have three different choices corresponding to the three different operators.</p>
<blockquote>
<p>The way we incorporate these partitions is by considering a 4th operator as well which simply moves one step forward and extends the current operand by one digit. Essentially, going from 12 --&gt; 123 is a NO OP operand in our implementation. (12 * 10) + 3.</p>
</blockquote>
<p>Now we have 4 different recursion paths in our algorithm and we have to try out all of them to see which ones lead to a potential solution.</p>
<p>This <code>try out everything</code> hints at a backtracking solution and that is exactly what we are going to look at here.</p>
<p><strong>Algorithm</strong></p>
<p>Let's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code.</p>
<ol>
<li>As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find <em><strong>all</strong></em> valid expressions.</li>
<li>Our recursive call will have an <code>index</code> which represents the current digit we're looking at in the original <code>nums</code> string and also the expression string built till now.</li>
<li>At every step, we have exactly 4 different recursive calls. The <code>NO OP</code> call simply extends the <code>current_operand</code> by the current digit and moves ahead. Rest of the recursive calls correspond to <code>+</code>, <code>-</code>, and <code>*</code>.</li>
<li>We keep on building our expression like this and eventually, the entire <code>nums</code> string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.</li>
</ol>
<pre>
1. procedure recurse(digits, index, expression):
2.     if we have reached the end of the string:
3.         if the expression evaluates to the target:
4.             Valid Expression found!
5.     else:
6.         try out operator 'NO OP' and recurse
7.         try out operator * and recurse
8.         try out operator + and recurse
9.         try out operator - and recurse
</pre>
<p>The algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation.</p>
<p>When we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ?</p>
<blockquote>
<p>How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same?</p>
</blockquote>
<p>Well, one way to go about this is to write a custom <code>eval</code> function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function <code>eval</code> for this), you will get a TLE i.e. time limit exceeded error.</p>
<br/>
<p><strong>Can't we keep track of the expression's value on the fly?</strong></p>
<p>Well yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in <span class="math inline">\(O(1)\)</span> time if the expression's value equals the target value or not.</p>
<p>The implementation would have been straightforward had it just been <code>+</code> and <code>-</code> operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.</p>
<center>
<img src="../Figures/282/282_Expression_Add_Operators_Diag_2.png" width="550"></center>
<p>So far so good. Now let us add the <code>*</code> operator as well and see how building the expression on the fly like this breaks.</p>
<center>
<img src="../Figures/282/282_Expression_Add_Operators_Diag_3.png" width="550"></center>
<p>What we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been <code>+</code> and <code>-</code> operators.</p>
<p>But, this approach is bound to fail because the <code>*</code> operator takes precedence over <code>+</code> and <code>-</code>. The <code>*</code> operator would require the <em><strong>actual</strong></em> previous operand in our expression rather than the current value of the expression. i.e. In the above example, the <code>*</code> operator needed <code>2</code> rather than <code>12</code> to get us the correct value of <code>18</code>.</p>
<br/>
<p><strong>How to handle this?</strong></p>
<p>The idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the <code>*</code> operator, we can <strong>reverse</strong> the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.</p>
<center>
<img src="../Figures/282/282_Expression_Add_Operators_Diag_4.png" width="550"></center>
<p>Now we can look at the actual implementation of this algorithm.</p>
<p><a href="https://leetcode.com/playground/X7CmRa6U/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:</p>
<ul>
<li>At every step along the way, we consider exactly 4 different choices or 4 different recursive paths. The base case is when the value of <code>index</code> reaches <span class="math inline">\(N\)</span> i.e. the length of the <code>nums</code> array. Hence, our complexity would be <span class="math inline">\(O(4^N)\)</span>.</li>
<li>For the base case we use a <code>StringBuilder::toString</code> operation in Java and <code>.join()</code> operation in Python and that takes <span class="math inline">\(O(N)\)</span> time. Here <span class="math inline">\(N\)</span> represents the length of our expression. In the worst case, each digit would be an operand and we would have <span class="math inline">\(N\)</span> digits and <span class="math inline">\(N - 1\)</span> operators. So <span class="math inline">\(O(N)\)</span>. This is for one expression. In the worst case, we can have <span class="math inline">\(O(4^N)\)</span> valid expressions.</li>
<li>Overall time complexity = <span class="math inline">\(O(N \times 4^N)\)</span>.</li>
</ul>
</li>
<li>
<p>Space Complexity:</p>
<ul>
<li>For both Python and Java implementations we have a list data structure that we update on the fly and only for valid expressions do we create a new string and add to our <code>answers</code> array. So, the space occupied by the intermediate list would be <span class="math inline">\(O(N)\)</span> since in the worst case the expression would be built out of all the digits as operands.</li>
<li>Additionally, the space used up by the recursion stack would also be <span class="math inline">\(O(N)\)</span> since the size of recursion stack is determined by the value of <code>index</code> and it goes from <span class="math inline">\(0\)</span> all the way to <span class="math inline">\(N\)</span>.</li>
<li>We don't consider the space occupied by the <code>answers</code> array since that is a part of the question's requirement and we can't reduce that in any way</li>
</ul>
</li>
</ul>
<p><strong>EDIT:</strong><br />
The previous implementation of the algorithm, although correct, lead me to write an incorrect complexity analysis section. I've re-written the algorithm from scratch and corrected the complexity analysis as well. Sorry for the inconvenience to all the readers. The core idea of the algorithm is still the same. That hasn't changed.</p>
<p>Special thanks to <a href="https://leetcode.com/ufarooqi/">@ufarooqi</a>, <a href="https://leetcode.com/vortexwolf">@vortexwolf</a> for providing correct complexity analysis in the discussion forum leading to corrections in the article. Pardon me if I've missed out on any other names :)</p>
<br /></div>
				</div>
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fair-distribution-of-cookies/description" target="_blank" rel="noopener noreferrer">Fair Distribution of Cookies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>cookies</code>, where <code>cookies[i]</code> denotes the number of cookies in the <code>i<sup>th</sup></code> bag. You are also given an integer <code>k</code> that denotes the number of children to distribute <strong>all</strong> the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.</p>

<p>The <strong>unfairness</strong> of a distribution is defined as the <strong>maximum</strong> <strong>total</strong> cookies obtained by a single child in the distribution.</p>

<p>Return <em>the <strong>minimum</strong> unfairness of all distributions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cookies = [8,15,10,20,8], k = 2
<strong>Output:</strong> 31
<strong>Explanation:</strong> One optimal distribution is [8,15,8] and [10,20]
- The 1<sup>st</sup> child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.
- The 2<sup>nd</sup> child receives [10,20] which has a total of 10 + 20 = 30 cookies.
The unfairness of the distribution is max(31,30) = 31.
It can be shown that there is no distribution with an unfairness less than 31.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cookies = [6,1,3,2,2,4,1,2], k = 3
<strong>Output:</strong> 7
<strong>Explanation:</strong> One optimal distribution is [6,1], [3,2,2], and [4,1,2]
- The 1<sup>st</sup> child receives [6,1] which has a total of 6 + 1 = 7 cookies.
- The 2<sup>nd</sup> child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.
- The 3<sup>rd</sup> child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.
The unfairness of the distribution is max(7,7,7) = 7.
It can be shown that there is no distribution with an unfairness less than 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= cookies.length &lt;= 8</code></li>
	<li><code>1 &lt;= cookies[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= k &lt;= cookies.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-backtracking">Approach: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with recursion, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/recursion-i/">Recursion Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>The concept of backtracking involves attempting all possible distributions of cookies. We distribute the current cookie to each child and recursively repeat the process with the next cookie until all the cookies are distributed. Once all the cookies have been distributed, we compute the unfairness of the current distribution and update the minimum unfairness encountered.</p>
<p>Letâ€™s take a look at a scenario with 3 cookies and 3 children that serves as a great example of this.</p>
<p>Initially, we move along the path in yellow by distributing all 3 cookies to child 0, but it is not a valid distribution as child 1 and child 2 receive no cookies.</p>
<p><img src="../Figures/2305/3.png" alt="img" /></p>
<p>As a result, we backtrack to the next possible distribution (by distributing the last cookie to child 1) and repeat this process.</p>
<p><img src="../Figures/2305/4.png" alt="img" /></p>
<p>After distributing all cookies, we will determine if the current distribution is valid, and if so, we will calculate the unfairness of this distribution.</p>
<p>To optimize the backtracking approach, we can use an early stop technique. Consider the same example in the image below: suppose that we have already distributed the first 2 cookies to child 0. When we come to the last cookie, should we continue the recursion process by distributing it to any child?</p>
<p>The answer is NO, because child 1 and child 2 require at least two cookies, and at this point, we only have one cookie remaining. Consequently, no matter how we distribute this last cookie, it will inevitably lead to an invalid distribution. Therefore, we can discard this path and not proceed further with it.</p>
<p><img src="../Figures/2305/5.png" alt="img" /></p>
<p>To implement the early stop technique, we will introduce a parameter named <code>zero_count</code> that represents <strong>the number of children without a cookie</strong>. During the backtracking process, if we have fewer undistributed cookies than <code>zero_count</code>, it means that some children will always end up with no cookie. At this point, we can terminate the recursion because it becomes impossible to obtain a valid distribution. The image below illustrates this concept, where the red states are not computed thanks to the early stop, significantly reducing unnecessary recursion steps.</p>
<p><img src="../Figures/2305/6.png" alt="img" /></p>
<p>Therefore, the algorithm only tracks the paths that lead to valid distributions and updates the global minimum by the maximum unfairness of each valid distribution.</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Create an array <code>distribute</code> of length <code>k</code> initialized with all zeros, which represents the unfairness of each child.</p>
</li>
<li>
<p>Define the recursive function <code>dfs(i, zero_count)</code> to distribute the <span class="math inline">\(i^{th}\)</span> cookie:</p>
<ul>
<li>If the number of undistributed cookies is less than <code>zero_count</code>, which is <code>n - i &lt; zero_count</code>, return a large integer like <code>float('inf')</code>, implying that the current distribution is invalid.</li>
<li>If <code>i = n</code>, return the maximum value of <code>distribute</code> which is the unfairness of this distribution.</li>
<li>Otherwise, set <code>answer</code> as <code>float('inf')</code> and continue with step 3.</li>
</ul>
</li>
<li>
<p>Iterate through <code>distribute</code> and for each child <code>j</code>:</p>
<ul>
<li>Increment <code>distribute[j]</code> by <code>cookie[i]</code>, if <code>distribute[i]</code> is 0 before the distribution, decrement <code>zero_count</code> by 1.</li>
<li>Recursively call <code>dfs(i + 1, zero_count)</code> and update <code>answer</code> as the minimum unfairness encountered, <code>answer = min(answer, dfs(i + 1, zero_count))</code>.</li>
<li>Decrement <code>distribute[j]</code> by <code>cookie[i]</code>, if <code>distribute[i]</code> is 0 after the process, increment <code>zero_count</code> by 1. (This is the backtrack step)</li>
</ul>
<p>Return <code>answer</code> after the iteration is complete.</p>
</li>
<li>
<p>Return <code>dfs(0, distribute)</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NJKWuHZS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>cookies</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k^n)\)</span></p>
<ul>
<li>The algorithm attempts to distribute each of the <span class="math inline">\(n\)</span> cookies to each of the <span class="math inline">\(k\)</span> children, resulting in at most <span class="math inline">\(O(k^n)\)</span> distinct distributions.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k + n)\)</span></p>
<ul>
<li>The array <code>distribute</code> represents the status of <span class="math inline">\(k\)</span> children, thus taking up <span class="math inline">\(O(k)\)</span> space.</li>
<li>The space complexity of a recursive call depends on the maximum depth of the recursive call stack, which is at most <span class="math inline">\(n\)</span>. As each recursive call increments <code>i</code> by 1. Therefore, at most <span class="math inline">\(n\)</span> levels of recursion will be created, and each level consumes a constant amount of space.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-all-possible-paths-from-top-to-bottom/1" target="_blank" rel="noopener noreferrer">Find all possible paths from top to bottom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a N x M grid. Find All possible paths from top left to bottom right.F<em>rom each cell you can either move only to right or down</em>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span><span style="font-size:18px">1 2 3</span>
<span style="font-size:18px">       4 5 6</span>
<span style="font-size:18px"><strong>Output: </strong></span><span style="font-size:18px">1 4 5 6</span>
<span style="font-size:18px">        1 2 5 6 </span>
<span style="font-size:18px">        1 2 3 6</span>
<span style="font-size:18px"><strong>Explanation: </strong>We can see that there are 3 </span>
<span style="font-size:18px">paths from the cell (0,0) to (1,2).</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span><span style="font-size:18px">1 2</span>
<span style="font-size:18px">       3 4</span>
<span style="font-size:18px"><strong>Output: </strong></span><span style="font-size:18px">1 2 4</span>
<span style="font-size:18px">        1 3 4</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>findAllPossiblePaths()&nbsp;</strong>which takes&nbsp;two integers n,m and grid[][]&nbsp;&nbsp;as input parameters and returns all possible paths from the top left cell to bottom right cell&nbsp;in a 2d array.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(2^N*M)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n,m &lt;= 10<sup>&nbsp;</sup><br />
1 &lt;= grid[i][j] &lt;= n*m<br />
n * m &lt;&nbsp;20</span><br />
&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-kth-permutation-0932/1" target="_blank" rel="noopener noreferrer">Find Kth permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two integers&nbsp;<strong>N&nbsp;</strong>(1&lt;=N&lt;=9) and&nbsp;<strong>K</strong>. Find the kth permutation sequence of first N natural numbers. Return the answer in&nbsp;<strong>string</strong>&nbsp;format.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N =<strong> </strong>4, K = 3</span>
<span style="font-size: 18px;"><strong>Output: </strong>1324</span>
<span style="font-size: 18px;"><strong>Explanation: </strong></span>
<span style="font-size: 18px;">Permutations of first 4 natural numbers:
1234,1243,1324,1342,1423,1432.....
So the 3rd permutation is 1324. </span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N = 3, K = 5</span>
<span style="font-size: 18px;"><strong>Output: </strong>312</span>
<span style="font-size: 18px;"><strong>Explanation: 
</strong>Permutations of first 3 natural numbers:
123,132,213,231,312,321.
So the 5th permutation is 312. </span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>kthPermutation()&nbsp;</strong>which takes two integers N and K as input parameters and returns a string denoting the kth permutation.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 9<br />1 &lt;= K &lt;= N!</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Finish All Jobs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>jobs</code>, where <code>jobs[i]</code> is the amount of time it takes to complete the <code>i<sup>th</sup></code> job.</p>

<p>There are <code>k</code> workers that you can assign jobs to. Each job should be assigned to <strong>exactly</strong> one worker. The <strong>working time</strong> of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the <strong>maximum working time</strong> of any worker is <strong>minimized</strong>.</p>

<p><em>Return the <strong>minimum</strong> possible <strong>maximum working time</strong> of any assignment. </em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> jobs = [3,2,3], k = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> By assigning each person one job, the maximum time is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> jobs = [1,2,4,7,8], k = 2
<strong>Output:</strong> 11
<strong>Explanation:</strong> Assign the jobs the following way:
Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)
Worker 2: 4, 7 (working time = 4 + 7 = 11)
The maximum working time is 11.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= jobs.length &lt;= 12</code></li>
	<li><code>1 &lt;= jobs[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-punishment-number-of-an-integer/description" target="_blank" rel="noopener noreferrer">Find the Punishment Number of an Integer</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>, return <em>the <strong>punishment number</strong></em> of <code>n</code>.</p>

<p>The <strong>punishment number</strong> of <code>n</code> is defined as the sum of the squares of all integers <code>i</code> such that:</p>

<ul>
	<li><code>1 &lt;= i &lt;= n</code></li>
	<li>The decimal representation of <code>i * i</code> can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals <code>i</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 182
<strong>Explanation:</strong> There are exactly 3 integers i in the range [1, 10] that satisfy the conditions in the statement:
- 1 since 1 * 1 = 1
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 and 1 with a sum equal to 8 + 1 == 9.
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 and 0 with a sum equal to 10 + 0 == 10.
Hence, the punishment number of 10 is 1 + 81 + 100 = 182
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 37
<strong>Output:</strong> 1478
<strong>Explanation:</strong> There are exactly 4 integers i in the range [1, 37] that satisfy the conditions in the statement:
- 1 since 1 * 1 = 1. 
- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. 
- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. 
- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.
Hence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a positive integer <code>n</code>, and our task is to return its <strong>punishment number</strong>.</p>
<p>The <strong>punishment number</strong> is the sum of the squares of all integers <code>i</code> that satisfy two conditions:</p>
<ol>
<li><strong>Range</strong>: <code>i</code> must be within the range <code>1 &lt;= i &lt;= n</code>.</li>
<li><strong>Partition</strong>: The decimal representation of <code>i * i</code> can be partitioned into contiguous substrings such that the sum of these substrings equals <code>i</code>.</li>
</ol>
<p>In other words, for each integer in the range <code>[1, n]</code>, we check whether the digits of its squared value can be split so that the resulting sum matches the original number.</p>
<p>Let's look at examples where the squared integer's digits can be partitioned as described:</p>
<p><img src="../Figures/2698/2698.png" alt="description" /></p>
<p>As we can see, multiple ways exist to split the digits of a squared integer, leading to different summations. Our goal is to find at least one valid partition for each integer in the given range and sum up the squares of all numbers that satisfy the condition.</p>
<hr />
<h3 id="approach-1-memoization">Approach 1: Memoization</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find whether a numberâ€™s square can be split into contiguous substrings that add to the original number. If such a partition exists, we add the square to the final punishment sum. To break this down, we need to establish the core relationship: for each number <code>currentNum</code> in the range <code>[1, n]</code>, we compute its square (say <code>squareNum</code>) and check whether we can split its digits in a way that the sum of those partitions equals <code>currentNum</code>. The challenge is to explore all possible ways to partition the number while ensuring we do not perform unnecessary computations.</p>
<p>A brute-force approach would involve generating every possible partition of <code>squareNum</code>, computing the sum for each partition, and checking if it equals <code>currentNum</code>. However, this results in exponential complexity since the number of ways to split a string grows exponentially with its length. Instead, we adopt a <strong>recursive backtracking approach</strong> where we attempt to build valid partitions step by step.</p>
<p>The key observation is that at any given position in the string representation of <code>squareNum</code>, we can take a substring of any length starting from that position, convert it into an integer, and add it to a running sum (<code>sum</code>). If at any point <code>sum</code> exceeds <code>currentNum</code>, we stop exploring that branch early. If we reach the end of the string and <code>sum</code> equals <code>currentNum</code>, we confirm that a valid partition exists. This naturally leads to a recursive function that explores different partitioning options.</p>
<p>However, recursion alone would lead to redundant calculations. If we repeatedly attempt to partition the same substring from the same index with the same accumulated sum, we are performing unnecessary recomputation. This is where <strong>dynamic programming (DP) with memoization</strong> helps. We use a 2D array <code>memo[startIndex][sum]</code> to store the results of previously computed states. Here, <code>startIndex</code> represents our current position in the string, and <code>sum</code> represents the accumulated sum of selected partitions. If a state has already been computed, we can return the stored result immediately, avoiding redundant calculations.</p>
<p>With this strategy in mind, we iterate through numbers from <code>1</code> to <code>n</code>, square each number, and check if it can be partitioned using the recursive function <code>findPartitions()</code>. Before each call, we reset the DP array to ensure we do not mix results across different numbers. Then, our recursive function attempts to extract substrings, add them to the sum, and continue exploring further partitions. If a valid partition is found, we add <code>squareNum</code> to our total punishment sum.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an integer <code>punishmentNum</code>, which represents the punishment number of the range <code>[1, n]</code>.</li>
<li>Create the <code>findPartitions()</code> function, which takes integers <code>startIndex</code>, <code>sum</code>, and <code>target</code>, a string <code>stringNum</code>, and a 2D array <code>memo</code> as parameters and returns a boolean value.
<ul>
<li>If we reach the end of the string, return <code>true</code> if the <code>sum</code> of the current partition equals <code>target</code>.</li>
<li>If the <code>sum</code> is greater than <code>target</code>, return <code>false</code>, indicating that the current permutation does not add up to <code>target</code>.</li>
<li>If <code>memo[startIndex][sum]</code> is not <code>-1</code>, return the stored result since it has already been computed.</li>
<li>Initialize a boolean value, <code>partitionFound</code>, to <code>false</code>.</li>
<li>Iterate through the digits from indices <code>startIndex</code> up to the size of <code>stringNum</code>. For each index, <code>currIndex</code>:
<ul>
<li>Get the substring of <code>stringNum</code> starting to the right of <code>currentIndex</code>.</li>
<li>Recursively call <code>findPartitions()</code> to check if the summation of the current partition added to the current <code>sum</code> equals <code>target</code>.</li>
<li>If any valid partition is found, return <code>true</code>.</li>
</ul>
</li>
<li>Memoize the result for future reference and return the result.</li>
</ul>
</li>
<li>Iterate through the integers from index <code>0</code> to <code>n</code>:
<ul>
<li>For each number, <code>currentNum</code>, calculate the squared value of <code>currentNum</code> and store it as <code>squareNum</code>.</li>
<li>Create a 2D array, <code>memoArray</code> to store all the partitions of <code>squareNum</code>, and initialize all of its values to <code>-1</code>.</li>
<li>Input <code>0</code>, <code>0</code>, the string version of <code>squareNum</code>, <code>currentNum</code>, and <code>memoArray</code> into the function <code>findPartitions()</code> as the <code>startIndex</code>, <code>sum</code>, <code>stringNum</code>, <code>target</code>, and <code>memo</code> parameters, respectively.</li>
<li>If <code>findPartitions()</code> returns <code>true</code>, add <code>currentNum</code> to <code>punishmentNum</code>.</li>
</ul>
</li>
<li>After all the iterations are completed, return <code>punishmentNum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wb2YiAui/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> represent an integer in the range <code>[1, n]</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span></p>
<p>We iterate through <span class="math inline">\(n\)</span> integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, <code>n</code>. This is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>, or simply <span class="math inline">\(\log_{10}(n)\)</span>.</p>
<p>At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of <span class="math inline">\(O(2^{\log_{10}(n)})\)</span>.</p>
<p>Since we iterate through this process <span class="math inline">\(n\)</span> times, we multiply this time complexity by a factor of <span class="math inline">\(n\)</span>. This leads to an overall time complexity of <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot {\log_{10}(n)} + {\log_{10}(n)})\)</span></p>
<p>The space complexity is determined by the <code>memo</code> array and recursion stack.</p>
<p>The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can continue until each digit is explored individually in a partition.</p>
<p>As a result, the maximum size of the stack is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>. This leads to a time complexity for the recursive stack of <span class="math inline">\(O({\log_{10}(n^2)})\)</span>, which can be simplified to <span class="math inline">\(O({\log_{10}(n)})\)</span>.</p>
<p>As for the <code>memo</code> array, its size equals the number of digits that can be explored, multiplied by the number of potential values for <span class="math inline">\(n\)</span>, to store all possible permutations. As a result, this creates a space complexity of <span class="math inline">\(O(n \cdot {\log_{10}(n)})\)</span>.</p>
<p>Combining these data structures, the overall space complexity of the solution is <span class="math inline">\(O(n \cdot {\log_{10}(n)} + {\log_{10}(n)})\)</span></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion-of-strings">Approach 2: Recursion of Strings</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The primary source of memory usage in the previous solution is the <code>memo</code> array, which stores the results of all possible partitions. This array consumes significant space, but we only need to determine whether a valid partition exists for each number. This eliminates the need to track every potential partition for future reference, making it unnecessary to store intermediate results. Thus, we can reduce the overall space complexity by removing the dependency on the <code>memo</code> array.</p>
<p>With this realization, we can refactor the solution to rely entirely on <strong>backtracking</strong>. We traverse all possible substrings and attempt to add them to see if we can match the original number. As soon as we find a valid partition, we return <code>true</code> and stop further exploration.</p>
<p>The rest of the solution follows the same logic as the memoization approach: for each number in the range <code>[1, n]</code>, we compute its square and check if any partition of the square sums up to the number itself. If we find a valid partition, we add the square to the punishment number.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an integer <code>punishmentNum</code>, which represents the punishment number of the range <code>[1, num]</code>.</li>
<li>Create the function <code>canPartition()</code>, which takes a string <code>stringNum</code> and an integer <code>target</code> parameter and returns a boolean value.
<ul>
<li>If the string is empty and the target equals <code>0</code>, return <code>true</code>, indicating that a valid partition that adds up to the target was found.</li>
<li>If the target is less than 0, return false, indicating that the current partition is invalid.</li>
<li>Iterate through the string <code>stringNum</code>. For each index <code>index</code>:
<ul>
<li>Let string <code>left</code> represent the substring up to <code>index</code>, and <code>right</code> represent the remainder of the string.</li>
<li>Recursively call <code>canPartition()</code>to check if <code>right</code> can be partitioned to match <code>target - leftNum</code>.</li>
</ul>
</li>
<li>If any recursive branch of <code>canPartition()</code> returns <code>true</code>, return <code>true</code>; else return <code>false</code>.</li>
</ul>
</li>
<li>Iterate through the integers from index <code>0</code> to <code>num</code>:
<ul>
<li>For each number, <code>currentNum</code>, calculate the squared value of <code>currentNum</code> and store it as <code>squareNum</code>.</li>
<li>Input the string version of <code>currentNum</code>, and <code>squareNum</code> into the function <code>canPartition()</code> as the <code>num</code> and <code>target</code> parameters, respectively.</li>
<li>If <code>canPartition()</code> returns <code>true</code>, add <code>currentNum</code> to <code>punishmentNum</code>.</li>
</ul>
</li>
<li>After all the iterations are completed, return <code>punishmentNum</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/a973cKNN/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> represent an integer in the range <code>[1, n]</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span></p>
<p>We iterate through <span class="math inline">\(n\)</span> integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, <code>n</code>. This is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>, or simply <span class="math inline">\(\log_{10}(n)\)</span>.</p>
<p>At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of <span class="math inline">\(O(2^{\log_{10}(n)})\)</span>.</p>
<p>Since we iterate through this process <span class="math inline">\(n\)</span> times, we multiply this time complexity by a factor of <span class="math inline">\(n\)</span>. This leads to an overall time complexity of <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O({\log_{10}(n)})\)</span></p>
<p>The space complexity is determined by the recursion stack.</p>
<p>The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can iterate within itself when each digit is explored individually in a partition.</p>
<p>As a result, the max size of the stack is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>. This leads to a time complexity for the recursive stack of <span class="math inline">\(O({\log_{10}(n^2)})\)</span>, which can be simplified to <span class="math inline">\(O({\log_{10}(n)})\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-recursion-of-integers">Approach 3: Recursion of Integers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approaches, we used string manipulation to get the answer. Now, instead of treating the problem as a sequence of string-based substrings, we can focus on partitioning the digits of a number using integer operations. This allows us to avoid the overhead of converting numbers to strings and directly work with the numeric properties of the number.</p>
<p>We can use the <strong>modulo</strong> and <strong>division</strong> operations to extract different parts of a number. These operations let us break the number down into individual digits or groups of digits, which we can then use to test if their sum matches the target value.</p>
<p>To understand this better, let's consider an example: the number <code>634</code>. Using the modulo operation, we can extract the digits or groups of digits as follows:</p>
<ul>
<li><code>634 % 10 = 4</code> (extracts the last digit)</li>
<li><code>634 % 100 = 34</code> (extracts the last two digits)</li>
<li><code>634 % 1000 = 634</code> (extracts the entire number)</li>
</ul>
<p>Now, using the division operation, we can continually reduce the number by removing its rightmost digits:</p>
<ul>
<li><code>634 / 10 = 63</code> (removes the last digit)</li>
<li><code>634 / 100 = 6</code> (removes the last two digits)</li>
<li><code>634 / 1000 = 0</code> (number is fully reduced)</li>
</ul>
<p>By performing these operations, we can generate permutations of the number from the rightmost side. This is a key observation: we start from the rightmost digits, using the modulo operation to extract the current part of the number and division to reduce the number progressively. When partitioning the number into its components, we want to break it down from the least significant digit (the rightmost side) to the most significant one.</p>
<p>More specifically, when processing from the right, we are naturally ensuring that smaller partitions (from right to left) are handled first. For instance, <code>634</code> can be partitioned as: <code>4</code>, <code>34</code>, and <code>634</code>. If we try to partition from left to right, we're forced to consider all permutations of the number starting with the largest unit (which can quickly escalate into complex cases).</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize an integer <code>punishmentNum</code>, which represents the punishment number of the range <code>[1, num]</code>.</li>
<li>Create the function <code>canPartition()</code>, which takes integer parameters <code>num</code> and <code>target</code> and returns a boolean value.
<ul>
<li>If <code>target</code> is less than <code>0</code> or <code>num</code> is less than <code>target</code>, return <code>false</code>, indicating that the current partition of <code>num</code> does not add up to <code>target</code>.</li>
<li>If <code>num</code> equals <code>target</code>, return true, indicating that the current partition of <code>num</code> adds up to <code>target</code>.</li>
<li>Otherwise, recursively check the digit combinations starting from the right side of the number to find any that make the summation equal to <code>target</code>, returning <code>true</code> if any are found.
<ul>
<li>Check each possible combination of digits, removing them from <code>num</code> and subtracting them from <code>target</code>.</li>
<li>Since <code>target</code> is bound by the constraint <code>1 &lt;= num &lt;= 1000</code>, we only have to check multiples of 10s, 100s, and 1000s.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate through the integers from index <code>0</code> to <code>num</code>:
<ul>
<li>For each number, <code>currentNum</code>, calculate the squared value of <code>currentNum</code> and store it as <code>squareNum</code>.</li>
<li>Input the <code>currentNum</code> and <code>squareNum</code> into the function <code>canPartition()</code> as the <code>num</code> and <code>target</code> parameters, respectively.</li>
<li>If <code>canPartition()</code> returns <code>true</code>, add <code>currentNum</code> to <code>punishmentNum</code>.</li>
</ul>
</li>
<li>After all the iterations are completed, return <code>punishmentNum</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/VbNfb2Mb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> represent an integer in the range <code>[1, n]</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span></p>
<p>We iterate through <span class="math inline">\(n\)</span> integers only once. For each integer, we recursively traverse all the possible ways to split the number. The number of recursion calls is dependent on how many times we have to partition a number, <code>n</code>. This is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>, or simply <span class="math inline">\(\log_{10}(n)\)</span>.</p>
<p>At each digit, we are given the option to either break a partition or continue adding to the partition, giving us 2 options at each digit. The number of times we have to make this decision to exhaust all possible options is proportional to the number of digits in the squared number. As a result, this leads to a time complexity for the recursive function of <span class="math inline">\(O(2^{\log_{10}(n)})\)</span>.</p>
<p>Since we iterate through this process <span class="math inline">\(n\)</span> times, we multiply this time complexity by a factor of <span class="math inline">\(n\)</span>. This leads to an overall time complexity of <span class="math inline">\(O(n \cdot 2^{\log_{10}(n)})\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O({\log_{10}(n)})\)</span></p>
<p>The space complexity is determined by the recursion stack.</p>
<p>The depth of the recursion stack is proportional to the current integer. In the worst case, a recursive call can iterate within itself when each digit is explored individually in a partition.</p>
<p>As a result, the max size of the stack is proportional to the number of digits in the squared number, which can be calculated as <span class="math inline">\({\log_{10}(n^2)}\)</span>. This leads to a space complexity for the recursive stack of <span class="math inline">\(O({\log_{10}(n^2)})\)</span>, which can be simplified to <span class="math inline">\(O({\log_{10}(n)})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-string/1" target="_blank" rel="noopener noreferrer">Find the String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two integers<strong> N</strong> and <strong>K, </strong>the task is to find the string <strong>S</strong> of <strong>minimum </strong>length such that it contains <strong>all possible strings </strong>of size <strong>N</strong> as a <strong>substring</strong>. The characters of the string should be from integers ranging from <strong>0 to K-1</strong>.&nbsp;&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 2, K = 2
<strong>Output:</strong> 
00110
<strong>Explanation: 
</strong>Allowed characters are from 0 to k-1 (i.e., 0 and 1).<br /></span><span style="font-size: 18px;">There are 4 string possible of size N=2 
(i.e "00", "01","10","11")
"00110" contains all possible string as a 
substring. It also has the minimum length.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 2, K = 3
<strong>Output: 
</strong>0010211220
<strong>Explanation: <br /></strong></span><span style="font-size: 18px;">Allowed characters are from 0 to k-1 (i.e., 0, 1 and 2).<strong><br /></strong>There are total 9 strings possible
of size N, given output string has the minimum
length that contains all those strings as substring.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;</strong><br />You don't need to read input or print anything. Complete the function<strong>&nbsp;findString( )</strong>&nbsp;which takes the integer <strong>N</strong> and the integer <strong>K</strong>&nbsp;as input parameters and returns the string.<br /><strong>Note:</strong> In case of multiple answers, return <strong>any string of minimum length </strong>which satisfies above condition. The driver will print the <strong>length</strong> of the&nbsp;string. In case of wrong answer it will print <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(K<sup>N</sup>K)<br /><strong>Expected Space Complexity: </strong>O(K<sup>N</sup>N)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N&nbsp;&le; 4<br />1 <u>&lt;</u> K <u>&lt;</u> 10<br />1&nbsp;<u>&lt;</u> K<sup>N</sup>N &lt; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-unique-binary-string/description" target="_blank" rel="noopener noreferrer">Find Unique Binary String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>nums</code> containing <code>n</code> <strong>unique</strong> binary strings each of length <code>n</code>, return <em>a binary string of length </em><code>n</code><em> that <strong>does not appear</strong> in </em><code>nums</code><em>. If there are multiple answers, you may return <strong>any</strong> of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;01&quot;,&quot;10&quot;]
<strong>Output:</strong> &quot;11&quot;
<strong>Explanation:</strong> &quot;11&quot; does not appear in nums. &quot;00&quot; would also be correct.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;00&quot;,&quot;01&quot;]
<strong>Output:</strong> &quot;11&quot;
<strong>Explanation:</strong> &quot;11&quot; does not appear in nums. &quot;10&quot; would also be correct.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [&quot;111&quot;,&quot;011&quot;,&quot;001&quot;]
<strong>Output:</strong> &quot;101&quot;
<strong>Explanation:</strong> &quot;101&quot; does not appear in nums. &quot;000&quot;, &quot;010&quot;, &quot;100&quot;, and &quot;110&quot; would also be correct.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 16</code></li>
	<li><code>nums[i].length == n</code></li>
	<li><code>nums[i] </code>is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li>All the strings of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursively-generate-all-strings">Approach 1: Recursively Generate All Strings</h3>
<p><strong>Intuition</strong></p>
<p>In the constraints, we see that <span class="math inline">\(n \leq 16\)</span>. Given that there are only <span class="math inline">\(2^{16} = 65536\)</span> possible binary strings, it is feasible to generate all of them in an attempt to find one that does not appear in <code>nums</code>.</p>
<p>We will use a recursive function <code>generate(curr)</code> to generate the binary strings. At each function call, <code>curr</code> is the current string we have. First, we check if <code>curr.length = n</code>. If it is, we need to stop adding characters and assess if we have an answer. If <code>curr</code> is in <code>nums</code>, we return an empty string. If it isn't, we return <code>curr</code>.</p>
<p>If <code>curr.length != n</code>, we will add a character. Since we are generating all strings, we will call both <code>generate(curr + &quot;0&quot;)</code> and <code>generate(curr + &quot;1&quot;)</code>. Note that in our base case, we return an empty string if we did not generate a valid answer. Thus, if either call returns a <strong>non-empty</strong> string, the value it returns is a valid answer.</p>
<p>As each call to <code>generate</code> creates two more calls, the algorithm will have a time complexity of at least <span class="math inline">\(O(2^n)\)</span>. However, we can implement a crucial optimization. We will first call <code>generate(curr + &quot;0&quot;)</code> and store the value in <code>addZero</code>. If <code>addZero</code> is not an empty string, we can immediately return it as the answer without needing to make the additional call to <code>generate(curr + &quot;1&quot;)</code>. If <code>addZero</code> is an empty string, it means all possible paths from adding a <code>&quot;0&quot;</code> lead to invalid answers, and thus <code>generate(curr + &quot;1&quot;)</code> must generate a valid answer, since it's guaranteed that a valid answer exists.</p>
<p>Why is this optimization such a big deal? Notice that the length of <code>nums</code> is <code>n</code>. Thus, if we check <code>n + 1</code> different strings of length <code>n</code>, we will surely find a valid answer. By returning <code>addZero</code> early, we terminate the recursion as soon as we find a valid answer, thus we won't check more than <code>n + 1</code> strings of length <code>n</code>. Without any early returns, we would check <span class="math inline">\(2^n\)</span> strings of length <code>n</code>.</p>
<p>Additionally, we will convert <code>nums</code> to a hash set prior to starting the recursion, allowing for membership checks in <span class="math inline">\(O(n)\)</span> time complexity in the base case due to the length of the strings.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a function <code>generate(curr)</code>:
<ul>
<li>If <code>curr.length = n</code>:
<ul>
<li>If <code>curr</code> is not in <code>numsSet</code>, return <code>curr</code>.</li>
<li>Return an empty string.</li>
</ul>
</li>
<li>Set <code>addZero = generate(curr + &quot;0&quot;)</code>.</li>
<li>If <code>addZero</code> is not an empty string, return it.</li>
<li>Return <code>generate(curr + &quot;1&quot;)</code>.</li>
</ul>
</li>
<li>Set <code>n = nums.length</code>.</li>
<li>Convert <code>nums</code> to a hash set <code>numsSet</code>.</li>
<li>Return <code>generate(&quot;&quot;)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/W5Ks3o85/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code> (and the length of each binary string),</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We require <span class="math inline">\(O(n^2)\)</span> to convert <code>nums</code> to a hash set.</p>
<p>Due to the optimization, we check <span class="math inline">\(O(n)\)</span> binary strings in our recursion. At each call, we perform some string concatenation operations, which costs up to <span class="math inline">\(O(n)\)</span> (unless you have mutable strings like in C++).</p>
</li>
</ul>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is primarily determined by the <code>numsSet</code> and the recursion stack. The <code>numsSet</code> stores all <span class="math inline">\(n\)</span> binary strings from the input, each of length <span class="math inline">\(n\)</span>, contributing <span class="math inline">\(O(n \cdot n) = O(n^2)\)</span> space.</p>
<p>The recursion stack can go up to depth <span class="math inline">\(n\)</span>, as the function builds strings of length <span class="math inline">\(n\)</span>. Each level of recursion stores a string of length up to <span class="math inline">\(n\)</span>, so the recursion stack contributes <span class="math inline">\(O(n^2)\)</span> space. However, this is already accounted for in the <span class="math inline">\(O(n^2)\)</span> space complexity of the <code>numsSet</code>.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-iterate-over-integer-equivalents">Approach 2: Iterate Over Integer Equivalents</h3>
<p><strong>Intuition</strong></p>
<p>Without the optimization, the previous approach would be reasonable when the length of <code>nums</code> is not bounded. However, <code>nums</code> has a length of <code>n</code>. There are many more possible binary strings than there are strings in <code>nums</code>.</p>
<p>In fact, since there are only <code>n</code> strings in <code>nums</code>, we never need to check more than <code>n + 1</code> different binary strings, since at least one of them would not appear in <code>nums</code> and thus be a valid answer. How do we decide which <code>n + 1</code> binary strings we should check?</p>
<p>Let's start by converting each string in <code>nums</code> to its equivalent base-10 integer. We will store these integers in a hash set <code>integers</code>. Now, we can simply use a for loop to iterate over the range <code>[0, n]</code> (the size of this range is <code>n + 1</code>, so it is guaranteed to contain at least one valid answer). For each number, we check if it is in <code>integers</code>. If it isn't, it represents a valid answer. We just need to convert it back to a binary string of length <code>n</code> and return it.</p>
<p>Note that in some cases, if a valid answer, when converted to a binary string, has a length shorter than <code>n</code>, we need to add &quot;0&quot;s to the beginning to make its length equal to <code>n</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create <code>integers</code>, a hash set containing all the elements of <code>nums</code> in their base-10 integer form.</li>
<li>Initialize <code>n = nums.length</code>.</li>
<li>Iterate <code>num</code> from <code>0</code> to <code>n</code>:
<ul>
<li>If <code>num</code> is not in <code>integers</code>, convert it to a binary string of length <code>n</code> and return it.</li>
</ul>
</li>
<li>The code should never reach this point. Return anything.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Sch8ocKs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code> (and the length of each binary string),</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We iterate over <span class="math inline">\(n\)</span> strings and convert them to integers, costing <span class="math inline">\(O(n)\)</span> for each integer.</p>
<p>We then iterate <code>num</code> in the range <code>[0, n]</code>. When we find the answer, we spend <span class="math inline">\(O(n)\)</span> to convert it to a string.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set <code>integers</code> has a size of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-random">Approach 3: Random</h3>
<p><strong>Intuition</strong></p>
<p>As mentioned before, there are many more possible binary strings than there are &quot;banned&quot; binary strings in <code>nums</code>.</p>
<p>We can randomly generate binary strings until we find one that is not in <code>nums</code>. For <code>n = 16</code>, there are <span class="math inline">\(2^{16} = 65536\)</span> strings we could generate, and only <span class="math inline">\(16\)</span> that would not be valid. Thus, the probability of finding a valid answer is <span class="math inline">\(\dfrac{65536 - 16}{65536}\)</span>, over 99.9%.</p>
<p>In general, the probability of generating a valid answer randomly is <span class="math inline">\(\dfrac{2^n - n}{2^n}\)</span>. Because <span class="math inline">\(2^n\)</span> grows much faster than <span class="math inline">\(n\)</span>, the probability is very favorable for us.</p>
<p>For ease of implementation, we will start by converting each binary string in <code>num</code> to its base-10 equivalent, then storing these integers in a hash set <code>integers</code>, just like in approach 2.</p>
<p>Then, we will generate random numbers in the range <span class="math inline">\([0, 2^n]\)</span> until we find one not in <code>integers</code>. Once we do, we convert it to a binary string of length <code>n</code> and return it.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create <code>integers</code>, a hash set containing all the elements of <code>nums</code> in their base-10 integer form.</li>
<li>Set <code>ans</code> to any value in <code>integers</code> and <code>n = nums.length</code>.</li>
<li>While <code>ans</code> is in <code>integers</code>:
<ul>
<li>Randomly generate an integer between <code>0</code> (inclusive) and <span class="math inline">\(2^n\)</span>.</li>
<li>Set <code>ans</code> to the randomly generated integer.</li>
</ul>
</li>
<li>Convert <code>ans</code> to a binary string and return it.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/T3FegUUe/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code> (and the length of each binary string),</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\infty)\)</span></p>
<p>Technically, the worst-case scenario would see the algorithm running infinitely, always selecting elements in <code>integers</code>. However, the probability that the algorithm runs for more than a few steps, let alone infinitely, is so low that we can assume it to be effectively 0. This probability also lowers exponentially as <code>n</code> increases.</p>
<p>For <code>n = 16</code>, there is an over 99.9% chance that we find an answer on the first iteration. For <code>n = 20</code>, we have an over 99.998% chance. Practically, this algorithm runs extremely quickly.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set <code>integers</code> has a size of <span class="math inline">\(n\)</span>.</p>
<p>We don't count the answer as part of the space complexity.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-cantors-diagonal-argument">Approach 4: Cantor's Diagonal Argument</h3>
<p><strong>Intuition</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument">Cantor's diagonal argument</a> is a proof in set theory.</p>
<p>While we do not need to fully understand the proof and its consequences, this approach uses very similar ideas.</p>
<p>We start by initializing the answer <code>ans</code> to an empty string. To build <code>ans</code>, we need to assign either <code>&quot;0&quot;</code> or <code>&quot;1&quot;</code> to each index <code>i</code> for indices <code>0</code> to <code>n - 1</code>. How do we assign them so <code>ans</code> is guaranteed to be different from every string in <code>nums</code>? We know that two strings are different, as long as they differ by at least one character. We can intentionally construct our <code>ans</code> based on this fact.</p>
<p>For each index <code>i</code>, we will check the <span class="math inline">\(i^{th}\)</span> character of the <span class="math inline">\(i^{th}\)</span> string in <code>nums</code>. That is, we check <code>curr = nums[i][i]</code>. We then assign <code>ans[i]</code> to the opposite of <code>curr</code>. That is, if <code>curr = &quot;0&quot;</code>, we assign <code>ans[i] = &quot;1&quot;</code>. If <code>curr = &quot;1&quot;</code>, we assign <code>ans[i] = &quot;0&quot;</code>.</p>
<p>What is the point of this strategy? <code>ans</code> will differ from every string in <strong>at least</strong> one position. More specifically:</p>
<ul>
<li><code>ans</code> differs from <code>nums[0]</code> in <code>nums[0][0]</code>.</li>
<li><code>ans</code> differs from <code>nums[1]</code> in  <code>nums[1][1]</code>.</li>
<li><code>ans</code> differs from <code>nums[2]</code> in  <code>nums[2][2]</code>.</li>
<li>...</li>
<li><code>ans</code> differs from <code>nums[n - 1]</code> in  <code>nums[n - 1][n - 1]</code>.</li>
</ul>
<p>Thus, it is guaranteed that <code>ans</code> does not appear in <code>nums</code> and is a valid answer.</p>
<blockquote>
<p>This strategy is applicable because both the length of <code>ans</code> and the length of each string in <code>nums</code> are larger than or equal to <code>n</code>, the number of strings in <code>nums</code>. Therefore, we can find one unique position for each string in <code>nums</code>.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the answer <code>ans</code>. Note that you should build the answer in an efficient manner according to the programming language you're using.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>Set <code>curr = nums[i][i]</code>.</li>
<li>If <code>curr = &quot;0&quot;</code>, add <code>&quot;1&quot;</code> to <code>ans</code>. Otherwise, add <code>&quot;0&quot;</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/FXtSUPmk/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code> (and the length of each binary string),</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over each string in <code>nums</code>. Assuming the string building is efficient, each iteration costs <span class="math inline">\(O(1)\)</span>, and joining the answer string at the end costs <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer as part of the space complexity.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/gcd-strings/" target="_blank" rel="noopener noreferrer">GCD Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">easy</span> <span class="topic-badge">math</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Let <span class="mathjax-latex">\(P[0 \dots N-1]\)</span>  be a binary string of length <em>N</em>. Then let's define <span class="mathjax-latex">\(S^{\infty}(P)\)</span> as an infinite string with <span class="mathjax-latex">\(S^{\infty}[i] = P[i\%N] \space \forall\space i â‰¥0\)</span> (informally, <span class="mathjax-latex">\(S^{\infty}(P)\)</span> is the concatenation of <em>P</em> with itself an infinite number of times). </p>
<p> 
Define the <b>GCD-string</b> of two integers <span class="mathjax-latex">\(a, b\)</span>, with <span class="mathjax-latex">\(a  \geq b\)</span> to be a binary string of length <em>a</em> that satisfies the following:
</p><ul>
<li> <span class="mathjax-latex">\(g(a,b)\)</span> = <span class="mathjax-latex">\(100\dots 000\)</span> (<em>1</em> followed by <span class="mathjax-latex">\(a-1\)</span> zeros ) if <em>a</em> is divisible by <em>b</em> </li>
<li> <span class="mathjax-latex">\(g(a,b)\)</span> = First <em>a</em> characters of <span class="mathjax-latex">\(S^{\infty}(g(b, a \space mod\space b))\)</span> otherwise</li>
</ul>
<p></p>
<p>
We can define <span class="mathjax-latex">\(F(a,b)\)</span> to be the value of the integer represented by the binary string <span class="mathjax-latex">\(g(a,b)\)</span> in <b>base-2</b>. 
Given <em>T</em> pairs of integers <span class="mathjax-latex">\((x,y)\)</span>, compute <span class="mathjax-latex">\(F(x,y)\space mod\space 10^9+7\)</span> for each pair.
</p>
<h3><b>Input Format:</b></h3>
<p>The first line will contain the number of test cases <em>T</em>. <br />
Each test case can be described with a single line containing two integers <span class="mathjax-latex">\(x,y\)</span>.<br /></p>
<h3><b>Output Format:</b></h3>
<p>Output <em>T</em>  numbers, the answers to each problem.</p>
<h3><b>Constraints</b></h3>
<p>For all subtasks:<br />
<span class="mathjax-latex">\(T â‰¤ 10^4\)</span><br />
<span class="mathjax-latex">\(1 â‰¤ y â‰¤ x\)</span> </p>
<p><b>File 1 (70 pts)</b><br />
<span class="mathjax-latex">\(x â‰¤ 100\)</span></p>
<p><b> File 2 (30 pts)</b><br />
<span class="mathjax-latex">\(x â‰¤ 10^9\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The base 2 results for the first four samples are as follows
</p><ol>
<li> <span class="mathjax-latex">\(100\)</span> </li>
<li> <span class="mathjax-latex">\(101\)</span> </li>
<li> <span class="mathjax-latex">\(10101\)</span> </li>
<li> <span class="mathjax-latex">\(1000100010\)</span> </li>
</ol><p></p></div>
				</div>
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/generate-binary-strings-without-adjacent-zeros/description" target="_blank" rel="noopener noreferrer">Generate Binary Strings Without Adjacent Zeros</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code>.</p>

<p>A binary string <code>x</code> is <strong>valid</strong> if all <span data-keyword="substring-nonempty">substrings</span> of <code>x</code> of length 2 contain <strong>at least</strong> one <code>&quot;1&quot;</code>.</p>

<p>Return all <strong>valid</strong> strings with length <code>n</code><strong>, </strong>in <em>any</em> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;010&quot;,&quot;011&quot;,&quot;101&quot;,&quot;110&quot;,&quot;111&quot;]</span></p>

<p><strong>Explanation:</strong></p>

<p>The valid strings of length 3 are: <code>&quot;010&quot;</code>, <code>&quot;011&quot;</code>, <code>&quot;101&quot;</code>, <code>&quot;110&quot;</code>, and <code>&quot;111&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[&quot;0&quot;,&quot;1&quot;]</span></p>

<p><strong>Explanation:</strong></p>

<p>The valid strings of length 1 are: <code>&quot;0&quot;</code> and <code>&quot;1&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 18</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/generate-ip-addresses/1" target="_blank" rel="noopener noreferrer">Generate IP Addresses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong> containing only digits, your task is to restore it by returning all possible valid IP address combinations.&nbsp;</span><span style="font-size: 18px;">You can return your answer in&nbsp;</span><strong style="font-size: 18px;">any&nbsp;</strong><span style="font-size: 18px;">order.</span></p>
<p><span style="font-size: 18px;">A <strong>valid</strong> IP address must be in the form of A.B.C.D, where A, B, C, and D are numbers from 0-255(inclusive).</span></p>
<p><span style="font-size: 18px;"><strong>Note: </strong>The numbers cannot be 0 prefixed unless they are 0. For example, 1.1.2.11 and 0.11.21.1 are valid IP addresses while 01.1.2.11 and 00.11.21.1 are not.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">s = &ldquo;255678166&rdquo;
</span><strong style="font-size: 18px;">Output: </strong></span><span style="font-size: 18px;">[&ldquo;25.56.78.166&rdquo;, &ldquo;255.6.78.166&rdquo;, &ldquo;255.67.8.166&rdquo;, &ldquo;255.67.81.66&rdquo;]<br /><strong>Explanation: </strong>These are the only valid possible IP addresses.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">s = </span><span style="font-size: 18px;">&ldquo;25505011535&rdquo;
</span><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;"> []<br /><strong>Explanation:</strong> We cannot generate a valid IP address with this string.</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=s.size()&lt;=16<br />s contains only digits(i.e. 0-9)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/generate-all-possible-parentheses/1" target="_blank" rel="noopener noreferrer">Generate Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a number <strong>n</strong>, return all the combinations of balanced parentheses of length <strong>n</strong>.</span><br /><span style="font-size: 14pt;"><strong>Note:</strong> A sequence of parentheses is <strong>balanced</strong> if every opening bracket has a corresponding closing bracket in the <strong>correct order</strong>.</span><br /><span style="font-size: 14pt;">For example, "(())", "()()", and "(()())" are balanced, whereas ")()(", "))((", and "()))" are not.</span></p>
<p><br /><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: n = 6
<strong>Output: </strong>["((()))", "(()())", "(())()", "()(())", "()()()"]<br /><strong>Explanation:</strong> These are the only possible valid balanced parentheses.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: n = 4
<strong>Output: </strong>["(())", "()()"]<br /><strong>Explanation:</strong> These are the only possible valid balanced parentheses.</span></pre>
<div><span style="font-size: 14pt;"><strong>Constraints: </strong></span><br /><span style="font-size: 14pt;">1 &le; n &le; 16</span></div>
<div><span style="font-size: 14pt;">n % 2 = 0</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/generate-parentheses/description" target="_blank" rel="noopener noreferrer">Generate Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> n = 3
<strong>Output:</strong> ["((()))","(()())","(())()","()(())","()()()"]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> n = 1
<strong>Output:</strong> ["()"]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/gray-code/description" target="_blank" rel="noopener noreferrer">Gray Code</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2<sup>n</sup></code> integers where:</p>

<ul>
	<li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2<sup>n</sup> - 1]</code>,</li>
	<li>The first integer is <code>0</code>,</li>
	<li>An integer appears <strong>no more than once</strong> in the sequence,</li>
	<li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong>, and</li>
	<li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li>
</ul>

<p>Given an integer <code>n</code>, return <em>any valid <strong>n-bit gray code sequence</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> [0,1,3,2]
<strong>Explanation:</strong>
The binary representation of [0,1,3,2] is [00,01,11,10].
- 0<u>0</u> and 0<u>1</u> differ by one bit
- <u>0</u>1 and <u>1</u>1 differ by one bit
- 1<u>1</u> and 1<u>0</u> differ by one bit
- <u>1</u>0 and <u>0</u>0 differ by one bit
[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].
- <u>0</u>0 and <u>1</u>0 differ by one bit
- 1<u>0</u> and 1<u>1</u> differ by one bit
- <u>1</u>1 and <u>0</u>1 differ by one bit
- 0<u>1</u> and 0<u>0</u> differ by one bit
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [0,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 16</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/hamiltonian-path2522/1" target="_blank" rel="noopener noreferrer">Hamiltonian Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="24" data-end="245"><span style="font-size: 14pt;">Given an undirected graph with <strong>n</strong> vertices and <strong>m</strong> edges, your task is to determine if a Hamiltonian path exists in the graph. </span></p>
<p data-start="24" data-end="245"><span style="font-size: 14pt;">A<a href="https://www.geeksforgeeks.org/hamiltonian-cycle/"> <strong data-start="154" data-end="174">Hamiltonian path</strong></a> is a path in an undirected graph that visits each vertex exactly once.</span></p>
<p data-start="247" data-end="278"><span style="font-size: 14pt;">You are provided the following:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul data-start="280" data-end="498">
<li data-start="280" data-end="325"><span style="font-size: 14pt;"><strong data-start="282" data-end="287">n</strong>: The number of vertices in the graph.</span></li>
<li data-start="326" data-end="368"><span style="font-size: 14pt;"><strong data-start="328" data-end="333">m</strong>: The number of edges in the graph.</span></li>
<li data-start="369" data-end="498"><span style="font-size: 14pt;"><strong data-start="371" data-end="384">edges[][]</strong>: A 2D list where each element edges[i] represents an edge between two vertices edges[i][0] and edges[i][1].&nbsp;</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 4
edges[][]= { {1,2}, {2,3}, {3,4}, {2,4} }
<strong>Output: </strong>1 
<strong>Explanation: </strong>There is a hamiltonian path: 1 -&gt; 2 -&gt; 3 -&gt; 4 </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 3 
edges[][] = { {1,2}, {2,3}, {2,4} } 
<strong>Output: </strong>0 
<strong>Explanation: </strong>It can be proved that there is no hamiltonian path in the given graph.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; n &le; 10</span><br /><span style="font-size: 18px;">1 &le; m &le; 15</span><br /><span style="font-size: 18px;">Size of edges[i] is 2</span><br /><span style="font-size: 18px;">1 &le; edges[i][0],edges[i][1] &le; n</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/iterator-for-combination/description" target="_blank" rel="noopener noreferrer">Iterator for Combination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design the <code>CombinationIterator</code> class:</p>

<ul>
	<li><code>CombinationIterator(string characters, int combinationLength)</code> Initializes the object with a string <code>characters</code> of <strong>sorted distinct</strong> lowercase English letters and a number <code>combinationLength</code> as arguments.</li>
	<li><code>next()</code> Returns the next combination of length <code>combinationLength</code> in <strong>lexicographical order</strong>.</li>
	<li><code>hasNext()</code> Returns <code>true</code> if and only if there exists a next combination.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;CombinationIterator&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
[[&quot;abc&quot;, 2], [], [], [], [], [], []]
<strong>Output</strong>
[null, &quot;ab&quot;, true, &quot;ac&quot;, true, &quot;bc&quot;, false]

<strong>Explanation</strong>
CombinationIterator itr = new CombinationIterator(&quot;abc&quot;, 2);
itr.next();    // return &quot;ab&quot;
itr.hasNext(); // return True
itr.next();    // return &quot;ac&quot;
itr.hasNext(); // return True
itr.next();    // return &quot;bc&quot;
itr.hasNext(); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= combinationLength &lt;= characters.length &lt;= 15</code></li>
	<li>All the characters of <code>characters</code> are <strong>unique</strong>.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code> and <code>hasNext</code>.</li>
	<li>It is guaranteed that all calls of the function <code>next</code> are valid.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-number-in-k-swaps-1587115620/1" target="_blank" rel="noopener noreferrer">Largest number in K swaps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a number <strong>k </strong>and string <strong>s </strong>of digits denoting a positive integer, build the largest number possible by performing swap operations on the digits of <strong>s </strong>at most <strong>k </strong>times.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "1234567", k = 4
<strong>Output: </strong>7654321<strong>
Explanation: </strong>Three swaps can make the input 1234567 to 7654321, swapping 1 with 7, 2 with 6 and finally 3 with 5.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s = "3435335", k = 3
<strong>Output: </strong>5543333
<strong>Explanation: </strong>Three swaps can make the input 3435335 to 5543333, swapping 3 with 5, 4 with 5 and finally 3 with 4.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">s = "1034", k = 2
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">4301<br /></span><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> Two swaps can make the input 1034 to 4301, swapping 1 with 4 and finally 0 with 3. </span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints</strong>:<br />1 &le; s.size()<strong>&nbsp;</strong>&le; 15<br />1 &le; k<strong>&nbsp;</strong>&le; 7</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-sum-cycle--170645/1" target="_blank" rel="noopener noreferrer">Largest Sum Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a maze with&nbsp;<strong>N</strong>&nbsp;cells. Each cell may have multiple entry points but not more than one exit(i.e entry/exit points are unidirectional doors like valves).<br />
You are given an array&nbsp;<strong>Edge[]</strong>&nbsp;of&nbsp;<strong>N&nbsp;</strong>integers,&nbsp;where Edge[i] contains the cell number that can be reached from of&nbsp;cell&nbsp;i in one step. Edge[i] is -1 if the ith cell doesn&#39;t have an exit.&nbsp;<br />
The task is to find the&nbsp;largest sum of a cycle in the maze(Sum of a cycle is the sum of the cell indexes of all cells present in that cycle).</span></p>

<p><span style="font-size:18px"><strong>Note:</strong>The cells are named with an integer value from 0 to N-1. <strong>If there is no cycle in the graph then return -1.</strong></span></p>

<p><span style="font-size:18px"><strong><strong>Example 1:</strong></strong></span></p>

<pre>
<span style="font-size:18px"><strong><strong>Input:</strong>
</strong>N = 4
Edge[] = {1, 2, 0, -1}<strong>
<strong>Output:</strong> </strong>3<strong>
<strong>Explanation</strong>: 
</strong>There is only one cycle in the graph.
(i.e 0-&gt;1-&gt;2-&gt;0)
Sum of the cell index in that cycle 
= 0 + 1 + 2 = 3.
</span></pre>

<p><span style="font-size:18px"><strong><strong>Example 2:</strong></strong></span></p>

<pre>
<span style="font-size:18px"><strong><strong>Input:</strong>
</strong>N = 4 
Edge[] = {2, 0, -1, 2}<strong>
<strong>Output:</strong> </strong>-1<strong>
<strong>Explanation</strong>:
</strong>1 -&gt; 0 -&gt; 2 &lt;- 3
There is no cycle in the graph.
</span></pre>

<p><br />
<span style="font-size:18px"><strong><strong>Your task:</strong></strong><br />
You dont need to read input or print anything. Your task is to complete the function&nbsp;<strong>largestSumCycle</strong>()&nbsp;which takes the integer N&nbsp;denoting the number of cells&nbsp;and the array Edge[]&nbsp;as input parameters and returns the sum of the&nbsp;largest sum cycle in the maze.</span></p>

<p><span style="font-size:18px"><strong><strong>Expected Time Complexity:</strong></strong>&nbsp;O(N)<br />
<strong><strong>Expected Auxiliary Space:&nbsp;</strong></strong>O(N)</span></p>

<p><span style="font-size:18px"><strong><strong>Constraints:</strong></strong><br />
1 &le; N&nbsp;&le; 10<sup>5</sup><br />
-1&nbsp;<u>&lt;</u>&nbsp;Edge[i] &lt; N<br />
Edge[i] != i</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-time-for-given-digits/description" target="_blank" rel="noopener noreferrer">Largest Time for Given Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of 4 digits, find the latest 24-hour time that can be made using each digit <strong>exactly once</strong>.</p>

<p>24-hour times are formatted as <code>&quot;HH:MM&quot;</code>, where <code>HH</code> is between <code>00</code> and <code>23</code>, and <code>MM</code> is between <code>00</code> and <code>59</code>. The earliest 24-hour time is <code>00:00</code>, and the latest is <code>23:59</code>.</p>

<p>Return <em>the latest 24-hour time in <code>&quot;HH:MM&quot;</code> format</em>. If no valid time can be made, return an empty string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4]
<strong>Output:</strong> &quot;23:41&quot;
<strong>Explanation:</strong> The valid 24-hour times are &quot;12:34&quot;, &quot;12:43&quot;, &quot;13:24&quot;, &quot;13:42&quot;, &quot;14:23&quot;, &quot;14:32&quot;, &quot;21:34&quot;, &quot;21:43&quot;, &quot;23:14&quot;, and &quot;23:41&quot;. Of these times, &quot;23:41&quot; is the latest.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,5,5,5]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There are no valid 24-hour times as &quot;55:55&quot; is not valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>arr.length == 4</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/letter-case-permutation/description" target="_blank" rel="noopener noreferrer">Letter Case Permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, you&nbsp;can transform every letter individually to be lowercase or uppercase to create another string.</p>

<p>Return <em>a list of all possible strings we could create</em>. Return the output in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a1b2&quot;
<strong>Output:</strong> [&quot;a1b2&quot;,&quot;a1B2&quot;,&quot;A1b2&quot;,&quot;A1B2&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3z4&quot;
<strong>Output:</strong> [&quot;3z4&quot;,&quot;3Z4&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 12</code></li>
	<li><code>s</code> consists of lowercase English letters, uppercase English letters, and digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/letter-combinations-of-a-phone-number/description" target="_blank" rel="noopener noreferrer">Letter Combinations of a Phone Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>

<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" style="width: 300px; height: 243px;" />
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;23&quot;
<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;&quot;
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> digits = &quot;2&quot;
<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= digits.length &lt;= 4</code></li>
	<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/letter-tile-possibilities/description" target="_blank" rel="noopener noreferrer">Letter Tile Possibilities</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code>&nbsp;&nbsp;<code>tiles</code>, where each tile has one letter <code>tiles[i]</code> printed on it.</p>

<p>Return <em>the number of possible non-empty sequences of letters</em> you can make using the letters printed on those <code>tiles</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;AAB&quot;
<strong>Output:</strong> 8
<strong>Explanation: </strong>The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;AAABBC&quot;
<strong>Output:</strong> 188
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tiles = &quot;V&quot;
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= tiles.length &lt;= 7</code></li>
	<li><code>tiles</code> consists of uppercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's think about how we naturally form different sequences from a set of letters. Imagine we have Scrabble tiles with the letters &quot;A&quot;, &quot;A&quot;, and &quot;B&quot;. How would we manually find all possible sequences? We would likely start with single letters (&quot;A&quot;, &quot;B&quot;), then try two-letter combinations (&quot;AA&quot;, &quot;AB&quot;), and finally three-letter combinations (&quot;AAB&quot;).</p>
<p>A point to note in this manual process is that at each step, we make a choice about whether to use each available letter. For example, when starting with &quot;AAB&quot;, we first decide: &quot;Should I use the first &quot;A&quot;?&quot; If we use it, we then face the same type of decision with our remaining letters. If we don't use it, we still have all our letters available for future choices.</p>
<p>This decision-making pattern, where each choice reduces the problem to a smaller version of itself and follows a repetitive structure, naturally suggests a recursive approach. At each level of the recursion (or decision point), we have two options: either use an available letter and continue exploring, or skip it and move to the next letter.</p>
<p>The diagram below illustrates the structure of a recursion tree for this problem:</p>
<p><img src="../Figures/1079/recursion_tree.png" alt="" /></p>
<p>However, there's a subtle complexity we need to address. Consider the input <code>&quot;AAB&quot;</code> again. If we're not careful, we might count the same sequence multiple times because we have duplicate letters. For instance, we could form <code>&quot;AB&quot;</code> by using either the first or second <code>&quot;A&quot;</code>.</p>
<p>To solve this, weâ€™ll store all the sequences we generate in a hash set. Hash sets allow for quick lookups and keep the characters unique due to the set property, so we can check whether a particular sequence has already been found.</p>
<p>Let's create a recursive function <code>generateSequences</code> which creates all possible letter sequences. We'll also maintain a boolean array <code>used</code> of size equal to that of <code>tiles</code>. Each index in <code>used</code> tells us whether the character at that index in <code>tiles</code> has been used in the current sequence or not.</p>
<p>The first step in the recursive function is to add the current sequence to the hash set. This is because all intermediate sequences are also valid combinations and not just the ones where we use all the tiles. Next, weâ€™ll iterate over each character in <code>tiles</code>. If a character hasnâ€™t been used yet, weâ€™ll add it to the current sequence and recurse. After exploring that path, weâ€™ll backtrack and mark the letter as unused to allow us to try different combinations.</p>
<p>We start the recursion by calling the function with an empty string. When the recursion completes, the hash set will contain all possible letter combinations. Finally, we return the size of the hash set minus one, since the problem asks for non-empty sequences only.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a hash set called <code>sequences</code> to store the unique sequences.</li>
<li>a variable <code>len</code> to store the length of the input string <code>tiles</code>.</li>
</ul>
</li>
<li>Create a boolean array <code>used</code> of size <code>len</code> to track the used characters</li>
<li>Call the recursive helper function <code>generateSequences</code> with the initial parameters: <code>tiles</code>, an empty string, <code>used</code> array, and the <code>sequences</code> set.</li>
<li>Return the size of the <code>sequences</code> set minus 1 (to exclude the empty string).</li>
</ul>
<p>Helper method <code>generateSequences(tiles, current, used, sequences)</code>:</p>
<ul>
<li>Add the <code>current</code> sequence to the <code>sequences</code> set.</li>
<li>Initialize a loop that runs from position <code>0</code> to the length of <code>tiles</code>. For each position:
<ul>
<li>Check if the character at the current position is not used. If not used:
<ul>
<li>Mark the current position as used in the <code>used</code> array.</li>
<li>Make a recursive call with: <code>tiles</code>, <code>current</code> string + character at the current position, <code>used</code> array, and <code>sequences</code> set.</li>
<li>After the recursive call returns, mark the current position as unused (backtrack).</li>
</ul>
</li>
</ul>
</li>
<li>When the loop ends, return to the previous recursive call.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DGSVqd6c/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n!)\)</span></p>
<p>The time complexity is determined by two main factors. First, for each position, we have at most <span class="math inline">\(n\)</span> choices (in the first level of recursion). At each subsequent level, we have one less choice as characters get used. This creates a pattern similar to <span class="math inline">\(n \cdot (n-1) \cdot (n-2) \cdot ... \cdot 1\)</span>, which is <span class="math inline">\(n!\)</span>. Additionally, at each step, we perform string concatenation which takes <span class="math inline">\(O(n)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot n!)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n!)\)</span></p>
<p>The space complexity has multiple components. First, the recursion stack can go up to depth <span class="math inline">\(n\)</span>, using <span class="math inline">\(O(n)\)</span> space. The set <code>sequences</code> will store all possible unique sequences. For a string of length <span class="math inline">\(n\)</span>, we can have sequences of length <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>, and each sequence can be made from <span class="math inline">\(n\)</span> possible characters (with repetition allowed). This means the hash set can store up to <span class="math inline">\(O(n!)\)</span> sequences, and each sequence can be of length <span class="math inline">\(O(n)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot n!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-recursion">Approach 2: Optimized Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Imagine we're playing with Scrabble tiles again, but this time we have the string &quot;AAABBC&quot;. We can make an important observation here: what really matters isn't the position of each letter, but rather how many of each letter we have available. Whether we use the first &quot;A&quot; or the second &quot;A&quot; doesn't change the sequences we can create - we just need to know we have three &quot;A&quot;s to work with.</p>
<p>This insight leads us to our first key decision: instead of tracking individual letters, we can track the frequency of each letter. Think of it like having separate piles for each letter - three tiles in the &quot;A&quot; pile, two in the &quot;B&quot; pile, and one in the &quot;C&quot; pile. To implement this, we can maintain an array <code>charCount</code> where each index represents a letter (0 for &quot;A&quot;, 1 for &quot;B&quot;, etc.), and the value represents how many of that letter we have.</p>
<p>Now, let's think about how we build sequences using these frequency counts. At each step, we're asking ourselves: &quot;Which letter should I add to my current sequence?&quot; We can loop over all 26 letters and use any letter that still has a positive count. This is fundamentally different from our previous approach where we were making yes/no decisions about each position in <code>tiles</code>.</p>
<p>This incremental building of the sequence using the remaining letters suggests a recursive approach. We'll pass <code>charCount</code> to the recursive function and start building the sequence by eliminating each available character one by one. Remember that we also need to count all intermediate sequences (where <code>charCount</code> is not empty yet), because these are also valid letter tile possibilities.</p>
<p>Notice that nowhere in our algorithm do we work with the actual sequence itself. Each unique sequence is determined by the number of letters available in <code>charCount</code>, not the sequence. This means we no longer need to maintain a hash set to store visited sequences, saving significant space.</p>
<p>Our main function calls the recursive method with the full <code>charCount</code> array. The result returned by it is our required answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an integer array <code>charCount</code> of size <code>26</code> to store the frequency of each uppercase letter.</li>
<li>Iterate through each character of <code>tiles</code>:
<ul>
<li>Increment the count at the index (character - 'A') in the <code>charCount</code> array.</li>
</ul>
</li>
<li>Call the recursive helper function <code>findSequences</code> with the <code>charCount</code> array.</li>
<li>Return the result from <code>findSequences</code>.</li>
</ul>
<p>Helper method <code>findSequences(charCount)</code>:</p>
<ul>
<li>Initialize a variable <code>totalCount</code> to <code>0</code> to track the number of possible sequences.</li>
<li>Start a loop that runs from position <code>0</code> to <code>25</code> (for 26 letters):
<ul>
<li>Check if the count of the current character is <code>0</code>. If true:
<ul>
<li>Skip to the next iteration.</li>
</ul>
</li>
<li>If not <code>0</code>:
<ul>
<li>Increment <code>totalCount</code> by <code>1</code> (counting the current character as a sequence).</li>
<li>Decrement the count of the current character in the <code>charCount</code> array.</li>
<li>Make a recursive call with the updated <code>charCount</code> array.</li>
<li>Add the result of the recursive call to <code>totalCount</code>.</li>
<li>Increment the count of the current character back (backtrack).</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalCount</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/TujH9fTX/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n!)\)</span></p>
<p>The time complexity comes from the fact that for each position in our sequence, we can choose any of the remaining available characters. At each recursive call, we try all remaining characters, and the number of choices decreases by <span class="math inline">\(1\)</span> each time since we're using frequency counting to handle duplicates. For an input string of length <span class="math inline">\(n\)</span>, at the first level we have <span class="math inline">\(n\)</span> choices, then <span class="math inline">\((n-1)\)</span> choices, and so on, leading to <span class="math inline">\(n \cdot (n-1) \cdot (n-2) ... 1\)</span> possibilities. This recursive pattern of decreasing choices at each level results in a time complexity of <span class="math inline">\(O(n!)\)</span>.</p>
<blockquote>
<p>[!NOTE]<br />
A common misconception is that the time complexity of this problem is <span class="math inline">\(O(2^n)\)</span>, stemming from the idea that each character has a binary decision, either to include or exclude. This may seem valid in problems involving combinations or subsets, but here, the goal is to generate all possible permutations of the tiles. Since we're considering character frequencies, the complexity grows factorially, not exponentially, leading to <span class="math inline">\(O(n!)\)</span>. Each recursive call handles one tile from a decreasing pool of remaining tiles, generating distinct sequences.</p>
<p>Another misconception is that the time complexity is <span class="math inline">\(O(26^n)\)</span>, based on the assumption that there are 26 possible characters at each recursive step. However, the actual complexity depends on the tile frequencies. The recursion operates within the constraints of the available tiles, not an arbitrary 26 choices per call.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity has two parts. First, the fixed-size array <code>charCount</code> takes <span class="math inline">\(O(1)\)</span> space as it always has <span class="math inline">\(26\)</span> elements regardless of input size. Second, the recursion stack can go up to depth <span class="math inline">\(n\)</span> as each recursive call uses one character.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-permutations-and-combinations">Approach 3: Permutations and Combinations</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Consider a sequence &quot;ABC&quot;. Generating it actually has two steps:</p>
<ol>
<li>Choosing the three tiles &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;.</li>
<li>Arranging them in order to form &quot;ABC&quot;.</li>
</ol>
<p>Notice that after step 1, we can create 5 more sequences: &quot;BAC&quot;, &quot;CBA&quot;, &quot;BCA&quot;, &quot;ACB&quot;, and &quot;CAB.&quot; These are all the permutations of &quot;ABC&quot;.</p>
<p>The total number of permutations that can be generated from <span class="math inline">\(n\)</span> unique characters is <span class="math inline">\(n!\)</span>. For the characters &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;, the number of unique characters is 3, so 6 sequences can be generated from them.</p>
<p>However, we need to account for cases where there are multiple occurrences of the same character. For example, consider the tiles &quot;A&quot;, &quot;A&quot;, and &quot;B&quot;. This will generate only 3 unique sequences of length 3: &quot;AAB&quot;, &quot;ABA&quot;, and &quot;BAA&quot;. This is because swapping the first and second &quot;A&quot; doesnâ€™t create a new sequence, so they canâ€™t be counted separately.</p>
<p>To account for this, we modify our formula to the following: if we have 3 characters with frequencies <span class="math inline">\(n_1\)</span>, <span class="math inline">\(n_2\)</span>, and <span class="math inline">\(n_3\)</span>, the number of <span class="math inline">\(3\)</span> length sequences are:</p>
<p><span class="math display">\[\begin{aligned}
    \frac{(n_1 + n_2 + n_3)!}{(n_1)! \cdot (n_2)! \cdot (n_3)!}
\end{aligned}
\]</span></p>
<p>The above formula can be extended to <span class="math inline">\(m\)</span> characters of different frequencies.</p>
<p>So now, our task is to generate all combinations of characters from the given tiles. We can use a recursive method to do this. The function iterates over the tiles string and makes two choices at each step: whether to pick the current character or not. This generates all possible combinations of characters, which we then pass to a helper method called <code>countPermutations</code>.</p>
<p>The <code>countPermutations</code> method counts the frequency of each character in the generated combination using an array called <code>charCount</code> (similar to the previous approach). It then applies the formula above to calculate all possible permutations of the current combination.</p>
<p>The total permutations for each combination are returned by the recursive function. The cumulative sum of all such combinations is our final answer, which we return at the end.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a hash set <code>seen</code> to store unique sequences.</li>
<li>Convert <code>seen</code> to a sorted string <code>sortedTiles</code>.</li>
<li>Call the recursive helper function <code>generateSequences</code> with initial parameters. Subtract 1 from the result and return it.</li>
</ul>
<p>Helper method <code>factorial(n)</code>:</p>
<ul>
<li>Check if <code>n</code> is less than or equal to <code>1</code>:
<ul>
<li>If <code>true</code>, return <code>1</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>result</code> to <code>1</code>.</li>
<li>Loop <code>num</code> from <code>2</code> to <code>n</code>:
<ul>
<li>Multiply the result by <code>num</code>.</li>
</ul>
</li>
<li>Return the final <code>result</code>.</li>
</ul>
<p>Helper method <code>countPermutations(seq)</code>:</p>
<ul>
<li>Initialize an integer array <code>charCount</code> of size <code>26</code> for character frequencies.</li>
<li>Iterate through each character in the input <code>seq</code>:
<ul>
<li>Increment the count at index (character - 'A') in <code>charCount</code>.</li>
</ul>
</li>
<li>Set a variable <code>total</code> as the <code>factorial</code> of the length of <code>seq</code>.</li>
<li>Divide the <code>total</code> by the factorial of each character's frequency in <code>charCount</code>.</li>
<li>Return the final <code>total</code>.</li>
</ul>
<p>Helper method <code>generateSequences(tiles, current, pos, seen)</code>:</p>
<ul>
<li>Check if the current <code>pos</code> has reached the length of <code>tiles</code>. If true and the <code>current</code> sequence is new (added to <code>seen</code> set):
<ul>
<li>Return the number of permutations for the current sequence.</li>
</ul>
</li>
<li>If true but the sequence is already seen:
<ul>
<li>Return <code>0</code>.</li>
</ul>
</li>
<li>Make two recursive calls and sum their results:
<ul>
<li>One excluding the current character (same sequence, next position).</li>
<li>One including the current character (sequence + current character, next position).</li>
</ul>
</li>
<li>Return the sum of both recursive calls.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/oW4cyKrY/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>tiles</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n \cdot n)\)</span></p>
<p>The time complexity is determined by several components:</p>
<ol>
<li>The initial sorting takes <span class="math inline">\(O(n \log n)\)</span> time.</li>
<li>In the <code>generateSequences</code> function, we create a binary recursion tree where at each position we have two choices (include or exclude), leading to <span class="math inline">\(2^n\)</span> possible sequences. For each unique sequence, we calculate permutations which involves iterating over the sequence (<span class="math inline">\(O(n)\)</span>) and performing factorial calculations (<span class="math inline">\(O(n)\)</span>).</li>
<li>The factorial calculations themselves are <span class="math inline">\(O(n)\)</span> as they iterate from <span class="math inline">\(1\)</span> to at most <span class="math inline">\(n\)</span>.</li>
</ol>
<p>Therefore, the dominant factor is generating and processing all possible sequences, giving us a time complexity of <span class="math inline">\(O(2^n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n \cdot n)\)</span></p>
<p>The space complexity also has multiple components.</p>
<ol>
<li>The recursion stack can go up to depth <span class="math inline">\(n\)</span>, using <span class="math inline">\(O(n)\)</span> space.</li>
<li>The hash set <code>seen</code> stores unique combinations of characters. In the worst case, with all distinct characters, we could have <span class="math inline">\(2^n\)</span> different combinations as each character can either be included or excluded. Each sequence in the set can be up to length <span class="math inline">\(n\)</span>. So, the set uses <span class="math inline">\(O(2^n \cdot n)\)</span> space.</li>
<li>The <code>charCount</code> array in <code>countPermutations</code> is constant space <span class="math inline">\(O(1)\)</span> as it's always size <span class="math inline">\(26\)</span>.</li>
</ol>
<p>Thus, the dominant factor is the space needed for storing unique sequences in the <code>seen</code> set, making the total space complexity <span class="math inline">\(O(2^n \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/longest-possible-route-in-a-matrix-with-hurdles/1" target="_blank" rel="noopener noreferrer">Longest Possible Route in a Matrix with Hurdles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an N&nbsp;x M&nbsp;matrix, with a few hurdles(denoted by 0) arbitrarily placed, calculate the length of the longest possible route possible from source<strong>(xs,ys)</strong> to a destination<strong>(xd,yd)</strong> within the matrix. We are allowed to move to only adjacent cells which are not hurdles. The route cannot contain any diagonal moves and a location once visited in a particular path cannot be visited again.If it is impossible to reach the destination from the source return <strong>-1</strong>.</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">{xs,ys} = {0,0}</span>
<span style="font-size: 18px;">{xd,yd} = {1,7}</span>
<span style="font-size: 18px;">matrix = 1 1 1 1 1 1 1 1 1 1</span>
<span style="font-size: 18px;">         1 1 0 1 1 0 1 1 0 1</span>
<span style="font-size: 18px;">         1 1 1 1 1 1 1 1 1 1</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">24</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<strong><span style="font-size: 18px;"><img style="height: 175px; width: 500px;" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/matrix_highlight.png" alt="" /></span></strong></pre>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong>
<span style="font-size: 18px;">{xs,ys} = {0,3}</span>
<span style="font-size: 18px;">{xd,yd} = {2,2}</span>
<span style="font-size: 18px;">matrix =<strong><span style="font-size: 18px;"> </span></strong>1 0 0 1 0</span>
<span style="font-size: 18px;">         0 0 0 1 0</span>
<span style="font-size: 18px;">         0 1 1 0 0</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">-1</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">We can see that it is impossible to</span>
<span style="font-size: 18px;">reach the cell (2,2) from (0,3).</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>longestPath()&nbsp;</strong>which takes matrix ,source and destination as&nbsp;input parameters and returns an integer denoting the longest path.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(2^(N*M))<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-subsequence-repeated-k-times/description" target="_blank" rel="noopener noreferrer">Longest Subsequence Repeated k Times</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> of length <code>n</code>, and an integer <code>k</code>. You are tasked to find the <strong>longest subsequence repeated</strong> <code>k</code> times in string <code>s</code>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>A subsequence <code>seq</code> is <strong>repeated</strong> <code>k</code> times in the string <code>s</code> if <code>seq * k</code> is a subsequence of <code>s</code>, where <code>seq * k</code> represents a string constructed by concatenating <code>seq</code> <code>k</code> times.</p>

<ul>
	<li>For example, <code>&quot;bba&quot;</code> is repeated <code>2</code> times in the string <code>&quot;bababcba&quot;</code>, because the string <code>&quot;bbabba&quot;</code>, constructed by concatenating <code>&quot;bba&quot;</code> <code>2</code> times, is a subsequence of the string <code>&quot;<strong><u>b</u></strong>a<strong><u>bab</u></strong>c<strong><u>ba</u></strong>&quot;</code>.</li>
</ul>

<p>Return <em>the <strong>longest subsequence repeated</strong> </em><code>k</code><em> times in string </em><code>s</code><em>. If multiple such subsequences are found, return the <strong>lexicographically largest</strong> one. If there is no such subsequence, return an <strong>empty</strong> string</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example 1" src="https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png" style="width: 457px; height: 99px;" />
<pre>
<strong>Input:</strong> s = &quot;letsleetcode&quot;, k = 2
<strong>Output:</strong> &quot;let&quot;
<strong>Explanation:</strong> There are two longest subsequences repeated 2 times: &quot;let&quot; and &quot;ete&quot;.
&quot;let&quot; is the lexicographically largest one.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;, k = 2
<strong>Output:</strong> &quot;b&quot;
<strong>Explanation:</strong> The longest subsequence repeated 2 times is &quot;b&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab&quot;, k = 2
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There is no subsequence repeated 2 times. Empty string is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length</code></li>
	<li><code>2 &lt;= k &lt;= 2000</code></li>
	<li><code>2 &lt;= n &lt; min(2001, k * 8)</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-brute-force-enumeration">Approach: Brute-force Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, the task is to find the longest subsequence of characters that appears at least <span class="math inline">\(k\)</span> times and is lexicographically largest. Therefore, the characters that make up this subsequence must appear at least <span class="math inline">\(k\)</span> times in <span class="math inline">\(s\)</span>. Characters that appear fewer than <span class="math inline">\(k\)</span> times in <span class="math inline">\(s\)</span> can be filtered out directly.</p>
<p>Let the length of <span class="math inline">\(s\)</span> be <span class="math inline">\(n\)</span>. We only consider characters in <span class="math inline">\(s\)</span> that appear at least <span class="math inline">\(k\)</span> times. The longest valid subsequence can only be composed of these characters, and their count cannot exceed <span class="math inline">\(\left\lfloor \dfrac{n}{k} \right\rfloor\)</span>. Since the problem states that <span class="math inline">\(n < 8k\)</span>, the length of the longest valid subsequence must be at most <span class="math inline">\(7\)</span>, and the number of qualifying characters is also at most <span class="math inline">\(7\)</span>. Therefore, the number of candidate subsequences does not exceed <span class="math inline">\(2^7 = 128\)</span>, making it feasible to use brute-force enumeration to find the correct answer.</p>
<p>We start by counting the frequency of each character to identify those that meet the required threshold. Then, we enumerate all possible permutations formed from any combination of these characters. For each such permutation <span class="math inline">\(\textit{permutation}_i\)</span>, we check whether it appears in <span class="math inline">\(s\)</span> at least <span class="math inline">\(k\)</span> times. Among all valid permutations, we return the one with the maximum length and the greatest lexicographical order.</p>
<p>To generate all permutations, we can use a queue. Each time, we pop the current valid subsequence <span class="math inline">\(\textit{curr}\)</span> from the queue and attempt to append a valid character <span class="math inline">\(c\)</span> to form a new string <span class="math inline">\(\textit{next}\)</span>. If <span class="math inline">\(\textit{next}\)</span> appears in <span class="math inline">\(s\)</span> at least <span class="math inline">\(k\)</span> times, we push it into the queue to continue expanding it. By enumerating characters in reverse lexicographical order (from largest to smallest), we ensure that the largest lexicographical string is generated first. This allows us to return the longest and lexicographically largest valid subsequence efficiently.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DmwxQ3yf/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the given string, and let <span class="math inline">\(k\)</span> be the given number.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot {\lfloor \dfrac{n}{k} \rfloor}!)\)</span>.</p>
<p>According to the analysis, the length of the subsequence does not exceed <span class="math inline">\(m = \lfloor \frac{n}{k} \rfloor\)</span>. At this point, there are <span class="math inline">\(i!\)</span> combinations of strings of length <span class="math inline">\(i\)</span>, so the total number of possible string combinations is</p>
</li>
</ul>
<p><span class="math display">\[
  Therefore, there are at most $2m!$ candidate subsequences. After generating the candidate subsequences, it still takes $O(n)$ time to match and check them, so the total time complexity is $O(n \cdot \lfloor \frac{n}{k} \rfloor!)$.

- Space complexity: $O(\lfloor \dfrac{n}{k} \rfloor!)$.

  There can be at most $\lfloor \dfrac{n}{k} \rfloor!$ candidate subsequences, and at most $\lfloor \dfrac{n}{k} \rfloor!$ elements can exist in the queue. Thus, the space complexity is $O(\lfloor \dfrac{n}{k} \rfloor!)$.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matchsticks-to-square/description" target="_blank" rel="noopener noreferrer">Matchsticks to Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>matchsticks</code> where <code>matchsticks[i]</code> is the length of the <code>i<sup>th</sup></code> matchstick. You want to use <strong>all the matchsticks</strong> to make one square. You <strong>should not break</strong> any stick, but you can link them up, and each matchstick must be used <strong>exactly one time</strong>.</p>

<p>Return <code>true</code> if you can make this square and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matchsticks = [1,1,2,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> You can form a square with length 2, one side of the square came two sticks with length 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matchsticks = [3,3,3,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> You cannot find a way to form a square with all the matchsticks.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>
	<li><code>1 &lt;= matchsticks[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Suppose we have <code>1,1,1,1,2,2,2,2,3,3,3,3</code> as our set of matchsticks. In this case a square of side <span class="math inline">\(6\)</span> can be formed and we have 4 matchsticks each of 1, 2 and 3 and so we can have each square side formed by <code>3 + 2 + 1 = 6</code>.</p>
<center>
<img src="../Figures/473/473_Matchsticks-In-Square-Diag-1.png" height="400"></center>
<p>We can clearly see in the diagram above that the 3 matchsticks of sizes <code>1</code>, <code>2</code> and <code>3</code> combine to give one side of our resulting square.</p>
<p>This problem boils down to splitting an array of integers into <span class="math inline">\(4\)</span> subsets where all of these subsets are:</p>
<ul>
<li>mutually exclusive i.e. no specific element of the array is shared by any two of these subsets, and</li>
<li>have the same sum which is equal to the side of our square.</li>
</ul>
<p>We know that we will have <span class="math inline">\(4\)</span> different subsets. The sum of elements of these subsets would be <span class="math inline">\(\frac{1}{4}\sum_{}^{} arr\)</span>. If the sum if not divisible by <span class="math inline">\(4\)</span>, that implies that <span class="math inline">\(4\)</span> subsets of equal value are not possible and we don't need to do any further processing on this.</p>
<p>The only question that remains now for us to solve is:</p>
<blockquote>
<p>what subset a particular element belongs to?</p>
</blockquote>
<p>If we are able to figure that out, then there's nothing else left to do. But, since we can't say which of the <span class="math inline">\(4\)</span> subsets would contain a particular element, we try out all the options.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>It is possible that a matchstick <em><strong>can</strong></em> be a part of any of the 4 sides of the resulting square, but which one of these choices leads to an actual square is something we don't know.</p>
<p>This means that for every matchstick in our given array, we have <span class="math inline">\(4\)</span> different options each representing the side of the square or subset that this matchstick can be a part of.</p>
<p>We try out all of them and keep on doing this recursively until we exhaust all of the possibilities or until we find an arrangement of our matchsticks such that they form the square.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>As discussed previously, we will follow a recursive, depth first approach to solve this problem. So, we have a function that takes the current matchstick index we are to process and also the number of sides of the square that are completely formed till now.</p>
</li>
<li>
<p>If all of the matchsticks have been used up and 4 sides have been completely formed, that implies our square is completely formed. This is the base case for the recursion.</p>
</li>
<li>
<p>For the current matchstick we have 4 different options. This matchstick at <span class="math inline">\(index\)</span> can be a part of any of the sides of the square. We try out the 4 options by recursing on them.</p>
<ul>
<li>If any of these recursive calls returns <span class="math inline">\(True\)</span>, then we return from there, else we return <span class="math inline">\(False\)</span></li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LGi7CtY9/shared">code</a></p>
<p>This solution is very slow as is. However, we can speed it up considerably by a small trick and that is to <code>sort our matchsticks sizes in reverse order before processing them recursively</code>.</p>
<p>The reason for this is that if there is no solution, trying a longer matchstick first will get to negative conclusion earlier.</p>
<p>e.g. <span class="math inline">\([8,4,4,4]\)</span>. In this case we can have a square of size 5 but the largest side 8 doesn't fit in anywhere i.e. cannot be a part of any of the sides (because we can't break matchsticks according to the question) and hence we can simply return <span class="math inline">\(False\)</span> without even considering the remaining matchsticks.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(4^N)\)</span> because we have a total of <span class="math inline">\(N\)</span> sticks and for each one of those matchsticks, we have <span class="math inline">\(4\)</span> different possibilities for the subsets they might belong to or the side of the square they might be a part of.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>. For recursive solutions, the space complexity is the stack space occupied by all the recursive calls. The deepest recursive call here would be of size <span class="math inline">\(N\)</span> and hence the space complexity is <span class="math inline">\(O(N)\)</span>. There is no additional space other than the recursion stack in this solution.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In any dynamic programming problem, what's important is that our problem must be breakable into smaller subproblems and also, these subproblems show some sort of overlap which we can save upon by caching or memoization.</p>
<p>Suppose we have <code>3,3,4,4,5,5</code> as our matchsticks that have been used already to construct some of the sides of our square (<strong>Note:</strong> not all the sides may be completely constructed at all times.)</p>
<p>If the square side is <span class="math inline">\(8\)</span>, then there are many possibilities for how the sides can be constructed using the matchsticks above. We can have</p>
<pre>
  (4, 4), (3, 5), (3, 5) -----------> 3 sides fully constructed.
  (3, 4), (3, 5), (4), (5) ---------> 0 sides completely constructed.
  (3, 3), (4, 4), (5), (5) ---------> 1 side completely constructed.
</pre>
<p>As we can see above, there are multiple ways to use the same set of matchsticks and land up in completely different recursion states.</p>
<p>This means that if we just keep track of what all matchsticks have been used and which all are remaining, it won't properly define the state of recursion we are in or what subproblem we are solving.</p>
<p>A single set of used matchsticks can represent multiple different unrelated subproblems and that is just not right.</p>
<p>We also need to keep track of number of sides of the square that have been <strong>completely</strong> formed till now.</p>
<p>Also, an important thing to note in the example we just considered was that if the matchsticks being used are <span class="math inline">\([3,3,4,4,5,5]\)</span> and the side of the square is <code>8</code>, then we will always consider that arrangement that forms the most number of complete sides over that arrangement that leads to incomplete sides. Hence, the optimal arrangement here is <span class="math inline">\((4, 4), (3, 5), (3, 5)\)</span> with 3 complete sides of the square.</p>
<p>Let us take a look at the following recursion tree to see if in-fact we can get overlapping subproblems.</p>
<center>
<img src="../Figures/473/473_Matchsticks-In-Square-Diag-2.png" width="500"></center>
<p><strong>Note:</strong> Not all subproblems have been shown in this figure. The thing we wanted to point out was overlapping subproblems.</p>
<p>We know that the overall sum of these matchsticks can be split equally into 4 halves. The only thing we don't know is if 4 <strong>equal</strong> halves can be carved out of the given set of matchsticks. For that also we need to keep track of the number of sides completely formed at any point in time. <em><strong>If we end up forming 4 equal sides successfully then naturally we would have used up all of the matchsticks each being used exactly once and we would have formed a square</strong></em>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Let us first look at the pseudo-code for this problem before looking at the exact implementation details for the same.</p>
<pre>
let square_side = sum(matchsticks) / 4
func recurse(matchsticks_used, sides_formed) {
    if sides_formed == 4, then {
        Square Formed!!
    }
    for match in matchsticks available, do {
          add match to matchsticks_used
          let result = recurse(matchsticks_used, sides_formed)
          if result == True, then {
              return True
          }
          remove match from matchsticks_used
    }
    return False
}
</pre>
<p>This is the overall structure of our dynamic programming solution. Of course, a lot of implementation details are missing here that we will address now.</p>
<br />
<p>It is very clear from the pseudo-code above that the state of a recursion is defined by two variables <code>matchsticks_used</code> and <code>sides_formed</code>. Hence, these are the two variables that will be used to <strong>memoize</strong> or cache the results for that specific subproblem.</p>
<p>The question however is how do we actually store all the matchsticks that have been used? We want a memory efficient solution for this.</p>
<p>If we look at the question's constraints, we find that the max number of matchsticks we can have are <span class="math inline">\(15\)</span>. That's a pretty small number and we can make use of this constraint.</p>
<p>All we need to store is which of the matchsticks from the original list have been used. <code>We can use a Bit-Map for this</code></p>
<p>We will use <span class="math inline">\(N\)</span> number of bits, one for each of the matchsticks (<span class="math inline">\(N\)</span> is at max 15 according to the question's constraints). Initially we will start with a bit mask of <code>all 1s</code> and then as we keep on using the matchsticks, we will keep on setting their corresponding bits to <code>0</code>.</p>
<p>This way, we just have to hash an integer value which represents our bit-map and the max value for this mask would be <span class="math inline">\(2^{15}\)</span>.</p>
<br />
<p><strong>Do we really need to see if all 4 sides have been completely formed ?</strong></p>
<p>Another implementation trick that helps optimize this solution is that we don't really need to see if 4 sides have been completely formed.</p>
<p>This is because, we already know that the sum of all the matchsticks is divisible by 4. So, <em>if 3 equal sides have been formed by using some of the matchsticks, then the remaining matchsticks would definitely form the remaining side of our square.</em></p>
<p>Hence, we only need to check if 3 sides of our square can be formed or not.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/kKkAjm9e/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \times 2^N)\)</span>. At max <span class="math inline">\(2^N\)</span> unique bit masks are possible and during every recursive call, we iterate our original matchsticks array to sum up the values of matchsticks used to update the <code>sides_formed</code> variable.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N + 2^N)\)</span> because <span class="math inline">\(N\)</span> is the stack space taken up by recursion and <span class="math inline">\(4 \times 2^N\)</span> = <span class="math inline">\(O(2^N)\)</span> is the max possible size of our cache for memoization.</p>
<ul>
<li>The size of the cache is defined by the two variables <code>sides_formed</code> and <code>mask</code>. The number of different values that <code>sides_formed</code> can take = 4 and number of unique values of <code>mask</code> = <span class="math inline">\(2^N\)</span>.</li>
</ul>
<br />
<br /></li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-score-after-n-operations/description" target="_blank" rel="noopener noreferrer">Maximize Score After N Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>nums</code>, an array of positive integers of size <code>2 * n</code>. You must perform <code>n</code> operations on this array.</p>

<p>In the <code>i<sup>th</sup></code> operation <strong>(1-indexed)</strong>, you will:</p>

<ul>
	<li>Choose two elements, <code>x</code> and <code>y</code>.</li>
	<li>Receive a score of <code>i * gcd(x, y)</code>.</li>
	<li>Remove <code>x</code> and <code>y</code> from <code>nums</code>.</li>
</ul>

<p>Return <em>the maximum score you can receive after performing </em><code>n</code><em> operations.</em></p>

<p>The function <code>gcd(x, y)</code> is the greatest common divisor of <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,6,8]
<strong>Output:</strong> 11
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6]
<strong>Output:</strong> 14
<strong>Explanation:</strong>&nbsp;The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 7</code></li>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-compatibility-score-sum/description" target="_blank" rel="noopener noreferrer">Maximum Compatibility Score Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a survey that consists of <code>n</code> questions where each question&#39;s answer is either <code>0</code> (no) or <code>1</code> (yes).</p>

<p>The survey was given to <code>m</code> students numbered from <code>0</code> to <code>m - 1</code> and <code>m</code> mentors numbered from <code>0</code> to <code>m - 1</code>. The answers of the students are represented by a 2D integer array <code>students</code> where <code>students[i]</code> is an integer array that contains the answers of the <code>i<sup>th</sup></code> student (<strong>0-indexed</strong>). The answers of the mentors are represented by a 2D integer array <code>mentors</code> where <code>mentors[j]</code> is an integer array that contains the answers of the <code>j<sup>th</sup></code> mentor (<strong>0-indexed</strong>).</p>

<p>Each student will be assigned to <strong>one</strong> mentor, and each mentor will have <strong>one</strong> student assigned to them. The <strong>compatibility score</strong> of a student-mentor pair is the number of answers that are the same for both the student and the mentor.</p>

<ul>
	<li>For example, if the student&#39;s answers were <code>[1, <u>0</u>, <u>1</u>]</code> and the mentor&#39;s answers were <code>[0, <u>0</u>, <u>1</u>]</code>, then their compatibility score is 2 because only the second and the third answers are the same.</li>
</ul>

<p>You are tasked with finding the optimal student-mentor pairings to <strong>maximize</strong> the<strong> sum of the compatibility scores</strong>.</p>

<p>Given <code>students</code> and <code>mentors</code>, return <em>the <strong>maximum compatibility score sum</strong> that can be achieved.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
<strong>Output:</strong> 8
<strong>Explanation:</strong>&nbsp;We assign students to mentors in the following way:
- student 0 to mentor 2 with a compatibility score of 3.
- student 1 to mentor 0 with a compatibility score of 2.
- student 2 to mentor 1 with a compatibility score of 3.
The compatibility score sum is 3 + 2 + 3 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The compatibility score of any student-mentor pair is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == students.length == mentors.length</code></li>
	<li><code>n == students[i].length == mentors[j].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 8</code></li>
	<li><code>students[i][k]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>mentors[j][k]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-good-people-based-on-statements/description" target="_blank" rel="noopener noreferrer">Maximum Good People Based on Statements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are two types of persons:</p>

<ul>
	<li>The <strong>good person</strong>: The person who always tells the truth.</li>
	<li>The <strong>bad person</strong>: The person who might tell the truth and might lie.</li>
</ul>

<p>You are given a <strong>0-indexed</strong> 2D integer array <code>statements</code> of size <code>n x n</code> that represents the statements made by <code>n</code> people about each other. More specifically, <code>statements[i][j]</code> could be one of the following:</p>

<ul>
	<li><code>0</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>bad</strong> person.</li>
	<li><code>1</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>good</strong> person.</li>
	<li><code>2</code> represents that <strong>no statement</strong> is made by person <code>i</code> about person <code>j</code>.</li>
</ul>

<p>Additionally, no person ever makes a statement about themselves. Formally, we have that <code>statements[i][i] = 2</code> for all <code>0 &lt;= i &lt; n</code>.</p>

<p>Return <em>the <strong>maximum</strong> number of people who can be <strong>good</strong> based on the statements made by the </em><code>n</code><em> people</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg" style="width: 600px; height: 262px;" />
<pre>
<strong>Input:</strong> statements = [[2,1,2],[1,2,2],[2,0,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Each person makes a single statement.
- Person 0 states that person 1 is good.
- Person 1 states that person 0 is good.
- Person 2 states that person 1 is bad.
Let&#39;s take person 2 as the key.
- Assuming that person 2 is a good person:
    - Based on the statement made by person 2, person 1 is a bad person.
    - Now we know for sure that person 1 is bad and person 2 is good.
    - Based on the statement made by person 1, and since person 1 is bad, they could be:
        - telling the truth. There will be a contradiction in this case and this assumption is invalid.
        - lying. In this case, person 0 is also a bad person and lied in their statement.
    - <strong>Following that person 2 is a good person, there will be only one good person in the group</strong>.
- Assuming that person 2 is a bad person:
    - Based on the statement made by person 2, and since person 2 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.
            - <strong>Following that person 2 is bad but told the truth, there will be no good persons in the group</strong>.
        - lying. In this case person 1 is a good person.
            - Since person 1 is a good person, person 0 is also a good person.
            - <strong>Following that person 2 is bad and lied, there will be two good persons in the group</strong>.
We can see that at most 2 persons are good in the best case, so we return 2.
Note that there is more than one way to arrive at this conclusion.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg" style="width: 600px; height: 262px;" />
<pre>
<strong>Input:</strong> statements = [[2,0],[0,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each person makes a single statement.
- Person 0 states that person 1 is bad.
- Person 1 states that person 0 is bad.
Let&#39;s take person 0 as the key.
- Assuming that person 0 is a good person:
    - Based on the statement made by person 0, person 1 is a bad person and was lying.
    - <strong>Following that person 0 is a good person, there will be only one good person in the group</strong>.
- Assuming that person 0 is a bad person:
    - Based on the statement made by person 0, and since person 0 is bad, they could be:
        - telling the truth. Following this scenario, person 0 and 1 are both bad.
            - <strong>Following that person 0 is bad but told the truth, there will be no good persons in the group</strong>.
        - lying. In this case person 1 is a good person.
            - <strong>Following that person 0 is bad and lied, there will be only one good person in the group</strong>.
We can see that at most, one person is good in the best case, so we return 1.
Note that there is more than one way to arrive at this conclusion.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == statements.length == statements[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 15</code></li>
	<li><code>statements[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
	<li><code>statements[i][i] == 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/description" target="_blank" rel="noopener noreferrer">Maximum Length of a Concatenated String with Unique Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>arr</code>. A string <code>s</code> is formed by the <strong>concatenation</strong> of a <strong>subsequence</strong> of <code>arr</code> that has <strong>unique characters</strong>.</p>

<p>Return <em>the <strong>maximum</strong> possible length</em> of <code>s</code>.</p>

<p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]
<strong>Output:</strong> 4
<strong>Explanation:</strong> All the valid concatenations are:
- &quot;&quot;
- &quot;un&quot;
- &quot;iq&quot;
- &quot;ue&quot;
- &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;)
- &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;)
Maximum length is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]
<strong>Output:</strong> 26
<strong>Explanation:</strong> The only string in arr has all 26 characters.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 16</code></li>
	<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>
	<li><code>arr[i]</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-achievable-transfer-requests/description" target="_blank" rel="noopener noreferrer">Maximum Number of Achievable Transfer Requests</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We have <code>n</code> buildings numbered from <code>0</code> to <code>n - 1</code>. Each building has a number of employees. It&#39;s transfer season, and some employees want to change the building they reside in.</p>

<p>You are given an array <code>requests</code> where <code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represents an employee&#39;s request to transfer from building <code>from<sub>i</sub></code> to building <code>to<sub>i</sub></code>.</p>

<p><strong>All buildings are full</strong>, so a list of requests is achievable only if for each building, the <strong>net change in employee transfers is zero</strong>. This means the number of employees <strong>leaving</strong> is <strong>equal</strong> to the number of employees <strong>moving in</strong>. For example if <code>n = 3</code> and two employees are leaving building <code>0</code>, one is leaving building <code>1</code>, and one is leaving building <code>2</code>, there should be two employees moving to building <code>0</code>, one employee moving to building <code>1</code>, and one employee moving to building <code>2</code>.</p>

<p>Return <em>the maximum number of achievable requests</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/10/move1.jpg" style="width: 600px; height: 406px;" />
<pre>
<strong>Input:</strong> n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
<strong>Output:</strong> 5
<strong>Explantion:</strong> Let&#39;s see the requests:
From building 0 we have employees x and y and both want to move to building 1.
From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.
From building 2 we have employee z and they want to move to building 0.
From building 3 we have employee c and they want to move to building 4.
From building 4 we don&#39;t have any requests.
We can achieve the requests of users x and b by swapping their places.
We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/10/move2.jpg" style="width: 450px; height: 327px;" />
<pre>
<strong>Input:</strong> n = 3, requests = [[0,0],[1,2],[2,1]]
<strong>Output:</strong> 3
<strong>Explantion:</strong> Let&#39;s see the requests:
From building 0 we have employee x and they want to stay in the same building 0.
From building 1 we have employee y and they want to move to building 2.
From building 2 we have employee z and they want to move to building 1.
We can achieve all the requests. </pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>1 &lt;= requests.length &lt;= 16</code></li>
	<li><code>requests[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have <span class="math inline">\(N\)</span> buildings, each having some number of employees; there are some requests by the employees to get transferred from one building to another. We need to return the maximum number of requests that we can accommodate, considering the employee change count in each building should be zero, i.e. if one employee leaves a building, then some other employee should enter it too.</p>
<p>The most important observation is that the total requests could be at a max of <span class="math inline">\(16\)</span>. Hence, trying out all the <span class="math inline">\(2^{16}\)</span> possibilities could be a possible solution. We have <span class="math inline">\(16\)</span> requests, and for each one, we can have two options either to consider this request and move the employees or don't consider it and move to the next request. This is similar to the classic 0/1 knapsack problem, as for each request, we can either take it (1) or not (0). We will discuss two approaches, one the recursive and other iterative.</p>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<p><strong>Intuition</strong></p>
<p>As we discussed, each request has two options; the first is to accept this and move the employee in request <code>[x, y]</code> from building <code>x</code> to <code>y</code> and the second is to ignore it. Since, in the end, we need to check if the change in each building is zero, we need to have an array where the indices for each building will store the current employee count that has entered or left it.</p>
<p>For every request <code>[x, y]</code> that we consider, we will decrement the count for the index <code>x</code> in the array and increment the count for <code>y</code> denoting that the number of employees in the building <code>x</code> has increased by one and similarly for <code>y</code> it got decreased by one. When we ignore a request, we don't need to do anything except move on to the next request and repeat the same process until we have reached the end of requests.</p>
<p>Once we iterate over all the requests, we will then check the count for each building, and if it's zero for all, we will count the number of requests we considered in this request and update the maximum requests we have considered so far without violating the constraint. In the end, we can just return the maximum number of requests we considered in a combination.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize <code>answer</code> to <code>0</code>; this will store the maximum requests we can consider.</p>
</li>
<li>
<p>Initialize an array <code>indegree</code> of size <span class="math inline">\(N\)</span> with all values as <code>0</code>. This array will store the employee change count for each building.</p>
</li>
<li>
<p>Start the recursion with <code>index</code> and <code>count</code> as <code>0</code>. The <code>count</code> here is the number of requests we have considered in the current combination, for each index:</p>
<p>i. If we have iterated over all the requests, check if all values in <code>indegree</code> are zero. If yes, update the variable <code>answer</code> by comparing it to <code>count</code>. If all values aren't zero, return.</p>
<p>ii. For the first option, when we consider this request, update the <code>indegree</code> for both the buildings the current request involves. And move on to the next request with count as <code>count + 1</code>.</p>
<p>iii Revert the changes in <code>indegree</code> for the  request at <code>index</code>; this is the backtracking step.</p>
<p>iv. For the second option, where we ignore the request, make the recursion call with the following index without changing the <code>count</code>.</p>
</li>
<li>
<p>Return <code>answer</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/2vVML2oW/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of buildings, and <span class="math inline">\(M\)</span> is the number of requests.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^M * N)\)</span>.</p>
<p>We iterate over every two possibilities for each of the <span class="math inline">\(M\)</span> requests; this is equal to <span class="math inline">\(2^M\)</span> possibilities. For the leaf nodes, which are <span class="math inline">\(O(2^{M-1})\)</span>, we will iterate over <span class="math inline">\(N\)</span> buildings to check if the employee change is zero. Therefore the total time complexity would be <span class="math inline">\(O(2^M * N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M)\)</span>.</p>
<p>The array <code>indegree</code> is of size <span class="math inline">\(N\)</span>, and there would be some stack space as well for the recursion. The maximum number of active stack calls would equal <span class="math inline">\(M\)</span>, i.e. when all the requests call would be active. Hence the total space complexity would be <span class="math inline">\(O(N + M)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-2-bitmasking">Approach 2: Bitmasking</h3>
<p><strong>Intuition</strong></p>
<p>We can solve the problem iteratively as well; all we need is a way to iterate over every possible combination of requests that we can consider. We know the number of requests can only go up to <span class="math inline">\(16\)</span>, so we can use <span class="math inline">\(N\)</span> bits to represent the state of <span class="math inline">\(N\)</span> requests. The <span class="math inline">\(i^{th}\)</span> bit will be set in the combinations when we consider it; otherwise, it will be zero. Since the number <span class="math inline">\(2^{16}\)</span> is well within the integer limit, we will use an integer to denote the state of a combination.</p>
<p>All the integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^{16} - 1\)</span> represent all the possible combinations of requests that we can consider. Each number is a possible combination that we can check if it violates the constraints, i.e. the employee change count should be <code>0</code> after considering the requests in this number. Therefore, in this approach, we will iterate over these numbers, considering them as the possible combinations of requests we will consider. For all those combinations that don't violate the constraints, we will update the variable <code>answer</code> with the number of <code>1s</code> (the number of requests we considered) in the bitwise representation.</p>
<p><img src="../Figures/1601/1601A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize <code>answer</code> to <code>0</code>; this will store the maximum request we can consider.</p>
</li>
<li>
<p>Iterate over the numbers from <code>0</code> to <code>requests.size() - 1</code>, for each number <code>mask</code>:</p>
<p>i. Initialize the array <code>indegree</code> of size <span class="math inline">\(N\)</span> with all values as <code>0</code>.</p>
<p>ii. Store the count of set bits in <code>mask</code>  in the variable <code>bitCount</code>.</p>
<p>iii. If <code>bitCount &lt; answer</code>, return immediately as this couldn't be a better answer.</p>
<p>iv. Iterate over the bits in <code>mask</code>, and for each set bit, update the array <code>indegree</code> for the building it involves.</p>
<p>v. Iterate over each building and check if the value in the array <code>indegree</code> is zero; if it is, then update the variable <code>answer</code> to <code>bitCount</code>.</p>
</li>
<li>
<p>Return <code>bitCount</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/MHzTTuRk/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of buildings, and <span class="math inline">\(M\)</span> is the number of requests.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^(M * (M + N))\)</span>.</p>
<p>We iterate over every two possibilities for each of the <span class="math inline">\(M\)</span> requests; this is equal to <span class="math inline">\(2^M\)</span> possibilities. For each bitmask, we may iterate over <span class="math inline">\(N\)</span> buildings and <span class="math inline">\(M\)</span> requests. Therefore the total time complexity would be <span class="math inline">\(O(2^(M * (M + N))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>The array <code>indegree</code> is of size <span class="math inline">\(N\)</span>. Hence the total space complexity would be <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-path-quality-of-a-graph/description" target="_blank" rel="noopener noreferrer">Maximum Path Quality of a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">graph</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>). You are given a <strong>0-indexed</strong> integer array <code>values</code> where <code>values[i]</code> is the <strong>value </strong>of the <code>i<sup>th</sup></code> node. You are also given a <strong>0-indexed</strong> 2D integer array <code>edges</code>, where each <code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code> indicates that there is an undirected edge between the nodes <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code>,<sub> </sub>and it takes <code>time<sub>j</sub></code> seconds to travel between the two nodes. Finally, you are given an integer <code>maxTime</code>.</p>

<p>A <strong>valid</strong> <strong>path</strong> in the graph is any path that starts at node <code>0</code>, ends at node <code>0</code>, and takes <strong>at most</strong> <code>maxTime</code> seconds to complete. You may visit the same node multiple times. The <strong>quality</strong> of a valid path is the <strong>sum</strong> of the values of the <strong>unique nodes</strong> visited in the path (each node&#39;s value is added <strong>at most once</strong> to the sum).</p>

<p>Return <em>the <strong>maximum</strong> quality of a valid path</em>.</p>

<p><strong>Note:</strong> There are <strong>at most four</strong> edges connected to each node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png" style="width: 269px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
<strong>Output:</strong> 75
<strong>Explanation:</strong>
One possible path is 0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0. The total time taken is 10 + 10 + 10 + 10 = 40 &lt;= 49.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png" style="width: 269px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
<strong>Output:</strong> 25
<strong>Explanation:</strong>
One possible path is 0 -&gt; 3 -&gt; 0. The total time taken is 10 + 10 = 20 &lt;= 30.
The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png" style="width: 236px; height: 170px;" />
<pre>
<strong>Input:</strong> values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
<strong>Output:</strong> 7
<strong>Explanation:</strong>
One possible path is 0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0. The total time taken is 10 + 13 + 13 + 10 = 46 &lt;= 50.
The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == values.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= 2000</code></li>
	<li><code>edges[j].length == 3 </code></li>
	<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>
	<li>All the pairs <code>[u<sub>j</sub>, v<sub>j</sub>]</code> are <strong>unique</strong>.</li>
	<li>There are <strong>at most four</strong> edges connected to each node.</li>
	<li>The graph may not be connected.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-points-in-an-archery-competition/description" target="_blank" rel="noopener noreferrer">Maximum Points in an Archery Competition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob are opponents in an archery competition. The competition has set the following rules:</p>

<ol>
	<li>Alice first shoots <code>numArrows</code> arrows and then Bob shoots <code>numArrows</code> arrows.</li>
	<li>The points are then calculated as follows:
	<ol>
		<li>The target has integer scoring sections ranging from <code>0</code> to <code>11</code> <strong>inclusive</strong>.</li>
		<li>For <strong>each</strong> section of the target with score <code>k</code> (in between <code>0</code> to <code>11</code>), say Alice and Bob have shot <code>a<sub>k</sub></code> and <code>b<sub>k</sub></code> arrows on that section respectively. If <code>a<sub>k</sub> &gt;= b<sub>k</sub></code>, then Alice takes <code>k</code> points. If <code>a<sub>k</sub> &lt; b<sub>k</sub></code>, then Bob takes <code>k</code> points.</li>
		<li>However, if <code>a<sub>k</sub> == b<sub>k</sub> == 0</code>, then <strong>nobody</strong> takes <code>k</code> points.</li>
	</ol>
	</li>
</ol>

<ul>
	<li>
	<p>For example, if Alice and Bob both shot <code>2</code> arrows on the section with score <code>11</code>, then Alice takes <code>11</code> points. On the other hand, if Alice shot <code>0</code> arrows on the section with score <code>11</code> and Bob shot <code>2</code> arrows on that same section, then Bob takes <code>11</code> points.</p>
	</li>
</ul>

<p>You are given the integer <code>numArrows</code> and an integer array <code>aliceArrows</code> of size <code>12</code>, which represents the number of arrows Alice shot on each scoring section from <code>0</code> to <code>11</code>. Now, Bob wants to <strong>maximize</strong> the total number of points he can obtain.</p>

<p>Return <em>the array </em><code>bobArrows</code><em> which represents the number of arrows Bob shot on <strong>each</strong> scoring section from </em><code>0</code><em> to </em><code>11</code>. The sum of the values in <code>bobArrows</code> should equal <code>numArrows</code>.</p>

<p>If there are multiple ways for Bob to earn the maximum total points, return <strong>any</strong> one of them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/24/ex1.jpg" style="width: 600px; height: 120px;" />
<pre>
<strong>Input:</strong> numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]
<strong>Output:</strong> [0,0,0,0,1,1,0,0,1,2,3,1]
<strong>Explanation:</strong> The table above shows how the competition is scored. 
Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.
It can be shown that Bob cannot obtain a score higher than 47 points.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/24/ex2new.jpg" style="width: 600px; height: 117px;" />
<pre>
<strong>Input:</strong> numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]
<strong>Output:</strong> [0,0,0,0,0,0,0,0,1,1,1,0]
<strong>Explanation:</strong> The table above shows how the competition is scored.
Bob earns a total point of 8 + 9 + 10 = 27.
It can be shown that Bob cannot obtain a score higher than 27 points.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>
	<li><code>aliceArrows.length == bobArrows.length == 12</code></li>
	<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>
	<li><code>sum(aliceArrows[i]) == numArrows</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/description" target="_blank" rel="noopener noreferrer">Maximum Product of the Length of Two Palindromic Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, find two <strong>disjoint palindromic subsequences</strong> of <code>s</code> such that the <strong>product</strong> of their lengths is <strong>maximized</strong>. The two subsequences are <strong>disjoint</strong> if they do not both pick a character at the same index.</p>

<p>Return <em>the <strong>maximum</strong> possible <strong>product</strong> of the lengths of the two palindromic subsequences</em>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png" style="width: 550px; height: 124px;" />
<pre>
<strong>Input:</strong> s = &quot;leetcodecom&quot;
<strong>Output:</strong> 9
<strong>Explanation</strong>: An optimal solution is to choose &quot;ete&quot; for the 1<sup>st</sup> subsequence and &quot;cdc&quot; for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 3 * 3 = 9.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;
<strong>Output:</strong> 1
<strong>Explanation</strong>: An optimal solution is to choose &quot;b&quot; (the first character) for the 1<sup>st</sup> subsequence and &quot;b&quot; (the second character) for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 1 * 1 = 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;accbcaxxcxx&quot;
<strong>Output:</strong> 25
<strong>Explanation</strong>: An optimal solution is to choose &quot;accca&quot; for the 1<sup>st</sup> subsequence and &quot;xxcxx&quot; for the 2<sup>nd</sup> subsequence.
The product of their lengths is: 5 * 5 = 25.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 12</code></li>
	<li><code>s</code> consists of lowercase English letters only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-rows-covered-by-columns/description" target="_blank" rel="noopener noreferrer">Maximum Rows Covered by Columns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>matrix</code> and an integer <code>numSelect</code>.</p>

<p>Your goal is to select exactly <code>numSelect</code> <strong>distinct </strong>columns from <code>matrix</code> such that you cover as many rows as possible.</p>

<p>A row is considered <strong>covered</strong> if all the <code>1</code>&#39;s in that row are also part of a column that you have selected. If a row does not have any <code>1</code>s, it is also considered covered.</p>

<p>More formally, let us consider <code>selected = {c<sub>1</sub>, c<sub>2</sub>, ...., c<sub>numSelect</sub>}</code> as the set of columns selected by you. A row <code>i</code> is <strong>covered</strong> by <code>selected</code> if:</p>

<ul>
	<li>For each cell where <code>matrix[i][j] == 1</code>, the column <code>j</code> is in <code>selected</code>.</li>
	<li>Or, no cell in row <code>i</code> has a value of <code>1</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> number of rows that can be <strong>covered</strong> by a set of <code>numSelect</code> columns.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png" style="width: 240px; height: 400px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One possible way to cover 3 rows is shown in the diagram above.<br />
We choose s = {0, 2}.<br />
- Row 0 is covered because it has no occurrences of 1.<br />
- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.<br />
- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.<br />
- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.<br />
Thus, we can cover three rows.<br />
Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png" style="height: 250px; width: 84px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [[1],[0]], numSelect = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting the only column will result in both rows being covered since the entire matrix is selected.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>matrix[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= numSelect&nbsp;&lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-words-formed-by-letters/description" target="_blank" rel="noopener noreferrer">Maximum Score Words Formed by Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a list of <code>words</code>, list of&nbsp; single&nbsp;<code>letters</code> (might be repeating)&nbsp;and <code>score</code>&nbsp;of every character.</p>

<p>Return the maximum score of <strong>any</strong> valid set of words formed by using the given letters (<code>words[i]</code> cannot be used two&nbsp;or more times).</p>

<p>It is not necessary to use all characters in <code>letters</code> and each letter can only be used once. Score of letters&nbsp;<code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, ... ,<code>&#39;z&#39;</code> is given by&nbsp;<code>score[0]</code>, <code>score[1]</code>, ... , <code>score[25]</code> respectively.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
<strong>Output:</strong> 23
<strong>Explanation:</strong>
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.
Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
<strong>Output:</strong> 27
<strong>Explanation:</strong>
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words &quot;ax&quot; (4+5), &quot;bx&quot; (4+5) and &quot;cx&quot; (4+5) with a score of 27.
Word &quot;xxxz&quot; only get a score of 25.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
Letter &quot;e&quot; can only be used once.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 14</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 15</code></li>
	<li><code>1 &lt;= letters.length &lt;= 100</code></li>
	<li><code>letters[i].length == 1</code></li>
	<li><code>score.length ==&nbsp;26</code></li>
	<li><code>0 &lt;= score[i] &lt;= 10</code></li>
	<li><code>words[i]</code>, <code>letters[i]</code>&nbsp;contains only lower case English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given a list of <code>words</code>, we need to find the maximum subset score using the given set of <code>letters</code>. Each letter has a score tied to it, which is provided in <code>score</code>. Each entry in <code>words</code> can only be used once, although the same word can occur as multiple entries. Each character in <code>letters</code> can be used at most once.</p>
<p>This problem tests your ability to implement an algorithm that efficiently maintains a maximum score over all subsets of a set of words. The two main ways to do this are using an iterative loop and a recursive search method.</p>
<hr />
<h3 id="approach-1-iterative-loop-for-every-subset">Approach 1: Iterative Loop for Every Subset</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the size of the input is very small, a brute-force solution is feasible. We can check all subsets of <code>words</code> and return the largest score among subsets that can be constructed with the given <code>letters</code>.</p>
<p>Let's create a frequency array <code>freq</code> that stores the frequency of each letter in <code>letters</code>, which is needed to track how many copies of each letter we can use. For every subset of words, let's also create a <code>subsetLetters</code> array that stores the frequency of each letter of every word in the subset. The <code>subsetLetters</code> array is used to track the current state of words and how many copies of each letter are needed to build the current subset. Specifically, this subset can be constructed if and only if <code>freq[c] &lt;= subsetLetters[c]</code> for all letters <code>c</code>. If a subset is valid, its score is equal to the sum of <code>subsetLetters[c] * score[c]</code> for all <code>c</code>.</p>
<p>Now that we have a strategy to check the validity and score of a subset, we need to generate and check the subsets. For this approach, we'll use a for loop that iterates through every integer <code>mask</code> whose binary representation corresponds to a subset of <code>words</code>. The <span class="math inline">\(i^{\texttt{th}}\)</span> bit in <code>mask</code> equals <code>1</code> if this subset contains <code>words[i]</code>, and <code>0</code> otherwise.</p>
<p>Example binary representations of subsets:</p>
<p><img src="../Figures/1255/1255_words_example_updated.png" alt="figA" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Generate a frequency array where <code>freq[c]</code> is the number of times letter <code>c</code> appears in <code>letters</code>.</li>
<li>Initialize <code>maxScore</code> to store the largest score among valid subsets.</li>
<li>Use a for loop that goes from <span class="math inline">\(0\)</span> (inclusive) to <span class="math inline">\(2^W\)</span> (exclusive) where <span class="math inline">\(W\)</span> is the length of <code>words</code> to iterate over every subset using masks. For each mask, word <span class="math inline">\(i\)</span> is in this subset if the <span class="math inline">\(i^{\texttt{th}}\)</span> bit is set in the current mask.</li>
<li>For each word in the current subset, increment <code>subsetLetters[c]</code> for each letter <code>c</code> in the word.</li>
<li>Declare a helper function, <code>subsetScore,</code> that checks if the subset can be built out of the given letters and calculates the score:
<ul>
<li>Initialize a variable <code>totalScore</code> to <code>0</code>.</li>
<li>For each character in the alphabet, compute the score of this subset by adding <code>score[c]</code> for every occurrence of <code>c</code> in this subset, and add it to <code>totalScore</code>.  If <code>freq[c] &lt; subsetLetters[c]</code> holds true for any letter <code>c</code>, then return <span class="math inline">\(0\)</span>, as this subset is impossible to construct with the given letters.</li>
<li>Return <code>totalScore</code>.</li>
</ul>
</li>
<li>If <code>maxScore</code> is less than the result of <code>subsetScore</code>, update <code>maxScore</code>.</li>
<li>Return <code>maxScore</code> after all subsets are checked.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Rkobsw98/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(W\)</span> be the length of <code>words</code>, <span class="math inline">\(L\)</span> be the maximum length of any word in <code>words</code>, and <span class="math inline">\(A\)</span> be the size of the alphabet (in this case, <span class="math inline">\(A = 26\)</span>).</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^W \cdot (WL + A))\)</span>.</li>
</ul>
<p>For each subset, we need to iterate through every string in this subset, which takes <span class="math inline">\(WL\)</span> time. Additionally, <span class="math inline">\(A\)</span> operations are needed to populate the <code>subsetLetters</code> array for each subset.</p>
<p>We have two choices for each word: it belongs in the subset, or it doesn't. This gives a total of <span class="math inline">\(2^W\)</span> possible subsets for <span class="math inline">\(W\)</span> words. Therefore, this yields a complexity of <span class="math inline">\(O(2^W(WL + A))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(A)\)</span>.</li>
</ul>
<p>In this implementation, only two arrays of length <span class="math inline">\(A\)</span> are created: the <code>freq</code> array, which stores the frequencies of characters in <code>letters</code>, and the <code>subsetLetters</code> array, which stores letter frequencies for the current subset.</p>
<hr />
<h3 id="approach-2-backtracking">Approach 2: Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Suppose the set of usable letters in a given input does not contain the letter &quot;d&quot;, and the set of words is <code>[&quot;abcd&quot;, &quot;acc&quot;, &quot;abb&quot;, &quot;bc&quot;]</code>. Note that any subset containing the word &quot;abcd&quot; is always invalid, because the word contains letter &quot;d&quot;. The iterative approach will continue to check every subset that contains &quot;abcd&quot;, which results in a considerable amount of unnecessary computation. What if we had a way to prune all subsets containing the word &quot;abcd&quot;? This is where a recursive solution comes into play.</p>
<p>Rather than iteratively checking every subset of words, we can use a recursive function to choose whether we include or exclude the current word in a candidate subset. If we pass the <code>subsetLetters</code> array as a parameter throughout every recursive call, after the addition of a word to a subset, we can check if there is a letter <code>c</code> where <code>subsetLetters[c]</code> exceeds <code>freq[c]</code> (see the <code>isValidWord</code> method). Once a recursive call terminates, we can roll back any changes made by the current recursive call to extensively search for all possibilities.</p>
<p>This approach is called backtracking, which is a search strategy that visits states and rolls back changes to return to a previous state. Doing so allows you to explore all branches from one state. For more details, see our <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">backtracking explore card</a>.</p>
<p>The base case is when all words have been considered for the subset, which is handled by comparing <code>maxScore</code> with <code>totalScore</code> and updating <code>maxScore</code> if <code>totalScore</code> is larger. The recursive case considers two choices: adding the <span class="math inline">\(i^{\texttt{th}}\)</span> word or not adding the <span class="math inline">\(i^{\texttt{th}}\)</span> word. This generates the subsets that will eventually either reach the base case or get pruned because that subset is not valid.</p>
<p>One notable merit of this backtracking solution lies in the pruning of bad subsets. If there is a set of subsets that share the same words that break the limits imposed by the given letters, the recursive algorithm can choose not to continue the search down this branch. For example, if the first word cannot be constructed, this recursive algorithm would immediately cut out any subset containing the first word, whereas an iterative solution would still check every subset that contains the first word.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Generate a frequency array where <code>freq[c]</code> is the number of times letter <code>c</code> appears in <code>letters</code>.</li>
<li>Initialize <code>maxScore</code> to store the largest score among valid subsets.</li>
<li>Call a recursive subroutine <code>check</code> that passes <code>w</code> (the index of the current word), <code>words</code>, <code>score</code>, <code>subsetLetters</code>, and <code>totalScore</code> (the sum of word scores in the subset) as parameters. Steps 4-10 describe the <code>check</code> method.</li>
<li>If <code>w</code> equals <span class="math inline">\(-1\)</span>, all words have been considered, and we should update <code>maxScore</code> to <code>totalScore</code> if <code>maxScore</code> is less than <code>totalScore</code>.</li>
<li>Otherwise, we need to consider two possible recursive calls: one that adds <code>words[w]</code> to the subset, and one that doesn't.</li>
<li>To account for not adding a word, call <code>check(w - 1, words, score, subsetLetters, totalScore)</code>.</li>
<li>To add <code>words[w]</code> to the subset, update <code>subsetLetters</code> and <code>totalScore</code> to include the word.</li>
<li>If the addition of <code>words[w]</code> does not violate letter limits imposed by <code>freq</code>, make the recursive call <code>check(w - 1, words, score, subsetLetters, totalScore)</code>. To check for validity, we define the <code>isValidWord</code> method as follows:
<ul>
<li>For each character in the alphabet, check if <code>freq[c] &lt; subsetLetters[c]</code>. If there exists such <code>c</code>, return <code>false</code>.</li>
<li>Return <code>true</code> if the subset can be built out of the given letters.</li>
</ul>
</li>
<li>Roll back the changes to <code>subsetLetters</code> and <code>totalScore</code> immediately after making this recursive call.</li>
<li>Call <code>check(W - 1, words, score, subsetLetters, 0)</code>, where <code>subsetLetters</code> is initially all zeros.</li>
<li>Return <code>maxScore</code> as the result.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nZ2w8A7G/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(W\)</span> be the length of <code>words</code>, <span class="math inline">\(L\)</span> be the maximum length of any word in <code>words</code>, and <span class="math inline">\(A\)</span> be the size of the alphabet (in this case, <span class="math inline">\(A = 26\)</span>).</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(2^W \cdot (L + A))\)</span>.</li>
</ul>
<p>There are a total of <span class="math inline">\(2^W\)</span> subsets that could be checked, and the <code>check</code> function could be called for each one, or up to <span class="math inline">\(2^W\)</span> times. Inside the <code>check</code> function, we iterate through the current word's letters to determine if the subset it currently belongs in is valid, which takes <span class="math inline">\(L\)</span> time. Additionally, the <code>isValidWord</code> function takes <span class="math inline">\(A\)</span> time because we compare the count of each letter in the alphabet with the frequency. This yields a complexity of <span class="math inline">\(O(2^W(L + A)\)</span>.</p>
<p>While the worst-case runtime of backtracking matches the worst-case runtime of the iterative solution, in practice, the backtracking solution will prune many subset possibilities that break the limits imposed by the given letters and will run significantly faster than the iterative solution.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(A + W)\)</span>.</li>
</ul>
<p>In this implementation, only two arrays of length <span class="math inline">\(A\)</span> are created: the <code>freq</code> array that stores the frequencies of characters in <code>letters</code>, and the <code>subsetLetters</code> array that stores letter frequencies for the current subset. Additionally, the <code>check</code> method is called with and without each element in <code>words</code>, which incurs <span class="math inline">\(O(W)\)</span> space on the recursive call stack.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-split-of-positive-even-integers/description" target="_blank" rel="noopener noreferrer">Maximum Split of Positive Even Integers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>finalSum</code>. Split it into a sum of a <strong>maximum</strong> number of <strong>unique</strong> positive even integers.</p>

<ul>
	<li>For example, given <code>finalSum = 12</code>, the following splits are <strong>valid</strong> (unique positive even integers summing up to <code>finalSum</code>): <code>(12)</code>, <code>(2 + 10)</code>, <code>(2 + 4 + 6)</code>, and <code>(4 + 8)</code>. Among them, <code>(2 + 4 + 6)</code> contains the maximum number of integers. Note that <code>finalSum</code> cannot be split into <code>(2 + 2 + 4 + 4)</code> as all the numbers should be unique.</li>
</ul>

<p>Return <em>a list of integers that represent a valid split containing a <strong>maximum</strong> number of integers</em>. If no valid split exists for <code>finalSum</code>, return <em>an <strong>empty</strong> list</em>. You may return the integers in <strong>any</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> finalSum = 12
<strong>Output:</strong> [2,4,6]
<strong>Explanation:</strong> The following are valid splits: <code>(12)</code>, <code>(2 + 10)</code>, <code>(2 + 4 + 6)</code>, and <code>(4 + 8)</code>.
(2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6].
Note that [2,6,4], [6,2,4], etc. are also accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> finalSum = 7
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no valid splits for the given finalSum.
Thus, we return an empty array.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> finalSum = 28
<strong>Output:</strong> [6,8,2,12]
<strong>Explanation:</strong> The following are valid splits: <code>(2 + 26)</code>, <code>(6 + 8 + 2 + 12)</code>, and <code>(4 + 24)</code>. 
<code>(6 + 8 + 2 + 12)</code> has the maximum number of integers, which is 4. Thus, we return [6,8,2,12].
Note that [10,2,4,12], [6,2,4,16], etc. are also accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= finalSum &lt;= 10<sup>10</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strength-of-a-group/description" target="_blank" rel="noopener noreferrer">Maximum Strength of a Group</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the score of students in an exam. The teacher would like to form one <strong>non-empty</strong> group of students with maximal <strong>strength</strong>, where the strength of a group of students of indices <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code> is defined as <code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>â€‹]</code>.</p>

<p>Return <em>the maximum strength of a group the teacher can create</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,-1,-5,2,5,-9]
<strong>Output:</strong> 1350
<strong>Explanation:</strong> One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-4,-5,-4]
<strong>Output:</strong> 20
<strong>Explanation:</strong> Group the students at indices [0, 1] . Then, we&rsquo;ll have a resulting strength of 20. We cannot achieve greater strength.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 13</code></li>
	<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1" target="_blank" rel="noopener noreferrer">M-Coloring Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an undirected graph consisting of&nbsp;<strong>V</strong>&nbsp;vertices and&nbsp;<strong>E</strong>&nbsp;edges represented by a list&nbsp;<strong>edges[][]</strong>, along with an integer&nbsp;<strong><code>m</code></strong>. Your task is to determine whether it is possible to&nbsp;<strong>color the graph</strong>&nbsp;using at most&nbsp;<strong><code>m</code></strong>&nbsp;different colors such that no two adjacent vertices share the&nbsp;<strong>same color</strong>. Return&nbsp;<code>true</code>&nbsp;if the graph can be colored with at most&nbsp;<strong><code>m</code></strong>&nbsp;colors, otherwise return&nbsp;<code>false</code>.<br /></span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;The graph is indexed with 0-based indexing.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>V = 4, edges[][] = [[0, 1], [1, 3], [2, 3], [3, 0], [0, 2]], m = 3
<strong>Output: </strong>true<strong>
Explanation: </strong>It is possible to color the given graph using 3 colors, for example, one of the possible ways vertices can be colored as follows:<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/893404/Web/Other/blobid3_1746162701.jpg" width="260" height="230" /><br />Vertex 0: Color 1
Vertex 1: Color 2
Vertex 2: Color 2
Vertex 3: Color 3
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>V = 3, edges[][] = [[0, 1], [1, 2], [0, 2]], m = 2
<strong>Output: </strong>false<br /><strong>Explanation: </strong>It is not possible to color the given graph using only 2 colors because vertices 0, 1, and 2 form a triangle.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; V &le; 10<br />1 &le; E = edges.size() &le; (V*(V-1))/2<br />0 &le; edges[i][j] &le; V-1<br />1 &le; m &le; V</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/description" target="_blank" rel="noopener noreferrer">Minimum Number of Work Sessions to Finish the Tasks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> tasks assigned to you. The task times are represented as an integer array <code>tasks</code> of length <code>n</code>, where the <code>i<sup>th</sup></code> task takes <code>tasks[i]</code> hours to finish. A <strong>work session</strong> is when you work for <strong>at most</strong> <code>sessionTime</code> consecutive hours and then take a break.</p>

<p>You should finish the given tasks in a way that satisfies the following conditions:</p>

<ul>
	<li>If you start a task in a work session, you must complete it in the <strong>same</strong> work session.</li>
	<li>You can start a new task <strong>immediately</strong> after finishing the previous one.</li>
	<li>You may complete the tasks in <strong>any order</strong>.</li>
</ul>

<p>Given <code>tasks</code> and <code>sessionTime</code>, return <em>the <strong>minimum</strong> number of <strong>work sessions</strong> needed to finish all the tasks following the conditions above.</em></p>

<p>The tests are generated such that <code>sessionTime</code> is <strong>greater</strong> than or <strong>equal</strong> to the <strong>maximum</strong> element in <code>tasks[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [1,2,3], sessionTime = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can finish the tasks in two work sessions.
- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.
- Second work session: finish the third task in 3 hours.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [3,1,3,1,1], sessionTime = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can finish the tasks in two work sessions.
- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.
- Second work session: finish the last task in 1 hour.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tasks = [1,2,3,4,5], sessionTime = 15
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can finish all the tasks in one work session.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == tasks.length</code></li>
	<li><code>1 &lt;= n &lt;= 14</code></li>
	<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>
	<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-break-locks-i/description" target="_blank" rel="noopener noreferrer">Minimum Time to Break Locks I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">depth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Bob is stuck in a dungeon and must break <code>n</code> locks, each requiring some amount of <strong>energy</strong> to break. The required energy for each lock is stored in an array called <code>strength</code> where <code>strength[i]</code> indicates the energy needed to break the <code>i<sup>th</sup></code> lock.</p>

<p>To break a lock, Bob uses a sword with the following characteristics:</p>

<ul>
	<li>The initial energy of the sword is 0.</li>
	<li>The initial factor <code><font face="monospace">x</font></code> by which the energy of the sword increases is 1.</li>
	<li>Every minute, the energy of the sword increases by the current factor <code>x</code>.</li>
	<li>To break the <code>i<sup>th</sup></code> lock, the energy of the sword must reach <strong>at least</strong> <code>strength[i]</code>.</li>
	<li>After breaking a lock, the energy of the sword resets to 0, and the factor <code>x</code> increases by a given value <code>k</code>.</li>
</ul>

<p>Your task is to determine the <strong>minimum</strong> time in minutes required for Bob to break all <code>n</code> locks and escape the dungeon.</p>

<p>Return the <strong>minimum </strong>time required for Bob to break all <code>n</code> locks.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">strength = [3,4,1], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Time</th>
			<th style="border: 1px solid black;">Energy</th>
			<th style="border: 1px solid black;">x</th>
			<th style="border: 1px solid black;">Action</th>
			<th style="border: 1px solid black;">Updated x</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Break 3<sup>rd</sup> Lock</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">Break 2<sup>nd</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Break 1<sup>st</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
	</tbody>
</table>

<p>The locks cannot be broken in less than 4 minutes; thus, the answer is 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">strength = [2,5,4], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;">Time</th>
			<th style="border: 1px solid black;">Energy</th>
			<th style="border: 1px solid black;">x</th>
			<th style="border: 1px solid black;">Action</th>
			<th style="border: 1px solid black;">Updated x</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">1</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">Break 1<sup>st</sup> Lock</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Nothing</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">4</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">Break 2<sup>n</sup><sup>d</sup> Lock</td>
			<td style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">5</td>
			<td style="border: 1px solid black;">Break 3<sup>r</sup><sup>d</sup> Lock</td>
			<td style="border: 1px solid black;">7</td>
		</tr>
	</tbody>
</table>

<p>The locks cannot be broken in less than 5 minutes; thus, the answer is 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == strength.length</code></li>
	<li><code>1 &lt;= n &lt;= 8</code></li>
	<li><code>1 &lt;= K &lt;= 10</code></li>
	<li><code>1 &lt;= strength[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/jumpingjack-488ce744/" target="_blank" rel="noopener noreferrer">Movement in arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">hard</span> <span class="topic-badge">implementation</span> <span class="topic-badge">recruit</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Consider an array <strong><em>A</em></strong> of size <strong><em>N</em></strong>. You start from the index 0 and your goal is to reach index <strong><span class="mathjax-latex">\(N-1\)</span></strong> in exactly <strong><em>M</em></strong> moves. </p>
<p>At any index, you can move forward or backward by a number of steps that is equal to a prime divisor of the value which exists at that index. You cannot go beyond the array while going forward or backward.</p>
<p>Write a program to determine whether it is possible to reach index <strong><span class="mathjax-latex">\(N-1\)</span></strong> in <strong><em>M</em></strong> moves.</p>
<p><strong>Input format</strong></p>
<ul>
<li>First line: <strong><em>T</em></strong> (number of test cases)</li>
<li>First line in each test case: <strong><em>N</em></strong></li>
<li>Second line in each test case: <strong><em>N</em></strong> space-separated integers (denoting the array <strong><em>A</em></strong>)</li>
<li>Third line in each test case: <strong><em>M</em></strong> </li>
</ul>
<p><strong>Output format</strong><br /></p>
<p>For each test case, print <strong>YES</strong> or <strong>NO</strong> depending upon the result.</p>
<p><strong>Constraints</strong><br /></p>
<p><span class="mathjax-latex">\(1 \le T \le 10\)</span><br /><span class="mathjax-latex">\(2 \le N \le 40\)</span><br /><span class="mathjax-latex">\(1 \le A[i] \le 10^6\)</span><br /><span class="mathjax-latex">\(1 \le M \le 10^6\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In testcase 1 you can directly jump from position 0 to position 2.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/nearby-squares-338a4a64/" target="_blank" rel="noopener noreferrer">Nearby Squares</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <span class="mathjax-latex">\(A\)</span> of length <span class="mathjax-latex">\(N\)</span>. There are two empty arrays, <span class="mathjax-latex">\(B\)</span> and <span class="mathjax-latex">\(C\)</span>. You have to put every element of <span class="mathjax-latex">\(A\)</span> into either <span class="mathjax-latex">\(B\)</span> or <span class="mathjax-latex">\(C\)</span>.</p>

<p>The score of an array is defined as the square of the sum of all of its elements. Find the minimum possible absolute difference between the score of <span class="mathjax-latex">\(B\)</span> and <span class="mathjax-latex">\(C\)</span>.</p>

<p><u><strong>Input Format:</strong></u></p>

<ul>
	<li>The first line of input contains a single integer <span class="mathjax-latex">\(T\)</span>, denoting the number of test cases.</li>
	<li>The first line of each test case contains a single integer <span class="mathjax-latex">\(N\)</span>, denoting the length of the array <span class="mathjax-latex">\(A\)</span>.</li>
	<li>The second line of each test case contains <span class="mathjax-latex">\(N\)</span> integers, denoting the elements of array <span class="mathjax-latex">\(A\)</span>.</li>
</ul>

<p><u><strong>Output Format:</strong></u></p>

<p>For each test case, print the minimum possible absolute difference between the score of <span class="mathjax-latex">\(B\)</span> and the score of <span class="mathjax-latex">\(C\)</span>.</p>

<p><u><strong>Constraints:</strong></u></p>

<p><span class="mathjax-latex">\(1 &lt;= T &lt;= 10\)</span></p>

<p><span class="mathjax-latex">\(1 &lt;= N &lt;= 20\)</span></p>

<p><span class="mathjax-latex">\(1 &lt;= A[i] &lt;= 10^8\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p><strong>First test case:</strong><br>
We can put the third element in <span class="mathjax-latex">\(B\)</span> and the other elements in <span class="mathjax-latex">\(C\)</span>.<br>
The score of <span class="mathjax-latex">\(B\)</span> is <span class="mathjax-latex">\(10 ^ 2 = 100\)</span>.<br>
The score of <span class="mathjax-latex">\(C\)</span> is <span class="mathjax-latex">\(( 4 + 5 + 3 ) ^ 2 = 144\)</span>.<br>
Their absolute difference is <span class="mathjax-latex">\(| 100 - 144 | = 44\)</span>.<br>
It can be shown that this is the minimum possible absolute difference. Thus, the answer is <span class="mathjax-latex">\(44\)</span>.</p>

<p><strong>Second test case:</strong><br>
We can put the first three elements in <span class="mathjax-latex">\(B\)</span> and the last two elements in <span class="mathjax-latex">\(C\)</span>.<br>
The score of <span class="mathjax-latex">\(B\)</span> is <span class="mathjax-latex">\(( 1 + 3 + 5 ) ^ 2 = 81\)</span>.<br>
The score of <span class="mathjax-latex">\(C\)</span> is <span class="mathjax-latex">\(( 4 + 5 ) ^ 2 = 81\)</span>.<br>
Their absolute difference is <span class="mathjax-latex">\(| 81 - 81 | = 0\)</span>. Thus, the answer is <span class="mathjax-latex">\(0\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-numerically-balanced-number/description" target="_blank" rel="noopener noreferrer">Next Greater Numerically Balanced Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An integer <code>x</code> is <strong>numerically balanced</strong> if for every digit <code>d</code> in the number <code>x</code>, there are <strong>exactly</strong> <code>d</code> occurrences of that digit in <code>x</code>.</p>

<p>Given an integer <code>n</code>, return <em>the <strong>smallest numerically balanced</strong> number <strong>strictly greater</strong> than </em><code>n</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 22
<strong>Explanation:</strong> 
22 is numerically balanced since:
- The digit 2 occurs 2 times. 
It is also the smallest numerically balanced number strictly greater than 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1000
<strong>Output:</strong> 1333
<strong>Explanation:</strong> 
1333 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times. 
It is also the smallest numerically balanced number strictly greater than 1000.
Note that 1022 cannot be the answer because 0 appeared more than 0 times.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3000
<strong>Output:</strong> 3133
<strong>Explanation:</strong> 
3133 is numerically balanced since:
- The digit 1 occurs 1 time.
- The digit 3 occurs 3 times.
It is also the smallest numerically balanced number strictly greater than 3000.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-special-palindrome-number/description" target="_blank" rel="noopener noreferrer">Next Special Palindrome Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>.</p>

<p>A number is called <strong>special</strong> if:</p>

<ul>
	<li>It is a <strong><span data-keyword="palindrome-integer">palindrome</span></strong>.</li>
	<li>Every digit <code>k</code> in the number appears <strong>exactly</strong> <code>k</code> times.</li>
</ul>

<p>Return the <strong>smallest</strong> special number <strong>strictly </strong>greater than <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">22</span></p>

<p><strong>Explanation:</strong></p>

<p>22 is the smallest special number greater than 2, as it is a palindrome and the digit 2 appears exactly 2 times.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 33</span></p>

<p><strong>Output:</strong> <span class="example-io">212</span></p>

<p><strong>Explanation:</strong></p>

<p>212 is the smallest special number greater than 33, as it is a palindrome and the digits 1 and 2 appear exactly 1 and 2 times respectively.<br />
 </p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 10<sup>15</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/non-decreasing-subsequences/description" target="_blank" rel="noopener noreferrer">Non-decreasing Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>all the different possible non-decreasing subsequences of the given array with at least two elements</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,6,7,7]
<strong>Output:</strong> [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,4,3,2,1]
<strong>Output:</strong> [[4,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 15</code></li>
	<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/n-queen-problem0315/1" target="_blank" rel="noopener noreferrer">N-Queen Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">The <strong>n</strong>-queens puzzle is the problem of placing n queens on a&nbsp;(<strong>n &times; n)</strong> chessboard such that no two queens can attack each other. Note that two queens attack each other if they are placed on the same row, the same column, or the same diagonal.</span></p>
<p><span style="font-size: 18px;">Given an integer <strong>n</strong>, find all distinct solutions to the <strong>n-queens puzzle</strong>. <br />You can return your answer in&nbsp;<strong>any&nbsp;</strong>order but e</span><span style="font-size: 18px;"><span style="font-size: 18px;">ach solution should represent a distinct board configuration of the queen placements, where the solutions are represented as permutations of [1, 2, 3, ..., n]. In this representation, the number in the <strong>ith </strong>position denotes the row in which the queen is placed in the <strong>ith </strong>column. <br /></span></span><span style="font-size: 18px;"><span style="font-size: 18px;">For eg. below figure represents a chessboard </span><strong style="font-size: 18px;">[3 1 4 2]</strong><span style="font-size: 18px;">.<br /></span></span><span style="font-size: 18px;"><br /><span style="font-size: 18px; height: 201px; width: 231px;"><img style="height: 201px; width: 231px;" src="https://contribute.geeksforgeeks.org/wp-content/uploads/ratinmaze_filled11-1.png" alt="" /></span></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 1
<strong>Output: </strong>[1]
<strong>Explaination: </strong>Only one queen can be placed in the single cell available.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n =<strong> </strong>4
<strong>Output: </strong>[[2 4 1 3 ] [3 1 4 2 ]]
<strong>Explaination: </strong>There are 2 possible solutions for n = 4.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n =<strong> </strong>2
<strong>Output: </strong>[]
<strong>Explaination: </strong>There are no possible solutions for n = 2.</span></pre>
<p><strong style="font-size: 18px;">Constraints:<br /></strong><span style="font-size: 18px;">1 &le; n &le; 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-queens/description" target="_blank" rel="noopener noreferrer">N-Queens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>

<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>

<p>Each solution contains a distinct board configuration of the n-queens&#39; placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;" />
<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]
<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [[&quot;Q&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/n-queensrecursion-tutorial/" target="_blank" rel="noopener noreferrer">N-Queens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">easy</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a chess board having <span class="mathjax-latex">\(N \times N\)</span> cells, you need to place <em>N</em> queens on the board in such a way that no queen attacks any other queen. </p>
<p><strong>Input:</strong><br />
The only line of input consists of a single integer denoting <em>N</em>.</p>
<p><strong>Output:</strong><br />
If it is possible to place all the <em>N</em> queens in such a way that no queen attacks another queen, then print <em>N</em> lines having <em>N</em> integers. The integer in <span class="mathjax-latex">\(i^{th}\)</span> line and <span class="mathjax-latex">\(j^{th}\)</span> column will denote the cell <span class="mathjax-latex">\((i,j)\)</span> of the board and should be <em>1</em> if a queen is placed at <span class="mathjax-latex">\((i,j)\)</span> otherwise <em>0</em>. If there are more than way of placing queens print any of them. If it is not possible to place all <em>N</em> queens in the desired way, then print "Not possible" (without quotes).</p>
<p><strong>Constraints:</strong><br />
<span class="mathjax-latex">\(1 \le N \le 10\)</span>.</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-queens-ii/description" target="_blank" rel="noopener noreferrer">N-Queens II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>

<p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the&nbsp;<strong>n-queens puzzle</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;" />
<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/k-excess-1-be669e5a/" target="_blank" rel="noopener noreferrer">Number of divisors</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">numbertheory</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two numbers <strong>n</strong> and <strong>k</strong>. For each number in the interval <strong>[1, n]</strong>, your task is to calculate its largest divisor&nbsp;that is not divisible by <strong>k</strong>. Print the sum of these divisors.</p>

<p>Note: <strong>k</strong> is a prime number.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains an integer T representing the number of test cases that will follow.</li>
	<li>Each test case consists of one line containing two integers n and k.</li>
</ul>

<p><strong>Output format</strong></p>

<p>The output must contain the answer for each test case on a different line.</p>

<p>Each answer consists of a single integer.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(T \le 300000\\ 1 \le n \le 1000000000\\ 2 \le k \le 1000000000\)</span><br />
&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>In the first test case, f (x) from 1 to 10 is [1, 2, 1, 4, 5, 2, 7, 8, 1, 10], sum of which is 41.</p>

<p>In the secondÂ test case, f (x) from 1 to 10Â is [1, 1, 3, 1, 5, 3, 7, 1, 9, 5].</p>

<p>In the thirdÂ test case, f (x) from 1 to 10 is [1, 2, 3, 4, 1, 6, 7, 8, 9, 2].</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-paths-in-a-matrix-with-k-coins2728/1" target="_blank" rel="noopener noreferrer">Number of paths in a matrix with k coins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>n x n</strong>&nbsp;matrix such that&nbsp;each of its&nbsp;cells contains some&nbsp;coins. Count the number of ways to collect <strong>exactly k coins</strong> while moving from&nbsp;top left corner of the matrix&nbsp;to the&nbsp;bottom right. From a cell (<strong>i</strong>, <strong>j</strong>), you can only move to (<strong>i+1</strong>, <strong>j</strong>) or (<strong>i</strong>, <strong>j+1</strong>).</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>:
k = 12, n = 3
arr[] = [[1, 2, 3], 
&nbsp;      [4, 6, 5], 
&nbsp;      [3, 2, 1]]
<strong>Output:</strong>&nbsp;<br />2
<strong>Explanation</strong>: 
There are 2 possible paths with exactly 12 coins, (1 + 2 + 6 + 2 + 1) and (1 + 2 + 3 + 5 + 1).
</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
k = 16, n = 3
arr[] = [[1, 2, 3],&nbsp;
&nbsp;      [4, 6, 5],&nbsp;
&nbsp;      [9, 8, 7]]
<strong>Output: <br /></strong>0 
<strong>Explanation: </strong>
There are no possible paths that lead to sum=16
</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>numberOfPath()</strong> which takes integers <strong>n</strong>, <strong>k</strong> and a 2D matrix <strong>arr</strong>[][] as input parameters and returns an integer denoting the number of possible paths.</span><br /><br /><span style="font-size: 14pt;"><strong>Expected Time Complexity:</strong> O(n*n*k)<br /><strong>Expected Auxiliary Space:</strong> O(n*n*k)</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong></span><span style="font-size: 14pt;">1 &lt;= k &lt; 100<br />1 &lt;= n &lt; 100<br />0 &lt;= arr<sub>ij</sub> &lt;= 200</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-squareful-arrays/description" target="_blank" rel="noopener noreferrer">Number of Squareful Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An array is <strong>squareful</strong> if the sum of every pair of adjacent elements is a <strong>perfect square</strong>.</p>

<p>Given an integer array nums, return <em>the number of permutations of </em><code>nums</code><em> that are <strong>squareful</strong></em>.</p>

<p>Two permutations <code>perm1</code> and <code>perm2</code> are different if there is some index <code>i</code> such that <code>perm1[i] != perm2[i]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,17,8]
<strong>Output:</strong> 2
<strong>Explanation:</strong> [1,8,17] and [17,8,1] are the valid permutations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 12</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/description" target="_blank" rel="noopener noreferrer">Number of Valid Move Combinations On Chessboard</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">simulation</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <code>8 x 8</code> chessboard containing <code>n</code> pieces (rooks, queens, or bishops). You are given a string array <code>pieces</code> of length <code>n</code>, where <code>pieces[i]</code> describes the type (rook, queen, or bishop) of the <code>i<sup>th</sup></code> piece. In addition, you are given a 2D integer array <code>positions</code> also of length <code>n</code>, where <code>positions[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> piece is currently at the <strong>1-based</strong> coordinate <code>(r<sub>i</sub>, c<sub>i</sub>)</code> on the chessboard.</p>

<p>When making a <strong>move</strong> for a piece, you choose a <strong>destination</strong> square that the piece will travel toward and stop on.</p>

<ul>
	<li>A rook can only travel <strong>horizontally or vertically</strong> from <code>(r, c)</code> to the direction of <code>(r+1, c)</code>, <code>(r-1, c)</code>, <code>(r, c+1)</code>, or <code>(r, c-1)</code>.</li>
	<li>A queen can only travel <strong>horizontally, vertically, or diagonally</strong> from <code>(r, c)</code> to the direction of <code>(r+1, c)</code>, <code>(r-1, c)</code>, <code>(r, c+1)</code>, <code>(r, c-1)</code>, <code>(r+1, c+1)</code>, <code>(r+1, c-1)</code>, <code>(r-1, c+1)</code>, <code>(r-1, c-1)</code>.</li>
	<li>A bishop can only travel <strong>diagonally</strong> from <code>(r, c)</code> to the direction of <code>(r+1, c+1)</code>, <code>(r+1, c-1)</code>, <code>(r-1, c+1)</code>, <code>(r-1, c-1)</code>.</li>
</ul>

<p>You must make a <strong>move</strong> for every piece on the board simultaneously. A <strong>move combination</strong> consists of all the <strong>moves</strong> performed on all the given pieces. Every second, each piece will instantaneously travel <strong>one square</strong> towards their destination if they are not already at it. All pieces start traveling at the <code>0<sup>th</sup></code> second. A move combination is <strong>invalid</strong> if, at a given time, <strong>two or more</strong> pieces occupy the same square.</p>

<p>Return <em>the number of <strong>valid</strong> move combinations</em>â€‹â€‹â€‹â€‹â€‹.</p>

<p><strong>Notes:</strong></p>

<ul>
	<li><strong>No two pieces</strong> will start in the<strong> same</strong> square.</li>
	<li>You may choose the square a piece is already on as its <strong>destination</strong>.</li>
	<li>If two pieces are <strong>directly adjacent</strong> to each other, it is valid for them to <strong>move past each other</strong> and swap positions in one second.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a1.png" style="width: 215px; height: 215px;" />
<pre>
<strong>Input:</strong> pieces = [&quot;rook&quot;], positions = [[1,1]]
<strong>Output:</strong> 15
<strong>Explanation:</strong> The image above shows the possible squares the piece can move to.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a2.png" style="width: 215px; height: 215px;" />
<pre>
<strong>Input:</strong> pieces = [&quot;queen&quot;], positions = [[1,1]]
<strong>Output:</strong> 22
<strong>Explanation:</strong> The image above shows the possible squares the piece can move to.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a3.png" style="width: 214px; height: 215px;" />
<pre>
<strong>Input:</strong> pieces = [&quot;bishop&quot;], positions = [[4,3]]
<strong>Output:</strong> 12
<strong>Explanation:</strong> The image above shows the possible squares the piece can move to.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == pieces.length </code></li>
	<li><code>n == positions.length</code></li>
	<li><code>1 &lt;= n &lt;= 4</code></li>
	<li><code>pieces</code> only contains the strings <code>&quot;rook&quot;</code>, <code>&quot;queen&quot;</code>, and <code>&quot;bishop&quot;</code>.</li>
	<li>There will be at most one queen on the chessboard.</li>
	<li><code>1 &lt;= r<sub>i</sub>, c<sub>i</sub> &lt;= 8</code></li>
	<li>Each <code>positions[i]</code> is distinct.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/numbers-with-same-consecutive-differences/description" target="_blank" rel="noopener noreferrer">Numbers With Same Consecutive Differences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integers n and k, return <em>an array of all the integers of length </em><code>n</code><em> where the difference between every two consecutive digits is </em><code>k</code>. You may return the answer in <strong>any order</strong>.</p>

<p>Note that the integers should not have leading zeros. Integers as <code>02</code> and <code>043</code> are not allowed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 7
<strong>Output:</strong> [181,292,707,818,929]
<strong>Explanation:</strong> Note that 070 is not a valid number, because it has leading zeroes.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, k = 1
<strong>Output:</strong> [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 9</code></li>
	<li><code>0 &lt;= k &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem asks us to come up a list of digit combinations that follow the defined pattern.<br />
Before jumping to the implementation, it is always helpful to <em>manually</em> deduce some examples.</p>
<p>Suppose that we have <code>N=3</code> and <code>K=2</code>, <em>i.e.</em> we should come up a series of 3-digits numbers, where for each number the difference between each adjacent digits is 2.</p>
<p>Let us try to build the number <em><strong>digit by digit</strong></em>. Starting from the highest digit (in the image), we can pick the digit <code>1</code>.<br />
Then for the next digit, we need to pick <code>3</code> (<em>i.e.</em> <span class="math inline">\(1+2\)</span>).<br />
Finally, for the last digit, we could have two choices: <code>5</code> and <code>1</code> (<em>i.e.</em> <span class="math inline">\(3+2, 3-2\)</span>).<br />
We illustrate the process in the following graph, where each <strong><em>node</em></strong> represents a digit that we pick, and the <strong><em>level</em></strong> of the node corresponds to the position that the digit situates in the final number.</p>
<p><img src="../Figures/967/967_tree_illustration.png" alt="tree illustration" /></p>
<blockquote>
<p>As one might notice that, we just converted the problem into a tree traversal problem, where each path from the root to a leaf forms a solution for the problem.</p>
</blockquote>
<p>As we know, the common algorithms for the tree traversal problem would be <em><strong>DFS</strong></em> (Depth-First Search) and <em><strong>BFS</strong></em> (Breadth-First Search), which are exactly what we will present in the following sections.</p>
<hr />
<h3 id="approach-1-dfs-depth-first-search">Approach 1: DFS (Depth-First Search)</h3>
<p><strong>Intuition</strong></p>
<p>If one is not familiar with the concepts of DFS and BFS, we have an Explore card called <a href="https://leetcode.com/explore/learn/card/queue-stack/">Queue &amp; Stack</a> where we cover the <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">DFS traversal</a> as well as the <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">BFS traversal</a>.</p>
<p>In this section, we will start from the DFS strategy, which arguably is more intuitive for this problem.</p>
<p>As we stated in the overview section, we could build a valid digit combination <em>digit by digit</em> or (node by node in terms of tree).</p>
<p>For a number consisting of <code>N</code> digits, we start from the highest digit and walk through to the lowest digit.<br />
At each step, we might have several candidates that are eligible to be explored.</p>
<p>With the DFS strategy, we prioritize the <em>depth</em> over the <em>breadth</em>, <em>i.e.</em> we pick one of the candidates and continue the exploration before moving on to the other candidates that are of the same level.</p>
<p><strong>Algorithm</strong></p>
<p>Intuitively we could implement the DFS algorithm with recursion. Here we define a recursive function <code>DFS(N, num)</code> (in Python) whose goal is to come up the combinations for the remaining <code>N</code> digits, starting from the current <code>num</code>.<br />
Note that, the signature of the function is slightly different in our Java implementation. Yet, the semantics of the function remains the same.</p>
<p><img src="../Figures/967/967_dfs_example.png" alt="DFS example" /></p>
<p>For instance, in the previous examples, where <code>N=3</code> and <code>K=2</code>, and there is a moment we would invoke <code>DFS(1, 13)</code> which is to add another digit to the existing number <code>13</code> so that the final number meets the requirements.<br />
If the DFS function works properly, we should have the numbers of <code>135</code> and <code>131</code> as results after the invocation.</p>
<p>We could implement the recursive function in the following steps:</p>
<ul>
<li>
<p>As a base case, when <code>N=0</code> <em>i.e.</em> no more remaining digits to complete, we could return the current <code>num</code> as the result.</p>
</li>
<li>
<p>Otherwise, there are still some remaining digits to be added to the current number, <em>e.g.</em> <code>13</code>. There are two potential cases to explore, based on the last digit of the current number which we denote as <code>tail_digit</code>.</p>
<ul>
<li>
<p>Adding the difference <code>K</code> to the last digit, <em>i.e.</em> <code>tail_digit + K</code>.</p>
</li>
<li>
<p>Deducting the difference <code>K</code> from the last digit, <em>i.e.</em> <code>tail_digit - K</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the result of either above case falls into the valid digit range (<em>i.e.</em> <span class="math inline">\([0, 9]\)</span>), we then continue the exploration by invoking the function itself.</p>
</li>
</ul>
<p>Once we implement the <code>DFS(N, num)</code> function, we then simply call this function over the scope of <span class="math inline">\([1, 9]\)</span>, <em>i.e.</em> the valid digits for the highest position.</p>
<p><strong>Note</strong>: <em>If we are asked to return numbers of a single digit (<em>i.e.</em> <code>N=1</code>), then regardless of <code>K</code>, all digits are valid, including zero.</em><br />
We treat this as a special case in the code, since in our implementation of DFS function, we will never return zero as the result.</p>
<p><a href="https://leetcode.com/playground/o99eFuUT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of digits for a valid combination, and <span class="math inline">\(K\)</span> be the difference between digits.</p>
<p>First of all, let us estimate the number of potential solutions.<br />
For the highest digit, we could have 9 potential candidates.<br />
Starting from the second highest position, we could have at most 2 candidates for each position.<br />
Therefore, at most, we could have <span class="math inline">\(9 \cdot 2^{N-1}\)</span> solutions, for <span class="math inline">\(N > 1\)</span>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Essentially, the execution of the algorithm will unfolder itself as a binary tree, where each node in the tree represents an invocation of the <code>DFS()</code> function.<br />
The execution of the <code>DFS()</code> function itself takes a constant time.<br />
Therefore, the overall time complexity is proportional to the number of nodes in the execution binary tree.</p>
</li>
<li>
<p>In the worst case, the total number of nodes in a binary tree of depth <span class="math inline">\(N-1\)</span> is <span class="math inline">\(2^N\)</span>.<br />
Hence, the overall time complexity of the algorithm is <span class="math inline">\(\mathcal{O}(2^{N})\)</span>.</p>
</li>
<li>
<p>Note that, when <span class="math inline">\(K = 0\)</span>, at each position, there is only one possible candidate, <em>e.g.</em> <span class="math inline">\(333\)</span>.<br />
In total, we would have 9 numbers in the result set, and each number is of <span class="math inline">\(N\)</span> digits. The time complexity would then be reduced down to <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Since we adopt a recursive solution, we would have some additional memory consumption on the function call stack. The maximum number of consecutive calls on the recursion function is <span class="math inline">\(N\)</span>. Hence, the space complexity for the call stack is <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>We use a list to keep all the solutions, which could amount to <span class="math inline">\(9 \cdot 2^{N-1}\)</span> number of elements.</p>
</li>
<li>
<p>To sum up, the overall space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N) + \mathcal{O}(9 \cdot 2^{N-1}) = \mathcal{O}(2^{N})\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs-breadth-first-search">Approach 2: BFS (Breadth-First Search)</h3>
<p><strong>Intuition</strong></p>
<p>It might be more intuitive to come up a DFS solution as we presented before.<br />
However, it is also viable to solve this problem with <em>BFS</em> (Breadth-First Search) traversal strategy.</p>
<blockquote>
<p>Rather than building the solution one by one, we could do it <em>batch by batch</em>, <em>i.e.</em> level by level.</p>
</blockquote>
<p>Each level contains the numbers that are of the same amount of digits.<br />
Also, each level corresponds to the solutions with a specific number of digits.</p>
<p><img src="../Figures/967/967_BFS.png" alt="BFS" /></p>
<p>For example, given <code>N=3</code> and <code>K=7</code>, at the first level, we would have potentially 9 candidates (<em>i.e.</em> <code>[1, 2, 3, 4, 5, 7, 8, 9]</code>).<br />
When we move on to the second level, the candidates are reduced down to <code>[18, 29, 70, 81, 92]</code>.<br />
Finally, at the last level, we would have the solutions as <code>[181, 292, 707, 818, 929]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Here are a few steps to implement the BFS algorithm for this problem.</p>
<ul>
<li>
<p>We could implement the algorithm with nested two-levels loops, where the outer loop iterates through levels and the inner loop handles the elements within each level.</p>
</li>
<li>
<p>We could use a list data structure to keep the numbers for a single level, <em>i.e.</em> here we name the variable as <code>queue</code>.</p>
</li>
<li>
<p>For each number in the queue, we could apply the same logics as in the DFS approach, except the last step, rather than making a recursive call for the next number we simply append the number to the queue for the next level.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/5ajtXWDv/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of digits for a valid combination, and <span class="math inline">\(K\)</span> be the difference between digits.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>Essentially with the BFS approach, all the intermeidate candidates form a binary tree, same as the execution tree as in the DFS approach.<br />
Only this time, we traverse in a breadth-first manner, rather than the depth-first.</p>
</li>
<li>
<p>Therefore, the overall time complexity of the algorithm would be <span class="math inline">\(\mathcal{O}(2^{N})\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(2^{N})\)</span></p>
<ul>
<li>
<p>We use two queues to maintain the intermediate solutions, which contain no more than two levels of elements.<br />
The number of elements at the level of <span class="math inline">\(i\)</span> is up to <span class="math inline">\(9 \cdot 2^{i-1}\)</span>.</p>
</li>
<li>
<p>To sum up, the space complexity of the algorithm would be <span class="math inline">\(\mathcal{O}(9 \cdot 2^{N-1} + 9 \cdot 2^{N-2}) = \mathcal{O}(2^N)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-partitioning/description" target="_blank" rel="noopener noreferrer">Palindrome Partitioning</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword="substring-nonempty">substring</span> of the partition is a <span data-keyword="palindrome-string"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "aab"
<strong>Output:</strong> [["a","a","b"],["aa","b"]]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "a"
<strong>Output:</strong> [["a"]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 16</code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/partition-array-to-k-subsets/1" target="_blank" rel="noopener noreferrer">Partition array to k subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer array <strong>arr[ ]</strong>&nbsp;and an integer <strong>k</strong>, the task is to check if the array <strong>arr[ ]</strong>&nbsp;could be divided into <strong>k</strong> non-empty subsets with equal sum of elements.<br /><strong>Note:</strong>&nbsp;All elements of this array should be part of exactly one partition.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [2, 1, 4, 5, 6], k = 3
<strong>Output:</strong> true
<strong>Explanation:</strong> We can divide above array into 3 parts with equal sum as (2, 4), (1, 5), (6)</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: arr[] = [2, 1, 5, 5, 6], k = 3
<strong>Output:</strong> false
<strong>Explanation</strong>: It is not possible to divide above array into 3 parts with equal sum.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; k &le; arr.size() &le; 10<br />1 &le; arr[i] &le; 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-string-into-minimum-beautiful-substrings/description" target="_blank" rel="noopener noreferrer">Partition String Into Minimum Beautiful Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary string <code>s</code>, partition the string into one or more <strong>substrings</strong> such that each substring is <strong>beautiful</strong>.</p>

<p>A string is <strong>beautiful</strong> if:</p>

<ul>
	<li>It doesn&#39;t contain leading zeros.</li>
	<li>It&#39;s the <strong>binary</strong> representation of a number that is a power of <code>5</code>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of substrings in such partition. </em>If it is impossible to partition the string <code>s</code> into beautiful substrings,&nbsp;return <code>-1</code>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1011&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can paritition the given string into [&quot;101&quot;, &quot;1&quot;].
- The string &quot;101&quot; does not contain leading zeros and is the binary representation of integer 5<sup>1</sup> = 5.
- The string &quot;1&quot; does not contain leading zeros and is the binary representation of integer 5<sup>0</sup> = 1.
It can be shown that 2 is the minimum number of beautiful substrings that s can be partitioned into.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;111&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can paritition the given string into [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;].
- The string &quot;1&quot; does not contain leading zeros and is the binary representation of integer 5<sup>0</sup> = 1.
It can be shown that 3 is the minimum number of beautiful substrings that s can be partitioned into.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> We can not partition the given string into beautiful substrings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 15</code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-to-k-equal-sum-subsets/description" target="_blank" rel="noopener noreferrer">Partition to K Equal Sum Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-sum-ii/description" target="_blank" rel="noopener noreferrer">Path Sum II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>

<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" style="width: 500px; height: 356px;" />
<pre>
<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]
<strong>Explanation:</strong> There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" style="width: 212px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2], targetSum = 0
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-maximum-gold/description" target="_blank" rel="noopener noreferrer">Path with Maximum Gold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a gold mine <code>grid</code> of size <code>m x n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p>

<p>Return the maximum amount of gold you can collect under the conditions:</p>

<ul>
	<li>Every time you are located in a cell you will collect all the gold in that cell.</li>
	<li>From your position, you can walk one step to the left, right, up, or down.</li>
	<li>You can&#39;t visit the same cell more than once.</li>
	<li>Never visit a cell with <code>0</code> gold.</li>
	<li>You can start and stop collecting gold from <strong>any </strong>position in the grid that has some gold.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,6,0],[5,8,7],[0,9,0]]
<strong>Output:</strong> 24
<strong>Explanation:</strong>
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
<strong>Output:</strong> 28
<strong>Explanation:</strong>
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 15</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
	<li>There are at most <strong>25 </strong>cells containing gold.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-with-backtracking">Approach 1: Depth-First Search with Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to collect the maximum amount of gold possible from a given <code>grid</code>.</p>
<p>It's possible to traverse the <code>grid</code> and find the cells containing gold using nested loops, but this won't provide us with the path with the maximum gold. Instead, we will use depth-first search (DFS) to search for the best path.</p>
<p>We can begin searching for gold in any cell of the <code>grid</code> that has gold, so we perform a depth-first search for gold starting at each cell.</p>
<p>Let's consider our search function. If the starting cell contains gold, we should continue searching for gold in the adjacent cells. However, if the starting cell does not contain gold, we should halt the search since this path cannot lead to a valid solution.</p>
<p>What if a cell in the middle of the search process doesn't contain gold? We could restart the entire search process, or we could backtrack to the last cell on this path that contained gold and resume the search from there.</p>
<p>This idea is called backtracking. If a certain choice cannot lead to a valid solution, we can implement backtracking to abandon the current choice to return to the last valid choice and explore other possibilities.</p>
<blockquote>
<p>If you are not familiar with backtracking, we recommend you read our <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">Backtracking Explore Card</a>.</p>
</blockquote>
<p>We will define a recursive function, <code>dfsBacktrack</code>, that returns the path with the maximum gold for a given starting cell.</p>
<p>Our base case occurs when the current cell contains no gold or when the given coordinates are outside the matrix boundary. In either case, we return zero.</p>
<p>Next, let's discuss the recursive case. First, we collect the gold at the current cell by saving its original value and setting the cell to <code>0</code>.</p>
<p>Then, we explore the possible paths from this cell by calling <code>dfsBacktrack</code> recursively for each of the four adjacent cells and updating the maximum gold if we find a better path.</p>
<p>For a given cell with coordinates <code>(row, col)</code> the four neighbors are:</p>
<ul>
<li>Right Neighbor: <code>(row + 0, col + 1)</code></li>
<li>Below Neighbor: <code>(row + 1, col + 0)</code></li>
<li>Left Neighbor: <code>(row + 0, col - 1)</code></li>
<li>Above Neighbor: <code>(row - 1, col + 0)</code></li>
</ul>
<p>We can observe that we change the first neighbor's column by the same amount as the next neighbor's row. By extracting this pattern, we can store it in an array <code>DIRECTIONS = {0, 1, 0, -1, 0}</code>. For each neighbor cell <code>i</code>, the row will change by <code>DIRECTIONS[i]</code>, and the column will change by <code>DIRECTIONS[i + 1]</code>.</p>
<p>After the recursive calls, we reset the current cell to its original value. This allows us to backtrack and explore other potential paths from this cell.</p>
<p>We return the sum of the maximum gold obtained and the current cell's gold value, representing the total gold collected on the path up to this point.</p>
<p>Then, from the <code>getMaximumGold</code> function, we use nested loops to traverse the possible starting cells. For each cell, we call the <code>dfsBacktrack</code> function and update the maximum gold value each time we find a better path.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a constant array <code>DIRECTIONS</code> to <code>{0, 1, 0, -1, 0}</code>.</li>
<li>Initialize the variable <code>rows</code> to the number of rows in the grid and <code>cols</code> to the number of columns.</li>
<li>Initialize a variable <code>maxGold</code> for storing the amount of gold collected on any path so far to <code>0</code>.</li>
<li>Define a function <code>dfsBacktrack</code> that finds the path with the maximum gold using DFS and backtracking. The function takes parameters <code>grid</code>, <code>rows</code>, <code>cols</code>, <code>row</code>, and <code>col</code>, representing the coordinates of the current cell within the <code>grid</code>.
<ul>
<li>Base Case: We cannot collect gold in the cell <code>(row, col)</code>. If <code>grid[row][col]</code> equals <code>0</code>, or if the cell is outside the <code>grid</code>, return zero. We check whether the cell is outside the grid using the condition <code>row &lt; 0 or col &lt; 0 or row == rows or col == cols</code>.</li>
<li>Initialize a local variable <code>maxGold</code> to <code>0</code>.</li>
<li>Mark the current cell as visited and save the value. Initialize a variable <code>originalVal</code> to <code>grid[row][col]</code>, and set <code>grid[row][col]</code> to <code>0</code>.</li>
<li>Search each of the four adjacent cells. Call <code>dfsBacktrack</code> for the cells to the left, right, above, and below the current cell. Update the maximum gold if a better path is found.</li>
<li>Reset the current cell back to its original value so that when we backtrack, we can explore other possible paths from this cell.</li>
<li>Return the sum of <code>maxGold</code> and <code>originalVal</code>, which represents the gold collected on this path so far.</li>
</ul>
</li>
<li>Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, find the maximum gold that can be collected starting at that cell using the <code>dfsBacktrack</code> function and update <code>maxGold</code> whenever a better path is found.</li>
<li>Return <code>maxGold</code>.</li>
</ol>
<p>The <code>dfsBacktrack</code> function is visualized below for the input <code>grid = [[1,5,0],[7,2,4]]</code> and the start cell <code>(0, 0)</code>:</p>
<p>!?!../Documents/1219/1219_slideshow.json:700,395!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EScajpgt/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <code>grid</code>, <span class="math inline">\(m\)</span> be the number of columns, and <span class="math inline">\(g\)</span> be the number of gold cells.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
<p>We search for the path with maximum gold from each starting cell that contains gold using the backtrack function, which recursively calls itself. From the starting cell, we explore paths in <span class="math inline">\(4\)</span> directions, but for each additional cell in the path, we explore paths in <span class="math inline">\(3\)</span> directions because we already collected gold from the direction we came from. That means the backtrack function can be called up to <span class="math inline">\(3^g\)</span> times for a given starting cell, and it takes <span class="math inline">\(O(g \cdot 3^g)\)</span> to search for the maximum gold from all the gold cells.</p>
<p>In the <code>getMaximumGold</code> function, we iterate through each cell in the matrix, checking whether each has gold. We've already accounted for the gold cells, so this takes <span class="math inline">\(O(m \cdot n - g)\)</span> for the cells that do not contain gold.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(g)\)</span></p>
<p>Since the length of a path through gold cells can be <span class="math inline">\(g\)</span>, the recursive call stack can grow up to size <span class="math inline">\(g\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-with-backtracking">Approach 2: Breadth-First Search with Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When a problem can be solved with depth-first search, it can often also be solved with breadth-first search (BFS).</p>
<p>We will create a function, <code>bfsBacktrack</code>, that uses a breadth-first search to find the path with the maximum gold for a given starting cell.</p>
<p>We will use a queue to store the cells we need to search. Each entry in the queue contains the coordinates of the current cell, the gold found so far on the path, and a set storing the cells visited on this path so far.</p>
<p>When we pop the front cell from the queue, we store the amount of gold found on the path so far as <code>currGold</code>, and update the <code>maxGold</code> if the <code>currGold</code> is higher.</p>
<p>Then, if each of the four adjacent cells has gold, is inside the matrix, and has not yet been visited, we mark them as visited and add them to the queue with the updated gold collected. After adding the cell to the queue, we remove it from the visited set to explore other possible paths from this cell during backtracking.</p>
<p>To improve the efficiency of the solution, we calculate the total amount of gold in the matrix before searching. This way, if we discover a path that has the maximum possible total gold, we can halt the search process.</p>
<p>Similar to the above solution, we call <code>bfsBacktrack</code> for every starting cell in the matrix.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a constant array <code>DIRECTIONS</code> to <code>{0, 1, 0, -1, 0}</code>.</li>
<li>Initialize the variable <code>rows</code> to the number of rows in the grid and <code>cols</code> to the number of columns.</li>
<li>Calculate the total amount of gold in the <code>grid</code> using a running sum. Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, add the gold to <code>totalGold</code>.</li>
<li>Initialize a variable <code>maxGold</code> to store the amount of gold collected on the path with the maximum gold to <code>0</code>.</li>
<li>Define a function <code>bfsBacktrack</code> that searches for the path with the maximum gold using BFS and backtracking. The parameters are the <code>grid</code>, <code>rows</code>, <code>cols</code>, <code>row</code>, and <code>col</code>, representing the current cell coordinates in the <code>grid</code>.
<ul>
<li>Initialize a queue <code>queue</code> which stores the path and gold collected for a given cell.</li>
<li>Initialize a set <code>visited</code> for storing <code>(row, col)</code> pairs we have already visited.</li>
<li>Initialize a local variable <code>maxGold</code> to <code>0</code>.</li>
<li>Add the starting <code>(row, col)</code> pair to the visited set.</li>
<li>Add the starting cell's <code>row</code>, <code>col</code>, amount of gold, and visited set to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the front entry from the queue. Save the row as <code>currRow</code>, the column as <code>currCol</code>, the visited set as <code>currVis</code>, and the gold as <code>currGold</code>.</li>
<li>Update <code>maxGold</code> to <code>currGold</code> if <code>currGold</code> is larger.</li>
<li>Search each of the four adjacent cells. For the cells to the left, right, above, and below of the current cell:
<ul>
<li>Set <code>nextRow</code> to the neighbor cell's row coordinates and <code>nextCol</code> to the neighbor's column coordinates.</li>
<li>Add the neighbor cell to the queue if it contains gold, is in the matrix, and has not been visited:
<ul>
<li>Mark this cell as visited in <code>currVis</code>.</li>
<li>Add this cell's gold to <code>currGold</code> and add the cell to the queue with a copy of the <code>currVis</code> set.</li>
<li>Remove this cell from <code>currVis</code> so that when we backtrack, we can explore other possible paths.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxGold</code>.</li>
</ul>
</li>
<li>Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, find the maximum gold that can be collected at that cell using the <code>bfsBacktrack</code> function and update <code>maxGold</code> when a better path is found. If a path with the <code>totalGold</code> is found, return the <code>totalGold</code>.</li>
<li>Return <code>maxGold</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MG7g9pY8/shared">code</a></p>
<blockquote>
<p><strong>Note:</strong> The copy operations for <code>unordered_set</code> are inefficient and cause the C++ solution to result in &quot;time limit exceeded&quot;. Therefore, the C++ implementation uses a bitset for the <code>visited</code> and <code>currVis</code> sets. Each bit in the bitset represents a cell in the matrix, with <code>1</code> indicating the cell as visited and <code>0</code> as unvisited. Matrix coordinates are mapped to the bitset using the formula <code>nextRow * cols + nextCol</code>.</p>
</blockquote>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <code>grid</code>, <span class="math inline">\(m\)</span> be the number of columns, and <span class="math inline">\(g\)</span> be the number of gold cells.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
<p>We search for the path with the maximum gold starting from each gold cell. We search in three directions for each cell along the path because we have already collected the gold on the current path. This means we push up to <span class="math inline">\(3^g\)</span> entries to the queue. We stop the BFS when the queue is empty, so this process takes <span class="math inline">\(O(g \cdot 3^g)\)</span>.</p>
<p>In the <code>getMaximumGold</code> function, we check whether each cell contains gold. The gold cells have already been accounted for, so this takes <span class="math inline">\(m \cdot n -g\)</span> for the cells with no gold.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(g \cdot 3^g)\)</span> (Java and Python3) or <span class="math inline">\(O(3^g + m \cdot n)\)</span> (C++)</p>
<p>Java and Python3: A visited set of size <span class="math inline">\(g\)</span> is created for each entry in the queue. The queue can grow to size <span class="math inline">\(3^g\)</span>, so the <code>currVis</code> sets can use up to <span class="math inline">\(O(g \cdot 3^g)\)</span> space.</p>
<p>C++: The queue may use up to <span class="math inline">\(3^g\)</span> space. We initialize the visited bitset to size <code>1024</code> since the constraints limit <code>m</code> and <code>n</code> to <code>100</code>, ensuring the bitset is large enough to store all <code>1000</code> possible coordinates. Therefore, the space complexity is <span class="math inline">\(O(3^g + m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/permutations/description" target="_blank" rel="noopener noreferrer">Permutations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of distinct integers, return all the possible <span data-keyword="permutation-array">permutations</span>. You can return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [[0,1],[1,0]]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [[1]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 6</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/permutations-ii/description" target="_blank" rel="noopener noreferrer">Permutations II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a collection of numbers, <code>nums</code>,&nbsp;that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong>
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 8</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>As the name of the problem suggests, this problem is an extension of the <a href="https://leetcode.com/problems/permutations/">Permutation</a> problem.<br />
The problem is different from the previous permutation problem on the condition that the input array can contain <strong><em>duplicates</em></strong>.</p>
<p>The key to solve the problem is still the <strong><em>backtracking</em></strong> algorithm.<br />
However, we need some adaptation to ensure that the <em>enumerated</em> solutions generated from our backtracking exploration do not have any duplicates.</p>
<blockquote>
<p>As a reminder, <strong><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">backtracking</a></strong> is a general algorithm for finding all (or some) solutions to some problems with constraints.<br />
It incrementally builds candidates to the solutions, and abandons a candidate as soon as it determines that the candidate cannot possibly lead to a solution.</p>
</blockquote>
<p>In this article, we will present a yet another backtracking solution to solve the problem.</p>
<hr />
<h3 id="approach-1-backtracking-with-groups-of-numbers">Approach 1: Backtracking with Groups of Numbers</h3>
<p><strong>Intuition</strong></p>
<p>First of all, let us review the general idea of permutation with an example.</p>
<p>Given the input array <code>[1, 1, 2]</code>, to generate a permutation of the array, we could follow the <em>Depth-First Search</em> (DFS) approach, or more precisely the backtracking technique as one will see later.</p>
<blockquote>
<p>The idea is that we pick the numbers one by one. For a permutation of length <span class="math inline">\(N\)</span>, we would then need <span class="math inline">\(N\)</span> stages to generate a valid permutation.<br />
At each stage, we need to pick one number into the permutation, out of the remaining available numbers.<br />
Later at the same stage, we will try out all available choices.<br />
By trying out, we progressively build up candidates to the solution, and revert each choice with another alternative until there is no more choice.</p>
</blockquote>
<p>Let us walk through the example with paper and pencil, as follows:</p>
<ul>
<li>
<p>Given the input of <code>[1, 1, 2]</code>, at the first stage, we have 2 choices to pick a number as the first number in the final permutation, <em>i.e.</em> <code>1</code> and <code>2</code>.<br />
Suppose that we pick the number <code>1</code>, now the remaining numbers would become <code>[1, 2]</code>.<br />
<strong>Note:</strong> The reason that we have only 2 choices instead of 3, is that there is a duplicate in the given input.<br />
Picking any of the duplicate numbers as the first number of the permutation would lead us to the same permutation at the end.<br />
Should the numbers in the array be all unique, we would then have the same number of choices as the length of the array.</p>
</li>
<li>
<p>At the second stage, we now then have again 2 choices, <em>i.e.</em> <code>[1, 2]</code>.<br />
Let us pick again the number <code>1</code>, which leaves us the only remaining number <code>2</code>.</p>
</li>
<li>
<p>Now at the third stage, we have only one candidate number left, <em>i.e.</em> <code>[2]</code>. We then pick the last remaining number, which leads to a final permutation sequence of <code>[1, 1, 2]</code>.</p>
</li>
<li>
<p>Moreover, we need to <strong><em>revisit</em></strong> each of the above stages, and make a different choice in order to try out all possibilities.<br />
The reversion of the choices is what we call <strong><em>backtracking</em></strong>.</p>
</li>
</ul>
<p>We illustrate all potential exploration in the following graph where each node represents a choice at a specific stage:</p>
<p><img src="../Figures/47/47_permutations.png" alt="permutation tree" /></p>
<blockquote>
<p>A key insight to avoid generating any <strong><em>redundant</em></strong> permutation is that at each step rather than viewing each number as a candidate, we consider each <strong><em>unique</em></strong> number as the true candidate.<br />
For instance, at the very beginning, given in the input of <code>[1, 1, 2]</code>, we have only two true candidates instead of three.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<p>Given the above insight, in order to find out all the unique numbers at each stage, we can build a <strong><em>hash table</em></strong> (denoted as <code>counter</code>), with each unique number as the key and its occurrence as the corresponding value.</p>
<p>To implement the algorithm, first we define a function called <code>backtrack(comb, counter)</code> which generates all permutations, starting from the current combination (<code>comb</code>) and the remaining numbers (<code>counter</code>).</p>
<p>Once the function is implemented, it suffices to invoke the function with the initial empty combination and the hash table we built out of the input array, to solve the problem.</p>
<p>Here are some sample implementations.</p>
<p><a href="https://leetcode.com/playground/gmT2V4Q3/shared">code</a></p>
<p><strong>Note:</strong> for a backtracking algorithm, usually there are some explorations that would lead to a <em>dead end</em>, and we have to abandon those explorations in the middle.</p>
<p>However, due to the specificity of this problem and our exploration strategy, each exploration will result in a valid permutation, <em>i.e.</em> none of the efforts is in vain.<br />
This insight would prove to be useful in the following complexity analysis.</p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the length of the input array.<br />
Hence, the number of permutations would be at maximum <span class="math inline">\(N!\)</span>, <em>i.e.</em> <span class="math inline">\(N \cdot (N-1) \cdot (N-2) ... 1\)</span>, when each number in the array is unique.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}\big(\sum_{k = 1}^{N}{P(N, k)}\big)\)</span> where <span class="math inline">\(P(N, k) = \frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)\)</span><br />
is so-called <a href="https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n"><em>k-permutations_of_N</em> or <em>partial permutation</em></a>.</p>
<ul>
<li>
<p>As one can see in the exploration graph we have shown earlier, the execution of the backtracking algorithm will unfold itself as a tree, where each node is an invocation of the recursive function <code>backtrack(comb, counter)</code>.<br />
The total number of steps to complete the exploration is <em>exactly</em> the number of nodes in the tree.<br />
Therefore, the time complexity of the algorithm is linked directly with the size of the tree.</p>
</li>
<li>
<p>It now boils down to estimating the number of nodes in the tree.<br />
As we know now, each level of the tree corresponds to a specific <em>stage</em> of the exploration.<br />
At each stage, the number of candidates to explore is <strong>bounded</strong>.<br />
For instance, at the first stage, <em>at most</em> we would have <span class="math inline">\(N\)</span> candidates to explore, <em>i.e.</em> the number of nodes at this level would be <span class="math inline">\(N\)</span>.<br />
Moving on to the next stage, for each of the nodes in the first stage, we would have <span class="math inline">\(N-1\)</span> child nodes. Therefore, the number of nodes at this stage would be <span class="math inline">\(N \cdot (N-1)\)</span>.<br />
So on and so forwards.</p>
</li>
</ul>
<p><img src="../Figures/47/47_number_of_nodes.png" alt="number of nodes" /></p>
<ul>
<li>
<p>By summing up all the nodes across the stages, we would then obtain the total number of nodes as <span class="math inline">\(\sum_{k = 1}^{N}{P(N, k)}\)</span> where <span class="math inline">\(P(N, k) = \frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)\)</span>.<br />
As a result, the exact time complexity of the algorithm is <span class="math inline">\(\mathcal{O}\big(\sum_{k = 1}^{N}{P(N, k)}\big)\)</span>.</p>
</li>
<li>
<p>The above complexity might appear a bit too abstract to comprehend.<br />
Here we could provide another <strong><em>loose upper bound</em></strong> on the complexity.</p>
</li>
<li>
<p>It takes <span class="math inline">\(N\)</span> steps to generate a single permutation. Since there are in total <span class="math inline">\(N!\)</span> possible permutations, at most it would take us <span class="math inline">\(N \cdot N!\)</span> steps to generate all permutations, simply assuming that there is no overlapping effort (which is not true).</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span></p>
<ul>
<li>
<p>First of all, we build a hash table out of the input numbers. In the worst case where each number is unique, we would need <span class="math inline">\(\mathcal{O}(N)\)</span> space for the table.</p>
</li>
<li>
<p>Since we applied recursion in the algorithm which consumes some extra space in the function call stack, we would need another <span class="math inline">\(\mathcal{O}(N)\)</span> space for the recursion.</p>
</li>
<li>
<p>During the exploration, we keep a candidate of permutation along the way, which takes yet another <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p>To sum up, the total space complexity would be <span class="math inline">\(\mathcal{O}(N) + \mathcal{O}(N) + \mathcal{O}(N) = \mathcal{O}(N)\)</span>.</p>
</li>
<li>
<p><strong>Note</strong>, we did not take into account the space needed to hold the results. Otherwise, the space complexity would become <span class="math inline">\(\mathcal{O}(N \cdot N!)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/permutations-of-a-given-string2041/1" target="_blank" rel="noopener noreferrer">Permutations of a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">Given a string <strong>s</strong>, which may contain duplicate characters, your task is to generate and return an array of all <strong>unique </strong>permutations of the string. You can return your answer in <strong>any </strong>order.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "ABC"
<strong>Output: </strong>["ABC", "ACB", "BAC", "BCA", "CAB", "CBA"]
<strong>Explanation: </strong>Given string ABC has 6 unique permutations.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "ABSG"
<strong>Output: </strong>["ABGS", "ABSG", "AGBS", "AGSB", "ASBG", "ASGB", "BAGS", "BASG", "BGAS", "BGSA", "BSAG", "BSGA", "GABS", "GASB", "GBAS", "GBSA", "GSAB", "GSBA", "SABG", "SAGB", "SBAG", "SBGA", "SGAB", "SGBA"]
<strong>Explanation: </strong>Given string ABSG has 24 unique permutations.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s =<strong> </strong>"AAA"
<strong>Output: </strong>["AAA"]<br /></span><strong style="font-size: 14pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation: </strong><span style="font-family: -apple-system, system-ui, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;"><span style="font-size: 18.6667px;">No other unique permutations can be formed as all the characters are same.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= s.size() &lt;= 9<br />s contains only Uppercase english alphabets</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/permutation-with-spaces3627/1" target="_blank" rel="noopener noreferrer">Permutation with Spaces</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a string <strong>s</strong>, you need to print <strong>all possible strings</strong> that can be made by placing spaces (zero or one) in between them. The output should be printed in <strong>sorted</strong> <strong>increasing</strong> order of strings.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
s = "ABC"
<strong>Output: </strong>(A B C)(A BC)(AB C)(ABC)
<strong>Explanation</strong>:
ABC
AB C
A BC
A B C
These are the possible combination of "ABC".</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
s = "BBR"
<strong>Output: </strong>(B B R)(B BR)(BB R)(BBR)
</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>permutation()</strong> which takes the string <strong>s</strong> as input parameters and returns the <strong>sorted array&nbsp;</strong>of the string denoting the different permutations <strong>(DON'T ADD '(' and ')' it will be handled by the driver code only)</strong>.<br /><br /><strong>Expected Time Complexity:</strong> O(2<sup>s</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>CONSTRAINTS:</strong><br />1 &lt;= |s| &lt; 10<br />s only contains <strong>lowercase and Uppercase English</strong> letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/possible-words-from-phone-digits-1587115620/1" target="_blank" rel="noopener noreferrer">Possible Words From Phone Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a keypad as shown in the diagram, and an&nbsp;array <strong>arr[ ]</strong>, your task is to <strong>list all possible words</strong>&nbsp;</span><span style="font-size: 18px;">in&nbsp;</span><strong style="font-size: 18px;">any order </strong><span style="font-size: 18px;">which can be generated by pressing numbers from array.</span></p>
<p><img src="https://media.geeksforgeeks.org/img-practice/PROD/addEditProblem/701199/Web/Other/a1d54f48-0118-45d8-a8ab-7551ed72df27_1685086793.png" alt="" /></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">arr[] = [2, 3]
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">[ad, ae, af, bd, be, bf, cd, ce, cf]
</span><strong style="font-size: 18px;">Explanation: </strong><span style="font-size: 18px;">When we press 2, 3 total possible words are 3 x 3 = 9.</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">arr[] =[2]
</span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">[a, b, c]<br /></span><span style="font-size: 18.6667px;"><strong>Explanation</strong>: When we press 2 total possible words are 3.</span><span style="font-size: 14pt;"><br /></span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 9<br />1 &le; arr[i] &le; 9</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-all-lcs-sequences3413/1" target="_blank" rel="noopener noreferrer">Print all LCS sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given two strings&nbsp;<strong>s1</strong>&nbsp;and&nbsp;<strong>s2</strong>. Your task is to print all <strong>distinct</strong> longest common subsequences in lexicographical order.</span></p>
<p><strong><span style="font-size: 18px;">Note:</span></strong><span style="font-size: 18px;"> </span><span style="font-size: 18px;">A subsequence is derived from another string by deleting some or none of the elements without changing the order of the remaining elements.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s1 = "abaaa", s2 = "baabaca"
<strong>Output: </strong>["aaaa", "abaa", "baaa"]<br /><strong>Explanation: </strong>Length of lcs is 4, in lexicographical order they are "aaaa", "abaa", "baaa".</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> s1 = "aaa", s2 = "a"
<strong>Output: </strong>["a"]<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation: </strong>Length of lcs is 1 and it is "a".</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; s1.size(), s2.size() &le; 50</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/prison-break-5/" target="_blank" rel="noopener noreferrer">Prison Break</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">approved</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">easy</span> <span class="topic-badge">graph</span> <span class="topic-badge">open</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alfie was a prisoner in mythland. Though Alfie was a witty and intelligent guy.He was confident of escaping prison.After few days of observation,He figured out that the prison consists of (<strong><span class="mathjax-latex">\(N Ã— N\)</span></strong>) cells.i.e The shape of prison was (<strong><span class="mathjax-latex">\(N Ã— N\)</span></strong>) matrix. Few of the cells of the prison contained motion detectors.So Alfie planned that while escaping the prison he will avoid those cells containing motion detectors.Yet before executing his plan,Alfie wants to know the total number of unique possible paths which he can take to escape the prison.Initially Alfie is in cell  <br />
<strong>(<span class="mathjax-latex">\(1,1\)</span>)</strong> while the exit of the cell <strong>(<span class="mathjax-latex">\(N,N\)</span>)</strong>.  </p>
<p><strong>note</strong>:-&gt;Alfie can move in all four direction{ if his current location is  <strong>(<span class="mathjax-latex">\(X,Y\)</span>)</strong>, he can move to either <br />
<strong>(<span class="mathjax-latex">\(X+1,Y\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X-1,Y\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X,Y+1\)</span>)</strong>, <strong>(<span class="mathjax-latex">\(X,Y-1\)</span>)</strong> }. If the first cell <strong>(<span class="mathjax-latex">\(1,1\)</span>)</strong> and the last cell(<strong><span class="mathjax-latex">\(N,N\)</span></strong>) contain motion detectors,then Alfie can't break out of the prison.</p>
<p><strong>INPUT</strong>: </p>
<p>The first line contain number of test cases "<strong><em>T</em></strong>".<strong><em>T</em></strong> test cases follow.The first line of each test case contains an integer "<strong><em>N</em></strong>",(i.e the size of the (<strong><span class="mathjax-latex">\(N Ã— N\)</span></strong>) matrix).The next <strong><em>n</em></strong> lines contain <strong><em>N</em></strong> space separated values either <strong><em>0</em></strong> or <strong><em>1</em></strong>."<strong><em>1</em></strong>" represents a cell containing motion detectors. </p>
<p><strong>OUTPUT</strong>: </p>
<p>output total number of unique possible paths which he can take to escape the prison.  </p>
<p><strong>Constraint</strong>:</p>
<p><span class="mathjax-latex">\(1 \le  T \le 20\)</span></p>
<p><span class="mathjax-latex">\(1 \le N \le 20\)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/description" target="_blank" rel="noopener noreferrer">Probability of a Two Boxes Having The Same Number of Distinct Balls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">probability-and-statistics</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>2n</code> balls of <code>k</code> distinct colors. You will be given an integer array <code>balls</code> of size <code>k</code> where <code>balls[i]</code> is the number of balls of color <code>i</code>.</p>

<p>All the balls will be <strong>shuffled uniformly at random</strong>, then we will distribute the first <code>n</code> balls to the first box and the remaining <code>n</code> balls to the other box (Please read the explanation of the second example carefully).</p>

<p>Please note that the two boxes are considered different. For example, if we have two balls of colors <code>a</code> and <code>b</code>, and two boxes <code>[]</code> and <code>()</code>, then the distribution <code>[a] (b)</code> is considered different than the distribution <code>[b] (a) </code>(Please read the explanation of the first example carefully).</p>

<p>Return<em> the probability</em> that the two boxes have the same number of distinct balls. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted as correct.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> balls = [1,1]
<strong>Output:</strong> 1.00000
<strong>Explanation:</strong> Only 2 ways to divide the balls equally:
- A ball of color 1 to box 1 and a ball of color 2 to box 2
- A ball of color 2 to box 1 and a ball of color 1 to box 2
In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> balls = [2,1,1]
<strong>Output:</strong> 0.66667
<strong>Explanation:</strong> We have the set of balls [1, 1, 2, 3]
This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
After that, we add the first two balls to the first box and the second two balls to the second box.
We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.
Probability is 8/12 = 0.66667
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> balls = [1,2,1,2]
<strong>Output:</strong> 0.60000
<strong>Explanation:</strong> The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.
Probability = 108 / 180 = 0.6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= balls.length &lt;= 8</code></li>
	<li><code>1 &lt;= balls[i] &lt;= 6</code></li>
	<li><code>sum(balls)</code> is even.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rat-in-a-maze-problem/1" target="_blank" rel="noopener noreferrer">Rat in a Maze Problem - I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Consider a rat placed at position (0, 0) in an <strong>n x n</strong> square matrix <code><strong>mat[][]</strong></code>. The rat's goal is to reach the destination at position (n-1, n-1). The rat can move in four possible directions:&nbsp;<strong>'U'(up)</strong>,&nbsp;<strong>'D'(down)</strong>,&nbsp;<strong>'L' (left)</strong>,&nbsp;<strong>'R' (right)</strong>.</span></p>
<p><span style="font-size: 14pt;">The matrix contains only two possible values:</span></p>
<ul>
<li><span style="font-size: 14pt;"><code>0</code>: A blocked cell through which the rat <strong>cannot</strong> travel.</span></li>
<li><span style="font-size: 14pt;"><code>1</code>: A free cell that the rat <strong>can</strong> pass through.</span></li>
</ul>
<p><span style="font-size: 14pt;"><span style="font-size: 14pt;">Your task is to find <strong>all possible paths</strong> the rat can take to reach the destination, starting from (0, 0) and ending at (n-1, n-1), under the condition that the rat cannot <strong>revisit</strong> any cell along the same path. Furthermore, the rat can only move to adjacent cells that are within the bounds of the matrix and not blocked.</span><br /><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px;">If no path exists, return an <strong>empty list</strong></span><strong style="font-size: 18.6667px;">.</strong></span></span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong> Return the final result vector in <strong>lexicographically smallest order</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1]]
<strong>Output: </strong>[<span class="hljs-string">"DDRDRR"</span>, <span class="hljs-string">"DRDDRR"</span>]
<strong>Explanation</strong>: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 0], [1, 0]]
<strong>Output: </strong>[]
<strong>Explanation</strong>: No path exists as the destination cell is blocked.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat = <span class="hljs-string">[[1, 1, 1], [1, 0, 1], [1, 1, 1]]</span>
<strong>Output: </strong>[<span class="hljs-string">"DDRR"</span>, <span class="hljs-string">"RRDD"</span>]
<strong>Explanation</strong>: The rat has two possible paths to reach the destination: <span class="hljs-number" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">1.</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> </span><span class="hljs-string" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">"DDRR" </span><span class="hljs-number" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">2.</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> </span><span class="hljs-string" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">"RRDD", </span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">These are returned </span><span class="hljs-keyword" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">in</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> lexicographically sorted order.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />2 &le; mat.size() &le; 5<br />0 &le; mat[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rat-maze-with-multiple-jumps3852/1" target="_blank" rel="noopener noreferrer">Rat Maze With Multiple Jumps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A maze is given as <strong>n*n</strong>&nbsp;matrix of blocks where source block is the upper left most block i.e., <strong>matrix[0][0]</strong> and destination block is lower rightmost block i.e., <strong>matrix[n-1][n-1]</strong>. A rat starts from source and has to reach the destination. </span></p>
<p><span style="font-size: 18px;">The rat can move in only two directions: first forward (if possible) or down. </span></p>
<p><span style="font-size: 18px;">In the maze matrix, <strong>0</strong> means the block is the <strong>dead </strong>end and <strong>non-zero number </strong>means the block can be used in the path from source to destination. The <strong>non-zero value</strong> of mat[i][j] indicates number of <strong>maximum </strong>jumps rat can make from cell <strong>mat[i][j]</strong>.&nbsp;</span></p>
<p><span style="font-size: 18px;">Return a maxtrix of size <strong>n*n </strong>in<strong> </strong>which&nbsp;</span><span style="font-size: 18px;"><strong>1</strong> at (i, j) represents the cell is taken into the path otherwise <strong>0</strong> .</span></p>
<p><span style="font-size: 18px;"><strong>Note :</strong> If multiple solutions exist, the shortest earliest hop will be accepted. For the same hop distance at any point, <strong>forward </strong>will be <strong>preferred </strong>over <strong>downward</strong>.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>{{2,1,0,0},{3,0,0,1},{0,1,0,1},
{0,0,0,1}}
<strong>Output: </strong>{{1,0,0,0},{1,0,0,1},{0,0,0,1},
{0,0,0,1}}
<strong>Explanation: </strong>Rat started with matrix[0][0] and 
can jump up to 2 steps right/down. First check 
matrix[0][1] as it is 1, next check 
matrix[0][2] ,this won't lead to the solution. 
Then check matrix[1][0], as this is 3(non-zero)
,so we can make 3 jumps to reach matrix[1][3]. 
From matrix[1][3] we can move downwards taking 
1 jump each time to reach destination at 
matrix[3][3].</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>{{2,1,0,0},{2,0,0,1},{0,1,0,1},
{0,0,0,1}}
<strong>Output:</strong> {{-1}}
<strong>Explanation: </strong>As no path exists so, -1.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anyhting, Your task is to complete the function&nbsp;<strong>ShortestDistance()&nbsp;</strong>which takes the matrix as input parameter and returns a matrix of size n if path exists otherwise returns a matrix of 1x1 which contains -1. In output matrix, 1&nbsp;at (i, j) represents the cell is taken into the path otherwise 0 if any path exists.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n*n*k) where k is max(matrix[i][j])<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 50<br />1 &lt;= matrix[i][j] &lt;= 20</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-invalid-parentheses/description" target="_blank" rel="noopener noreferrer">Remove Invalid Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>

<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;()())()&quot;
<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;(a)())()&quot;
<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;)(&quot;
<strong>Output:</strong> [&quot;&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 25</code></li>
	<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>
	<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<p><strong>Intuition</strong></p>
<p>For this question, we are given an expression consisting of parentheses and there can be some misplaced or extra brackets in the expression that cause it to be invalid. An expression consisting of parentheses is considered valid only when every closing bracket has a corresponding opening bracket and vice versa.</p>
<p>This means if we start looking at each of the bracket from left to right, as soon as we encounter a closing bracket, there should be an unmatched opening bracket available to match it. Otherwise the expression would become invalid. The expression can also become invalid if the number of opening parentheses i.e. <code>(</code> are more than the number of closing parentheses i.e. <code>)</code>.</p>
<p>Let us look at an invalid expression and all the possible valid expressions that can be formed from it by removing some of the brackets. There is no restriction on which parentheses we can remove. We simply have to make the expression valid.</p>
<blockquote>
<p>The only condition is that we should be removing the minimum number of brackets to make an invalid expression, valid. If this condition was not present, we could potentially remove most of the brackets and come down to say 2 brackets in the end which form <code>()</code> and that would be a valid expression.</p>
</blockquote>
<center>
<img src="../Figures/301/Diag_1.png" width="800"></center>
<p>An important thing to observe in the above diagram is that there are multiple ways of reaching the same solution i.e. say the optimal number of parentheses to be removed to make the original expression valid is K. We can remove multiple different sets of K brackets that will eventually give us the same final expression. But, each valid expression should be recorded only once. We have to take care of this in our solution. Note that there are other possible ways of reaching one of the two valid expressions shown above. We have simply shown 3 ways each for the two valid expressions.</p>
<p>Coming back to our problem, the question that now arises is, how to decide which of the parentheses to remove?</p>
<blockquote>
<p>Since we don't know which of the brackets can possibly be removed, we try out all the options!</p>
</blockquote>
<p>For every bracket we have two choices:</p>
<ul>
<li>Either it can be considered a part of the final expression OR</li>
<li>It can be ignored i.e. we can delete it from our final expression.</li>
</ul>
<p>Such kind of problems where we have multiple options and we have no strategy or metric of deciding greedily which option to take, we try out all of the options and see which ones lead to an answer. These type of problems are perfect candidates for the programming paradigm, <code>Recursion</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize an array that will store all of our valid expressions finally.</li>
<li>Start with the leftmost bracket in the given sequence and proceed right in the recursion.</li>
<li>The state of recursion is defined by the index which we are currently processing in the original expression. Let this index be represented by the character <code>i</code>. Also, we have two different variables <code>left_count</code> and <code>right_count</code> that represent the number of left and right parentheses we have added to our expression till now. These are the parentheses that were considered.</li>
<li>If the current character i.e. <code>S[i]</code> (considering S is the expression string) is neither a closing or an opening parenthesis, then we simply add this character to our final solution string for the current recursion.</li>
<li>However, if the current character is either of the two brackets i.e. <code>S[i] == '(' or S[i] == ')'</code>, then we have two options. We can either discard this character by marking it an invalid character or we can consider this bracket to be a part of the final expression.</li>
<li>When all of the parentheses in the original expression have been processed, we simply check if the expression represented by <code>expr</code> i.e. the expression formed till now is valid one or not. The way we check if the final expression is valid or not is by looking at the values in <code>left_count</code> and <code>right_count</code>. For an expression to be valid <code>left_count == right_count</code>. If it is indeed valid, then it could be one of our possible solutions.
<ul>
<li>Even though we have a valid expression, we also need to keep track of the number of removals we did to get this expression. This is done by another variable passed in recursion called <code>rem_count</code>.</li>
<li>Once recursion finishes we check if the current value of <code>rem_count</code> is &lt; the least number of steps we took to form a valid expression till now i.e. the global minima. If this is not the case, we don't record the new expression, else we record it.</li>
</ul>
</li>
</ol>
<p>One small optimization that we can do from an implementation perspective is introducing some sort of pruning in our algorithm. Right now we simply go till the very end i.e. process all of the parentheses and when we are done processing all of them, we check if the expression we have can be considered or not.</p>
<p>We have to wait till the very end to decide if the expression formed in recursion is a valid expression or not. Is there a way for us to cutoff from some of the recursion paths early on because they wouldn't lead to a solution? The answer to this is Yes! The optimization is based on the following idea.</p>
<p>For a left bracket encountered during recursion, if we decide to consider it, then it may or may not lead to an invalid final expression. It may lead to an invalid expression eventually if there are no matching closing bracket available afterwards. But, we don't know for sure if this will happen or not.</p>
<blockquote>
<p>However, for a closing bracket, if we decide to keep it as a part of our final expression (remember for every bracket we have two options, either to keep it or to remove it and recurse further) and there is no corresponding opening bracket to match it in the expression till now, then it will definitely lead to an invalid expression no matter what we do afterwards.</p>
</blockquote>
<p>e.g.</p>
<pre>
( (  ) ) )
</pre>
<p>In this case the third closing bracket will make the expression invalid. No matter what comes afterwards, this will give us an invalid expression and if such a thing happens, we shouldn't recurse further and simply prune the recursion tree.</p>
<p>That is why, in addition to having the index in the original string/expression which we are currently processing and the expression string formed till now, we also keep track of the number of left and right parentheses. Whenever we keep a left parenthesis in the expression, we increment its counter. For a right parenthesis, we check if <code>right_count &lt; left_count</code>. If this is the case then only we consider that right parenthesis and recurse further. Otherwise we don't as we know it will make the expression invalid. This simple optimization saves a lot of runtime.</p>
<p>Now, let us look at the implementation for this algorithm.</p>
<p><a href="https://leetcode.com/playground/ZNSLoChx/shared">code</a></p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time Complexity : <span class="math inline">\(O(2^N)\)</span> since in the worst case we will have only left parentheses in the expression and for every bracket we will have two options i.e. whether to remove it or consider it. Considering that the expression has <span class="math inline">\(N\)</span> parentheses, the time complexity will be <span class="math inline">\(O(2^N)\)</span>.</li>
<li>Space Complexity : <span class="math inline">\(O(N)\)</span> because we are resorting to a recursive solution and for a recursive solution there is always stack space used as internal function states are saved onto a stack during recursion. The maximum depth of recursion decides the stack space used. Since we process one character at a time and the base case for the recursion is when we have processed all of the characters of the expression string, the size of the stack would be <span class="math inline">\(O(N)\)</span>. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.<br />
<br /><br />
<br /></li>
</ul>
<hr />
<h3 id="approach-2-limited-backtracking">Approach 2: Limited Backtracking!</h3>
<p>Although the previous solution does get accepted on the platform, it is a very inefficient solution because we try removing each and every possible parentheses from the expression and in the end we check two things:</p>
<ol>
<li>if the expression is valid or not</li>
<li>if the total number of removed parentheses removed in the current recursion is less than the global minimum till now or not.</li>
</ol>
<p>We cannot determine which of the parentheses are misplaced because, as the problem statement puts across, we can remove multiple combinations of parentheses and end up with a valid expression. This means there can be multiple valid expressions from a single invalid expression and we have to find all of them.</p>
<blockquote>
<p>The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed.</p>
</blockquote>
<p>What if we could determine this count?</p>
<p>What if in addition to determining this count of characters to be removed, we could also determine the number of left parentheses and number of right parentheses to be removed from the original expression to get <strong>any</strong> valid expression?</p>
<p>This would cut down the computations immensely and the runtime would plummet as a result. The reason for this is, if we knew how many left and right parentheses are to be removed from the original expression to get a valid expression, we would cut down on so many unwanted recursive calls.</p>
<p>Imagine the original expression to be 1000 characters with only 3 misplaced <code>(</code> parentheses and 2 misplaced <code>)</code> parentheses. In our previous solution we would end up trying to remove each one of left and right parentheses and try to reach a valid expression in the end whereas we should only be trying out removing 3 <code>(</code> brackets and 2 <code>)</code> brackets.</p>
<blockquote>
<p>This is the exact number of <code>(</code> and <code>)</code> that have to be removed to get a valid expression. No more, no less.</p>
</blockquote>
<p>Let us look at how we can find out the number of misplaced left and right parentheses in a given expression first and then we will slightly modify our original algorithm to incorporate these counts as well.</p>
<ol>
<li>We process the expression one bracket at a time starting from the left.</li>
<li>Suppose we encounter an opening bracket i.e. <code>(</code>, it may or may not lead to an invalid expression because there can be a matching ending bracket somewhere in the remaining part of the expression. Here, we simply increment the counter keeping track of left parentheses till now. <code>left += 1</code></li>
<li>If we encounter a closing bracket, this has two meanings:
<ul>
<li>Either there was no matching opening bracket for this closing bracket and in that case we have an invalid expression. This is the case when <code>left == 0</code> i.e. when there are no unmatched left brackets available. In such a case we increment another counter say <code>right += 1</code> to represent misplaced right parentheses.</li>
<li>Or, we had some unmatched opening bracket available to match this closing bracket. This is the case when <code>left &gt; 0</code>. In this case we simply decrement the left counter we had i.e. <code>left -= 1</code></li>
</ul>
</li>
<li>Continue processing the string until all parentheses have been processed.</li>
<li>In the end the values of <code>left</code> and <code>right</code> would tell us the number of unmatched <code>(</code> and <code>)</code> parentheses respectively.</li>
</ol>
<p>Now that we have these two values available that tell us the total number of left i.e. <code>(</code> and right i.e. <code>)</code> parentheses that have to be removed to make the invalid expression valid, we will modify our original algorithm discussed in the previous session to avoid unwanted recursions.</p>
<p><strong>Algorithm</strong></p>
<p>The overall algorithm remains exactly the same as before. The changes that we will incorporate are listed below:</p>
<ul>
<li>The state of the recursion is now defined by five different variables:
<ol>
<li><code>index</code> which represents the current character that we have to process in the original string.</li>
<li><code>left_count</code> which represents the number of left parentheses that have been added to the expression we are building.</li>
<li><code>right_count</code> which represents the number of right parentheses that have been added to the expression we are building.</li>
<li><code>left_rem</code> is the number of left parentheses that remain to be removed.</li>
<li><code>right_rem</code> represents the number of right parentheses that remain to be removed. Overall, for the final expression to be valid, <code>left_rem == 0</code> and <code>right_rem == 0</code>.</li>
</ol>
</li>
<li>When we decide to not consider a parenthesis i.e. delete a parenthesis, be it a left or a right parentheses, we have to consider their corresponding remaining counts as well. This means that we can only discard a left parentheses if <code>left_rem &gt; 0</code> and similarly for the right one we will check for <code>right_rem &gt; 0</code>.</li>
<li>There are no changes to checks for <strong>considering</strong> a parenthesis. Only the conditions change for <strong>discarding</strong> a parenthesis.</li>
<li>Condition for an expression being valid in the base case would now become <code>left_rem == 0 and right_rem == 0</code>. Note that we don't have to check if <code>left_count == right_count</code> anymore because in the case of a valid expression, we would have removed all the misplaced or invalid parenthesis by the time the recursion ends. So, the only check we need if <code>left_rem == 0 and right_rem == 0</code>.</li>
</ul>
<blockquote>
<p>The most important thing here is that we have completely gotten rid of checking if the number of parentheses removed is lesser than the current minimum or not. The reason for this is we always remove the same number of parentheses as defined by <code>left_rem + right_rem</code> at the start of recursion.</p>
</blockquote>
<p>Now let us look at the implementation for this modified version of algorithm.</p>
<p><a href="https://leetcode.com/playground/bjCaADnt/shared">code</a></p>
<p><strong>Complexity analysis</strong></p>
<ul>
<li>Time Complexity : The optimization that we have performed is simply a better form of pruning. Pruning here is something that will vary from one test case to another. In the worst case, we can have something like <code>(((((((((</code> and the <code>left_rem = len(S)</code> and in such a case we can discard all of the characters because all are misplaced. So, in the worst case we <strong>still</strong> have 2 options per parenthesis and that gives us a complexity of <span class="math inline">\(O(2^N)\)</span>.</li>
<li>Space Complexity : The space complexity remains the same i.e. <span class="math inline">\(O(N)\)</span> as previous solution. We have to go to a maximum recursion depth of <span class="math inline">\(N\)</span> before hitting the base case. Note that we are not considering the space required to store the valid expressions. We only count the intermediate space here.</li>
</ul>
<br />
<br /></div>
				</div>
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/restore-ip-addresses/description" target="_blank" rel="noopener noreferrer">Restore IP Addresses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>

<ul>
	<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>
</ul>

<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;25525511135&quot;
<strong>Output:</strong> [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0000&quot;
<strong>Output:</strong> [&quot;0.0.0.0&quot;]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;101023&quot;
<strong>Output:</strong> [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 20</code></li>
	<li><code>s</code> consists of digits only.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>Since a valid IP address consists of 4 integers, that means we need to place 3 dots. We can try putting dots at all possible different positions using backtracking. If an invalid number is formed then we backtrack to try out another combination.</p>
<blockquote>
<p>Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate (&quot;backtracks&quot;) when it determines that the candidate cannot lead to the solution.</p>
</blockquote>
<p>We will recursively enumerate all the possibilities and whenever we get a new integer because of a dot (or 2 integers for the last dot), we check whether the integer(s) is valid, i.e the integer cannot have leading 0s other than being 0 itself and it's no larger than 255.<br />
There are 3 possibilities to add each dot, namely it can be added after 1, 2, or 3 digits from the last dot or the beginning of the string, so there are at most <span class="math inline">\(3 ^ 3 = 27\)</span> possibilities to add all 3 dots.</p>
<p>An optimization is to return an empty result if the input string's length is longer than 12 since each integer can have 3 digits at most (any more and it would either have leading zeroes or be greater than 255).</p>
<p>We can create a helper function <code>valid(s, start, length)</code> to check whether the substring from index <code>start</code> to <code>start + length</code> is a valid number from range 0-255. The logic is to check both the conditions (the caller guarantees that the length is in the range of [1, 3]):</p>
<ol>
<li>If the substring's first character is <code>0</code> (i.e. <code>s[start]</code> is '0'), then <code>length</code> must be 1.</li>
<li>If <code>length</code> is <code>3</code>, the substring should no larger than &quot;255&quot; lexically. If the length is 1 or 2 and the first case was not triggered, then it will be in the acceptable range.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<p>Create a function <code>helper</code> which takes the original string <code>s</code>, the processing index <code>startIndex</code> (i.e we only consider the substring starting from <code>startIndex</code> and the prefix part is already separated into valid integers.), a list of integers <code>dots</code> which saves distances for the dots we have added so far and a list of strings <code>ans</code> to save the answers.</p>
<ol>
<li>Set <code>remainingLength</code> to <code>length of s - startIndex</code> which is the string length we want to process.</li>
<li>Set <code>remainingNumberOfIntegers</code> to <code>4 - dots.length</code>. This is how many integers we have left to form.</li>
<li>Return if <code>remainingLength</code> is larger than <code>remainingNumberOfIntegers * 3</code> or smaller than <code>remainingNumberOfIntegers</code>, since each integer has 1-3 digits. Also note that this catches the case where <code>s.length() &gt; 12</code> since at the very beginning <code>remainingLength</code> is <code>s.length()</code> and <code>remainingNumberOfIntegers</code> is 4.</li>
<li>If <code>remainingNumberOfIntegers = 1</code>,
<ul>
<li>if the last integer <code>s.substring(startIndex, startIndex + remainingLength)</code> is valid
<ul>
<li>Create an empty string to save this answer using the following steps.</li>
<li>Set <code>last</code> to <code>0</code>.</li>
<li>Iterate over all elements <code>dot</code> in the list <code>dots</code>.
<ul>
<li>Append <code>s.substring(last, last + dot)</code> and a '.' into the answer string.</li>
<li>Increase <code>last</code> by <code>dot</code> and repeat these steps for each dot.</li>
</ul>
</li>
<li>Append <code>s.substring(last, s.length)</code>. This is the final integer after the last dot.</li>
<li>Add the answer string into <code>ans</code>.</li>
</ul>
</li>
<li>Return.</li>
</ul>
</li>
<li>Iterate over <code>curPos</code> from <code>1</code> to <code>min(3, remainingLength)</code>. <code>curPos</code> is the number of digits we are including before placing a dot.
<ul>
<li>Place a dot by adding <code>curPos</code> into <code>dots</code>.</li>
<li>If the integer <code>s.substring(startIndex, startIndex + curPos)</code> is valid
<ul>
<li>Call helper(s, startIndex + curPos, dots, ans)</li>
</ul>
</li>
<li>Remove the dot that we placed to backtrack.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DYStKNxi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let's assume we need to separate the input string into <span class="math inline">\(N\)</span> integers, each integer is at most <span class="math inline">\(M\)</span> digits.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(M ^ N \cdot N)\)</span>.</li>
</ul>
<p>There are at most <span class="math inline">\(M ^ {N - 1}\)</span> possibilities, and for each possibility checking whether all parts are valid takes <span class="math inline">\(O(M \cdot N)\)</span> time, so the final time complexity is <span class="math inline">\(O(M ^ {N - 1}) \cdot O(M \cdot N)\)</span> = <span class="math inline">\(O(M ^ N \cdot N)\)</span>.</p>
<p>For this question, M = 3, N = 4, so the time complexity is <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span>.</p>
<p>For each possibility, we save (N - 1) numbers (the number of digits before each dot) which takes <span class="math inline">\(O(N)\)</span> space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is <span class="math inline">\(M \cdot N + M - 1\)</span> = <span class="math inline">\(O(M \cdot N)\)</span>, so the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span> if we don't take the output space into consideration.</p>
</li>
</ul>
<p>For this question, M = 3, N = 4, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<h3 id="approach-2-iterative">Approach 2: Iterative</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We need to separate the input string into 4 integers, so we can enumerate the length of the first 3 integers, <code>len1</code>, <code>len2</code>, <code>len3</code>. We could iterate over <code>len1</code>, <code>len2</code>, <code>len3</code> with 3 nested loops and the last integer is the remaining part after separating out the first 3.</p>
<p>We can make the ranges of <code>len1</code>, <code>len2</code>, <code>len3</code> tighter:</p>
<ul>
<li><code>len1</code> should be in the range <code>[max(1, s.length() - 9), min(3, s.length() - 3]</code> since we need to separate 3 more integers after it and the length of each integer is in [1..3].</li>
<li>Similarly, <code>len2</code> should be in the range <code>[max(1, s.length() - len1 - 6, min(3, s.length() - len1 - 2]</code></li>
<li><code>len3</code> should be in the range <code>[max(1, s.length() - len1 - len2 - 3), min(3, s.length() - len1 - len2 - 1]</code></li>
</ul>
<p>In this way, the last part's length is always in the range of <code>[1..3]</code>, then we can split each substring out based on the lengths and check whether they are valid. Each integer can be validated before starting the loop of the next part to prevent wasting time.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an array of strings <code>ans</code>.</li>
<li>Iterate over the range of <code>len1</code>, the length of the first integer.
<ul>
<li>If the first integer is valid, then we iterate over <code>len2</code>'s range.
<ul>
<li>If the second integer is also valid, then we iterate over <code>len3</code>'s range.
<ul>
<li>If both third and fourth integers are valid, concatenate all four integers together with a character <code>'.'</code> between any 2 neighbors, and add the result string to <code>ans</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/mcmi5hLS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let's assume we need to separate the input string into <span class="math inline">\(N\)</span> integers, each integer is at most <span class="math inline">\(M\)</span> digits.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M ^ N \cdot N)\)</span>.</p>
<p>We have <span class="math inline">\((N - 1)\)</span> nested loops and each of them iterates at most <span class="math inline">\(M\)</span> times, so the total number of iterations is at most  <span class="math inline">\(M ^ {N - 1}\)</span> .</p>
<p>In each iteration we split <span class="math inline">\(N\)</span> substrings out to check whether they are valid, each substring's length is at most <span class="math inline">\(M\)</span>, so the time complexity to separate out all of them is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<p>For this question, M = 3, N = 4, so the time complexity is <span class="math inline">\(O(1)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span>.</li>
</ul>
<p>The algorithm saves (N - 1) numbers (the number of digits before each dot) which takes <span class="math inline">\(O(N)\)</span> space. And we need temporary space to save a solution before putting it into the answer list. The length of each solution string is <span class="math inline">\(M \cdot N + M - 1\)</span> = <span class="math inline">\(O(M \cdot N)\)</span>, so the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span> if we don't take the output space into consideration.</p>
<p>For this question, M = 3, N = 4, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shopping-offers/description" target="_blank" rel="noopener noreferrer">Shopping Offers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In LeetCode Store, there are <code>n</code> items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>

<p>You are given an integer array <code>price</code> where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> item, and an integer array <code>needs</code> where <code>needs[i]</code> is the number of pieces of the <code>i<sup>th</sup></code> item you want to buy.</p>

<p>You are also given an array <code>special</code> where <code>special[i]</code> is of size <code>n + 1</code> where <code>special[i][j]</code> is the number of pieces of the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> offer and <code>special[i][n]</code> (i.e., the last integer in the array) is the price of the <code>i<sup>th</sup></code> offer.</p>

<p>Return <em>the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers</em>. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == price.length == needs.length</code></li>
	<li><code>1 &lt;= n &lt;= 6</code></li>
	<li><code>0 &lt;= price[i], needs[i] &lt;= 10</code></li>
	<li><code>1 &lt;= special.length &lt;= 100</code></li>
	<li><code>special[i].length == n + 1</code></li>
	<li><code>0 &lt;= special[i][j] &lt;= 50</code></li>
	<li>The input is generated that at least one of <code>special[i][j]</code> is non-zero for <code>0 &lt;= j &lt;= n - 1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sliding-puzzle/description" target="_blank" rel="noopener noreferrer">Sliding Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On an <code>2 x 3</code> board, there are five tiles labeled from <code>1</code> to <code>5</code>, and an empty square represented by <code>0</code>. A <strong>move</strong> consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>

<p>The state of the board is solved if and only if the board is <code>[[1,2,3],[4,5,0]]</code>.</p>

<p>Given the puzzle board <code>board</code>, return <em>the least number of moves required so that the state of the board is solved</em>. If it is impossible for the state of the board to be solved, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[4,0,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Swap the 0 and the 5 in one move.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[5,4,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No number of moves will make the board solved.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[4,1,2],[5,0,3]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 2</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>
	<li>Each value <code>board[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute-force approach is feasible due to the problem's small constraints. We can explore all possible board states and track the number of moves taken to reach each one. Once we reach the solved state, we return the move count.</p>
<p>The first step is to identify the possible moves from each board position. Each move shifts the '0' (blank square) in one of the four cardinal directions. To simplify, weâ€™ll flatten the 2-D board to a 1-D string by appending the first row to the second. The moves at each square are now converted as given below, where each index represents the position of the zero, and lists the indices in the 1-D string it can go to:</p>
<p><img src="../Figures/773/2dto1d.png" alt="" /></p>
<p>The above figure demonstrates how each tile position is mapped to an index in the 1-D string, and how the tile movements are simulated in the string.</p>
<p>We'll use depth-first search (DFS) to explore all board states. DFS is well-suited here because it allows us to explore each possible path to the solution one by one, fully exploring each path before backtracking. Starting from the initial board state as a flattened string, we maintain a <code>visited</code> map, where each board state is a key, and the value is the number of moves taken to reach it. In our DFS, if the current state already exists in the map with fewer moves, we return early. Otherwise, we update the map with the current move count and explore all possible moves.</p>
<p>Next, we can put the current state in the map with the current move count and start exploring all possible moves from this position. We modify the board based on the next move and recursively call the DFS function to explore further.</p>
<p>After exploring all moves, if the solved state appears in the map, we return its move count; if not, we return -1, as solving the board is impossible.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a 2-D array <code>directions</code> which represents the possible moves for the empty tile (<code>0</code>) at each position on a flattened 1D representation of the <span class="math inline">\(2 \times 3\)</span> board.</li>
</ul>
<p>Main method <code>slidingPuzzle</code>:</p>
<ul>
<li>Initialize a string <code>startState</code> to represent the initial state of the board in a 1-D string format.</li>
<li>Iterate over each cell in the 2-D board and append each element to <code>startState</code>.</li>
<li>Initialize a map <code>visited</code> to store each unique state of the board encountered during the search.</li>
<li>Call a helper function <code>dfs</code> on <code>startState</code>, passing <code>visited</code>, the index of <code>0</code> in <code>startState</code>, and a move count initialized to <code>0</code>.</li>
<li>Return the minimum moves required to reach the solved state (<code>&quot;123450&quot;</code>), or -1 if the state was not found in <code>visited</code>.</li>
</ul>
<p>Helper method <code>dfs</code>:</p>
<ul>
<li>Check if the <code>state</code> has already been visited with fewer or equal moves than the current count (<code>moves</code>).
<ul>
<li>If so, skip further exploration of this path.</li>
</ul>
</li>
<li>Update <code>visited</code> with the current state and move count.</li>
<li>For each adjacent position <code>nextPos</code> in <code>directions</code>:
<ul>
<li>Swap the characters at <code>zeroPos</code> and <code>nextPos</code> in <code>state</code>.</li>
<li>Recursively call <code>dfs</code> on the newly generated state with <code>moves</code> incremented by 1.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7xoehmiw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<blockquote>
<p>Note: The values of m and n are fixed by the problem constraints, so their complexities can be considered constant. However, we have kept them as variables for clarity and better understanding.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span></p>
<p>In DFS, each of the <span class="math inline">\((m \cdot n)!\)</span> possible board states can be revisited multiple times due to different move sequences, as DFS doesnâ€™t prioritize the shortest path and may explore all possible paths, reaching the same state repeatedly. Since each state has up to four possible moves on a 2D board, DFS could re-explore each configuration from different directions, leading to up to <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span> recursive calls. Generating each new configuration requires <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Thus, the time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The DFS approach requires storing each of the <span class="math inline">\((m \cdot n)!\)</span> unique states in a <code>visited</code> map to avoid recalculations when a state is reached with the same or fewer moves. In the worst case, the DFS call stack can reach a maximum depth of <span class="math inline">\(O((m \cdot n)!)\)</span>, giving a space complexity of <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The DFS approach explores all possible board states before reaching the final state, which can be inefficient. Although we might find the solution early, DFS will still continue to explore all paths, potentially with non-optimal move counts. To address this, we switch to Breadth-First Search (BFS). BFS is better suited in scenarios like this because it explores all states at the current move level before going deeper, ensuring that the first time it reaches the goal, it has found the shortest path.</p>
<p>Our setup remains similar: we convert the board to a 1-D string and use a set to track visited states. A queue will handle the BFS traversal, starting from the initial state. The queueâ€™s structure works well to support BFSâ€™s layered exploration, since each level is processed sequentially and we stop as soon as we reach the goal.</p>
<p>We then loop while the queue is not empty, processing all states at the current move count. If we encounter the final state, we return the current move count as the answer. Otherwise, we explore all possible moves from the current state, modify the board accordingly, and, if unvisited, add the new state to the queue for further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define an array <code>directions</code> to map the possible moves for the empty tile (<code>0</code>) at each position.</li>
<li>Initialize a string:
<ul>
<li><code>target</code> to &quot;123450&quot;, representing the goal state of the board.</li>
<li><code>startState</code> to store the initial configuration of the board in string form.</li>
</ul>
</li>
<li>Iterate through each row and column of <code>board</code>:
<ul>
<li>Append each tile value to <code>startState</code> to create a single string representing the initial board state.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a set <code>visited</code> to store all the board states already processed to prevent redundant calculations.</li>
<li>a <code>queue</code> for the Breadth-First Search (BFS) traversal.</li>
<li>an integer <code>moves</code> to 0, which will track the number of moves taken to reach the goal state.</li>
</ul>
</li>
<li>Add <code>startState</code> to <code>visited</code> to mark it as processed.</li>
<li>Start a while loop that continues as long as <code>queue</code> is not empty:
<ul>
<li>Store the current size of <code>queue</code> in <code>size</code>. For each item in the current level:
<ul>
<li>Remove the front element of <code>queue</code> and assign it to <code>currentState</code>.</li>
<li>Check if <code>currentState</code> matches <code>target</code>. If it does, return <code>moves</code> as the minimum moves required to reach the solved state.</li>
<li>Set <code>zeroPos</code> to the position of zero in <code>currentState</code>.</li>
<li>For each valid new position <code>newPos</code> in <code>directions[zeroPos]</code>:
<ul>
<li>Generate <code>nextState</code> by swapping <code>zeroPos</code> and <code>newPos</code>.</li>
<li>If <code>nextState</code> is already in <code>visited</code>, skip it to avoid redundant processing.</li>
<li>Otherwise, add <code>nextState</code> to both <code>visited</code> and <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>moves</code> to continue to the next level of BFS.</li>
</ul>
</li>
<li>If <code>queue</code> becomes empty without reaching the target, return -1, indicating the puzzle is unsolvable.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2hGW2Z7j/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span></p>
<p>The algorithm uses Breadth-First Search (BFS) to explore all possible board configurations. With <span class="math inline">\((m \cdot n)!\)</span> unique configurations, BFS may process each configuration once. Each configuration requires checking moves and generating new ones, taking <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The space complexity is determined by the <code>visited</code> set and the BFS queue, each of which can hold up to <span class="math inline">\((m \cdot n)!\)</span> unique configurations in the worst case. Therefore, the space complexity is <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-divisible-digit-product-ii/description" target="_blank" rel="noopener noreferrer">Smallest Divisible Digit Product II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>num</code> which represents a <strong>positive</strong> integer, and an integer <code>t</code>.</p>

<p>A number is called <strong>zero-free</strong> if <em>none</em> of its digits are 0.</p>

<p>Return a string representing the <strong>smallest</strong> <strong>zero-free</strong> number greater than or equal to <code>num</code> such that the <strong>product of its digits</strong> is divisible by <code>t</code>. If no such number exists, return <code>&quot;-1&quot;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">num = &quot;1234&quot;, t = 256</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;1488&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>The smallest zero-free number that is greater than 1234 and has the product of its digits divisible by 256 is 1488, with the product of its digits equal to 256.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">num = &quot;12355&quot;, t = 50</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;12355&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>12355 is already zero-free and has the product of its digits divisible by 50, with the product of its digits equal to 150.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">num = &quot;11111&quot;, t = 26</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;-1&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>No number greater than 11111 has the product of its digits divisible by 26.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= num.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>num</code> consists only of digits in the range <code>[&#39;0&#39;, &#39;9&#39;]</code>.</li>
	<li><code>num</code> does not contain leading zeros.</li>
	<li><code>1 &lt;= t &lt;= 10<sup>14</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-string-starting-from-leaf/description" target="_blank" rel="noopener noreferrer">Smallest String Starting From Leaf</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree where each node has a value in the range <code>[0, 25]</code> representing the letters <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>.</p>

<p>Return <em>the <strong>lexicographically smallest</strong> string that starts at a leaf of this tree and ends at the root</em>.</p>

<p>As a reminder, any shorter prefix of a string is <strong>lexicographically smaller</strong>.</p>

<ul>
	<li>For example, <code>&quot;ab&quot;</code> is lexicographically smaller than <code>&quot;aba&quot;</code>.</li>
</ul>

<p>A leaf of a node is a node that has no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/30/tree1.png" style="width: 534px; height: 358px;" />
<pre>
<strong>Input:</strong> root = [0,1,2,3,4,3,4]
<strong>Output:</strong> &quot;dba&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/30/tree2.png" style="width: 534px; height: 358px;" />
<pre>
<strong>Input:</strong> root = [25,1,3,1,3,0,2]
<strong>Output:</strong> &quot;adz&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/01/tree3.png" style="height: 490px; width: 468px;" />
<pre>
<strong>Input:</strong> root = [2,2,1,null,1,0,null,0]
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 8500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 25</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the root of a binary tree, where each node has a value in the range <code>[0, 25]</code> representing the letters <code>'a'</code> to <code>'z'</code>. The task is to find the lexicographically smallest string that starts at a leaf node and ends at the root of the binary tree.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The string should start from a leaf node and end at the root node.</li>
<li>The string should be the smallest lexicographically, where a shorter prefix is considered smaller than a longer prefix of equal lexicographical size.</li>
<li>The input values are numbers and represent characters from <code>'a'</code> to <code>'z'</code>, and the output needs to be returned as a string of characters.</li>
</ol>
<p>This article includes tree traversal. If you're not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">tree traversal explore card</a>.</p>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A common approach to solving this problem is to use a depth-first search (DFS), exploring the tree from the leaf nodes to the root and keeping track of the current string. The idea is to recursively explore all possible paths while maintaining the lexicographically smallest string encountered along the way.</p>
<p>During traversal, we ensure that we visit all nodes to avoid missing any potential lexicographically smallest string. To achieve this, we maintain track of the current values traversed to construct the current string.</p>
<p>As we explore different paths, we check if the current string is lexicographically smaller than the previously encountered smallest string. If the current string is lexicographically smaller, we update it; otherwise, we continue our exploration.</p>
<p>The following is an illustration demonstrating the depth first search approach:</p>
<p>!?!../Documents/988/depth_first_search.json:636,301!?!</p>
<blockquote>
<p><strong>Note:</strong> You may wonder whether a greedy algorithm that assumes that each local optimal step will eventually lead to a globally optimal solution could solve this problem. Consider the test case [4,0,1,1]. In this scenario, a greedy approach would fail to produce the correct result. Similarly, in the case of [25,1,null,0,0,1,null,null,null,0], the expected answer is &quot;ababz&quot;, but the greedy solution would result in &quot;abz&quot;.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty string <code>smallestString</code> to store the lexicographically smallest string.</p>
</li>
<li>
<p>Call the helper function <code>dfs(root, &quot;&quot;)</code>.</p>
<ul>
<li>The <code>dfs</code> function takes the current node <code>root</code> and the current string <code>currentString</code> as parameters.</li>
</ul>
</li>
<li>
<p>Inside the <code>dfs</code> function:</p>
<ul>
<li>If the current node <code>root</code> is NULL, return (base case).</li>
<li>Construct the <code>currentString</code> by appending the character corresponding to the current node's value to the beginning of the <code>currentString</code>.</li>
<li>If the current node <code>root</code> is a leaf node:
<ul>
<li>If <code>smallestString</code> is empty or if the <code>currentString</code> is lexicographically smaller than <code>smallestString</code>:<br />
- Update <code>smallestString</code> to be the <code>currentString</code>.</li>
</ul>
</li>
<li>Recursively call <code>dfs</code> on the left child of the current node (if it exists).</li>
<li>Recursively call <code>dfs</code> on the right child of the current node (if it exists).</li>
</ul>
</li>
<li>
<p>After the <code>dfs</code> function call, return the <code>smallestString</code>.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Characters are represented as integers using ASCII values. For lowercase letters, the ASCII values start from 97 for <code>'a'</code>, 98 for <code>'b'</code>, and so on.</p>
<ul>
<li>Now, consider the expression <code>char(root-&gt;val + 'a')</code>. Here, <code>root-&gt;val</code> represents some integer value. Adding it to 'a' (which is 97) essentially shifts it to the corresponding position in the alphabet. For example, if <code>root-&gt;val</code> is 0, then <code>root-&gt;val + 'a'</code> becomes 97 ('a' in ASCII), resulting in the character 'a'. Similarly, if <code>root-&gt;val</code> is 1, then <code>root-&gt;val + 'a'</code> becomes 98 ('b' in ASCII), resulting in the character 'b', and so on. So, the expression <code>char(root-&gt;val + 'a')</code> converts the integer value <code>root-&gt;val</code> into its corresponding lowercase alphabetical character.</li>
</ul>
</blockquote>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QJn69ay9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>During each node visit in DFS, a new string is constructed by concatenating characters. Since string concatenation takes <span class="math inline">\(O(n)\)</span> time, where <code>n</code> is the length of the resulting string, and the length of the string grows with each recursive call, the time complexity of constructing and comparing each string in the worst case(skewed tree) is <span class="math inline">\(O(n)\)</span>. Additionally, each node in the tree is visited once.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>This space is utilized for the recursive function calls on the call stack during the DFS traversal, which is equal to the height of the tree. In the worst-case scenario, when the tree is completely unbalanced (skewed), the height of the tree can be equal to the number of nodes, resulting in <span class="math inline">\(O(n)\)</span> space complexity.</p>
<p>In addition to the recursive call stack, the algorithm creates and stores a string for each node. In the worst-case scenario, where the tree is completely unbalanced and each node visit results in a new string, the total space required to store these strings becomes <span class="math inline">\(O(n \cdot n)\)</span>.</p>
<p>Thus, the overall space complexity of the algorithm is <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs-approach">Approach 2: Breadth First Search (BFS) Approach</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Apart from DFS, we can also utilize the BFS approach to achieve the same outcome. In BFS, we implement a level-order traversal method, where we traverse the nodes level by level. Initially, we initialize an empty string to store the smallest path found so far and a queue to facilitate BFS traversal.</p>
<p>Given that the tree contains integer values that need to be returned as characters, we append nodes to the queue during traversal. Each node is accompanied by its value, converted to characters.</p>
<p>During each iteration, if the current node has a left child, we append it to the queue. Additionally, we concatenate the current string with the character representation of its value and include it in the queue. Likewise, if the current node has a right child, we follow the same procedure.</p>
<p>Within each iteration, we pop the node from the front of the queue along with its corresponding string. If the node is a leaf node (i.e., it lacks both left and right children), we compare its corresponding string with the current smallest string found. If it's lexicographically smaller, we update the smallest string accordingly.</p>
<p>Once the queue becomes empty, which signifies the completion of traversal for all paths from the root to the leaf nodes, the smallest string found represents the lexicographically smallest path from the root to a leaf node in the binary tree.</p>
<p>The following is an illustration demonstrating the breadth first search approach:</p>
<p>!?!../Documents/988/bfs.json:741,291!?!</p>
<blockquote>
<p><strong>Note:</strong> One advantage of DFS over BFS is its ability to avoid the need to create new string versions for each state. Instead, it allows for continuous appending and removal from a single string as child nodes are traversed. This eliminates the need to maintain multiple string states within the queue, simplifying the process compared to the BFS approach.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty string, <code>smallestString</code>, to store the lexicographically smallest string.</li>
<li>Initialize an empty queue, <code>nodeQueue</code>, for storing node-value pairs.</li>
<li>Add the root node and its value, converted to a character, to the back of the <code>nodeQueue</code>.</li>
<li>While the <code>nodeQueue</code> is not empty:
<ul>
<li>Pop the front node and its corresponding string from the <code>nodeQueue</code>.</li>
<li>If the current node is a leaf node and if <code>smallestString</code> is empty or the current string <code>currentString</code> is lexicographically smaller than <code>smallestString</code>, update <code>smallestString</code> to be the current string <code>currentString</code>.</li>
<li>If the current node has a left child:
<ul>
<li>Add the left child and the string obtained by prepending the left child's value to <code>currentString</code> to the back of the <code>nodeQueue</code>.</li>
</ul>
</li>
<li>If the current node has a right child:
<ul>
<li>Add the right child and the string obtained by prepending the right child's value to <code>currentString</code> to the back of the <code>nodeQueue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the string <code>smallestString</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ci8dSWxd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>In each iteration of the BFS traversal, a new string is created by concatenating characters. As string concatenation takes <span class="math inline">\(O(n)\)</span> time, where n is the length of the resulting string, the time complexity of constructing and comparing each string in worst case(skewed tree) will take <span class="math inline">\(O(n)\)</span>. Additionally, each node in the tree is visited once.</p>
<p>Therefore, the overall time complexity of the BFS traversal becomes <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>At any given time during the BFS traversal, the deque could contain up to the maximum number of nodes at any level of the tree, which can be at most the number of nodes in the last level of the tree.</p>
<p>Additionally, the size of each string stored in the deque can be up to <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the space complexity in the worst-case scenario (where the tree is completely unbalanced) would be <span class="math inline">\(O(n \cdot n)\)</span>, considering the space required to store both nodes and strings.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/solve-the-sudoku-1587115621/1" target="_blank" rel="noopener noreferrer">Solve the Sudoku</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an&nbsp;incomplete&nbsp;<a href="https://www.geeksforgeeks.org/introduction-to-sudoku-puzzles-and-how-to-solve-them/"><strong>Sudoku</strong></a> configuration in terms of a 9x9&nbsp; 2-D interger square matrix, <strong>mat[][]</strong>, the task is to solve the Sudoku.&nbsp;</span><span style="font-size: 18px;">It is <strong>guaranteed </strong>that the input Sudoku will have exactly <strong>one </strong>solution.</span></p>
<p><span style="font-size: 18px;">A sudoku solution must satisfy&nbsp;all of the following rules:</span></p>
<ol>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each row.</span></li>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each column.</span></li>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each of the 9&nbsp;<code>3x3</code>&nbsp;sub-boxes of the grid.</span></li>
</ol>
<p><span style="font-size: 18px;"><strong>Note:</strong> Zeros represent blanks to be filled with numbers 1-9, while non-zero cells are <strong>fixed </strong>and cannot be changed.</span><span style="font-size: 18px;"><br /></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">mat[][] = 
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306620.png" alt="" width="260" height="212" />
</span><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;">
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306722.png" alt="" width="258" height="203" /><br /></span><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> Each row, column and 3 x 3 box of the output matrix contains unique numbers.</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">mat[][] = 
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886267/Web/Other/blobid1_1738136756.png" alt="" width="262" height="209" /><br /></span><strong style="font-size: 18px;">Output:</strong><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306722.png" alt="" width="258" height="203" /><br /><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> Each row, column and 3 x 3 box of the output matrix contains unique numbers.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />mat.size() = 9<br />mat[i].size() = 9<br />0 &le; mat[i][j] &le; 9<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/special-series-3d8fcc86/" target="_blank" rel="noopener noreferrer">Special series</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">c++</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Consider a series $$F$$&nbsp;that is defined as follows:</p>

<ul>
	<li><em>F(1) = 1</em></li>
	<li><em>F(2) = 1</em></li>
	<li><em>F(3) = 2</em></li>
	<li>For <em>n &gt;= 3</em>,&nbsp;<span class="mathjax-latex">\(F(n)^2 - F(n + 1) \times F(n -1) = (-1)^n\)</span></li>
</ul>

<p>Given two integers n and m. We need to make the <span class="mathjax-latex">\(n^{th}\)</span> term and <span class="mathjax-latex">\(m^{th}\)</span> term of the series co-prime. Find the largest positive number by which we must divide the <span class="mathjax-latex">\(n^{th}\)</span> term and <span class="mathjax-latex">\(m^{th}\)</span> term of the series such both terms become co-prime. Since, this number can be very large, print it modulo&nbsp;<span class="mathjax-latex">\(10^9 + 7\)</span>.</p>

<p><em><strong>Note</strong></em>: Two numbers are said to be co-prime if there does not exist any number greater than <em>1,&nbsp;</em>which divides both the numbers.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains an integer $$T$$ denoting the number of test cases.</li>
	<li>For each test case:
	<ul>
		<li>The first line contains a string denoting the integer $$n$$<em>.</em></li>
		<li>The second line contains an integer $$m$$.</li>
	</ul>
	</li>
</ul>

<p><strong>Output format</strong></p>

<p>For each test case in a new line, find the required largest positive number modulo&nbsp;<span class="mathjax-latex">\(10^9 + 7\)</span>.</p>

<p><strong>Constraints</strong></p>

<p><strong><span class="mathjax-latex">\(1 \le T \le 100 \\ 1 \le n \le 10^{10^5} \\ 1 \le m \le 10^9\)</span></strong></p>

<p>&nbsp;</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><ul>
	<li><em>F(3) = 2 and F(6) = 8. </em>If we divide both the terms by <em>2</em>, then they become co-prime.</li>
	<li>Thus, <em>2</em> is the required answer.</li>
</ul></div>
				</div>
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-array-into-fibonacci-sequence/description" target="_blank" rel="noopener noreferrer">Split Array into Fibonacci Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string of digits <code>num</code>, such as <code>&quot;123456579&quot;</code>. We can split it into a Fibonacci-like sequence <code>[123, 456, 579]</code>.</p>

<p>Formally, a <strong>Fibonacci-like</strong> sequence is a list <code>f</code> of non-negative integers such that:</p>

<ul>
	<li><code>0 &lt;= f[i] &lt; 2<sup>31</sup></code>, (that is, each integer fits in a <strong>32-bit</strong> signed integer type),</li>
	<li><code>f.length &gt;= 3</code>, and</li>
	<li><code>f[i] + f[i + 1] == f[i + 2]</code> for all <code>0 &lt;= i &lt; f.length - 2</code>.</li>
</ul>

<p>Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number <code>0</code> itself.</p>

<p>Return any Fibonacci-like sequence split from <code>num</code>, or return <code>[]</code> if it cannot be done.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;1101111&quot;
<strong>Output:</strong> [11,0,11,11]
<strong>Explanation:</strong> The output [110, 1, 111] would also be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;112358130&quot;
<strong>Output:</strong> []
<strong>Explanation:</strong> The task is impossible.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;0123&quot;
<strong>Output:</strong> []
<strong>Explanation:</strong> Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= num.length &lt;= 200</code></li>
	<li><code>num</code> contains only digits.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The first two elements of the array uniquely determine the rest of the sequence.</p>
<p><strong>Algorithm</strong></p>
<p>For each of the first two elements, assuming they have no leading zero, let's iterate through the rest of the string.  At each stage, we expect a number less than or equal to <code>2^31 - 1</code> that starts with the sum of the two previous numbers.</p>
<p><a href="https://leetcode.com/playground/FjRr9KuG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>S</code>, and with the requirement that the values of the answer are <span class="math inline">\(O(1)\)</span> in length.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description" target="_blank" rel="noopener noreferrer">Split a String Into the Max Number of Unique Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string&nbsp;<code>s</code><var>,</var>&nbsp;return <em>the maximum&nbsp;number of unique substrings that the given string can be split into</em>.</p>

<p>You can split string&nbsp;<code>s</code> into any list of&nbsp;<strong>non-empty substrings</strong>, where the concatenation of the substrings forms the original string.&nbsp;However, you must split the substrings such that all of them are <strong>unique</strong>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababccc&quot;
<strong>Output:</strong> 5
<strong>Explanation</strong>: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;]. Splitting like [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;cc&#39;] is not valid as you have &#39;a&#39; and &#39;b&#39; multiple times.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> 2
<strong>Explanation</strong>: One way to split maximally is [&#39;a&#39;, &#39;ba&#39;].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aa&quot;
<strong>Output:</strong> 1
<strong>Explanation</strong>: It is impossible to split the string any further.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>
	<p><code>1 &lt;= s.length&nbsp;&lt;= 16</code></p>
	</li>
	<li>
	<p><code>s</code> contains&nbsp;only lower case English letters.</p>
	</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>There are many patterns that can be recognized when solving data structures and algorithms (DSA) questions. Identifying these patterns by reading can help you solve problems more efficiently within your limited time. Over time and with practice, people start recognizing these patterns.</p>
<p>So this time before diving into the answer, letâ€™s understand a few general patterns that you can use in your future journey:</p>
<p>Sorted Input:</p>
<ul>
<li>Apply binary search for efficient element lookup.</li>
<li>Use the two-pointer technique for problems involving pairs or segments.</li>
</ul>
<p>Unsorted Input:</p>
<ul>
<li>Apply dynamic programming for questions related to counting ways or optimizing values.</li>
<li>Use backtracking for problems that ask for all possibilities or combinations (this is also a suitable fallback if dynamic programming isnâ€™t going to work).</li>
<li>Use a Trie for prefix matching and string-building scenarios.</li>
<li>Use a hash map or set to find specific elements quickly.</li>
<li>Implement a monotonic stack or sliding window technique for managing elements while continuously finding maximum or minimum values.</li>
</ul>
<p>Input is a Graph or Tree:</p>
<ul>
<li>Use DFS to explore all paths or when the question does not require finding the shortest path.</li>
<li>Use BFS when the question asks for the shortest path or fewest steps.</li>
<li>For binary trees, use DFS if the problem involves exploring specific depths or levels.</li>
</ul>
<p>Linked List Input:</p>
<ul>
<li>Use techniques involving slow and fast pointers or &quot;prev&quot; and &quot;dummy&quot; pointers to facilitate certain operations if you are unsure how to achieve a specific outcome.</li>
</ul>
<blockquote>
<p>Note: There's so much more to this pattern! We just wanted to give you a glimpse of what pattern recognition boils down to in its simplest form. Feel free to add your own flair and create a detailed chart!</p>
</blockquote>
<p><img src="../Figures/1593/1593_mintotal.png" alt="gist" /></p>
</br>
<p>In the context of this problem, many of you might initially assume that a DP approach would yield the correct solution, but it doesnâ€™t work well here.</p>
<p>Suppose weâ€™re currently examining the substring starting at <code>start</code> (our current index). Our goal is to split the remaining substring from <code>start</code> to <code>s.size() - 1</code> into smaller substrings such that:</p>
<ul>
<li>Each substring is non-empty.</li>
<li>Each substring is unique, meaning it doesnâ€™t match any substring weâ€™ve already taken.</li>
</ul>
<p>To solve this, we:</p>
<ul>
<li>Consider each possible substring starting from <code>start</code>, such as <code>s[start:start+1]</code>, <code>s[start:start+2]</code>, and so on, up to <code>s[start:s.size()]</code>.</li>
<li>Attempt to add each of these substrings to our <code>seen</code> set and then recursively continue with the remaining characters.</li>
<li>Only proceed if the substring, letâ€™s call it <code>substring</code>, does not already exist in <code>seen</code>.</li>
</ul>
<p>This is where we run into a limitation with DP: finding whether <code>substring</code> exists in the set of substrings from <code>0</code> to <code>start-1</code> is challenging. There are numerous ways to partition those characters into unique substrings, and the results vary depending on how those partitions are made. This makes the DP approach ineffective here, as the uniqueness constraint depends on the precise configuration of substrings.</p>
<p>Looking at the constraints, we can see that DFS combined with backtracking tends to have exponential complexity.</p>
<p>Specifically when the constraints are like this <span class="math inline">\(1 < n \leq 16\)</span>. The expected time complexity likely involves <span class="math inline">\(O(2^n)\)</span>. Any higher base, such as <span class="math inline">\(20\)</span> or a factorial, will be too slow (for instance, <span class="math inline">\(3^{20} \approx 3.5\)</span> billion, and <span class="math inline">\(20!\)</span> is significantly larger). An <span class="math inline">\(O(2^n)\)</span> complexity usually implies that, given a collection of elements, you are considering all subsets or subsequencesâ€”meaning for each element, you have two choices: either take it or leave it.</p>
<p>Since this bound is quite small, most algorithms will be efficient enough. Therefore, consider backtracking and recursion in these types of cases.</p>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>We start at the beginning of the string and generate substrings one by one. Each substring is checked against a set of previously seen substrings to ensure it is unique.</p>
<p>We initialize a set called <code>seen</code> to track the substrings we have already included in our current split. Then we can begin by checking if we have reached the end of the string. If we have, we return 0, indicating that no further substrings can be added.</p>
<p>Next to hold the maximum number of unique substrings we can form we will set a variable <code>maxCount</code> to zero. We then enter a loop, generating substrings by extending the endpoint from the current starting position. For each possible endpoint, we extract a substring and check if it is in the <code>seen</code> set.</p>
<p>If the substring is not present in the set, we add it to the <code>seen</code> set. We then make a recursive call, moving the starting point to the end of the current substring, to explore further splits from this new position. After the recursive call, we remove the substring from the <code>seen</code> set to backtrack and explore other potential substrings.</p>
<p>By the end of the loop, we return the highest count of unique substrings we found during the exploration.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty unordered set <code>seen</code> to track unique substrings encountered.</p>
</li>
<li>
<p>Call the <code>backtrack</code> function starting from index <code>0</code> with the empty <code>seen</code> set.</p>
</li>
<li>
<p>In the <code>backtrack</code> function:</p>
<ul>
<li>
<p>If <code>start</code> equals the size of the string <code>s</code>, return <code>0</code> (base case: no more substrings to add).</p>
</li>
<li>
<p>Initialize <code>maxCount</code> to <code>0</code> to track the maximum number of unique substrings.</p>
</li>
<li>
<p>Use a loop to iterate over all possible substrings starting from index <code>start</code>:</p>
<ul>
<li>For each <code>end</code> from <code>start + 1</code> to the size of <code>s</code>, extract the substring <code>s.substr(start, end - start)</code>.</li>
<li>If the substring is unique (i.e., not found in <code>seen</code>):
<ul>
<li>Insert the substring into the <code>seen</code> set.</li>
<li>Recursively call <code>backtrack</code> for the next position (<code>end</code>) and update <code>maxCount</code> with the maximum of its current value and <code>1 + backtrack(s, end, seen)</code> (including the current substring).</li>
<li>Backtrack by removing the substring from the <code>seen</code> set to explore other possibilities.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After evaluating all substrings, return <code>maxCount</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5jz6Euc3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <span class="math inline">\(s\)</span>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2 \cdot 2^n)\)</span></p>
<p>The function recursively explores all possible substrings of the input string. For each starting index <code>start</code>, it iterates over every possible end index <code>end</code>, which can be up to <span class="math inline">\(n\)</span>, creating a nested loop structure that takes <span class="math inline">\(O(n^2)\)</span> per recursive depth due to the substring creation operation.</p>
<p>Specifically, the substring operation <span class="math inline">\(s[start:end]\)</span> takes <span class="math inline">\(O(k)\)</span> time where <span class="math inline">\(k\)</span> is the length of the substring. Over all recursive calls, this results in <span class="math inline">\(O(n^2)\)</span> for each split due to the cumulative cost of substring operations at each level.</p>
<p>In the worst case, there are <span class="math inline">\(2^n\)</span> possible ways to partition the string, as each character can either start a new substring or continue the previous one, forming an exponential number of combinations. Thus, the recursion branches exponentially, contributing an additional <span class="math inline">\(O(2^n)\)</span> factor.</p>
<p>Combining these, we get a total time complexity of <span class="math inline">\(O(n^2 \cdot 2^n)\)</span>. The <span class="math inline">\(O(n^2)\)</span> factor accounts for the cost of generating substrings within each partition, and the <span class="math inline">\(O(2^n)\)</span> factor represents the exponential number of partitioning combinations.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The maximum depth of the recursion can go up to <span class="math inline">\(n\)</span> (in the worst case, where we split every single character into its own substring). Therefore, the call stack contributes <span class="math inline">\(O(n)\)</span>.</p>
<p>The unordered set <code>seen</code> can store at most <span class="math inline">\(n\)</span> unique substrings. In the worst case, this could also be <span class="math inline">\(O(n)\)</span>, though in practice, the number of unique substrings is likely less than <span class="math inline">\(n\)</span> due to repetitions.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-backtracking-with-pruning">Approach 2: Backtracking with Pruning</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can build upon the first approach by adding a pruning mechanism to improve efficiency. We still begin with the same initial setup, using a set to keep track of unique substrings and a variable to store the maximum count of unique substrings found.</p>
<p>As with approach 1, we check if we have reached the end of the string. If we have, we update our maximum count if the current count of unique substrings exceeds it. However, In optimization problems like this, the usual trick of pruning is not to do further work if you can't improve the current answer.</p>
<p>We check whether the current count of unique substrings, combined with the remaining characters in the string, can yield a higher count than what we have already found. If this total cannot exceed our maximum count, we return immediately, skipping unnecessary calculations. This step significantly reduces the number of recursive calls, especially for longer strings.</p>
<p>More technically: If we're currently at <code>start</code>, and we've counted <code>count</code> unique substrings so far (stored in the <code>seen</code> set), and we take <code>s[start:end]</code> as a new unique substring, then there are at most <code>s.size() - end</code> unique substrings possible from <code>end</code> to the end of <code>s</code>.</p>
<p>This gives us a total of <code>count + 1 + (s.size() - end)</code> as the best possible result for the current choice of <code>s[start:end]</code>. For this to potentially improve our maximum so far, it must be greater than <code>maxCount</code>. If itâ€™s not, we would be wasting work by exploring options that can, at best, only match the current <code>maxCount</code>.</p>
<p>So this let us:</p>
<ul>
<li>Return early from recursive calls if we canâ€™t improve on the current best.</li>
<li>When iterating over <code>end</code>, use the condition <code>if (count + (s.size() - start) &lt;= maxCount) return;</code> to determine an upper bound for <code>end</code>, dynamically limiting the range and avoiding unnecessary recursion.</li>
</ul>
<p>Next, we proceed to generate substrings just as in the backtracking approach. For each substring, we verify its uniqueness against the <code>seen</code> set. If it is unique, we add it to the set and continue exploring the remaining string by making a recursive call with the updated starting position and count of unique substrings. After the recursive call, we backtrack by removing the substring from the set.</p>
<p>In the end, return the maximum count of unique substrings found.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty unordered set <code>seen</code> to keep track of unique substrings and set <code>maxCount</code> to <code>0</code>.</p>
</li>
<li>
<p>Call the <code>backtrack</code> function starting from index <code>0</code>:</p>
<ul>
<li>Pass the string <code>s</code>, current starting index <code>0</code>, the <code>seen</code> set, the current count of unique substrings <code>0</code>, and the reference to <code>maxCount</code>.</li>
</ul>
</li>
<li>
<p>In the <code>backtrack</code> function:</p>
<ul>
<li>Prune: If the current count plus the number of remaining characters cannot exceed <code>maxCount</code>, return immediately to avoid unnecessary computations.</li>
<li>Base case: If the <code>start</code> index reaches the end of the string, update <code>maxCount</code> to be a maximum of <code>maxCount</code> and <code>count</code>.</li>
<li>Iterate through all possible substrings starting from the current <code>start</code> index:
<ul>
<li>For each ending index <code>end</code>, extract the substring from <code>s[start:end]</code>.</li>
<li>If the substring is unique (not found in <code>seen</code>):
<ul>
<li>Add the substring to the <code>seen</code> set.</li>
<li>Recursively call <code>backtrack</code> to explore further unique substrings from the next position <code>end</code> with an incremented count.</li>
<li>Backtrack by removing the substring from the <code>seen</code> set to explore other possibilities.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After evaluating all substrings, return <code>maxCount</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ScvnCEKu/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>times</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot 2^n)\)</span></p>
<p>The algorithm uses backtracking to explore all possible unique substrings. In the worst case, it may try every substring starting from each position in the string, which is exponential.</p>
<p>Specifically, the substring operation <span class="math inline">\(s[start:end]\)</span> takes <span class="math inline">\(O(k)\)</span> time where <span class="math inline">\(k\)</span> is the length of the substring. Over all recursive calls, this results in <span class="math inline">\(O(n^2)\)</span> for each split due to the cumulative cost of substring operations at each level.</p>
<p>In the worst case, there are <span class="math inline">\(2^n\)</span> possible ways to partition the string, as each character can either start a new substring or continue the previous one, forming an exponential number of combinations. Thus, the recursion branches exponentially, contributing an additional <span class="math inline">\(O(2^n)\)</span> factor.</p>
<p>Combining these, we get a total time complexity of <span class="math inline">\(O(n^2 \cdot 2^n)\)</span>. We might generate up to <span class="math inline">\(2^n\)</span> unique combinations of substrings, so the impact on the overall time complexity is encompassed in the <span class="math inline">\(O(n^2 \cdot 2^n)\)</span> term.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is largely determined by the <code>seen</code>, which can store up to <span class="math inline">\(n\)</span> unique substrings in the worst case. This contributes <span class="math inline">\(O(n)\)</span> to the space complexity.</p>
<p>The maximum depth of the recursive call stack can also go up to <span class="math inline">\(n\)</span> in the worst case if the string is such that we keep making recursive calls without hitting the base case quickly. This also contributes <span class="math inline">\(O(n)\)</span> to the space complexity.</p>
<p>Thus, the overall space complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/description" target="_blank" rel="noopener noreferrer">Splitting a String Into Descending Consecutive Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that consists of only digits.</p>

<p>Check if we can split <code>s</code> into <strong>two or more non-empty substrings</strong> such that the <strong>numerical values</strong> of the substrings are in <strong>descending order</strong> and the <strong>difference</strong> between numerical values of every two <strong>adjacent</strong> <strong>substrings</strong> is equal to <code>1</code>.</p>

<ul>
	<li>For example, the string <code>s = &quot;0090089&quot;</code> can be split into <code>[&quot;0090&quot;, &quot;089&quot;]</code> with numerical values <code>[90,89]</code>. The values are in descending order and adjacent values differ by <code>1</code>, so this way is valid.</li>
	<li>Another example, the string <code>s = &quot;001&quot;</code> can be split into <code>[&quot;0&quot;, &quot;01&quot;]</code>, <code>[&quot;00&quot;, &quot;1&quot;]</code>, or <code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>. However all the ways are invalid because they have numerical values <code>[0,1]</code>, <code>[0,1]</code>, and <code>[0,0,1]</code> respectively, all of which are not in descending order.</li>
</ul>

<p>Return <code>true</code> <em>if it is possible to split</em> <code>s</code>â€‹â€‹â€‹â€‹â€‹â€‹ <em>as described above</em><em>, or </em><code>false</code><em> otherwise.</em></p>

<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1234&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no valid way to split s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;050043&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> s can be split into [&quot;05&quot;, &quot;004&quot;, &quot;3&quot;] with numerical values [5,4,3].
The values are in descending order with adjacent values differing by 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;9080701&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no valid way to split s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 20</code></li>
	<li><code>s</code> only consists of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stickers-to-spell-word/description" target="_blank" rel="noopener noreferrer">Stickers to Spell Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>n</code> different types of <code>stickers</code>. Each sticker has a lowercase English word on it.</p>

<p>You would like to spell out the given string <code>target</code> by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.</p>

<p>Return <em>the minimum number of stickers that you need to spell out </em><code>target</code>. If the task is impossible, return <code>-1</code>.</p>

<p><strong>Note:</strong> In all test cases, all words were chosen randomly from the <code>1000</code> most common US English words, and <code>target</code> was chosen as a concatenation of two random words.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;with&quot;,&quot;example&quot;,&quot;science&quot;], target = &quot;thehat&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong>
We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.
After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.
Also, this is the minimum number of stickers necessary to form the target string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;notice&quot;,&quot;possible&quot;], target = &quot;basicbasic&quot;
<strong>Output:</strong> -1
Explanation:
We cannot form the target &quot;basicbasic&quot; from cutting letters from the given stickers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stickers.length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= target.length &lt;= 15</code></li>
	<li><code>stickers[i]</code> and <code>target</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-optimized-exhaustive-search">Approach 1: Optimized Exhaustive Search</h3>
<br>
<p><strong>Intuition</strong></p>
<p>A natural answer is to exhaustively search for combinations of stickers. Because the data is randomized, there are many heuristics available to us that will make this faster.</p>
<ul>
<li>
<p>For all stickers, we can ignore any letters that are not in the target word.</p>
</li>
<li>
<p>When our candidate's answer won't be smaller than an answer we have already found, we can stop searching this path.</p>
</li>
<li>
<p>We should try to have our exhaustive search bound to the answer as soon as possible, so the effect described in the above point happens more often.</p>
</li>
<li>
<p>When a sticker dominates another, we shouldn't include the dominant sticker in our sticker collection.  [Here, we say a sticker <code>A</code> dominates <code>B</code> if <code>A.count(letter) &gt;= B.count(letter)</code> for all letters.]</p>
</li>
</ul>
<br>
<p><strong>Algorithm</strong></p>
<p>Firstly, for each sticker, let's create a count of that sticker (a mapping <code>letter -&gt; sticker.count(letter)</code>) that does not consider letters not in the target word.  Let <code>A</code> be an array of these counts.  Also, let's create <code>t_count</code>, a count of our <code>target</code> word.</p>
<p>Secondly, let's remove dominated stickers. Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren't dominated are included in our collection.</p>
<p>We are now ready to begin our exhaustive search. A call to <code>search(ans)</code> denotes that we want to decide the minimum number of stickers we can use in <code>A</code> to satisfy the target count <code>t_count</code>. <code>ans</code> will store the currently formed answer, and <code>best</code> will store the current best answer.</p>
<p>If our current answer can't beat our current best answer, we should stop searching.  Also, if there are no stickers left and our target is satisfied, we should update our answer.</p>
<p>Otherwise, we want to know the maximum number of these stickers we can use. For example, if this sticker is <code>'abb'</code> and our target is <code>'aaabbbbccccc'</code>, then we could use a maximum of 3 stickers.  This is the maximum of <code>math.ceil(target.count(letter) / sticker.count(letter))</code>, taken over all <code>letter</code>s in <code>sticker</code>.  Let's call this quantity <code>used</code>.</p>
<p>After, for the sticker we are currently considering, we try to use <code>used</code> of them, then <code>used - 1</code>, <code>used - 2</code>, and so on. The reason we do it in this order is so that we can arrive at a value for <code>best</code> more quickly, which will stop other branches of our exhaustive search from continuing.</p>
<p>The Python version of this solution showcases using <code>collections.Counter</code> as a way to simplify some code sections, whereas the Java solution sticks to arrays.</p>
<p><a href="https://leetcode.com/playground/KP3fS7G3/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Let <span class="math inline">\(N\)</span> be the number of stickers, and <span class="math inline">\(T\)</span> be the number of letters in the target word. A bound for time complexity is <span class="math inline">\(O(N^{T+1} T^2)\)</span>: for each sticker, we'll have to try using it up to <span class="math inline">\(T+1\)</span> times, and updating our target count costs <span class="math inline">\(O(T)\)</span>, which we do up to <span class="math inline">\(T\)</span> times. Alternatively, since the answer is bounded at <span class="math inline">\(T\)</span>, we can prove that we can only search up to <span class="math inline">\(\binom{N+T-1}{T-1}\)</span> times. This would be <span class="math inline">\(O(\binom{N+T-1}{T-1} T^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N+T)\)</span>, to store <code>stickersCount</code>, <code>targetCount</code>, and handle the recursive call stack when calling <code>search</code>.</p>
</li>
</ul>
<br>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<br>
<p><strong>Intuition</strong></p>
<p>Suppose we need <code>dp[state]</code> stickers to satisfy all <code>target[i]</code>'s for which the <code>i</code>-th bit of <code>state</code> is set. We would like to know <code>dp[(1 &lt;&lt; len(target)) - 1]</code>.</p>
<br>
<p><strong>Algorithm</strong></p>
<p>For each <code>state</code>, let's work with it as <code>now</code> and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of <code>state</code>, we set the bit (<code>now |= 1 &lt;&lt; i</code>). In the end, we know <code>now</code> is the result of applying that sticker to <code>state</code>, and we update our <code>dp</code> appropriately.</p>
<p>When using Python, we will need some extra techniques from <em>Approach #1</em> to pass in time.</p>
<p><a href="https://leetcode.com/playground/JTZ2SYco/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(2^T * S * T)\)</span> where <span class="math inline">\(S\)</span> is the total number of letters in all stickers, and <span class="math inline">\(T\)</span> is the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(2^T)\)</span>, the space used by <code>dp</code>.</p>
</li>
</ul>
<br></div>
				</div>
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subsets/description" target="_blank" rel="noopener noreferrer">Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword="subset"><em>subsets</em></span> <em>(the power set)</em>.</p>

<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0]
<strong>Output:</strong> [[],[0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
	<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="overview-solution-pattern">Overview: Solution Pattern</h3>
<p>Let us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.</p>
<p>First, their solution space is often quite large:</p>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n">Permutations</a>: <span class="math inline">\(N!\)</span>.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations">Combinations</a>: <span class="math inline">\(C_N^k = \frac{N!}{(N - k)! k!}\)</span></p>
</li>
<li>
<p>Subsets: <span class="math inline">\(2^N\)</span>, since each element could be absent or present.</p>
</li>
</ul>
<p>Given their exponential solution space, it is tricky to ensure that the generated solutions are <em><strong>complete</strong></em> and <em><strong>non-redundant</strong></em>. It is essential to have a clear and easy-to-reason strategy.</p>
<p>There are generally three strategies to do it:</p>
<ul>
<li>
<p>Iterative</p>
</li>
<li>
<p>Recursion/Backtracking</p>
</li>
<li>
<p>Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.</p>
</li>
</ul>
<p>As one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.</p>
<p>Besides, as a bonus, it generates lexicographically sorted output for the sorted inputs.</p>
<hr />
<h3 id="approach-1-cascading">Approach 1: Cascading</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones.</p>
<p><img src="../Figures/78/recursion.png" alt="diff" /></p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/GfSoguWr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N \times 2^N)\)</span> to generate all subsets and then copy them into the output list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N \times 2^N)\)</span>. This is exactly the number of solutions for subsets multiplied by the number <span class="math inline">\(N\)</span> of elements to keep for each subset.</p>
<ul>
<li>For a given number, it could be present or absent (<em>i.e.</em> binary choice) in a subset solution. As a result, for <span class="math inline">\(N\)</span> numbers, we would have in total <span class="math inline">\(2^N\)</span> choices (solutions).<br />
<br /><br />
<br /></li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-backtracking">Approach 2: Backtracking</h3>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Power set is all possible combinations of all possible <em>lengths</em>, from 0 to n.</p>
</blockquote>
<p>Given the definition, the problem can also be interpreted as finding the <em>power set</em> from a sequence.</p>
<p>So, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of <em>backtracking</em> technique.</p>
<p><img src="../Figures/78/combinations.png" alt="diff" /></p>
<blockquote>
<p><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">Backtracking</a> is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be <em>not</em> a solution (or at least not the <em>last</em> one), the backtracking algorithm discards it by making some changes on the previous step, <em>i.e.</em> <em>backtracks</em> and then tries again.</p>
</blockquote>
<p><img src="../Figures/78/backtracking.png" alt="diff" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<p>We define a backtrack function named <code>backtrack(first, curr)</code> that takes the index of the first element to add and a current combination as arguments.</p>
<ul>
<li>
<p>If the current combination is done, we add the combination to the final output.</p>
</li>
<li>
<p>Otherwise, we iterate over the indexes <code>i</code> from <code>first</code> to the length of the entire sequence <code>n</code>.</p>
<ul>
<li>
<p>Add integer <code>nums[i]</code> into the current combination <code>curr</code>.</p>
</li>
<li>
<p>Proceed to add more integers into the combination: <code>backtrack(i + 1, curr)</code>.</p>
</li>
<li>
<p>Backtrack by removing <code>nums[i]</code> from <code>curr</code>.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/X6GCLJ3t/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N \times 2^N)\)</span> to generate all subsets and then copy them into the output list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. We are using <span class="math inline">\(O(N)\)</span> space to maintain <code>curr</code>, and are modifying <code>curr</code> in-place with backtracking. Note that for space complexity analysis, we do not count space that is <em>only</em> used for the purpose of returning output, so the <code>output</code> array is ignored.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-lexicographic-binary-sorted-subsets">Approach 3: Lexicographic (Binary Sorted) Subsets</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The idea of this solution is originated from <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">Donald E. Knuth</a>.</p>
<blockquote>
<p>The idea is that we map each subset to a bitmask of length n,<br />
where <code>1</code> on the i<em>th</em> position in bitmask means the presence of <code>nums[i]</code><br />
in the subset, and <code>0</code> means its absence.</p>
</blockquote>
<p><img src="../Figures/78/bitmask4.png" alt="diff" /></p>
<p>For instance, the bitmask <code>0..00</code> (all zeros) corresponds to an empty subset,<br />
and the bitmask <code>1..11</code> (all ones) corresponds to the entire input array <code>nums</code>.</p>
<p>Hence to solve the initial problem, we just need to generate n bitmasks<br />
from <code>0..00</code> to <code>1..11</code>.</p>
<p>It might seem simple at first glance to generate binary numbers, but<br />
the real problem here is how to deal with<br />
<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding">zero left padding</a>,<br />
because one has to generate bitmasks of fixed length, <em>i.e.</em> <code>001</code> and not just <code>1</code>.<br />
For that one could use standard bit manipulation trick:</p>
<p><a href="https://leetcode.com/playground/PtHUHaeY/shared">code</a></p>
<p>or keep it simple stupid and shift iteration limits:</p>
<p><a href="https://leetcode.com/playground/4XWEGcWd/shared">code</a></p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Generate all possible binary bitmasks of length n.</p>
</li>
<li>
<p>Map a subset to each bitmask:<br />
<code>1</code> on the i<em>th</em> position in bitmask means the presence of <code>nums[i]</code><br />
in the subset, and <code>0</code> means its absence.</p>
</li>
<li>
<p>Return output list.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/DwHHy2yt/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N \times 2^N)\)</span> to generate all subsets<br />
and then copy them into output list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> to store the bitset<br />
of length <span class="math inline">\(N\)</span>. Note that for space complexity analysis, we do not count space that is <em>only</em> used for the purpose of returning output, so the <code>output</code> array is ignored.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/subsets-1613027340/1" target="_blank" rel="noopener noreferrer">Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of distinct positive integers, your task is to find all its subsets. The subsets should be returned in lexicographical order.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [1, 2, 3]
<strong>Output: </strong>[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
<strong>Explanation: <br /></strong>The subsets of [1, 2, 3] in lexicographical order are:
[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [1, 2]
<strong>Output: </strong>[[], [1], [1, 2], [2]]
<strong>Explanation:</strong>
The subsets of [1, 2] in lexicographical order are:
[], [1], [1, 2], [2]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [10]
<strong>Output: </strong>[[], [10]]
<strong>Explanation: </strong>For the array with a single element [10]<span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">, the subsets are [ ] </span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">and [10]</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.</span></span></pre>
<div><span style="font-size: 14pt;"><strong>Constraints :</strong></span></div>
<div><span style="font-size: 14pt;">1 &le; arr.size() &le; 10</span></div>
<div><span style="font-size: 14pt;">1 &le; arr[i] &le; </span><span style="font-size: 14pt;">10</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subsets-ii/description" target="_blank" rel="noopener noreferrer">Subsets II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> <span data-keyword="subset"><em>subsets</em></span><em> (the power set)</em>.</p>

<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,2]
<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [[],[0]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10</code></li>
	<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sudoku-solver/description" target="_blank" rel="noopener noreferrer">Sudoku Solver</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>

<ol>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>
</ol>

<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" style="height:250px; width:250px" />
<pre>
<strong>Input:</strong> board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Output:</strong> [[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Explanation:</strong>&nbsp;The input board is shown above and the only valid solution is shown below:

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" style="height:250px; width:250px" />
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 9</code></li>
	<li><code>board[i].length == 9</code></li>
	<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>
	<li>It is <strong>guaranteed</strong> that the input board has only one solution.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-all-subset-xor-totals/description" target="_blank" rel="noopener noreferrer">Sum of All Subset XOR Totals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">math</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>XOR total</strong> of an array is defined as the bitwise <code>XOR</code> of<strong> all its elements</strong>, or <code>0</code> if the array is<strong> empty</strong>.</p>

<ul>
	<li>For example, the <strong>XOR total</strong> of the array <code>[2,5,6]</code> is <code>2 XOR 5 XOR 6 = 1</code>.</li>
</ul>

<p>Given an array <code>nums</code>, return <em>the <strong>sum</strong> of all <strong>XOR totals</strong> for every <strong>subset</strong> of </em><code>nums</code>.&nbsp;</p>

<p><strong>Note:</strong> Subsets with the <strong>same</strong> elements should be counted <strong>multiple</strong> times.</p>

<p>An array <code>a</code> is a <strong>subset</strong> of an array <code>b</code> if <code>a</code> can be obtained from <code>b</code> by deleting some (possibly zero) elements of <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3]
<strong>Output:</strong> 6
<strong>Explanation: </strong>The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,1,6]
<strong>Output:</strong> 28
<strong>Explanation: </strong>The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,5,6,7,8]
<strong>Output:</strong> 480
<strong>Explanation:</strong> The sum of all XOR totals for every subset is 480.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 12</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The task is to calculate the sum of the <strong>XOR</strong> totals for every subset of <code>nums</code>.</p>
<p>All the possible subsets are known as the power set, which includes all combinations of different lengths, ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(N\)</span>.</p>
<p>Relevant properties of <strong>XOR</strong>:</p>
<ul>
<li>The <strong>XOR</strong> operator <code>^</code> evaluates to true for two operands if exactly one of them is true.</li>
<li>The <strong>XOR</strong> total of a subset with one element is that element.</li>
<li>The <strong>XOR</strong> total of a subset with multiple elements is the <strong>XOR</strong> of all of the elements.</li>
</ul>
<p>The solutions in this editorial utilize the following concepts:</p>
<ul>
<li><strong>XOR</strong> and <strong>OR</strong> bitwise operations: <a href="https://leetcode.com/explore/learn/card/bit-manipulation/669/bit-manipulation-concepts/4496/">Bitwise Operator Explore Card</a></li>
<li>Backtracking: <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">Backtracking Explore Card</a></li>
</ul>
<p>If you are not familiar with a topic, we recommend you read the corresponding linked explore card.</p>
<hr />
<h3 id="approach-1-generate-all-subsets-using-backtracking">Approach 1: Generate All Subsets Using Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>We can break calculating the sum of the subset <strong>XOR</strong> totals into three main steps.</p>
<ol>
<li>Generate all the subsets.</li>
<li>Calculate the <strong>XOR</strong> total for each subset.</li>
<li>Return the sum of the subset <strong>XOR</strong> totals.</li>
</ol>
<p>A common way to generate subsets is using backtracking.</p>
<p>We will use a list of lists to store the subsets, where each list is a subset. We can create a function <code>generateSubsets</code> that recursively generates all the subsets for the array <code>nums</code>.</p>
<p>For each element, we can include it in the subset or not include it.</p>
<p><img src="../Figures/1863/1863_subsets.png" alt="subsets" /></p>
<p>The bottom row of the diagram shows all of the subsets for the input.</p>
<p>For a given element from <code>nums</code>, we can call <code>generateSubsets</code> with the element included in the subset and without the element in the subset.</p>
<p>For the first element, we can start building subsets in two ways:</p>
<ol>
<li>Include the element in the subset and continue choosing other elements. Add the element to the subset, call <code>generateSubsets</code> with the next element, and then remove the element from the subset so we can explore other subsets.</li>
<li>Not include the element in the subset and continue choosing other elements. Call <code>generateSubsets</code> with the next element.</li>
</ol>
<p>Our base case is when we pass the last index of <code>nums</code> because there are no more elements to try adding to the subset. We add the subset to the list of subsets and return.</p>
<p>Then, we use a nested loop to calculate the sum of the subset <strong>XOR</strong> totals. The outer loop iterates through the subsets, adding each subset's <strong>XOR</strong> total to the result. The inner loop iterates through each element in a subset, calculating the running <strong>XOR</strong> total for that subset.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a list of lists <code>subsets</code>.</li>
<li>Declare a recursive function <code>generateSubsets</code> that generates all the subsets of <code>nums</code> using backtracking and add them to the list.
<ul>
<li>Base case: <code>index</code> equals the size of <code>nums</code>. The current subset is complete. Add it to <code>subsets</code> and return.</li>
<li>Include the current element <code>nums[i]</code> in the current subset. Add the element to the subset, call <code>generateSubsets</code> with the next element, and then remove the element from the subset.</li>
<li>Generate the next subset without the current element. Call <code>generateSubsets</code> with the next element.</li>
</ul>
</li>
<li>Initialize a variable <code>result</code> to <code>0</code>.</li>
<li>For each <code>subset</code> in <code>subsets</code>:
<ul>
<li>Set <code>subsetXORTotal</code> to <code>0</code>.</li>
<li>For each element <code>num</code> in the subset, <strong>XOR</strong> <code>num</code> with the <code>subsetXORTotal</code> to calculate the <strong>XOR</strong> total of the subset.</li>
<li>Add the current subset's <code>subsetXORTotal</code> to the <code>result</code>.</li>
</ul>
</li>
<li>Return the <code>result</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/9qz46r4G/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot 2^N)\)</span></p>
<p>Each element can be included or excluded from any given subset, meaning there are <span class="math inline">\(2^N\)</span> possible subsets. Generating them takes <span class="math inline">\(O(2^N)\)</span>.</p>
<p>We iterate through each of the <span class="math inline">\(2^N\)</span> subsets to calculate the result. The average size of each subset is approximately <span class="math inline">\(\frac{N}{2}\)</span>, so it takes <span class="math inline">\(O(\frac{N}{2} \cdot 2^N)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(2^N + \frac{N}{2} \cdot 2^N)\)</span>, which we can represent as <span class="math inline">\(O(N \cdot 2^N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot 2^N)\)</span></p>
<p>The <code>subsets</code> list will contain <span class="math inline">\(2^N\)</span> subsets with an average size of <span class="math inline">\(\frac{N}{2}\)</span>, so it requires <span class="math inline">\(O(\frac{N}{2} \cdot 2^N)\)</span> space.</p>
<p>The recursion depth can reach size <span class="math inline">\(N\)</span> because we generate subsets with and without each index in <code>nums</code>. The recursive call stack may use up to <span class="math inline">\(O(N)\)</span> space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(N + \frac{N}{2} \cdot 2^N)\)</span>, which we can represent as <span class="math inline">\(O(N \cdot 2^N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-backtracking">Approach 2: Optimized Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The previous approach generated each subset and then calculated the running <strong>XOR</strong> totals and sum. We can develop a more efficient approach by performing these calculations while we generate the subsets.</p>
<p>We can calculate the running <strong>XOR</strong> total for the current subset by passing the <strong>XOR</strong> of the running <strong>XOR</strong> and the current element in <code>nums</code> as a parameter to our helper function.</p>
<p>For the current subset, we save the <strong>XOR</strong> total by adding the element to the subset in the variable <code>withElement</code> and the <strong>XOR</strong> total by not adding the element in the variable <code>withoutElement</code>. Each of these variables represents the <strong>XOR</strong> total of a different subset, so we can return their sum to compute the running total for those two subsets.</p>
<p>The process is visualized below:</p>
<p><img src="../Figures/1863/1863_XORsum.png" alt="XOR Sum" /></p>
<p>The subsets are shown in the above image for visualization purposes; the algorithm does not explicitly store the subsets in lists.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Declare a recursive function <code>XORSum</code> that calculates the sum of the subset <strong>XOR</strong> totals using backtracking. The parameters are <code>nums</code>, <code>index</code>, and <code>currentXOR</code>.
<ul>
<li>Base case: <code>index</code> equals the size of <code>nums</code>. The current subset is complete. Return  <code>currentXOR</code>.</li>
<li>Calculate the sum of the subset <strong>XOR</strong> totals when the current element <code>nums[i]</code> is added to the current subset. Save the result of <code>XORSum</code> with the next element and <code>currentXOR ^ nums[index]</code> as <code>withElement</code>.</li>
<li>Calculate the sum of the subset <strong>XOR</strong> totals when the current element <code>nums[i]</code> is not added to the current subset. Save the result of <code>XORSum</code> with the next element and <code>currentXOR</code> as <code>withoutElement</code>.</li>
<li>Return the sum of <code>withElement</code> and <code>withoutElement</code>, which is the sum of the subset <strong>XOR</strong> totals.</li>
</ul>
</li>
<li>Return the result of <code>XORSum</code> with <code>nums</code>. The initial index and initial <code>currentXOR</code> are both <code>0</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/EvtDBKgr/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^N)\)</span></p>
<p>We traverse through each of the <span class="math inline">\(2^N\)</span> subsets to calculate the result.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The recursion depth can reach <span class="math inline">\(N\)</span> because we calculate the <strong>XOR</strong> totals for each of the <span class="math inline">\(N\)</span> indices in <code>nums</code>. The recursive call stack may require up to <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-bit-manipulation">Approach 3: Bit Manipulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p><strong>XOR</strong> is a bitwise operation, so we may be able to develop a more efficient approach using bit manipulation.</p>
<p>Working backward can help develop bit manipulation approaches.</p>
<p>Let's start by considering what bits are set in the result.</p>
<blockquote>
<p>Input: nums = [1,3] (N = 2) Output = 6 = <code>110</code><br />
Input: nums = [5,1,6] (N = 3) Output = 28 = <code>11100</code><br />
Input: nums = [3,4,5,6,7,8] (N = 6) Output = 480 = <code>111100000</code></p>
</blockquote>
<p>Let's look for patterns in the output. Focusing on the bit representation, we can observe a pattern that the least significant (rightmost) <code>N - 1</code> bits in the binary representation are <code>0</code>.</p>
<p>Let's see if we can break the pattern by testing more inputs.</p>
<blockquote>
<p>Input: nums = [1] (N = 1) Output = 1 = <code>1</code></p>
</blockquote>
<p><code>1 - 1 = 0</code> so the least significant <code>N - 1</code> (0) bits in the binary representation are still <code>0</code>. All test cases will follow this pattern. The reason for this is further explained in the dropdown below.</p>
<p>This means we can find the bits that need to be set, then shift them by <code>N - 1</code>, and we will have the result.</p>
<p>We can observe that the most significant bits in the output are all <code>1</code>. Let's try to break this pattern.</p>
<blockquote>
<p>Input: nums = [5, 20] (n = 2) Output = 42 = <code>101010</code>.</p>
</blockquote>
<p>We found a test case that broke the pattern, which means we need to develop a way to determine the most significant bits.</p>
<p>Let's compare the bits in the numbers with the bits in the output.</p>
<p><img src="../Figures/1863/1863_compare_bits.png" alt="compare bits" /></p>
<p>This image shows the most significant of the output - all bits excluding the least significant (rightmost) <code>N - 1</code> bits.</p>
<p>Observe that every bit that is set in any of the elements is set in the output. The <strong>OR</strong> operator is true for a bit position if that bit position is set for any of the elements in the input, so we can utilize <strong>OR</strong> to get from the input to the output.</p>
<p>We can generate and test a solution using this strategy. First, we calculate the running <strong>OR</strong> of each of the elements in <code>nums</code> and save it in <code>result</code>. Then, we append <code>N - 1</code> zeros to the right of the binary representation by shifting the <code>result</code> by <code>N - 1</code>.</p>
<details>
<summary><b> Why Does This Method Work? (Click Here): </b></summary>
<p>The underlying idea of this method is to directly find the number of times each bit is set in all of the subset <strong>XOR</strong> totals, and use this to set the appropriate bits in the result.</p>
<p>We utilize several additional properties of <strong>XOR</strong>:</p>
<ul>
<li>The <strong>XOR</strong> of two equal numbers is zero.</li>
<li>The <strong>XOR</strong> total of the empty set is zero.</li>
<li>With more than two operands, the <strong>XOR</strong> operation evaluates to true when an odd number of them are true.</li>
</ul>
<pre><code>0 ^ 0 ^ 0 = 0
0 ^ 0 ^ 1 = 1
1 ^ 1 ^ 0 = 0
1 ^ 1 ^ 1 = 1
</code></pre>
<p><em>For a bit position to be set in the subset <strong>XOR</strong> total, it must be set in an odd number of the elements in the subset.</em></p>
<p>For a given element, how many subsets will include it?</p>
<ul>
<li>When <code>nums</code> contains <span class="math inline">\(N\)</span> elements, the total number of subsets, including the empty set, is <span class="math inline">\(2^N\)</span>. A particular element will be included in half of those subsets as shown in the first approach. Half of <span class="math inline">\(2^N\)</span> is <span class="math inline">\(2^{N-1}\)</span>.</li>
</ul>
<p>For a given bit position <code>x</code>, how many subset <strong>XOR</strong> totals have the <code class="">x<sup>th</sup></code> bit set?</p>
<ul>
<li>
<p>If the <code class="">x<sup>th</sup></code> bit is not set in any of the elements, none of the subset <strong>XOR</strong> totals will have the <code class="">x<sup>th</sup></code> bit set.</p>
</li>
<li>
<p>If the <code class="">x<sup>th</sup></code> bit is set in exactly one of the elements, it will be set in half of the <strong>XOR</strong> totals because half of the subsets contain that element.</p>
</li>
</ul>
<p><img src="../Figures/1863/1863_bit_set_once.png" alt="bit set once" /></p>
<ul>
<li>If the <code class="">x<sup>th</sup></code> bit is set in more than one of the elements, it will be set in half of the subset <strong>XOR</strong> totals.
<ul>
<li>Let's consider when <code>nums</code> contains two elements with the <code class="">x<sup>th</sup></code> bit set. The <code class="">x<sup>th</sup></code> bit is not set in the <strong>XOR</strong> total of the empty subset. For the two subsets with one element, the <code class="">x<sup>th</sup></code> bit is set in both of their <strong>XOR</strong> totals, so it will not be set in the <strong>XOR</strong> total of the subset containing both elements. Therefore, the <code class="">x<sup>th</sup></code> bit will be set in two out of four, or half, of the subset <strong>XOR</strong> totals. Let's call this set of subsets <span class="math inline">\(A\)</span>.</li>
<li>If we add an element with the <code class="">x<sup>th</sup></code> bit set to <code>nums</code>, all of the <span class="math inline">\(A\)</span> subsets will still be included. There will also be several new subsets that consist of one of the <span class="math inline">\(A\)</span> subsets and the new element. For each of these new subsets, if the <code class="">x<sup>th</sup></code> bit of the <strong>XOR</strong> total was <code>0</code> in the corresponding subset in <span class="math inline">\(A\)</span>, it will be <code>1</code> in the new subset, and vice versa. This means the <code class="">x<sup>th</sup></code> bit will be set for half of the new subsets. Since the <code class="">x<sup>th</sup></code> bit was also set for half of the <span class="math inline">\(A\)</span> subsets, the <code class="">x<sup>th</sup></code> bit will be set for half of the total subsets.</li>
<li>Adding another element that has the <code class="">x<sup>th</sup></code> bit set to a subset creates a new subset for each of the original subsets. The <code class="">x<sup>th</sup></code> bit will be flipped in <strong>XOR</strong> total for each new subset, so the <code class="">x<sup>th</sup></code> bit will be set in half of the subsets.</li>
</ul>
</li>
</ul>
<p><img src="../Figures/1863/1863_bit_set_multiple.png" alt="bit set multiple" /></p>
<p><em>This means for each bit that is set in any of the numbers in <code>nums</code>, the bit will be set in half of the subsets.</em></p>
<p>How is this information used to set the appropriate bits in the result?</p>
<p>We take the <strong>OR</strong> of all of the elements to capture every bit that is set in any of the elements and store in <code>result</code>.</p>
<p><em>If a bit is set in any element at least once, its corresponding value will be added to the sum exactly <span class="math inline">\(2^{N-1}\)</span> times.</em></p>
<blockquote>
<p>Input: nums = [1,3] (N = 2) Output = 6 = <code>110</code></p>
</blockquote>
<p><span class="math inline">\(2^{N-1} = 2^{2-1} = 2\)</span><br />
The first bit is set in <span class="math inline">\(2\)</span> of the subsets: <span class="math inline">\(1 \cdot 2 = 2\)</span><br />
The second bit is set in <span class="math inline">\(2\)</span> of the subsets: <span class="math inline">\(2 \cdot 2 = 4\)</span><br />
<span class="math inline">\(2 + 4 = 6\)</span></p>
<p>So, we multiply the <code>result</code> containing the set bit positions by the number of subsets each bit is set in, <span class="math inline">\(2^{N-1}\)</span>, which can be achieved using the shift operation: <code>result &lt;&lt; (N - 1)</code>.</p>
</details>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize a variable <code>result</code> to <code>0</code>.</li>
<li>For each <code>num</code> in <code>nums</code>:
<ul>
<li>Take the running <strong>OR</strong> of <code>result</code> and <code>num</code>, <code>result |= num</code>.</li>
</ul>
</li>
<li>Append <code>N - 1</code> zeros to the right of the binary representation of <code>result</code> by shifting <code>result</code> by <code>N - 1</code> places, <code>result &lt;&lt; (N - 1)</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/mVMb8sab/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We traverse through each of the <span class="math inline">\(N\)</span> elements in <code>nums</code> to calculate the running <strong>OR</strong> so the time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables but no data structures that grow with input size, so the space complexity is constant, i.e. <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-string3151/1" target="_blank" rel="noopener noreferrer">Sum-string</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="109" data-end="209"><span style="font-size: 14pt;">Given a string <strong><code data-start="124" data-end="127">s</code></strong> consisting of digits, determine whether it can be classified as a <strong data-start="194" data-end="208">sum-string</strong>.</span></p>
<p data-start="211" data-end="310"><span style="font-size: 14pt;">A <strong data-start="213" data-end="227">sum-string</strong> is a string that can be split into <strong data-start="263" data-end="278">more</strong> <strong>than two </strong>non-empty substrings such that:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul data-start="312" data-end="640">
<li data-start="312" data-end="436"><span style="font-size: 14pt;"> </span>
<p data-start="314" data-end="436"><span style="font-size: 14pt;">The <strong data-start="318" data-end="341">rightmost substring</strong> is equal to the <strong data-start="358" data-end="409">sum of the two substrings immediately before it</strong> (interpreted as integers).</span></p>
<span style="font-size: 14pt;"> </span></li>
<li data-start="437" data-end="509"><span style="font-size: 14pt;"> </span>
<p data-start="439" data-end="509"><span style="font-size: 14pt;">This condition must apply <strong data-start="465" data-end="480">recursively</strong> to the substrings before it.</span></p>
<span style="font-size: 14pt;"> </span></li>
<li data-start="510" data-end="640"><span style="font-size: 14pt;"> </span>
<p data-start="512" data-end="640"><span style="font-size: 14pt;">The <strong data-start="516" data-end="539">rightmost substring</strong> (and any number in the sum) <strong data-start="568" data-end="603">must not contain leading zeroes</strong>, unless the number is exactly <code data-start="634" data-end="639">'0'</code>.</span></p>
</li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "12243660"
<strong>Output: </strong>true
<strong>Explanation: </strong></span><span style="font-size: 18.6667px;">The string can be split as {"12", "24", "36", "60"} where each number is the sum of the two before it:
36 = 12 + 24, and 60 = 24 + 36. Hence, it is a sum-string.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> s <strong>= "</strong>1111112223"
<strong>Output: </strong>true
<strong>Explanation: </strong></span><span style="font-size: 18.6667px;">Split the string as {"1", "111", "112", "223"}, where:
112 = 1 + 111 and 223 = 111 + 112. Hence, it follows the sum-string rule.<br /></span></pre>
<pre><span style="font-size: 18.6667px;"><strong>Input</strong>: s = "123456"<br /></span><span style="font-size: 18.6667px;"><strong>Output</strong>: false<br /></span><span style="font-size: 18.6667px;"><strong>Explanation</strong>: There is no valid split of the string such that each part satisfies the sum-string property recursively.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; s.size() &le; 100</span><span style="font-size: 14pt;"><br /><span style="font-size: 14pt;">String consists of characters from '0' to '9'.</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/target-sum/description" target="_blank" rel="noopener noreferrer">Target Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p>

<p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p>

<ul>
	<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li>
</ul>

<p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,1,1], target = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1], target = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 20</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
	<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a list of numbers, <code>nums</code>, and a <code>target</code> value. Our task is to figure out how many ways we can add plus or minus signs in front of the numbers in <code>nums</code> to get the <code>target</code> value, while keeping the order of the numbers the same.</p>
<p>Let's consider an example where <code>nums = [2, 1]</code> and <code>target = 1</code>.</p>
<p>The possible expressions from this are:</p>
<ol>
<li><code>+2 - 1 = 1</code> â†’ <strong>matches the target</strong>.</li>
<li><code>-2 + 1 = -1</code> â†’ does not match.</li>
<li><code>+2 + 1 = 3</code> â†’ does not match.</li>
<li><code>-2 - 1 = -3</code> â†’ does not match.</li>
</ol>
<p>So, thereâ€™s only one way (<code>+2 - 1</code>) to get the target value <code>1</code>.</p>
<blockquote>
<p>Note: We need to use all the elements of the <code>nums</code> array.</p>
</blockquote>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Start by thinking about how we would manually solve this problem. We would consider each number and decide whether to add it or subtract it. This decision-making process can be modeled using recursion.</p>
<p>We start by defining a recursive function that takes the current index in the list, the current sum of the expression, and the target. For each number, we make two recursive calls: one where we add the number and one where we subtract it.</p>
<p>When we reach the end of the list (i.e., all numbers have been considered), we check if the current sum equals the target. If it does, we increment a counter that tracks the number of valid expressions for that route. We repeat this for every route and find the total number of ways.</p>
<p>While this works for small inputs, it becomes impractical for larger lists due to its exponential time complexity (<span class="math inline">\(2^n\)</span>).</p>
<blockquote>
<p>For a more comprehensive understanding of recursion, check out the <a href="https://leetcode.com/explore/learn/card/recursion-i/">Recursion Explore Card ðŸ”—</a>. This resource provides an in-depth look at recursion, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>totalWays</code> to 0 to track the number of ways to reach the target sum.</p>
</li>
<li>
<p>Call <code>calculateWays</code> with the initial parameters: <code>nums</code>, <code>currentIndex = 0</code>, <code>currentSum = 0</code>, <code>target</code>, to start the recursive process.</p>
</li>
<li>
<p>In the <code>calculateWays</code> function:</p>
<ul>
<li>If <code>currentIndex</code> equals the length of <code>nums</code>:
<ul>
<li>Check if <code>currentSum</code> matches <code>target</code>:
<ul>
<li>If yes, increment <code>totalWays</code> by 1 (a valid way to reach the target sum).</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Include the number at <code>currentIndex</code> with a positive sign:
<ul>
<li>Recursively call <code>calculateWays</code> with <code>currentIndex + 1</code> and <code>currentSum + nums[currentIndex]</code>.</li>
</ul>
</li>
<li>Include the current number at <code>currentIndex</code> with a negative sign:
<ul>
<li>Recursively call <code>calculateWays</code> with <code>currentIndex + 1</code> and <code>currentSum - nums[currentIndex]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>totalWays</code> after all recursive calls, representing the total number of ways to assign signs to reach the target sum.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: The Python3 solution gets a TLE.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/gAErDNjQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The function <code>calculateWays</code> is a recursive function that branches out into two recursive calls at each step. This is because each element in the array can either be added or subtracted, leading to <span class="math inline">\(2\)</span> choices for each of the <span class="math inline">\(n\)</span> elements.</p>
<p>This results in a binary tree of recursive calls, where each level of the tree corresponds to a position in the array <code>nums</code>. Since there are <span class="math inline">\(n\)</span> elements in the array, the maximum depth of the recursion tree is <span class="math inline">\(n\)</span>. Therefore, the total number of recursive calls is <span class="math inline">\(2^n\)</span>, leading to a time complexity of <span class="math inline">\(O(2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the depth of the recursion stack. In the worst case, the recursion stack can go as deep as <span class="math inline">\(n\)</span> levels (one level for each element in the array). Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion-with-memoization">Approach 2: Recursion with Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Building on the brute force approach, we can say that it has many subproblems that are being solved repeatedly. To understand this redundancy, let's consider a simple example.</p>
<p>Suppose we have the list <code>nums = [1, 1, 1, 1, 1]</code> and the target <code>target = 3</code>.</p>
<p>In the brute force approach, we would explore all possible combinations of signs:</p>
<ul>
<li><code>+1 +1 +1 +1 +1</code></li>
<li><code>+1 +1 +1 +1 -1</code></li>
<li><code>+1 +1 +1 -1 +1</code></li>
<li><code>+1 +1 -1 +1 +1</code></li>
<li><code>+1 -1 +1 +1 +1</code></li>
<li><code>-1 +1 +1 +1 +1</code></li>
<li>...</li>
</ul>
<p>Let's focus on a specific subproblem: reaching a sum of <code>2</code> using the first four numbers <code>[1, 1, 1, 1]</code>.</p>
<ol>
<li>
<p>Combination 1: <code>+1 +1 +1 -1 +1</code></p>
<ul>
<li>The sum of the first three numbers is <code>3</code>.</li>
<li>The sum of the first four numbers is <code>2</code> (since <code>3 - 1 = 2</code>).</li>
</ul>
</li>
<li>
<p>Combination 2: <code>+1 +1 -1 +1 +1</code></p>
<ul>
<li>The sum of the first three numbers is <code>1</code>.</li>
<li>The sum of the first four numbers is <code>2</code> (since <code>1 + 1 = 2</code>).</li>
</ul>
</li>
<li>
<p>Combination 3: <code>+1 -1 +1 +1 +1</code></p>
<ul>
<li>The sum of the first three numbers is <code>1</code>.</li>
<li>The sum of the first four numbers is <code>2</code> (since <code>1 + 1 = 2</code>).</li>
</ul>
</li>
</ol>
<p>In each of these combinations, we encounter the subproblem of reaching a sum of <code>2</code> using the first four numbers multiple times. Specifically, the subproblem of reaching a sum of <code>2</code> using the first four numbers <code>[1, 1, 1, -1]</code> or <code>[1, 1, -1, 1]</code> is solved repeatedly.</p>
<p>Another example can be given with <code>nums = [a, b, c]</code>.</p>
<p>Here is the corresponding recursion tree:</p>
<pre><code>â”œâ”€â”€ (+a)
â”‚   â”œâ”€â”€ (+b)^
â”‚   â”‚   â”œâ”€â”€ (+c)
â”‚   â”‚   â””â”€â”€ (-c)
â”‚   â””â”€â”€ (-b)~
â”‚       â”œâ”€â”€ (+c)
â”‚       â””â”€â”€ (-c)
â””â”€â”€ (-a)
    â”œâ”€â”€ (+b)^
    â”‚   â”œâ”€â”€ (+c)
    â”‚   â””â”€â”€ (-c)
    â””â”€â”€ (-b)~
        â”œâ”€â”€ (+c)
        â””â”€â”€ (-c)
</code></pre>
<p>As illustrated, the subtrees marked by <code>^</code> and <code>~</code> are solved twice.</p>
<p>To avoid this redundancy, we introduce a memoization table (a 2D array) where <code>memo[index][currentSum]</code> stores the number of ways to reach the target starting from the <code>index</code> with the <code>currentSum</code>.</p>
<p>Before making recursive calls, we check if the result for the current <code>index</code> and <code>currentSum</code> is already computed. If it is, we return the stored result instead of recalculating it. After computing the result for a given <code>index</code> and <code>currentSum</code>, we store it in the memoization table for future reference.</p>
<p>For example, after calculating the number of ways to reach a sum of <code>2</code> using the first four numbers, we store this result in the memoization table. The next time we encounter this subproblem, we simply retrieve the stored result instead of recalculating it. This reduces the time complexity from exponential to polynomial.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Calculate <code>totalSum</code>, the sum of all elements in the array <code>nums</code>.</p>
</li>
<li>
<p>Initialize a 2D array <code>memo</code> of size <code>[nums.length][2 * totalSum + 1]</code> to store intermediate results, and fill it with minimum value to indicate uncomputed states. Possible sums are shifted by <code>totalSum</code> to handle negative indices.</p>
</li>
<li>
<p>Call <code>calculateWays</code> with the initial parameters: <code>nums</code>, <code>currentIndex = 0</code>, <code>currentSum = 0</code>, <code>target</code>, and <code>memo</code>.</p>
</li>
<li>
<p>In the <code>calculateWays</code> function:</p>
<ul>
<li>
<p>If <code>currentIndex</code> equals <code>nums.length</code>:</p>
<ul>
<li>Check if <code>currentSum</code> equals <code>target</code>:
<ul>
<li>Return 1 if they match, as this represents a valid way to reach the target sum.</li>
<li>Otherwise, return 0.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the result for the current state (<code>currentIndex</code> and <code>currentSum</code>) is already computed in <code>memo</code>:</p>
<ul>
<li>Return the stored result from <code>memo</code>.</li>
</ul>
</li>
<li>
<p>Recursively calculate the number of ways:</p>
<ul>
<li>Add the current number (<code>nums[currentIndex]</code>) to <code>currentSum</code> and call <code>calculateWays</code> for the next index.</li>
<li>Subtract the current number (<code>nums[currentIndex]</code>) from <code>currentSum</code> and call <code>calculateWays</code> for the next index.</li>
</ul>
</li>
<li>
<p>Store the sum of the results from both recursive calls in <code>memo[currentIndex][currentSum + totalSum]</code> to avoid recomputing.</p>
</li>
<li>
<p>Return the stored result from <code>memo</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return the result of the initial call to <code>calculateWays</code>, which represents the total number of ways to reach the target sum.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p>Instead of using the range <span class="math inline">\([-\text{totalSum}, +\text{totalSum}]\)</span>, which is not possible in an array due to negative indices, we shift the range by adding <span class="math inline">\(\text{totalSum}\)</span> to both the lower and upper bounds. This transformation changes the range to <span class="math inline">\([-\text{totalSum} + \text{totalSum}, \text{totalSum} + \text{totalSum}]\)</span>, which simplifies to <span class="math inline">\([0, 2 \times \text{totalSum}]\)</span>.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/7CJP4uAJ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \text{totalSum})\)</span></p>
<p>In the worst case, the function <code>calculateWays</code> is called for each index in the array and each possible sum within the range <span class="math inline">\([-\text{totalSum}, \text{totalSum}]\)</span>. Since the sum can range from <span class="math inline">\(-\text{totalSum}\)</span> to <span class="math inline">\(\text{totalSum}\)</span>, there are <span class="math inline">\(2 \cdot \text{totalSum} + 1\)</span> possible sums.</p>
<p>Therefore, the total number of unique states (index, sum) is <span class="math inline">\(n \times (2 \cdot \text{totalSum} + 1)\)</span>. Each state is computed once and stored in the memoization table, leading to a time complexity of <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot \text{totalSum})\)</span></p>
<p>The space complexity is determined by the memoization table, which has dimensions <span class="math inline">\(n \times (2 \cdot \text{totalSum} + 1)\)</span>. Additionally, the recursion stack can go as deep as <span class="math inline">\(n\)</span>, but this is typically dominated by the space used by the memoization table. Therefore, the space complexity is <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
<p>The space complexity also includes the space used by the built-in functions, such as computing the sum and filling the rows. However, these operations are linear in terms of the input size and do not significantly affect the overall space complexity, which is dominated by the memoization table.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-2d-dynamic-programming">Approach 3: 2D Dynamic Programming</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Dynamic programming (DP) is a technique that solves problems by breaking them down into simpler subproblems and solving each subproblem only once. We create a 2D DP table where <code>dp[index][sum]</code> represents the number of ways to reach the sum <code>sum</code> using the first <code>index</code> numbers.</p>
<p>Suppose we have the list <code>nums = [1, 1, 1, 1, 1]</code> and the target <code>target = 3</code>.</p>
<p>We initialize the first row of the DP table. For the first number, there is exactly one way to reach the sum equal to the number itself (either by adding or subtracting it). In our example, we initialize <code>dp[0][1 + totalSum] = 1</code> and <code>dp[0][-1 + totalSum] = 1</code>.</p>
<p>For each subsequent number, we update the DP table based on the previous row. For each possible sum, we add the number of ways to reach that sum by either adding or subtracting the current number. For example, if we are at the second number <code>1</code>, we update the DP table based on the first row:</p>
<ul>
<li>If the previous sum was <code>0</code> (i.e., <code>dp[0][0 + totalSum] = 1</code>), we can reach a sum of <code>1</code> by adding the current number (<code>1 + 1 = 2</code>) or a sum of <code>-1</code> by subtracting the current number (<code>1 - 1 = 0</code>).</li>
</ul>
<p>We continue this process for each number in the list. The value at <code>dp[nums.length - 1][target + totalSum]</code> gives the number of ways to reach the target sum using all numbers. This approach efficiently computes the number of valid expressions by leveraging the results of previously solved subproblems.</p>
<p>The animation below shows how various sums are generated, along with the corresponding indices. The example assumes that the sum values lie in the range of <code>-6</code> to <code>+6</code>, just for the purpose of illustration.</p>
<p>!?!../Documents/494/494_Target_Sum_slides.json:1280,720!?!</p>
<blockquote>
<p>For a more comprehensive understanding of dynamic programming, check out the <a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming Explore Card ðŸ”—</a>. This resource provides an in-depth look at dynamic programming, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Compute <code>totalSum</code> as the sum of all elements in the <code>nums</code> array.</p>
</li>
<li>
<p>Initialize a 2D <code>dp</code> array with dimensions <code>[nums.length][2 * totalSum + 1]</code> to represent possible sums shifted by <code>totalSum</code> (to handle negative indices).</p>
</li>
<li>
<p>Set up the base case for the first row of the DP table:</p>
<ul>
<li>Add 1 to <code>dp[0][nums[0] + totalSum]</code> to account for adding the first number.</li>
<li>Add 1 to <code>dp[0][-nums[0] + totalSum]</code> to account for subtracting the first number (handle duplicate cases).</li>
</ul>
</li>
<li>
<p>Iterate through the remaining numbers in the <code>nums</code> array:</p>
<ul>
<li>For each possible sum <code>sum</code> in the range <code>-totalSum</code> to <code>totalSum</code>:
<ul>
<li>If <code>dp[index - 1][sum + totalSum] &gt; 0</code> (i.e., the sum is achievable from previous numbers):
<ul>
<li>Add its value to <code>dp[index][sum + nums[index] + totalSum]</code> (sum achieved by adding the current number).</li>
<li>Add its value to <code>dp[index][sum - nums[index] + totalSum]</code> (sum achieved by subtracting the current number).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the absolute value of the <code>target</code> exceeds <code>totalSum</code>:</p>
<ul>
<li>If yes, return 0 (the target is unachievable).</li>
<li>Otherwise, return <code>dp[nums.length - 1][target + totalSum]</code>, which contains the number of ways to achieve the <code>target</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<blockquote>
<p>Like in the previous approach, we shift the range of possible sums by adding <span class="math inline">\(\text{totalSum}\)</span> to both the lower and upper bounds, in order to avoid negative indices.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/iY7GEgWd/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \text{totalSum})\)</span></p>
<p>The time complexity is determined by the nested loops in the function. The outer loop runs <span class="math inline">\(n\)</span> times (once for each element in <code>nums</code>), and the inner loop runs <span class="math inline">\(2 \cdot \text{totalSum} + 1\)</span> times (once for each possible sum from <span class="math inline">\(-\text{totalSum}\)</span> to <span class="math inline">\(\text{totalSum}\)</span>).</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot \text{totalSum})\)</span></p>
<p>The space complexity is determined by the size of the DP table <code>dp</code>, which is a 2D array of size <span class="math inline">\(n \times (2 \cdot \text{totalSum} + 1)\)</span>. Each entry in the DP table requires constant space, so the total space complexity is <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
<p>Additionally, the space complexity includes the space required for the input array <code>nums</code>, which is <span class="math inline">\(O(n)\)</span>. However, since <span class="math inline">\(O(n \cdot \text{totalSum})\)</span> dominates <span class="math inline">\(O(n)\)</span>, the overall space complexity is <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized">Approach 4: Space Optimized</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the previous DP approach, the table <code>dp[index][sum]</code> stores the number of ways to reach the sum <code>sum</code> using the first <code>index</code> numbers. Each entry in the table is calculated based on the entries from the previous row. Specifically, to calculate <code>dp[index][sum]</code>, we only need values from the previous row:</p>
<ul>
<li><code>dp[index-1][sum - nums[index]]</code> (subtracting the current number)</li>
<li><code>dp[index-1][sum + nums[index]]</code> (adding the current number).</li>
</ul>
<p>Suppose we have the list <code>nums = [1, 1, 1, 1, 1]</code> and the target <code>target = 3</code>.</p>
<p>In the 2D DP table, the calculation for <code>dp[2][3]</code> (number of ways to reach a sum of <code>3</code> using the first three numbers) depends on:</p>
<ul>
<li><code>dp[1][3 - 1]</code> (number of ways to reach a sum of <code>2</code> using the first two numbers)</li>
<li><code>dp[1][3 + 1]</code> (number of ways to reach a sum of <code>4</code> using the first two numbers)</li>
</ul>
<p>This dependency shows that each row in the 2D DP table only depends on the previous row. Once we have calculated the values for <code>dp[index - 1]</code>, we no longer need the values from <code>dp[index - 2]</code> or any earlier rows. Thus, instead of maintaining a full 2D table, we update a single array as we process each number in the list.</p>
<p>We initialize the DP array with the first number. For the first number <code>1</code>, we initialize <code>dp[1 + totalSum] = 1</code> and <code>dp[-1 + totalSum] = 1</code>.</p>
<p>For each subsequent number, we create a new array and update it based on the previous array. This avoids the need to store the entire 2D table. For each possible sum, we update the new array by adding the number of ways to reach that sum by either adding or subtracting the current number. For example, if we are at the second number <code>1</code>, we update the new array based on the previous array:</p>
<ul>
<li>If the previous sum was <code>0</code> (i.e., <code>dp[0 + totalSum] = 1</code>), we can reach a sum of <code>1</code> by adding the current number (<code>0 + 1 = 1</code>) or a sum of <code>-1</code> by subtracting the current number (<code>0 - 1 = -1</code>).</li>
</ul>
<p>We continue this process for each number in the list. The value at <code>dp[target + totalSum]</code> gives the number of ways to reach the target sum using all numbers.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Calculate the <code>totalSum</code> as the sum of all elements in the array <code>nums</code>.</p>
</li>
<li>
<p>Create a <code>dp</code> array of size <code>2 * totalSum + 1</code> to track the number of ways to achieve each possible sum, offset by <code>totalSum</code> to handle negative indices.</p>
</li>
<li>
<p>Initialize the first row of the DP table:</p>
<ul>
<li>Set <code>dp[nums[0] + totalSum] = 1</code> for adding the first number.</li>
<li>Increment <code>dp[-nums[0] + totalSum]</code> by 1 for subtracting the first number (handles duplicates).</li>
</ul>
</li>
<li>
<p>Iterate through the rest of the <code>nums</code> array:</p>
<ul>
<li>For each index in <code>nums</code>, create a <code>next</code> array to represent the next state of the DP table.</li>
<li>For each possible <code>sum</code> in the range <code>[-totalSum, totalSum]</code>:
<ul>
<li>If the current sum <code>dp[sum + totalSum]</code> has valid ways:
<ul>
<li>Add the number at <code>nums[index]</code> to the current sum and update <code>next[sum + nums[index] + totalSum]</code>.</li>
<li>Subtract the number at <code>nums[index]</code> from the current sum and update <code>next[sum - nums[index] + totalSum]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Replace <code>dp</code> with <code>next</code> to move to the next state.</li>
</ul>
</li>
<li>
<p>After processing all numbers, check if the target is within the valid range of <code>[-totalSum, totalSum]</code>:</p>
<ul>
<li>If the <code>target</code> is out of range, return 0 (no valid ways exist).</li>
<li>Otherwise, return <code>dp[target + totalSum]</code>, which gives the number of ways to achieve the target sum.</li>
</ul>
</li>
<li>
<p>The final result represents the number of ways to assign <code>+</code> or <code>-</code> to elements in <code>nums</code> to achieve the <code>target</code>.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<blockquote>
<p>Note: The line <code>dp[-nums[0] + totalSum] += 1</code> ensures that if the first number is <code>0</code>, both <code>+0</code> and <code>-0</code> are counted as valid sums. This is crucial because for <code>nums[0] = 0</code>, both adding and subtracting <code>0</code> result in the sum of <code>0</code>.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/cSYY4EQu/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \text{totalSum})\)</span></p>
<p>The algorithm iterates through each element of the array <code>nums</code> once, and for each element, it iterates through all possible sums from <span class="math inline">\(- \text{totalSum}\)</span> to <span class="math inline">\(\text{totalSum}\)</span>. The <code>totalSum</code> is the sum of all elements in the array <code>nums</code>, which is <span class="math inline">\(O(n)\)</span> in terms of the number of elements.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n \cdot \text{totalSum})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2 \cdot \text{totalSum}) \approx O(\text{totalSum})\)</span></p>
<p>The space complexity is dominated by the dynamic programming table, which stores values for sums in the range from <code>-totalSum</code> to <code>totalSum</code>. This means the DP table has a size of <span class="math inline">\(2 \cdot \text{totalSum} + 1\)</span>, or <span class="math inline">\(O(2 \cdot \text{totalSum})\)</span>.</p>
<p>Additionally, there is an extra array <code>next</code> that is used to store the results of the next state, which also requires <span class="math inline">\(O(2 \cdot \text{totalSum})\)</span> space.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(2 \cdot \text{totalSum}) \approx O(\text{totalSum})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/description" target="_blank" rel="noopener noreferrer">The k-th Lexicographical String of All Happy Strings of Length n</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>happy string</strong> is a string that:</p>

<ul>
	<li>consists only of letters of the set <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>
	<li><code>s[i] != s[i + 1]</code> for all values of <code>i</code> from <code>1</code> to <code>s.length - 1</code> (string is 1-indexed).</li>
</ul>

<p>For example, strings <strong>&quot;abc&quot;, &quot;ac&quot;, &quot;b&quot;</strong> and <strong>&quot;abcbabcbcb&quot;</strong> are all happy strings and strings <strong>&quot;aa&quot;, &quot;baa&quot;</strong> and <strong>&quot;ababbc&quot;</strong> are not happy strings.</p>

<p>Given two integers <code>n</code> and <code>k</code>, consider a list of all happy strings of length <code>n</code> sorted in lexicographical order.</p>

<p>Return <em>the kth string</em> of this list or return an <strong>empty string</strong> if there are less than <code>k</code> happy strings of length <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 3
<strong>Output:</strong> &quot;c&quot;
<strong>Explanation:</strong> The list [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] contains all happy strings of length 1. The third string is &quot;c&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1, k = 4
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There are only 3 happy strings of length 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 3, k = 9
<strong>Output:</strong> &quot;cab&quot;
<strong>Explanation:</strong> There are 12 different happy string of length 3 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;]. You will find the 9<sup>th</sup> string = &quot;cab&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>1 &lt;= k &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a positive integer <code>n</code>, which represents the length of the string, and an integer <code>k</code>. Our task is to find the <span class="math inline">\(k^{\text{th}}\)</span> happy string of length <code>n</code> when all <em>happy</em> strings are listed in lexicographical order. Letâ€™s break this down:</p>
<ul>
<li>
<p><strong>Happy Strings</strong>: A string is called happy if it consists only of the characters <code>'a'</code>, <code>'b'</code>, and <code>'c'</code>, and no two consecutive characters are the same. For example, <code>&quot;abc&quot;</code> and <code>&quot;aba&quot;</code> are happy strings, but <code>&quot;aa&quot;</code> and <code>&quot;ad&quot;</code> are not.</p>
</li>
<li>
<p><strong>Lexicographical Order</strong>: This is the order in which words appear in a dictionary. When comparing two strings, we look at the first different character. The one with the smaller character (closer to <code>'a'</code> in the alphabet) comes first. For example, <code>&quot;abc&quot;</code> comes before <code>&quot;acb&quot;</code> because <code>'b'</code> comes before <code>'c'</code>.</p>
</li>
</ul>
<blockquote>
<p>Note: If there are fewer than <span class="math inline">\(k\)</span> such strings, we return an empty string.</p>
</blockquote>
<hr />
<h3 id="approach-1-backtracking-optimized">Approach 1: Backtracking (Optimized)</h3>
<h4 id="intuition">Intuition</h4>
<p>In this approach, we use backtracking to generate the <code>k-</code>th happy string directly, without needing to generate all happy strings and then sort them. This eliminates the overhead of sorting, which is particularly beneficial for larger values of <code>n</code>. We can determine the order in which the happy strings are generated by carefully choosing the order of characters in our backtracking.</p>
<blockquote>
<p>For a more comprehensive understanding of backtracking, check out the <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Backtracking Explore Card ðŸ”—</a>. This resource provides an in-depth look at recursion and backtracking, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>We start with an empty string and recursively extend it by adding characters <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>, ensuring that no two consecutive characters are the same. Crucially, we maintain the lexicographical order by trying <code>'a'</code>, then <code>'b'</code>, then <code>'c'</code> at each step. Because we generate the strings in lexicographical order and are looking for the <code>k-</code>th string, we can stop generating strings as soon as we find it.</p>
<p>To implement this, we iterate over the characters <code>'a'</code>, <code>'b'</code>, and <code>'c'</code> in that specific order. For each character, we check if it matches the last character of the string we've constructed so far. If it does, we skip it. Otherwise, we add it to the end of the current string and continue the backtracking. We decrement <code>k</code> with each valid character we add to the string. If <code>k</code> becomes <code>0</code>, we've found our <code>k-</code>th string.</p>
<h5 id="why-sorting-is-not-needed">Why Sorting is Not Needed:</h5>
<p>A good observation is that we create happy strings in lexicographical order. Since we only need the <code>k</code>-th string, we donâ€™t have to generate all possible strings and sort them. Instead, we can stop as soon as we find the <code>k</code>-th one. This saves a lot of time, especially for large <code>n</code>. We generate strings using the order <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, which naturally keeps them in alphabetical order. By keeping track of how many happy strings we have found, we can skip entire sections of the search that donâ€™t contain the <code>k</code>-th string.</p>
<h3 id="algorithm">Algorithm</h3>
<ul>
<li>
<p>Initialize <code>currentString</code> as an empty string to build happy strings.</p>
</li>
<li>
<p>Initialize <code>happyStrings</code> as a array to store all valid happy strings.</p>
</li>
<li>
<p>Generate all happy strings of length <code>n</code> by calling <code>generateHappyStrings</code>.</p>
</li>
<li>
<p>If the total count of happy strings is less than <code>k</code>, return an empty string.</p>
</li>
<li>
<p>Otherwise, return the <code>k</code>-th happy string from <code>happyStrings</code>.</p>
</li>
<li>
<p>In <code>generateHappyStrings</code>:</p>
<ul>
<li>If <code>currentString</code> reaches length <code>n</code>, add it to <code>happyStrings</code> and return.</li>
<li>Iterate over characters <code>'a'</code>, <code>'b'</code>, and <code>'c'</code>:
<ul>
<li>Skip adding a character if it matches the last character of <code>currentString</code>.</li>
<li>Recursively append the valid character and continue generating happy strings.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RsTYPdGA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the desired length of the happy strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{n-1} \cdot 3) \approx O(2^n)\)</span></p>
<p>Let <span class="math inline">\(n\)</span> be the desired length of the happy strings. For the first character of the string, there are 3 options (<code>'a'</code>, <code>'b'</code>, or <code>'c'</code>). For each subsequent character, there are 2 options (since the same character cannot be repeated consecutively). Therefore, the total number of happy strings generated is <span class="math inline">\(3 \cdot 2^{n-1}\)</span>.</p>
<p>The function <code>generateHappyStrings</code> explores all these possibilities recursively, resulting in a time complexity of <span class="math inline">\(O(3 \cdot 2^{n-1})\)</span>, which simplifies to <span class="math inline">\(O(2^{n-1} \cdot 3) \approx O(2^n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(2^n)\)</span>.</p>
<p>We create an array to store all happy strings of length <span class="math inline">\(n\)</span>, which will eventually hold <span class="math inline">\(3 \cdot 2^{n - 1} = O(2^n)\)</span> elements. Additionally, the recursion depth can grow up to <span class="math inline">\(n\)</span>, adding another <span class="math inline">\(O(n)\)</span> factor to the total space complexity. However, the amount of extra space used is dominated by the <code>happyStrings</code> array and remains equal to <span class="math inline">\(O(2^n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-recursion">Approach 2: Optimized Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Building on the previous approach, we will again generate happy strings of length <code>n</code> by extending an already happy string until it reaches the desired size. However, there's a key observation: the order in which we generate the strings is not random.</p>
<p>Since we add characters in alphabetical order, we naturally explore all strings starting with <code>'a'</code> before backtracking and moving to those starting with <code>'b'</code>, and so on. This means the strings are generated directly in lexicographical order.</p>
<p>Because of this, we don't need to store all the strings and sort them later. Instead, we can keep a counter - corresponding to the index of the current string in the sorted list - to track how many strings we've generated. When we reach the <span class="math inline">\(k^{\text{th}}\)</span> string, we store it as the result and stop the process, saving both time and space.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>In the <code>generateHappyStrings(n, k, currentString, indexInSortedList, result)</code> function:
<ul>
<li>If we have reached the desired string length, i.e., <code>currentString.size() == n</code>:
<ul>
<li>Increment <code>indexInSortedList</code> by <code>1</code>.</li>
<li>If we have reached the <code>k-th</code> string, i.e., <code>indexInSortedList == k</code>, store <code>currentString</code> in <code>result</code>.</li>
</ul>
</li>
<li>Otherwise, extend the current string by iterating over the candidate characters with <code>currentChar</code> from <code>'a'</code> to <code>'c'</code>:
<ul>
<li>If <code>currentChar</code> is the same as the last character in the <code>currentString</code>, skip it.</li>
<li>Otherwise, add it to the end of <code>currentString</code>.</li>
<li>Recursively call <code>generateHappyString(n, k, currentString, indexInSortedList, result)</code>.</li>
<li>If we have found the <code>k-th</code> string during this traversal, i.e., <code>result</code> is not an empty string, return.</li>
<li>Remove the last character of <code>currentString</code> to backtrack with the next one.</li>
</ul>
</li>
</ul>
</li>
<li>In the main <code>getHappyString</code> function:
<ul>
<li>Initialize <code>currentString</code> and <code>result</code> to empty strings.</li>
<li>Initialize <code>indexInSortedList</code> to <code>0</code>.</li>
<li>Call <code>generateHappyStrings(n, k, currentString, indexInSortedList, result)</code> to generate the happy strings starting from the empty string.</li>
<li>Return <code>result</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PTMum3xg/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the happy strings and <span class="math inline">\(k\)</span> the index of the result string in the sorted list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(k \cdot n)\)</span> or <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
<p>The algorithm generates happy strings in lexicographical order using backtracking and stops when the <span class="math inline">\(k^{\text{th}}\)</span> one is found.</p>
<p>In the worst case, the algorithm generates <span class="math inline">\(min(k, 3 \cdot 2^{n - 1})\)</span> strings before terminating. For each string, it performs <span class="math inline">\(n\)</span> recursive calls (one for each character in the string) and each of them involves only constant-time operations such as checking if the current character is valid and updating the current string.</p>
<p>Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(k \cdot n)\)</span> or <span class="math inline">\(O(n \cdot 2^n)\)</span> the number of strings generated is <span class="math inline">\(O(2^n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>Regarding additional space usage, we maintain a string <code>currentString</code> for backtracking, which can grow up to size <span class="math inline">\(n\)</span>. Since this string is passed by reference in the recursive function, no extra copies are created, keeping its space usage at <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, the recursion depth is also <span class="math inline">\(O(n)\)</span> because we make a recursive call for each of the <span class="math inline">\(n\)</span> characters in the string.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-using-a-stack">Approach 3: Iterative Using a Stack</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Recursive solutions are often more intuitive for backtracking but can be inefficient due to uncontrolled stack growth. Each recursive call adds a new frame to the call stack, storing local variables and execution details, which can lead to excessive memory usage or even a stack overflow. To avoid this, we will use our own stack to simulate recursion, giving us greater control over memory usage and preventing unnecessary overhead. Feel free to refer to the relative <a href="https://leetcode.com/explore/learn/card/queue-stack/">LeetCode Explore Card</a> for a more detailed overview of the stack data structure.</p>
<p>So, instead of making a new function call every time we extend the <code>currentString</code>, we store the next string to be processed (i.e., <code>currentString + currentChar</code>) in a stack. Then, retrieving a string from the top of the stack is the same as entering the function call that would have this string as <code>currentString</code>. The logic from this point remains the same: we go over all valid characters and try to extend the current string by adding them to the end of it. However, it is important to note that the string at the top of the stack is the one that will be processed (or expanded) first. Therefore, we need to push, for example, the string <code>&quot;abca&quot;</code> onto the stack after <code>&quot;abcb&quot;</code> so that it is retrieved first, ensuring that the strings are generated in lexicographic order. To achieve this, we will extend the current string by starting from the last valid character (<code>'c'</code>) and iterating backward to the first (<code>'a'</code>).</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an empty stack, <code>stringsStack</code>.</li>
<li>Initialize <code>indexInSortedList</code> to <code>0</code>.</li>
<li>Push the empty string into the <code>stringsStack</code>.</li>
<li>While the <code>stringsStack</code> is not empty:
<ul>
<li>Pop the top element of the stack as <code>currentString</code>.</li>
<li>If the <code>currentString</code> has a length equal to <code>n</code>:
<ul>
<li>Increment <code>indexInSortedList</code> by <code>1</code>.</li>
<li>If this is the <code>k-th</code> string in lexicographical order, i.e., <code>indexInSortedList == k</code>, return it.</li>
</ul>
</li>
<li>Otherwise, extend the current string by iterating over the valid characters in reversed order, i.e., with <code>currentChar</code> from <code>'c'</code> to <code>'a'</code>:
<ul>
<li>If the current string is not empty and <code>currentChar</code> is equal to its last character, skip it.</li>
<li>Add <code>currentString + currentChar</code> to the stack.</li>
</ul>
</li>
</ul>
</li>
<li>If the traversal ends and the <code>k-th</code> happy string is not found, there are less than <code>k</code> happy strings of length <code>n</code>, so return an empty string.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/eV8kewY8/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the happy strings and <span class="math inline">\(k\)</span> the index of the result string in the sorted list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(k \cdot n)\)</span> or <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
<p>As in the previous approach, we generate <span class="math inline">\(min(k, 3 \cdot 2^{n - 1})\)</span> strings of length <span class="math inline">\(n\)</span>, so the loop will run for <span class="math inline">\(O(k \cdot n)\)</span> or <span class="math inline">\(O(n \cdot 2^n)\)</span> times. Extending the current string by one character involves only constant-time operations, like iterating over the 3 valid characters and pushing the next string onto the top of the stack. Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(k \cdot n)\)</span> or <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The algorithm uses an explicit stack (<code>stringsStack</code>) to perform backtracking. During the traversal to construct the lexicographically smallest happy string (<code>&quot;ababa...&quot;</code>), we continuously extend a string of the form <code>&quot;ababa...&quot;</code>. At each level of recursion, we also push alternative choices onto the stack, such as <code>&quot;ababc&quot;</code>, which represent different branches of the search.</p>
<p>When we reach a valid happy string of length <span class="math inline">\(n\)</span>, the stack contains <span class="math inline">\(O(n)\)</span> stored strings at most, each of which can be <span class="math inline">\(O(n)\)</span> in length. Therefore, the total space complexity of the algorithm, determined by the size of the stack, is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-combinatorics">Approach 4: Combinatorics</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The main idea of this approach is that we do not need to generate all <span class="math inline">\(k - 1\)</span> happy strings to find the <span class="math inline">\(k^{th}\)</span> smaller one. To better understand this, let's make the following observations:</p>
<ul>
<li>
<p>The total number of happy strings of length <code>n</code> is <span class="math inline">\(3 \cdot 2^{n - 1}\)</span>. This is because the first character has 3 choices (<code>'a'</code>, <code>'b'</code>, or <code>'c'</code>) and each subsequent character has 2 choices, as it must differ from the preceding character. Therefore, if <span class="math inline">\(k\)</span> exceeds this total, it implies that the <span class="math inline">\(k\)</span>-th happy string does not exist, and we should return an empty string.</p>
</li>
<li>
<p>Moving on to the harder case, note that the set of all happy strings can be divided into three equal groups based on their starting character:</p>
<ul>
<li>Strings starting with <code>'a'</code>: positions <span class="math inline">\(1\)</span> to <span class="math inline">\(2^{n - 1}\)</span>.</li>
<li>Strings starting with <code>'b'</code>: positions <span class="math inline">\(2^{n - 1} + 1\)</span> to <span class="math inline">\(2 \cdot 2^{n - 1}\)</span>.</li>
<li>Strings starting with <code>'c'</code>: positions <span class="math inline">\(2 \cdot 2^{n - 1} + 1\)</span> to <span class="math inline">\(3 \cdot 2^{n - 1}\)</span>.</li>
</ul>
<p>Each group contains <span class="math inline">\(2^{n - 1}\)</span> strings, as fixing the first character leaves <span class="math inline">\(2^{n - 1}\)</span> ways to choose the remaining characters. By comparing <span class="math inline">\(k\)</span> to these ranges, we can determine the first character of the desired string and adjust <span class="math inline">\(k\)</span> to reflect its position within the subgroup by subtracting the group's starting index.</p>
</li>
<li>
<p>Similarly, every subsequent character at the <span class="math inline">\(i^{th}\)</span> position divides the strings of its group into two subgroups of size <span class="math inline">\(2^{n - i - 1}\)</span>:</p>
<ul>
<li>Strings starting with the smallest valid character (<code>'a'</code> -&gt; <code>'b'</code>, <code>'b'</code> -&gt; <code>'a'</code> and <code>'c'</code> -&gt; <code>'a'</code>).</li>
<li>Strings starting with the greatest valid character (<code>'a'</code> -&gt; <code>'c'</code>, <code>'b'</code> -&gt; <code>'c'</code> and <code>'c'</code> -&gt; <code>'b'</code>).</li>
</ul>
<p>By comparing <span class="math inline">\(k\)</span> with the midpoint at which the groups are split, i.e., <span class="math inline">\(2^{n - i - 1}\)</span>, we can determine whether the result string belongs to the first or last subgroup and set the character at position <span class="math inline">\(i\)</span> accordingly.</p>
</li>
</ul>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Calculate the total number of happy strings of length <code>n</code> as <code>total = 3 * pow(2, n - 1)</code>.</li>
<li>If <code>k</code> is greater than <code>total</code>, return an empty string.</li>
<li>Initialize the <code>result</code> string.</li>
<li>Initialize two maps, <code>nextSmallest</code> and <code>nextGreatest</code>, that map each of the three characters to the smallest and largest characters respectively that can go after them.</li>
<li>Set the index of the first string that starts with <code>'a'</code> (<code>startA</code>) to <code>1</code> (the lexicographically smallest happy string with <code>'a'</code>).</li>
<li>Calculate the index of the first string that starts with <code>'b'</code> as <code>startB = startA + pow(2, n - 1)</code>.</li>
<li>Calculate the index of the first string that starts with <code>'c'</code> as <code>startC = startB + pow(2, n - 1)</code>.</li>
<li>Determine the first character of the string:
<ul>
<li>If <code>k</code> is less than <code>startB</code>, set the first character of <code>result</code> to <code>'a'</code> and subtract <code>startA</code> from <code>k</code>.</li>
<li>Else if <code>k</code> is less than <code>startC</code>, set the first character of <code>result</code> to <code>'b'</code> and subtract <code>startB</code> from <code>k</code>.</li>
<li>Else, set the first character of <code>result</code> to <code>'c'</code> and subtract <code>startC</code> from <code>k</code>.</li>
</ul>
</li>
<li>For each subsequent character, at <code>charIndex</code>:
<ul>
<li>Calculate the <code>midpoint</code> of its group, as <code>midpoint = pow(2, n - charIndex - 1)</code>.</li>
<li>If <code>k</code> is less than <code>midpoint</code>, set <code>result[charIndex] = nextSmallest[result[charIndex - 1]]</code> to extend <code>result</code> with the smallest valid character.</li>
<li>Otherwise:
<ul>
<li>Set <code>result[charIndex] = nextGreatest[result[charIndex - 1]]</code>.</li>
<li>Decrement <code>k</code> by <code>midpoint</code> so that it corresponds to the index of the result string within the current group.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/UdnvEmRb/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the happy strings.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We construct the result string by iterating over its characters and determining each of them in constant time. Therefore, the time complexity of this algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Excluding the output string, the algorithm only requires a fixed number of variables and two maps (<code>nextGreatest</code> and <code>nextSmallest</code>) of fixed size. Thus, the auxiliary space complexity is constant or <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-number-of-beautiful-subsets/description" target="_blank" rel="noopener noreferrer">The Number of Beautiful Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of positive integers and a <strong>positive</strong> integer <code>k</code>.</p>

<p>A subset of <code>nums</code> is <strong>beautiful</strong> if it does not contain two integers with an absolute difference equal to <code>k</code>.</p>

<p>Return <em>the number of <strong>non-empty beautiful </strong>subsets of the array</em> <code>nums</code>.</p>

<p>A <strong>subset</strong> of <code>nums</code> is an array that can be obtained by deleting some (possibly none) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,6], k = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 18</code></li>
	<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of positive integers <code>nums</code> and a positive integer <code>k</code>; the task is to find the number of non-empty beautiful subsets of <code>nums</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>A subset is defined as a set of elements taken from the original array <code>nums</code>.</li>
<li>If a subset contains two integers <code>a</code> and <code>b</code> such that <code>|a - b| = k</code>, then it's not beautiful.</li>
<li>We need to count the number of possible beautiful subsets of <code>nums</code>.</li>
</ol>
<p>The solutions in this editorial utilize the following concepts:</p>
<ul>
<li>Recursion: <a href="https://leetcode.com/explore/learn/card/recursion-ii/">Recursion Explore Card</a></li>
<li>Dynamic Programming: <a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming</a></li>
<li><strong>XOR</strong> and <strong>OR</strong> bitwise operations: <a href="https://leetcode.com/explore/learn/card/bit-manipulation/669/bit-manipulation-concepts/4496/">Bitwise Operator Explore Card</a></li>
</ul>
<p>If you are not familiar with a topic, we recommend you read the corresponding linked explore card.</p>
<hr />
<h3 id="approach-1-using-bitset">Approach 1: Using Bitset</h3>
<h4 id="intuition">Intuition</h4>
<p>The size of the <code>nums</code> array is very small (<code>&lt;= 20</code>). This means that the number of possible subsets is also relatively small, as there are at most <span class="math inline">\(2^{20}\)</span> subsets. We can take advantage of this fact and use a bitset to represent the subsets.</p>
<p>A bitset is a compact way of representing a set of elements, where each bit corresponds to a single element. If the bit is set (1), it means the element is included in the set; otherwise, it is not included (0).</p>
<p>Example: nums = [1,2,3,4,5,6], subset: [1,3,4]</p>
<p>This subset includes the elements at indices 0, 2, and 3, so the corresponding mask is <code>001101</code>. The least significant bit corresponds to the element at index zero.</p>
<p>We traverse the elements of the array <code>nums</code>. For each element <code>nums[i]</code>, we check if including it in the current subset would make the subset ugly (i.e., if there exists a pair of elements with a difference of <code>k</code>). We can do this by checking all previously included elements in the bitset.</p>
<p>If the current element <code>nums[i]</code> does not make the subset ugly, we include it in the bitset by setting the corresponding bit. Otherwise, we skip it and move to the next element.</p>
<p>The process is visualized below:</p>
<p><img src="../Figures/2597/bitset.png" alt="bitset" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><code>beautifulSubsets</code> Method:</p>
<ul>
<li>Call <code>countBeautifulSubsets</code> with initial parameters <code>nums</code>, <code>k</code>, <code>0</code>, and <code>0</code> to calculate the number of beautiful subsets of an array <code>nums</code> with a given difference <code>k</code>.</li>
<li>Return the result.</li>
</ul>
<p><code>countBeautifulSubsets</code> Method:</p>
<ul>
<li>It takes four parameters: <code>nums</code> (the array of integers), <code>difference</code> (<code>k</code>), <code>index</code> (the index of the current element being considered), and <code>mask</code> (an integer representing the current subset).</li>
<li>Base case: When we process the last index of <code>nums</code> (i.e., the index equals the size of <code>nums</code>), if <code>mask</code> is greater than <code>0</code> (i.e., indicating a non-empty subset), then return <code>1</code>; otherwise, return <code>0</code>.</li>
<li>Initialize a boolean variable <code>isBeautiful</code> to true.</li>
<li>Iterate through the elements before the current index to check if the current number forms a beautiful pair with any previous number in the subset.</li>
<li>Recursively calculate beautiful subsets including and excluding the current number.
<ul>
<li><code>skip</code>: Call <code>countBeautifulSubsets</code> with the next index and the same <code>mask</code>.</li>
<li><code>take</code>: If the current subset is beautiful, call <code>countBeautifulSubsets</code> with the next index and the updated <code>mask</code> (adding the current index to the <code>mask</code>); otherwise, set <code>take</code> to <code>0</code>.</li>
</ul>
</li>
<li>Return the sum of <code>skip</code> and <code>take</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/adEVk7dj/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Each number in the input array <code>nums</code> can be either included or excluded in a subset, resulting in <span class="math inline">\(2^n\)</span> possible subsets.</p>
<p>Work done within each recursive call: The function iterates over the previous elements in the current subset to check if any pair satisfies the difference constraint. In the worst case, when all elements are included in the subset, the iteration takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Combining the number of recursive calls and the work done within each call, the overall time complexity will be <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the recursive call stack, which can grow up to the depth of the input array <code>nums</code>. Hence, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion-with-backtracking">Approach 2: Recursion with Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To build subsets, we decide for each number in <code>nums</code> whether to include it in the subset or not. This creates two paths: one where we add the number to the subset and one where we don't.</p>
<p>For an array of size <code>n</code>, there can be up to <span class="math inline">\(2^n\)</span> subsets, as each element can either be included or excluded. At index <code>i</code>, we make two subsets: one with it and one without it. One of the subsets we create will be the empty subset, so we subtract 1 at the end to exclude it.</p>
<p>To ensure a &quot;beautiful&quot; subset, we need to check if neither <code>nums[i] + k</code> nor <code>nums[i] - k</code> has been used before. We can use a frequency map that will keep track of seen numbers. Before adding <code>nums[i]</code>, we check if neither <code>nums[i] + k</code> nor <code>nums[i] - k</code> is in the map. If both are absent, we add <code>nums[i]</code> to the subset.</p>
<p>But what if we know that before the current index <code>i</code>, there were no larger elements in the array? Then we only need to check for the existence of <code>nums[i] - k</code>. We don't even need to check for <code>nums[i] + k</code> because any element larger than <code>nums[i]</code> would not have been processed yet due to the sorted order. Therefore, we sort the array before starting the recursion.</p>
<p>This way, we only need to check for <code>nums[i] - k</code>, leading to fewer operations.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><code>beautifulSubsets</code> Method:</p>
<ul>
<li>Initialize a <code>map</code> called <code>freqMap</code> to keep track of the frequency of elements.</li>
<li>Sort the <code>nums</code> array.</li>
<li>Call the <code>countBeautifulSubsets</code> method with parameters <code>nums</code>, <code>k</code>, <code>freqMap</code>, and <code>0</code>.</li>
<li>Subtract <code>1</code> from the result and return it.</li>
</ul>
<p><code>countBeautifulSubsets</code> Method:</p>
<ul>
<li>It takes four parameters: <code>nums</code> (given array), <code>difference</code> (given as <code>k</code>), <code>freqMap</code> (a map to keep track of element frequencies), and <code>i</code> (the index of the current element being considered).</li>
<li>Base case: If <code>i</code> is equal to the length of the array <code>nums</code>, return 1 (representing a subset of size 1).</li>
<li>Recursively call <code>countBeautifulSubsets</code> with <code>i + 1</code> to count subsets without including the current element.</li>
<li>Check if it's possible to include the current element <code>nums[i]</code> without violating the condition.
<ul>
<li>If <code>nums[i] - k</code> is not present in <code>freqMap</code>, it means the difference condition is satisfied.</li>
<li>Mark <code>nums[i]</code> as taken in <code>freqMap</code>.</li>
<li>Recursively call <code>countBeautifulSubsets</code> with <code>i + 1</code> to count subsets including the current element.</li>
<li>Backtrack: Mark <code>nums[i]</code> as not taken in <code>freqMap</code>.</li>
<li>Remove <code>nums[i]</code> from <code>freqMap</code> if its count becomes 0.</li>
</ul>
</li>
<li>Return the total count of beautiful subsets.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/bFk5Eds5/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The time complexity of the solution is primarily determined by the number of subsets generated. Since the algorithm explores all possible subsets of the input array, the maximum number of subsets that can be generated from an array of size <span class="math inline">\(n\)</span> is <span class="math inline">\(2^n\)</span></p>
<p>Additionally, sorting <code>nums</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(2^n)\)</span>, because it is dominated by the subset generation.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Note that some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>The recursion stack space and the frequency map each use <span class="math inline">\(O(n)\)</span> space. Thus, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-optimised-recursion-deriving-recurrence-relation">Approach 3: Optimised Recursion (Deriving Recurrence Relation)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we generated all possible subsets and checked each one to find the beautiful subsets. This lead to an exponential time complexity. However, we can optimize this approach by identifying certain cases where we can directly calculate the number of beautiful subsets without generating all subsets. What if there are no elements with a difference of <code>k</code> in the array?</p>
<p>Let's understand this with a few examples:</p>
<h5 id="direct-calculation-of-beautiful-subsets">Direct Calculation of Beautiful Subsets:</h5>
<p><strong>Example 1: No Elements with Difference k</strong></p>
<ul>
<li>Suppose <code>nums = [1, 3, 5, 7]</code> and <code>k = 1</code>. We observe that there are no pairs of elements in the array with a difference of <code>k</code> (i.e., 1). This means that every subset of this array is a beautiful subset. Therefore, we can directly return <code>2^n - 1</code> (subtracting 1 for the empty subset) as the number of beautiful subsets, without checking every subset.</li>
</ul>
<p><strong>Example 2: Handling Elements with Difference k</strong></p>
<ul>
<li>Now, consider <code>nums = [1, 2, 3, 4]</code> and <code>k = 2</code>. Here, we notice that the difference of 2 can be achieved by pairs like (4, 2) and (3, 1). This means that if we include both elements of such a pair in the same subset, it will not be a beautiful subset. To handle this, we can separate the array into groups, where each group contains elements that cannot form a pair with a difference of <code>k</code> with any element from another group.</li>
</ul>
<h5 id="subsets-separation-and-calculation">Subsets Separation and Calculation:</h5>
<p>In this example, we can separate the array into two groups: <code>s1 = [1, 3]</code> and <code>s2 = [2, 4]</code>. We can calculate the number of beautiful subsets for <span class="math inline">\(s_1\)</span> and <span class="math inline">\(s_2\)</span> separately, denoted as <span class="math inline">\(f(s_1)\)</span> and <span class="math inline">\(f(s_2)\)</span>, because the choices in <span class="math inline">\(s_1\)</span> are independent of <span class="math inline">\(s_2\)</span> and vice versa.</p>
<p>For final answer, we can multiply <span class="math inline">\(f(s_1)\)</span> and <span class="math inline">\(f(s_2)\)</span> because there is no pair <span class="math inline">\((x_1, x_2)\)</span> such that <span class="math inline">\(x_1 âˆˆ s_1\)</span> , <span class="math inline">\(x_2 âˆˆ s_2\)</span> and <span class="math inline">\(âˆ£x_1 âˆ’ x_2âˆ£ = k\)</span></p>
<h5 id="takeaway">Takeaway</h5>
<p>The final answer would be <span class="math inline">\(f(nums) = f(s_1) \times f(s_2) - 1\)</span> (subtracting 1 for the empty subset).</p>
<p>In general, we can separate the given array into groups such that there is no pair <code>(x1, x2)</code> with <code>x1</code> and <code>x2</code> belonging to different groups and <code>|x1 - x2| = k</code>. We can create these groups based on the remainder when each element is divided by <code>k</code>. For instance, if <code>nums = [1, 2, 3, 4, 5, 6]</code> and <code>k = 2</code>, we can create the groups: <code>s1: [2, 4, 6]</code> (where <code>nums[i] % k = 0</code>) and <code>s2: [1, 3, 5]</code> (where <code>nums[i] % k = 1</code>).</p>
<p>Now consider <code>nums = [5, 5, 5, 7, 7, 11, 11]</code> and <code>k = 2</code>. We can't include <code>[5, 7]</code> in the same subset due to the restriction. We represent <span class="math inline">\(s_1\)</span> as <code>[5: 3, 7: 2, 11: 2]</code> (indicating the frequency of each value).</p>
<h5 id="developing-the-recurrence-relation">Developing the Recurrence Relation:</h5>
<p>Now, let's derive the mathematical proof and recurrence relation for calculating the number of beautiful subsets.</p>
<p>Let <code>f(i)</code> be the number of beautiful subsets in <span class="math inline">\(s_1\)</span> starting from index <code>i</code>. We want to calculate <code>f(0)</code>.</p>
<p>When i = 0, the element is 5. There are two options: skip it or take it. There are <span class="math inline">\(2^3\)</span> ways we can include the three occurrences of <code>5</code> in subsets. <span class="math inline">\(2^3 - 1 = 7\)</span> of these take at least one 5, and one that skips 5.</p>
<p><span class="math inline">\(take_{5} = 7\)</span>, <span class="math inline">\(skip_{5} = 1\)</span></p>
<p>Now, the next element at i + 1 is 7 = 5 + 2 = 5 + k, so we can't take it if we took 5. Therefore, the number of ways of taking 5 will be <span class="math inline">\(take_{5} \times f(i + 2)\)</span>.</p>
<p>The number of ways of skipping 5 will be <span class="math inline">\(skip_{5} \times f(i + 1)\)</span>.</p>
<p><span class="math inline">\(take_{s[i]} = 2 ^ {frequency(s[i])} - 1\)</span></p>
<p><span class="math inline">\(skip_{s[i]} = 1\)</span></p>
<p><span class="math inline">\(f(i) = take_{s[i]} \times f(i + 2) + skip_{s[i]} \times f(i + 1)\)</span></p>
<p><span class="math inline">\(f(0) = 7 \times f(2) + 1 \times f(1)\)</span></p>
<p>When i = 1, the value is 7. There are two options: <span class="math inline">\(take_{7} = 2^2 - 1 = 3\)</span> and <span class="math inline">\(skip_{7} = 1\)</span>. The next element is 11 = 7 + 4 = 7 + 2k, so we can take it even if we took 7.</p>
<p><span class="math inline">\(f(i) = take_{s[i]} \times f(i + 1) + skip_{s[i]} \times f(i + 1)\)</span></p>
<p><span class="math inline">\(f(1) = 3 \times f(2) + 1 \times f(2)\)</span></p>
<p>When i = 2, the value is 11. There are two options: <span class="math inline">\(take_{11} = 2^2 - 1 = 3\)</span> and <span class="math inline">\(skip_{11} = 1\)</span>. There is not a next element. So, we will denote this as a base case <span class="math inline">\(f(n) = 1\)</span>.</p>
<p><span class="math inline">\(f(i) = take_{s[i]} \times f(i + 1) + skip_{s[i]} \times f(i + 1)\)</span></p>
<p><span class="math inline">\(f(2) = 3 \times f(3) + 1 \times f(3) = 3 \times 1 + 1 \times 1 = 4\)</span></p>
<p><span class="math inline">\(f(1) = 3 \times f(2) + 1 \times f(2) = 3 \times 4 + 1 \times 4 = 16\)</span></p>
<p><span class="math inline">\(f(0) = 7 \times f(2) + 1 \times f(1) = 7 \times 4 + 1 \times 16 = 44\)</span></p>
<p><span class="math inline">\(answer = f(0) - 1 = 43\)</span></p>
<p>The general recurrence relation for <code>f(i)</code> will be:</p>
<p><span class="math inline">\(f(i) = \text{skip}_{s[i]} \times f(i + 1) + \text{take}_{s[i]} \times \begin{cases} f(i + 2) & \text{if } s[i + 1] - s[i] = k \\ f(i + 1) & \text{otherwise} \end{cases}\)</span></p>
<p>If we follow these steps, the final answer will be as listed below:</p>
<ol>
<li>Split the array into different groups, denoted <span class="math inline">\(s_i\)</span>, based on their remainder when divided by <span class="math inline">\(k\)</span>.</li>
<li>Sort the groups and represent in {value:frequency} form.</li>
</ol>
<p><span class="math inline">\(\text{answer} = \left(\prod_i f_{s_i}(0)\right) - 1\)</span></p>
<p>This approach optimizes the naive approach by avoiding the generation of all subsets and directly calculating the number of beautiful subsets based on the properties of the array and the value of <code>k</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p><code>beautifulSubsets</code> Method:</p>
<ul>
<li>Initialize <code>totalCount</code> to 1.</li>
<li>Initialize a <code>map</code> called <code>freqMap</code> to track the frequency of elements based on their remainder when divided by <code>k</code>.</li>
<li>Calculate frequencies for each element in <code>nums</code> and update <code>freqMap</code>.</li>
<li>Iterate over each remainder group in <code>freqMap</code>.
<ul>
<li>Convert the frequency map of each remainder group into an array of pairs (<code>subsets</code>) containing the element and its frequency.</li>
<li>Call the <code>countBeautifulSubsets</code> method with parameters <code>subsets</code>, <code>subsets.size()</code>, <code>k</code>, and <code>0</code>.</li>
<li>Multiply <code>totalCount</code> with the result of <code>countBeautifulSubsets</code> for each remainder group.</li>
</ul>
</li>
<li>Return <code>totalCount - 1</code>.</li>
</ul>
<p><code>countBeautifulSubsets</code> Method:</p>
<ul>
<li>It takes four parameters: <code>subsets</code> (the array of pairs containing element frequencies), <code>numSubsets</code> (the number of subsets), <code>difference</code> (the given difference), and <code>i</code> (the index of the current subset being considered).</li>
<li>Base case: If <code>i</code> is equal to <code>numSubsets</code>, return 1 (representing a subset of size 1).</li>
<li>Calculate subsets where the current subset is not taken by recursively calling <code>countBeautifulSubsets</code> with <code>i + 1</code>.</li>
<li>Calculate subsets where the current subset is taken by multiplying <code>(1 &lt;&lt; subsets[i].second) - 1</code> (which represents all possible combinations of taking elements from the current subset).</li>
<li>If the next number has a <code>difference</code>, calculate subsets recursively; otherwise, move to the next subset.</li>
<li>Return the sum of subsets where the current subset is taken and not taken.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YFw7RmrF/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the nums array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + 2^n) = O(2^n)\)</span></p>
<p>Since the map is sorted and implemented using a Self-Balancing Binary Search Tree (BST), the insert operation is <span class="math inline">\(O(\log n)\)</span>. Thus, constructing the map takes <span class="math inline">\(O(n \log n)\)</span>. With a maximum of <span class="math inline">\(k\)</span> different remainders, there can be up to <span class="math inline">\(k\)</span> subset splits. In the worst-case scenario, where all numbers have the same remainder, and none are repeated (frequency = 1), this approach still results in a time complexity of <span class="math inline">\(O(2^n)\)</span>.</p>
<blockquote>
<p>In Python3 we use a <code>defaultdict</code>. Inserting a key-value pair into a dictionary takes <span class="math inline">\(O(1)\)</span> on average, resulting in a construction time of <span class="math inline">\(O(n)\)</span>. Still, the overall time complexity remains <span class="math inline">\(O(2^n)\)</span>.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The frequency map stores the count of elements based on their remainders when divided by <code>k</code>. In the worst case, this requires <span class="math inline">\(O(n)\)</span> space, as it needs to store counts for each element.</p>
<p>The depth of the recursive call stack can grow up to the number of unique elements in the subset list, which is at most <span class="math inline">\(n\)</span>. Thus, the space used by the call stack is <span class="math inline">\(O(n)\)</span>.</p>
<p>For the <code>counts</code> array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to <span class="math inline">\(n\)</span>. This results in <span class="math inline">\(O(n)\)</span> space complexity for the <code>counts</code> array.</p>
<p>The <code>subsets</code> list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be <span class="math inline">\(n\)</span> such pairs, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>So, overall, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-dynamic-programming---memoization">Approach 4: Dynamic Programming - Memoization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the previous approach we developed the recurrence relation for calculating the number of beautiful subsets.</p>
<p>The function <code>f(i)</code> calculates the number of beautiful subsets in the array <code>s</code> starting from index <code>i</code>. Now, instead of recomputing <code>f(i)</code> for the same index multiple times during recursion, we can memoize the function <code>f(i)</code> in a data structure, such as an array.</p>
<blockquote>
<p>Memoization is a technique used to optimize recursive solutions by storing the results of expensive function calls and reusing them instead of recomputing them every time.</p>
</blockquote>
<p>So whenever we need to compute <code>f(i)</code>, we first check if the result is already stored in the memoized array. If it is, we return the stored result; otherwise, we compute <code>f(i)</code>, store the result in the memoized array, and return the computed value.</p>
<p>By memoizing <code>f(i)</code>, we avoid redundant calculations and improve the overall time complexity of the solution.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><code>beautifulSubsets</code> Method:</p>
<ul>
<li>Initialize <code>totalCount</code> to 1.</li>
<li>Initialize a <code>map</code> called <code>freqMap</code> to track the frequency of elements based on their remainder when divided by <code>k</code>.</li>
<li>Calculate frequencies for each element in <code>nums</code> and update <code>freqMap</code>.</li>
<li>Iterate over each remainder group in <code>freqMap</code>.
<ul>
<li>Convert the frequency map of each remainder group into an array of pairs (<code>subsets</code>) containing the element and its frequency.</li>
<li>Initialize an array called <code>counts</code> with size equal to the number of distinct elements in the current remainder group, filled with <code>-1</code> for memoization purposes.</li>
<li>Call the <code>countBeautifulSubsets</code> method with parameters <code>subsets</code>, <code>subsets.size()</code>, <code>k</code>, <code>0</code>, and <code>counts</code>.</li>
<li>Multipy <code>totalCount</code> with the result of <code>countBeautifulSubsets</code> for each remainder group.</li>
</ul>
</li>
<li>Return <code>totalCount - 1</code>.</li>
</ul>
<p><code>countBeautifulSubsets</code> Method:</p>
<ul>
<li>It takes five parameters: <code>subsets</code> (the array of pairs containing element frequencies), <code>numSubsets</code> (the number of subsets), <code>difference</code> (the given difference), <code>i</code> (the index of the current subset being considered), and <code>counts</code> (an array to store counts of subsets for memoization).</li>
<li>Base case: If <code>i</code> is equal to <code>numSubsets</code>, return 1 (representing a subset of size 1).</li>
<li>If the count for the current subset has already been calculated (stored in <code>counts[i]</code>), return it.</li>
<li>Calculate subsets where the current subset is not taken by recursively calling <code>countBeautifulSubsets</code> with <code>i + 1</code>.</li>
<li>Calculate subsets where the current subset is taken by multiplying <code>(1 &lt;&lt; subsets[i].second) - 1</code> (which represents all possible combinations of taking elements from the current subset).</li>
<li>If the next number has a difference of 'difference', calculate subsets accordingly by recursively calling <code>countBeautifulSubsets</code>; otherwise, move to the next subset.</li>
<li>Store the calculated count in <code>counts[i]</code> for memoization.</li>
<li>Return the sum of subsets where the current subset is taken and not taken.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/LwtnN45H/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the nums array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + n) = O(n \log n)\)</span></p>
<p>We first group the numbers by their remainder modulo <span class="math inline">\(k\)</span>, which takes <span class="math inline">\(O(n)\)</span> time. For each group, we sort its unique numbers, which takes <span class="math inline">\(O(g \log g)\)</span> per group, where <span class="math inline">\(g\)</span> is the number of unique elements in that group. Across all <span class="math inline">\(k\)</span> remainder groups, this totals to <span class="math inline">\(O(n \log n)\)</span> since the sum of all group sizes is at most <span class="math inline">\(n\)</span>.</p>
<p>Then, for each group, we use memoized recursion to count all valid subsets. Each group of size <span class="math inline">\(g\)</span> contributes at most <span class="math inline">\(O(g)\)</span> recursive calls thanks to memoization (each index visited once). Across all groups, this step is bounded by <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the total time complexity is: <span class="math inline">\(O(n + n \log n + n) = O(n \log n)\)</span></p>
<blockquote>
<p>In Python3, <code>defaultdict</code> provides average-case <span class="math inline">\(O(1)\)</span> insertion time, so grouping the numbers by their remainder is <span class="math inline">\(O(n)\)</span>, not <span class="math inline">\(O(n \log n)\)</span> as would be the case in a language using a self-balancing BST (e.g., <code>TreeMap</code> in Java or <code>map</code> in C++).</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The frequency map stores the count of elements based on their remainders when divided by <code>k</code>. In the worst case, this requires <span class="math inline">\(O(n)\)</span> space, as it needs to store counts for each element.</p>
<p>The depth of the recursive call stack can grow up to the number of unique elements in the subset list, which is at most <span class="math inline">\(n\)</span>. Thus, the space used by the call stack is <span class="math inline">\(O(n)\)</span>.</p>
<p>For the <code>counts</code> array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to <span class="math inline">\(n\)</span>. This results in <span class="math inline">\(O(n)\)</span> space complexity for the <code>counts</code> array.</p>
<p>The <code>subsets</code> list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be <span class="math inline">\(n\)</span> such pairs, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>So, overall, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-dynamic-programming---iterative">Approach 5: Dynamic Programming - Iterative</h3>
<h4 id="intuition-4">Intuition</h4>
<p>We can reduce the overhead needed to solve the problem by changing the recursive approach to an iterative one using Dynamic Programming (DP). Instead of making recursive calls, which require space on the call stack, we can use an array to store the values of <code>f(i)</code> for different indices <code>i</code>.</p>
<p>To calculate <code>f(i)</code>, we need to know the values of <code>f(i + 1)</code> and <code>f(i + 2)</code>. This is because when we include the element at index <code>i</code> in the subset, we need to check if the next element <code>nums[i + 1]</code> satisfies the condition <code>|nums[i + 1] - nums[i]| != k</code>. If it does, we can include it in the subset, and the number of beautiful subsets starting from <code>i + 1</code> is <code>f(i + 1)</code>. Otherwise, we need to skip <code>nums[i + 1]</code> and consider the number of beautiful subsets starting from <code>i + 2</code>, which is <code>f(i + 2)</code>.</p>
<p>Since we need to know the values of <code>f(i + 1)</code> and <code>f(i + 2)</code> to compute <code>f(i)</code>, we need to fill the DP array from right to left, starting from the end of the array.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>Initialize <code>totalCount</code> to 1.</li>
<li>Initialize a <code>map</code> called <code>freqMap</code> to track the frequency of elements based on their remainder when divided by <code>k</code>.</li>
<li>Calculate frequencies for each element in <code>nums</code> and update <code>freqMap</code>.</li>
<li>Iterate over each remainder group in <code>freqMap</code>.
<ul>
<li>Calculate the number of elements <code>n</code> in the current group.</li>
<li>Convert the frequency map of each remainder group into an array of pairs (<code>subsets</code>) containing the element and its frequency.</li>
<li>Initialize an array called <code>counts</code> with size <code>n + 1</code> to store counts of subsets.</li>
<li>Initialize <code>counts[n]</code> to 1, representing the count of the last subset.</li>
<li>Iterate from the second-to-last subset to the first one.
<ul>
<li>Calculate subsets where the current subset is not taken (<code>skip</code>) by using the count of the next subset (<code>counts[i + 1]</code>).</li>
<li>Calculate subsets where the current subset is taken (<code>take</code>) by multiplying <code>(1 &lt;&lt; subsets[i].second) - 1</code> (representing all possible combinations of taking elements from the current subset) and the count of the next subset (<code>counts[i + 1]</code> or <code>count[i + 2]</code> depending on the difference condition).</li>
<li>Store the total count for the current subset in <code>counts[i]</code>.</li>
</ul>
</li>
<li>Multiply <code>totalCount</code> with the count of the first subset (stored in <code>counts[0]</code>).</li>
</ul>
</li>
<li>Return <code>totalCount - 1</code>.</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2597/approach5.json:960,333!?!</p>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/bTiP2YoC/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the nums arrays.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Since the map is sorted and implemented using a Self-Balancing Binary Search Tree (BST), the insert operation is <span class="math inline">\(O(\log n)\)</span>. Thus, constructing the map takes <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Then, iterating through each remainder group and its associated numbers involves nested loops. In the worst-case scenario, each remainder group contains <span class="math inline">\(n/k\)</span> elements. The time complexity of iterating through each remainder group is <span class="math inline">\(O(k \cdot (n/k) \log (n/k)) \)</span>. The number of groups is limited to <span class="math inline">\(n\)</span>, and so is the group size. Therefore, we can we can simplify this to <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The frequency map stores a remainder group for each unique remainder. Each remainder group stores an entry for each unique element in the group. In the worst case, when each element in <code>nums</code> is unique, <span class="math inline">\(n\)</span> elements will be stored across all of the remainder groups.</p>
<p>For the <code>counts</code> array, which is used for memoization, its size is equal to the number of unique elements in each subset list, which again can be up to <span class="math inline">\(n\)</span>. This results in <span class="math inline">\(O(n)\)</span> space complexity for the <code>counts</code> array.</p>
<p>The <code>subsets</code> list, derived from the frequency map, stores pairs of element values and their counts. In the worst case, there could be <span class="math inline">\(n\)</span> such pairs, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-6-dynamic-programming---optimized-iterative">Approach 6: Dynamic Programming - Optimized Iterative</h3>
<h4 id="intuition-5">Intuition</h4>
<p>In the previous iterative DP approach, we calculated the DP array in the reverse direction (right to left) of the array <code>s</code>. This was necessary because we needed to know the values of <code>f(i + 1)</code> and <code>f(i + 2)</code> to compute <code>f(i)</code>. However, the above approach required us to convert the sorted map (which represents the frequency of each element in the array) into an array (named <code>subsets</code>) first.</p>
<p>This conversion step can be avoided if we traverse the array(<code>s</code>) from left to right instead of right to left.</p>
<p>By traversing from left to right, we can directly use the sorted map and update the values of <code>f(i)</code> accordingly. This approach eliminates the need for the conversion step, thereby optimizing the time complexity.</p>
<p>We can also optimize space usage by observing that to calculate <code>f(i)</code>, we only need <code>f(i + 1)</code> and <code>f(i + 2)</code>. Storing <code>f(i + 3)</code> onwards is unnecessary, as those values are not required for further calculations.</p>
<p>Instead of using an array to store all the values of <code>f(i)</code>, we will use three variables <code>curr</code>, <code>prev1</code>, and <code>prev2</code> to store the values of <code>f(i)</code>, <code>f(i + 1)</code>, and <code>f(i + 2)</code>, respectively. We can update these variables in each iteration, effectively reusing the same space instead of allocating new space for each index.</p>
<p>The core idea is that, when we traverse from left to right, we can keep track of the elements we have processed so far. For each new element, we can check if it satisfies the condition <code>|nums[i] - nums[j]| != k</code> for all previously processed elements <code>j</code>. If the condition is satisfied, we can include the current element in the subset and update the value of <code>f(i)</code> accordingly.</p>
<h4 id="algorithm-5">Algorithm</h4>
<ul>
<li>Initialize <code>totalCount</code> to 1.</li>
<li>Initialize a <code>map</code> called <code>freqMap</code> to track the frequency of elements based on their remainder when divided by <code>k</code>.</li>
<li>Calculate frequencies for each element in <code>nums</code> and update <code>freqMap</code>.</li>
<li>Iterate over each remainder group in <code>freqMap</code>.
<ul>
<li>Initialize variables <code>prevNum</code>, <code>prev1</code>, and <code>prev2</code>.</li>
<li>Iterate through each number in the current remainder group.
<ul>
<li>Calculate subsets where the current number is not taken (<code>skip</code>) by using the count of the previous number (<code>prev1</code>).</li>
<li>Calculate subsets where the current number is taken (<code>take</code>) by multiplying <code>(1 &lt;&lt; freq) - 1</code> (representing all possible combinations of taking elements with the current frequency) and the count of the previous number (<code>prev1</code> or <code>prev2</code> depending on whether the current number and the previous number form a beautiful pair).</li>
<li>Store the total count for the current number in <code>curr</code>.</li>
<li>Update <code>prev2</code> with the value of <code>prev1</code>, <code>prev1</code> with the value of <code>curr</code>, and <code>prevNum</code> with the current number.</li>
</ul>
</li>
<li>Multiply <code>totalCount</code> with the count of the last calculated number (stored in <code>curr</code>).</li>
</ul>
</li>
<li>Return <code>totalCount - 1</code>.</li>
</ul>
<h4 id="implementation-5">Implementation</h4>
<p><a href="https://leetcode.com/playground/AaD47Fqd/shared">code</a></p>
<h4 id="complexity-analysis-5">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the nums array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The time complexity of this approach primarily arises from the operations on the map data structure. Since up to <span class="math inline">\(n\)</span> values are added to the frequency map, the sorting operation on the frequency map takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>Then, iterating through each remainder group and its associated numbers involves nested loops. In the worst-case scenario, each remainder group contains <span class="math inline">\(n/k\)</span> elements, where <span class="math inline">\(n/k\)</span> is a positive integer. The time complexity of iterating through each remainder group is <span class="math inline">\(O(k \cdot (n/k) \log (n/k)) \)</span>, which we can simplify to <span class="math inline">\(O(n \log n)\)</span>.</p>
<blockquote>
<p>The <span class="math inline">\((\log n)\)</span> term arises from the usage of the map data structure in the code. map/TreeMap is implemented as a self-balancing binary search tree (such as Red-Black Tree) in C++/Java, which provides logarithmic time complexity for operations such as insertion, deletion, and retrieval.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The frequency map stores a remainder group for each unique remainder. Each remainder group stores an entry for each unique element in the group. In the worst case, when each element in <code>nums</code> is unique, <span class="math inline">\(n\)</span> elements will be stored across all of the remainder groups. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/three-arrays-8ec556bc/" target="_blank" rel="noopener noreferrer">Three arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">basicprogramming</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given three arrays&nbsp;<span class="mathjax-latex">\(a_{1 \dots n}, b_{1 \dots n}, c_{1 \dots n}\)</span>&nbsp;and two numbers <strong><em>M</em></strong>&nbsp;and <strong><em>K</em></strong>. Find a lexicographically minimum <span class="mathjax-latex">\(\{x, y, z\}\)</span>&nbsp;such that there are exactly <strong><em>K</em></strong>&nbsp;indices <span class="mathjax-latex">\(i(1 \le i \le n)\)</span>&nbsp;where&nbsp;<span class="mathjax-latex">\(x*a_i+y*b_i-c_i*z = M*f\)</span>&nbsp;for some integer <span class="mathjax-latex">\(f\)</span>. Also, you are given ranges of <span class="mathjax-latex">\(x\)</span>, <span class="mathjax-latex">\(y\)</span>, and <span class="mathjax-latex">\(z\)</span>--&nbsp;<span class="mathjax-latex">\(l_{1..3}, r_{1..3}\)</span>(<span class="mathjax-latex">\((l_1 \le x \le r_1, l_2 \le y \le r_2, l_3 \le z \le r_3)\)</span>.&nbsp;Here, a triplet of integers&nbsp;<span class="mathjax-latex">\(\{x_1,y_1,z_1\}\)</span>&nbsp;is considered to be lexicographically smaller than a triplet&nbsp;<em><span class="mathjax-latex">\(\{x_2,y_2,z_2\}\)</span></em>&nbsp;if sequence <em><span class="mathjax-latex">\([x_1, y_1, z_1]\)</span></em>&nbsp;is lexicographically smaller than sequence <span class="mathjax-latex">\([x_2, y_2, z_2]\)</span>. A sequence <strong><em>a</em></strong>&nbsp;is lexicographically smaller than a sequence <strong><em>b</em></strong>&nbsp;if in the first position where <em>a</em>&nbsp;and <em>b</em> differ, the sequence&nbsp;<strong><em>a</em></strong> has a smaller element than the corresponding element in <strong><em>b</em></strong>.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line contains one three integers&nbsp;<span class="mathjax-latex">\(n, m, K (1 \le n \le 10000, 0 \le K \le n, 1 \le M \le 15)\)</span>.</li>
	<li>The next&nbsp;<strong>n</strong> lines contain three integers&nbsp;<span class="mathjax-latex">\(a_i, b_i, c_i (1 \le a_i, b_i, c_i \le 10^9)\)</span>.</li>
	<li>The next three lines contain two integers <span class="mathjax-latex">\(l_i, r_i (1 \le l_i \le r_i \le 10^9)\)</span>.</li>
</ul>

<p><strong>Output format</strong></p>

<p>If an answer does not exist, print <strong>-1</strong>. Otherwise,&nbsp;print desirable <span class="mathjax-latex">\(\{x, y, z\}\)</span>.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Since,Â <span class="mathjax-latex">\(K=n=4 \)</span>, the above condition must hold for all indices.Â <span class="mathjax-latex">\(i=1) \quad 3*5+3*6-3*1=30 \\i=2) \quad 3*2+3*6-3*9=-3 \\i=3) \quad 3*11+3*5-3*6=30\\i=4) \quad 3*1+3*1-3*1=3\)</span>. As we can see, it is correct.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/description" target="_blank" rel="noopener noreferrer">Tiling a Rectangle with the Fewest Squares</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a rectangle of size <code>n</code> x <code>m</code>, return <em>the minimum number of integer-sided squares that tile the rectangle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/17/sample_11_1592.png" style="width: 154px; height: 106px;" /></p>

<pre>
<strong>Input:</strong> n = 2, m = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> <code>3</code> squares are necessary to cover the rectangle.
<code>2</code> (squares of <code>1x1</code>)
<code>1</code> (square of <code>2x2</code>)</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/17/sample_22_1592.png" style="width: 224px; height: 126px;" /></p>

<pre>
<strong>Input:</strong> n = 5, m = 8
<strong>Output:</strong> 5
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/17/sample_33_1592.png" style="width: 224px; height: 189px;" /></p>

<pre>
<strong>Input:</strong> n = 11, m = 13
<strong>Output:</strong> 6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt;= 13</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-binary-search-trees-ii/description" target="_blank" rel="noopener noreferrer">Unique Binary Search Trees II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, our task is to return all unique BSTs (binary search trees) that have exactly <code>n</code> nodes of unique values from <code>1</code> to <code>n</code>.</p>
<hr />
<h3 id="approach-1-recursive-dynamic-programming">Approach 1: Recursive Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>In each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.</p>
<p>To find all the possible permutations of BSTs with <code>n</code> nodes, we can lock one node as the <code>root</code> node and split <code>n - 1</code> nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value <code>i</code> as the root node and place <code>i - 1</code> nodes having values from <code>1</code> to <code>i - 1</code> in the left subtree. (If <code>i == 1</code>, the left child is null). Similarly, we place the remaining <code>n - i</code> nodes having values from <code>i + 1</code> to <code>n</code> in the right subtree. (If <code>i == n</code>, the right child is null).</p>
<p>Now, we create a list of nodes called <code>leftSubTrees</code> for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called <code>rightSubTrees</code> for all the BSTs that could be the right subtree.</p>
<blockquote>
<p>In a BST, every subtree is also a BST.</p>
</blockquote>
<p>We iterate over both the lists and for each node pair <code>l</code> in <code>leftSubTrees</code> and <code>r</code> in <code>rightSubTrees</code>, we create a new <code>root</code> node with value <code>i</code> and set the left and right child of <code>root</code> to <code>l</code> and <code>r</code> respectively to form all the BSTs with the root node as <code>i</code>.</p>
<p>We can iterate over the root's value from <code>i = 1</code> to <code>n</code> and repeat the process for each root value to get all the BSTs.</p>
<p>You may notice that the subproblem of finding the arrays <code>leftSubTrees</code> and <code>rightSubTrees</code> are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with <code>n</code> nodes to smaller, repetitive subproblems with <code>i - 1</code> and <code>n - i</code> nodes (for <code>i = 1</code> till <code>n</code>) to compute the answer for <code>n</code> nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.</p>
<p>We implement a recursive function <code>allPossibleBST(start, end)</code> where <code>start</code> and <code>end</code> correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value <code>i</code>, we will find all the left subtrees using <code>leftSubTrees = allPossibleBST(start, i - 1)</code> and also compute all the right subtrees using <code>rightSubTrees = allPossibleBST(i + 1, right)</code>. Finally, we iterate over all pairs between <code>leftSubTrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair.</p>
<p>The base case of this function is when <code>start &gt; end</code>. We have no values in our range and thus we will return <code>null</code> (an empty tree).</p>
<p>Here is a visual representation of the recursion tree with <code>3</code> nodes:</p>
<p><img src="../Figures/95/95-1.png" alt="img" /></p>
<p>Several subproblems, such as <code>allPossibleBST(1, 1)</code>, <code>allPossibleBST(3, 3)</code>, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of <code>TreeNode</code>. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hash map <code>memo</code> where <code>memo[(start, end)]</code> contains the list of root nodes of all possible BSTs with the range of node values from <code>start</code> to <code>end</code>.</li>
<li>We implement a recursive function <code>allPossibleBST</code> which takes the starting range of node values <code>start</code>, ending range <code>end</code>, and <code>memo</code> as parameters. It returns a list of <code>TreeNode</code> corresponding to all the BSTs that can be formed with this range of node values. We call <code>allPossibleBST(1, n, memo)</code> and perform the following:
<ul>
<li>We declare a list of <code>TreeNode</code> called <code>res</code> to store the list of root nodes of all possible BSTs.</li>
<li>If <code>start &gt; end</code>, we push <code>null</code> to <code>res</code> and return it.</li>
<li>If we already have solved this subproblem, i.e., <code>memo</code> contains the pair <code>(start, end)</code>, we return <code>memo[(start, end)]</code>.</li>
<li>Select the root node value from <code>i = start</code> to <code>end</code> incrementing <code>i</code> by <code>1</code> after each iteration. We recursively call <code>leftSubtrees = llPossibleBST(start, i - 1, memo)</code> and <code>rightSubTrees = allPossibleBST(i + 1, end, memo)</code>. We iterate over all pairs between <code>leftSubtrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair. We push <code>root</code> of the new formed BST into <code>res</code>.</li>
<li>Set <code>memo[(start, end)] = res</code> and return <code>res</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FiZegYw8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Note, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.</p>
<p>The number of unique BSTs that can be formed with <code>n</code> nodes is <span class="math inline">\(G(n)\)</span> where <span class="math inline">\(G(n)\)</span> is the <span class="math inline">\(n^{th}\)</span> <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>. <span class="math inline">\(G(n) = O(\dfrac{4^{n}}{n^{1.5}})\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>There are <span class="math inline">\(G(n) = \dfrac{4^n}{n^{1.5}}\)</span> BSTs in our answer. Each of these BSTs has <span class="math inline">\(n\)</span> nodes, so it cost us <span class="math inline">\(O(n)\)</span> to build each one. This gives us a time complexity of <span class="math inline">\(O(n \cdot G(n)) = O(\dfrac{4^n}{\sqrt{n}})\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<p>We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in <code>memo</code>. Let's analyze how many nodes are stored in <code>memo</code>.</p>
<p>The number of nodes in a range <code>start, end</code> is <code>end - start + 1</code>. Let <span class="math inline">\(k = \text{end} - \text{start} + 1\)</span> represent this formula.</p>
<p>There are <span class="math inline">\(n\)</span> states <code>start, end</code> with one node, that is <span class="math inline">\(k = 1\)</span>.</p>
<p>There are <span class="math inline">\(n - 1\)</span> states <code>start, end</code> with two nodes, that is <span class="math inline">\(k = 2\)</span>.</p>
<p>There are <span class="math inline">\(n - 2\)</span> states <code>start, end</code> with three nodes, that is <span class="math inline">\(k = 3\)</span>.</p>
<p>This continues until there is only one state with <span class="math inline">\(n\)</span> nodes (the original input). In general, a value of <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states.</p>
<p>For a given state with value <span class="math inline">\(k\)</span>, there are <span class="math inline">\(G(k) = \dfrac{4^k}{k^{1.5}}\)</span> BSTs. Each of these BSTs has <span class="math inline">\(k\)</span> nodes, and thus takes up <span class="math inline">\(k \cdot G(k) = \dfrac{4^k}{\sqrt{k}}\)</span> space in <code>memo</code>.</p>
<p>A given value <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states and thus takes up <span class="math inline">\((n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}\)</span> space. In our algorithm, <span class="math inline">\(k\)</span> ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p>
<p>The space complexity is the summation for all values of <span class="math inline">\(k\)</span>:</p>
<p><span class="math inline">\(\Large{\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]}}\)</span></p>
<p>This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:</p>
<p><span class="math inline">\(4^{1 + n} \cdot \Phi(4, -0.5, 1 + n) - 4^{1 + n} \cdot (1 + n) \cdot \Phi(4, 0.5, 1 + n) - \text{Li}_{-0.5}(4) + \text{Li}_{0.5}(4) + n \cdot \text{Li}_{0.5}(4)\)</span></p>
<p>Where <span class="math inline">\(\Phi\)</span> is the <a href="https://en.wikipedia.org/wiki/Lerch_zeta_function">Lerch transcendent</a> and <span class="math inline">\(\text{Li}_n(x)\)</span> is the <a href="https://en.wikipedia.org/wiki/Polylogarithm">polylogarithm function</a>. Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.</p>
<p>We create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of all BSTs that have node values ranging from <code>i</code> to <code>j</code>. Note that <code>dp[i][j] = allPossibleBST(i, j)</code> from the previous approach.</p>
<p>When <code>i = j</code>, the range contains only one node with value <code>i</code>. We push a single node with value <code>i</code> in the list <code>dp[i][i]</code> for all the values of <code>i</code> from <code>1</code> to <code>n</code>. This acts as the base case of our solution while we move in bottom to top manner.</p>
<p>We form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from <code>numberOfNodes = 2</code> to <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. This loop controls the total number of nodes under consideration.</p>
<p>We further need to choose a node value we start with. Let's call it <code>start</code>. As we have <code>numberOfNodes</code> nodes under consideration with consecutive values, the maximum node value in such a BST would be <code>end = start + numberOfNodes - 1</code>. We will move <code>start</code> from <code>1</code> to <code>n - numberOfNodes + 1</code>.</p>
<p>Now we have the <code>start</code> value and the <code>end</code> value, we can implement the same logic that we did in the <code>allPossibleBST</code> function from the previous approach. Lock a value <code>i</code>, find all left and right subtrees, and then iterate over each <code>left, right</code> pair and create a new root with value <code>i</code> for each pair.</p>
<p>As we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.</p>
<p>Locking a value <code>i</code> as the root node, we can find all left subtrees in <code>dp[start][i - 1]</code> and all right subtrees in <code>dp[i + 1][end]</code>. If <code>i == start</code>, the left subtree would be empty. Similarly, if <code>i == end</code>, the right subtree would be empty. We can handle these cases separately.</p>
<p>We run an outer loop from <code>numberOfNodes = 2</code> to <code>n</code>. We run an inner loop that selects the starting node value. It runs from <code>start = 1</code> to <code>n - numberOfNodes + 1</code>. We define <code>end = start + numberOfNodes - 1</code>. We run a third nested loop that selects the root of the BSTs under consideration. It runs from <code>i = start</code> to <code>end</code>.</p>
<p>We then iterate over the both the lists of left and right subtrees. For each root node <code>l</code> of the left subtree and <code>r</code> of the right subtree, we create a new <code>root</code> node with value <code>i</code> and set the left and right child to <code>l</code> and <code>r</code> respectively to form all the BSTs with root node as <code>i</code>. We also push each BST into <code>dp[start][end]</code> to be used later to build answer for other <code>dp</code> states with larger number of nodes.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of root nodes for all possible BSTs using <code>j - i + 1</code> nodes with values from <code>i</code> to <code>j</code> nodes.</li>
<li>We initialize each list <code>dp[i][i]</code> to a <code>TreeNode</code> having value <code>i</code> for <code>i = 0</code> to <code>n</code>.</li>
<li>Iterate from <code>numberOfNodes = 2</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>start = 1</code> to <code>n - numberOfNodes + 1</code> incrementing <code>start</code> by <code>1</code>. We create an integer variable <code>end = start + numberOfNodes - 1</code> which stores the highest node value of the BSTs that will be formed. We run another loop from <code>i = start</code> to <code>end</code> to use all the permutations as the root node value. We perform the following in this loop:
<ul>
<li>We create a list of <code>TreeNode</code> called <code>leftSubtrees</code> which will store all the BSTs that can be formed with node values from <code>start</code> to <code>i - 1</code>. If <code>i == start</code>, we just add <code>null</code> to <code>leftSubtrees</code>, else <code>leftSubtrees == dp[start][i - 1]</code>.</li>
<li>Similarly, we create a list of <code>TreeNode</code> called <code>rightSubtrees</code> which will store all the BSTs that can be formed with node values from <code>i + 1</code> to <code>end</code>. If <code>i == end</code>, we just add <code>null</code> to <code>rightSubtrees</code>, else <code>rightSubtrees == dp[i + 1][end]</code>.</li>
<li>We form a new BST by creating a new node which acts as a root node with value <code>i</code>. For each element <code>left</code> in <code>leftSubtrees</code> and <code>right</code> in <code>rightSubtrees</code>, we set <code>root.left = left</code> and <code>root.right = right</code>. Finally, we add <code>root</code> to <code>dp[start][end]</code>.</li>
</ul>
</li>
<li>Return <code>dp[1][n]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/hj8MdGva/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>The time complexity of this approach will be similar to the <strong>time complexity</strong> of the first approach because we are iterating over the same <code>dp</code> states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<ul>
<li>The space complexity would also be the number of BSTs stored in the <code>dp</code> list which is equal to the number of BSTs stored in <code>memo</code> in the worst-case. Hence, we have the same space complexity as the first approach.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-with-space-optimization">Approach 3: Dynamic Programming with Space Optimization</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We used a 3D list where we used <code>dp[start][end]</code> to store all the BSTs having <code>end - start + 1</code> nodes with range from <code>start</code> to <code>end</code>. Let's think if we can reduce the 3D <code>dp</code> list to a 2D list.</p>
<p>If we compare all the BSTs that can be created from a set of consecutive values from <code>start</code> to <code>end</code> to those that can be created with the same number of nodes from a set of values starting at <code>1</code> and ending at <code>end - start + 1</code>, we will find that <strong>the structure of all the BSTs created with the above two ranges would be identical</strong>. The only difference is an offset of <code>start - 1</code> in the node values.</p>
<p>Here's a visual representation of BSTs with 3 nodes from range <code>[1, 3]</code> and all BSTs with range <code>[4, 6]</code>:</p>
<p><img src="../Figures/95/95-2.png" alt="img" /></p>
<p>We can see the structure of all the BSTs created with the above two ranges are identical.</p>
<p>So, we can just store the BSTs for all the ranges starting from <code>1</code> and add the offset to convert them to required ranges.</p>
<p>We create a 2D list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of all BSTs with <code>i</code> nodes having values from <code>1</code> to <code>i</code>. <code>dp[n]</code> would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.</p>
<p>We push a <code>null</code> node (empty tree) to <code>dp[0]</code> which acts as the base case.</p>
<p>To get the list of root nodes for all possible BSTs with <code>numberOfNodes</code> nodes, we would split the <code>numberOfNodes</code> nodes with <code>i - 1</code> nodes with values <code>1</code> to <code>i - 1</code> in the left subtree, a root node with value <code>i</code> and the remaining <code>numberOfNodes - i</code> nodes with values <code>i + 1</code> to <code>numberOfNodes</code> in the right subtree where <code>1 &lt;= i &lt;= numberOfNodes</code>. Note that we do not need the starting of the range here, unlike the previous approach. It is always <code>1</code>.</p>
<p>As we are executing in bottom-up manner and figuring out the answer for <code>numberOfNodes</code> nodes, we will already have the list of root nodes for all BSTs with <code>i - 1</code> and <code>numberOfNodes - i</code> nodes (for all values of <code>i = 1</code> to <code>numberOfNodes</code>).</p>
<p>However, you may realize that <code>dp[i - 1]</code> will give all the BSTs having values from <code>1</code> to <code>i - 1</code> which is exactly what we want but <code>dp[numberOfNodes - i]</code> will give all the BSTs having values from <code>1</code> to <code>numberOfNodes - i</code> which isn't what we want. We want the right subtree to have <code>numberOfNodes - i</code> nodes but the range of nodes should be from <code>i + 1</code> to <code>numberOfNodes</code>. If we add the offset <code>(i + 1) - 1 = i</code> to all the nodes, it would solve this as we would now have trees with <code>numberOfNodes - i</code> nodes from values <code>i + 1</code> to <code>numberOfNodes</code>. Let us form the BSTs now.</p>
<p>Similar to the previous approach, we create a new instance of <code>TreeNode</code> called <code>root</code> with the value <code>i</code>. We set the left child of <code>root</code> to an element in <code>dp[i - 1]</code>.</p>
<p>Now, let's set the right child of <code>root</code>. We know every element in <code>dp[numberOfNodes - i]</code> is a root node that stores a BST with <code>numberOfNodes - 1</code> nodes having values from <code>1</code> to <code>numberOfNodes - i</code>. To set the right child of <code>root</code>, we create a new tree exactly similar to the tree stored by an element of <code>dp[numberOfNodes - i]</code> but increment all the node values of the new tree by <code>i</code>. We then set the right child of <code>root</code> to this newer tree.</p>
<p>The required tree with <code>i</code> offset can be created by using a recursive function <code>clone</code> in which we pass a <code>TreeNode node</code> which corresponds to an element in <code>dp[numberOfNodes - i]</code> and an integer <code>offset</code>. We create a new <code>TreeNode clonedNode</code> with value <code>node.val + offset</code>. We then recursively set the left and the right child of <code>clonedNode</code> by performing <code>clonedNode.left = clone(node.left, offset)</code> and <code>clonedNode.right = clone(node.right, offset)</code>. Finally, return <code>clonedNode</code>.</p>
<p>It is important to note that we are creating new trees to set the right child of <code>root</code> to preserve the original trees as it might be used directly (as <code>dp[i - 1]</code>) in some other iteration of <code>i</code> and <code>numberOfNodes</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible BSTs using <code>i</code> nodes. We initialize each list <code>dp[i]</code> to an empty list for <code>i = 0</code> to <code>n</code>.</li>
<li>We push a <code>null</code> node (empty tree) into <code>dp[0]</code> because with <code>n = 0</code> we can't have any BST. This forms the base case.</li>
<li>Iterate from <code>numberOfNodes = 1</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>i = 1</code> to <code>numberOfNodes</code> incrementing <code>i</code> by <code>1</code>. We perform the following in this loop:
<ul>
<li>Create a variable <code>j = numberOfNodes - i - 1</code>. It presents the number of nodes in the right subtree under consideration.</li>
<li>We can form a new BST by creating a new node which acts as a root node with value <code>i</code>. We assign its left child to any element in <code>dp[i]</code> and right child to a new tree where tree is similar to an element in <code>dp[j]</code> but all node values are incremented by <code>i</code>. As a result, we need two loops to iterate through the lists <code>dp[i]</code> and <code>dp[j]</code>. We create a new <code>root</code> node with value <code>i</code>. For each element <code>left</code> in <code>dp[i]</code> and <code>right</code> in <code>dp[j]</code>, we set <code>root.left = left</code> and <code>root.right = clone(right, i)</code>. Finally, we add <code>root</code> to <code>dp[numberOfNodes]</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/a8x29E6y/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range <code>1</code>. However, we are creating all the BSTs for all the ranges from <code>[start, end]</code> (for <code>1 &lt;= start, end  &lt;= 1</code>) using the <code>clone</code> method by iterating over the BSTs starting with range <code>1</code>.</li>
<li>As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</p>
<ul>
<li>For any state <code>dp[k]</code>, we are storing all the BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. We know there are <span class="math inline">\(G(k)\)</span> BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. As we have <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> states, the total space consumed would be <span class="math inline">\(O(\sum_{k=1}^{n} k \cdot G(k))\)</span> = <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/unique-partitions1041/1" target="_blank" rel="noopener noreferrer">Unique partitions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a positive integer <strong>n</strong>, generate all possible unique ways to represent <strong>n</strong> as sum of positive integers.</span></p>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong>The generated output is&nbsp;printed without partitions.&nbsp;Each partition must be&nbsp;in decreasing order. Printing of all the partitions is done in reverse sorted order.&nbsp;</span><br /><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3
<strong>Output: </strong>3 2 1 1 1 1
<strong>Explanation: </strong>For n = 3, 
{3}, {2, 1} and {1, 1, 1}.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4 
<strong>Output: </strong>4 3 1 2 2 2 1 1 1 1 1 1
<strong>Explanation: </strong>For n = 4, 
{4}, {3, 1}, {2, 2}, {2, 1, 1}, {1, 1, 1, 1}.</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>UniquePartitions()&nbsp;</strong>which takes n as input parameter and returns a list of all possible combinations in lexicographically decreasing order.&nbsp;</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(2<sup>n</sup>)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(2<sup>n</sup>)</span><br /><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= n &lt;= 25</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-paths-iii/description" target="_blank" rel="noopener noreferrer">Unique Paths III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer array <code>grid</code> where <code>grid[i][j]</code> could be:</p>

<ul>
	<li><code>1</code> representing the starting square. There is exactly one starting square.</li>
	<li><code>2</code> representing the ending square. There is exactly one ending square.</li>
	<li><code>0</code> representing empty squares we can walk over.</li>
	<li><code>-1</code> representing obstacles that we cannot walk over.</li>
</ul>

<p>Return <em>the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique1.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique2.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,1],[2,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>1 &lt;= m * n &lt;= 20</code></li>
	<li><code>-1 &lt;= grid[i][j] &lt;= 2</code></li>
	<li>There is exactly one starting cell and one ending cell.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/subsets-1587115621/1" target="_blank" rel="noopener noreferrer">Unique Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">sorting</span> <span class="topic-badge">subset</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an array <strong>arr[]</strong><strong> </strong>of integers&nbsp;of size <strong>N</strong> that might contain <strong>duplicates</strong>, the task is to find all possible unique subsets.</span></p>

<p><span style="font-size:18px"><strong>Note:</strong> Each subset should be sorted.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 3, arr[] = {2,1,2}
<strong>Output:</strong>(),(1),(1 2),(1 2 2),(2),(2 2)</span>
<span style="font-size:18px"><strong>Explanation: </strong>
All possible subsets = (),(2),(1),(1,2),(2),(2,2),(2,1),(2,1,2)
After Sorting each subset = (),(2),(1),(1,2),(2),(2,2),(1,2),(1,2,2) 
Unique Susbsets in Lexicographical order = (),(1),(1,2),(1,2,2),(2),(2,2)</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>N = 4, arr[] = {1,2,3,3}
<strong>Output: </strong>(),(1),(1 2),(1 2 3)
(1 2 3 3),(1 3),(1 3 3),(2),(2 3)
(2 3 3),(3),(3 3)</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Your task is to complete the function <strong>AllSubsets()</strong>&nbsp;which takes the array <strong>arr[]</strong> and <strong>N</strong> as input parameters and returns list of&nbsp;all possible unique subsets in lexicographical order.&nbsp;</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(2<sup>N</sup>).<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(2<sup>N</sup>&nbsp;* X), X = Length of each subset.</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N &le; 12</span><br />
<span style="font-size:18px">1 &le; arr[i] &le; 9</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/verbal-arithmetic-puzzle/description" target="_blank" rel="noopener noreferrer">Verbal Arithmetic Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">math</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an equation, represented by <code>words</code> on the left side and the <code>result</code> on the right side.</p>

<p>You need to check if the equation is solvable under the following rules:</p>

<ul>
	<li>Each character is decoded as one digit (0 - 9).</li>
	<li>No two characters can map to the same digit.</li>
	<li>Each <code>words[i]</code> and <code>result</code> are decoded as one number <strong>without</strong> leading zeros.</li>
	<li>Sum of numbers on the left side (<code>words</code>) will equal to the number on the right side (<code>result</code>).</li>
</ul>

<p>Return <code>true</code> <em>if the equation is solvable, otherwise return</em> <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Map &#39;S&#39;-&gt; 9, &#39;E&#39;-&gt;5, &#39;N&#39;-&gt;6, &#39;D&#39;-&gt;7, &#39;M&#39;-&gt;1, &#39;O&#39;-&gt;0, &#39;R&#39;-&gt;8, &#39;Y&#39;-&gt;&#39;2&#39;
Such that: &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; ,  9567 + 1085 = 10652</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Map &#39;S&#39;-&gt; 6, &#39;I&#39;-&gt;5, &#39;X&#39;-&gt;0, &#39;E&#39;-&gt;8, &#39;V&#39;-&gt;7, &#39;N&#39;-&gt;2, &#39;T&#39;-&gt;1, &#39;W&#39;-&gt;&#39;3&#39;, &#39;Y&#39;-&gt;4
Such that: &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; ,  650 + 68782 + 68782 = 138214</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no possible mapping to satisfy the equation, so we return false.
Note that two different characters cannot map to the same digit.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= words.length &lt;= 5</code></li>
	<li><code>1 &lt;= words[i].length, result.length &lt;= 7</code></li>
	<li><code>words[i], result</code> contain only uppercase English letters.</li>
	<li>The number of different characters used in the expression is at most <code>10</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-boggle4143/1" target="_blank" rel="noopener noreferrer">Word Boggle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a dictionary of distinct <strong>words</strong> and an <strong>M x N</strong> board where every cell has one character. Find all possible words from the dictionary that can be formed by a sequence of adjacent characters on the board. We can move to any of 8 adjacent characters</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;While forming a word we can move to&nbsp;any of the 8 adjacent cells. A&nbsp;cell can be used&nbsp;only once in one word.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: 
</strong>N = 1
dictionary = {"CAT"}
R = 3, C = 3
board = {{C,A,P},{A,N,D},{T,I,E}}
<strong>Output:</strong>
CAT
<strong>Explanation</strong>: 
<span style="color: #800080;">C</span> A P
<span style="color: #800080;">A</span> N D
<span style="color: #800080;">T</span> I E
Words we got is denoted using same color.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 4
dictionary = {"GEEKS","FOR","QUIZ","GO"}
R = 3, C = 3 
board = {{G,I,Z},{U,E,K},{Q,S,E}}
<strong>Output:</strong>
GEEKS QUIZ
<strong>Explanation</strong>: 
<span style="color: #ff8c00;">G</span> <span style="color: #0000cd;">I</span> <span style="color: #0000cd;">Z</span>
<span style="color: #0000cd;">U</span> <span style="color: #ff8c00;">E</span> <span style="color: #ff8c00;">K</span>
<span style="color: #0000cd;">Q</span> <span style="color: #ff8c00;">S</span> <span style="color: #ff8c00;">E</span> 
Words we got is denoted using same color.</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your task:</strong><br />You dont need to read input or print anything. Your task is to complete the function&nbsp;<strong>wordBoggle()</strong>&nbsp;which takes the dictionary contaning N&nbsp;space-separated strings and R*C board </span><span style="font-size: 18px;">as input parameters and returns a list of&nbsp;words that exist on the board in <strong>lexicographical order</strong>.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(N*W + R*C^2)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*W + R*C)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N&nbsp;&le; 15<br />1 &le; R, C&nbsp;&le; 50<br />1 &le; length of Word&nbsp;&le; 60<br />Each word can consist of both lowercase and uppercase letters.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-break-part-23249/1" target="_blank" rel="noopener noreferrer">Word Break - 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a string <strong><code data-start="116" data-end="119">s</code></strong> and a dictionary <strong><code data-start="137" data-end="145">dict[] </code></strong>of valid words, you need to return <strong>all possible ways</strong> to break the string&nbsp;<strong>s </strong>into <strong>sentence </strong>such that each word in the sentence is a valid dictionary word. <br />You are allowed to use a valid word multiple times in the sentence.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> s = "likegfg", dict[] = ["lik", "like", "egfg", "gfg"]
<strong>Output:</strong> <br />"lik egfg"<br />"like gfg"
<strong>Explanation:</strong> All the words in the given sentences are present in the dictionary.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> s = "geeksforgeeks", dict[] = ["for", "geeks"]
<strong>Output:</strong> "geeks for geeks"
<strong>Explanation:</strong> The string "geeksforgeeks" can be broken into valid words from the dictionary in one way.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; dict.size() &le; 20<br />1 &le; dict[i] &le; 15<br />1 &le; s.size() &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-break-ii/description" target="_blank" rel="noopener noreferrer">Word Break II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>

<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]
<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]
<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]
<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 20</code></li>
	<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
	<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
	<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
	<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
	<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have a string <code>s</code> and a dictionary of strings <code>wordDict</code>. The task is to add spaces in <code>s</code> to construct valid sentences where each word is present in <code>wordDict</code> and return all possible valid sentences. The same word from the dictionary can be reused multiple times.</p>
<p>This problem is an extension of <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a>, where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a> as well as <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Problem 208. Implement Trie Prefix Tree</a>, as those questions provide the foundational concepts and intuition necessary for solving this problem.</p>
<p>Here, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms.</p>
<p>To gain an understanding of their underlying mechanisms, we suggest you check out these explore cards:</p>
<ol>
<li><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Backtracking Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card</a>.</li>
</ol>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>Initially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string.</p>
<p>At each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one.</p>
<p>If we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index.</p>
<p>The backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions.</p>
<p>The process is visualized below:</p>
<p><img src="../Figures/140/backtrack.png" alt="backtrack" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty array <code>results</code> to store valid sentences.</li>
<li>Initialize an empty string <code>currentSentence</code> to keep track of the sentence being constructed.</li>
<li>Call the <code>backtrack</code> function with the input string <code>s</code>, <code>wordSet</code>, <code>currentSentence</code>, <code>results</code>, and a starting index set to 0, the beginning of the input string.</li>
<li>Return <code>results</code>.</li>
</ul>
<p><strong><code>backtrack</code> Function:</strong></p>
<ul>
<li>Base Case: If the <code>startIndex</code> is equal to the length of the string, add the <code>currentSentence</code> to <code>results</code> and return as it means that <code>currentSentence</code> represents a valid sentence.</li>
<li>Iterate over possible <code>endIndex</code> values from <code>startIndex + 1</code> to the end of the string.
<ul>
<li>Extract the substring <code>word</code> from <code>startIndex</code> to <code>endIndex - 1</code>.</li>
<li>If <code>word</code> is found in <code>wordSet</code>:
<ul>
<li>Store the current <code>currentSentence</code> in <code>originalSentence</code>.</li>
<li>Append <code>word</code> to <code>currentSentence</code> (with a space if needed).</li>
<li>Recursively call <code>backtrack</code> with the updated <code>currentSentence</code> and <code>endIndex</code>.</li>
<li>Reset <code>currentSentence</code> to its original value (<code>originalSentence</code>) to backtrack and try the next <code>endIndex</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return from the <code>backtrack</code> function.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/izdRa3p9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has <span class="math inline">\(2^n\)</span> leaf nodes, resulting in an exponential time complexity. For each leaf node, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>Since each position in the string can be a split point or not, and for <span class="math inline">\(n\)</span> positions, there are <span class="math inline">\(2^n\)</span> possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming---memoization">Approach 2: Dynamic Programming - Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.</p>
<p>We use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).</p>
<p>If the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.</p>
<p>By memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty unordered map <code>memoization</code> to store the results of subproblems.</li>
<li>Call the <code>dfs</code> function with the input string <code>s</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
</ul>
<p><strong><code>dfs</code> Function:</strong></p>
<ul>
<li>Check if the answer for the current <code>remainingStr</code>(the remaining part of the string to be processed) are already in <code>memoization</code>. If so, return them.</li>
<li>Base Case: If <code>remainingStr</code> is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.</li>
<li>Initialize an empty array <code>results</code>.</li>
<li>Iterate from 1 to the length of <code>remainingStr</code>:
<ul>
<li>Extract the substring <code>currentWord</code> from 0 to <code>i</code> to check if it is a valid word.</li>
<li>If <code>currentWord</code> is found in <code>wordSet</code>:
<ul>
<li>Recursively call <code>dfs</code> with <code>remainingStr.substr(i)</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
<li>Append <code>currentWord</code> and the recursive results to <code>results</code>(with a space if needed) to form valid sentences.</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>results</code> for <code>remainingStr</code> in <code>memoization</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ri3aMwXd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still unique <span class="math inline">\(2^n\)</span> possible substrings that need to be explored, leading to an exponential time complexity. For each subproblem, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>The memoization map needs to store the results for all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> substrings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming---tabulation">Approach 3: Dynamic Programming - Tabulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table (or map) of valid sentences for each starting index in the string.</p>
<p>The tabulation approach is often more efficient than backtracking and memoization in terms of time and space complexity because it avoids the overhead of recursive calls and stack usage. It also eliminates the need for a separate memoization map, as the table itself serves as the storage for the subproblem solutions.</p>
<p>The tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning. At each step, we construct all possible sentences that can be formed starting from the current index by checking if substrings form valid words in the dictionary.</p>
<p>If a valid word is found, we combine it with the valid sentences formed from the remaining substring. This process continues until we reach the beginning of the string, building up the table of valid sentences for each starting index.</p>
<p>The key idea behind tabulation is that we ensure all subproblems are solved before they are needed, enabling the construction of complete solutions in an organized manner. By iterating from the end to the beginning of the string, we guarantee that the necessary subproblems have already been solved when we need them.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an empty unordered map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string to the beginning (<code>startIdx</code> from <code>s.size()</code> to 0):
<ul>
<li>Initialize an empty array <code>validSentences</code> to store all valid sentences starting from that index.</li>
<li>Iterate from <code>startIdx</code> to the end of the string (<code>endIdx</code>):
<ul>
<li>Extract the substring <code>currentWord</code> from <code>startIdx</code> to <code>endIdx</code>.</li>
<li>If <code>currentWord</code> is a valid word in <code>wordDict</code>:
<ul>
<li>If <code>endIdx</code> is the last index, add <code>currentWord</code> to <code>validSentences</code>.</li>
<li>Else, append <code>currentWord</code> to each sentence formed by the remaining substring (<code>sentencesFromNextIndex</code>) from <code>dp[endIdx + 1]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>validSentences</code> in <code>dp[startIdx]</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code> (valid sentences formed from the entire string).</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/140/tabulation.json:976,631!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWJckozB/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Similar to memoization, the tabulation approach still needs to explore all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> in the worst case, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed to explore each substring, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The dynamic programming table or map needs to store the valid sentences for all possible starting indices, which can be up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-trie-optimization">Approach 4: Trie Optimization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>While the previous approaches focus on optimizing the search and computation process, we can also consider leveraging efficient data structures to enhance the word lookup process. This leads us to the trie-based approach, which uses a trie data structure to store the word dictionary, allowing efficient word lookup and prefix matching.</p>
<blockquote>
<p>The trie, also known as a prefix tree, is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. This structure is particularly useful for problems involving word segmentation because it allows for efficient prefix matching.</p>
</blockquote>
<p>Here, we first build a trie from the dictionary words. Each word is represented as a path in the trie, where each node corresponds to a character in the word.</p>
<p>By using the trie, we can quickly determine whether a substring can form a valid word without having to perform linear searches or set lookups. This reduces the search space and improves the efficiency of the algorithm.</p>
<p>In this approach, instead of recursively exploring the remaining substring and using memoization, we iterate from the end of the input string to the beginning (in reverse order). For each starting index (<code>startIdx</code>), we attempt to find valid sentences that can be formed from that index by iterating through the string and checking if the current substring forms a valid word using the trie data structure.<br />
When a valid word is encountered in the trie, we append it to the list of valid sentences for the current starting index. If the current valid word is not the last word in the sentence, we combine it with the valid sentences formed from the next index (<code>endIdx + 1</code>), which are retrieved from the <code>dp</code> dictionary.</p>
<p>The valid sentences for each starting index are stored in the <code>dp</code> dictionary, ensuring that previously computed results are reused. By using tabulation and storing the valid sentences for each starting index, we avoid redundant computations and achieve significant time and space efficiency improvements compared to the standard backtracking method with memoization.</p>
<p>The trie-based approach offers advantages in terms of efficient word lookup and prefix matching, making it particularly suitable for problems involving word segmentation or string manipulation. However, it comes with the additional overhead of constructing and maintaining the trie data structure, which can be more memory-intensive for large dictionaries.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Initialize TrieNode Structure</strong></p>
<ul>
<li>Each TrieNode has two properties:</li>
<li><code>isEnd</code>: A boolean value indicating if the node marks the end of a word.</li>
<li><code>children</code>: An array of size 26 (for lowercase English letters) to store pointers to child nodes.</li>
<li>The constructor initializes <code>isEnd</code> to <code>false</code> and all elements in <code>children</code> to <code>null</code>.</li>
</ul>
<p><strong>Trie Class</strong></p>
<ul>
<li>The Trie class has a <code>root</code> pointer of type <code>TrieNode</code>.</li>
<li>The constructor initializes the <code>root</code> with a new <code>TrieNode</code> object.</li>
<li>The <code>insert</code> function:</li>
<li>Takes a string <code>word</code> as input.</li>
<li>Starts from the <code>root</code> node.</li>
<li>For each character <code>c</code> in the <code>word</code>:
<ul>
<li>Calculate the index corresponding to the character.</li>
<li>If the child node at the calculated index doesn't exist, create a new <code>TrieNode</code> and assign it to that index.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>After processing all characters, mark the current node's <code>isEnd</code> as <code>true</code>.</li>
</ul>
<p><strong>wordBreak Function</strong></p>
<ul>
<li>Create a <code>Trie</code> object.</li>
<li>Insert all words from <code>wordDict</code> into the trie using the <code>insert</code> function.</li>
<li>Initialize a map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string <code>s</code> to the beginning (in reverse order).</li>
<li>For each starting index <code>startIdx</code>:
<ul>
<li>Initialize a vector <code>validSentences</code> to store valid sentences starting from <code>startIdx</code>.</li>
<li>Initialize a <code>current_node</code> pointer to the <code>root</code> of the trie.</li>
<li>Iterate from <code>startIdx</code> to the end of the string.
<ul>
<li>For each character <code>c</code> in the string:
<ul>
<li>Calculate the index corresponding to <code>c</code>.</li>
<li>Check if the child node at the calculated index exists in the trie.</li>
<li>If the child node doesn't exist, break out of the inner loop. This means that the current substring cannot form a valid word, so there is no need to continue checking the remaining characters.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Check if the current node's <code>isEnd</code> is <code>true</code>, indicating a valid word.</li>
<li>If a valid word is found:
<ul>
<li>Extract the current word from the string using <code>substr</code>.</li>
<li>If it's the last word in the sentence (<code>endIdx</code> is the last index):
<ul>
<li>Add the current word to <code>validSentences</code>.</li>
</ul>
</li>
<li>If it's not the last word:
<ul>
<li>Retrieve the valid sentences formed by the remaining substring from <code>dp[endIdx + 1]</code>.</li>
<li>Combine the current word with each sentence and add it to <code>validSentences</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>validSentences</code> for the current <code>startIdx</code> in <code>dp</code>.</li>
</ul>
</li>
<li>Return the valid sentences stored in <code>dp[0]</code>, which represents the valid sentences formed from the entire string.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/YBoyT88T/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Even though the trie-based approach uses an efficient data structure for word lookup, it still needs to explore all possible ways to break the string into words. In the worst case, there are <span class="math inline">\(2^n\)</span> unique possible partitions, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed for each partition, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The trie data structure itself can have a maximum of <span class="math inline">\(2^n\)</span> nodes in the worst case, where each character in the string represents a separate word. Additionally, the tabulation map used in this approach can also store up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span>, resulting in an overall exponential space complexity.</p>
</li>
</ul>
<hr />
<p><strong>Further Thoughts On Complexity Analysis:</strong></p>
<p>The complexity of this problem cannot be reduced from <span class="math inline">\(n \cdot 2^n\)</span>; the worst-case scenario will still be <span class="math inline">\((n \cdot 2^n)\)</span>. However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case.</p>
<p>Consider the input <code>&quot;aaaaaa&quot;</code>, with <code>wordDict = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;, &quot;aaaaa&quot;]</code>.<br />
Every possible partition is a valid sentence, and there are <span class="math inline">\(2^{n-1}\)</span> such partitions. The algorithms cannot perform better than this since they must generate all valid sentences. The cost of iterating over cached results will be exponential, as every possible partition will be cached, resulting in the same runtime as regular backtracking. Likewise, the space complexity will also be <span class="math inline">\(O(n \cdot 2^n)\)</span> for the same reasonâ€”every partition is stored in memory.</p>
<p>Another way to explain why the worst-case complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span> for all the algorithms is that, given an array of length <span class="math inline">\(n\)</span>, there are <span class="math inline">\(n+1\)</span> ways/intervals to partition it into two parts. Each interval has two choices: to split or not to split. In the worst case, we will have to check all possibilities, which results in a time complexity of <span class="math inline">\(O(n \cdot 2^{n+1})\)</span>, which simplifies to <span class="math inline">\(O(n \cdot 2^n)\)</span>. This analysis is extremely similar to palindrome partitioning.</p>
<p>Overall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-ladder-ii/description" target="_blank" rel="noopener noreferrer">Word Ladder II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>

<ul>
	<li>Every adjacent pair of words differs by a single letter.</li>
	<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
	<li><code>s<sub>k</sub> == endWord</code></li>
</ul>

<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]
<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:
&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;
&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]
<strong>Output:</strong> []
<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>
	<li><code>endWord.length == beginWord.length</code></li>
	<li><code>1 &lt;= wordList.length &lt;= 500</code></li>
	<li><code>wordList[i].length == beginWord.length</code></li>
	<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>
	<li><code>beginWord != endWord</code></li>
	<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>
	<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-search/description" target="_blank" rel="noopener noreferrer">Word Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>

<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n = board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 6</code></li>
	<li><code>1 &lt;= word.length &lt;= 15</code></li>
	<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-search/1" target="_blank" rel="noopener noreferrer">Word Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a <strong>two-dimensional</strong> <strong>mat[][]</strong> of <strong>size n*m</strong> containing English alphabets and a string <strong>word</strong>. Check if the word exists on the mat. The word can be constructed by using letters from <strong>adjacent</strong> cells, either horizontally or vertically. The same cell cannot be used more than <strong>once</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['T', 'E', 'E'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
<strong>Output: </strong>true
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid4_1737981964.png" alt="" width="220" height="200" /><br />The letter cells which are used to construct the "GEEK" are colored.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['T', 'E', 'U'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
<strong>Output: </strong>false
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid5_1737981964.png" alt="" width="220" height="199" /><br />It is impossible to construct the string word from the mat using each cell only once.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [['A', 'B', 'A'], ['B', 'A', 'B']], word = "AB"
<strong>Output: </strong>true
<strong>Explanation:</strong>
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886266/Web/Other/blobid6_1737981964.png" alt="" width="222" height="184" /><br />There are multiple ways to construct the word "AB".</span></pre>
<p><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Constraints:</strong><br /><span style="font-size: 14pt;">1 &le; n, m &le; 6</span><br /><span style="font-size: 14pt;">1 &le; L &le; 15</span><br /><span style="font-size: 18.6667px;">mat and word consists of only lowercase and uppercase English letters.</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-search-ii/description" target="_blank" rel="noopener noreferrer">Word Search II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>

<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" style="width: 322px; height: 322px;" />
<pre>
<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]
<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>board[i][j]</code> is a lowercase English letter.</li>
	<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>words</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/word-search-ii/1" target="_blank" rel="noopener noreferrer">Word Search II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>2-D board </strong>of characters of size <strong>n</strong>x<strong>m</strong> and a list of string <strong>words</strong>. Return a list of words that are present in the board in <strong>any</strong> order.</span></p>
<p><span style="font-size: 14pt;">Each word must be constructed from letters of sequentially <strong>adjacent</strong> cells, where adjacent cells are <strong>horizontally</strong> or <strong>vertically</strong> connected.&nbsp;<br />The same letter cell cannot be used more than once in a word. A single-letter cell can be used for many different words.</span></p>
<p><span style="font-size: 14pt;">Note: Driver code will sort the returned list before printing.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">board[][] = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']], words[] = ["oath", "pea", "eat", "rain"]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876764/Web/Other/blobid0_1732516922.jpg" width="312" height="276" /><br /><strong>Output: </strong>["eat", "oath"]<br /></span></pre>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><span style="font-size: 14pt;"> board[][] = [['a', 'b'],['c', 'd']], words[] = ["abcb"]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/876764/Web/Other/blobid0_1732517302.jpg" height="100" /><br /><strong>Output: </strong>[]</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1&nbsp; &lt;=&nbsp; n, m&nbsp; &lt;=&nbsp; 12</span><span style="font-size: 14pt;"><br />1&nbsp; &lt;=&nbsp; words.size() &nbsp;&lt;=&nbsp; 3*10<sup>4</sup><br />1&nbsp; &lt;=&nbsp; words[i].length() &nbsp;&lt;=&nbsp; 10<br />All strings of words are <strong>unique</strong> and only consist of <strong>lowercase</strong> English letters</span></p></div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>