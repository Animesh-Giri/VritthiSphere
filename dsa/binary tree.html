<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary tree - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>binary tree</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">130</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">Add One Row to Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">All Elements in Two Binary Search Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">All Nodes Distance K in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">All Possible Full Binary Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Amount of Time for Binary Tree to Be Infected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Average of Levels in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Balance a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Balanced Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Binary Search Tree Iterator</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Binary Search Tree to Greater Sum Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Binary Tree Cameras</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Binary Tree Coloring Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Binary Tree Inorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Binary Tree Level Order Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Binary Tree Level Order Traversal II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Binary Tree Maximum Path Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Binary Tree Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Binary Tree Postorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Binary Tree Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Binary Tree Pruning</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Binary Tree Right Side View</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Binary Tree Tilt</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Binary Tree Zigzag Level Order Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Check Completeness of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Closest Nodes Queries in a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Complete Binary Tree Inserter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Construct Binary Search Tree from Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Construct Binary Tree from Inorder and Postorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Construct Binary Tree from Preorder and Inorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Construct Binary Tree from Preorder and Postorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Construct String from Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Convert BST to Greater Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Convert Sorted Array to Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Convert Sorted List to Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Count Complete Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Count Good Nodes in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Count Nodes Equal to Average of Subtree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Count Nodes With the Highest Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Cousins in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Cousins in Binary Tree II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Create Binary Tree From Descriptions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Cycle Length Queries in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Deepest Leaves Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Delete Leaves With a Given Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Delete Node in a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Delete Nodes And Return Forest</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Diameter of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Distribute Coins in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Evaluate Boolean Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Even Odd Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Find Bottom Left Tree Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Find Duplicate Subtrees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Find Elements in a Contaminated Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Find Largest Value in Each Tree Row</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Find Mode in Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Flatten Binary Tree to Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Flip Binary Tree To Match Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Flip Equivalent Binary Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Height of Binary Tree After Subtree Removal Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">House Robber III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Increasing Order Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Insert into a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Insufficient Nodes in Root to Leaf Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Invert Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Kth Largest Element in a Stream</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">K-th Largest Perfect Subtree Size in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Kth Largest Sum in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Kth Smallest Element in a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Leaf-Similar Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Linked List in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Longest Univalue Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Longest ZigZag Path in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Lowest Common Ancestor of a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Lowest Common Ancestor of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Lowest Common Ancestor of Deepest Leaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Make Costs of Paths Equal in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Maximum Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Maximum Binary Tree II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Maximum Depth of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Maximum Difference Between Node and Ancestor</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Maximum Level Sum of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Maximum Product of Splitted Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Maximum Sum BST in Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-84" class="toc-link">Maximum Width of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">Merge BSTs to Create Single BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Merge Two Binary Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Minimum Absolute Difference in BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Minimum Depth of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Minimum Distance Between BST Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Minimum Number of Operations to Sort a Binary Tree by Level</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Most Frequent Subtree Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Number of Good Leaf Nodes Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Number of Ways to Reorder Array to Get Same BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Path In Zigzag Labelled Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Path Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Path Sum II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Path Sum III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Populating Next Right Pointers in Each Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Populating Next Right Pointers in Each Node II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Print Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Pseudo-Palindromic Paths in a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Range Sum of BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Recover a Tree From Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Recover Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Reverse Odd Levels of Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Root Equals Sum of Children</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Same Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Search in a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Second Minimum Node In a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Serialize and Deserialize Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Serialize and Deserialize BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Smallest String Starting From Leaf</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Smallest Subtree with all the Deepest Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Step-By-Step Directions From a Binary Tree Node to Another</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-115" class="toc-link">Subtree of Another Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Sum of Left Leaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Sum of Nodes with Even-Valued Grandparent</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Sum of Root To Leaf Binary Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Sum Root to Leaf Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Symmetric Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Trim a Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-122" class="toc-link">Two Sum IV - Input is a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Unique Binary Search Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Unique Binary Search Trees II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Univalued Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Validate Binary Search Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Validate Binary Tree Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Verify Preorder Serialization of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-129" class="toc-link">Vertical Order Traversal of a Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/add-one-row-to-tree/description" target="_blank" rel="noopener noreferrer">Add One Row to Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and two integers <code>val</code> and <code>depth</code>, add a row of nodes with value <code>val</code> at the given depth <code>depth</code>.</p>

<p>Note that the <code>root</code> node is at depth <code>1</code>.</p>

<p>The adding rule is:</p>

<ul>
	<li>Given the integer <code>depth</code>, for each not null tree node <code>cur</code> at the depth <code>depth - 1</code>, create two tree nodes with value <code>val</code> as <code>cur</code>&#39;s left subtree root and right subtree root.</li>
	<li><code>cur</code>&#39;s original left subtree should be the left subtree of the new left subtree root.</li>
	<li><code>cur</code>&#39;s original right subtree should be the right subtree of the new right subtree root.</li>
	<li>If <code>depth == 1</code> that means there is no depth <code>depth - 1</code> at all, then create a tree node with value <code>val</code> as the new root of the whole original tree, and the original tree is the new root&#39;s left subtree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg" style="width: 500px; height: 231px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2
<strong>Output:</strong> [4,1,1,2,null,null,6,3,1,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg" style="width: 500px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [4,2,null,3,1], val = 1, depth = 3
<strong>Output:</strong> [4,2,null,1,1,3,null,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li>The depth of the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-elements-in-two-binary-search-trees/description" target="_blank" rel="noopener noreferrer">All Elements in Two Binary Search Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two binary search trees <code>root1</code> and <code>root2</code>, return <em>a list containing all the integers from both trees sorted in <strong>ascending</strong> order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/q2-e1.png" style="width: 457px; height: 207px;" />
<pre>
<strong>Input:</strong> root1 = [2,1,4], root2 = [1,0,3]
<strong>Output:</strong> [0,1,1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/18/q2-e5-.png" style="width: 352px; height: 197px;" />
<pre>
<strong>Input:</strong> root1 = [1,null,8], root2 = [8,1]
<strong>Output:</strong> [1,1,8,8]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description" target="_blank" rel="noopener noreferrer">All Nodes Distance K in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the value of a target node <code>target</code>, and an integer <code>k</code>, return <em>an array of the values of all nodes that have a distance </em><code>k</code><em> from the target node.</em></p>

<p>You can return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" style="width: 500px; height: 429px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
<strong>Output:</strong> [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1], target = 1, k = 3
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 500</code></li>
	<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>target</code> is the value of one of the nodes in the tree.</li>
	<li><code>0 &lt;= k &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-possible-full-binary-trees/description" target="_blank" rel="noopener noreferrer">All Possible Full Binary Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">memoization</span> <span class="topic-badge">recursion</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>a list of all possible <strong>full binary trees</strong> with</em> <code>n</code> <em>nodes</em>. Each node of each tree in the answer must have <code>Node.val == 0</code>.</p>

<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in <strong>any order</strong>.</p>

<p>A <strong>full binary tree</strong> is a binary tree where each node has exactly <code>0</code> or <code>2</code> children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" style="width: 700px; height: 400px;" />
<pre>
<strong>Input:</strong> n = 7
<strong>Output:</strong> [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[0,0,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, our task is to return a list of root nodes of all possible full binary trees with <code>n</code> nodes.</p>
<hr />
<h3 id="approach-1-recursion--memoization-top-down-dp">Approach 1: Recursion + Memoization (Top-Down DP)</h3>
<h4 id="intuition">Intuition</h4>
<p>As stated in the description, each node in a full binary tree has either <code>0</code> or <code>2</code> children. Because there is a root node, a full binary tree will always have an <strong>odd</strong> number of nodes (root node + even child nodes).</p>
<p>To find all the possible permutations of full binary trees with <code>n</code> nodes, we can use one node as the <code>root</code> node and split the other <code>n - 1</code> nodes between the left and right subtrees in all possible ways. Let us say we place <code>i</code> nodes in the left subtree and <code>n - i - 1</code> in the right subtree.</p>
<p>Now, we create a list of root nodes called <code>left</code> for all possible full binary trees that can be formed using <code>i</code> nodes. Similarly, we create a list of root nodes called <code>right</code> for all the full binary trees using <code>n - i - 1</code> nodes. We can now create a new full binary tree by choosing one element from <code>left</code> to be the left child and one element from <code>right</code> to be the right child. To generate all full binary trees, we will iterate over all pairs between <code>left, right</code>.</p>
<p>As we know any full binary tree must have an odd number of nodes, <code>i</code> and <code>n - 1 - i</code> should be odd as well to form full binary trees that are being used as the left and right subtrees. As a result, we move the value of <code>i</code> from <code>i = 1</code> till <code>n - 1</code> incrementing <code>i</code> by <code>2</code> each time so that we just loop on odd numbers of <code>i</code>. Since we have odd <code>n</code> and odd <code>i</code>, <code>n - 1 - i</code> would also be an odd number.</p>
<p>Notice that generating the lists <code>left</code> and <code>right</code> is the same as the original problem, just with a different value of <code>n</code>. We can implement this approach using recursion as we are breaking down a problem with <code>n</code> nodes to smaller, repetitive subproblems with <code>i</code> and <code>n - i - 1</code> nodes (for <code>i = 1</code> till <code>n - 1</code>, incrementing <code>i</code> by <code>2</code>) to compute the answer for <code>n</code> nodes.</p>
<p>We can convert the given method <code>allPossibleFBT</code> in the implementation into a recursive function as we only need the number of nodes as the parameter to create a list of nodes for all possible full binary tree using recursion. Here is a visual representation of the recursion tree with <code>7</code> nodes:</p>
<p><img src="../Figures/894/894-1.png" alt="img" /></p>
<p>Several subproblems, such as <code>allPossibleFBT(3)</code>, <code>allPossibleFBT(5)</code>, etc., are solved multiple times in the partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from the number of nodes to the list of root nodes of all possible full binary trees that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of <code>TreeNode</code>. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hash map <code>memo</code> where <code>memo[i]</code> contains the list of root nodes of all possible full binary trees with <code>i</code> nodes.</li>
<li>If <code>n</code> is even, we return an empty list as we cannot form any full binary tree with even number of nodes.</li>
<li>If <code>n == 1</code>, we simply return a list with single node.</li>
<li>If we already have solved this subproblem, i.e., <code>memo</code> contains the key <code>n</code>, we return <code>memo[n]</code>.</li>
<li>We have odd <code>n</code>. We declare a list of <code>TreeNode</code> called <code>res</code> to store the list of root nodes of all possible full binary trees with <code>n</code> nodes.</li>
<li>Iterate from <code>i = 1</code> to <code>n - 1</code> incrementing <code>i</code> by <code>2</code> after each iteration:
<ul>
<li>Create a list of <code>TreeNode</code> called <code>left</code> to store the root nodes for all possible full binary trees using <code>i</code> nodes. We perform <code>left = allPossibleFBT(i)</code>.</li>
<li>Create a list of <code>TreeNode</code> called <code>right</code> to store the root nodes for all possible full binary trees using <code>n - 1 - i</code> nodes. We perform <code>right = allPossibleFBT(n - i - 1)</code>.</li>
<li>Iterate over both the lists <code>left</code> and <code>right</code> using two loops. For each element <code>count</code> in <code>left</code> and <code>r</code> in <code>right</code>, we create a new <code>root</code> node and set <code>root.left = l</code> and <code>root.right = r</code>. We add <code>root</code> into our answer variable <code>res</code>.</li>
</ul>
</li>
<li>Set <code>memo[n]</code> equal to <code>res</code>.</li>
<li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/KpYEVWSK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Note, the time and space complexity of this problem is difficult to derive exactly. In an interview, do your best to calculate an upper bound while explaining your thought process.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{n/2})\)</span>.</p>
<ul>
<li>The maximum number of nodes that can be in the left subtree of a full binary tree with <code>n </code>nodes is <code>n - 2</code>, since one node is the root of the tree and one node must be in the right subtree. Therefore, the total number of possible full binary trees with <code>n</code> nodes can be calculated by considering all possible combinations of the number of nodes in the left and right subtrees, such that the sum of the number of nodes in the left and right subtrees is equal to <code>n - 1</code>.</li>
<li>We can express the total number of possible full binary trees with <code>n</code> nodes as a recurrence relation <code>T(n) = T(1) * T(n - 2) + T(3) * T(n - 4) + ... + T(n - 2) * T(1)</code>, where the summation goes over all odd numbers from <code>1</code> to <code>n - 2</code>. Solving this recurrence relation using dynamic programming shows that <code>T(n)</code> is equal to the <span class="math inline">\(n^{th}\)</span> <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>, which is bounded by <span class="math inline">\(2^{n/2}\)</span>.</li>
<li>Our implementation generates all of these trees taking <span class="math inline">\(O(2^{n/2})\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</p>
<ul>
<li>The algorithm uses memoization to store the results of subproblems. Specifically, it uses a hash map called <code>memo</code> to store the results of subproblems that have already been solved.</li>
<li>For every subproblem with <code>n</code> nodes, the algorithm may need to store up to <span class="math inline">\(2^{n/2}\)</span> <code>TreeNode</code> objects in the <code>memo</code> hash map. This is because there can be up to <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes, and the algorithm needs to store all of them in order to return the result for the subproblem with <code>n</code> number of nodes. There are maximum of <code>n/2</code> subproblems (with nodes <code>1</code>, <code>3</code>, .. <code>n - 1</code>) and hence the space complexity of the algorithm is <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.</p>
<p>We create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible full binary trees using <code>i</code> nodes. This is analogous to what <code>memo[i]</code> was in the previous approach.</p>
<p>We push a single node to <code>dp[1]</code> which acts as the base case.</p>
<p>We form the answer with a smaller number of nodes and move on to form answers for a bigger number of nodes. We run an outer loop from <code>count = 3</code> to <code>count = n</code> incrementing <code>count</code> by <code>2</code> after each iteration. This loop controls the total number of nodes <code>count</code> under consideration. Please keep in mind that we are only iterating over odd numbers of nodes because the answer for even numbers of nodes is an empty list. Note that here, <code>count</code> represents <code>n</code> in the previous approach. We have to use a different variable name since we are now implementing the algorithm iteratively and <code>n</code> is static per test case.</p>
<p>To get the list of root nodes for all possible full binary trees with <code>count</code> nodes, we would split the <code>count</code> nodes with <code>i</code> nodes in the left subtree and <code>count - i - 1</code> in the right subtree in the same manner as described previously. As we are executing in bottom-up manner, we will already have the list of root nodes for all possible full binary trees with <code>i</code> and <code>count - i - 1</code> nodes.</p>
<p>We create a new instance of <code>TreeNode</code> called <code>root</code> and set the left child of <code>root</code> to an element in <code>dp[i]</code> and set the right child of <code>root</code> to an element in <code>dp[l - i - 1]</code> to form a new full binary tree with <code>count</code> nodes. We will iterate over all the elements in <code>dp[i]</code> and <code>dp[count - i - 1]</code> to form all the full binary trees in this split.</p>
<p>We would run an inner loop to move <code>i</code> from <code>1</code> to <code>count - 2</code> (one node is used as root, <code>count - 2</code> nodes are used in the left subtree, leaving at least one node for the right subtree) incrementing <code>i</code> by <code>2</code> to split the <code>count</code> nodes in all the possible ways between the left and right subtree.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>If <code>n</code> is even, we return an empty list as we cannot form any full binary tree with even number of nodes.</li>
<li>Create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible full binary trees using <code>i</code> nodes. We initialize each list <code>dp[i]</code> to an empty list for <code>i = 0</code> to <code>n</code>.</li>
<li>We push a single node into <code>dp[1]</code> because with <code>n = 1</code> we can just have a root node in the tree.</li>
<li>Iterate from <code>count = 3</code> till <code>count = n</code> incrementing <code>count</code> by <code>2</code> after each iteration. The outer loop corresponds to the total number of nodes under consideration. We start an inner loop from <code>i = 1</code> to <code>count - 2</code> incrementing <code>i</code> by <code>2</code> which represents the number of nodes in the left subtree under consideration. We perform the following in this loop:
<ul>
<li>Create a variable <code>j = n - i - 1</code>. It presents the number of nodes in the right subtree under consideration.</li>
<li>We can form a new full binary tree by creating a new node which acts as a root node and assigning its left child to any element in <code>dp[i]</code> and right child to any element in <code>dp[j]</code>. As a result, we iterate over both the lists <code>dp[i]</code> and <code>dp[j]</code> using two loops. For each element <code>left</code> in <code>dp[i]</code> and <code>right</code> in <code>dp[j]</code>, we create a new <code>root</code> node and set <code>root.left = left</code> and <code>root.right = right</code> to form all the full binary trees in this split. We add <code>root</code> to <code>dp[count]</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Vxs5u5PG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{n/2})\)</span>.</p>
<ul>
<li>There are a maximum of <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes (where <code>n</code> is an odd number) and the algorithm generates all of them without solving any subproblem twice. The time complexity is similar to the previous approach.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</p>
<ul>
<li>Similar to the <code>memo</code> hash map used in the previous approach, <code>dp[i]</code> will store the list of root nodes for all possible full binary trees with <code>i</code> nodes. As there can be a maximum of <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes, <code>dp</code> will consume <span class="math inline">\(O(n \cdot 2^{n/2})\)</span> space to store the list of nodes corresponding to all the number of nodes from <code>1</code> to <code>n</code>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description" target="_blank" rel="noopener noreferrer">Amount of Time for Binary Tree to Be Infected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <strong>unique</strong> values, and an integer <code>start</code>. At minute <code>0</code>, an <strong>infection</strong> starts from the node with value <code>start</code>.</p>

<p>Each minute, a node becomes infected if:</p>

<ul>
	<li>The node is currently uninfected.</li>
	<li>The node is adjacent to an infected node.</li>
</ul>

<p>Return <em>the number of minutes needed for the entire tree to be infected.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png" style="width: 400px; height: 306px;" />
<pre>
<strong>Input:</strong> root = [1,5,3,null,4,10,6,9,2], start = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The following nodes are infected during:
- Minute 0: Node 3
- Minute 1: Nodes 1, 10 and 6
- Minute 2: Node 5
- Minute 3: Node 4
- Minute 4: Nodes 9 and 2
It takes 4 minutes for the whole tree to be infected so we return 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png" style="width: 75px; height: 66px;" />
<pre>
<strong>Input:</strong> root = [1], start = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> At minute 0, the only node in the tree is infected so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li>A node with a value of <code>start</code> exists in the tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to find the number of minutes needed for the entire tree to become infected. A node one level away from the start node takes 1 minute to become infected. All nodes on that level take the same amount of time to become infected. A node two levels away from the start node takes two minutes to become infected. We can reason that the distance of any given node from the start node will be the number of minutes it takes to infect the whole tree. Therefore, our solution will be the maximum distance from the start node.</p>
<hr />
<h3 id="approach-1-convert-to-graph-and-breadth-first-search">Approach 1: Convert to Graph and Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Before we can approach finding the maximum distance from the start node, we must note that the start node is not necessarily the root node. This means the infection may spread from child to root, which would include traversal from child to parent. The ordinary definition of a binary tree does not support this kind of traversal, so we need to convert the binary tree to a structure that represents the original but allows traversal from child to parent. In this scenario, a child is a neighbor of a parent and vice-versa. An undirected graph will work for this.</p>
<h5 id="1-convert-the-binary-tree-to-an-undirected-graph">1. Convert the binary tree to an undirected graph</h5>
<p>A tree is a special kind of graph with a root and subtrees. We want to search the graph from any node, not just the root, and be able to traverse to all neighbors, including parents and children. An undirected graph is a set of vertices with edges that connect them. We will use a map to represent our graph, made up of integer vertices, and an adjacency list to record the edges.</p>
<p>We can define a function that converts our binary tree to an undirected graph by traversing the tree and creating a graph. The parameters are the current node and its parent. We traverse the tree with a preorder traversal, visiting first the root, then the left and right child, so we can log the parent of each node and make a connection to it. When we encounter a new right or left child, we add them to the adjacency list.</p>
<p>The algorithm for this recursive <code>convert</code> function is defined as follows:</p>
<ol>
<li>If <code>current == null</code>, return.</li>
<li>If the root has a new value, we add it to the map and create a new adjacency list to store the adjacent vertices</li>
<li>Retrieve the adjacency list of the current vertex.</li>
<li>If <code>current</code> is not the root, add its parent to the adjacency list.</li>
<li>If <code>current</code> a left child, add the child to its adjacency list.</li>
<li>If <code>current</code> has a right child, add the child to its adjacency list.</li>
<li>Recursively call convert on <code>current.left</code> with current as the parent.</li>
<li>Recursively call convert on <code>current.right</code> with current as the parent.</li>
</ol>
<p><a href="https://leetcode.com/playground/R2LABaZY/shared">code</a></p>
<h5 id="2-conduct-a-breath-first-search-bfs-to-find-the-maximum-distance-between-the-start-and-other-vertices">2. Conduct a Breath First Search (BFS) to find the maximum distance between the start and other vertices.</h5>
<p>We can find the maximum distance between the vertex with the value <code>start</code> and the rest of the vertices in our graph by using a BFS starting with the <code>start</code>.</p>
<h6 id="standard-breadth-first-search">Standard Breadth-First Search</h6>
<ol>
<li>Add the first node to the queue</li>
<li>While the queue is not empty:
<ul>
<li>Remove the front node of the queue and mark it as visited.</li>
<li>Check whether all adjacent nodes have been visited. If they have not, add them to the queue</li>
</ul>
</li>
</ol>
<p>If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p>To determine the amount of time it takes to infect all of the vertices, we specifically need to determine the maximum distance from the start vertex. We use the variable <code>minute</code> to store the distance from the start vertex. We will make a few tweaks to BFS to update <code>minute</code> accurately.</p>
<p>For our implementation of BFS, we will use a queue to store the vertices that we need to visit. We will create a set to store the nodes we have already visited so we don't visit them multiple times. We add <code>start</code> to the queue and the visited set and then iterate through the vertices in the queue until it is empty.  We set the variable <code>levelSize</code> to the size of the queue so we can keep track of how many vertices are in the current level. We <code>poll()</code> a vertex <code>current</code> from the queue. We iterate through each of the values in its adjacency list checking whether each one has been visited. If they have not been visited, we add them to the queue and the visited set. After adding all of the adjacent vertices, we decrement <code>levelSize</code>. When there are no more vertices in the current level, we will move to the next level, so we increment the variable <code>minute</code>. When the queue is empty, we return <code>minute - 1</code>, because we have incremented <code>minute</code> for each level, but the time taken by the first node to infect neighbors is zero.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Declare a hash map <code>map</code> to store vertices and their adjacency list for edges.</li>
<li>Implement a function <code>convert</code> that creates an undirected graph of the tree and stores it in <code>map</code> as explained above.</li>
<li>Call <code>convert(root, 0, map)</code> as the root has no parent.</li>
<li>Set <code>minute</code>, the distance from the start vertex to 0.</li>
<li>Initialize a <code>queue</code> and add <code>start</code>.</li>
<li>Initialize a set <code>visited</code> to store the visited vertexes and add <code>start</code>.</li>
<li>While <code>queue</code> is not empty:
<ul>
<li>Set <code>levelSize</code>, the number of vertices in this level, to the size of <code>queue</code>.</li>
<li>While  <code>levelSize</code> is greater than 0:
<ul>
<li>Remove a vertex <code>current</code> from the <code>queue </code>.</li>
<li>For each edge in the adjacency list:
<ul>
<li>Check whether the edge has been visited. If not, add it to <code>queue</code> and <code>visited</code>.</li>
</ul>
</li>
<li>Decrement <code>levelSize</code>.</li>
</ul>
</li>
<li>Increment <code>minute</code> as the distance from <code>startNode</code> has increased.</li>
</ul>
</li>
<li>After the BFS, return <code>minute - 1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWBgxCJ9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Converting the tree to a graph using a preorder traversal costs <span class="math inline">\(O(n)\)</span>. We then perform BFS, which also costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>When converting the tree to a graph, we require <span class="math inline">\(O(n)\)</span> extra space for the map. We also require <span class="math inline">\(O(n)\)</span> space for the queue and <span class="math inline">\(O(n)\)</span> space for the visited set during the BFS.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-one-pass-depth-first-search">Approach 2: One-Pass Depth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The above solution passed over each node twice, once to create an undirected graph, and again to complete the breath first search. Is there a way to find the maximum distance from the start node with only one pass?</p>
<p>If the node with the value start happened to be the root, the maximum distance from the start node would be equivalent to the maximum height of the tree. We can also reason that there are certain test cases where the maximum height of the start node's sub-tree would be the maximum distance from the start node. An example case where this is true is <code>[1, 2, null, 3, null, 4, null]</code> where the start node is 2. In this case, all nodes have only one child.</p>
<p>Is there a way to calculate the maximum distance from the start node using subtree depths, even when the start node is not the root? This would help us solve the problem in just one pass.</p>
<p>The first question we need to solve is &quot;Can we determine the max distance of the start node using the depths of sub-trees?&quot; We use the image below to demonstrate a method for determining the max distance using sub-tree depths.</p>
<p><img src="../Documents/2385/2385.drawio.svg" alt="Tree with Highlighted Nodes" /></p>
<p>In the image above the start node is the red node, 5.<br />
subDepth = 2 // red subtree's depth (Nodes below the start node)<br />
depth = 1 // red node's depth (the start node)<br />
otherDepth = 2 // green subtree depth (nodes above the start node)<br />
distance = depth + other_depth = 3 // distance of any node above the start node from the start node<br />
maxDistance = max(distance, sub_depth) = 3</p>
<p>Knowing that we can calculate the maximum distance from the start node using subtree height, we can attempt a one-pass method of solving this problem. We can base our algorithm on a calculation of max depth using a depth-first search.</p>
<p>Here is the basic recursive algorithm for finding the maximum depth, which we will adjust to our needs.</p>
<ol>
<li>If <code>root = null</code> return 0.</li>
<li>Make a recursive call with root.right and save as <code>rightDepth</code>.</li>
<li>Make a recursive call with root.left and save as <code>leftDepth</code>.</li>
<li>Return max(rightDepth, leftDepth) + 1.</li>
</ol>
<p>One challenge to this task is identifying whether we have encountered the start node during the traversal. We can return a negative depth when we encounter the start node. This will flag that we have found the start node, and as we traverse the tree, whenever we encounter a negative depth, we know the subtree contains the start node.</p>
<p>Additionally, as we traverse the tree, we might find the start node before we have calculated the max depth of each part of the tree. Therefore, we need to be able to save the max distance and continue calculating it while traversing the rest of the tree.</p>
<p>There are four main cases:</p>
<ol>
<li>If <code>root</code> is null, return 0.</li>
<li><code>root.val = start</code>. If so, we return <code>depth = -1</code> to signify this is the start node. In this way, in subsequent recursive calls, the parent node of the start node will know whether its child nodes contain the start node. Here we are also able to calculate the <code>maxDistance</code> of any node in the start node's subtree by finding the max of the left and right depth.</li>
<li>The left and right depth are both non-negative. If they are, we know the start node is not in this subtree, and we can set <code>depth = max(leftDepth, rightDepth)</code> just like with the basic max depth.</li>
<li>The final case is when the <code>root</code> is not the start node, but its subtree contains the start node. In this case, we will set <code>depth = min(leftDepth, rightDepth) - 1</code>, which will give us a negative number, the absolute value of which represents the distance of the start node to the root node. To calculate the distance from the start node to the furthest node in the other subtree, we will add the absolute value of the negative depth of the subtree that contains the start node, and the positive depth of the other subtree, for convenience, we can directly take the absolute value of two values. Then, we update <code>maxDistance</code> with <code>distance</code> if it is larger.</li>
</ol>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Declare a variable <code>maxDistance</code> to store maximum distance from the start node.</li>
<li>Define a function <code>traverse</code> that performs a depth-first search of the tree that returns depth and calculates and saves <code>maxDistance</code>.
<ul>
<li>For each call to <code>traverse</code>, we have a new root and declare a variable <code>depth = 0</code>.</li>
<li>If <code>root == null</code> set <code>depth = 0</code> and return.</li>
<li>Recursively call <code>traverse</code> with <code>root.right</code> and save in the variable <code>rightDepth</code>.</li>
<li>Recursively call <code>traverse</code> with <code>root.left</code> and save in the variable <code>leftDepth</code>.</li>
<li>If <code>root = start</code> the root is the start node:
<ul>
<li>Set <code>maxDistance = max(leftDepth, rightDepth)</code>  to calcualte the start node's max depth.</li>
<li>Set <code>depth = -1</code> to signify this is the start node.</li>
</ul>
</li>
<li>If the <code>leftDepth</code> and <code>rightDepth</code> are both greater than or equal to <code>0</code>, the start node is not in this subtree:
<ul>
<li>Set <code>depth = max(leftDepth, rightDepth) + 1</code> to calculate the current root's max depth.</li>
</ul>
</li>
<li>Else, the current root's subtree contains the start node:
<ul>
<li>Define a variable <code>distance</code> as the sum of <code>abs(leftDepth)</code> and <code>abs(rightDepth)</code>, which is the distance of the furthest node in the other subtree.</li>
<li>Set <code>maxDistance = max(maxDistance,  distance)</code> to update <code>maxDistance</code> if <code>distance</code> is larger.</li>
<li>Set <code>depth = min(leftDepth, rightDepth) - 1</code> to calculate a negative number that signifies the subtree contains the start node and represents the distance of the start node from the root.</li>
</ul>
</li>
<li>return <code>depth</code>.</li>
</ul>
</li>
<li>Call <code>traverse(root, start)</code>.</li>
<li>Return <code>maxDistance</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWL2KH7K/shared">code</a></p>
<h4 id="complexity">Complexity</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS is determined by the maximum depth of the call stack, which corresponds to the height of the tree (or the graph in our case). In the worst case, if the tree is completely unbalanced (e.g., a linked list), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/average-of-levels-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Average of Levels in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given the <code>root</code> of a binary tree, return <em>the average value of the nodes on each level in the form of an array</em>. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" style="width: 292px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,15,7]
<strong>Output:</strong> [3.00000,14.50000,11.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/balance-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Balance a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">greedy</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p>

<p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg" style="width: 500px; height: 319px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,null,3,null,4,null,null]
<strong>Output:</strong> [2,1,3,null,null,null,4]
<b>Explanation:</b> This is not the only correct answer, [3,1,4,null,2] is also correct.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg" style="width: 224px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to balance a binary search tree rooted at the <code>root</code> such that the difference between the depths of the two subtrees of every node never exceeds one. As a reminder, the depth of a given node in a tree is the number of edges from the root of the tree to that node.</p>
<blockquote>
<p>Note: Binary search trees (BSTs) are structured such that the value of each node is greater than all values in its left subtree and less than all values in its right subtree. Please refer to LeetCode's Explore Card on binary trees for a more detailed explanation: <a href="https://leetcode.com/explore/learn/card/data-structure-tree/"><strong>Binary Trees</strong></a></p>
</blockquote>
<p>We call such BSTs balanced BSTs. Balanced BSTs are efficient because they keep the tree height low, usually in logarithmic proportion to the number of nodes. This balance allows operations like insertion, deletion, and lookup to be done in logarithmic time on average. Keeping the tree balanced prevents it from becoming too deep, which would otherwise slow these operations down to linear time. This efficiency makes balanced BSTs ideal for tasks that need fast updates and quick searches.</p>
<p>There are two main approaches to balance a BST.</p>
<p>The first approach is to traverse and store all the BST nodes in a sorted array, then reconstruct the BST from scratch. Storing the values in sorted order ensures the new tree maintains the BST properties, where each node's left subtree contains only values less than the node's value, and the right subtree contains only values greater.</p>
<p>The second approach is to balance the BST in-place by restructuring it without additional storage. This involves performing rotations and rearrangements directly on the existing nodes to achieve balance while preserving BST properties.</p>
<p>This approach is more complex and is unlikely to be asked in an interview setting. However, it's worth understanding for deeper insights into tree rotations, balancing techniques, and the workings of self-balancing trees like AVL and Red-Black trees.</p>
<hr />
<h3 id="approach-1-inorder-traversal--recursive-construction">Approach 1: Inorder Traversal + Recursive Construction</h3>
<h4 id="intuition">Intuition</h4>
<p>In the overview, we mentioned the need to traverse and store the nodes of the BST in increasing order. This can be achieved by iteratively visiting each node in the following order: first the left subtree, then the node itself, and finally the right subtree, known as an inorder traversal.</p>
<p>If you are not familiar with the three main traversal methods (inorder, preorder, and postorder), we encourage you to read about them here:</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/editorial/">Inorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/editorial/">Preorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/editorial/">Postorder Traversal</a></li>
</ul>
<p>We can perform the inorder traversal either recursively or iteratively. In this editorial, we will use the recursive approach for its simplicity and brevity, though you are encouraged to try both methods.</p>
<p>With the nodes of the BST stored in an array in increasing order, we can now reconstruct the BST to be balanced.</p>
<p>The stored values in the array have a convenient property: for any given element that serves as the root, all elements to its left belong to the left subtree, and all elements to its right belong to the right subtree. To construct a balanced BST, we pick the middle element of the array as the root, ensuring the number of elements in the left and right subtrees differs by at most one. We then recursively apply the same process to the left and right subarrays to build the left and right subtrees. This approach ensures the balanced property of the BST.</p>
<p>!?!../Documents/1382/slideshow1.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialization:
<ul>
<li>Create an empty list <code>inorder</code> to store the nodes' values after the inorder traversal.</li>
</ul>
</li>
<li>Perform inorder traversal:
<ul>
<li>Traverse the BST and populate the <code>inorder</code> list with the node values in sorted order.</li>
</ul>
</li>
<li>Reconstruct the balanced BST:
<ul>
<li>Define a recursive function <code>createBalancedBST</code> that takes the <code>inorder</code> list, <code>start</code> index, and <code>end</code> index as parameters.
<ul>
<li>If <code>start</code> is greater than <code>end</code>, return <code>null</code> (or equivalent).</li>
<li>Calculate the <code>mid</code> index as the middle of the current range.</li>
<li>Create a new tree node with the value at the <code>mid</code> index.</li>
<li>Recursively build the left subtree using the left half of the current range.</li>
<li>Recursively build the right subtree using the right half of the current range.</li>
</ul>
</li>
</ul>
</li>
<li>Return the root of the newly constructed balanced BST.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JcbyAFbA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the BST.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inorderTraversal</code> function visits each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Constructing the balanced BST with the <code>createBalancedBST</code> function also involves visiting each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inorderTraversal</code> function uses an additional array to store the inorder traversal, which requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>The recursive calls in the <code>inorderTraversal</code> and <code>createBalancedBST</code> functions contribute to the space complexity. In the worst case, the recursion stack can grow to <span class="math inline">\(O(n)\)</span> for a skewed tree.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-day-stout-warren-algorithm--in-place-balancing">Approach 2: Day-Stout-Warren Algorithm / In-Place Balancing</h3>
<h4 id="intuition-1">Intuition</h4>
<blockquote>
<p><strong>Note:</strong> This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>The Day-Stout-Warren (DSW) algorithm provides an in-place method for balancing Binary Search Trees (BSTs). To understand DSW, we first need to grasp the concept of rotations, which are fundamental operations for restructuring the tree to reduce its height and improve balance.</p>
<p>Rotations come in two forms:</p>
<ul>
<li>Right Rotation: This operation elevates the left child of a node to take its place, while the original node becomes the right child of its former left child.</li>
<li>Left Rotation: Conversely, this operation elevates the right child of a node to take its place, with the original node becoming the left child of its former right child.</li>
</ul>
<p>It's important to note that right and left rotations are inverse operations, each undoing the effect of the other.</p>
<p><img src="../Figures/1382/1382_DSW_slides_1_fix.png" alt="rotate1" /></p>
<p>With this foundation, we can now explore how DSW leverages these rotations. The algorithm employs a three-phase approach to balance a BST:</p>
<ol>
<li>Create the Backbone (vine)</li>
</ol>
<p>In this initial phase, DSW transforms the BST into a right-skewed tree, resembling a vine or linked list. This is achieved through a series of right rotations. The process involves traversing the tree and performing a right rotation whenever a node with a left child is encountered, continuing until the entire tree is right-skewed.</p>
<p>The slideshow is shown below:</p>
<p>!?!../Documents/1382/1382_DSW_slides_Re.json:1320,850!?!</p>
<ol start="2">
<li>Count the nodes</li>
</ol>
<p>Once the backbone is created, the next step is to determine the total number of nodes in the vine. This is done by traversing the right-skewed structure and counting each node. Let's denote this count as <code>n</code>. This count becomes crucial for the final balancing phase.</p>
<ol start="3">
<li>Balance the vine</li>
</ol>
<p>The final phase aims to convert the right-skewed vine into a balanced BST. This is accomplished through a series of left rotations. The process begins by calculating <code>m</code>, which is the largest power of 2 less than <code>n + 1</code>, minus 1. This calculation is significant as it identifies the largest complete subtree that can be fully balanced.</p>
<p>The balancing then proceeds in two steps:</p>
<p>a) Perform <code>n - m</code> left rotations to partially balance the tree. This ensures that the remaining nodes will form a complete binary tree after the first set of rotations.</p>
<p>b) Enter a loop where <code>m</code> is halved repeatedly. For each iteration, perform left rotations to balance the next level of the tree. This process continues until the vine is fully transformed into a balanced BST.</p>
<p>!?!../Documents/1382/slideshow3.json:960,540!?!</p>
<blockquote>
<p><strong>Note:</strong> While this approach is space-efficient, it modifies the tree structure during traversal, which might not be suitable in all scenarios, especially if the tree is being accessed concurrently by other processes. The constant modification of tree links may have a slight impact on performance compared to straightforward recursive approaches, especially for smaller trees.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialization:
<ul>
<li>If the root is <code>null</code>, return <code>null</code>.</li>
<li>Create a temporary dummy node <code>vineHead</code>.</li>
<li>Set the right child of <code>vineHead</code> as the root of the BST.</li>
<li>Initialize a pointer <code>current</code> to <code>vineHead</code>.</li>
</ul>
</li>
<li>Create the Backbone (Vine):
<ul>
<li>While <code>current</code> has a right child:
<ul>
<li>If <code>current</code>'s right child has a left child:
<ul>
<li>Perform a right rotation on <code>current</code> and its right child.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Count the Nodes:
<ul>
<li>Initialize <code>nodeCount</code> to 0.</li>
<li>Set <code>current</code> as the right child of <code>vineHead</code>.</li>
<li>While <code>current</code> is not <code>null</code>:
<ul>
<li>Increment <code>nodeCount</code>.</li>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
<li>Create a Balanced BST:
<ul>
<li>Calculate <code>m</code> as the largest power of 2 less than <code>nodeCount + 1</code> minus 1.</li>
<li>Perform <code>nodeCount - m</code> left rotations on the vine to partially balance it.</li>
<li>While <code>m</code> is greater than 1:
<ul>
<li>Halve <code>m</code>.</li>
<li>Perform <code>m</code> left rotations on the vine to further balance it.</li>
</ul>
</li>
</ul>
</li>
<li>Return the Balanced BST:
<ul>
<li>Set <code>balancedRoot</code> to the right child of <code>vineHead</code>.</li>
<li>Delete the temporary dummy node <code>vineHead</code>.</li>
<li>Return <code>balancedRoot</code>.</li>
</ul>
</li>
</ol>
<ul>
<li>Right Rotation:
<ul>
<li>Given a parent node and its right child:
<ul>
<li>Set <code>tmp</code> to the left child of the right child.</li>
<li>Set the left child of the right child to the right child of <code>tmp</code>.</li>
<li>Set the right child of <code>tmp</code> to the right child of the parent node.</li>
<li>Set the right child of the parent node to <code>tmp</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Left Rotation:
<ul>
<li>Given a parent node and its right child:
<ul>
<li>Set <code>tmp</code> to the right child of the right child.</li>
<li>Set the right child of the right child to the left child of <code>tmp</code>.</li>
<li>Set the left child of <code>tmp</code> to the right child of the parent node.</li>
<li>Set the right child of the parent node to <code>tmp</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Make Rotations:
<ul>
<li>Given <code>vineHead</code> and <code>count</code>:
<ul>
<li>Set <code>current</code> to <code>vineHead</code>.</li>
<li>For <code>i</code> from 0 to <code>count - 1</code>:
<ul>
<li>Set <code>tmp</code> to the right child of <code>current</code>.</li>
<li>Perform a left rotation on <code>current</code> and <code>tmp</code>.</li>
<li>Move <code>current</code> to its right child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/TZ3STb7N/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the BST at <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The loop that creates the vine visits each node exactly once, and each right rotation is <span class="math inline">\(O(1)\)</span>, resulting in <span class="math inline">\(O(n)\)</span> time.</p>
<p>Counting nodes in the vine involves a single traversal of the vine, which is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>makeRotations</code> function performs a series of left rotations. Each rotation is <span class="math inline">\(O(1)\)</span>, and the total number of rotations across all iterations is <span class="math inline">\(O(n)\)</span>. Although the number of rotations is bounded by a logarithmic factor due to iteratively halving <span class="math inline">\(m\)</span>, the overall complexity remains <span class="math inline">\(O(n)\)</span> due to the linear traversal and rotation steps.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm primarily uses a temporary pointer structure and the original nodes, contributing to <span class="math inline">\(O(1)\)</span> additional space. The vine structure uses the existing nodes in-place, without requiring extra memory.</p>
<p>However, the depth of the recursion stack in the worst case can reach <span class="math inline">\(O(n)\)</span> if the tree is skewed.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/balanced-binary-tree/description" target="_blank" rel="noopener noreferrer">Balanced Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree, determine if it is <span data-keyword="height-balanced"><strong>height-balanced</strong></span>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" style="width: 342px; height: 221px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" style="width: 452px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search-tree-iterator/description" target="_blank" rel="noopener noreferrer">Binary Search Tree Iterator</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">design</span> <span class="topic-badge">iterator</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)" target="_blank">in-order traversal</a></strong> of a binary search tree (BST):</p>

<ul>
	<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>
	<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>
	<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>
</ul>

<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>

<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />
<pre>
<strong>Input</strong>
[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>Explanation</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description" target="_blank" rel="noopener noreferrer">Binary Search Tree to Greater Sum Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>

<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" style="width: 400px; height: 273px;" />
<pre>
<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0,null,1]
<strong>Output:</strong> [1,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 538: <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/" target="_blank">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem requires modifying the binary search tree rooted at the <code>root</code> so that each node has a new value equal to the sum of all original tree values that are greater than or equal to <code>node.val</code>. The tree contains between 0 and 100 unique nodes.</p>
<p>Check out the example below to understand how the root value gets replaced by adding greater values:</p>
<p><img src="../Figures/1038/visual1.png" alt="figB" /></p>
<hr />
<h3 id="approach-1-in-order-traversal-brute-force">Approach 1: In-order Traversal (Brute-Force)</h3>
<h4 id="intuition">Intuition</h4>
<p>In a binary search tree, all nodes in the left subtree of a node have values less than the node, and all nodes in the right subtree have values greater. During an in-order traversal, we move from the left subtree to the root node, then to the right subtree. Thus, in a binary search tree, in-order traversal yields node values in ascending order.</p>
<p>Given that the number of nodes is small, we can consider using a brute-force approach to solve the problem.</p>
<p>We can store all node values in an array as we traverse the tree using in-order traversal. Now, we can traverse the tree again and modify each node's value by incrementing the original value with the sum of all the greater values in the array.</p>
<p>Since the array is sorted in ascending order, we can start iterating from the end of the array. If we reach any value in the array less than the current node value, we can break the iteration to further optimize this approach.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong>Main function - <code>bstToGst(root)</code></strong></p>
<ol>
<li>Initialize an integer array <code>inorderTraversal</code>.</li>
<li>Call <code>inorder(root)</code>.</li>
<li>Reverse the <code>inorderTraversal</code> array.</li>
<li>Call <code>replaceValues(root)</code>.</li>
<li>Return <code>root</code>.</li>
</ol>
<p><strong><code>inorder(root)</code></strong></p>
<ol>
<li>If the root is <code>null</code>, return.</li>
<li>Make a call to <code>inorder(root-&gt;left)</code>.</li>
<li>Store the value of the current node in the <code>inorderTraversal</code> array.</li>
<li>Make a call to <code>inorder(root-&gt;right)</code>.</li>
</ol>
<p><strong><code>replaceValues(root)</code></strong></p>
<ol>
<li>If the root is <code>null</code>, return.</li>
<li>Make calls to the left and right child, i.e. call the <code>replaceValues(root-&gt;left)</code> and <code>replaceValues(root-&gt;right)</code>.</li>
<li>Initialize <code>nodeSum</code> with 0.</li>
<li>Iterate through the <code>inorderTraversal</code> array:
<ul>
<li>If the current value is greater than <code>root-&gt;val</code>:
<ul>
<li>Add this value to the <code>nodeSum</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>root-&gt;val</code> by <code>nodeSum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/oQyR8Jh9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The <code>inorder</code> function traverses all the nodes exactly once. All other operations in <code>inorder</code> are constant time. Therefore, the time complexity for this function is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>replaceValues</code> function iterates all the values in <code>inorderTraversal</code> of size <code>n</code> in each iteration. It iterates all the nodes exactly once. Therefore, the time complexity for this function is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The time complexity for the main function is given by <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>While traversing the tree, the recursion stack in both functions stores exactly <code>n</code> nodes in the worst case. Also, the size of the <code>inorderTraversal</code> array is <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-reverse-in-order-traversal">Approach 2: Reverse In-order Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Traversing the right subtree before the left subtree during an in-order traversal means we can visit the greater values before the smaller ones. This approach will traverse the tree so that all the nodes are visited in descending order. An example of this reverse in-order traversal is shown below:</p>
<p><img src="../Figures/1038/Slide1.PNG" alt="figA" /></p>
<p>We use recursion to visit the right subtree first, reaching the rightmost node with the maximum value. During traversal, each node's value is updated with a running sum of all previously visited nodes. This approach works because visiting nodes in descending order allows us to accumulate and update the sum progressively.</p>
<p>Next, we move to the left subtree and repeat the process, using the call stack to return to nodes with smaller values.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Main function</strong></p>
<ol>
<li>Initialize an integer <code>nodeSum</code> with 0.</li>
<li>Call <code>bstToGstHelper(root)</code>.</li>
<li>Return the value of <code>root</code>.</li>
</ol>
<p><strong>Helper function - <code>bstToGstHelper(TreeNode root,int nodeSum)</code></strong></p>
<ol>
<li>If the <code>root</code> is null:
<ul>
<li>Return the <code>root</code> without any changes.</li>
</ul>
</li>
<li>Recursively call the right subtree of root.</li>
<li>Increment <code>nodeSum</code> by the value of the current node and replace current node's value with <code>nodeSum</code>.</li>
<li>Recursively call the left subtree of the root.</li>
<li>Return <code>root</code>.</li>
</ol>
<p>!?!../Documents/1038/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/P4NiS6sq/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive function is called for every node exactly once. All the operations performed in the <code>bstToGst</code> function are constant time. Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive function is called exactly <code>n</code> times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-reverse-in-order-traversal">Approach 3: Iterative Reverse In-order Traversal</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can perform a reverse in-order traversal by emulating the recursion call stack iteratively using a stack.</p>
<p>We can iterate the nodes of the tree, and push them in the stack until we reach the rightmost node of the tree, similar to the recursive process.</p>
<p>We need to maintain the sum while traversing in decreasing order and increment the value of the top node of the stack by this sum. Similarly, we can repeat this process for the left subtree of the current node.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize integer <code>nodeSum</code> with 0 and a stack <code>st</code> to store the nodes of the tree. Create a copy of the <code>root</code> in <code>node</code>.</li>
<li>Iterate until <code>st</code> is not empty or <code>node</code> is not <code>null</code>:
<ul>
<li>While <code>node</code> is not null:
<ul>
<li>Push the current node in <code>st</code>.</li>
<li>Replace <code>node</code> with the right child of <code>node</code>.</li>
</ul>
</li>
<li>Store the top element of <code>st</code> in <code>node</code> and pop <code>st</code>.</li>
<li>Increment <code>nodeSum</code> with the value of <code>node</code>.</li>
<li>Replace the value of <code>node</code> with this value.</li>
<li>Replace <code>node</code> with the left child of <code>node</code>.</li>
</ul>
</li>
<li>Return <code>root</code>.</li>
</ol>
<p>!?!../Documents/1038/slideshow2.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/7ecgLZtM/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>Every node is pushed into the stack and popped from the stack exactly once. All the other operations performed in the loop are constant time. Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>The recursive function is called exactly <code>n</code> times. In the worst case where the binary search tree is skewed such that all the nodes only have the right children, the call stack size will grow up to <code>n</code>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
<hr />
<h3 id="approach-4-morris-traversal">Approach 4: Morris Traversal</h3>
<h4 id="intuition-3">Intuition</h4>
<blockquote>
<p>This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>We will continue using the same idea from the previous approach. Is there a way for us to perform the inorder traversal without using any space, including the recursion call stack?</p>
<p>Morris Traversal is an efficient algorithm used to perform in-order tree traversal without using any extra space for recursion or a stack, which is typically required in conventional tree traversal methods. The algorithm uses the concept of threaded binary trees, temporarily modifying the tree structure during traversal to avoid additional memory usage.</p>
<p>Before diving into Morris traversal, it's crucial to understand threaded binary trees:</p>
<ol>
<li>In a threaded binary tree, &quot;null&quot; right pointers are replaced with pointers to the in-order successor of the node.</li>
<li>This threading allows for efficient traversal without recursion or a stack.</li>
</ol>
<p><strong>Note:</strong> If you are new to the concept of Morris traversal, we recommend you first read <a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded Binary Trees</a> and <a href="https://stackoverflow.com/a/5506601">Working of the Morris traversal algorithm</a>. You can also understand the implementation of the algorithm <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/editorial/#approach-3-morris-traversal">here</a>.</p>
<p>To apply the reverse in-order traversal using Morris traversal, we can swap all <code>left</code> and <code>right</code> pointer references to the BST. This would return all the nodes in the descending order of their values.</p>
<p>Check out the example given below to understand the conversion process:</p>
<p>!?!../Documents/1038/slideshow3.json:960,540!?!</p>
<p>In the final tree obtained, if there is no right subtree, then we can visit this node and continue traversing left. If there is a right subtree, then there is at least one node that has a greater value than the current one. Therefore, we must traverse that subtree first before the current node which would help us to traverse all the node values in decreasing order.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Main function - <code>bstToGst(root)</code></strong></p>
<ol>
<li>Initialize an integer <code>sum</code> with 0 and a dummy node <code>node</code> with root.</li>
<li>Iterate while node's value is not <code>null</code>:
<ul>
<li>If node's right child is not <code>null</code>:
<ul>
<li>Increment <code>sum</code> with node's value.</li>
<li>Replace node's value with this sum and move to the left child.</li>
</ul>
</li>
<li>Otherwise, if the right child is <code>null</code>:
<ul>
<li>Store the in-order successor of <code>node</code> in <code>succ</code>, calculated using <code>getSuccessor(node)</code>.
<ul>
<li>If left child of <code>succ</code> is <code>null</code>:
<ul>
<li>Store <code>node</code> as the left child of <code>succ</code>.</li>
<li>Move towards the right child of <code>node</code>.</li>
</ul>
</li>
<li>Otherwise, if the left child isn't <code>null</code>:
<ul>
<li>Set left child of <code>succ</code> as null.</li>
<li>Increment <code>sum</code> with node's value.</li>
<li>Replace node's value with this sum and move to the left child.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>root</code>.</li>
</ol>
<p><strong><code>getSuccessor(node)</code></strong></p>
<ol>
<li>Initialize <code>succ</code> with right child of <code>node</code>.</li>
<li>Return the left-most child of <code>succ</code>.</li>
</ol>
<blockquote>
<p>Note: While this approach is space-efficient, it modifies the tree structure during traversal, which might not be suitable in all scenarios, especially if the tree is being accessed concurrently by other processes. The constant modification and restoration of tree links may have a slight impact on performance compared to straightforward recursive approaches, especially for smaller trees.</p>
</blockquote>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/5Uz6xMNm/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree rooted at <code>root</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Note that <code>getSuccessor</code> is called at most twice per node. On the first invocation, the temporary link back to the node in question is created, and on the second invocation, the temporary link is erased.</p>
<p>Then, the algorithm steps into the left subtree with no way to return to the node. Therefore, each edge can only be traversed 3 times: once when we move the node pointer, and once for each of the two calls to getSuccessor.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Because we only manipulate pointers that already exist, the Morris traversal uses constant space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-cameras/description" target="_blank" rel="noopener noreferrer">Binary Tree Cameras</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.</p>

<p>Return <em>the minimum number of cameras needed to monitor all nodes of the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png" style="width: 138px; height: 163px;" />
<pre>
<strong>Input:</strong> root = [0,0,null,0,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong> One camera is enough to monitor all nodes if placed as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png" style="width: 139px; height: 312px;" />
<pre>
<strong>Input:</strong> root = [0,0,null,0,null,0,null,null,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong> At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>Node.val == 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<p>Let's try to cover every node, starting from the top of the tree and working down.  Every node considered must be covered by a camera at that node or some neighbor.</p>
<p>Because cameras only care about local state, we can hope to leverage this fact for an efficient solution.  Specifically, when deciding to place a camera at a node, we might have placed cameras to cover some subset of this node, its left child, and its right child already.</p>
<p><strong>Algorithm</strong></p>
<p>Let <code>solve(node)</code> be some information about how many cameras it takes to cover the subtree at this node in various states.  There are essentially 3 states:</p>
<ul>
<li>[State 0] Strict subtree:  All the nodes below this node are covered, but not this node.</li>
<li>[State 1] Normal subtree:  All the nodes below and including this node are covered, but there is no camera here.</li>
<li>[State 2] Placed camera:  All the nodes below and including this node are covered, and there is a camera here (which may cover nodes above this node).</li>
</ul>
<p>Once we frame the problem in this way, the answer falls out:</p>
<ul>
<li>To cover a strict subtree, the children of this node must be in state 1.</li>
<li>To cover a normal subtree without placing a camera here, the children of this node must be in states 1 or 2, and at least one of those children must be in state 2.</li>
<li>To cover the subtree when placing a camera here, the children can be in any state.</li>
</ul>
<p><a href="https://leetcode.com/playground/9RMjEFK8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(H)\)</span>, where <span class="math inline">\(H\)</span> is the height of the given tree.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy">Approach 2: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>Instead of trying to cover every node from the top down, let's try to cover it from the bottom up - considering placing a camera with the deepest nodes first, and working our way up the tree.</p>
<p>If a node has its children covered and has a parent, then it is strictly better to place the camera at this node's parent.</p>
<p><strong>Algorithm</strong></p>
<p>If a node has children that are not covered by a camera, then we must place a camera here.  Additionally, if a node has no parent and it is not covered, we must place a camera here.</p>
<p><a href="https://leetcode.com/playground/SDtoVPrq/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(H)\)</span>, where <span class="math inline">\(H\)</span> is the height of the given tree.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-coloring-game/description" target="_blank" rel="noopener noreferrer">Binary Tree Coloring Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Two players play a turn based game on a binary tree. We are given the <code>root</code> of this binary tree, and the number of nodes <code>n</code> in the tree. <code>n</code> is odd, and each node has a distinct value from <code>1</code> to <code>n</code>.</p>

<p>Initially, the first player names a value <code>x</code> with <code>1 &lt;= x &lt;= n</code>, and the second player names a value <code>y</code> with <code>1 &lt;= y &lt;= n</code> and <code>y != x</code>. The first player colors the node with value <code>x</code> red, and the second player colors the node with value <code>y</code> blue.</p>

<p>Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an <strong>uncolored</strong> neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)</p>

<p>If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.</p>

<p>You are the second player. If it is possible to choose such a <code>y</code> to ensure you win the game, return <code>true</code>. If it is not possible, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png" style="width: 500px; height: 310px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3
<strong>Output:</strong> true
<strong>Explanation: </strong>The second player can choose the node with value 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2,3], n = 3, x = 1
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>1 &lt;= x &lt;= n &lt;= 100</code></li>
	<li><code>n</code> is odd.</li>
	<li>1 &lt;= Node.val &lt;= n</li>
	<li>All the values of the tree are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-inorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Inorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,2,6,5,7,1,3,9,8]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursive-approach">Approach 1: Recursive Approach</h3>
<p>The first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.</p>
<p><a href="https://leetcode.com/playground/E5pBkUup/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The time complexity is <span class="math inline">\(O(n)\)</span> because the recursive function is <span class="math inline">\(T(n) = 2 \cdot T(n/2)+1\)</span>.</li>
</ul>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The worst case space required is <span class="math inline">\(O(n)\)</span>, and in the average case it's <span class="math inline">\(O(\log n)\)</span> where <span class="math inline">\(n\)</span> is number of nodes.</li>
</ul>
<br />
<hr />
<h3 id="approach-2-iterating-method-using-stack">Approach 2: Iterating method using Stack</h3>
<p>The strategy is very similiar to the first method, the different is using stack.</p>
<p>Here is an illustration:</p>
<p>!?!../Documents/94_Binary.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/9k44r9CB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<br />
<hr />
<h3 id="approach-3-morris-traversal">Approach 3: Morris Traversal</h3>
<p>In this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:</p>
<blockquote>
<p>Step 1: Initialize current as root</p>
<p>Step 2: While current is not NULL,</p>
<pre><code>If current does not have left child

    a. Add current’s value

    b. Go to the right, i.e., current = current.right

Else

    a. In current's left subtree, make current the right child of the rightmost node

    b. Go to this left child, i.e., current = current.left
</code></pre>
</blockquote>
<p>For example:</p>
<pre><code>
          1
        /   \
       2     3
      / \   /
     4   5 6

</code></pre>
<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is</p>
<pre><code>         2
        / \
       4   5
</code></pre>
<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).<br />
The tree now looks like:</p>
<pre><code>         2
        / \
       4   5
            \
             1
              \
               3
              /
             6
</code></pre>
<p>For current 2, which has left child 4, we can continue with the same process as we did above</p>
<pre><code>        4
         \
          2
           \
            5
             \
              1
               \
                3
               /
              6
</code></pre>
<p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.<br />
Finally, the inorder traversal is [4,2,5,1,6,3].</p>
<p>For more details, please check<br />
<a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded binary tree</a> and<br />
<a href="https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion">Explanation of Morris Method</a></p>
<p><a href="https://leetcode.com/playground/fVkds6Bx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>To prove that the time complexity is <span class="math inline">\(O(n)\)</span>, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is <span class="math inline">\(O(n \log n)\)</span>, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs <span class="math inline">\(O(n)\)</span> time. Because a binary Tree with <span class="math inline">\(n\)</span> nodes has <span class="math inline">\(n-1\)</span> edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>Extra space is only allocated for the ArrayList of size <span class="math inline">\(n\)</span>, however the output does not count towards the space complexity.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-level-order-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[9,20],[15,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-level-order-traversal-ii/description" target="_blank" rel="noopener noreferrer">Binary Tree Level Order Traversal II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level from leaf to root).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[15,7],[9,20],[3]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-maximum-path-sum/description" target="_blank" rel="noopener noreferrer">Binary Tree Maximum Path Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>

<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>

<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" />
<pre>
<strong>Input:</strong> root = [-10,9,20,null,null,15,7]
<strong>Output:</strong> 42
<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-paths/description" target="_blank" rel="noopener noreferrer">Binary Tree Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>

<p>A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" style="width: 207px; height: 293px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,5]
<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [&quot;1&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-postorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Postorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[3,2,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[4,6,7,5,2,9,8,3,1]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>To traverse a tree, we use two main strategies:</p>
<ul>
<li>
<p>Breadth-First Search (BFS): This strategy involves scanning the tree level by level from the top down, visiting nodes at higher levels before those at lower levels.</p>
</li>
<li>
<p>Depth-First Search (DFS): This approach explores as far down a branch as possible before backtracking. It starts at the root, proceeds to a leaf, and then returns to explore other branches. DFS can be further categorized into:</p>
<ul>
<li>Preorder: Visit the root first, then the left subtree, followed by the right subtree.</li>
<li>Inorder: Visit the left subtree first, then the root, and then the right subtree.</li>
<li>Postorder: Visit the left subtree first, then the right subtree, and finally the root.</li>
</ul>
</li>
</ul>
<p><img src="../Figures/145/traverse2.png" alt="Tree Traversal Example" /><br />
<em>Figure 1. Nodes are numbered in the order they are visited; refer to the sequence <code>1-2-3-4-5</code> to compare different traversal strategies.</em></p>
<p>For a binary tree with the root <code>[1, null, 2, 3]</code>, the tree structure is as follows:</p>
<pre><code>1
 \
  2
 /
3
</code></pre>
<p>In Postorder traversal, nodes are visited in the sequence: <code>3</code> (left subtree), <code>2</code> (right subtree), and finally <code>1</code> (root). Thus, the output for this input should be <code>[3, 2, 1]</code>.</p>
<hr />
<h3 id="approach-1-recursive-postorder-traversal">Approach 1: Recursive Postorder Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p><img src="../Figures/145/recursion.png" alt="recursion" /><br />
<em>Figure 2. Recursive DFS traversals.</em></p>
<p>In this approach, we treat each node as the root of its subtree. We start by recursively traversing the left subtree. If the left child is not null, we continue exploring until the left subtree is fully traversed. Then, we move to the right subtree and repeat the process. After both subtrees are explored, we process the current node by adding its value to the result list.</p>
<p>The base case occurs when the current node is null, indicating no further subtree to explore. At this point, we simply return and backtrack.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Define a helper function <code>postorderTraversalHelper</code>:
<ul>
<li>If <code>currentNode</code> is <code>null</code>, return to stop further recursion.</li>
<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode-&gt;left</code> to process the left subtree.</li>
<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode-&gt;right</code> to process the right subtree.</li>
<li>Append <code>currentNode-&gt;val</code> to the <code>result</code> array to collect values in postorder.</li>
</ul>
</li>
<li>In the <code>postorderTraversal</code> function:
<ul>
<li>Initialize an empty <code>result</code> array to store the postorder ordering of the nodes in<code>root</code>.</li>
<li>Call <code>postorderTraversalHelper</code> with the root node and <code>result</code> to start the traversal.</li>
<li>Return the <code>result</code> array containing the postorder traversal.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/X7v7GcVB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is visited once during the traversal, so the time complexity is linear with respect to the number of nodes <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the recursion stack. In the worst case (e.g., a completely unbalanced tree), the recursion stack could hold all <code>n</code> nodes.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-manipulating-preorder-traversal-iterative-hack">Approach 2: Manipulating Preorder Traversal (Iterative Hack)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's take a creative leap in this approach by exploiting the relationship between preorder and postorder traversals. In a standard preorder traversal, we visit the root node before we visit the left and right subtrees. However, postorder traversal requires us to visit the left and right subtrees before the root node.</p>
<p>We can adapt the preorder traversal by visiting nodes in the order of root, right subtree, and then left subtree. Reversing the resulting list from this modified preorder traversal gives us the correct postorder sequence.</p>
<p>We use a stack to traverse the tree iteratively, starting with the root node. We push the current node onto the stack and add its value to the result list. Instead of moving to the left child, we move to the right child. If there's no right child, we pop a node from the stack and move to its left child. This approach processes the right subtree before the left subtree, aligning with the modified preorder traversal.</p>
<p>After traversing the entire tree, we reverse the result list to get the postorder sequence: left subtree, right subtree, root.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list to store the traversal result, a <code>traversalStack</code> for nodes, and set <code>currentNode</code> to <code>root</code>.</li>
<li>While <code>currentNode</code> is not <code>null</code> or <code>traversalStack</code> is not empty:
<ul>
<li>If <code>currentNode</code> is not <code>null</code>, add <code>currentNode-&gt;val</code> to the <code>result</code> list before processing its children.</li>
<li>Push <code>currentNode</code> onto the <code>traversalStack</code> to revisit it later.</li>
<li>Move <code>currentNode</code> to <code>currentNode-&gt;right</code> to continue traversal in the right subtree.</li>
<li>If <code>currentNode</code> is <code>null</code>, pop the top node from <code>traversalStack</code> and set it to <code>currentNode</code>.</li>
<li>Move <code>currentNode</code> to <code>currentNode-&gt;left</code> to process the left subtree.</li>
</ul>
</li>
<li>Reverse the <code>result</code> list to correct the order from preorder to postorder.</li>
<li>Return the <code>result</code> list with postorder traversal values.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5wrszGxT/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times (essentially twice), so the time complexity remains linear with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(2n) = O(n)\)</span> due to the stack used for traversing the tree nodes. This stack could hold up to <code>n</code> nodes in the worst case.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-stack-postorder-traversal-iterative">Approach 3: Two Stack Postorder Traversal (Iterative)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of relying on hacks and tricks, this time we will build on the idea that we need to control the order in which nodes are processed to achieve postorder traversal.</p>
<p>To achieve postorder traversal without recursion, we use two stacks to control the node processing order systematically.</p>
<p>First, we push the root node onto the first stack. This stack simulates the recursive traversal of the tree. To process nodes in postorder (left-right-root), we need a second stack to reverse the order. As we pop nodes from the first stack, we push them onto the second stack. This reversal ensures that nodes are processed in the correct order.</p>
<p>After all nodes are transferred to the second stack, popping from it gives us the nodes in postorder sequence. This method efficiently achieves the desired traversal order by leveraging the two stacks to manage the processing sequence without needing a final reversal step.</p>
<p>In summary, the two-stack approach uses the first stack for tree traversal and the second stack to reverse the order, resulting in a postorder traversal. Despite initially seeming like a manipulation of preorder traversal, the final order of nodes from the second stack aligns with postorder traversal.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list, and create <code>mainStack</code> and <code>pathStack</code> for nodes.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>Push <code>root</code> onto <code>mainStack</code> to start the traversal.</li>
<li>While <code>mainStack</code> is not empty:
<ul>
<li>Peek at the top of <code>mainStack</code> to examine the current node.</li>
<li>If the top of <code>pathStack</code> is the same as the top of <code>mainStack</code>, add <code>root-&gt;val</code> to the <code>result</code> list.</li>
<li>Pop the top node from both <code>mainStack</code> and <code>pathStack</code> after processing.</li>
<li>Otherwise, push the current node onto <code>pathStack</code>.</li>
<li>Push <code>root-&gt;right</code> and <code>root-&gt;left</code> onto <code>mainStack</code> if they exist to process their children.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/GkvWqGqp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times (once when pushed to the first stack and once when popped to the second stack), so the time complexity is linear with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n)\)</span> due to the use of two stacks. Each stack can hold up to <code>n</code> nodes in the worst case.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-single-stack-postorder-traversal-iterative">Approach 4: Single Stack Postorder Traversal (Iterative)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>After exploring the two-stack approach, we might seek to optimize further by reducing space complexity. While two stacks effectively manage traversal order, they double our space usage. Instead, we can use a single stack combined with a <code>previousNode</code> pointer to track the traversal.</p>
<p>We start by pushing nodes onto the stack while traversing left, similar to inorder traversal. In postorder traversal, we must process each node after its right subtree. To manage this, the <code>previousNode</code> pointer helps remember the last processed node.</p>
<p>When a node is reached on the stack, we first check if it has an unvisited right child. If so, we move to that right child since we can't process the current node until after its right subtree. If the node has no right child or its right child has already been processed (indicated by <code>previousNode</code>), we process the node by popping it from the stack and adding its value to the result list, then update <code>previousNode</code> to this node.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list, set <code>previousNode</code> to <code>null</code>, and initialize <code>traversalStack</code>.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>While <code>root</code> is not <code>null</code> or <code>traversalStack</code> is not empty:
<ul>
<li>If <code>root</code> is not <code>null</code>, push <code>root</code> onto <code>traversalStack</code>.</li>
<li>Move <code>root</code> to <code>root-&gt;left</code> to process the left subtree.</li>
<li>If <code>root</code> is <code>null</code>, peek at the top of <code>traversalStack</code>.</li>
<li>If <code>root-&gt;right</code> is <code>null</code> or <code>root-&gt;right</code> equals <code>previousNode</code>, add <code>root-&gt;val</code> to <code>result</code>.</li>
<li>Pop <code>root</code> from <code>traversalStack</code>, set <code>previousNode</code> to <code>root</code>, and set <code>root</code> to <code>null</code>.</li>
<li>If <code>root-&gt;right</code> is not <code>null</code>, move <code>root</code> to <code>root-&gt;right</code> to continue the traversal.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/PMTa9tEv/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is processed a constant number of times. The stack operations and pointer manipulations also contribute to a linear time complexity with respect to <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Although this approach uses only a single stack, in the worst case, the stack can still hold up to <code>n</code> nodes, so the space complexity remains <span class="math inline">\(O(n)\)</span>. However, this approach optimizes the space usage compared to using two stacks.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-morris-traversal-no-stack">Approach 5: Morris Traversal (No stack)</h3>
<h4 id="intuition-4">Intuition</h4>
<p>All the approaches so far have been using some auxiliary space. To optimize for space complexity, we can use a traversal algorithm called Morris traversal. In Morris traversal, the tree structure is temporarily modified to create temporary links that simulate the effect of a stack or recursion. As a result, there is no overhead from additional data structures and the space complexity is constant. This traversal is tricky to understand at first, but the high level idea is to link each predecessor back to the current node, which allows us to trace back to the top of the tree. We encourage you to simulate the traversal on a piece of paper to get a stronger understanding.</p>
<p>In setting up Morris traversal, we introduce a <code>dummyNode</code> with a value that is not part of the original tree and link it to the root. Our traversal begins with this dummyNode, treating it as the new root of the tree.</p>
<p>For each node, we look for its in-order predecessor, the rightmost node in its left subtree. We do this so that the in-order predecessor can be used to create a temporary link back to the current node, simulating the recursive call stack.</p>
<ul>
<li>If the current node has a left child, we find the rightmost node in the left subtree. This rightmost node is the in-order predecessor.</li>
<li>We then create a temporary link from this predecessor to the current node by setting its right pointer to the current node.</li>
</ul>
<p>If the predecessor’s right pointer is <code>null</code>, set it to point to the current node and move to the left child. This simulates the recursive call by allowing us to return to the current node after processing the left subtree.</p>
<p>When a node’s predecessor’s right pointer points back to the current node, it indicates the left subtree is processed. Process the current node and reverse the temporary link to restore the tree’s structure.</p>
<p>Finally, move to the right child and continue the traversal.</p>
<p>Morris traversal operates in <span class="math inline">\(O(n)\)</span> time because finding the predecessor is not done for every node but only for nodes with a valid left child.</p>
<blockquote>
<p>Note: Morris traversal may be a surprise topic in interviews. It’s useful to know but not always the main focus; prioritize understanding basic traversal methods first.</p>
</blockquote>
<h4 id="algorithm-4">Algorithm</h4>
<ol>
<li>Initialize an empty <code>result</code> list and create a dummy node with the value <code>-1</code>. Set <code>dummyNode-&gt;left</code> to <code>root</code> and update <code>root</code> to <code>dummyNode</code>.</li>
<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>
<li>While <code>root</code> is not <code>null</code>:
<ul>
<li>If <code>root-&gt;left</code> is not <code>null</code>, find the rightmost node (predecessor) in the <code>root-&gt;left</code> subtree.</li>
<li>If the right child of the predecessor is <code>null</code>, set the right child to <code>root</code> and move <code>root</code> to <code>root-&gt;left</code>.</li>
<li>If the right child of the predecessor is <code>root</code>, perform reverse traversal of the <code>root-&gt;left</code> subtree and add values to <code>result</code>.</li>
<li>Reverse the subtree back to its original state by restoring pointers.</li>
<li>Remove the temporary link from the predecessor to <code>root</code> and move <code>root</code> to <code>root-&gt;right</code>.</li>
<li>If <code>root-&gt;left</code> is <code>null</code>, move <code>root</code> to <code>root-&gt;right</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> list containing postorder traversal values.</li>
</ol>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/XKjo3KQc/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each node is visited a constant number of times, and the traversal through the tree is linear in terms of <code>n</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The Morris Traversal technique uses no extra space beyond the pointers used for traversal. The temporary modifications to the tree structure are reversed before the traversal ends, so the space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" style="width: 200px; height: 264px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,4,5,6,7,3,8,9]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" style="width: 350px; height: 286px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-pruning/description" target="_blank" rel="noopener noreferrer">Binary Tree Pruning</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the same tree where every subtree (of the given tree) not containing a </em><code>1</code><em> has been removed</em>.</p>

<p>A subtree of a node <code>node</code> is <code>node</code> plus every node that is a descendant of <code>node</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png" style="width: 500px; height: 140px;" />
<pre>
<strong>Input:</strong> root = [1,null,0,0,1]
<strong>Output:</strong> [1,null,0,null,1]
<strong>Explanation:</strong> 
Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.
The diagram on the right represents the answer.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png" style="width: 500px; height: 115px;" />
<pre>
<strong>Input:</strong> root = [1,0,1,0,0,0,1]
<strong>Output:</strong> [1,null,1,null,1]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png" style="width: 500px; height: 134px;" />
<pre>
<strong>Input:</strong> root = [1,1,0,1,1,0,1,0]
<strong>Output:</strong> [1,1,0,1,1,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 200]</code>.</li>
	<li><code>Node.val</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-right-side-view/description" target="_blank" rel="noopener noreferrer">Binary Tree Right Side View</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,null,5,null,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" style="width: 400px; height: 207px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,null,null,null,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,4,5]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" style="width: 400px; height: 214px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,null,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3]</span></p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = []</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-tilt/description" target="_blank" rel="noopener noreferrer">Binary Tree Tilt</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the sum of every tree node&#39;s <strong>tilt</strong>.</em></p>

<p>The <strong>tilt</strong> of a tree node is the <strong>absolute difference</strong> between the sum of all left subtree node <strong>values</strong> and all right subtree node <strong>values</strong>. If a node does not have a left child, then the sum of the left subtree node <strong>values</strong> is treated as <code>0</code>. The rule is similar if the node does not have a right child.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg" style="width: 712px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg" style="width: 800px; height: 203px;" />
<pre>
<strong>Input:</strong> root = [4,2,9,3,5,null,7]
<strong>Output:</strong> 15
<strong>Explanation:</strong> 
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 5 : |0-0| = 0 (no children)
Tilt of node 7 : |0-0| = 0 (no children)
Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)
Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)
Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)
Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg" style="width: 800px; height: 293px;" />
<pre>
<strong>Input:</strong> root = [21,7,14,1,1,2,2,3,3]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>First of all, let us clarify the concept of <strong><em>tilt</em></strong> for a given node in a tree.</p>
<p>In order to calculate the tilt value for a node, we need to know the sum of nodes in its left and right subtrees respectively.</p>
<p>Assume that we have a function <code>valueSum(node)</code> which gives the sum of all nodes, starting from the input node, then the sum of the node's left subtree would be <code>valueSum(node.left)</code>.<br />
Similarly, the sum of its right subtree would be <code>valueSum(node.right)</code>.</p>
<p>With the above functions, we can then define the tilt value of a node as follows:</p>
<p><span class="math display">\[    \text{tilt(node)} = |\text{valueSum(node.left)} - \text{valueSum(node.right)}|
\]</span></p>
<p>Given the above formula, we show an example on how the tilt value of each node looks like, in the following graph:</p>
<p><img src="../Figures/563/563_tilt_example.png" alt="tilt example" /></p>
<p><em>Note: when a subtree is empty, its value sum is zero.</em><br />
As a result, the tilt value for a leaf node would be zero, since both the left and right subtree of a leaf node are empty.</p>
<hr />
<h3 id="approach-1-post-order-dfs-traversal">Approach 1: Post-Order DFS Traversal</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>The overall idea is that we <em>traverse</em> each node, and calculate the <em>tilt</em> value for each node. At the end, we sum up all the tilt values, which is the desired result of the problem.</p>
</blockquote>
<p>There are in general two strategies to traverse a tree data structure, namely <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search</a> (<strong><em>BFS</em></strong>) and <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search</a> (<strong><em>DFS</em></strong>).</p>
<p>Concerning the DFS strategy, it can further be divided into three categories: <em>Pre-Order</em>, <em>In-Order</em> and <em>Post-Order</em>, depending on the relative order of visit among the node and its children nodes.</p>
<p>Sometimes, both strategies could work for a specific problem. In other cases, one of them might be more adapted to the problem.<br />
In our case here, the <em>DFS</em> is a more optimized choice, as one will see later.<br />
More specifically, we could apply the <strong><em>Post-Order DFS</em></strong> traversal here.</p>
<p><strong>Algorithm</strong></p>
<p>As we discussed before, in order to calculate the tilt value for a node, we need to calculate the sum of its left and right subtrees respectively.</p>
<p>Let us first implement the function <code>valueSum(node)</code> which returns the sum of values for all nodes starting from the given <code>node</code>, which can be summarized with the following recursive formula:</p>
<p><span class="math display">\[    \text{valueSum(node)} = \text{node.val} + \text{valueSum(node.left)} + \text{valueSum(node.right)}
\]</span></p>
<p>Furthermore, the tilt value of a node also depends on the value sum of its left and right subtrees, as follows:</p>
<p><span class="math display">\[    \text{tilt(node)} = |\text{valueSum(node.left)} - \text{valueSum(node.right)}|
\]</span></p>
<p>Intuitively, we could combine the above calculations within a single recursive function.<br />
In this way, we only need to traverse each node once and only once.</p>
<blockquote>
<p>More specifically, we will traverse the tree in the <strong>post-order DFS</strong>, <em>i.e.</em> we visit a node's left and right subtrees before processing the value of the current node.</p>
</blockquote>
<p>Here are some sample implementations.</p>
<p><a href="https://leetcode.com/playground/iY8eedsa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the input tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span></p>
<ul>
<li>We traverse each node once and only once. During the traversal, we calculate the tilt value for each node.</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span></p>
<ul>
<li>
<p>Although the variables that we used in the algorithm are of constant-size, we applied recursion in the algorithm which incurs additional memory consumption in function call stack.</p>
</li>
<li>
<p>In the worst case where the tree is not well balanced, the recursion could pile up <span class="math inline">\(N\)</span> times. As a result, the space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description" target="_blank" rel="noopener noreferrer">Binary Tree Zigzag Level Order Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[20,9],[15,7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-completeness-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Check Completeness of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, determine if it is a <em>complete binary tree</em>.</p>

<p>In a <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">complete binary tree</a></strong>, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" style="width: 180px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" style="width: 200px; height: 145px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> The node with value 7 isn&#39;t as far left as possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Closest Nodes Queries in a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary search tree </strong>and an array <code>queries</code> of size <code>n</code> consisting of positive integers.</p>

<p>Find a <strong>2D</strong> array <code>answer</code> of size <code>n</code> where <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code>:</p>

<ul>
	<li><code>min<sub>i</sub></code> is the <strong>largest</strong> value in the tree that is smaller than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
	<li><code>max<sub>i</sub></code> is the <strong>smallest</strong> value in the tree that is greater than or equal to <code>queries[i]</code>. If a such value does not exist, add <code>-1</code> instead.</li>
</ul>

<p>Return <em>the array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png" style="width: 261px; height: 281px;" />
<pre>
<strong>Input:</strong> root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
<strong>Output:</strong> [[2,2],[4,6],[15,-1]]
<strong>Explanation:</strong> We answer the queries in the following way:
- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].
- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].
- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png" style="width: 101px; height: 121px;" />
<pre>
<strong>Input:</strong> root = [4,null,9], queries = [3]
<strong>Output:</strong> [[-1,4]]
<strong>Explanation:</strong> The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>n == queries.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/complete-binary-tree-inserter/description" target="_blank" rel="noopener noreferrer">Complete Binary Tree Inserter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>complete binary tree</strong> is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>

<p>Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.</p>

<p>Implement the <code>CBTInserter</code> class:</p>

<ul>
	<li><code>CBTInserter(TreeNode root)</code> Initializes the data structure with the <code>root</code> of the complete binary tree.</li>
	<li><code>int insert(int v)</code> Inserts a <code>TreeNode</code> into the tree with value <code>Node.val == val</code> so that the tree remains complete, and returns the value of the parent of the inserted <code>TreeNode</code>.</li>
	<li><code>TreeNode get_root()</code> Returns the root node of the tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg" style="width: 500px; height: 143px;" />
<pre>
<strong>Input</strong>
[&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;]
[[[1, 2]], [3], [4], []]
<strong>Output</strong>
[null, 1, 2, [1, 2, 3, 4]]

<strong>Explanation</strong>
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3);  // return 1
cBTInserter.insert(4);  // return 2
cBTInserter.get_root(); // return [1, 2, 3, 4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 5000</code></li>
	<li><code>root</code> is a complete binary tree.</li>
	<li><code>0 &lt;= val &lt;= 5000</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>insert</code> and <code>get_root</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-deque">Approach 1: Deque</h3>
<p><strong>Intuition</strong></p>
<p>Consider all the nodes numbered first by level and then left to right.  Call this the &quot;number order&quot; of the nodes.</p>
<p>At each insertion step, we want to insert into the node with the lowest number (that still has 0 or 1 children).</p>
<p>By maintaining a <code>deque</code> (double ended queue) of these nodes in number order, we can solve the problem.  After inserting a node, that node now has the highest number and no children, so it goes at the end of the deque.  To get the node with the lowest number, we pop from the beginning of the deque.</p>
<p><strong>Algorithm</strong></p>
<p>First, perform a breadth-first search to populate the <code>deque</code> with nodes that have 0 or 1 children, in number order.</p>
<p>Now when inserting a node, the parent is the first element of <code>deque</code>, and we add this new node to our <code>deque</code>.</p>
<p><a href="https://leetcode.com/playground/KLGeXjUA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  The preprocessing is <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.  Each insertion operation thereafter is <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N_{\text{cur}})\)</span> space complexity, when the size of the tree during the current insertion operation is <span class="math inline">\(N_{\text{cur}}\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Search Tree from Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p>

<p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p>

<p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p>

<p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" style="height: 386px; width: 590px;" />
<pre>
<strong>Input:</strong> preorder = [8,5,1,7,10,12]
<strong>Output:</strong> [8,5,10,1,7,null,12]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [1,3]
<strong>Output:</strong> [1,null,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
	<li><code>1 &lt;= preorder[i] &lt;= 1000</code></li>
	<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Tree from Inorder and Postorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
<strong>Output:</strong> [3,9,20,null,null,15,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> inorder = [-1], postorder = [-1]
<strong>Output:</strong> [-1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>
	<li><code>postorder.length == inorder.length</code></li>
	<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>
	<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>
	<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>
	<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>
	<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Tree from Preorder and Inorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>Output:</strong> [3,9,20,null,null,15,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [-1], inorder = [-1]
<strong>Output:</strong> [-1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
	<li><code>inorder.length == preorder.length</code></li>
	<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
	<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>
	<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>
	<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>
	<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Tree from Preorder and Postorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays, <code>preorder</code> and <code>postorder</code> where <code>preorder</code> is the preorder traversal of a binary tree of <strong>distinct</strong> values and <code>postorder</code> is the postorder traversal of the same tree, reconstruct and return <em>the binary tree</em>.</p>

<p>If there exist multiple answers, you can <strong>return any</strong> of them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" style="width: 304px; height: 265px;" />
<pre>
<strong>Input:</strong> preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
<strong>Output:</strong> [1,2,3,4,5,6,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [1], postorder = [1]
<strong>Output:</strong> [1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 30</code></li>
	<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>
	<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
	<li><code>postorder.length == preorder.length</code></li>
	<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>
	<li>All the values of <code>postorder</code> are <strong>unique</strong>.</li>
	<li>It is guaranteed that <code>preorder</code> and <code>postorder</code> are the preorder traversal and postorder traversal of the same binary tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two integer arrays that represent the <code>preorder</code> and <code>postorder</code> traversals of a binary tree. Our task is to rebuild the tree and return its root. First, let's clarify the key terms involved in this task:</p>
<p>A <em>binary tree</em> is a tree data structure where each node has at most two children, called <code>left</code> and <code>right</code>. Tree traversal means visiting all the nodes in a specific order. In this problem, we use two common types of binary tree traversal:</p>
<ul>
<li><strong>Preorder traversal</strong>: We visit the current node first, then go to the left child, and finally to the right child. This means that the parent node will appear before its children in the <code>preorder</code> array.</li>
</ul>
<p>!?!../Documents/889/889_preorder.json:960,540!?!</p>
<ul>
<li><strong>Postorder traversal</strong>: We temporarily ignore the current node and move directly to its children, visiting the left child first and then the right. After that, we return to the node and process it last. In other words, the parent node always appears after its children in the <code>postorder</code> array.</li>
</ul>
<p>!?!../Documents/889/889_postorder.json:960,540!?!</p>
<blockquote>
<p>For a more comprehensive understanding of binary trees, check out the <a href="https://leetcode.com/explore/learn/card/data-structure-tree/">Binary Tree Explore Card 🔗</a>. This resource provides an in-depth look at binary trees, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>If you'd like more practice with binary trees, you can first try to construct the two traversals that we are going to use in this problem:</p>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">Binary Tree Preorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">Binary Tree Postorder Traversal</a></li>
</ul>
<h3 id="approach-1-divide-and-conquer">Approach 1: Divide and Conquer</h3>
<h4 id="intuition">Intuition</h4>
<p>Binary trees are inherently recursive structures, meaning we can break them down into smaller subtrees until the problem becomes simple enough to solve directly. In this problem, the base cases are straightforward: if the traversal arrays contain only one element, the tree consists of a single node with that element as its value. Even simpler, when the arrays are empty, the tree is <code>NULL</code>.</p>
<p>For cases where the arrays contain more than one element, we assume we already know how to solve the problem for smaller trees (<span class="math inline">\(N - 1\)</span> elements or fewer). The key observation is that the first node in the preorder traversal is always the root of the tree. Our goal, then, is to correctly determine which parts of the preorder and postorder arrays correspond to the left and right subtrees. Once we identify these sections, we can recursively construct the left and right subtrees and attach them to the root, forming the complete tree.</p>
<p>To determine which nodes belong to the left and right subtrees, note that the second element in the preorder array is the root of the left subtree, which we'll call <code>leftRoot</code>. In the <code>postorder</code> array, all nodes visited before <code>leftRoot</code> belong to the left subtree. Conversely, the nodes visited after <code>leftRoot</code> in the <code>postorder</code> array belong to the right subtree. Using this division, we can pass the appropriate segments of the arrays to the recursive function, allowing it to build the tree step by step.</p>
<p>This approach is based on the <strong>Divide and Conquer</strong> technique, where we recursively break the problem down into two or more subproblems of the same type, continuing until we reach a base case. For a deeper understanding of the topic, you can refer to the relevant <a href="https://leetcode.com/problem-list/divide-and-conquer/">LeetCode Explore Card 🔗</a>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define the recursive function <code>constructTree(preStart, preEnd, postStart, preorder, postorder)</code>:
<ul>
<li>If <code>preStart &gt; preEnd</code>, i.e. there are no more nodes to process, return <code>NULL</code>.</li>
<li>If <code>preStart == preEnd</code>, the tree contains only one node:
<ul>
<li>Return a new node with value <code>preorder[preStart]</code> and no children.</li>
</ul>
</li>
<li>Define <code>leftRoot</code> as the second element of the current portion of the preorder array, i.e., <code>preorder[preStart + 1]</code>.</li>
<li>Initialize <code>numOfNodesInLeft</code> to <code>1</code>.</li>
<li>Iterate over the current portion of the <code>postorder</code> array until <code>leftRoot</code> is found. While <code>postorder[postStart + numOfNodesInLeft - 1] != leftRoot</code>:
<ul>
<li>Increment <code>numOfNodesInLeft</code> by <code>1</code>.</li>
</ul>
</li>
<li>Create a new node <code>root</code> and set its value to <code>preorder[preStart]</code>.</li>
<li>Recursively construct the left subtree of root by calling <code>constructTree(preStart + 1, preStart + numOfNodesInLeft, postStart, preorder, postorder)</code>.</li>
<li>Construct the right subtree by calling: <code>constructTree(preStart + numOfNodesInLeft + 1, preEnd, postStart + numOfNodesInLeft, preorder, postorder)</code>.</li>
<li>Return <code>root</code>.</li>
</ul>
</li>
<li>In the main <code>constructFromPrePost</code> function:
<ul>
<li>Initialize <code>numOfNodes</code> to the size of the traversal arrays.</li>
<li>Call the helper function <code>constructTree(preStart = 0, preEnd = numOfNodes - 1, postStart = 0, preorder, postorder)</code> and return the root of the constructed tree.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/eermTXfp/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the traversal arrays.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We call the <code>constructTree</code> function <span class="math inline">\(n\)</span> times, once for each element in the preorder array. In each call, the function makes a linear pass over the <code>postorder</code> array to find the position of the element that matches the root of the left subtree. This means each call to <code>constructTree</code> takes <span class="math inline">\(O(n)\)</span> time, and with <span class="math inline">\(n\)</span> calls in total, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since we are not using any additional data structures other than the input arrays and the result tree, the space complexity is determined by the depth of the recursion. In the worst case, where the tree is a list of nodes with only left children, the recursion will go <span class="math inline">\(O(n)\)</span> levels deep, one for each node. Therefore, the algorithm requires <span class="math inline">\(O(n)\)</span> extra space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-index-array">Approach 2: Using Index Array</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Looking at our previous approach, we see that searching through the <code>postorder</code> array in each call to <code>constructTree</code> adds an extra <span class="math inline">\(O(n)\)</span> time cost, slowing down the algorithm. How can we remove this bottleneck while using the fact that all node values are unique?</p>
<p>An intuitive solution might be to use a hash map to store the index of each node value in <code>postorder</code>. This allows quick lookups and helps us determine how many nodes belong to each subtree efficiently. While this works well and keeps the time and space complexity the same, we can optimize further. Since node values do not exceed the length of the traversal arrays, we can use an index array instead of a hash map. This improves both runtime and auxiliary space usage.</p>
<p>So, in the preprocessing phase, we create an index array by storing the position of each element in the post-order traversal. This index array replaces the need for the original post-order array in recursion.</p>
<p>The algorithm then follows the same structure: the first node in the current preorder segment is the root, and the second is the root of its left subtree (<code>leftRoot</code>). By finding the index of <code>leftRoot</code> in post-order, we determine the left subtree's size and split the problem into two smaller subproblems. We then recursively build the left and right subtrees using the relevant subarrays.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define the recursive function <code>constructTree(preStart, preEnd, postStart, preorder, indexInPostorder)</code>:
<ul>
<li>If <code>preStart &gt; preEnd</code>, meaning that there are no more nodes to process, return <code>NULL</code>.</li>
<li>If <code>preStart == preEnd</code>, the tree contains only one node:
<ul>
<li>Return a new node with value <code>preorder[preStart]</code> and no children.</li>
</ul>
</li>
<li>Define <code>leftRoot</code> as the second element of the current portion of the preorder array, i.e., <code>preorder[preStart + 1]</code>.</li>
<li>Initialize <code>numOfNodesInLeft</code> to <code>indexInPostorder[leftRoot] - postStart + 1</code>, indicating the number of nodes that occur before <code>leftRoot</code> in <code>postorder</code> and should be added to the left subtree.</li>
<li>Create a new node <code>root</code> and set its value to <code>preorder[preStart]</code>.</li>
<li>Recursively construct the left subtree of <code>root</code> by calling: <code>constructTree(preStart + 1, preStart + numOfNodesLeft, postStart, preorder, indexInPostorder)</code>.</li>
<li>Construct the right subtree by calling: <code>constructTree(preStart + numOfNodesInLeft + 1, preEnd, postStart + numOfNodesInLeft, preorder, indexInPostorder)</code>.</li>
<li>Return <code>root</code>.</li>
</ul>
</li>
<li>In the main <code>constructFromPrePost</code> function:
<ul>
<li>Initialize <code>numOfNodes</code> to the size of the traversal arrays.</li>
<li>Create an index array <code>indexInPostorder</code> of size <code>numOfNodes + 1</code>.</li>
<li>Iterate over <code>postorder</code> and for each element store its index in the <code>indexInPostorder</code> array.</li>
<li>Call the helper function <code>constructTree(preStart = 0, preEnd = numOfNodes - 1, postStart = 0, preorder, indexInPostorder)</code> and return the root of the constructed tree.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FNvvG4un/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the traversal arrays.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>constructTree</code> function is called exactly <span class="math inline">\(n\)</span> times, once for each node in the tree. Unlike the previous approach, each call handles a constant amount of work because subtree sizes are computed in constant time using the <code>indexInPostorder</code> array. As a result, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>indexInPostorder</code> array requires <span class="math inline">\(O(n)\)</span> space, as it stores the index of each element in the <code>postorder</code> traversal. Additionally, in the worst case, the recursion depth can reach <span class="math inline">\(n\)</span> levels, leading to a total space complexity of <span class="math inline">\(O(n)\)</span> for both recursion and auxiliary data structures.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-optimized-recursion">Approach 3: Optimized Recursion</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approaches, we explicitly searched for the dividing point between the left and right subtrees using <code>postorder</code>, which introduced an additional lookup step. Here we remove that extra search by dynamically determining subtree boundaries as we traverse the arrays, making the recursion more efficient.</p>
<p>The core idea is to process nodes in preorder to determine which nodes to create and use postorder to recognize when a subtree is complete. Since preorder always visits nodes in the order Root → Left → Right, each recursive call picks the next node from <code>preorder</code> and assigns it as the root of the current subtree. Meanwhile, since postorder follows Left → Right → Root, a subtree is fully processed when we encounter its root in <code>postorder</code>. To track this, we maintain an index <code>posIndex</code> that moves forward as nodes get finalized.</p>
<p>To construct the tree, we first check if the current root’s value matches <code>postorder[posIndex]</code>. If it does, the subtree ends at this node, meaning it has no children. Otherwise, we attempt to construct the left subtree by making a recursive call. If the next value still doesn’t match <code>postorder[posIndex]</code>, it means there must also be a right subtree, so we make another recursive call to construct it.</p>
<p>Once both subtrees are built, we move <code>posIndex</code> forward to mark this node and its subtree as fully processed.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Define the recursive function <code>constructTree(preIndex, postIndex, preorder, postorder)</code>:
<ul>
<li>Create a new node <code>root</code> with value <code>preorder[preIndex]</code>.</li>
<li>Increment <code>preIndex</code> by <code>1</code> to mark this node as created.</li>
<li>If the value of root is not equal to <code>postorder[postIndex]</code>, meaning that the node has children:
<ul>
<li>Recursively construct the left subtree using: <code>constructTree(preIndex, postIndex, preorder, postorder)</code>.</li>
</ul>
</li>
<li>If the value of <code>root</code> is still not equal to <code>postorder[postIndex]</code>, the node has a right child as well:
<ul>
<li>Construct the right subtree using: <code>constructTree(preIndex, postIndex, preorder, postorder)</code>.</li>
</ul>
</li>
<li>Increment <code>postIndex</code> by <code>1</code> to mark this node and its subtree as processed.</li>
<li>Return <code>root</code>.</li>
</ul>
</li>
<li>In the main <code>constructFromPrePost</code> function:
<ul>
<li>Initialize two variables, <code>preIndex = 0</code>, <code>postIndex = 0</code>.</li>
<li>Create the tree using <code>constructTree(preIndex, postIndex, preorder, postorder)</code> and return it.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z5S9HWsh/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the traversal arrays.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We are making <span class="math inline">\(n\)</span> recursive calls, one for each node in the tree. Each call of the <code>constructTree</code> function involves only constant-time operations, like comparing values and incrementing pointers, and therefore the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since we are not using any additional data structures, the auxiliary space complexity is determined by the recursion depth. In the worst case (when the <code>postorder</code> array contains the nodes in reverse order from the <code>preorder</code> array), we make <span class="math inline">\(n\)</span> recursive calls to create all the nodes before starting to backtrack. Therefore, the recursion depth can reach <span class="math inline">\(O(n)\)</span>, which also corresponds to the space complexity of the algorithm.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-string-from-binary-tree/description" target="_blank" rel="noopener noreferrer">Construct String from Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines:</p>

<ul>
	<li>
	<p><strong>Node Representation</strong>: Each node in the tree should be represented by its integer value.</p>
	</li>
	<li>
	<p><strong>Parentheses for Children</strong>: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically:</p>

	<ul>
		<li>If a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node&#39;s value.</li>
		<li>If a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child.</li>
	</ul>
	</li>
	<li>
	<p><strong>Omitting Empty Parentheses</strong>: Any empty parentheses pairs (i.e., <code>()</code>) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained.</p>

	<p>In summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree&#39;s structure accurately.</p>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4]
<strong>Output:</strong> &quot;1(2(4))(3)&quot;
<strong>Explanation:</strong> Originally, it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4]
<strong>Output:</strong> &quot;1(2()(4))(3)&quot;
<strong>Explanation:</strong> Almost the same as the first example, except the <code>()</code> after <code>2</code> is necessary to indicate the absence of a left child for <code>2</code> and the presence of a right child.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-bst-to-greater-tree/description" target="_blank" rel="noopener noreferrer">Convert BST to Greater Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>

<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" style="width: 500px; height: 341px;" />
<pre>
<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0,null,1]
<strong>Output:</strong> [1,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1038: <a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Convert Sorted Array to Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword="height-balanced"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" style="width: 302px; height: 222px;" />
<pre>
<strong>Input:</strong> nums = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" style="width: 302px; height: 222px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" style="width: 342px; height: 142px;" />
<pre>
<strong>Input:</strong> nums = [1,3]
<strong>Output:</strong> [3,1]
<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Convert Sorted List to Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword="height-balanced"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" style="width: 500px; height: 388px;" />
<pre>
<strong>Input:</strong> head = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-complete-tree-nodes/description" target="_blank" rel="noopener noreferrer">Count Complete Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>

<p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>

<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type="code">O(n)</code>&nbsp;time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" style="width: 372px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The tree is guaranteed to be <strong>complete</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-good-nodes-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Count Good Nodes in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named&nbsp;<strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.</p>

<p>Return the number of <strong>good</strong> nodes in the binary tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" style="width: 263px; height: 156px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [3,1,4,3,null,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.
Root Node (3) is always a good node.
Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.
Node 5 -&gt; (3,4,5) is the maximum value in the path
Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" style="width: 157px; height: 161px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [3,3,null,4,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the binary tree is in the range&nbsp;<code>[1, 10^5]</code>.</li>
	<li>Each node&#39;s value is between <code>[-10^4, 10^4]</code>.</li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-nodes-equal-to-average-of-subtree/description" target="_blank" rel="noopener noreferrer">Count Nodes Equal to Average of Subtree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the number of nodes where the value of the node is equal to the <strong>average</strong> of the values in its <strong>subtree</strong></em>.</p>

<p><strong>Note:</strong></p>

<ul>
	<li>The <strong>average</strong> of <code>n</code> elements is the <strong>sum</strong> of the <code>n</code> elements divided by <code>n</code> and <strong>rounded down</strong> to the nearest integer.</li>
	<li>A <strong>subtree</strong> of <code>root</code> is a tree consisting of <code>root</code> and all of its descendants.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png" style="width: 300px; height: 212px;" />
<pre>
<strong>Input:</strong> root = [4,8,5,0,1,null,6]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
For the node with value 0: The average of its subtree is 0 / 1 = 0.
For the node with value 1: The average of its subtree is 1 / 1 = 1.
For the node with value 6: The average of its subtree is 6 / 1 = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png" style="width: 80px; height: 76px;" />
<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> For the node with value 1: The average of its subtree is 1 / 1 = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-depth-first-search-dfs">Approach: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<p>We are given a binary tree with nodes that have non-negative integer values. We need to return the number of nodes that have the same value as the average value of all the nodes that have that node as their root (and the root node is included in the subtree). To find the average, we can round down the value to the nearest integer.</p>
<p>To find the average of some integers, we have two requirements. One is the sum of all the integers, and the other one is the number of integers. If we have both of these, we can find the average by dividing the sum by the number of integers. In this problem, we need the sum of all the nodes in the subtree <code>Sum of nodes</code>, and the second is the number of nodes in the subtree <code>Number of nodes</code>. We can then find the average as the <code>Sum of nodes / Number of nodes</code>.</p>
<p>One naive way to do this is to iterate over each node in the binary tree and then iterate over the subtree starting with this node, keeping the sum of nodes and count of nodes in two variables. Then, after completing the subtree, we will check if the average is equal to the root node value. If it is, we will increment the count of the answer variable. This approach is, however, inefficient as we will be iterating over the nodes multiple times. For each node, we will have to iterate over the nodes in the subtree, even if they have already been traversed.</p>
<p>In the above approach, we have to iterate over the nodes multiple times because we have started from top to bottom and as a result, we are not able to reuse the sum and count. Instead of going from to root node to the leaves, we can iterate in the reverse manner. We will first iterate over the left and right subtree of each node and return the sum of nodes as well as the count of nodes, Then we can find the average and check if this node should be counted. We will repeat the process for each node and return the final count once we have iterated over all the nodes.</p>
<p>If we look closely, traversing the children before traversing the nodes is a depth-first search traversal. We will use a recursive function that will return a pair of integers where the first integer is the sum of the nodes and the second integer is the count of the nodes. Using the pairs returned from the left and right subtrees, we can find the number of nodes in the total subtree and the total number of nodes. We can then find the average and determine whether the node should be counted in the final answer.</p>
<p>Note that at the current node when we get the node values sum and count of nodes in both the left and right subtree, we add these values along with the current node value to get the total sum of this subtree and we add one to the total nodes to get the total nodes.</p>
<p><img src="../Figures/2265/2265A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Define the method <code>postOrder</code> which takes a node <code>root</code> and returns a pair of integers, where the first integer is the sum of all nodes in the subtree under <code>root</code> and the second integer is the count of a node in the subtree under <code>root</code>. <code>postOrder</code> will include these steps:</p>
</li>
<li>
<p>Return a pair with <code>(0, 0)</code> if the <code>root</code> is <code>NULL</code>.</p>
</li>
<li>
<p>Recursively call <code>postOrder</code> for the left and the right child of the <code>root</code> and store the pairs as <code>left</code> and <code>right</code> respectively.</p>
</li>
<li>
<p>Find the total sum under <code>root</code> as the sum of nodes in the pair <code>left</code>, and <code>right</code> and the <code>root</code> itself as <code>nodeSum</code>.</p>
</li>
<li>
<p>Find the total node count under <code>root</code> as the count of nodes in the pair <code>left</code>, and <code>right</code> and the <code>1</code> for the <code>root</code>  as <code>nodeCount</code>.</p>
</li>
<li>
<p>Find the average using <code>nodeSum</code> and <code>nodeCount</code> and increment the counter <code>count</code> if the average is equal to the <code>root</code> value.</p>
</li>
<li>
<p>Return a pair as <code>(nodeSum, nodeCount)</code>.</p>
</li>
<li>
<p>When <code>postOrder</code> is finished, return <code>count</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/HdrFXhxy/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity <span class="math inline">\(O(N)\)</span></p>
<p>We need to iterate over each node in the binary tree only once, and all other operations, like finding the average, are <span class="math inline">\(O(1)\)</span>, and hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity <span class="math inline">\(O(N)\)</span></p>
<p>Recursion requires some stack space, and the maximum number of active stack calls would be equal to <span class="math inline">\(N\)</span> (one for each node). The space required by the pair is <span class="math inline">\(O(1)\)</span> and hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-nodes-with-the-highest-score/description" target="_blank" rel="noopener noreferrer">Count Nodes With the Highest Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>binary</strong> tree rooted at <code>0</code> consisting of <code>n</code> nodes. The nodes are labeled from <code>0</code> to <code>n - 1</code>. You are given a <strong>0-indexed</strong> integer array <code>parents</code> representing the tree, where <code>parents[i]</code> is the parent of node <code>i</code>. Since node <code>0</code> is the root, <code>parents[0] == -1</code>.</p>

<p>Each node has a <strong>score</strong>. To find the score of a node, consider if the node and the edges connected to it were <strong>removed</strong>. The tree would become one or more <strong>non-empty</strong> subtrees. The <strong>size</strong> of a subtree is the number of the nodes in it. The <strong>score</strong> of the node is the <strong>product of the sizes</strong> of all those subtrees.</p>

<p>Return <em>the <strong>number</strong> of nodes that have the <strong>highest score</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/10/03/example-1.png" style="width: 604px; height: 266px;" />
<pre>
<strong>Input:</strong> parents = [-1,2,0,2,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- The score of node 0 is: 3 * 1 = 3
- The score of node 1 is: 4 = 4
- The score of node 2 is: 1 * 1 * 2 = 2
- The score of node 3 is: 4 = 4
- The score of node 4 is: 4 = 4
The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="example-2" src="https://assets.leetcode.com/uploads/2021/10/03/example-2.png" style="width: 95px; height: 143px;" />
<pre>
<strong>Input:</strong> parents = [-1,2,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- The score of node 0 is: 2 = 2
- The score of node 1 is: 2 = 2
- The score of node 2 is: 1 * 1 = 1
The highest score is 2, and two nodes (node 0 and node 1) have the highest score.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parents.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>parents[0] == -1</code></li>
	<li><code>0 &lt;= parents[i] &lt;= n - 1</code> for <code>i != 0</code></li>
	<li><code>parents</code> represents a valid binary tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cousins-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Cousins in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree with unique values and the values of two different nodes of the tree <code>x</code> and <code>y</code>, return <code>true</code> <em>if the nodes corresponding to the values </em><code>x</code><em> and </em><code>y</code><em> in the tree are <strong>cousins</strong>, or </em><code>false</code><em> otherwise.</em></p>

<p>Two nodes of a binary tree are <strong>cousins</strong> if they have the same depth with different parents.</p>

<p>Note that in a binary tree, the root node is at the depth <code>0</code>, and children of each depth <code>k</code> node are at the depth <code>k + 1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" style="width: 304px; height: 270px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4], x = 4, y = 3
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" style="width: 334px; height: 266px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" style="width: 267px; height: 258px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4], x = 2, y = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li><code>x != y</code></li>
	<li><code>x</code> and <code>y</code> are exist in the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cousins-in-binary-tree-ii/description" target="_blank" rel="noopener noreferrer">Cousins in Binary Tree II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, replace the value of each node in the tree with the <strong>sum of all its cousins&#39; values</strong>.</p>

<p>Two nodes of a binary tree are <strong>cousins</strong> if they have the same depth with different parents.</p>

<p>Return <em>the </em><code>root</code><em> of the modified tree</em>.</p>

<p><strong>Note</strong> that the depth of a node is the number of edges in the path from the root node to it.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/example11.png" style="width: 571px; height: 151px;" />
<pre>
<strong>Input:</strong> root = [5,4,9,1,10,null,7]
<strong>Output:</strong> [0,0,0,7,7,null,11]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 5 does not have any cousins so its sum is 0.
- Node with value 4 does not have any cousins so its sum is 0.
- Node with value 9 does not have any cousins so its sum is 0.
- Node with value 1 has a cousin with value 7 so its sum is 7.
- Node with value 10 has a cousin with value 7 so its sum is 7.
- Node with value 7 has cousins with values 1 and 10 so its sum is 11.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/11/diagram33.png" style="width: 481px; height: 91px;" />
<pre>
<strong>Input:</strong> root = [3,1,2]
<strong>Output:</strong> [0,0,0]
<strong>Explanation:</strong> The diagram above shows the initial binary tree and the binary tree after changing the value of each node.
- Node with value 3 does not have any cousins so its sum is 0.
- Node with value 1 does not have any cousins so its sum is 0.
- Node with value 2 does not have any cousins so its sum is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-two-pass-bfs">Approach 1: Two Pass BFS</h3>
<h4 id="intuition">Intuition</h4>
<p>Cousins are nodes that share the same depth but have different parents. This means that to find the sum of a node’s cousins, we first need to know the total sum of all nodes at the same depth. If we subtract the sum of a node and its siblings from this total, we’re left with the sum of its cousins.</p>
<p><img src="../Figures/2641/2641_cousins_II.png" alt="2641_cousins_II" /></p>
<p>With this thought in mind, we break down the solution into two parts. First, we perform a BFS traversal to calculate the sum of all nodes at each level. In BFS, we explore each level independently, which lets us sum the node values for each level as we go. We store these sums in an array, <code>levelSums</code>, so each level’s total is recorded and ready for the next part.</p>
<p>In the second part, we go through the tree again with another BFS traversal. Now, as we visit each node, we use the <code>levelSums</code> array recorded earlier. For each node, we subtract the value of itself and its sibling from the corresponding <code>levelSums</code> entry. The remaining sum is the cousin sum, which we then assign to the current node.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>If the <code>root</code> is null, return <code>root</code>.</p>
</li>
<li>
<p>Initialize a queue <code>nodeQueue</code> and push <code>root</code> into it.</p>
</li>
<li>
<p>Create an array <code>levelSums</code> to store the sum of node values at each level.</p>
</li>
<li>
<p>First BFS traversal to calculate the sum of nodes at each level:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Initialize <code>levelSum</code> to <code>0</code> for the current level.</li>
<li>Get the number of nodes at the current level (<code>levelSize</code>).</li>
<li>For each node at this level:
<ul>
<li>Pop the front node from the queue and add its value to <code>levelSum</code>.</li>
<li>If the node has a left child, push it to the queue.</li>
<li>If the node has a right child, push it to the queue.</li>
</ul>
</li>
<li>After processing all nodes at the level, append <code>levelSum</code> to <code>levelSums</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Second BFS traversal to update each node's value to the sum of its cousins:</p>
<ul>
<li>
<p>Push <code>root</code> back into the queue.</p>
</li>
<li>
<p>Set <code>root.val</code> to <code>0</code> since it has no cousins.</p>
</li>
<li>
<p>Initialize <code>levelIndex</code> to <code>1</code>.</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>Get the number of nodes at the current level (<code>levelSize</code>).</li>
<li>For each node at this level:
<ul>
<li>Pop the front node from the queue.</li>
<li>Calculate <code>siblingSum</code> by adding the values of the left and right children (if they exist).</li>
<li>If the left child exists, update its value to <code>levelSums[levelIndex] - siblingSum</code> and push it to the queue.</li>
<li>If the right child exists, update its value similarly and push it to the queue.</li>
</ul>
</li>
<li>Increment <code>levelIndex</code> after processing the current level.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the modified <code>root</code> of the tree.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/m8rZC574/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the first BFS, we traverse each node in the tree once to calculate the sum of values at each level. This requires visiting each of the <span class="math inline">\(n\)</span> nodes, leading to a time complexity of <span class="math inline">\(O(n)\)</span>. Similarly, the second BFS traverses each node to update its value based on the sums of its cousins, which also takes <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity primarily comes from the queue used in the BFS and the array that stores the level sums. The maximum size of the queue will be the maximum width of the tree, which in the worst case (for a complete binary tree) can be <span class="math inline">\(O(n)\)</span>. Additionally, the <code>levelSums</code> array will store one integer for each level of the tree. In a balanced binary tree, the height is <span class="math inline">\(O(\log n)\)</span>, leading to <span class="math inline">\(O(\log n)\)</span> levels. However, in the worst case, we can have <span class="math inline">\(O(n)\)</span> elements in <code>levelSums</code> when considering unbalanced trees (e.g., all nodes have only one child). Thus, the overall space complexity can be represented as <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pass-dfs">Approach 2: Two Pass DFS</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can apply the same approach in DFS as we did in BFS. We begin with a DFS traversal to calculate the sum of the values of all nodes at each depth level. We define an array called <code>levelSums</code>, where each index corresponds to a specific level in the tree. As we traverse, we add each node's value to the appropriate index in <code>levelSums</code>.</p>
<p>Next, we proceed with the second DFS traversal to update each node's values. In this traversal, we calculate each node's left and right children’s values, defaulting to zero if they are absent. If the node is at the root level or the first level, we set its value to zero since these nodes do not have cousins.</p>
<p>For deeper nodes, we compute their new value as the sum from <code>levelSums</code> at their level, subtracting their current value and the sum of their siblings.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Declare an array <code>levelSums</code> to store the sum of values at each level of the tree.</p>
</li>
<li>
<p>Define the <code>replaceValueInTree</code> function:</p>
<ul>
<li>Call <code>calculateLevelSum(root, 0)</code> to perform a depth-first search (DFS) and calculate the sum of values at each level.</li>
<li>Call <code>replaceValueInTreeInternal(root, 0, 0)</code> to replace each node's value with the sum of its cousins.</li>
<li>Return the modified tree root.</li>
</ul>
</li>
<li>
<p>Define the <code>calculateLevelSum</code> function:</p>
<ul>
<li>If <code>node</code> is <code>null</code>, return (base case).</li>
<li>Add the value of <code>node</code> to <code>levelSums[level]</code> (accumulate the sum at the current level).</li>
<li>Recursively call <code>calculateLevelSum</code> for the left child, increasing the level by 1.</li>
<li>Recursively call <code>calculateLevelSum</code> for the right child, increasing the level by 1.</li>
</ul>
</li>
<li>
<p>Define the <code>replaceValueInTreeInternal</code> function:</p>
<ul>
<li>
<p>If <code>node</code> is <code>null</code>, return (base case).</p>
</li>
<li>
<p>Determine the values of the left and right children:</p>
<ul>
<li>If <code>node.left</code> is <code>null</code>, set <code>leftChildVal</code> to 0; otherwise, set it to <code>node.left.val</code>.</li>
<li>If <code>node.right</code> is <code>null</code>, set <code>rightChildVal</code> to 0; otherwise, set it to <code>node.right.val</code>.</li>
</ul>
</li>
<li>
<p>For the root and its children (level 0 and level 1):</p>
<ul>
<li>Set <code>node.val</code> to 0.</li>
</ul>
</li>
<li>
<p>For other levels:</p>
<ul>
<li>Set <code>node.val</code> to <code>levelSums[level] - node.val - siblingSum</code> (sum of cousins).</li>
</ul>
</li>
<li>
<p>Recursively call <code>replaceValueInTreeInternal</code> for the left child, passing the right child's value as the sibling sum and increasing the level by 1.</p>
</li>
<li>
<p>Recursively call <code>replaceValueInTreeInternal</code> for the right child, passing the left child's value as the sibling sum and increasing the level by 1.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/g5KmjUxf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the first DFS traversal, we visit each node exactly once to compute the sum of values at each level. Thus, this part has a time complexity of <span class="math inline">\(O(n)\)</span>. In the second DFS, we again traverse each node exactly once to update the values based on the previously computed sums. Therefore, this part also has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The maximum depth of the recursion stack will be equal to the height of the tree, which is <span class="math inline">\(O(h)\)</span>. In a balanced binary tree, <span class="math inline">\(h\)</span> is <span class="math inline">\(O(\log n)\)</span>, while in the worst case (for a skewed tree), <span class="math inline">\(h\)</span> can be <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>levelSums</code> array is determined by the maximum number of levels in the tree, which can be at most <span class="math inline">\(n\)</span>. Thus, the overall space complexity can be represented as <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-single-bfs-with-running-sum">Approach 3: Single BFS with Running Sum</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can aim to reduce our two-step process into a single traversal. So the question is: can we calculate the level sums and update the nodes’ values simultaneously? With some adjustments, it’s possible. Instead of storing each level’s sum first and revisiting it later, we calculate the cousin sum as we traverse each level and apply it immediately.</p>
<p>We begin by initializing a variable called <code>currentLevelSum</code>. This variable holds the total value of all nodes at the current level. We set <code>currentLevelSum</code> to the root value value since it is the only node at level zero.</p>
<p>We traverse the tree level-by-level to visit each node and apply a formula to determine its new value. The formula is:</p>
<p><span class="math inline">\(\text{currentNode.val} = \text{currentLevelSum} - \text{siblingSum}\)</span></p>
<p>The formula subtracts the sum of each node's siblings from <code>currentLevelSum</code> to give us the sum of all other nodes at that level, which is effectively the sum of its cousins.</p>
<p>While processing each node, we also need to prepare for the next level. For each child of the current node, we calculate their contribution to the sibling sum of their level. This ensures that when we update the children's values in the next iteration, we have the correct sibling sum to use. We then add these children to a queue to process them in the next level and continue till we process the entire tree.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>If <code>root</code> is null, return <code>root</code> (base case).</p>
</li>
<li>
<p>Initialize a queue <code>nodeQueue</code> and add the <code>root</code> node to it.</p>
</li>
<li>
<p>Set <code>currentLevelSum</code> to the value of <code>root</code>.</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>
<p>Determine the number of nodes at the current level with <code>levelSize = nodeQueue.size()</code>.</p>
</li>
<li>
<p>Initialize <code>nextLevelSum</code> to <code>0</code> for accumulating the sum of the next level.</p>
</li>
<li>
<p>For each node in the current level (loop <code>levelSize</code> times):</p>
<ul>
<li>
<p>Remove the front node from the queue and assign it to <code>currentNode</code>.</p>
</li>
<li>
<p>Update <code>currentNode.val</code> to <code>currentLevelSum - currentNode.val</code> (replace its value with the cousin sum).</p>
</li>
<li>
<p>Calculate the <code>siblingSum</code> as the sum of the values of <code>currentNode</code>'s left and right children (if they exist):</p>
<ul>
<li>If <code>currentNode.left</code> is not null, add its value to <code>nextLevelSum</code> and update <code>currentNode.left.val</code> to <code>siblingSum</code>, then enqueue <code>currentNode.left</code>.</li>
<li>If <code>currentNode.right</code> is not null, add its value to <code>nextLevelSum</code> and update <code>currentNode.right.val</code> to <code>siblingSum</code>, then enqueue <code>currentNode.right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Update <code>currentLevelSum</code> to <code>nextLevelSum</code> for the next iteration.</p>
</li>
</ul>
</li>
<li>
<p>After processing all levels, return the modified <code>root</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/dnB3neCy/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse each node in the binary tree exactly once. During the traversal, we perform constant-time operations to update the node values and calculate sibling sums. Since there are <span class="math inline">\(n\)</span> nodes in total, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is primarily determined by the queue used in the BFS. In the worst case, when the tree is completely unbalanced (like a linked list), the queue can grow to hold all <span class="math inline">\(n\)</span> nodes at once, leading to a space complexity of <span class="math inline">\(O(n)\)</span>. While there are no additional data structures like arrays that grow with the number of nodes, the queue remains the primary contributor to space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/create-binary-tree-from-descriptions/description" target="_blank" rel="noopener noreferrer">Create Binary Tree From Descriptions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>descriptions</code> where <code>descriptions[i] = [parent<sub>i</sub>, child<sub>i</sub>, isLeft<sub>i</sub>]</code> indicates that <code>parent<sub>i</sub></code> is the <strong>parent</strong> of <code>child<sub>i</sub></code> in a <strong>binary</strong> tree of <strong>unique</strong> values. Furthermore,</p>

<ul>
	<li>If <code>isLeft<sub>i</sub> == 1</code>, then <code>child<sub>i</sub></code> is the left child of <code>parent<sub>i</sub></code>.</li>
	<li>If <code>isLeft<sub>i</sub> == 0</code>, then <code>child<sub>i</sub></code> is the right child of <code>parent<sub>i</sub></code>.</li>
</ul>

<p>Construct the binary tree described by <code>descriptions</code> and return <em>its <strong>root</strong></em>.</p>

<p>The test cases will be generated such that the binary tree is <strong>valid</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png" style="width: 300px; height: 236px;" />
<pre>
<strong>Input:</strong> descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
<strong>Output:</strong> [50,20,80,15,17,19]
<strong>Explanation:</strong> The root node is the node with value 50 since it has no parent.
The resulting binary tree is shown in the diagram.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png" style="width: 131px; height: 300px;" />
<pre>
<strong>Input:</strong> descriptions = [[1,2,1],[2,3,0],[3,4,1]]
<strong>Output:</strong> [1,2,null,null,3,4]
<strong>Explanation:</strong> The root node is the node with value 1 since it has no parent.
The resulting binary tree is shown in the diagram.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= descriptions.length &lt;= 10<sup>4</sup></code></li>
	<li><code>descriptions[i].length == 3</code></li>
	<li><code>1 &lt;= parent<sub>i</sub>, child<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= isLeft<sub>i</sub> &lt;= 1</code></li>
	<li>The binary tree described by <code>descriptions</code> is valid.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D integer array <code>descriptions</code>, where each element is a triplet <code>[parent_i, child_i, isLeft_i]</code>.<br />
Each triplet <code>[parent_i, child_i, isLeft_i]</code> provides specific information:</p>
<ul>
<li><code>parent_i</code> is the value of a parent node in the binary tree.</li>
<li><code>child_i</code> is the value of the child node associated with <code>parent_i</code>.</li>
<li><code>isLeft_i</code> indicates the position of <code>child_i</code> relative to <code>parent_i</code>. A value of <code>1</code> means <code>child_i</code> is the left child, and a value of <code>0</code> means <code>child_i</code> is the right child.</li>
</ul>
<p>Our task is to construct the binary tree based on the given descriptions and return the root node of this tree. It is important to note that the input <code>descriptions</code> are guaranteed to describe a valid binary tree, where each node's value is unique. This uniqueness ensures that we can confidently build the tree without conflicts in node values.</p>
<p>In a binary tree, each node can have at most two children: a left child and a right child. For any given node, we need to determine and assign its left and right children based on the provided descriptions. The <code>descriptions</code> array provides explicit instructions on how to connect parent nodes to their respective children. Knowing whether a child is a left or right child (indicated by <code>isLeft_i</code>) is crucial for placing the child in the correct position.</p>
<p>To build the tree, we can iterate through each triplet <code>[parent_i, child_i, isLeft_i]</code> from the <code>descriptions</code> array. For each triplet, we establish the parent-child relationship by creating or identifying the nodes and linking the child to the parent in the specified position (left or right).</p>
<hr />
<h3 id="approach-1-convert-to-graph-with-breadth-first-search">Approach 1: Convert to Graph with Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need a way to organize the information we're given. The <code>descriptions</code> provide parent-child relationships, but they are unordered. To address this, we begin by constructing a graph representation. Using a map to link each parent to its children, we establish a structure that facilitates quick lookup of all children associated with any node.</p>
<p>But a graph isn't enough; we must identify our starting point. In a binary tree, this starting point is the root node—the only node that is a parent but never a child. To find the root node, we track all parents and children separately. By removing all children from the set of parents, we isolate the root. This approach saves time by avoiding multiple scans through the entire list of descriptions to find the root.</p>
<p>So to construct the binary tree, we initially set up data structures to manage parent-child relationships efficiently. We utilize two sets: <code>children</code>, which stores all child nodes, and <code>parents</code>, which stores all parent nodes. Additionally, we use a map named <code>parentToChildren</code> to map each parent node to a list of its children along with their positional information (<code>isLeft_i</code>).</p>
<p>As we iterate through each description <code>[parent_i, child_i, isLeft_i]</code> in the <code>descriptions</code> array, we add each <code>parent_i</code> to the <code>parents</code> set and each <code>child_i</code> to the <code>children</code> set. We also update the <code>parentToChildren</code> map to associate each <code>parent_i</code> with its child and positional information. This mapping allows us to systematically establish the binary tree structure later.</p>
<p>Next, to determine the root of the binary tree, we identify the node in the <code>parents</code> set that does not appear in the <code>children</code> set. The node remaining in <code>parents</code> after removing all elements present in <code>children</code> represents the root of our binary tree.</p>
<p>With the root identified, we construct the binary tree using a breadth-first search (BFS). We initialize a queue with the root node. For each parent node dequeued, we create <code>TreeNode</code> objects for its children from the <code>parentToChildren</code> map, enqueue them, and link them as left or right children based on <code>isLeft_i</code>.</p>
<p>Upon completing the BFS traversal, the binary tree is fully constructed and linked according to the relationships defined in the <code>descriptions</code> array. Finally, we return the root node of the constructed binary tree.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>children</code> and <code>parents</code> as sets to track unique child and parent nodes, respectively.</p>
</li>
<li>
<p>Initialize <code>parentToChildren</code> as a map to store parent to children relationships using array of pairs.</p>
</li>
<li>
<p>Build the graph:</p>
<ul>
<li>Iterate through each <code>d</code> in <code>descriptions</code>:
<ul>
<li>Extract <code>parent</code>, <code>child</code>, and <code>isLeft</code> from <code>d</code>.</li>
<li>Add <code>parent</code> and <code>child</code> to <code>parents</code> to track all nodes.</li>
<li>Add <code>child</code> to <code>children</code>.</li>
<li>Push back the pair <code>(child, isLeft)</code> into <code>parentToChildren[parent]</code> to store child nodes and their left/right flags.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate through <code>parents</code> to find the node that is in <code>parents</code> but not in <code>children</code>, and assign it to <code>root</code>.</p>
</li>
<li>
<p>Create the root node <code>TreeNode*</code> using the first element of <code>parents</code>.</p>
</li>
<li>
<p>Construct the binary tree using BFS:</p>
<ul>
<li>Initialize a queue and push <code>root</code> into it.</li>
<li>While <code>queue</code> is not empty:
<ul>
<li>Dequeue the front <code>parent</code> node from <code>queue</code>.</li>
<li>Iterate over each <code>childInfo</code> in <code>parentToChildren[parent.val]</code>:
<ul>
<li>Extract <code>childValue</code> and <code>isLeft</code>.</li>
<li>Create a new <code>TreeNode* child</code> with <code>childValue</code>.</li>
<li>Push <code>child</code> into <code>queue</code>.</li>
<li>Attach <code>child</code> to <code>parent.left</code> or <code>parent.right</code> based on the <code>isLeft</code> flag.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the constructed <code>root</code> node of the binary tree.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cAUP2TPX/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of entries in <code>descriptions</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Building the <code>parentToChildren</code> map and the <code>children</code> and <code>parents</code> sets takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Finding the root node involves iterating through the <code>parents</code> set, which is <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Constructing the binary tree using BFS also takes <span class="math inline">\(O(n)\)</span> time since each node is processed once. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>parentToChildren</code> map can store up to <span class="math inline">\(n\)</span> entries. The <code>children</code> and <code>parents</code> sets can each store up to <span class="math inline">\(n\)</span> elements. The BFS queue can store up to <span class="math inline">\(n\)</span> nodes in the worst case. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-convert-to-graph-with-depth-first-search">Approach 2: Convert to Graph with Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The main logic frame remains the same as the BFS approach; the difference lies in how we construct it using the DFS algorithm.</p>
<p>To construct the binary tree, we initially set up data structures to manage parent-child relationships efficiently. We utilize two sets: <code>children</code>, which stores all child nodes, and <code>allNodes</code>, which stores all nodes (both parents and children). Additionally, we use a dictionary named <code>parentToChildren</code> to map each parent node to a list of its children along with their positional information (<code>isLeft</code>).</p>
<p>As we iterate through each <code>[parent, child, isLeft]</code> in <code>descriptions</code>, we populate <code>allNodes</code> with all nodes and <code>children</code> with child nodes. Using <code>parentToChildren</code>, each parent maps to a list including its child and positional info (<code>isLeft</code>), facilitating binary tree creation.</p>
<p>To determine the root of the binary tree, we identify the node in the <code>allNodes</code> set that does not appear in the <code>children</code> set. This node remains in the <code>allNodes</code> set after removing all elements also present in <code>children</code> and represents the root of our binary tree.</p>
<p>With the root identified, we construct the binary tree using a depth-first search (DFS). The <code>dfs</code> function recursively creates <code>TreeNode</code> instances for each node value. If a node has children in <code>parentToChildren</code>, <code>dfs</code> iterates through them, attaching each subtree based on <code>isLeft</code>. Finally, <code>dfs</code> returns the fully constructed subtree rooted at the current node.</p>
<p>We start the whole process by calling a depth-first search on the root value we identified. This initiates the recursive construction of the entire tree.</p>
<p>The DFS approach naturally follows the structure of the tree, building each branch completely before moving to the next. This method is particularly efficient for deep trees, as it doesn't need to store information about all nodes at one level before proceeding to the next (unlike BFS).</p>
<p>Upon completing the DFS traversal, the binary tree is fully constructed and linked according to the relationships defined in the <code>descriptions</code> array. Finally, we return the root node of the constructed binary tree.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>parentToChildren</code> as a map to store parent-child relationships using lists of integer arrays.</p>
</li>
<li>
<p>Initialize <code>allNodes</code> as a set to track all node values and <code>children</code> as another <code>HashSet</code> to track child nodes.</p>
</li>
<li>
<p>Iterate through each <code>desc</code> in <code>descriptions</code>:</p>
<ul>
<li>Extract <code>parent</code>, <code>child</code>, and <code>isLeft</code> from <code>desc</code>.</li>
<li>If <code>parent</code> is not already in <code>parentToChildren</code>, initialize it with an empty list.</li>
<li>Add the pair <code>(child, isLeft)</code> to <code>parentToChildren[parent]</code>.</li>
<li>Add both <code>parent</code> and <code>child</code> to the <code>allNodes</code> set.</li>
<li>Add <code>child</code> to the <code>children</code> set.</li>
</ul>
</li>
<li>
<p>Find the root node value (<code>rootVal</code>):</p>
<ul>
<li>Iterate through <code>allNodes</code>:
<ul>
<li>If a node is not in the <code>children</code> set, assign it to <code>rootVal</code> and break out of the loop.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Call <code>dfs(parentToChildren, rootVal)</code> to recursively construct the binary tree.</p>
</li>
</ul>
<p>Helper method <code>dfs</code> with parameters: <code>parentToChildren</code>, <code>val</code>:</p>
<ul>
<li>
<p>Create a new <code>TreeNode</code> for <code>val</code>.</p>
</li>
<li>
<p>If <code>val</code> has children:</p>
<ul>
<li>Iterate through each <code>childInfo</code> in <code>parentToChildren.get(val)</code>:
<ul>
<li>Extract <code>child</code> and <code>isLeft</code>.</li>
<li>If <code>isLeft</code> is <code>1</code>, recursively call <code>dfs</code> to attach <code>child</code> as the left child of <code>node</code>.</li>
<li>Otherwise, attach <code>child</code> as the right child of <code>node</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the root node of the constructed binary tree.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7c2h3pfA/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of entries in <code>descriptions</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Building the <code>parentToChildren</code> map and the <code>allNodes</code> and <code>children</code> sets takes <span class="math inline">\(O(n)\)</span> time. Finding the root node involves iterating through the <code>allNodes</code> set, which is <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Constructing the binary tree using DFS also takes <span class="math inline">\(O(n)\)</span> time since each node is processed once. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>parentToChildren</code> map can store up to <span class="math inline">\(n\)</span> entries. The <code>allNodes</code> and <code>children</code> sets can each store up to <span class="math inline">\(n\)</span> elements. The recursive DFS stack can store up to <span class="math inline">\(n\)</span> nodes in the worst case. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-constructing-tree-from-directly-map-and-treenode-object">Approach 3: Constructing Tree From Directly Map and TreeNode Object</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While the DFS solution effectively built the tree through recursive traversal, it required multiple data structures and a separate step to identify the root. To build the binary tree efficiently, we need a way to quickly access any node by its value. Trees are not inherently sequential structures, making navigation and referencing more complex. Using a map to associate each node value with its corresponding <code>TreeNode</code> object solves this problem, providing instant access to any node.</p>
<p>This map serves a dual purpose: it not only provides <span class="math inline">\(O(1)\)</span> access to any node but also eliminates the need for separate parent and child tracking sets used in our previous approach, thus significantly reducing the algorithm's time and space complexity.</p>
<p>The first step involves creating this map to link each node's value to its <code>TreeNode</code> object. As we iterate through each description <code>[parent_i, child_i, isLeft_i]</code>, we need to check if the parent and child nodes already exist in the map. If they do not, we create them and store them in the map.</p>
<p>Next, based on the <code>isLeft_i</code> value, we link the parent node to the child node by setting either the left or right pointer of the parent's <code>TreeNode</code> object to the child's <code>TreeNode</code> object. This way we can establish the left and right child relationships as described by the input.</p>
<p>While setting up these relationships, we also maintain a set (say <code>children</code>) to keep track of all nodes that have been assigned as a child to some parent node. This set is crucial for identifying the root node later because the root will not be a child of any node.</p>
<p>Finally, once all descriptions are processed, we iterate through the nodes in the map. For each node, we check if it is not present in the <code>children</code> set. The node not present in the <code>children</code> set is the one which has never been assigned as a child, indicating that it is the root of the tree. We return this root node.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2196/approach3.json:975,550!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>nodeMap</code> to map node values to <code>TreeNode</code> pointers.</p>
</li>
<li>
<p>Initialize <code>children</code> set to track child nodes from descriptions.</p>
</li>
<li>
<p>Iterate through each <code>description</code> in <code>descriptions</code>:</p>
<ul>
<li>Extract <code>parentValue</code>, <code>childValue</code>, and <code>isLeft</code> (boolean indicating if it's a left child).</li>
<li>Create <code>TreeNode</code> objects for <code>parentValue</code> and <code>childValue</code> if not already in <code>nodeMap</code>.</li>
<li>Attach <code>childValue</code> as left or right child to <code>parentValue</code> based on <code>isLeft</code>.</li>
<li>Add <code>childValue</code> to <code>children</code> set.</li>
</ul>
</li>
<li>
<p>Iterate through <code>nodeMap</code> to find the root node:</p>
<ul>
<li>Check each node:
<ul>
<li>If node's value is not in <code>children</code>, return it as the root node.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the identified root node of the binary tree.</p>
</li>
<li>
<p>If no root node is found (should not occur per problem statement), return <code>nullptr</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/bhW8Q2j4/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes created in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through each description exactly once, and for each description, it performs constant-time operations:</p>
<ul>
<li>Checking and adding nodes to <code>nodeMap</code>.</li>
<li>Updating node connections (<code>left</code> or <code>right</code> child assignments).</li>
<li>Adding child values to the <code>children</code> set.</li>
</ul>
<p>The final loop iterates through the <code>nodeMap</code>, which contains all created nodes, to find the root node. The loop's runtime is linear in relation to the number of nodes created, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses <code>nodeMap</code> to store references to all created nodes. In the worst case, this map contains all nodes, so it takes up <span class="math inline">\(O(n)\)</span> space. The <code>children</code> set also takes <span class="math inline">\(O(n)\)</span> space to store child values.</p>
<p>Additional space is used for the <code>TreeNode</code> objects themselves, but that's accounted for within the <span class="math inline">\(O(n)\)</span> space complexity due to the nodes being stored in <code>nodeMap</code>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cycle-length-queries-in-a-tree/description" target="_blank" rel="noopener noreferrer">Cycle Length Queries in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. There is a <strong>complete binary tree</strong> with <code>2<sup>n</sup> - 1</code> nodes. The root of that tree is the node with the value <code>1</code>, and every node with a value <code>val</code> in the range <code>[1, 2<sup>n - 1</sup> - 1]</code> has two children where:</p>

<ul>
	<li>The left node has the value <code>2 * val</code>, and</li>
	<li>The right node has the value <code>2 * val + 1</code>.</li>
</ul>

<p>You are also given a 2D integer array <code>queries</code> of length <code>m</code>, where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. For each query, solve the following problem:</p>

<ol>
	<li>Add an edge between the nodes with values <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</li>
	<li>Find the length of the cycle in the graph.</li>
	<li>Remove the added edge between nodes with values <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</li>
</ol>

<p><strong>Note</strong> that:</p>

<ul>
	<li>A <strong>cycle</strong> is a path that starts and ends at the same node, and each edge in the path is visited only once.</li>
	<li>The length of a cycle is the number of edges visited in the cycle.</li>
	<li>There could be multiple edges between two nodes in the tree after adding the edge of the query.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>m</code><em> where</em> <code>answer[i]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/25/bexample1.png" style="width: 647px; height: 128px;" />
<pre>
<strong>Input:</strong> n = 3, queries = [[5,3],[4,7],[2,3]]
<strong>Output:</strong> [4,5,3]
<strong>Explanation:</strong> The diagrams above show the tree of 2<sup>3</sup> - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.
- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.
- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/25/aexample2.png" style="width: 146px; height: 71px;" />
<pre>
<strong>Input:</strong> n = 2, queries = [[1,2]]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The diagram above shows the tree of 2<sup>2</sup> - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.
- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= 2<sup>n</sup> - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/deepest-leaves-sum/description" target="_blank" rel="noopener noreferrer">Deepest Leaves Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given the <code>root</code> of a binary tree, return <em>the sum of values of its deepest leaves</em>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png" style="width: 273px; height: 265px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
<strong>Output:</strong> 15
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
<strong>Output:</strong> 19
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-leaves-with-a-given-value/description" target="_blank" rel="noopener noreferrer">Delete Leaves With a Given Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree <code>root</code> and an integer <code>target</code>, delete all the <strong>leaf nodes</strong> with value <code>target</code>.</p>

<p>Note that once you delete a leaf node with value <code>target</code><strong>, </strong>if its parent node becomes a leaf node and has the value <code>target</code>, it should also be deleted (you need to continue doing that until you cannot).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/09/sample_1_1684.png" style="width: 500px; height: 112px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [1,2,3,2,null,2,4], target = 2
<strong>Output:</strong> [1,null,3,null,4]
<strong>Explanation:</strong> Leaf nodes in green with value (target = 2) are removed (Picture in left). 
After removing, new nodes become leaf nodes with value (target = 2) (Picture in center).
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/09/sample_2_1684.png" style="width: 400px; height: 154px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [1,3,3,3,2], target = 3
<strong>Output:</strong> [1,3,null,null,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/01/15/sample_3_1684.png" style="width: 500px; height: 166px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [1,2,null,2,null,2], target = 2
<strong>Output:</strong> [1]
<strong>Explanation:</strong> Leaf nodes in green with value (target = 2) are removed at each step.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 3000]</code>.</li>
	<li><code>1 &lt;= Node.val, target &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree <code>root</code> and an integer <code>target</code>. Our objective is to delete all the leaf nodes of the binary tree with the value <code>target</code>.</p>
<blockquote>
<p>Note: Leaf nodes are the nodes in the tree that do not have children.</p>
</blockquote>
<p><strong>Key Observations:</strong></p>
<ol>
<li>While deleting nodes, it's important to maintain the structure of the binary tree. Deleting a leaf node may require updating its parent's pointer to null, potentially affecting the entire structure of the tree.</li>
<li>Deleting a leaf node will alter the binary tree, potentially causing the parent node to become a leaf node.</li>
</ol>
<hr />
<h3 id="approach-1-recursion-postorder-traversal">Approach 1: Recursion (Postorder Traversal)</h3>
<h4 id="intuition">Intuition</h4>
<p>Since deleting a child node might transform a parent node into a new leaf node, we should start checking and removing qualifying leaf nodes from the bottom of the tree. We will examine each level as we ascend the tree to ensure we identify all nodes requiring removal. This process of checking from the bottom to the top sets our traversal order.</p>
<p>Postorder traversal efficiently deletes targeted nodes in a binary tree by starting at the deepest leaves and moving upward. This ensures that each node is assessed for deletion only after its descendants, recursively capturing any new leaf nodes created by prior deletions. The process continues until the entire tree is covered, systematically eliminating all nodes with the target value.</p>
<p>The following is an illustration demonstrating the postorder traversal approach:</p>
<p>!?!../Documents/1325/slideshow.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Base Case: If <code>root</code> is <code>null</code>, return <code>null</code>, to handle the conditions of an empty tree or traversing beyond the leaf nodes.</li>
<li>Recursive Traversal: Perform a postorder traversal to ensure that we process all descendant nodes before the current node (<code>root</code>):
<ul>
<li>Recursively call <code>removeLeafNodes</code> for the left child of the <code>root</code> and update the left child with the return value.</li>
<li>Similarly, recursively call <code>removeLeafNodes</code> for the right child of <code>root</code> and update the right child with the return value.</li>
</ul>
</li>
<li>Node Evaluation:
<ul>
<li>Check if the current <code>root</code> node is a leaf node and if its value equals the <code>target</code>. If both conditions are satisfied, return <code>null</code> to effectively delete the node by not reconnecting it to its parent.</li>
<li>If the node is neither a leaf nor matches <code>target</code>, return the <code>root</code> itself.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Wk6ubdQn/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We recursively visit each node of the binary tree exactly once, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>At each node, operations such as checking if the node is a leaf, verifying if its value matches the target, and potentially setting the node to <code>null</code> are executed in constant time.</p>
<p>Since each node in the tree is visited exactly once, and a constant amount of work is done per node, the overall time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>For each recursive call to the <code>removeLeafNodes</code> function, a frame is allocated on the call stack. This frame is used to store function parameters, local variables, and the return address.</p>
<p>The maximum number of frames on the call stack depends on the height of the binary tree. The height of a binary tree is defined as the maximum distance from the root to any leaf node.</p>
<p>In an unbalanced tree, such as a linear tree where each node has only one child, the height of the tree is equal to the number of nodes, denoted as <span class="math inline">\(n\)</span>. Consequently, the call stack may grow to a depth of <span class="math inline">\(n\)</span> frames, leading to a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Beyond the recursive call stack, the algorithm uses a constant amount of auxiliary space for local variables, adding an extra space complexity of <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-postorder-traversal">Approach 2: Iterative (PostOrder Traversal)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we traversed the nodes of the binary tree <code>root</code> recursively using the postorder traversal algorithm. Alternatively, we can use an iterative approach. While the recursive approach is simpler to implement, understanding the iterative method is advantageous, as it avoids the need for numerous recursive function calls.</p>
<p>Notice that we need a data structure to keep track of the nodes encountered on our path to the leaf nodes. This is essential because in the postorder traversal algorithm, we must visit the children before visiting the parents.</p>
<p>The stack's LIFO property makes it a suitable choice for this task. Nodes encountered earlier can be stored on the stack and later accessed as we ascend from leaf nodes toward the root during processing.</p>
<p>We can leverage the stack by continuously pushing the leftmost nodes of the tree onto it. Once a node with no left child is encountered, we then explore any right children, pushing these onto the stack as well. This method ensures that we visit all child nodes before their parent node, aligning with the requirements of postorder traversal.</p>
<p>The stack's role is to store nodes during the exploration of their subtrees to the left and right, facilitating revisiting as we ascend towards the <code>root</code>.</p>
<p>To prevent revisiting right subtrees and potentially causing infinite loops, we use a variable to track whether a right subtree has been recently visited. This check is performed before moving to a right child and prevents re-entry into subtrees that have already been processed.</p>
<p>When revisiting a node from the stack, we can be certain that both its left and right subtrees have been fully explored. If, at this point, the node is a leaf and its value matches the target, it is removed by updating the parent's reference to it to nullptr. We can access the parent of any current node immediately by querying the top of the stack at that instant.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>stack</code> to hold nodes during traversal.</li>
<li>Set <code>currentNode</code> to <code>root</code> to start traversal from the <code>root</code>.</li>
<li>Use <code>lastRightNode</code> as a marker to remember the last right subtree visited to avoid revisiting and potential infinite loops.</li>
<li>Continuously push the left children of <code>currentNode</code> onto the <code>stack</code> until a <code>null</code> is reached, ensuring that the traversal reaches the leftmost node first.</li>
<li>At each node, after popping from the stack, check if there is an unexplored right subtree that has not been recently visited, using <code>lastRightNode</code> for comparison. If there is, move to the right subtree and repeat the left push process for this subtree.</li>
<li>After ensuring no unexplored right subtrees are left, consider the current node for removal:</li>
<li>Determine if the current node is a leaf and check if the leaf node's value equals <code>target</code>.
<ul>
<li>If both conditions are met, disconnect the node from the tree by updating its parent's child reference to <code>null</code>:
<ul>
<li>If <code>stack</code> is empty, it means <code>root</code> itself is a target leaf node. Return <code>null</code> to indicate the entire tree should be removed.</li>
<li>Otherwise, identify the parent of <code>currentNode</code> (the next node in the stack) and set the appropriate child reference (left or right) to <code>null</code> to disconnect the leaf.</li>
</ul>
</li>
</ul>
</li>
<li>Continue the loop until both <code>stack</code> is empty and <code>currentNode</code> is <code>null</code>, which indicates that all nodes have been processed.</li>
<li>Finally, return <code>root</code>, representing the modified tree with the target leaves removed.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QJ7ZvGXX/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each of the above operations—such as pushing, popping, checking node conditions, updating references, and managing the <code>prev</code> variable—is executed at a constant time for each node.</p>
<p>Since every node in the tree undergoes these operations exactly once, the dominant factor in the time complexity is the number of nodes <span class="math inline">\(n\)</span>. Therefore, the combined time complexity of all these operations is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The stack is used to simulate the depth-first traversal of the tree, specifically mimicking a postorder traversal in this case.</p>
<p>A few auxiliary variables (such as <code>cur</code>, <code>prev</code>, and <code>parent</code>) are used, but they occupy constant space, <span class="math inline">\(O(1)\)</span>.</p>
<p>In an unbalanced tree, like a skewed tree where each node has only one child, the height of the tree equals the number of nodes, denoted as <span class="math inline">\(n\)</span>. Therefore, the call stack may grow to a depth of <span class="math inline">\(n\)</span> frames, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-node-in-a-bst/description" target="_blank" rel="noopener noreferrer">Delete Node in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>

<p>Basically, the deletion can be divided into two stages:</p>

<ol>
	<li>Search for a node to remove.</li>
	<li>If the node is found, delete the node.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" style="width: 800px; height: 214px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3
<strong>Output:</strong> [5,4,6,2,null,null,7]
<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s also accepted.
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" style="width: 350px; height: 255px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0
<strong>Output:</strong> [5,3,6,2,4,null,7]
<strong>Explanation:</strong> The tree does not contain a node with value = 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [], key = 0
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>Each node has a <strong>unique</strong> value.</li>
	<li><code>root</code> is a valid binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve it with time complexity <code>O(height of tree)</code>?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-nodes-and-return-forest/description" target="_blank" rel="noopener noreferrer">Delete Nodes And Return Forest</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.</p>

<p>After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).</p>

<p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png" style="width: 237px; height: 150px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7], to_delete = [3,5]
<strong>Output:</strong> [[1,2,null,4],[6],[7]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2,4,null,3], to_delete = [3]
<strong>Output:</strong> [[1,2,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the given tree is at most <code>1000</code>.</li>
	<li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li>
	<li><code>to_delete.length &lt;= 1000</code></li>
	<li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree <code>root</code> where each node has a unique value, and an array <code>to_delete</code> containing values of nodes to delete. The goal is to delete all nodes with values in <code>to_delete</code> and return all the remaining root nodes.</p>
<blockquote>
<p>Note: As a reminder, a root node is a node that does not have a parent.</p>
</blockquote>
<p>Handling the children first prevents premature removal of nodes and ensures that all nodes are correctly added to the forest. This principle is crucial to solving the problem effectively.</p>
<p>!?!../Documents/1110/slideshow.json:960,540!?!</p>
<p>To optimize lookup time for deletions, <code>to_delete</code> is converted into a set. Using a set allows constant time <span class="math inline">\(O(1)\)</span> checks to determine if a node should be deleted, which is more efficient compared to linear time array lookups.</p>
<hr />
<h3 id="approach-1-recursion-postorder-traversal">Approach 1: Recursion (Postorder Traversal)</h3>
<h4 id="intuition">Intuition</h4>
<p>We mentioned the need to process each node's children before the node itself. One traversal method that aligns with this requirement is postorder traversal. In postorder traversal, we visit the left child, then the right child, and finally the parent node. This sequence ensures that by the time we reach a node, its entire subtree has already been processed, allowing us to safely delete the node if necessary.</p>
<p>In contrast, preorder and inorder traversals do not meet this requirement. In preorder traversal, we visit the parent node before its children, risking deletion of a node before its children are handled, potentially losing subtrees. In inorder traversal, we first visit the left child, then the parent node, and finally the right child, partially processing the subtree before addressing the parent node, which can lead to incomplete handling of nodes and subtree loss.</p>
<p>To solve this problem, we recursively traverse each node's left and right children before processing the node itself. If the current node needs deletion, we check its children. If they are not null, we add them to the forest as new roots. Finally, we delete the current node by returning null to its parent.</p>
<p>Special handling is required for the root node. After processing the entire tree, if the root is not null and hasn't been deleted, it should be added to the forest as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialization:</p>
<ul>
<li>Convert the <code>to_delete</code> array to a set for efficient lookups and store it as <code>toDeleteSet</code>.</li>
<li>Create an empty list <code>forest</code> to store the roots of the resulting forest.</li>
</ul>
</li>
<li>
<p>Recursive Traversal: Perform a postorder traversal to ensure that we process all descendant nodes before the current node (<code>node</code>):</p>
<ul>
<li>Recursively call <code>processNode</code> for the left child of <code>node</code> and update the left child with the return value.</li>
<li>Similarly, recursively call <code>processNode</code> for the right child of <code>node</code> and update the right child with the return value.</li>
</ul>
</li>
<li>
<p>Node Evaluation:</p>
<ul>
<li>Check if the current <code>node</code> needs to be deleted by checking if its value exists in the <code>toDeleteSet</code>. If the node needs to be deleted:
<ul>
<li>If <code>node</code> has a left child that is not <code>null</code>, add the left child to the <code>forest</code>.</li>
<li>If <code>node</code> has a right child that is not <code>null</code>, add the right child to the <code>forest</code>.</li>
<li>Delete the current <code>node</code> and return <code>null</code> to effectively remove the node by not reconnecting it to its parent.</li>
</ul>
</li>
<li>If the node is not to be deleted, return the <code>node</code> itself.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JJn3hfWR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> denote the number of nodes in the binary tree <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Recursive traversal of each node in the binary tree takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Initializing and converting the <code>to_delete</code> list into a set takes <span class="math inline">\(O(m)\)</span> time, where <span class="math inline">\(m\)</span> is the number of elements in <code>to_delete</code>. Since <span class="math inline">\(m \leq n\)</span>, this operation is bounded by <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>processNode</code> function recursively visits each node exactly once. Operations such as checking if the node's value is in <code>toDeleteSet</code>, adding the node's children to <code>forest</code> if it's to be deleted, and deleting the node are constant time operations, <span class="math inline">\(O(1)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Each recursive call to <code>processNode</code> allocates a stack frame. In the worst-case scenario of an unbalanced tree, the maximum number of stack frames could be <span class="math inline">\(n\)</span>, leading to <span class="math inline">\(O(n)\)</span> space complexity due to the call stack.</p>
<p>The <code>toDeleteSet</code> uses <span class="math inline">\(O(m)\)</span> space, where <span class="math inline">\(m\)</span> is the number of elements in <code>to_delete</code>. Since <span class="math inline">\(m \leq n\)</span>, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>forest</code> list could potentially store up to <span class="math inline">\(n\)</span> nodes if each deleted node becomes a separate tree, resulting in <span class="math inline">\(O(n)\)</span> space.</p>
<p>Apart from these data structures, the algorithm uses a constant amount of space for local variables, contributing <span class="math inline">\(O(1)\)</span> additional space complexity.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bfs-forest-formation">Approach 2: BFS Forest Formation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we recursively traversed the nodes of the binary tree <code>root</code> using the postorder traversal algorithm. An alternative is applying an iterative approach, using a queue for breadth-first search (BFS). This allows us to process each node level by level. Starting with the root node in the queue, we handle each node and its children iteratively, disconnecting nodes marked for deletion and adding any remaining nodes to the forest.</p>
<p>BFS explores all nodes at the current depth before progressing to nodes at deeper levels. We use a queue for BFS to manage traversal order, ensuring nodes are visited level by level.</p>
<p>Starting BFS with the root node, we systematically process the tree from the top down. As each node is processed, we assess if it needs deletion. If so, we disconnect it from its parent and potentially treat its children as new roots for the forest by enqueuing them.</p>
<p>We have to make sure we are not losing any nodes in the subtree while disconnecting a node, by pushing its children to the queue before deleting that node. This way, the children can be handled as potential new roots for the forest.</p>
<p>If a node's children need to be deleted, we disconnect them as well. Finally, after processing all nodes, we check the root node separately. If the root was not deleted, we will add it to the forest as well.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Check if the root is null. If so, return an empty list.</li>
<li>Create an unordered set <code>toDeleteSet</code> from the <code>to_delete</code> list for efficient lookup.</li>
<li>Initialize an empty list <code>forest</code> to store the roots of the resulting trees.</li>
<li>Create a queue <code>nodesQueue</code> and push the root node into it.</li>
<li>While the queue is not empty:<br />
a. Dequeue the front node as <code>currentNode</code>.<br />
b. If <code>currentNode</code> has a left child:
<ul>
<li>Push the left child to the queue.</li>
<li>If the left child's value is in <code>toDeleteSet</code>, set <code>currentNode-&gt;left</code> to null.<br />
c. If <code>currentNode</code> has a right child:</li>
<li>Push the right child to the queue.</li>
<li>If the right child's value is in <code>toDeleteSet</code>, set <code>currentNode-&gt;right</code> to null.<br />
d. If <code>currentNode</code>'s value is in <code>toDeleteSet</code>:</li>
<li>If <code>currentNode</code> has a non-null left child, add it to <code>forest</code>.</li>
<li>If <code>currentNode</code> has a non-null right child, add it to <code>forest</code>.</li>
</ul>
</li>
<li>After processing all nodes, check if the root's value is not in <code>toDeleteSet</code>:
<ul>
<li>If true, add the root to <code>forest</code>.</li>
</ul>
</li>
<li>Return the <code>forest</code> list containing the roots of the resulting trees.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/X3L8prPo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We visit each node of the binary tree exactly once using a BFS traversal, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The set initialization, converting the <code>to_delete</code> list to a set, takes <span class="math inline">\(O(m)\)</span> time, where <span class="math inline">\(m\)</span> is the number of elements in <code>to_delete</code>. Since <span class="math inline">\(m \leq n\)</span>, this operation is bounded by <span class="math inline">\(O(n)\)</span>.</p>
<p>During the BFS traversal, operations such as checking if a node's value is in the <code>toDeleteSet</code>, adding the node's children to the <code>forest</code> if the node is to be deleted, and disconnecting child nodes are performed in constant time, <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of the queue used for BFS is <span class="math inline">\(O(n)\)</span> in the worst case, where all nodes are stored in the queue simultaneously.</p>
<p>The <code>toDeleteSet</code> uses <span class="math inline">\(O(m)\)</span> space, where <span class="math inline">\(m\)</span> is the number of elements in <code>to_delete</code>. Since <span class="math inline">\(m \leq n\)</span>, this is bounded by <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>forest</code> list could store up to <span class="math inline">\(n\)</span> nodes in the worst case where each node becomes a separate tree, resulting in <span class="math inline">\(O(n)\)</span> space.</p>
<p>Beyond the queue, the <code>toDeleteSet</code>, and the <code>forest</code> list, the algorithm uses a constant amount of auxiliary space for local variables, adding an extra space complexity of <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/diameter-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Diameter of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p>

<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>

<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" style="width: 292px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/distribute-coins-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Distribute Coins in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <code>n</code> nodes where each <code>node</code> in the tree has <code>node.val</code> coins. There are <code>n</code> coins in total throughout the whole tree.</p>

<p>In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.</p>

<p>Return <em>the <strong>minimum</strong> number of moves required to make every node have <strong>exactly</strong> one coin</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" style="width: 250px; height: 236px;" />
<pre>
<strong>Input:</strong> root = [3,0,0]
<strong>Output:</strong> 2
<strong>Explanation: </strong>From the root of the tree, we move one coin to its left child, and one coin to its right child.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" style="width: 250px; height: 236px;" />
<pre>
<strong>Input:</strong> root = [0,3,0]
<strong>Output:</strong> 3
<strong>Explanation: </strong>From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= Node.val &lt;= n</code></li>
	<li>The sum of all <code>Node.val</code> is <code>n</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the <code>root</code> of a binary tree storing coins, our objective is to determine the minimum number of moves required to distribute the coins so that each node has exactly one coin. A move consists of moving one coin from a node to an adjacent node.</p>
<p>We will need to traverse the tree to distribute the coins.</p>
<blockquote>
<p>If you are not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">Tree Traversal Explore Card</a></p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to ensure each node contains one coin. Let's start with an example. How do we obtain a coin for the root node?</p>
<blockquote>
<p><strong>Input</strong> [0,0,2,4,0,1,0]</p>
</blockquote>
<p><img src="../Figures/979/ExampleA.png" alt="Example A" /></p>
<p>We could give the blue <code>root</code> node a coin from its red right child. However, this is not an optimal move, as then, a coin from the leftmost node in the tree with four coins must be passed to the red node's child that has zero coins.</p>
<p>From the <code>root</code>, it's hard to determine how to optimally distribute the coins because we don't have enough information about the subtrees.</p>
<p>What if we started distributing coins from the leaves?</p>
<p><img src="../Figures/979/ExampleB.png" alt="Example B" /></p>
<p>If we represent extra coins as positive values and needed coins as negative values we can calculate the coins exchanged in the subtree rooted at the red node as follows:</p>
<pre><code>current.val = current.val + leftCoins + rightCoins = 0 + 3 + -1 = 2
</code></pre>
<p><code>current</code> is the red parent node in the subtree, and <code>leftCoins</code> and <code>rightCoins</code> are the number of coins the children need to exchange.</p>
<p>There are three cases for distributing coins from a leaf node:</p>
<ol>
<li>The leaf node doesn't have any coins: Take a coin from the parent, since the parent is the only node it is connected to.</li>
<li>The leaf node has exactly one coin: No coins need to be exchanged.</li>
<li>The leaf node has more than one coin: Keep one coin and give all the extra coins to the parent.</li>
</ol>
<p>From a leaf node, we can directly determine how to optimally distribute coins in the subtree because the only neighbor a leaf can exchange with is their parent.</p>
<p>How will we traverse the tree so that we handle child nodes before parent nodes? One of the primary ways to traverse a tree is a Depth-First Search (DFS). There are three main traversal types for DFS, one of which is a postorder traversal. In a postorder traversal, the left subtree is visited first, then the right, then the root.</p>
<p><strong>Recursive DFS Postorder Traversal Template:</strong></p>
<ul>
<li>If the tree is empty, return.</li>
<li>Traverse the left subtree: <code>dfs(root.left)</code>.</li>
<li>Traverse the right subtree: <code>dfs(root.right)</code>.</li>
<li>Handle the root.</li>
</ul>
<p>Moving up the tree, how many coins can the current node pass on to its parent?</p>
<p><img src="../Figures/979/ExampleC.png" alt="Example C" /></p>
<p>The current node will keep one of its coins, so it will pass on one less than the number of coins it has. This means if it has only one coin, it won't pass on any coins.</p>
<p>The best practice is not to modify the input, so instead of manipulating the node's value, we will pass along the number of coins exchanged.</p>
<p><img src="../Figures/979/ExampleD.png" alt="Example D" /></p>
<p>We can calculate the number of coins a parent node can pass on to its parent by subtracting one from its value to represent the coin it keeps, then adding the number of coins its left and right subtrees need to exchange.</p>
<p>To calculate the number of coins each subtree needs to exchange, we implement a recursive function, <code>dfs</code>, using the postorder traversal template.</p>
<p><strong>dfs:</strong></p>
<ul>
<li>If the tree is empty, return <code>0</code>.</li>
<li>Calculate the number of coins the left subtree needs to exchange: <code>leftCoins = dfs(root.left)</code>.</li>
<li>Calculate the number of coins the right subtree needs to exchange: <code>rightCoins = dfs(root.right)</code>.</li>
<li>Return the number of coins the current node has available to exchange with its parent: <code>(current.val - 1) + leftCoins + rightCoins</code>.</li>
</ul>
<p>This function would calculate the number of coins each node needs to exchange with its parent. This is not the number of moves, but we can calculate the number of moves in the same function.</p>
<p><img src="../Figures/979/ExampleE.png" alt="Example E" /></p>
<p>For the green highlighted subtree, it takes three moves to give each extra coin from the left child to the parent and one move to give one coin from the parent to the right child. In total, four coin exchanges occurred, requiring four moves. We calculate the number of moves by adding the absolute values of the number of coins each child needs to exchange with its parent node.</p>
<p>In the <code>dfs</code> function, we add the number of moves it takes to distribute coins within the current subtree to a globally maintained running sum before handling the root.</p>
<p>How do we know this process provides the minimum number of moves? Each child node either gives coins to or receives coins from its parent, but not both. Each node exchanges coins with its direct neighbors in a unidirectional flow, minimizing the total number of moves.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a variable <code>moves</code> to <code>0</code>.</li>
<li>Define a recursive function <code>dfs</code> that counts the number of moves needed to distribute the coins in the tree given the root as <code>current</code>.
<ul>
<li>Base case: If <code>current</code> is <code>null</code>, return <code>0</code> because no coins need to be exchanged.</li>
<li>Set a variable <code>leftCoins</code> to the number of coins the left subtree needs to exchange, the result of <code>dfs(current.left)</code>.</li>
<li>Set a variable <code>rightCoins</code> to the number of coins the right subtree needs to exchange, the result of <code>dfs(current.right)</code>.</li>
<li>Calculate the number of moves needed to distribute coins in each of the subtrees. Since the coins exchanged may be negative, we sum the absolute values of <code>leftCoins</code> and <code>rightCoins</code> and then add this sum to <code>moves</code>.</li>
<li>Return the number of coins the <code>current</code> node has available to exchange with its parent. It will keep one coin, so subtract <code>1</code> from its value and sum the result with <code>leftCoins</code> and <code>rightCoins</code>.</li>
</ul>
</li>
<li>Call <code>dfs(current)</code>.</li>
<li>Return <code>moves</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/979/979_slideshow1.json:650,460!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/BBNKWdf9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree using DFS costs <span class="math inline">\(O(n)\)</span>, as we visit each node exactly once and perform <span class="math inline">\(O(1)\)</span> of work at each visit.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS, when implemented recursively, is determined by the maximum depth of the call stack, which corresponds to the depth of the tree. In the worst case, if the tree is entirely unbalanced (e.g., a linked list or a left/right skewed tree), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/evaluate-boolean-binary-tree/description" target="_blank" rel="noopener noreferrer">Evaluate Boolean Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>full binary tree</strong> with the following properties:</p>

<ul>
	<li><strong>Leaf nodes</strong> have either the value <code>0</code> or <code>1</code>, where <code>0</code> represents <code>False</code> and <code>1</code> represents <code>True</code>.</li>
	<li><strong>Non-leaf nodes</strong> have either the value <code>2</code> or <code>3</code>, where <code>2</code> represents the boolean <code>OR</code> and <code>3</code> represents the boolean <code>AND</code>.</li>
</ul>

<p>The <strong>evaluation</strong> of a node is as follows:</p>

<ul>
	<li>If the node is a leaf node, the evaluation is the <strong>value</strong> of the node, i.e. <code>True</code> or <code>False</code>.</li>
	<li>Otherwise, <strong>evaluate</strong> the node&#39;s two children and <strong>apply</strong> the boolean operation of its value with the children&#39;s evaluations.</li>
</ul>

<p>Return<em> the boolean result of <strong>evaluating</strong> the </em><code>root</code><em> node.</em></p>

<p>A <strong>full binary tree</strong> is a binary tree where each node has either <code>0</code> or <code>2</code> children.</p>

<p>A <strong>leaf node</strong> is a node that has zero children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png" style="width: 700px; height: 252px;" />
<pre>
<strong>Input:</strong> root = [2,1,3,null,null,0,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram illustrates the evaluation process.
The AND node evaluates to False AND True = False.
The OR node evaluates to True OR False = True.
The root node evaluates to True, so we return true.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> false
<strong>Explanation:</strong> The root node is a leaf node and it evaluates to false, so we return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 3</code></li>
	<li>Every node has either <code>0</code> or <code>2</code> children.</li>
	<li>Leaf nodes have a value of <code>0</code> or <code>1</code>.</li>
	<li>Non-leaf nodes have a value of <code>2</code> or <code>3</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a full binary tree where the leaf nodes store boolean values (<code>True</code> or <code>False</code>), and non-leaf nodes store boolean operations (<strong>AND</strong> or <strong>OR</strong>). Our task is to return the evaluation result of the root node.</p>
<p>The evaluation result of any leaf node is given by its stored boolean value, while for a non-leaf node, the evaluation result is determined by applying the boolean operation stored in the node to the evaluations of its children.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The given tree is a full binary tree. This implies that there will be no nodes in the tree with exactly one child node.</li>
<li>Leaf nodes have either the value <code>0</code> or <code>1</code>, where <code>0</code> represents <code>False</code> and <code>1</code> represents <code>True</code>. Non-leaf nodes have either the value <code>2</code> or <code>3</code>, where <code>2</code> represents the boolean <strong>OR</strong> and <code>3</code> represents the boolean <strong>AND</strong>.</li>
</ol>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The Boolean <strong>OR</strong> returns <code>True</code> if at least one of the conditions is <code>True</code>. For example, <code>True OR False</code> evaluates to <code>True</code>. The Boolean <strong>AND</strong> returns <code>True</code> only if both conditions are <code>True</code>. For example, <code>True AND False</code> evaluates to <code>False</code>.</li>
<li>A leaf node is a node that has zero children.</li>
</ul>
</blockquote>
<hr />
<h3 id="approach-1-recursion-depth-first-search">Approach 1: Recursion (Depth First Search)</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's assume that we want to evaluate the tree shown below:</p>
<p><img src="../Figures/2331/2.png" alt="image.png" /></p>
<p>In the tree depicted above, the root node has exactly two leaf child nodes. The tree can be evaluated as <code>True OR False</code>, resulting in <code>True</code>. However, there may be cases where the root node has non-leaf children. For example:</p>
<p><img src="../Figures/2331/1.png" alt="image.png" /></p>
<p>Let's assume that <code>evaluateTree(Node)</code> denotes the boolean result after evaluating a subtree rooted at any node of the tree, given by <code>Node</code>. For the tree given above, it can be observed that <code>evaluateTree(root)</code> is determined by performing the stored boolean operation in the root on <code>evaluateTree(left child of root)</code> and <code>evaluateTree(right child of root)</code>.</p>
<p>We need to evaluate the children of the root node in order to calculate the evaluation of the root node. Therefore, the most intuitive way to solve this problem is through recursion.</p>
<p>Let's adapt our recursive solution based on these insights:</p>
<ul>
<li>The base case occurs when we have reached a leaf node while traversing the tree. In this case, we will return the boolean value of the leaf node.<br />
 </li>
<li>Calculate the evaluation for the left child and the right child of the current node recursively. The evaluation for the current node is given by performing the stored operation on the results of the left and right child.<br />
 </li>
<li>Return the boolean evaluation for the current node. This evaluation might be useful for calculating the evaluation of the parents or ancestors of the current node.</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>If the root node is a leaf node (left and right children are <code>null</code>), return the boolean value of the root node.</li>
<li>Initialize <code>evaluateLeftSubtree</code> with <code>evaluateTree(left child of root)</code> and <code>evaluateRightSubtree</code> with <code>evaluateTree(right child of root)</code>.</li>
<li>There are two cases possible for non-leaf roots:<br />
  * if the value of the root node is <code>2</code>, return the boolean <strong>OR</strong> of <code>evaluateLeftSubtree</code> and <code>evaluateRightSubtree</code>.<br />
  * if the value of the root node is <code>3</code>, return the boolean <strong>AND</strong> of <code>evaluateLeftSubtree</code> and <code>evaluateRightSubtree</code>.</li>
</ol>
<p>!?!../Documents/2331/slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5Qeajzb6/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>  We make a recursive call on every node of the tree exactly once. Since we visit each node of the tree exactly once, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>  The space complexity of the algorithm is primarily determined by two factors: the auxiliary space used and the recursion stack space. The auxiliary space is <span class="math inline">\(O(1)\)</span> because we have created two boolean variables.</p>
<p>Additionally, the recursion stack space can grow up to <span class="math inline">\(O(n)\)</span> in the worst case, constrained by the length of the path traversed up to a particular node, as each recursive call may add a node to the stack.</p>
<p>Therefore, the overall space complexity is the sum of these two components, resulting in <span class="math inline">\(O(1) + O(n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<hr />
<h3 id="approach-2-iterative-approach-depth-first-search">Approach 2: Iterative approach (Depth First Search)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The evaluation of the root node is given by the sum of the evaluation of the subtrees rooted at the left child and right child of the root node. Therefore, if we want to calculate the evaluation of the root, we must know the evaluation of the subtrees rooted at the left child and right child of the root.</p>
<p>While solving iteratively, we need to choose a data structure that can mimic the evaluation process of depth-first search in the previous case. Therefore, we can use a stack data structure to perform a traversal on the tree iteratively.</p>
<blockquote>
<p>A stack is a data structure that follows the Last-In, First-Out (LIFO) principle, allowing elements to be inserted and removed from only one end, typically referred to as the &quot;top&quot; of the stack.</p>
</blockquote>
<p>Analogous to the recursive approach discussed above, where the function <code>evaluateTree(Node)</code> calculates the evaluation for a subtree rooted at <code>Node</code>, we define that if the element at the top of the stack in the current iteration is <code>Node</code>, we will calculate its evaluation in this iteration.</p>
<p>The stack contains the root node of the tree in the first iteration. If the root is a leaf node (in the case where the tree has a single node) or both the left and right children of the root node are leaf nodes, the root node can be evaluated directly.</p>
<p>In other cases, we cannot evaluate the root node directly. Therefore, we must calculate the evaluated values of the right and left children, which will be used to determine the evaluation of the root node. Consequently, we will push the left child and right child of the current node onto the stack without popping the root node from the stack. Since the stack follows the Last In, First Out (LIFO) principle, we will calculate the evaluations of the left child and right child of the root node before reaching the root node again.</p>
<p>In this approach, we need to store the evaluations of the left child and right child of <code>Node</code>, where <code>Node</code> is the root of the subtree we evaluate. One option is to store the evaluations in the data of the node itself. We were storing the boolean operations for non-leaf nodes in the data. Therefore, once the node is evaluated, we don't need the boolean operation stored in it. However, it is not considered good practice to mutate the given input.</p>
<p>Using a hashmap is another method to store the evaluations of the nodes. A hashmap provides constant lookup and insertion time for the nodes. After evaluating a node, we can store its evaluated value in a hashmap, which can be used to evaluate other elements of the stack.</p>
<p>In cases where the current node is a leaf node or both children of the current node have already been evaluated, we can pop the top element of the stack and add the evaluated value to the hashmap with the current node as the key. However, in cases where the children have not been evaluated, we will push both children of the current node onto the stack.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a stack <code>st</code> with the <code>root</code> node. Also, create a hashmap <code>evaluated</code> with <code>node</code> data type for the key and <code>boolean</code> for values.</li>
<li>Iterate until <code>st</code> is empty:
<ul>
<li>Initialise the top element of the <code>st</code> with <code>topNode</code>.</li>
<li>If the <code>topNode</code> is a leaf node:
<ul>
<li>Pop the top element of <code>st</code> and add the value of the node to <code>evaluated</code> with the node as the key.</li>
</ul>
</li>
<li>If both the children of <code>topNode</code> are present in the hashmap <code>evaluated</code>:
<ul>
<li>If the value of <code>topNode</code> is 2:
<ul>
<li>Store the evaluation of <code>topNode</code> as <code>boolean OR</code> of the evaluations of the children of <code>topNode</code> in <code>evaluated</code>.</li>
</ul>
</li>
<li>If the value of <code>topNode</code> is 3:
<ul>
<li>Store the evaluation of <code>topNode</code> as <code>boolean AND</code> of the evaluations of the children of <code>topNode</code> in <code>evaluated</code>.</li>
</ul>
</li>
<li>Pop the top element of <code>st</code>.</li>
</ul>
</li>
<li>If any of the children of <code>topNode</code> are not present in <code>evaluated</code>:
<ul>
<li>Push the left and right child of <code>topNode</code> in <code>st</code>. </li>
</ul>
</li>
</ul>
</li>
<li>Return the evaluated boolean value of <code>root</code> stored in <code>evaluated</code>.</li>
</ol>
<p>!?!../Documents/2331/slideshow2.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GwNCrKJY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>  We iterate through the tree using a stack with constant insertion and deletion time. Additionally, we iterate through every node at most two times. Therefore, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>  Since every node can be inserted into the stack at most once, the stack can contain at most <span class="math inline">\(n\)</span> nodes. The hashmap stores the value of every node as a key exactly once. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/even-odd-tree/description" target="_blank" rel="noopener noreferrer">Even Odd Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A binary tree is named <strong>Even-Odd</strong> if it meets the following conditions:</p>

<ul>
	<li>The root of the binary tree is at level index <code>0</code>, its children are at level index <code>1</code>, their children are at level index <code>2</code>, etc.</li>
	<li>For every <strong>even-indexed</strong> level, all nodes at the level have <strong>odd</strong> integer values in <strong>strictly increasing</strong> order (from left to right).</li>
	<li>For every <b>odd-indexed</b> level, all nodes at the level have <b>even</b> integer values in <strong>strictly decreasing</strong> order (from left to right).</li>
</ul>

<p>Given the <code>root</code> of a binary tree, <em>return </em><code>true</code><em> if the binary tree is <strong>Even-Odd</strong>, otherwise return </em><code>false</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/sample_1_1966.png" style="width: 362px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The node values on each level are:
Level 0: [1]
Level 1: [10,4]
Level 2: [3,7,9]
Level 3: [12,8,6,2]
Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/sample_2_1966.png" style="width: 363px; height: 167px;" />
<pre>
<strong>Input:</strong> root = [5,4,2,3,3,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> The node values on each level are:
Level 0: [5]
Level 1: [4,2]
Level 2: [3,3,7]
Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/22/sample_1_333_1966.png" style="width: 363px; height: 167px;" />
<pre>
<strong>Input:</strong> root = [5,9,1,3,5,7]
<strong>Output:</strong> false
<strong>Explanation:</strong> Node values in the level 1 should be even integers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to determine whether a given binary tree is an <strong>Even-Odd</strong> tree.</p>
<p>To be considered an <strong>Even-Odd</strong> tree, a tree must meet the following conditions:</p>
<ul>
<li>Nodes at <strong>even</strong> levels must have <strong>odd</strong> values and be in <strong>increasing (left to right)</strong> order.</li>
<li>Nodes at <strong>odd</strong> levels must have <strong>even</strong> values and be in <strong>decreasing (left to right)</strong> order.</li>
</ul>
<p>Some of the conditions involve parity, the property of an integer with respect to being odd or even. We can determine the parity of an integer by using the modulo operation, <code>%</code>. For an odd integer <code>x</code>, <code>x % 2</code> always evaluates to <code>1</code> while for even integers <code>y</code>, <code>y % 2</code> always evaluates to <code>0</code>.</p>
<p>To determine whether a tree is <strong>Even-Odd</strong>, we need to traverse the tree, checking whether each node meets the above conditions.</p>
<blockquote>
<p>If you are not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">Explore Card</a></p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The conditions depend on the level or depth of the tree, which we will need to track.</p>
<p>One of the primary ways to traverse a tree is a Depth-First Search (DFS). We will use this approach with a preorder traversal.</p>
<p>Binary trees are often traversed using recursive methods. Below is an example pseudocode for a preorder traversal.</p>
<h5 id="recursive-preorder-traversal">Recursive Preorder Traversal</h5>
<ol>
<li>If the tree is empty, return.</li>
<li>Handle the root.</li>
<li>Traverse the right subtree - call Preorder(root.left).</li>
<li>Traverse the left subtree - call Preorder(root.right).</li>
</ol>
<p>We can implement a recursive function, <code>dfs</code>, to traverse the tree and check the <strong>Even-Odd</strong> conditions.</p>
<p>When writing recursive functions, we start with the base case. When the tree is empty, we return <code>true</code>; an empty tree is <strong>Even-Odd</strong>.</p>
<p>From there, we can build the rest of our recursive function <code>dfs</code>. The parameters will be a tree node <code>current</code> and <code>level</code> because when we encounter a node, we need to know what level we are on because the conditions are different for even and odd levels.</p>
<p>We also need to know whether the level we are on is even or odd. We can calculate <code>level % 2</code>, which will evaluate to <code>1</code> on odd levels and  <code>0</code> on even levels.</p>
<p>We also need to know the value of the previous node on this level so we can compare the current node and determine whether the values are increasing or decreasing. Depth-First Search does not visit the levels in order, so we will need to save the previously visited node from each level. We will use an array <code>prev</code>, indexed by <code>level</code>. The previous node on level 1 will be stored at <code>prev[1]</code>, and the previous node on level 2 will be stored at <code>prev[2]</code>. After handling each node, we will update <code>prev[level]</code> to the current node's value for use with the next node on this level.</p>
<p>To handle a node, we must check the conditions to determine whether it meets the requirements to be an <strong>Even-Odd</strong> tree:</p>
<p>Check whether the current value has the correct parity:</p>
<ul>
<li>Nodes on <strong>even</strong> levels must have <strong>odd</strong> values</li>
<li>Nodes on <strong>odd</strong> levels must have <strong>even</strong> values</li>
</ul>
<p>The level and the value should have opposite parity. We can use <code>current-&gt;val % 2 == level % 2</code> to compare the parity. If the parities are the same, the node breaks <strong>Even-Odd</strong> tree conditions, and we return <code>false</code>.</p>
<p>Check whether the current value is in the correct order:</p>
<ul>
<li>
<p>Nodes on <strong>even</strong> levels must be in strictly <strong>increasing</strong> order.</p>
<pre><code> node.val &lt;= prev[level] // True when node.val is less than or equal to `prev`
</code></pre>
</li>
</ul>
<p>If true, the node breaks the <strong>increasing</strong> condition, and we can return false.</p>
<ul>
<li>
<p>Nodes on <strong>odd</strong> levels must be in strictly <strong>decreasing</strong> order.</p>
<pre><code> node.val &gt;= prev[level] // True when node.val is greater than or equal to `prev`
</code></pre>
</li>
</ul>
<p>If true, the node breaks the <strong>decreasing</strong> condition, and we can return false.</p>
<p>After handling a node, we recursively call <code>dfs</code> on its children.</p>
<p>After defining <code>dfs</code>, all we have to do to solve the problem is call the function and return.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1609/1609_dfs_slideshow.json:960,480!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Declare an array <code>prev</code> to store the previous value on each level.</li>
<li>Initialize a node <code>current</code> to <code>root</code> for traversing the tree.</li>
<li>Define a function <code>dfs</code> whose parameters are a TreeNode <code>current</code> and <code>level</code> that performs a depth-first search, checking that the nodes meet the requirements for being an <strong>Even-Odd</strong> tree. If the tree is <strong>Even-Odd</strong>, it returns <code>true</code>; otherwise, it returns <code>false</code>.
<ol>
<li>Base case: if the tree is empty, return <code>true</code>. An empty tree is <strong>Even-Odd</strong>.</li>
<li>Check whether the current value has the correct parity compared with the level: <code>current-&gt;val % 2 == level % 2</code>. Return <code>false</code> if not.</li>
<li>Resize and add a new level to <code>prev</code> if we've reached a new level.</li>
<li>If we have already visited a node on this level, check that the current value is in the correct order depending on the level.
<ul>
<li>If on an even level, check that <code>current.val</code> is greater than the previous.</li>
<li>If on an odd level, check that <code>current.val</code> is less than the previous.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
</li>
<li>Add <code>current</code>'s value to the <code>prev</code> array. Only the most recent node on this level matters to the next node.</li>
<li>Recursively call <code>dfs</code> on the left and right child, incrementing <code>level</code>.</li>
</ol>
</li>
<li>Call and return <code>dfs(current, 0)</code> because the first level will be <code>0</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p>In the below implementation, we will use tail recursion. Many times, we use tail recursion without even recognizing it. It's a significant concept and an optimization strategy often overlooked in interviews. Tail recursion is a specific optimization technique used in functional programming to avoid the use of explicit loops and improve performance.</p>
<p>In a recursive function, each recursive call creates a new stack frame, which can lead to a stack overflow if the function is called too many times. Tail recursion reduces this problem by reusing the current stack frame instead of creating a new one.</p>
<p>To use tail recursion, the last statement of a function must be a recursive call, and the function must have a base case that can be reached by the recursive call. The base case is used to stop the recursion and return a value.<br />
Since our approach has both conditions, we can use tail recursion in the below implementation.</p>
<p><a href="https://leetcode.com/playground/FHwmAU3N/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once. At each visit, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS, when implemented recursively, is determined by the maximum depth of the call stack, which corresponds to the depth of the tree. In the worst case, if the tree is entirely unbalanced (e.g., a linked list or a left/right skewed tree), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. We also use an array, <code>prev</code>, which can grow as large as the depth of the tree, making the overall time complexity <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The other primary way to traverse a tree is a Breath-First Search (BFS). This traversal method, also known as level-order traversal, could apply to this problem because the algorithm visits all the nodes in each level before moving on to the next level. BFS could be helpful because on each level, we need to check that all nodes on the level meet certain conditions. The general algorithm for Breadth-First Search is below.</p>
<h5 id="breadth-first-search">Breadth-First Search</h5>
<ol>
<li>Create a queue for storing the nodes on each level.</li>
<li>Add the first node to the queue.</li>
<li>While the queue is not empty:
<ol>
<li>Remove the front node of the queue.</li>
<li>Add the adjacent nodes to the queue.</li>
</ol>
</li>
</ol>
<p>We will adjust a Breath-First Search to determine whether a tree is <strong>Even-Odd</strong>.</p>
<p>We create a flag <code>even</code> to track the current level's parity. It is set to <code>true</code> on even levels and <code>false</code> on odd levels. The size of the level is tracked to iterate through its nodes. After handling a node and enqueueing its children, we decrement <code>size</code>. The <code>even</code> flag is flipped with <code>!even</code> after processing all nodes on a level, alternating between <code>true</code> and <code>false</code> for even and odd levels.</p>
<p>To determine whether a tree is <strong>Even-Odd</strong>, we must handle each node, testing its parity.  We must also check the node's value compared to the other nodes on this level. Our BFS traversal will visit each node in each level in order, so we can use a variable <code>prev</code> to store the previous node's value. We can use this to check that the current node is greater than or less than the  <code>prev</code>, as needed.</p>
<p>Below are the conditions we will check to ensure the tree is <strong>Even-Odd</strong> :</p>
<p>Nodes on even levels must have <strong>odd</strong> values and must be in strictly <strong>increasing</strong> order. We check the following conditions:</p>
<ul>
<li><code>node.val % 2 == 0</code> // True when <code>node.val</code> is even</li>
<li><code>node.val &lt;= prev</code> // True when <code>node.val</code> is less than or equal to <code>prev</code></li>
</ul>
<p>If either of these are <code>true</code>, the node breaks <strong>Even-Odd</strong> tree conditions, and we can return <code>false</code>.</p>
<p>Nodes on odd levels must have <strong>even</strong> values and must be in strictly <strong>decreasing</strong> order. We check the following conditions:</p>
<ul>
<li><code>node.val % 2 == 1</code> // True when <code>node.val</code> is odd</li>
<li><code>node.val &gt;= prev</code> // True when <code>node.val</code> is greater than or equal to <code>prev</code></li>
</ul>
<p>If either of these are <code>true</code>, the node breaks <strong>Even-Odd</strong> tree conditions, and we can return <code>false</code>.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1609/1609_bfs_slideshow.json:685,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a Queue <code>queue</code> for storing the nodes on each level.</li>
<li>Declare a node <code>current</code> and set it to <code>root</code>. Add <code>current</code> to the queue.</li>
<li>Declare a boolean <code>even</code>, which will evaluate to <code>true</code> on even levels and <code>false</code> on odd levels. Initialize to <code>true</code>; we will start on level <code>0</code> which is even.</li>
<li>While <code>queue</code> is not empty:
<ol>
<li>Initialize a variable <code>size</code> to store the size of this level.</li>
<li>Declare a variable <code>prev</code> to store the value of the previous node on this level, so we can determine whether the nodes are in increasing or decreasing order. Set to <code>INT_MAX</code> on odd levels, which will ensure <code>current.val</code> is less than <code>prev</code>, and set to <code>INT_MIN</code> on even levels, which will ensure <code>current.val</code> is greater than <code>prev</code>.</li>
<li>For each node on this level:
<ol>
<li>Remove the front node from the queue and save in <code>current</code>.</li>
<li>Check to make sure this node meets the conditions of being even-odd:
<ul>
<li>If on an even level, make sure the current node's value is odd and greater than the previous value.</li>
<li>If on an odd level, make sure the current node's value is even, and less than the previous value.</li>
<li>Otherwise return <code>false</code>.</li>
</ul>
</li>
<li>Set <code>prev</code> to the current value.</li>
<li>If <code>current</code> has a left child, add it to <code>queue</code>.</li>
<li>If <code>current</code> has a right child, add it to <code>queue</code>.</li>
<li>Decrement <code>size</code>, we have handled a node on this level.</li>
</ol>
</li>
<li>Flip the value of <code>even</code> with <code>!even</code>. The next level will have the opposite parity.</li>
</ol>
</li>
<li>If the loop completes, every node in the tree has been visited and the whole tree is <strong>Even-Odd</strong>. Return <code>true</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/KJibuLLw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform BFS, which costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space for the queue during the BFS for <code>queue</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description" target="_blank" rel="noopener noreferrer">Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two binary trees <code>original</code> and <code>cloned</code> and given a reference to a node <code>target</code> in the original tree.</p>

<p>The <code>cloned</code> tree is a <strong>copy of</strong> the <code>original</code> tree.</p>

<p>Return <em>a reference to the same node</em> in the <code>cloned</code> tree.</p>

<p><strong>Note</strong> that you are <strong>not allowed</strong> to change any of the two trees or the <code>target</code> node and the answer <strong>must be</strong> a reference to a node in the <code>cloned</code> tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e1.png" style="width: 544px; height: 426px;" />
<pre>
<strong>Input:</strong> tree = [7,4,3,null,null,6,19], target = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e2.png" style="width: 221px; height: 159px;" />
<pre>
<strong>Input:</strong> tree = [7], target =  7
<strong>Output:</strong> 7
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/21/e3.png" style="width: 459px; height: 486px;" />
<pre>
<strong>Input:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the <code>tree</code> is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li>The values of the nodes of the <code>tree</code> are unique.</li>
	<li><code>target</code> node is a node from the <code>original</code> tree and is not <code>null</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve the problem if repeated values on the tree are allowed?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p><strong>How to Solve</strong></p>
<p>Let's traverse both trees in parallel, and once the target node is identified in the first tree, return the corresponding node from the second tree.</p>
<p><strong>How to Traverse the Tree: DFS vs BFS</strong></p>
<p>There are two ways to traverse the tree: DFS <em>depth first search</em> and BFS <em>breadth first search</em>. Here is a small summary</p>
<p><img src="../Figures/1379/traversals.png" alt="diff" /></p>
<p>Both start from the root and go down, both use additional structures, what's the difference? Here is how it looks at the big scale: BFS traverses level by level, and DFS first goes to the leaves.</p>
<p><img src="../Figures/1379/dfs_bfs_2.png" alt="diff" /></p>
<blockquote>
<p>Description doesn't give us any clue which traversal is better to use here. Interview-simple solutions are DFS in order traversals.</p>
</blockquote>
<p>In Approach 1 and Approach 2, we're going to discuss recursively inorder DFS and iterative inorder DFS traversals. They both need up to <span class="math inline">\(\mathcal{O}(H)\)</span> space to keep stack, where <span class="math inline">\(H\)</span> is a tree height.</p>
<p>In Approach 3, we provide a BFS solution. Normally, it's a bad idea to use BFS during the interview, unless the interviewer would push for it by adding new details into the problem description.</p>
<p><strong>Could We Solve in Constant Space?</strong></p>
<p>No. The problem could be solved in constant space using the DFS Morris inorder traversal algorithm, but it modifies the tree, and that isn't allowed here.</p>
<p><strong>Follow up: Repeated Values are Allowed</strong></p>
<p>If duplicate values are not allowed, one could compare node values:</p>
<p><a href="https://leetcode.com/playground/XvE3tVVZ/shared">code</a></p>
<p>Otherwise, one has to compare the nodes:</p>
<p><a href="https://leetcode.com/playground/gdNRDRYo/shared">code</a></p>
<br />
<br />
<hr />
<h3 id="approach-1-dfs-recursive-inorder-traversal">Approach 1: DFS: Recursive Inorder Traversal.</h3>
<p>Recursive inorder traversal is extremely simple: follow <code>Left-&gt;Node-&gt;Right</code> direction, <em>i.e.</em>, do the recursive call for the <em>left</em> child, then do all the business with the node (= check if the node is a target one or not), and then do the recursive call for the <em>right</em> child.</p>
<p><img src="../Figures/1379/dfs.png" alt="diff" /><br />
<em>Figure 1. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8CVVBmSp/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. Since one has to visit each node, where <span class="math inline">\(N\)</span> is the number of nodes.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. In the degenerative tree case (where the tree is shaped like a linked list), all nodes will be on the run-time stack while the deepest node is being processed. If the tree is balanced, the space complexity will be nearer to <span class="math inline">\(\mathcal{O}(\log N)\)</span>, but remember that for the purposes of complexity analysis, we mostly consider the worst case.</p>
</li>
</ul>
<br />
<br />
<hr />
<h3 id="approach-2-dfs-iterative-inorder-traversal">Approach 2: DFS: Iterative Inorder Traversal.</h3>
<p>Iterative inorder traversal is straightforward: go left as far as you can, then one step right. Repeat till the end of nodes in the tree.</p>
<p>!?!../Documents/1379_LIS.json:1000,310!?!</p>
<p><strong>Implementation</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Don't use Stack in Java, use ArrayDeque instead</a>.</p>
<p><a href="https://leetcode.com/playground/2UFXYe3o/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. Since one has to visit each node.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(\mathcal{O}(N)\)</span>. In the degenerative tree case (where the tree is shaped like a linked list), all nodes will be on the stack while the deepest node is being processed. If the tree is balanced, the space complexity will be nearer to <span class="math inline">\(\mathcal{O}(\log N)\)</span>, but remember that for the purposes of complexity analysis, we mostly consider the worst case.</p>
</li>
</ul>
<br />
<hr />
<h3 id="approach-3-bfs-iterative-traversal">Approach 3: BFS: Iterative Traversal.</h3>
<p><strong>Algorithm</strong></p>
<p>Here we implement standard BFS traversal with the queue:</p>
<ul>
<li>
<p>Add root into queue.</p>
</li>
<li>
<p>While queue is not empty:</p>
<ul>
<li>
<p>Pop out a node from queue.</p>
</li>
<li>
<p>If the node is a target, we're done.</p>
</li>
<li>
<p>Add first <em>left</em> and then <em>right</em> child node into queue.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html">Don't use Stack in Java, use ArrayDeque instead</a>.</p>
<p><a href="https://leetcode.com/playground/mnfHHeRK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(N)\)</span> to keep the queue. Let's use the last level to estimate the queue size. This level could contain up to <span class="math inline">\(N/2\)</span> tree nodes in the case of <a href="https://leetcode.com/problems/count-complete-tree-nodes/">complete binary tree</a>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-bottom-left-tree-value/description" target="_blank" rel="noopener noreferrer">Find Bottom Left Tree Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" style="width: 302px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" style="width: 432px; height: 421px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,null,5,6,null,null,7]
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to find the leftmost value at the bottom level of the tree. We are provided with the root of the tree.</p>
<p>Since we need to find a specific value at the bottom of a tree, we will need to traverse the tree, searching for the leftmost node at the bottom level. When we find that node, we can return its value.</p>
<blockquote>
<p>If you are not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">Explore Card</a></p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the leftmost node in the bottom level of the tree. As we are concerned with the bottom level specifically, we will need to keep track of the current level/depth as we traverse.</p>
<p>One of the primary ways to traverse a tree is a Depth-First Search (DFS). We will use this approach to search for the leftmost node in the bottom level because it will be easy to keep track of the depth. We will use a preorder traversal, visiting each subtree's root first so that we can keep track of the level and visiting the left child first so that when we get to a new depth, we know that the current node is the leftmost node of that level.</p>
<p>Binary trees are often traversed using recursive methods. Below is an example pseudocode for a preorder traversal.</p>
<h5 id="standard-recursive-preorder-traversal">Standard Recursive Preorder Traversal</h5>
<ol>
<li>If the tree is empty, return.</li>
<li>Handle the root.</li>
<li>Traverse the left subtree - call Preorder(root.left).</li>
<li>Traverse the right subtree - call Preorder(root.right).</li>
</ol>
<p>Below is an example tree, with each level's depth labeled.</p>
<p><img src="../Figures/513/513_1.png" alt="Binary Tree with [1, 2, 3, 4, null, 5, 6, null, null, 7]" /></p>
<p>A preorder traversal visits the nodes in this order: 1, 2, 4, 3, 5, 7, 6.</p>
<p>We can implement a recursive function <code>dfs</code> to search for the leftmost node in the bottom level, which we will call <code>bottomLeftValue</code>.</p>
<p>Generally, when working recursively with trees, the base case is when the tree is empty. If the current node is empty, we return.</p>
<p>From there, we can build the rest of our recursive function <code>dfs</code>. We keep track of the deepest level of the tree we have encountered so far in <code>maxDepth</code>. We store the value of the deepest leftmost node we have found thus far in <code>bottomLeftValue</code>. To perform a pre-order traversal, we first handle the root, then recursively search the left subtree, then the right subtree. Each time we recursively call <code>dfs</code>, we increment the depth by one because the left or right child of the current node is one level deeper than the current node. When we visit the current node, we will check if it is deeper than any node we have discovered yet. If the current node is the deepest we have found so far, we have discovered a new level of the tree. We visit nodes to the left first, so we know this is the leftmost node in this level. We can update <code>bottomLeftValue</code> to the current node's value and also update <code>maxDepth</code>.</p>
<p>After defining <code>dfs</code>, all we have to do to solve the problem is call the function and then return `bottomLeftValue``.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a variable <code>maxDepth</code> to store the depth of the bottom level of the tree.</li>
<li>Initialize a variable <code>bottomLeftValue</code> to store the leftmost value in the last row of the tree.</li>
<li>Implement a recursive function, <code>dfs</code>, that traverses the tree and finds the leftmost value in the last row of the tree. The parameters are <code>current</code>, the current node, and <code>depth</code>, its depth.
<ol>
<li>Check whether <code>current</code> is empty. If so, return.</li>
<li>Check if the current depth exceeds the global variable <code>maxDepth</code>. If it does, that means we have found a new level.
<ol>
<li>Set <code>maxDepth</code> to <code>depth</code>.</li>
<li>Set <code>bottomLeftValue</code> to the value of the current node.</li>
</ol>
</li>
<li>Recursively call <code>dfs</code> on the current node's left subtree and increment <code>depth</code> by one.</li>
<li>Recursively call <code>dfs</code> on the current node's right subtree and increment <code>depth</code> by one.</li>
</ol>
</li>
<li>Call <code>dfs</code> with <code>root</code> and the initial <code>depth</code> of <code>0</code>.</li>
<li>Return <code>bottomLeftValue</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/795bdDWi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Traversing the tree with a DFS costs <span class="math inline">\(O(n)\)</span> as we visit each node exactly once. At each visit, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity of DFS, when implemented recursively, is determined by the maximum depth of the call stack, which corresponds to the depth of the tree. In the worst case, if the tree is entirely unbalanced (e.g., a linked list), the call stack can grow as deep as the number of nodes, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-right-to-left">Approach 2: Breadth-First Search Right to Left</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The other primary way to traverse a tree is a Breath-First Search (BFS). This traversal method, also known as level-order traversal, could apply to this problem because the algorithm visits all the nodes in each level before moving on to the next level. BFS could be helpful because we are concerned with the last level specifically, and visiting the levels in order means that the final nodes we encounter are on the bottom level. The general algorithm for Breadth-First Search is below.</p>
<h5 id="standard-breadth-first-search">Standard Breadth-First Search</h5>
<ol>
<li>Create a queue for storing the nodes on each level.</li>
<li>Add the root node to the queue.</li>
<li>While the queue is not empty:
<ol>
<li>Remove the front node of the queue.</li>
<li>Handle the node and add its children to the back of the queue.</li>
</ol>
</li>
</ol>
<p>Below is an example tree to visualize how BFS works.</p>
<p><img src="../Figures/513/513_2.png" alt="Binary Tree with [1, 2, 3, 4, null, 5, 6, null, null, 7]" /></p>
<p>Breath First Search visits the nodes in this order: 1, 2, 3, 4, 5, 6, 7.</p>
<p>In the depth-first search implementation above, we kept track of the depth and <code>maxDepth</code> of the tree using a variable. We could use the same strategy to track the depth during the BFS, but it may not be necessary. BFS performs a level order search, meaning the last nodes we encounter will be on the bottom level. We are searching for the leftmost node in the bottom level of the tree.</p>
<blockquote>
<p>How can we find the leftmost node in the bottom level?</p>
</blockquote>
<p>BFS of a tree is often implemented such that the left child of a given node is visited first, then the right child. If we implement BFS such that the right child of a given node is visited first, then the left child, the last node we visit is the leftmost node in the bottom level of the tree. This makes a variable for depth unnecessary. We can just return the value of the last node we encounter during the search.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a Queue <code>queue</code> for storing the nodes on each level.</li>
<li>Create a new node <code>current</code> and set it to <code>root</code>.</li>
<li>Add <code>current</code> to <code>queue</code>.</li>
<li>While <code>queue</code> is not empty:
<ol>
<li>Remove the front node from the queue and save it in <code>current</code>.</li>
<li>If the <code>current</code> has a right child, add it to <code>queue</code>.</li>
<li>If the <code>current</code> has a left child, add it to <code>queue</code>.</li>
</ol>
</li>
<li>After the while loop, each node in the tree has been visited. The search traversed the whole tree, top to bottom, right to left, so the last node stored in <code>current</code> is the leftmost node in the bottom level of the tree, and we return its value.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/g6zXpErc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform BFS, which costs <span class="math inline">\(O(n)\)</span> because we don't visit a node more than once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space for the queue during the BFS for <code>queue</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-duplicate-subtrees/description" target="_blank" rel="noopener noreferrer">Find Duplicate Subtrees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code>&nbsp;of a binary tree, return all <strong>duplicate subtrees</strong>.</p>

<p>For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them.</p>

<p>Two trees are <strong>duplicate</strong> if they have the <strong>same structure</strong> with the <strong>same node values</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e1.jpg" style="width: 450px; height: 354px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,null,2,4,null,null,4]
<strong>Output:</strong> [[2,4],[4]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e2.jpg" style="width: 321px; height: 201px;" />
<pre>
<strong>Input:</strong> root = [2,1,1]
<strong>Output:</strong> [[1]]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/16/e33.jpg" style="width: 450px; height: 303px;" />
<pre>
<strong>Input:</strong> root = [2,2,2,3,null,3,null]
<strong>Output:</strong> [[2,3],[3]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the tree will be in the range <code>[1, 5000]</code></li>
	<li><code>-200 &lt;= Node.val &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description" target="_blank" rel="noopener noreferrer">Find Elements in a Contaminated Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree with the following rules:</p>

<ol>
	<li><code>root.val == 0</code></li>
	<li>For any <code>treeNode</code>:
	<ol type="a">
		<li>If <code>treeNode.val</code> has a value <code>x</code> and <code>treeNode.left != null</code>, then <code>treeNode.left.val == 2 * x + 1</code></li>
		<li>If <code>treeNode.val</code> has a value <code>x</code> and <code>treeNode.right != null</code>, then <code>treeNode.right.val == 2 * x + 2</code></li>
	</ol>
	</li>
</ol>

<p>Now the binary tree is contaminated, which means all <code>treeNode.val</code> have been changed to <code>-1</code>.</p>

<p>Implement the <code>FindElements</code> class:</p>

<ul>
	<li><code>FindElements(TreeNode* root)</code> Initializes the object with a contaminated binary tree and recovers it.</li>
	<li><code>bool find(int target)</code> Returns <code>true</code> if the <code>target</code> value exists in the recovered binary tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg" style="width: 320px; height: 119px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1]],[1],[2]]
<strong>Output</strong>
[null,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1]); 
findElements.find(1); // return False 
findElements.find(2); // return True </pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg" style="width: 400px; height: 198px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,-1,-1,-1,-1]],[1],[3],[5]]
<strong>Output</strong>
[null,true,true,false]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);
findElements.find(1); // return True
findElements.find(3); // return True
findElements.find(5); // return False</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg" style="width: 306px; height: 274px;" />
<pre>
<strong>Input</strong>
[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]
[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]
<strong>Output</strong>
[null,true,false,false,true]
<strong>Explanation</strong>
FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);
findElements.find(2); // return True
findElements.find(3); // return False
findElements.find(4); // return False
findElements.find(5); // return True
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>TreeNode.val == -1</code></li>
	<li>The height of the binary tree is less than or equal to <code>20</code></li>
	<li>The total number of nodes is between <code>[1, 10<sup>4</sup>]</code></li>
	<li>Total calls of <code>find()</code> is between <code>[1, 10<sup>4</sup>]</code></li>
	<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree <code>root</code> which follows the following 3 rules:</p>
<ol>
<li>The value of the root node <code>root</code> is always 0</li>
<li>Given a node in the tree with value <code>x</code>, the value of its left child (if it exists) is always <code>x * 2 + 1</code></li>
<li>Given a node in the tree with value <code>x</code>, the value of its right child (if it exists) is always <code>x * 2 + 2</code></li>
</ol>
<p>This tree is then &quot;contaminated&quot;, which means the values of all nodes are overwritten to <code>-1</code>. We now have to find out what values existed in the tree before it was contaminated. We do this by implementing two functions:</p>
<ol>
<li><code>FindElements(TreeNode* root)</code> is our constructor that gives us the contaminated binary tree <code>root</code></li>
<li><code>bool find(int target)</code> should return whether or not <code>target</code> is one of the original values in <code>root</code> before contamination</li>
</ol>
<h3 id="approach-1-tree-traversal-dfs">Approach 1: Tree Traversal (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Our goal is to restore the original values of the tree before it was contaminated. The problem gives us three key rules that define how values are assigned to nodes based on their parent. If we carefully analyze these rules, we can see that the root node always has a value of <code>0</code>. From this starting point, we can apply the second rule to determine that the left child (if it exists) must have a value of <code>0 * 2 + 1 = 1</code>, and the third rule tells us that the right child must have a value of <code>0 * 2 + 2 = 2</code>. Once we establish these values, we can continue applying the same logic to the children of these nodes, propagating the correct values throughout the tree.</p>
<p>This observation naturally leads to a recursive approach. Since each node's value is determined by its parent, we can traverse the tree while applying these rules at every step, ensuring that each node is assigned its correct value. To keep track of the values we recover, we store them in a set called <code>seen</code>. This allows us to efficiently check whether a given value exists in the tree whenever needed.</p>
<p>The best way to traverse the tree in this scenario is <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">depth-first search (DFS)</a>. DFS is particularly useful here because it allows us to fully process one branch of the tree before moving to the next, making it a straightforward way to assign values as we traverse. The DFS process follows a simple structure:</p>
<ol>
<li>If we reach a <code>null</code> node, we stop and return immediately, as there’s nothing left to explore.</li>
<li>For each valid node, we store its recovered value in our <code>seen</code> set.</li>
<li>We then move to the left child, using rule 2 (<code>currentValue * 2 + 1</code>) to compute its value before making a recursive DFS call.</li>
<li>We move to the right child next, using rule 3 (<code>currentValue * 2 + 2</code>) before making another recursive DFS call.</li>
</ol>
<p>To implement this, we define a function <code>DFS(currentNode, currentValue)</code>, where <code>currentNode</code> represents the node we are currently processing, and <code>currentValue</code> is its correct original value. This function will handle the recursive traversal and ensure each node gets assigned its correct value.</p>
<p>Since we always know the parent’s value, we can immediately compute the child's values and pass them into the next recursive call. By the end of this process, we will have fully reconstructed the tree’s original values, and since all recovered values are stored in <code>seen</code>, checking for the existence of a number in the tree becomes a simple lookup operation.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Declare a HashSet <code>seen</code> as a  member of the <code>FindElements</code> class</li>
<li>For <code>FindElements(root)</code> constructor:
<ul>
<li>Initialize <code>seen</code> to an empty set.</li>
<li>Call the helper function <code>dfs(root, 0)</code>.</li>
</ul>
</li>
<li>For helper function <code>dfs(currentNode, currentValue, seen)</code>:
<ul>
<li>If the <code>currentNode</code> is <code>null</code>, then we return.</li>
<li>Otherwise, we process the value of <code>currentNode</code> by adding <code>currentValue</code> to <code>seen</code>.</li>
<li>We then recurse to the left and right children:
<ul>
<li>For left child, we call <code>dfs(currentNode.left, currentValue * 2 + 1, seen)</code>.</li>
<li>For right child, we call <code>dfs(currentNode.right, currentValue * 2 + 2, seen)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>For <code>find(target)</code> function:
<ul>
<li>We return whether or not <code>seen</code> contains <code>target</code>: return <code>seen.contains(target)</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LSchxPfd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> for <code>FindElements</code>, <span class="math inline">\(O(1)\)</span> for <code>find</code></p>
<p>For the <code>FindElements</code> constructor, traversing through <code>root</code> and processing all nodes takes <span class="math inline">\(O(N)\)</span> time. Afterwards, each call of <code>find</code> looks up a value in our set, which takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>After the <code>FindElements</code> constructor is called, our set contains the values of all the nodes of <code>root</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tree-traversal-bfs">Approach 2: Tree Traversal (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we used depth-first search (DFS) to traverse the tree, assigning the correct values to nodes and storing these values in a set. Now, we will take a different approach using <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">breadth-first search (BFS)</a>, which follows a different traversal pattern but ultimately achieves the same goal.</p>
<p>To understand the difference, recall that DFS explores a tree by going as deep as possible along one branch before backtracking to explore others. BFS, on the other hand, processes nodes <strong>level by level</strong>, meaning it explores all nodes at a given depth before moving to the next level. This fundamental difference in traversal order leads to a different way of structuring our solution.</p>
<p>To implement BFS, we use a queue, which allows us to control the flow of traversal systematically. We start by inserting the root node into the queue, using it as our initial entry point. Then, as long as the queue is not empty, we repeatedly take the front node, determine its correct original value, and store it in a set for quick lookups later.</p>
<p>Once a node has been processed, we compute the values of its children based on the given rules. If the node has a left child, we use <strong>rule 2</strong> (<code>n.val * 2 + 1</code>) to compute its value and enqueue it for future processing. Similarly, if the node has a right child, we use <strong>rule 3</strong> (<code>n.val * 2 + 2</code>) and enqueue it as well. This ensures that by the time these children are processed, they already hold their correct recovered values.</p>
<p>Unlike DFS, where we explicitly pass the recovered value through recursive calls, BFS allows us to overwrite the node values directly as we process them. This means that when we remove a node from the queue, its left and right children already have their correct values assigned.</p>
<p>Since BFS naturally ensures that nodes are visited in level order, this guarantees a systematic reconstruction of the entire tree. By the end of the traversal, every node will hold its correct original value, and checking whether a number exists in the tree becomes a simple lookup operation in our set.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Declare a HashSet <code>seen</code> as a member of the <code>FindElements</code> class</li>
<li>For <code>FindElements(root)</code> constructor:
<ul>
<li>Initialize <code>seen</code> to an empty set.</li>
<li>Call the helper function <code>bfs(root)</code>.</li>
</ul>
</li>
<li>For helper function <code>bfs(TreeNode root)</code>:
<ul>
<li>Initialize a queue which first contains <code>root</code>. <code>root.val</code> should be set to <code>0</code>.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the front element of the queue: <code>currentNode = queue.pop()</code>.</li>
<li>Save the recovered value by adding <code>currentNode.val</code> into <code>seen</code>.</li>
<li>If left child exists, overwrite its value <code>currentNode.left.val = currentNode.val * 2 + 1</code> and then enqueue it.</li>
<li>If right child exists, overwrite its value <code>currentNode.right.val = currentNode.val * 2 + 2</code> and then enqueue it.</li>
</ul>
</li>
</ul>
</li>
<li>For <code>find(target)</code> function:
<ul>
<li>We return whether or not <code>seen</code> contains <code>target</code>: return <code>seen.contains(target)</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/aUjXxUTe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span> for <code>FindElements</code>, <span class="math inline">\(O(1)\)</span> for <code>find</code></p>
<p>For the <code>FindElements</code> constructor, traversing through <code>root</code> and processing all nodes takes <span class="math inline">\(O(N)\)</span> time. Afterwards, each call of <code>find</code> looks up a value in our set, which takes <span class="math inline">\(O(1)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>After the <code>FindElements</code> constructor is called, our set contains the values of all the nodes of <code>root</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-largest-value-in-each-tree-row/description" target="_blank" rel="noopener noreferrer">Find Largest Value in Each Tree Row</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>an array of the largest value in each row</em> of the tree <strong>(0-indexed)</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" style="width: 300px; height: 172px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,3,null,9]
<strong>Output:</strong> [1,3,9]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> [1,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
</blockquote>
<p>BFS is perfect when we are dealing specifically with rows/levels of a binary tree. With BFS, we handle one row of the tree at a time.</p>
<p>Here, we need to find the maximum value in each row. We can simply perform a BFS and for each row, keep track of the maximum value we have seen so far. We will initialize an integer <code>currMax</code> to a small value like negative infinity. Then we go through the row and try to update <code>currMax</code> when we see larger values. After handling the row, we add <code>currMax</code> to our answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>If the <code>root</code> is null (empty) tree, just return an empty list.</li>
<li>Initialize the answer list <code>ans</code> and a <code>queue</code> with the <code>root</code> to perform BFS.</li>
<li>Perform BFS - while the <code>queue</code> is not empty:
<ul>
<li>Initialize <code>currMax</code> to a small value and save the length of the queue in <code>currentLength</code>.</li>
<li>Iterate <code>currentLength</code> times:
<ul>
<li>Remove a <code>node</code> from the <code>queue</code>.</li>
<li>Update <code>currMax</code> with <code>node.val</code> if it is larger.</li>
<li>For each child of <code>node</code>, if it is not null, push it to the <code>queue</code>.</li>
</ul>
</li>
<li>Add <code>currMax</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/P7pFhbid/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the BFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In a perfect binary tree, the final row has <span class="math inline">\(O(\frac{n}{2}) = O(n)\)</span> nodes, all of which will be in <code>queue</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Note: This problem is perfect for BFS, but an interviewer might you to implement DFS as a follow-up. We have included a DFS approach for completeness.</p>
</blockquote>
<p>In BFS, we handle each row explicitly, so it's easy to just keep track of the maximum value as we traverse through the row.</p>
<p>In DFS, the order in which we move through the tree is not related to the rows. Thus, we need to be more creative to find the maximum value in each row. The first observation to make is that each row can be described by the depth of its nodes.</p>
<p><img src="../Figures/515/1.png" alt="depth" /><br />
<br></p>
<p>The depth of a node is its distance from the root. The root has a depth of <code>0</code>, and every child has a depth of <code>1</code> greater than its parent. You may also notice that in terms of indices, each node's depth corresponds to its index in the answer.</p>
<p>For example, if <code>ans</code> is our answer list, then <code>ans[2]</code> holds the maximum value of all nodes with depth <code>2</code>.</p>
<p>If we keep track of each node's depth during the traversal, then we can update <code>ans</code> directly. How do we keep track of the depth? We will pass an additional argument <code>depth</code> in our <code>dfs</code> function. When we initially call <code>dfs</code> with <code>root</code>, we will pass <code>depth = 0</code>. When we call <code>dfs</code> on a child, we will pass <code>depth + 1</code>.</p>
<p>There is one problem: how do we know what length <code>ans</code> should be? We will initialize <code>ans</code> as an empty list. If we are at a <code>depth</code> that would be out of bounds if we tried to access <code>ans[depth]</code>, then we will simply initialize the current <code>node.val</code> as the maximum value seen at <code>depth</code> so far by pushing <code>node.val</code> to <code>ans</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>ans</code> as an empty list.</li>
<li>Define a function <code>dfs(node, depth)</code>:
<ul>
<li>If <code>node</code> is null, return.</li>
<li>If <code>depth == ans.length</code>, then push <code>node.val</code> to <code>ans</code>. Otherwise, try to update <code>ans[depth]</code> with <code>node.val</code> if its larger.</li>
<li>Call <code>dfs</code> on <code>node.left</code> and <code>node.right</code> with <code>depth + 1</code> as the second argument.</li>
</ul>
</li>
<li>Call <code>dfs(root, 0)</code> and then <code>return ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/CmiiemQN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree and <span class="math inline">\(h\)</span> as the max depth of the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(h)\)</span></p>
<p>We use extra space for the recursion call stack. The most calls in the call stack at any given time will be the max depth of the tree. In the worst-case scenario where the tree is like a linked list, the max depth will be <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-dfs-iterative">Approach 3: DFS, Iterative</h3>
<p><strong>Intuition</strong></p>
<p>We can also implement DFS iteratively using a stack. Each entry in the stack will be a pair <code>node, depth</code>. We will use a while loop to perform the DFS, with each iteration being analogous to a function call from the previous approach. As such, we will perform the same process in each while loop iteration: try to update <code>ans</code> with <code>node.val</code>, then push the children of <code>node</code> to the stack if they exist.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>If the <code>root</code> is null (empty) tree, just return an empty list.</li>
<li>Initialize the answer list <code>ans</code> and a <code>stack</code> with <code>(root, 0)</code>.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop <code>(node, depth)</code> from the stack.</li>
<li>If <code>depth == ans.length</code>, then push <code>node.val</code> to <code>ans</code>. Otherwise, try to update <code>ans[depth]</code> with <code>node.val</code> if its larger.</li>
<li>If <code>node.left</code> is not null, push <code>(node.left, depth + 1)</code> to <code>stack</code>.</li>
<li>If <code>node.right</code> is not null, push <code>(node.right, depth + 1)</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Gc9wyzzK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree and <span class="math inline">\(h\)</span> as the max depth of the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(h)\)</span></p>
<p>We use extra space for the recursion call stack. The most calls in the call stack at any given time will be the max depth of the tree. In the worst-case scenario where the tree is like a linked list, the max depth will be <span class="math inline">\(O(n)\)</span>.</p>
<p>We pop the top node from the stack and then push its child nodes onto the stack based on the DFS traversal strategy. This process of pushing and popping forms a path-like structure within the stack, and the length of this path will not exceed the height of the tree. Therefore, <span class="math inline">\(O(h)\)</span> space will be used.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-mode-in-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Find Mode in Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>

<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>

<p>Assume a BST is defined as follows:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" style="width: 142px; height: 222px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,2]
<strong>Output:</strong> [2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this article, we will present many different approaches to solving this problem.</p>
<p>The level of these approaches varies greatly. Some approaches have different time complexities, while some simply present a different way of attacking the problem.</p>
<p>Note that not all of these approaches will be expected in an interview. At the start of each approach, there will be a comment regarding the difficulty of the approach and if it should be used in an interview.</p>
<p>For all approaches, we will assume that you are already familiar with how trees are given in LeetCode problems and how to traverse them.</p>
<hr />
<h3 id="approach-1-count-frequency-with-hash-map-dfs">Approach 1: Count Frequency With Hash Map (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a great first approach to use in an interview. It is simple, easy to implement, has good complexity, and demonstrates an understanding of binary trees and hash maps. You should be prepared for follow-ups after implementing this solution.</p>
</blockquote>
<p>Our goal is to find all the modes in the tree. A mode is a value that has the maximum frequency. Note that there could be multiple modes: for example, if we had the following tree:</p>
<p><img src="../Figures/501/1.png" alt="example" /><br />
<br></p>
<p>The frequency of each value is as follows:</p>
<table>
<thead>
<tr>
<th align="center">Value</th>
<th align="center">Frequency</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<br>
<p>The maximum frequency is <code>2</code>, thus we have two modes: <code>4</code> and <code>8</code>.</p>
<p>We can solve this problem by collecting the frequency of all values in the tree, finding the maximum frequency <code>maxFreq</code>, then checking which values have a frequency of <code>maxFreq</code>.</p>
<p>To count the frequency of each value, we will perform a depth-first search (DFS) on the tree to visit every node. We can initialize a hash map <code>counter</code> before starting the DFS. At each node we visit, we will update the frequency of <code>node.val</code> in <code>counter</code>.</p>
<p>Once we have finished the DFS (visited every node), <code>counter</code> will hold the frequency of all values. We will save the maximum frequency as <code>maxFreq</code>, then iterate over all the elements of <code>counter</code> and check which ones have a frequency equal to <code>maxFreq</code>. Each of those elements will be in our final answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code>.</li>
<li>Create a function <code>dfs(node, counter)</code>:
<ul>
<li>If <code>node</code> is null, immediately exit the function.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>Call <code>dfs</code> on both children with <code>dfs(node.left, counter)</code> and <code>dfs(node.right, counter)</code>.</li>
</ul>
</li>
<li>Call <code>dfs(root, counter)</code>.</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>In Python, we are using <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">collections.defaultdict</a> to make the code cleaner. It is similar to <code>std::unordered_map</code> in C++.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/BH7zk7gP/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map operations cost <span class="math inline">\(O(1)\)</span>.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst case scenario is <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-iterative-dfs">Approach 2: Iterative DFS</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach may be asked as a follow-up to the previous approach, or vice-versa if you implement this one first. It is common for interviewers to ask you to solve a problem with DFS both recursively and iteratively.</p>
</blockquote>
<p>In this approach, we will use the same algorithm from the previous approach, except that we will implement the DFS iteratively.</p>
<p>Instead of using recursion, we will use a stack <code>stack</code>. Initially, we will have the <code>root</code> in the <code>stack</code>. Then, we will perform a DFS until the <code>stack</code> is empty using a while loop. At each iteration, we pop a <code>node</code> from the <code>stack</code>. We will increment the frequency of <code>node</code> in <code>counter</code> just like we did in the previous approach, then push the children of <code>node</code> to <code>stack</code> if they exist. In this way, we go as deep into the tree as possible before backtracking, similar to node exploration in recursive DFS.</p>
<p>Each iteration of the while loop is analogous to a function call from the previous approach, as we are handling a given <code>node</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code> and a stack <code>stack</code> that contains <code>root</code>.</li>
<li>Perform a DFS. While <code>stack</code> is not empty:
<ul>
<li>Pop <code>node</code> from the top of <code>stack</code>.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>If <code>node.left</code> is not null, push it to <code>stack</code>.</li>
<li>If <code>node.right</code> is not null, push it to <code>stack</code>.</li>
</ul>
</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/QiC3LGWA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map and stack operations cost <span class="math inline">\(O(1)\)</span>.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, <code>stack</code> may grow to a size of <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-breadth-first-search-bfs">Approach 3: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>Again, this approach may be asked as a follow-up if you implemented DFS first, or vice-versa. It is also common for interviewers to ask you to implement both DFS and BFS.</p>
<p>We have included approaches 2 and 3 to demonstrate the usage of iterative DFS and BFS to solve this problem. We are able to do this because there isn't really a difference in using recursive DFS, iterative DFS, or BFS for this algorithm - we simply need to visit each node.</p>
</blockquote>
<p>In this approach, we again use the same algorithm from the first two approaches. This time, we will perform the traversal using BFS.</p>
<p>With BFS, instead of using a stack (or the recursion stack) like in DFS, we use a queue. The main difference is that we handle nodes in a first-in, first-out fashion (FIFO) as opposed to in DFS where we handle nodes in a last-in, first-out (LIFO) fashion. This results in us visiting each node by depth - we can imagine the root at depth <code>0</code>, the root's children at depth <code>1</code>, the children of those children at depth <code>2</code>, and so on.</p>
<p><img src="../Figures/501/bfs.png" alt="example" /><br />
<br></p>
<p>With BFS, we visit all nodes at a depth of <code>x</code> before visiting any node at a depth of <code>x + 1</code>. While BFS excels over DFS for many problems, in this problem it is just another way for us to perform the traversal. We simply need to visit each node in the tree so that we can record the frequencies in <code>counter</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize a hash map <code>counter</code> and a queue <code>queue</code> that contains <code>root</code>.</li>
<li>Perform a BFS. While <code>queue</code> is not empty:
<ul>
<li>Pop <code>node</code> from the front of <code>queue</code>.</li>
<li>Increment the frequency of <code>node.val</code> in <code>counter</code>.</li>
<li>If <code>node.left</code> is not null, push it to <code>queue</code>.</li>
<li>If <code>node.right</code> is not null, push it to <code>queue</code>.</li>
</ul>
</li>
<li>Find the maximum value in <code>counter</code> as <code>maxFreq</code>.</li>
<li>Initialize the answer list <code>ans</code>.</li>
<li>Iterate over all key-value pairs in <code>counter</code>. If the value is equal to <code>maxFreq</code>, add the key to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>In Python, we are using <a href="https://docs.python.org/3/library/collections.html#collections.deque">collections.deque</a> to implement an efficient queue.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/maqHS24V/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the BFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work since hash map and queue operations cost <span class="math inline">\(O(1)\)</span>. Note that this assumes that the implementation of <code>queue</code> is efficient. In the code we presented above, all implementations are efficient.</p>
<p>Next, we find <code>maxFreq</code>, which involves iterating over <code>counter</code>. In the worst-case scenario where the tree has only unique values, <code>counter</code> will have a size of <span class="math inline">\(n\)</span>, and thus this will cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Finally, we construct <code>ans</code>, which involves iterating over <code>counter</code> again. Overall, our time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, <code>queue</code> may grow to a size of <span class="math inline">\(O(n)\)</span>. Also, as mentioned above, if the tree only has unique values then <code>counter</code> will have a size of <span class="math inline">\(n\)</span>. Thus, <code>counter</code> also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-no-hash-map">Approach 4: No Hash-Map</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is another way to attack the problem compared to the previous three approaches. It is slightly more complex and can be implemented if the interviewer asks for an alternate way to solve the problem. While this approach has the same time and space complexity as the first three, it runs slightly faster as we avoid the overhead associated with hash maps.</p>
</blockquote>
<p>So far, we have not taken advantage of the fact that the input tree is a binary search tree (with duplicates). The first three approaches would work for <strong>any</strong> binary tree.</p>
<p>If you perform an inorder DFS traversal on a binary search tree (BST), you will handle the nodes in <strong>sorted</strong> order. Why?</p>
<p>Recall that in a BST, all nodes to the left are less than the current node and all nodes to the right are greater than the current node. In an inorder traversal, we handle all the nodes on the left first, then the current node, and then all the nodes to the right.</p>
<p>The fact that there are duplicates in the BSTs given in this problem does not change this property - we will still handle nodes in sorted order during an inorder traversal. So how does this help us? If we can obtain the nodes in sorted order, then we can find the most frequent elements without needing a hash map.</p>
<p>Let's say we have a list <code>values</code> that has all the values in the tree in sorted order. Any duplicated values must be adjacent to each other in this list since it is sorted. We can iterate over this list from left to right and keep count of a streak - how many of the same number we have seen in a row. Let's call our current streak <code>currStreak</code>, and the number we have seen most recently <code>currNum</code>. For each <code>num</code> we iterate over:</p>
<ul>
<li>If <code>num = currNum</code>, then we can increment <code>currStreak</code> by <code>1</code>.</li>
<li>If <code>num != currNum</code>, then we must start a new streak. We update <code>currNum = num</code> and reset <code>currStreak = 1</code>.</li>
</ul>
<p>We will also maintain the <code>maxStreak</code> we have seen so far. When we find a new streak with a longer length, i.e. <code>currStreak &gt; maxStreak</code>, we update <code>maxStreak</code> and reset the answer, since all the numbers stored in the answer are guaranteed not to be modes. When we find that <code>currStreak = maxStreak</code>, we can add the current <code>num</code> to the answer.</p>
<p>!?!../Documents/501.json:960,540!?!<br />
<br></p>
<p>Once we have finished iterating through the array, <code>maxStreak</code> represents the max frequency and our answer list <code>ans</code> will hold all the values that have this frequency.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Perform an inorder DFS using a recursive <code>dfs</code> function to traverse the input tree. At each <code>node</code>, add <code>node.val</code> to a list <code>values</code>.</li>
<li>Initialize variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>.</li>
<li>Iterate over <code>values</code>. At each <code>num</code>:
<ul>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/3Yvsv9sP/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During the DFS, we visit each node once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
<p>After the DFS, we iterate over <code>values</code> which has a length of <span class="math inline">\(n\)</span>. At each iteration, we perform <span class="math inline">\(O(1)\)</span> work. Overall, we perform <span class="math inline">\(O(n)\)</span> work.</p>
<p>You may notice that the runtime of this algorithm is faster than the first three approaches. This is because while hash map operations are <span class="math inline">\(O(1)\)</span>, the constant overhead still takes a little bit of time, especially compared to just using a list.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst-case scenario is <span class="math inline">\(O(n)\)</span>. Also, the <code>values</code> array always grows to a size of <span class="math inline">\(n\)</span>, and thus also uses <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-5-no-values-array">Approach 5: No &quot;Values&quot; Array</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach could be asked as a follow-up to the previous approach. It also satisfies the follow-up given in the problem description (at the bottom, under the constraints). The only extra space we will use in this approach is the call stack from recursion.</p>
</blockquote>
<p>In the previous approach, we perform an inorder traversal to create a <code>values</code> list. We then iterate over the <code>values</code> list. Do we need this extra list?</p>
<p>The answer is no: because by definition, the values we iterate over in <code>values</code> are the same values we visit during the inorder traversal, in the same order. Thus, we can perform the same logic on the fly during the inorder DFS, instead of performing DFS once to record the numbers in <code>values</code>, and then traversing <code>values</code> to count the recorded numbers.</p>
<p>We will use the same process: initialize <code>maxStreak, currStreak, currNum</code> as global variables. Perform an inorder traversal using recursion, and at each <code>node</code>, treat <code>num = node.val</code> and perform the same logic from the previous approach.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize global variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>.</li>
<li>Perform an inorder traversal from <code>root</code>. At each <code>node</code>:
<ul>
<li>If <code>node</code> is null, immediately exit the function.</li>
<li>Call <code>dfs(node.left)</code>.</li>
<li>Set <code>num = node.val</code>.</li>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
<li>Call <code>dfs(node.right)</code>.</li>
</ul>
</li>
<li>Return <code>ans.</code></li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/6ueeqDnu/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We perform a DFS, visiting each node in the tree once. At each node, we perform <span class="math inline">\(O(1)\)</span> work.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>During DFS, recursion is executed using the call stack. This call stack is equal to the depth of the tree, which in the worst case scenario is <span class="math inline">\(O(n)\)</span>.</p>
<p>Note that space used by the answer is not considered part of the space complexity. If we don't count the recursion call stack space either (as suggested in the problem description's follow-up), then this approach uses <span class="math inline">\(O(1)\)</span> space as we only use a few extra variables like <code>maxStreak, currStreak, currNum</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-6-true-constant-space-morris-traversal">Approach 6: True Constant Space: Morris Traversal</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This approach is very advanced and would not be expected in an interview. We have included it for completeness.</p>
</blockquote>
<p>We will continue using the same idea from the previous approach. Is there a way for us to perform the inorder traversal without using any space, including the recursion call stack?</p>
<p>Morris traversal is an advanced technique that allows us to traverse a binary tree with constant auxiliary space. In this approach, we will implement a variant of Morris traversal that will still allow us to achieve an <span class="math inline">\(O(1)\)</span> space complexity. To understand Morris traversal, we must first understand why a stack is &quot;necessary&quot; during DFS.</p>
<p><img src="../Figures/501/10.png" alt="example" /><br />
<br></p>
<p>In the above tree, we start at the root and move to the left child. Once we are finished fully handling the left subtree, we then handle the root, and finally the right subtree. The reason we use extra stack space during DFS is to &quot;remember&quot; the root and right subtree. Think about it: if we move to <code>root.left</code>, how can we get back to <code>root</code> and thus <code>root.right</code>?</p>
<p><img src="../Figures/501/11.png" alt="example" /><br />
<br></p>
<p>Furthermore, when we are the green node, how do we get back to the blue nodes? Let's assign each node a <strong>friend</strong>. A node's friend is the <strong>rightmost</strong> node in the left subtree. That is, to find the friend of <code>node</code>, we first do <code>node = node.left</code>, then do <code>node = node.right</code> until there is no right child.</p>
<p><img src="../Figures/501/12.png" alt="example" /><br />
<br></p>
<p>You may notice that some nodes will not have a friend. Namely, a node will not have a friend if it does not have a left child.</p>
<p><img src="../Figures/501/13.png" alt="example" /><br />
<br></p>
<p>Morris traversal takes advantage of the following facts:</p>
<blockquote>
<ol>
<li>
<p>All friends are unique. That is, a node cannot be the friend of more than one node.</p>
</li>
<li>
<p>Friend nodes do not have the right children. This is because, by definition, we find friend nodes by traversing right until there is no right child.</p>
</li>
</ol>
</blockquote>
<p>Thus, we can safely assign the right child of each friend to the node it is a friend to. In the following examples, we are numbering the nodes arbitrarily (these are not the values of a binary search tree):</p>
<p><img src="../Figures/501/14.png" alt="example" /><br />
<br></p>
<p>The rightmost node in the left subtree of the root is the node labeled <code>4</code>. Thus, we can assign the right child of <code>4</code> to the root.</p>
<p><img src="../Figures/501/15.png" alt="example" /><br />
<br></p>
<p>In these example images, green edges will indicate &quot;friend&quot; edges. Notice that now, we have a way back to the root (and thus the right subtree of the root) after entering the left subtree! Let's add the other friend edges.</p>
<p><img src="../Figures/501/16.png" alt="example" /><br />
<br></p>
<p>With these friend edges, we can now perform an inorder traversal without recursion or a stack! We start by handling the <code>3</code>, then use the friend edge to get back to <code>1</code>. We handle the <code>1</code>, then the <code>4</code>, and then use the friend edge to get back to the root. After handling the root, we handle the <code>5</code>, then use the friend edge to get back to the <code>2</code>, which is the final node in our inorder traversal.</p>
<p>Now comes the tricky part: how do we implement this idea? We will use the following process. First, initialize <code>curr = root</code>. This represents the current node that we iterating on. Next, we perform the following in a while loop until <code>curr = null</code>, indicating we have finished the traversal:</p>
<ul>
<li>If <code>curr.left != null</code>, we will find the <code>friend</code> of <code>curr</code>. After finding <code>friend</code>, we set <code>friend.right = curr</code> then move to the left subtree with <code>curr = curr.left</code>. Once we are in the left subtree, we should delete the edge to prevent any infinite loops.</li>
<li>If <code>curr.left = null</code>, it means there is no left subtree. We can handle this node now, then move to the right with <code>curr = curr.right</code>.</li>
</ul>
<p>We will quickly demonstrate the traversal using the previous example. At any given time, the green node is <code>curr</code>.</p>
<p><img src="../Figures/501/17.png" alt="example" /><br />
<br></p>
<p>Initially, <code>curr = root</code>. Because there is a left subtree, we will find the friend.</p>
<p><img src="../Figures/501/18.png" alt="example" /><br />
<br></p>
<p>We find the friend by moving to the left subtree, then moving right as much as we can. Set <code>friend.right = curr</code>. Next, we set <code>curr = curr.left</code>.</p>
<p><img src="../Figures/501/19.png" alt="example" /><br />
<br></p>
<p>After we move to the left subtree, we must delete the edge we used. This is is so when we return back to the root, we don't repeat the process we just performed (as without deleting the edge, <code>root.left != null</code>).</p>
<p><img src="../Figures/501/20.png" alt="example" /><br />
<br></p>
<p>Again, <code>curr.left != null</code>, so we find the <code>friend</code> and set <code>friend.right = curr</code>. Then we move to the left subtree and delete the edge.</p>
<p><img src="../Figures/501/21.png" alt="example" /><br />
<br></p>
<p>At the node labeled <code>3</code>, we have no left subtree. Thus we can now handle this node and move to <code>curr.right</code>, which you will notice is the friend edge we created earlier.</p>
<p><img src="../Figures/501/22.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/501/23.png" alt="example" /><br />
<br></p>
<p>The next two nodes, <code>1</code> and <code>4</code> are handled the same way. Notice that so far, we have handled nodes in the order <code>3, 1, 4</code>, which is the correct order for an inorder traversal. Now, we find ourselves back at the <code>root</code>. Because we deleted the left edge earlier, we now move to handle the <code>root</code> and move right.</p>
<p><img src="../Figures/501/24.png" alt="example" /><br />
<br></p>
<p><img src="../Figures/501/25.png" alt="example" /><br />
<br></p>
<p>We have reached another node where <code>curr.left != null</code>. We find the friend and set the right edge.</p>
<p><img src="../Figures/501/26.png" alt="example" /><br />
<br></p>
<p>At the node labeled <code>5</code>, we find that <code>curr.left = null</code>. Thus, we handle the node and then move right (back to the <code>2</code>, as we set this &quot;friend&quot; edge earlier).</p>
<p><img src="../Figures/501/27.png" alt="example" /><br />
<br></p>
<p>We finally handle the last node. The traversal ends as we move right, but there is no right child. We handled the nodes in the correct order: <code>3, 1, 4, 0, 5, 2</code>.</p>
<p>Finally, we solve the problem by using the same algorithm from the previous approach during our Morris traversal.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize variables <code>maxStreak, currStreak, currNum</code> to <code>0</code> and an empty list <code>ans</code>. Also, initialize <code>curr = root</code>.</li>
<li>While <code>curr != null</code>, perform Morris traversal:
<ul>
<li>If <code>curr.left != null</code>:
<ul>
<li>Find <code>friend</code>. We first set <code>friend = curr.left</code>, then move with <code>friend = friend.right</code> as long as <code>friend.right</code> exists.</li>
<li>Once <code>friend</code> is found, we set <code>friend.right = curr</code>.</li>
<li>Move to <code>curr.left</code> and delete the edge. You can do this by first saving <code>left = curr.left</code>, then setting <code>curr.left = null</code>, and finally performing <code>curr = left</code>.</li>
</ul>
</li>
<li>Otherwise, <code>curr.left = null</code>:
<ul>
<li>Set <code>num = curr.val</code>.</li>
<li>If <code>num = currNum</code>, increment <code>currStreak</code>. Otherwise, set <code>currStreak = 1, currNum = num</code>.</li>
<li>If <code>currStreak &gt; maxStreak</code>, update <code>maxStreak = currStreak</code> and reset <code>ans</code>.</li>
<li>If <code>currStreak = maxStreak</code>, add <code>num</code> to <code>ans</code>.</li>
<li>Perform <code>curr = curr.right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans.</code></li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: <code>friend</code> is a keyword in C++, so we will use <code>friendNode</code> as the variable name instead.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/8HrkiKo3/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the number of nodes in the tree,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>You may be thinking: there is a nested while loop, wouldn't this algorithm have a time complexity of <span class="math inline">\(O(n^2)\)</span>? The answer is no because the inner while loop can only iterate <span class="math inline">\(O(n)\)</span> times total across the entire algorithm.</p>
<p>In a binary tree with <span class="math inline">\(n\)</span> nodes, there are <span class="math inline">\(n - 1\)</span> edges. This is because every node except for the root has a parent. During a Morris traversal, we never use an edge more than twice. We use each edge once to move <code>curr</code> through the tree, and we use each edge another time to find friends.</p>
<p>This means we have <span class="math inline">\(O(2 \cdot (n - 1)) = O(n)\)</span> edge iterations. Thus, the Morris traversal overall costs <span class="math inline">\(O(n)\)</span>, since everything else we do costs <span class="math inline">\(O(1)\)</span>.</p>
<p>In Java, we need to convert <code>ans</code> to the correct type, but this doesn't change the time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer as part of the space complexity. The only extra space we use is a few extra variables like <code>maxStreak, currStreak, currNum</code>. Thus, we have achieved a true <span class="math inline">\(O(1)\)</span> space complexity.</p>
<p>Note that we are modifying the input in this algorithm, which may be considered a bad practice. Some people will also argue that by modifying the input, we should also include it in the space complexity.</p>
</li>
</ul>
<br/>
<p><strong>Morris Traversal Follow-Up</strong></p>
<p>As mentioned before, what we have implemented above is a variant of the traditional Morris traversal. One drawback to this variant is that the tree is heavily modified after the traversal. With some small changes, we can actually &quot;repair&quot; the tree to its original state while still accomplishing an <span class="math inline">\(O(1)\)</span> space traversal!</p>
<p>This article focused on the variant for the sake of brevity. We encourage any eager readers to try and implement the standard traversal on their own as a follow-up.</p>
<details>
<summary>Click here to see the solution!</summary>
<p><a href="https://leetcode.com/playground/X5m5zXQy/shared">code</a></p>
</details>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flatten-binary-tree-to-linked-list/description" target="_blank" rel="noopener noreferrer">Flatten Binary Tree to Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>

<ul>
	<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>
	<li>The &quot;linked list&quot; should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" style="width: 500px; height: 226px;" />
<pre>
<strong>Input:</strong> root = [1,2,5,3,4,null,6]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Flip Binary Tree To Match Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <code>n</code> nodes, where each node is uniquely assigned a value from <code>1</code> to <code>n</code>. You are also given a sequence of <code>n</code> values <code>voyage</code>, which is the <strong>desired</strong> <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order" target="_blank"><strong>pre-order traversal</strong></a> of the binary tree.</p>

<p>Any node in the binary tree can be <strong>flipped</strong> by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg" style="width: 400px; height: 187px;" />
<p>Flip the <strong>smallest</strong> number of nodes so that the <strong>pre-order traversal</strong> of the tree <strong>matches</strong> <code>voyage</code>.</p>

<p>Return <em>a list of the values of all <strong>flipped</strong> nodes. You may return the answer in <strong>any order</strong>. If it is <strong>impossible</strong> to flip the nodes in the tree to make the pre-order traversal match </em><code>voyage</code><em>, return the list </em><code>[-1]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/02/1219-01.png" style="width: 150px; height: 205px;" />
<pre>
<strong>Input:</strong> root = [1,2], voyage = [2,1]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> It is impossible to flip the nodes such that the pre-order traversal matches voyage.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" style="width: 150px; height: 142px;" />
<pre>
<strong>Input:</strong> root = [1,2,3], voyage = [1,3,2]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" style="width: 150px; height: 142px;" />
<pre>
<strong>Input:</strong> root = [1,2,3], voyage = [1,2,3]
<strong>Output:</strong> []
<strong>Explanation:</strong> The tree&#39;s pre-order traversal already matches voyage, so no nodes need to be flipped.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>n == voyage.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= Node.val, voyage[i] &lt;= n</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li>All the values in <code>voyage</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<p><strong>Intuition</strong></p>
<p>As we do a pre-order traversal, we will flip nodes on the fly to try to match our voyage with the given one.</p>
<p>If we are expecting the next integer in our voyage to be <code>voyage[i]</code>, then there is only at most one choice for path to take, as all nodes have different values.</p>
<p><strong>Algorithm</strong></p>
<p>Do a depth first search.  If at any node, the node's value doesn't match the voyage, the answer is <code>[-1]</code>.</p>
<p>Otherwise, we know when to flip: the next number we are expecting in the voyage <code>voyage[i]</code> is different from the next child.</p>
<p><a href="https://leetcode.com/playground/VzfWsiG2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flip-equivalent-binary-trees/description" target="_blank" rel="noopener noreferrer">Flip Equivalent Binary Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>For a binary tree <strong>T</strong>, we can define a <strong>flip operation</strong> as follows: choose any node, and swap the left and right child subtrees.</p>

<p>A binary tree <strong>X</strong>&nbsp;is <em>flip equivalent</em> to a binary tree <strong>Y</strong> if and only if we can make <strong>X</strong> equal to <strong>Y</strong> after some number of flip operations.</p>

<p>Given the roots of two binary trees <code>root1</code> and <code>root2</code>, return <code>true</code> if the two trees are flip equivalent or <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="Flipped Trees Diagram" src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" style="width: 500px; height: 220px;" />
<pre>
<strong>Input:</strong> root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
<strong>Output:</strong> true
<strong>Explanation: </strong>We flipped at nodes with values 1, 3, and 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root1 = [], root2 = []
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root1 = [], root2 = [1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each tree is in the range <code>[0, 100]</code>.</li>
	<li>Each tree will have <strong>unique node values</strong> in the range <code>[0, 99]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the roots of two <a href="https://leetcode.com/explore/learn/card/data-structure-tree/">binary trees</a> and we are asked to determine whether they are flip equivalent. To clarify, let’s break down the two key terms involved:</p>
<ol>
<li>Flip Operation:</li>
</ol>
<p>A flip operation involves selecting any node in the tree and swapping its left and right subtrees. The node's value and the internal structure of its subtrees remain unchanged. The only modification is that the positions of the node's direct children are swapped.</p>
<p>For example, consider the tree below. The tree on the left shows the initial structure, and the tree on the right shows the result after performing a flip on node 1.</p>
<p><img src="../Figures/951/951_flip_operation_example.png" alt="Flip operation example" /></p>
<ol start="2">
<li>Equivalent Trees:</li>
</ol>
<p>Two binary trees are considered equivalent if they satisfy the following conditions:</p>
<ul>
<li>Same structure: The arrangement of nodes and their subtrees (left and right) are identical.</li>
<li>Same node values: Every corresponding node in both trees has the same value.</li>
</ul>
<p>In this context, we want to determine whether two given binary trees can become equivalent by applying flip operations as needed.</p>
<hr />
<h3 id="approach-1-recursion-top-down-traversal">Approach 1: Recursion (Top-down Traversal)</h3>
<h4 id="intuition">Intuition</h4>
<p>Since binary trees are inherently recursive structures, a recursive approach is intuitive.</p>
<p>For each node, we have two possible options: either we swap its left and right subtrees, or we leave them as they are. We explore both possibilities for every node, starting from the root. If any sequence of flips results in the two trees becoming equivalent, our function will return <code>true</code>, indicating that the trees are flip equivalent. If no valid sequence leads to equivalence, the function returns <code>false</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>If both <code>root1</code> and <code>root2</code> are empty trees, they are considered flip equivalent according to the definition provided; return true.</p>
</li>
<li>
<p>If only one of <code>root1</code> or <code>root2</code> is empty, they are <strong>not</strong> flip equivalent, as they do not satisfy the structural property of equivalence; return false.</p>
</li>
<li>
<p>If <code>root1</code> and <code>root2</code> have different node values, the trees are <strong>not</strong> flip equivalent, since this means their corresponding nodes differ; return false.</p>
</li>
<li>
<p>Recursively check two scenarios for flip equivalence:</p>
<ul>
<li>No Swap: Check if the left subtree of <code>root1</code> is flip equivalent to the left subtree of <code>root2</code> and the right subtree of <code>root1</code> is flip equivalent to the right subtree of <code>root2</code>.</li>
<li>Swap: Check if the left subtree of <code>root1</code> is flip equivalent to the right subtree of <code>root2</code> and the right subtree of <code>root1</code> is flip equivalent to the left subtree of <code>root2</code>.</li>
</ul>
</li>
<li>
<p>Return <code>true</code> if either the <code>noSwap</code> or <code>swap</code> conditions are satisfied, as this confirms flip equivalence for the current nodes and their subtrees.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CJ8BnMSW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the smaller tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>This is because the recursion stops at the leaf nodes or when a mismatch occurs. In the worst case, every node in the smaller tree will be visited.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>This is due to the recursion stack. In the worst case, the recursion goes as deep as the tree's height, which can be <span class="math inline">\(O(N)\)</span> in the case of a skewed tree (a tree in which every internal node has only one child). For a balanced tree, the space complexity will be <span class="math inline">\(O(\log N)\)</span> because the tree's height would be logarithmic relative to the number of nodes.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dfs-using-a-stack">Approach 2: Iterative DFS (using a Stack)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>While a recursive method is intuitive, it can lead to issues such as stack overflow for very deep trees.</p>
<p>By using an iterative DFS approach with a stack, we can simulate the recursive process while maintaining control over the stack size. The idea is to push pairs of nodes onto the stack and evaluate their equivalence in a structured manner, ultimately determining if the trees can be made equivalent through flips.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define a helper function <code>checkNodeValues</code> to verify if two nodes should be considered equivalent:
<ul>
<li>If both <code>node1</code> and <code>node2</code> are <code>nullptr</code>, return <code>true</code>.</li>
<li>If both nodes are not <code>nullptr</code> and their values match, return <code>true</code>.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
</li>
<li>In the <code>flipEquiv</code> main function:
<ul>
<li>Initialize a stack <code>s</code> to store pairs of nodes (<code>node1</code>, <code>node2</code>) from <code>root1</code> and <code>root2</code>.</li>
<li>Push the root nodes of both trees onto the stack.</li>
</ul>
</li>
<li>While the stack is not empty:
<ul>
<li>Pop the top pair of nodes from the stack.</li>
<li>If both <code>node1</code> and <code>node2</code> are <code>nullptr</code>, continue to the next iteration.</li>
<li>If only one of the nodes is <code>nullptr</code>, return <code>false</code> (trees are not equivalent).</li>
<li>If the values of <code>node1</code> and <code>node2</code> do not match, return <code>false</code>.</li>
<li>Check both configurations for equivalence:
<ul>
<li>If the left child of <code>node1</code> matches the left child of <code>node2</code> and the right child of <code>node1</code> matches the right child of <code>node2</code>, push these pairs onto the stack for further examination.</li>
<li>If the left child of <code>node1</code> matches the right child of <code>node2</code> and the right child of <code>node1</code> matches the left child of <code>node2</code>, push these pairs onto the stack.</li>
</ul>
</li>
<li>If neither configuration is satisfied, return <code>false</code>.</li>
</ul>
</li>
<li>If the stack is emptied without returning <code>false</code>, return <code>true</code>, indicating that the two trees are flip equivalent.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/5u3Kb4Wy/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the smaller tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>Each node in the smaller tree will enter the stack at most twice (one with swap and one without). Therefore, the loop will run <span class="math inline">\(O(N)\)</span> times. Since the operations within the loop have a constant time complexity of <span class="math inline">\(O(1)\)</span>, the overall time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>The size of the stack can reach at most twice the number of nodes in the smaller tree, as each node can be pushed onto the stack in up to two configurations.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-canonical-forms">Approach 3: Canonical Forms</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We observe that the choice of tree for the flip operation does not affect the outcome. In fact, we can simultaneously perform flips on both trees to check for flip equivalence, and the result will remain unchanged.</p>
<p>This raises the question: what if we could apply flip operations to transform each tree into a standardized format that makes it easier to determine whether they are equivalent? This idea underpins the solution for determining flip equivalent binary trees using their canonical forms.</p>
<h5 id="canonical-form-of-a-binary-tree">Canonical Form of a Binary Tree</h5>
<p>A binary tree is in its canonical form if, for each node, one of the following conditions holds:</p>
<ul>
<li>The node has no children.</li>
<li>The node has only a left child.</li>
<li>The left child's value is greater than the right child's value.</li>
</ul>
<p>Interestingly, it turns out that two binary trees are flip-equivalent if and only if they have the same canonical form.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p><code>findCanonicalForm(TreeNode* root)</code> function:</p>
<ul>
<li>If <code>root</code> is null, return immediately (base case).</li>
<li>Perform a post-order traversal:
<ul>
<li>Recursively call <code>findCanonicalForm</code> on <code>root-&gt;left</code>.</li>
<li>Recursively call <code>findCanonicalForm</code> on <code>root-&gt;right</code>.</li>
</ul>
</li>
<li>If <code>root-&gt;right</code> is null, return as no further action is required.</li>
<li>If <code>root-&gt;left</code> is null, swap <code>root-&gt;left</code> and <code>root-&gt;right</code>, then set <code>root-&gt;right</code> to null to ensure <code>root-&gt;left</code> is non-empty. No further action is required; return.</li>
<li>If both <code>left</code> and <code>right</code> are non-null, swap them if <code>left-&gt;val</code> is greater than <code>right-&gt;val</code> to place them in a canonical order.</li>
</ul>
</li>
<li>
<p><code>areEquivalent(TreeNode* root1, TreeNode* root2)</code> function:</p>
<ul>
<li>If both <code>root1</code> and <code>root2</code> are null, return <code>true</code> (both trees are equivalent).</li>
<li>If one is null and the other is not, return <code>false</code> (they are not equivalent).</li>
<li>If the values of <code>root1</code> and <code>root2</code> are different, return <code>false</code> (they are not equivalent).</li>
<li>Recursively call <code>areEquivalent</code> for <code>root1-&gt;left</code> and <code>root2-&gt;left</code>, and for <code>root1-&gt;right</code> and <code>root2-&gt;right</code>, returning <code>true</code> only if both subtrees are equivalent.</li>
</ul>
</li>
<li>
<p><code>flipEquiv(TreeNode* root1, TreeNode* root2)</code> function:</p>
<ul>
<li>Call <code>findCanonicalForm</code> on <code>root1</code> to convert it to its canonical form.</li>
<li>Call <code>findCanonicalForm</code> on <code>root2</code> to convert it to its canonical form.</li>
<li>Return the result of <code>areEquivalent(root1, root2)</code> to determine if the two trees are equivalent.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZguNr8UL/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the bigger tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>The <code>findCanonicalForm</code> function processes each node in the tree exactly once, and since its inner operations, such as comparisons and swaps, have constant time complexity, the overall time complexity of this function is <span class="math inline">\(O(N)\)</span>.</p>
<p>Similarly, the <code>areEquivalent</code> function performs a depth-first search (DFS) on both trees, also visiting each node once. Therefore, its time complexity is <span class="math inline">\(O(N)\)</span>.</p>
<p>As both functions run independently and sequentially, the overall time complexity of the algorithm remains <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>.</p>
<p>This is due to the recursion stack. In the worst case, the recursion goes as deep as the height of the tree, which can be <span class="math inline">\(O(N)\)</span> in the case of a skewed tree (a tree in which every internal node has only one child). For a balanced tree, the space complexity will be <span class="math inline">\(O(\log N)\)</span> because the height of the tree would be logarithmic relative to the number of nodes.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/description" target="_blank" rel="noopener noreferrer">Height of Binary Tree After Subtree Removal Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary tree</strong> with <code>n</code> nodes. Each node is assigned a unique value from <code>1</code> to <code>n</code>. You are also given an array <code>queries</code> of size <code>m</code>.</p>

<p>You have to perform <code>m</code> <strong>independent</strong> queries on the tree where in the <code>i<sup>th</sup></code> query you do the following:</p>

<ul>
	<li><strong>Remove</strong> the subtree rooted at the node with the value <code>queries[i]</code> from the tree. It is <strong>guaranteed</strong> that <code>queries[i]</code> will <strong>not</strong> be equal to the value of the root.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>m</code><em> where </em><code>answer[i]</code><em> is the height of the tree after performing the </em><code>i<sup>th</sup></code><em> query</em>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>The queries are independent, so the tree returns to its <strong>initial</strong> state after each query.</li>
	<li>The height of a tree is the <strong>number of edges in the longest simple path</strong> from the root to some node in the tree.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png" style="width: 495px; height: 281px;" />
<pre>
<strong>Input:</strong> root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The diagram above shows the tree after removing the subtree rooted at node with value 4.
The height of the tree is 2 (The path 1 -&gt; 3 -&gt; 2).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;" />
<pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]
<strong>Output:</strong> [3,2,3,2]
<strong>Explanation:</strong> We have the following queries:
- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 4).
- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -&gt; 8 -&gt; 1).
- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -&gt; 8 -&gt; 2 -&gt; 6).
- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -&gt; 9 -&gt; 3).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= n</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li><code>m == queries.length</code></li>
	<li><code>1 &lt;= m &lt;= min(n, 10<sup>4</sup>)</code></li>
	<li><code>1 &lt;= queries[i] &lt;= n</code></li>
	<li><code>queries[i] != root.val</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The approaches outlined below have similar time and space complexities. Rather than representing significant improvements over one another, they offer different methods and perspectives for solving the problem. You can either review all of them and choose the one that appeals to you, or explore each one in detail to understand the various ways to tackle the problem.</p>
<hr />
<h3 id="approach-1-left-and-right-traversal">Approach 1: Left and Right Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem asks us to find the height of a tree (the longest path from the root) after removing a subtree rooted at nodes listed in <code>queries</code>.</p>
<p>A brute force solution would process each query separately by removing the specified subtree and recalculating the height of the remaining tree. However, this approach is inefficient due to its high time complexity.</p>
<p>To optimize, we can track the tree's height as we traverse from the root. For any node, the height after removing its subtree is simply the height of the tree before reaching that node. This allows us to avoid recalculating the height repeatedly.</p>
<p>We’ll perform a preorder traversal, tracking the maximum distance from the root. However, if the maximum height is achieved in the right subtree, we may miss it when traversing the left. To address this, we perform a second traversal in reverse preorder (root, right, left).</p>
<p>We maintain an array <code>heights</code> where <code>heights[i]</code> stores the tree height after removing the subtree rooted at node <code>i</code>. During the first traversal, we update <code>heights</code> with the height at each node as we explore its left and right subtrees. In the reverse traversal, we update <code>heights</code> if the current height is greater than the stored value.</p>
<p>Finally, we iterate over <code>queries</code> and return the corresponding heights for each specified node.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a static array <code>maxHeightAfterRemoval</code> to store the maximum height of the tree after removing each node.</li>
<li>a variable <code>currentMaxHeight</code> to 0, which will track the current maximum height during traversals.</li>
</ul>
</li>
</ul>
<p>Main method <code>treeQueries</code>:</p>
<ul>
<li>
<p>Call the <code>traverseLeftToRight</code> method with the root node and initial height 0.</p>
</li>
<li>
<p>Reset <code>currentMaxHeight</code> to 0 for the second traversal.</p>
</li>
<li>
<p>Now call the <code>traverseRightToLeft</code> method with the root node and initial height 0.</p>
</li>
<li>
<p>Initialize an array <code>queryResults</code> to store the results of the queries.</p>
</li>
<li>
<p>Iterate through the queries:</p>
<ul>
<li>For each query, retrieve the corresponding maximum height from <code>maxHeightAfterRemoval</code>.</li>
<li>Store this height in <code>queryResults</code>.</li>
</ul>
</li>
<li>
<p>Return the <code>queryResults</code> array.</p>
</li>
<li>
<p>Define a method <code>traverseLeftToRight</code>:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Store the current <code>currentMaxHeight</code> in <code>maxHeightAfterRemoval</code> for the current node's value.</li>
<li>Update <code>currentMaxHeight</code> to be the maximum of itself and the current height.</li>
<li>Recursively call <code>traverseLeftToRight</code> for the left and right child, incrementing the height.</li>
</ul>
</li>
<li>
<p>Define a method <code>traverseRightToLeft</code>:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Update <code>maxHeightAfterRemoval</code> for the current node's value to be the maximum of its current value and <code>currentMaxHeight</code>.</li>
<li>Update <code>currentMaxHeight</code> to be the maximum of the current height and itself.</li>
<li>Recursively call <code>traverseRightToLeft</code> for the right and left child, incrementing the height.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TynrBwcK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The solution performs two traversals of the binary tree, followed by processing the queries. In both the traversals, each node in the tree is visited exactly once. Thus, the traversals take linear time.</p>
<p>To process the queries, the algorithm iterates through the queries array once, taking <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n) + O(q) = O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by mainly 2 factors:</p>
<ol>
<li>The <code>maxHeightAfterRemoval</code> array, which has a fixed size of <span class="math inline">\(100,001\)</span>. This contributes <span class="math inline">\(O(1)\)</span> to the space complexity as it's constant regardless of input size.</li>
<li>The recursion stack used in the tree traversals. In the worst case (a completely unbalanced tree), this could reach a depth of <span class="math inline">\(n\)</span>, resulting in <span class="math inline">\(O(n)\)</span> space.</li>
</ol>
<p>Combining these factors, the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
<blockquote>
<p>Note: The size of the output array is not included in the space complexity calculations since it is a part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-single-traversal">Approach 2: Single Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's optimize our solution to use just one traversal. We'll perform a preorder traversal starting from the root, similar to our previous approach. During this traversal, we’ll track a variable <code>maxVal</code> representing the maximum height encountered so far.</p>
<p>For each node, we store its corresponding answer (the <code>maxVal</code> at that point) in a <code>resultMap</code> for quick lookups during queries. We’ll also keep track of the depth as we traverse.</p>
<p>To determine the maximum height if a node is removed, we consider two values:</p>
<ol>
<li>The current <code>maxVal</code> on the path from the root to the node.</li>
<li>The node’s depth plus one (to include itself) and the height of its sibling subtree.</li>
</ol>
<p>To calculate the height of a sibling subtree, we’ll use a memoized helper function that finds the maximum distance from a given node to its leaf nodes.</p>
<p>Starting the DFS from the root, we populate <code>resultMap</code> with heights for each node. Once the traversal completes, we can answer queries using the information stored in <code>resultMap</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>resultMap</code> to store the maximum height of the tree after removing each node.</li>
<li><code>heightCache</code> to store pre-computed heights of subtrees.</li>
</ul>
</li>
<li>
<p>Call the <code>dfs</code> method with initial parameters: root node, <code>depth</code> 0, <code>maxVal</code> 0, <code>resultMap</code>, and <code>heightCache</code>.</p>
</li>
<li>
<p>Initialize an array <code>result</code> to store the final query results.</p>
</li>
<li>
<p>Iterate through the queries:</p>
<ul>
<li>For each query, retrieve the corresponding maximum height from <code>resultMap</code>.</li>
<li>Store this height in the <code>result</code> array.</li>
</ul>
</li>
<li>
<p>Return the <code>result</code> array.</p>
</li>
<li>
<p>Define the <code>height</code> method to calculate the height of a tree:</p>
<ul>
<li>If the node is <code>null</code>, return -1.</li>
<li>If the height of the node is already in <code>heightCache</code>, return the cached value.</li>
<li>Calculate the height recursively as 1 plus the maximum of left and right subtree heights.</li>
<li>Store the calculated height in <code>heightCache</code>.</li>
<li>Return the calculated height.</li>
</ul>
</li>
<li>
<p>Define the <code>dfs</code> method for the depth-first search:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Store the current <code>maxVal</code> in <code>resultMap</code> for the current node's value.</li>
<li>Recursively call <code>dfs</code> for the left child:
<ul>
<li>Increment the depth.</li>
<li>Update maxVal as the maximum of current maxVal and (depth + 1 + height of right subtree).</li>
</ul>
</li>
<li>Recursively call <code>dfs</code> for the right child:
<ul>
<li>Increment the depth.</li>
<li>Update maxVal as the maximum of current maxVal and (depth + 1 + height of left subtree).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GFsjLbDT/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The main <code>dfs</code> function visits each node in the tree exactly once. For each node, it calls the <code>height</code> function (which uses memoization) to calculate the heights of the subtrees. In the worst case, when we first encounter a node, we might need to calculate its height by traversing its entire subtree. However, subsequent calls for the same node or its ancestors will use the memoized value. Given that each node is visited once by <code>dfs</code>, and each node's height is calculated once and then cached, the overall time complexity for processing the tree is <span class="math inline">\(O(n)\)</span>.</p>
<p>The algorithm also iterates over the <code>queries</code> array to create the result, taking <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>resultMap</code> and <code>heightCache</code> each take <span class="math inline">\(O(n)\)</span> space. The recursion stack for the DFS can go as deep as the height of the tree, which is <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-subtree-size">Approach 3: Subtree Size</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In a preorder traversal of a tree, a subtree starts at its root's index and ends at the index equal to the start index plus the subtree's size. If we know the index and size of the subtree to be removed, we can remove this section from the traversal list. The maximum depth in the remaining traversal then represents the tree’s maximum height after removal.</p>
<p>For example, given the indices and depths of nodes, removing a subtree will leave us with the highest depth among the remaining nodes as our answer. To understand this better, have a look at the visualization below:</p>
<p><img src="../Figures/2458_re/preorderdepth_fix.png" alt="" /></p>
<p>To implement this, we’ll perform a preorder traversal to:</p>
<ol>
<li>Assign an index to each node</li>
<li>Track the depth of each node</li>
</ol>
<p>We then create two arrays, <code>maxDepthsFromLeft</code> and <code>maxDepthsFromRight</code>, to store the maximum depth to the left and right of each index, respectively. These arrays are filled by iterating through the nodes and updating each index with the maximum of the previous result and the current node’s depth.</p>
<p>Finally, to process each query, we compute the result as the maximum of:</p>
<ol>
<li>The maximum depth from the left up to the starting index</li>
<li>The maximum depth from the right beyond the ending index, if available.</li>
</ol>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>nodeIndexMap</code> to store the index of each node value.</li>
<li><code>subtreeSize</code> to store the number of nodes in the subtree for each node.</li>
</ul>
</li>
<li>
<p>Initialize lists <code>nodeDepths</code>, <code>maxDepthFromLeft</code>, and <code>maxDepthFromRight</code> to store node depths and maximum depths from left and right.</p>
</li>
<li>
<p>Call the <code>dfs</code> method to populate <code>nodeIndexMap</code> and <code>nodeDepths</code>.</p>
</li>
<li>
<p>Store the total number of nodes in <code>totalNodes</code>.</p>
</li>
<li>
<p>Call <code>calculateSubtreeSize</code> method to populate the <code>subtreeSize</code> map.</p>
</li>
<li>
<p>Initialize <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code> with the first and last node depths respectively.</p>
</li>
<li>
<p>Iterate through the nodes to calculate <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code>:</p>
<ul>
<li>Update <code>maxDepthFromLeft</code> with the maximum of the previous max and current depth.</li>
<li>Update <code>maxDepthFromRight</code> with the maximum of the previous max and current depth (in reverse order).</li>
</ul>
</li>
<li>
<p>Reverse the <code>maxDepthFromRight</code> list.</p>
</li>
<li>
<p>Initialize an array <code>results</code> to store the query results.</p>
</li>
<li>
<p>Process each query. For each query node:</p>
<ul>
<li>Calculate the end index as the node's index minus 1.</li>
<li>Calculate the start index as the end index plus the subtree size plus 1.</li>
<li>Initialize <code>maxDepth</code> with the value from <code>maxDepthFromLeft</code> at the end index.</li>
<li>If the start index is within bounds, update <code>maxDepth</code> with the maximum of current <code>maxDepth</code> and the value from <code>maxDepthFromRight</code> at the start index.</li>
<li>Store the <code>maxDepth</code> in the <code>results</code> array.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define a method <code>dfs</code> for the depth-first search:</p>
<ul>
<li>If the current node is null, return.</li>
<li>Add the current node's value and index to <code>nodeIndexMap</code>.</li>
<li>Add the current depth to <code>nodeDepths</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the depth.</li>
</ul>
</li>
<li>
<p>Define a method <code>calculateSubtreeSize</code> :</p>
<ul>
<li>If the current node is <code>null</code>, return 0.</li>
<li>Recursively calculate the size of left and right subtrees.</li>
<li>Calculate the total size as left size plus right size plus 1.</li>
<li>Store the total size in <code>subtreeSize</code> for the current node.</li>
<li>Return the total size.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/X7rHFYHY/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>This solution employs a four-step approach to solve the problem:</p>
<ol>
<li>The initial depth-first search traverses each node once, populating <code>nodeIndexMap</code> and <code>nodeDepths</code>. This takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>The calculation of subtree sizes (<code>calculateSubtreeSize</code> method) also visits each node once, taking <span class="math inline">\(O(n)\)</span> time.</li>
<li>Computing <code>maxDepthFromLeft</code> and <code>maxDepthFromRight</code> involves iterating through the <code>nodeDepths</code> list once, which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Processing the queries and populating the result array takes <span class="math inline">\(O(q)\)</span> time.</li>
</ol>
<p>Summing up the parts, the algorithm has a time complexity of <span class="math inline">\(3 \cdot O(n) + O(q) = O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>nodeIndexMap</code> and <code>subtreeSize</code> maps each store information for every node, taking <span class="math inline">\(O(n)\)</span> space each. The <code>nodeDepths</code>, <code>maxDepthFromLeft</code>, and <code>maxDepthFromRight</code> lists each contain an entry for every node, also taking <span class="math inline">\(O(n)\)</span> space each.</p>
<p>Similar to the previous approach, the recursion stack has a <span class="math inline">\(O(n)\)</span> complexity.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-eulerian-tour">Approach 4: Eulerian Tour</h3>
<h4 id="intuition-3">Intuition</h4>
<p>The previous approach can be generalized using an Eulerian tour. An Eulerian tour traverses the tree such that each node is visited twice, once when first encountered, and again when leaving after exploring all its subtrees.</p>
<p><img src="../Figures/2458_re/eulertour_fix.png" alt="" /></p>
<p>In this tour, a subtree is bounded by the first and last occurrences of its root node. To find the maximum height of the tree after removing a subtree, we can simply look at the maximum depth before the first occurrence and after the last occurrence of the subtree's root node.</p>
<p>To create the Eulerian tour, we perform a DFS over the tree, recording the first and last occurrences of each node in the <code>firstOccurrence</code> and <code>lastOccurrence</code> maps, respectively, while tracking each node's depth.</p>
<p>Like the previous approach, we calculate <code>maxDepthLeft</code> and <code>maxDepthRight</code> for each node for quick access. For each query, we can then retrieve the maximum depths at the first and last occurrences of the queried node and return the greater of the two as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize a list <code>eulerTour</code> to store the Euler tour of the tree.</p>
</li>
<li>
<p>Initialize maps <code>nodeHeights</code>, <code>firstOccurrence</code>, and <code>lastOccurrence</code> to store information about each node.</p>
</li>
<li>
<p>Call the <code>dfs</code> function to build the Euler tour and populate the maps.</p>
</li>
<li>
<p>Set <code>tourSize</code> to the size of <code>eulerTour</code>.</p>
</li>
<li>
<p>Initialize arrays <code>maxDepthLeft</code> and <code>maxDepthRight</code> of size <code>tourSize</code>.</p>
</li>
<li>
<p>Set the first element of <code>maxDepthLeft</code> and last element of <code>maxDepthRight</code> to the height of the root node.</p>
</li>
<li>
<p>Iterate from 1 to <code>tourSize - 1</code>:</p>
<ul>
<li>Set <code>maxDepthLeft[i]</code> to the maximum of the previous max height and the current node's height.</li>
</ul>
</li>
<li>
<p>Iterate backward from <code>tourSize - 2</code> to 0:</p>
<ul>
<li>Set <code>maxDepthRight[i]</code> to the maximum of the next max height and the current node's height.</li>
</ul>
</li>
<li>
<p>Initialize an array <code>results</code> with the same length as <code>queries</code>.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Set <code>queryNode</code> to the current query value.</li>
<li>Calculate <code>leftMax</code> and <code>rightMax</code> as the max height to the left and right of the node's first occurrence, respectively.</li>
<li>Store the maximum of <code>leftMax</code> and <code>rightMax</code> in <code>results</code>.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define the <code>dfs</code> function:</p>
<ul>
<li>If the current node is <code>null</code>, return.</li>
<li>Add the current node's height to <code>nodeHeights</code>.</li>
<li>Set the first occurrence of the current node in <code>firstOccurrence</code>.</li>
<li>Add the current node's value to <code>eulerTour</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the height.</li>
<li>Set the last occurrence of the current node in <code>lastOccurrence</code>.</li>
<li>Add the current node's value to <code>eulerTour</code> again.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/hxAu4KY5/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The <code>dfs</code> method traverses each node twice (down and up) to construct the Euler tour, which takes <span class="math inline">\(O(n)\)</span> time. The <code>maxDepthLeft</code> and <code>maxDepthRight</code> arrays are then built by iterating over the Euler tour in both directions and since the tour has a length of <span class="math inline">\(2n\)</span>, this step also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Processing the queries takes <span class="math inline">\(O(q)\)</span> time, making the total time complexity <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The Euler tour, stored in a list, contains <span class="math inline">\(2 \cdot n\)</span> elements and occupies <span class="math inline">\(O(n)\)</span> space. Three maps - <code>nodeHeights</code>, <code>firstOccurrence</code>, and <code>lastOccurrence</code> - each store information for every node, also taking <span class="math inline">\(O(n)\)</span> space. Two arrays, <code>maxDepthLeft</code> and <code>maxDepthRight</code>, mirror the Euler tour's length and consume <span class="math inline">\(O(n)\)</span> space each. Additionally, the recursion stack, as is typical, requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-two-largest-cousins">Approach 5: Two Largest Cousins</h3>
<h4 id="intuition-4">Intuition</h4>
<p>At any node, the longest path through it is the sum of its depth and the height of its subtree. For each depth, the maximum tree height at that level will be the depth plus the maximum height of any node at that depth.</p>
<p><img src="../Figures/2458_re/cousinheights_fix.png" alt="" /></p>
<p>To optimize this, we organize nodes by their depths and precalculate their heights. If a query removes a node, we find the maximum height at that depth, excluding the removed node.</p>
<p>To streamline further, the maximum height from a given depth can be found using two precomputed values:</p>
<ol>
<li>The maximum height at that depth, excluding the current node.</li>
<li>The second-highest height at that depth, if the maximum height subtree is removed.</li>
</ol>
<p>Thus, we only need the two largest heights at each depth. We maintain two lists, <code>firstLargestHeight</code> and <code>secondLargestHeight</code>, where each index stores the two largest heights for each depth. We then use DFS to populate these lists, along with each node's depth and height. For each query, if a node’s height matches the largest height at its depth, we return the second-largest height at that level; otherwise, we return the largest height.</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>
<p>Initialize a map:</p>
<ul>
<li><code>nodeDepths</code> to store the depth of each node.</li>
<li><code>subtreeHeights</code> to store the height of the subtree rooted at each node.</li>
</ul>
</li>
<li>
<p>Initialize maps <code>firstLargestHeight</code> and <code>secondLargestHeight</code> to store the first and second largest heights at each level.</p>
</li>
<li>
<p>Call the <code>dfs</code> function to populate these maps.</p>
</li>
<li>
<p>Initialize an array <code>results</code> with the same length as <code>queries</code>.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
<ul>
<li>Set <code>queryNode</code> to the current query value.</li>
<li>Set <code>nodeLevel</code> to the depth of the query node.</li>
<li>If the height of the query node's subtree equals the first largest height at its level:
<ul>
<li>Set the result to the sum of node level and second largest height at that level, minus 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Otherwise:</p>
<ul>
<li>Set the result to the sum of node level and first largest height at that level, minus 1.</li>
</ul>
</li>
<li>
<p>Return the <code>results</code> array.</p>
</li>
<li>
<p>Define the <code>dfs</code> function:</p>
<ul>
<li>If the current node is <code>null</code>, return 0.</li>
<li>Add the current node's depth to <code>nodeDepths</code>.</li>
<li>Recursively call <code>dfs</code> for left and right children, incrementing the level.</li>
<li>Calculate <code>currentHeight</code> as 1 plus the maximum of left and right subtree heights.</li>
<li>Add the current node's subtree height to <code>subtreeHeights</code>.</li>
<li>Set <code>currentFirstLargest</code> to the first largest height at the current level.</li>
<li>If <code>currentHeight</code> is greater than <code>currentFirstLargest</code>:
<ul>
<li>Update <code>secondLargestHeight</code> at the current level with <code>currentFirstLargest</code>.</li>
<li>Update <code>firstLargestHeight</code> at the current level with <code>currentHeight</code>.</li>
</ul>
</li>
<li>Else if <code>currentHeight</code> is greater than the second largest height at the current level:
<ul>
<li>Update <code>secondLargestHeight</code> at the current level with <code>currentHeight</code>.</li>
</ul>
</li>
<li>Return <code>currentHeight</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: The C++ implementation opts for vectors instead of unordered_maps. This choice stems from unordered_maps' reputation for slower performance in certain scenarios.</p>
</blockquote>
<h4 id="implementation-4">Implementation</h4>
<p><a href="https://leetcode.com/playground/5NYL6aFg/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree, and <span class="math inline">\(q\)</span> be the number of queries.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The <code>dfs</code> method traverses each node in the tree exactly once. For each node, it performs several comparison and update operations, all of which take constant time. So, this step takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>To process each query, the algorithm does some map lookups and a comparison, both taking constant time. Thus, processing all the queries requires <span class="math inline">\(O(q)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>nodeDepths</code> and <code>subtreeHeights</code> maps store information for every node, taking <span class="math inline">\(O(n)\)</span> space each.</p>
<p>The <code>firstLargestHeight</code> and <code>secondLargestHeight</code> maps typically store <span class="math inline">\(log n\)</span> (balanced trees) elements, but in the worst case (skewed trees), could store information for all <span class="math inline">\(n\)</span> levels. Thus, these take a further <span class="math inline">\(O(n)\)</span> space.</p>
<p>The recursion stack goes as deep as the height of the tree, which can be <span class="math inline">\(n\)</span> in the worst case.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/house-robber-iii/description" target="_blank" rel="noopener noreferrer">House Robber III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p>

<p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p>

<p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" style="width: 277px; height: 293px;" />
<pre>
<strong>Input:</strong> root = [3,2,3,null,3,null,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" style="width: 357px; height: 293px;" />
<pre>
<strong>Input:</strong> root = [3,4,5,1,3,null,1]
<strong>Output:</strong> 9
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increasing-order-search-tree/description" target="_blank" rel="noopener noreferrer">Increasing Order Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" style="width: 600px; height: 350px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" style="width: 300px; height: 114px;" />
<pre>
<strong>Input:</strong> root = [5,1,7]
<strong>Output:</strong> [1,null,5,null,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/insert-into-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Insert into a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>

<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" style="width: 752px; height: 221px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 5
<strong>Output:</strong> [4,2,7,1,3,5]
<strong>Explanation:</strong> Another accepted tree is:
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" style="width: 352px; height: 301px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25
<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
<strong>Output:</strong> [4,2,7,1,3,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>
	<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>
	<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/description" target="_blank" rel="noopener noreferrer">Insufficient Nodes in Root to Leaf Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>limit</code>, delete all <strong>insufficient nodes</strong> in the tree simultaneously, and return <em>the root of the resulting binary tree</em>.</p>

<p>A node is <strong>insufficient</strong> if every root to <strong>leaf</strong> path intersecting this node has a sum strictly less than <code>limit</code>.</p>

<p>A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png" style="width: 500px; height: 207px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1
<strong>Output:</strong> [1,2,3,4,null,null,7,8,9,null,14]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-3.png" style="width: 400px; height: 274px;" />
<pre>
<strong>Input:</strong> root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22
<strong>Output:</strong> [5,4,8,11,null,17,4,7,null,null,null,5]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/06/11/screen-shot-2019-06-11-at-83301-pm.png" style="width: 250px; height: 199px;" />
<pre>
<strong>Input:</strong> root = [1,2,-3,-5,null,4,null], limit = -1
<strong>Output:</strong> [1,null,-3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= limit &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/invert-binary-tree/description" target="_blank" rel="noopener noreferrer">Invert Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" style="width: 500px; height: 165px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3,6,9]
<strong>Output:</strong> [4,7,2,9,6,3,1]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" style="width: 500px; height: 120px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,3,1]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-largest-element-in-a-stream/description" target="_blank" rel="noopener noreferrer">Kth Largest Element in a Stream</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are part of a university admissions office and need to keep track of the <code>kth</code> highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.</p>

<p>You are tasked to implement a class which, for a given integer&nbsp;<code>k</code>, maintains a stream of test scores and continuously returns the&nbsp;<code>k</code>th highest test score&nbsp;<strong>after</strong>&nbsp;a new score has been submitted. More specifically, we are looking for the <code>k</code>th highest score in the sorted list of all scores.</p>

<p>Implement the&nbsp;<code>KthLargest</code> class:</p>

<ul>
	<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of test scores&nbsp;<code>nums</code>.</li>
	<li><code>int add(int val)</code> Adds a new test score&nbsp;<code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the pool of test scores so far.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]<br />
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[null, 4, 5, 5, 8, 8]</span></p>

<p><strong>Explanation:</strong></p>

<p>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);<br />
kthLargest.add(3); // return 4<br />
kthLargest.add(5); // return 5<br />
kthLargest.add(10); // return 5<br />
kthLargest.add(9); // return 8<br />
kthLargest.add(4); // return 8</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]<br />
[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[null, 7, 7, 7, 8]</span></p>

<p><strong>Explanation:</strong></p>
KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);<br />
kthLargest.add(2); // return 7<br />
kthLargest.add(10); // return 7<br />
kthLargest.add(9); // return 7<br />
kthLargest.add(9); // return 8</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length + 1</code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Imagine a university admissions office wants to keep track of the <code>k-th</code> highest test scores from applicants in real time. This allows them to dynamically determine the cut-off score as new applications come in. To achieve this, we'll create a class <code>KthLargest</code> that can return the <code>k-th</code> largest element for an incoming stream of numbers. Specifically, we need to implement:</p>
<ol>
<li>The constructor <code>KthLargest(int k, int[] nums)</code>, which initializes the class with <code>k</code> and the initial stream of numbers <code>num</code>,</li>
<li>The function <code>add(int val)</code>, which adds a new number <code>val</code> into the existing stream of numbers, and returns the <code>k-th</code> largest element of the updated stream.</li>
</ol>
<h3 id="approach-1-maintain-sorted-list">Approach 1: Maintain Sorted List</h3>
<h3 id="intuition">Intuition</h3>
<p>In this problem, we need to be able to repeatedly fetch the <code>k-th</code> largest element from a growing stream of numbers. Suppose we assume that the stream of numbers is always sorted in ascending order. In that case, returning the <code>k-th</code> largest element becomes a straightforward operation of fetching the <code>k-th</code> element from the end of the stream.</p>
<p>Thus, one approach is to maintain a list that stores the entire stream of numbers seen so far, and ensure the list remains sorted each time we add a new element. This allows us to fetch the <code>k-th</code> largest element with no extra work.</p>
<p>For our constructor, we can initialize our list <code>stream</code> with the initial set of numbers <code>nums</code> provided, and then sort <code>stream</code> in ascending order.</p>
<p>For every new <code>val</code> added to the <code>stream</code> by the <code>add(int val)</code> call, we ensure <code>val</code> is inserted at the correct position so that <code>stream</code> remains sorted. Because <code>stream</code> is sorted beforehand, we can efficiently find the correct position for <code>val</code> by using <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search</a>.</p>
<p>For this binary search insertion:</p>
<ol>
<li>We start with the entirety of <code>stream</code> as our search space</li>
<li>We check the middle element <code>stream[mid]</code>
<ul>
<li>If <code>stream[mid] == val</code> then we know that we can add <code>val</code> at index <code>mid</code></li>
<li>If <code>stream[mid] &lt; val</code>, then <code>val</code> needs to be added to the right of <code>stream[mid]</code>, so we limit the search space to the right half of <code>stream</code>.</li>
<li>If <code>stream[mid]</code> is greater than <code>val</code>,<code>val</code> needs to be added to the left of <code>stream[mid]</code>, so we limit the search space to the left half of <code>stream</code>.</li>
</ul>
</li>
<li>We can repeat this procedure until we narrow down our search space to the correct index to add <code>val</code>.</li>
</ol>
<p>After inserting <code>val</code> in the correct position, we can return <code>stream[stream.length - k]</code>, which is the <code>k-th</code> largest element in the stream.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>In the constructor:
<ul>
<li>Initialize class variable <code>k</code></li>
<li>Initialize class variable list <code>stream</code></li>
<li>Add all of <code>nums</code> to <code>stream</code>, used to keep track of the total stream.</li>
<li>Sort <code>stream</code> in ascending order</li>
</ul>
</li>
<li>In the <code>add(int val)</code> function:
<ul>
<li>Call helper function <code>getIndex(int val)</code> to find the index <code>i</code> to add <code>val</code></li>
<li>Insert <code>val</code> in <code>stream</code> at index <code>i</code></li>
<li>Return the <code>k-th</code> largest element in <code>stream</code>, at index <code>stream.size() - k</code></li>
</ul>
</li>
<li>In the <code>getIndex(int val)</code>:
<ul>
<li><strong>Define starting search space</strong>: Initialize <code>left</code> to <code>0</code> and <code>right</code> to <code>stream.size() - 1</code></li>
<li>While <code>left &lt;= right</code>:
<ul>
<li><strong>Calculate index for middle element</strong>: Initialize <code>mid</code> to <code>(left + right) / 2</code></li>
<li><strong>Get middle element</strong>: Initialize <code>midElement</code> to <code>stream.get(mid)</code></li>
<li>If <code>midElement == val</code> return <code>mid</code></li>
<li>If <code>midElement &gt; val</code>:
<ul>
<li><strong>Go to left half of search space</strong>: Reassign <code>right</code> to <code>mid - 1</code></li>
</ul>
</li>
<li>If <code>midElement &lt; val</code>:
<ul>
<li><strong>Go to right half of search space</strong>: Reassign <code>left</code> to <code>mid + 1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/eBbNQ3hn/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(M\)</span> be the size of the initial stream <code>nums</code> given in the constructor. Let <span class="math inline">\(N\)</span> be the number of calls of <code>add</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^2 + N \cdot M)\)</span></p>
<p>The constructor involves creating a list <code>stream</code> from <code>nums</code>, which takes <span class="math inline">\(O(M)\)</span> time. Then, sorting this list takes <span class="math inline">\(O(M \cdot \log M)\)</span> time. Thus, the time complexity of the constructor is <span class="math inline">\(O(M \cdot \log M)\)</span> time.</p>
<p>The <code>add</code> function involves running a binary search on <code>stream</code>. Because the total size of <code>stream</code> at the end would be <span class="math inline">\(O(M + N)\)</span>, each binary search is bounded by a time complexity of <span class="math inline">\(O(\log(M + N))\)</span>. Moreover, adding a number in <code>stream</code> can take worst-case <span class="math inline">\(O(M + N)\)</span> time, as adding an element in the middle of a list can offset all the elements to its right. Then, the time complexity of a single <code>add</code> call would be <span class="math inline">\(O(M + N + \log(M + N))\)</span>. Because <code>add</code> is called <span class="math inline">\(N\)</span> times, the time complexity of all the <code>add</code> calls would be <span class="math inline">\(O(N \cdot (M + N + \log(M + N)))\)</span>.</p>
<p>We see that after expanding the time complexity for the <code>add</code> function, the <span class="math inline">\(N \cdot M\)</span> and <span class="math inline">\(N^2\)</span> terms dominate all the other <span class="math inline">\(\log\)</span> terms in our calculations, so the total time complexity is <span class="math inline">\(O(N^2 + N \cdot M)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>The maximum size for <code>stream</code> is <span class="math inline">\(M + N\)</span>, so the total space complexity is <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-heap">Approach 2: Heap</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, sorting the entire stream of numbers seems unnecessary because we only need the <code>k-th</code> largest element. Maintaining a sorted list becomes costly as its size increases. To optimize, we can focus on only the necessary elements for retrieving and updating the <code>k-th</code> largest element.</p>
<p>!?!../Documents/703/slideshow1.json:960,540!?!</p>
<p>Consider a stream of numbers <code>[0, 4, 6, 9]</code> where <code>k = 3</code> and incoming <code>val = 2</code>. Before adding <code>2</code>, the <code>k-th</code> largest element is <code>4</code>. Adding <code>2</code> does not affect <code>4</code>'s position since <code>2</code> is smaller. Now, if the incoming value is <code>7</code>, which is greater than both <code>4</code> and <code>6</code>, <code>7</code> would become the 2nd largest number, pushing <code>6</code> to be the new <code>k-th</code> largest element, and <code>4</code> is no longer in the top <code>k</code>.</p>
<p>!?!../Documents/703/slideshow2.json:960,540!?!</p>
<p>From this example, we see that keeping track of just the <code>k</code> largest elements allows us to efficiently maintain the <code>k-th</code> largest element:</p>
<ol>
<li><strong>If an incoming element <code>val</code> is smaller than or equal to the existing <code>k-th</code> largest element</strong>: The <code>k</code> largest elements remain unchanged, and we can return the current <code>k-th</code> largest element.</li>
<li><strong>If <code>val</code> is larger than the current <code>k-th</code> largest element</strong>: It replaces the current <code>k-th</code> largest element. After adding <code>val</code>, the new <code>k-th</code> largest element is the next largest element.</li>
</ol>
<p>To efficiently maintain the <code>k</code> largest elements, we use a min-heap. In a min-heap, elements are organized such that the smallest element is always at the top (root node), providing <span class="math inline">\(O(1)\)</span> access time. Adding elements and removing the top element from the min-heap can be done in <span class="math inline">\(O(\log n)\)</span> time.</p>
<p>For our problem, the min-heap will contain the <code>k</code> largest elements, with the <code>k-th</code> largest element at the top. If a new <code>val</code> is greater than the <code>k-th</code> largest element, we add <code>val</code> to the heap and remove the top element, keeping the heap size at <code>k</code> and updating the <code>k-th</code> largest element.</p>
<p>In our optimized approach, we initialize the min-heap with the initial stream <code>nums</code> in the constructor and ensure it contains only the <code>k</code> largest elements. In the <code>add(int val)</code> function, if <code>val</code> is smaller than the current <code>k-th</code> largest element and the heap already contains <code>k</code> elements, we return the top element. Otherwise, we add <code>val</code>, remove the top element if the heap size exceeds <code>k</code>, and return the updated top element.</p>
<p>This approach is more efficient in both time and space complexity compared to maintaining a fully sorted list, as the relaxed ordering of a heap allows quick access and updates to the <code>k</code> largest elements without the overhead of sorting the entire stream.</p>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>In the constructor:
<ul>
<li>Initialize class variable <code>k</code> to the input value <code>k</code></li>
<li>Initialize a class <code>PriorityQueue</code> <code>minHeap</code> to hold the <code>k</code> largest elements</li>
<li>Iterate through each element <code>num</code> in the initial stream <code>nums</code>:
<ul>
<li>Call <code>add(num)</code></li>
</ul>
</li>
</ul>
</li>
<li>In the <code>add(int val)</code> function:
<ul>
<li>If <code>val</code> is greater than the smallest element in <code>minHeap</code> or the size of <code>minHeap</code> is less than <code>k</code> elements:
<ul>
<li>Add <code>val</code> to <code>minHeap</code></li>
<li>If the size of <code>minHeap</code> is greater than <code>k</code>, then remove the top element</li>
</ul>
</li>
<li>Return the top element as the <code>k-th</code> largest element in the stream</li>
</ul>
</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/7W8gK6JG/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(M\)</span> be the size of the initial stream <code>nums</code> given in the constructor, and let <span class="math inline">\(N\)</span> be the number of calls to <code>add</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((M + N) \cdot \log k)\)</span></p>
<p>The <code>add</code> function involves adding and removing an element from a heap of size <span class="math inline">\(k\)</span>, which is an <span class="math inline">\(O( \log k)\)</span> operation. Since the <code>add</code> function is called <span class="math inline">\(N\)</span> times, the total time complexity for all <code>add</code> calls is <span class="math inline">\(O(N \cdot \log k)\)</span>.</p>
<p>The constructor also calls <code>add</code> <span class="math inline">\(M\)</span> times to initialize the heap, leading to a time complexity of <span class="math inline">\(O(M \cdot \log k)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((M + N) \cdot \log k)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The <code>minHeap</code> maintains at most <span class="math inline">\(k\)</span> elements, so the space complexity is <span class="math inline">\(O(k)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree/description" target="_blank" rel="noopener noreferrer">K-th Largest Perfect Subtree Size in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary tree</strong> and an integer <code>k</code>.</p>

<p>Return an integer denoting the size of the <code>k<sup>th</sup></code> <strong>largest<em> </em>perfect binary</strong><em> </em><span data-keyword="subtree">subtree</span>, or <code>-1</code> if it doesn&#39;t exist.</p>

<p>A <strong>perfect binary tree</strong> is a tree where all leaves are on the same level, and every parent has two children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmpresl95rp-1.png" style="width: 400px; height: 173px;" /></p>

<p>The roots of the perfect binary subtrees are highlighted in black. Their sizes, in non-increasing order are <code>[3, 3, 1, 1, 1, 1, 1, 1]</code>.<br />
The <code>2<sup>nd</sup></code> largest size is 3.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,4,5,6,7], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmp_s508x9e-1.png" style="width: 300px; height: 189px;" /></p>

<p>The sizes of the perfect binary subtrees in non-increasing order are <code>[7, 3, 3, 1, 1, 1, 1]</code>. The size of the largest perfect binary subtree is 7.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">root = [1,2,3,null,4], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/10/14/tmp74xnmpj4-1.png" style="width: 250px; height: 225px;" /></p>

<p>The sizes of the perfect binary subtrees in non-increasing order are <code>[1, 1]</code>. There are fewer than 3 perfect binary subtrees.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 2000</code></li>
	<li><code>1 &lt;= k &lt;= 1024</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Kth Largest Sum in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree and a positive integer <code>k</code>.</p>

<p>The <strong>level sum</strong> in the tree is the sum of the values of the nodes that are on the <strong>same</strong> level.</p>

<p>Return<em> the </em><code>k<sup>th</sup></code><em> <strong>largest</strong> level sum in the tree (not necessarily distinct)</em>. If there are fewer than <code>k</code> levels in the tree, return <code>-1</code>.</p>

<p><strong>Note</strong> that two nodes are on the same level if they have the same distance from the root.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png" style="width: 301px; height: 284px;" />
<pre>
<strong>Input:</strong> root = [5,8,9,2,1,3,7,4,6], k = 2
<strong>Output:</strong> 13
<strong>Explanation:</strong> The level sums are the following:
- Level 1: 5.
- Level 2: 8 + 9 = 17.
- Level 3: 2 + 1 + 3 + 7 = 13.
- Level 4: 4 + 6 = 10.
The 2<sup>nd</sup> largest level sum is 13.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png" style="width: 181px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2,null,3], k = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> The largest level sum is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a binary tree and an integer <code>k</code>, where we want to find the <code>k-th</code> largest level sum of the tree. A level sum of a tree for a given level can be defined as the sum of the values of all nodes that all have equal distance from the <code>root</code>.</p>
<h3 id="approach-1-level-order-traversal--max-heap">Approach 1: Level Order Traversal + Max Heap</h3>
<h3 id="intuition">Intuition</h3>
<p>To calculate the sum of each level in a tree, we can use level order traversal, which processes nodes level by level. This is similar to breadth-first search (BFS), where we visit all neighbors of a node before moving on. However, unlike traditional BFS, all nodes at a given level are processed together in level-order traversal. So, for each level <code>i</code>, we visit all nodes and maintain a <code>sum</code> variable to track the sum of nodes for that level.</p>
<p>Since we need to find the <code>k-th</code> largest sum, we can store each level's sum in a max heap. By removing the first <code>k-1</code> elements from the heap, the <code>k-th</code> largest element remains at the top and can be accessed directly.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Initialize a max heap/priority queue <code>pq</code></li>
<li>Initialize a queue <code>bfsQueue</code> to maintain the ordering of which nodes to visit for our level order traversal</li>
<li>Start by adding <code>root</code> to <code>bfsQueue</code></li>
<li>Perform level order traversal. While <code>bfsQueue</code> is not empty:
<ul>
<li>Initialize <code>size</code> to be the current number of nodes of <code>bfsQueue</code>, which are all the nodes for the current level that we want to visit</li>
<li>For <code>size</code> iterations:
<ul>
<li>Initialize <code>sum</code> to <code>0</code></li>
<li>Visit the next node by removing the next node in <code>bfsQueue</code>. Store it in <code>poppedNode</code></li>
<li>Update <code>sum</code>: <code>sum += poppedNode.val</code></li>
<li>Add the left and right children of <code>poppedNode</code> to the queue, if they exist. These children will be a part of the next level of the tree that will be visited in the next iteration.</li>
</ul>
</li>
<li><code>sum</code> now contains a level order sum. Add it to <code>pq</code></li>
</ul>
</li>
<li>If <code>pq</code> has less than <code>k</code> sums, then return -1 because we have less than <code>k</code> levels in our tree</li>
<li>Otherwise, remove the first <code>k-1</code> elements from <code>pq</code>, and then return the top element: <code>pq.peek()</code></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/iupTHRrb/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the total number of nodes in our tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((N + K) \cdot \log N)\)</span></p>
<p>The level order traversal takes <span class="math inline">\(O(N)\)</span> time. Since our heap can have a maximum of <span class="math inline">\(O(N)\)</span> elements, adding a sum to the heap takes <span class="math inline">\(O(\log N)\)</span> time, resulting in a total heap build time of <span class="math inline">\(O(N \cdot \log N)\)</span>. Popping <span class="math inline">\(k-1\)</span> elements from the heap takes <span class="math inline">\(O(k \cdot \log N)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O((N + K) \cdot \log N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space usage is determined by both the level-order traversal queue and the heap. The queue, which reaches its maximum size when storing all nodes at the last level, requires <span class="math inline">\(O(N)\)</span> space. The heap, in the worst case (such as when the tree is a single path of <span class="math inline">\(N\)</span> nodes), can also take up to <span class="math inline">\(O(N)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-level-order-traversal--min-heap">Approach 2: Level Order Traversal + Min Heap</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, our max heap stored sums for all levels of the tree, making heap operations costly. In Approach 2, we use a min heap instead, where the smallest level sum is at the top. As we add new level sums, if the heap size exceeds <code>k</code>, we remove the top element. This ensures that, after processing all level sums, our heap contains the <code>k</code> largest sums, with the <code>k-th</code> largest at the top, which we can return. All smaller sums would have been evicted earlier whenever the heap size exceeded <code>k</code>. By limiting the heap size to <code>k</code>, where <span class="math inline">\(k \leq \log N\)</span>, we reduce the overall time complexity.</p>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Initialize a min heap/priority queue <code>pq</code></li>
<li>Initialize a queue <code>bfsQueue</code> to maintain the ordering of which nodes to visit for our level order traversal</li>
<li>Start by adding <code>root</code> to <code>bfsQueue</code></li>
<li>Perform level order traversal. While <code>bfsQueue</code> is not empty:
<ul>
<li>Initialize <code>size</code> to be the current number of nodes of <code>bfsQueue</code>, which are all the nodes for the current level that we want to visit</li>
<li>For <code>size</code> iterations:
<ul>
<li>Initialize <code>sum</code> to <code>0</code></li>
<li>Visit the next node by removing the next node in <code>bfsQueue</code>. Store it in <code>poppedNode</code></li>
<li>Update <code>sum</code>: <code>sum += poppedNode.val</code></li>
<li>Add the left and right children of <code>poppedNode</code> to the queue, if they exist. These children will be a part of the next level of the tree that will be visited in the next iteration.</li>
</ul>
</li>
<li><code>sum</code> now contains a level order sum. Add it to <code>pq</code></li>
<li>If size of <code>pq</code> now exceeds <code>k</code> elements, remove the top element.</li>
</ul>
</li>
<li>If <code>pq</code> has less than <code>k</code> sums, then return -1 because we have less than <code>k</code> levels in our tree</li>
<li>Top element is the <code>k-th</code> largest sum so return it: <code>pq.peek()</code></li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/AHjgz2oC/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the total number of nodes in our tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot \log k)\)</span></p>
<p>The level order traversal requires <span class="math inline">\(O(N)\)</span> time. We add to the heap a maximum of <span class="math inline">\(O(N)\)</span> times, with a maximum heap size of <span class="math inline">\(k\)</span>, so building the heap takes <span class="math inline">\(O(N \cdot \log k)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is dominated by the level order traversal queue and the heap. The queue will reach <span class="math inline">\(O(N)\)</span> at the last level, while the heap has a maximum size of <span class="math inline">\(O(k)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-element-in-a-bst/description" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" style="width: 212px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [3,1,4,null,2], k = 1
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" style="width: 382px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/leaf-similar-trees/description" target="_blank" rel="noopener noreferrer">Leaf-Similar Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Consider all the leaves of a binary tree, from&nbsp;left to right order, the values of those&nbsp;leaves form a <strong>leaf value sequence</strong><em>.</em></p>

<p><img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" style="width: 400px; height: 336px;" /></p>

<p>For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>

<p>Two binary trees are considered <em>leaf-similar</em>&nbsp;if their leaf value sequence is the same.</p>

<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg" style="width: 600px; height: 237px;" />
<pre>
<strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg" style="width: 300px; height: 110px;" />
<pre>
<strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in each tree will be in the range <code>[1, 200]</code>.</li>
	<li>Both of the given trees will have values in the range <code>[0, 200]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's find the leaf value sequence for both given trees.  Afterwards, we can compare them to see if they are equal or not.</p>
<p>To find the leaf value sequence of a tree, we use a depth first search.  Our <code>dfs</code> function writes the node's value if it is a leaf, and then recursively explores each child.  This is guaranteed to visit each leaf in left-to-right order, as left-children are fully explored before right-children.</p>
<p><a href="https://leetcode.com/playground/9QQFY3Jv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis**</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in <code>root1</code> and <span class="math inline">\(M\)</span> the number of nodes in <code>root2</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + M)\)</span></p>
<p>The <code>dfs</code> function visits each node exactly once in both trees, resulting in a time complexity of <span class="math inline">\(O(N)\)</span> for the first call and <span class="math inline">\(O(M)\)</span> for the second call.</p>
<p>After collecting all leaves in the <code>leaves1</code> and <code>leaves2</code> arrays, we compare them using the <code>==</code> operator. Comparing two arrays of size <span class="math inline">\(L\)</span> has a worst-case time complexity of <span class="math inline">\(O(L)\)</span>, where <span class="math inline">\(L\)</span> is the number of leaf nodes in the larger array.</p>
<p>Since <span class="math inline">\(L \leq \min(N, M)\)</span>, the comparison time is <span class="math inline">\(O(\min(N, M))\)</span>, but this is dominated by the time spent traversing both trees.</p>
<p>Overall, the time complexity is <span class="math inline">\(O(N + M)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N + M)\)</span></p>
<p>The recursive <code>dfs</code> calls will require stack space for each node. In the worst case, if the trees are completely unbalanced (like a linked list), the recursion depth could be <span class="math inline">\(O(N)\)</span> and <span class="math inline">\(O(M)\)</span> respectively, leading to a total stack space complexity of <span class="math inline">\(O(N + M)\)</span>.</p>
<p>Additionally, each <code>dfs</code> call collects leaf nodes into <code>leaves1</code> and <code>leaves2</code>. The maximum number of leaves in a binary tree is <span class="math inline">\(\frac{N}{2}\)</span> (for a full binary tree), resulting in <span class="math inline">\(O(N)\)</span> and <span class="math inline">\(O(M)\)</span> space for each array.</p>
<p>Therefore, the total space complexity, combining both the recursion stack and the storage for the leaves, is <span class="math inline">\(O(N + M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Linked List in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree <code>root</code> and a&nbsp;linked list with&nbsp;<code>head</code>&nbsp;as the first node.&nbsp;</p>

<p>Return True if all the elements in the linked list starting from the <code>head</code> correspond to some <em>downward path</em> connected in the binary tree&nbsp;otherwise return False.</p>

<p>In this context downward path means a path that starts at some node and goes downwards.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png" style="width: 220px; height: 280px;" /></strong></p>

<pre>
<strong>Input:</strong> head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> Nodes in blue form a subpath in the binary Tree.  
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png" style="width: 220px; height: 280px;" /></strong></p>

<pre>
<strong>Input:</strong> head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no path in the binary tree that contains all the elements of the linked list from <code>head</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 2500]</code>.</li>
	<li>The number of nodes in the list will be in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val&nbsp;&lt;= 100</code>&nbsp;for each node in the linked list and binary tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary tree and a linked list. Our task is to determine if the linked list is represented by any downward path in the binary tree. A downward path in the binary tree is defined as a path that starts at any node and extends to its subsequent child nodes, going downward.</p>
<hr />
<h3 id="approach-1-dfs">Approach 1: DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>A direct approach is to explore every possible path in the tree using Depth-First Search (DFS). This method allows us to examine each path fully before moving to the next.</p>
<p>We begin at the root of the tree and compare its value to the head of the linked list. If they match, we continue by checking the left and right children of the tree node against the next node in the linked list. If the tree node's value does not match the linked list node, we stop exploring that path since it can't lead to a match. We then backtrack and try the next possible path.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>If <code>root</code> is null, return <code>false</code> (base case).</p>
</li>
<li>
<p>Call <code>checkPath(root, head)</code> to start checking for the linked list path in the tree.</p>
</li>
<li>
<p><code>checkPath</code> function:</p>
<ul>
<li>If <code>node</code> is null, return <code>false</code> (base case).</li>
<li>Call <code>dfs(node, head)</code> to check if a matching path starts from <code>node</code>.
<ul>
<li>If <code>dfs</code> returns <code>true</code>, return <code>true</code> (a matching path is found).</li>
</ul>
</li>
<li>Recursively call <code>checkPath</code> on both left and right subtrees with the same <code>head</code>.</li>
</ul>
</li>
<li>
<p><code>dfs</code> function:</p>
<ul>
<li>If <code>head</code> is null, return <code>true</code> (all nodes in the list have been matched).</li>
<li>If <code>node</code> is null, return <code>false</code> (reached end of the tree without matching all nodes).</li>
<li>If the value of <code>node</code> does not match <code>head</code>, return <code>false</code> (value mismatch).</li>
<li>Recursively call <code>dfs</code> on both left and right children of <code>node</code> with <code>head-&gt;next</code>.</li>
</ul>
</li>
<li>
<p>Return <code>true</code> if <code>checkPath</code> or <code>dfs</code> finds a matching path; otherwise, continue checking.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6JiUxUZa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>In the worst case, we might need to check every node in the tree as a potential starting point for the linked list. For each node, we might need to traverse up to m nodes in the linked list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The space complexity remains the same as Approach 1 due to the recursive nature of the solution.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-approach">Approach 2: Iterative Approach</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A common rule of thumb is that all approaches solvable via recursion can also be solved using a stack to mimic the call stack's nature. Unlike recursion, where each function call adds a new frame to the call stack, using a stack avoids the risk of stack overflow errors in cases where the depth of recursion is too large (e.g., in a very deep tree).</p>
<p>We start by putting the root of the tree onto the stack. This stack helps us explore the tree without recursion. We repeatedly take the top node from the stack and check if there is a path from this node that matches the linked list. If there is, we return true. If not, we add the node's left and right children to the stack for further checking.</p>
<p>To match the path, we use another stack to keep track of pairs of tree nodes and linked list nodes. We compare each pair, and if they match, we continue with the next node in the linked list and the children of the current tree node. If we find that the entire linked list matches a path in the tree, we return true.</p>
<p>If we finish checking all possible paths without finding a match, we return false.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1367/iterative.json:1135,835!?!</p>
<blockquote>
<p>Fun fact: Iterative approaches often provide more control over traversal, allowing you to access every path and create patterns that do not follow traditional recursion rules.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Check if <code>root</code> is null:</p>
<ul>
<li>If <code>root</code> is null, return <code>false</code> (base case).</li>
</ul>
</li>
<li>
<p>Initialize a stack <code>nodes</code> and push <code>root</code> onto the stack.</p>
</li>
<li>
<p>While the stack <code>nodes</code> is not empty:</p>
<ul>
<li>Pop the top <code>node</code> from the stack.</li>
<li>Call <code>isMatch(node, head)</code> to check if the linked list <code>head</code> matches a path starting from <code>node</code>.
<ul>
<li>If <code>isMatch</code> returns <code>true</code>, return <code>true</code> (a matching path is found).</li>
</ul>
</li>
<li>If <code>node</code> has a left child, push it onto the stack.</li>
<li>If <code>node</code> has a right child, push it onto the stack.</li>
</ul>
</li>
<li>
<p>If no matching path is found after checking all nodes, return <code>false</code>.</p>
</li>
<li>
<p><code>isMatch</code> function:</p>
<ul>
<li>
<p>Initialize a stack <code>s</code> and push a pair <code>{node, lst}</code> onto it.</p>
</li>
<li>
<p>While the stack <code>s</code> is not empty:</p>
<ul>
<li>Pop the top pair <code>{currentNode, currentList}</code> from the stack.</li>
<li>While both <code>currentNode</code> and <code>currentList</code> are not null:
<ul>
<li>If <code>currentNode-&gt;val</code> does not match <code>currentList-&gt;val</code>, break (no match).</li>
<li>Move to the next node in the linked list (<code>currentList = currentList-&gt;next</code>).</li>
<li>If <code>currentList</code> is not null:
<ul>
<li>If <code>currentNode</code> has a left child, push <code>{currentNode-&gt;left, currentList}</code> onto the stack.</li>
<li>If <code>currentNode</code> has a right child, push <code>{currentNode-&gt;right, currentList}</code> onto the stack.</li>
<li>Break to continue with the next pair in the stack.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>currentList</code> becomes null, return <code>true</code> (all nodes in the list matched).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no matching path is found after exploring all possibilities.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GzvsGb96/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>We potentially visit each node in the tree once. For each node, we might need to check up to <code>m</code> nodes in the linked list.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space is used by the stack, which in the worst case might contain all nodes of the tree. We don't need extra space for the linked list traversal as it's done iteratively.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-knuth-morris-pratt-kmp-algorithm">Approach 3: Knuth-Morris-Pratt (KMP) Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Approach 3 is more advanced and requires an understanding of the Knuth-Morris-Pratt (KMP) string-matching algorithm. We suggest reviewing <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. Find the Index of the First Occurrence in a String - Easy Tagged</a> and solving it using the KMP algorithm before diving into this approach.</p>
<p>The previous approaches all involve searching the tree from the root and checking each path independently, which can be repetitive. By adjusting the idea behind the KMP algorithm, we can reduce this repetition and optimize the approach.</p>
<p>The KMP algorithm efficiently finds occurrences of a pattern (in this case, the linked list) within a text by using a prefix table, or failure function, to skip unnecessary comparisons.</p>
<p>The key to KMP is the prefix table, also known as the failure function. This table helps us understand how to skip certain comparisons based on what we’ve already matched.</p>
<p>We first build a table that indicates the longest proper prefix of the pattern that is also a suffix. This table tells us where to resume the search in the pattern after a mismatch. For example, consider the pattern <code>ABABCABAB</code>. The prefix table for this pattern helps us understand that if a mismatch occurs after <code>AB</code>, we don’t need to start from the beginning of the pattern but can skip to the next best position that aligns with what we’ve already matched.</p>
<p>As we search for the pattern in the text, if we encounter a mismatch, the prefix table tells us how far back we should go in the pattern to continue the search efficiently. Instead of starting the comparison from the beginning of the pattern again, we use the prefix table to skip over parts of the pattern that have already been matched. This reduces unnecessary comparisons.</p>
<p>Similarly, we construct the prefix table for the linked list by following the same principle of finding the longest prefix that is also a suffix. This helps in efficiently finding where to resume the search if a mismatch occurs while traversing paths in the tree.</p>
<p>We perform a DFS on the tree, treating each node's value as part of the text where we want to match our pattern (the linked list). As we traverse the tree, if a mismatch occurs, the prefix table tells us how much of the pattern we can skip, based on what we’ve already matched.</p>
<blockquote>
<p>Note: Running through a dry run of this approach will help you get a better grip on how it works. It’s a great way to see the logic in action with a few concrete examples and spot any issues.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Build the pattern and prefix table from the linked list:</p>
<ul>
<li>Initialize <code>pattern</code> with the value of the head node of the linked list.</li>
<li>Initialize <code>prefixTable</code> with <code>0</code> to store prefix lengths.</li>
<li>Iterate through the linked list to construct <code>pattern</code> and <code>prefixTable</code>:
<ul>
<li>For each value, update the <code>patternIndex</code> to find matching prefixes using the <code>prefixTable</code>.</li>
<li>Add the current value to <code>pattern</code> and update <code>prefixTable</code> accordingly.</li>
<li>Move to the next node in the linked list.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform DFS to search for the pattern in the tree:</p>
<ul>
<li>Call <code>searchInTree</code> with the root of the tree, starting pattern index <code>0</code>, and the <code>pattern</code> and <code>prefixTable</code>.</li>
</ul>
</li>
<li>
<p><code>searchInTree</code> function:</p>
<ul>
<li>
<p>If <code>node</code> is null, return <code>false</code> (base case).</p>
</li>
<li>
<p>Update <code>patternIndex</code> to find the matching prefix:</p>
<ul>
<li>If the current node value does not match the pattern at <code>patternIndex</code>, use the <code>prefixTable</code> to backtrack to the correct index.</li>
<li>Increment <code>patternIndex</code> if there is a match.</li>
</ul>
</li>
<li>
<p>Check if the entire <code>pattern</code> has been matched (<code>patternIndex == pattern.size()</code>):</p>
<ul>
<li>If matched, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Recursively search in both left and right subtrees of the current <code>node</code>:</p>
<ul>
<li>Return <code>true</code> if either subtree contains a matching path; otherwise, continue searching.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/H3NN3rA5/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree and <span class="math inline">\(m\)</span> be the length of the linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{k - 1} \cdot m)\)</span></p>
<p>The complexity of building the <code>prefixTable</code> for the KMP pattern is <span class="math inline">\(O(m)\)</span>. However, the primary bottleneck is in the <code>searchInTree</code> function, which performs a DFS on the binary tree with <span class="math inline">\(n\)</span> nodes.</p>
<p>While traversing the tree, the algorithm repeatedly evaluates portions of the <code>pattern</code>, and due to the tree structure, a mismatch can trigger repetitive re-evaluation of the <code>prefixTable</code> across multiple nodes. In the worst case, this could result in up to <span class="math inline">\(O(2^{k - 1} \cdot m)\)</span> time complexity, where <span class="math inline">\(m = 2k - 1\)</span>, as each failed match can lead to exponential time growth due to repeated pattern comparisons.</p>
</li>
</ul>
<ul>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We need <span class="math inline">\(O(m)\)</span> space for the pattern and prefix table. The recursive call stack in the worst case (skewed tree) can take up to <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-univalue-path/description" target="_blank" rel="noopener noreferrer">Longest Univalue Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the length of the longest path, where each node in the path has the same value</em>. This path may or may not pass through the root.</p>

<p><strong>The length of the path</strong> between two nodes is represented by the number of edges between them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg" style="width: 450px; height: 238px;" />
<pre>
<strong>Input:</strong> root = [5,4,5,1,1,null,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The shown image shows that the longest path of the same value (i.e. 5).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg" style="width: 450px; height: 238px;" />
<pre>
<strong>Input:</strong> root = [1,4,5,4,4,null,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The shown image shows that the longest path of the same value (i.e. 4).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li>The depth of the tree will not exceed <code>1000</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<p><strong>Intuition</strong></p>
<p>We can try to solve the problem in a recursive manner, as for trees the recursive solutions are intuitive and easy to follow. Let's suppose we have a node in the binary tree, and for both the left and right child, we have the count of nodes in the path that is equal to the node's value. How can we determine the longest univalue path for this node? If the node count for the left and right child is <code>x</code> and <code>y</code> respectively, then the answer for the parent node should be <code>x + y</code>. This is because the longest path would be considering the nodes on both children starting from one child to the parent node and then to the other child.</p>
<p>In the image below, the univalue path for the root node will be 3, as the number of nodes on the left child path that have the same value as the root node is 1 and the number of nodes on the right child path having the same value as the root node is 2. Hence, the path will include the nodes on both left and right and thus will have a length of 3.</p>
<p><img src="../Figures/687/687B.png" alt="fig" /></p>
<p>Now, we know that, for each left and right child path, we can find the number of nodes equal to their parent node. Then we can find the longest univalue path for the parent node. How to find the count of these nodes? As we just discussed above, if the number of nodes on the left and right child path have the same value as the node <code>x</code> and <code>y</code>, then the number of nodes that are equal to the parent node should be <code>max(x, y) + 1</code>. This is because we will consider only the longest child path, and there's an extra <code>1</code> representing the current node.</p>
<p>Therefore, in the recursive function, the base condition would be that if the node is null then we can return <code>0</code>. Otherwise, we will recursively call for the left and right child and store the count of nodes in the variables <code>left</code> and <code>right</code>. Update the answer variable if it's less than the univalue path at the current node which is <code>x + y</code>. Return the <code>max(x, y) + 1</code> which is the maximum number of nodes that have the same value as <code>root</code> on either the left or right side.</p>
<p><img src="../Figures/687/687A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Define the recursive function <code>solve()</code>, which accepts two arguments first the current node<code> root</code> and the second is the value of its parent node <code>parent</code>. This method returns the maximum number of consecutive nodes that are present on either the left or right side of the <code>root</code> with the same value, including the <code>root</code>.</p>
<ol>
<li>If the root is <code>NULL</code>, then return <code>0</code>.</li>
<li>Recursively call <code>solve()</code> for the left and right child with the parent value as the value of <code>root</code>.</li>
<li>Update the answer variable <code>ans</code> if <code>left + right</code> is greater than <code>ans</code>.</li>
<li>If the value of <code>root</code> is equal to the parent, return <code>max(left, right) + 1</code>, otherwise, return <code>0</code>.</li>
</ol>
</li>
<li>
<p>Call <code>solve()</code> with <code>root</code> and parent value as <code>-1</code>.</p>
</li>
<li>
<p>Return the maximum univalue path length <code>ans</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/RDxJkYBK/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We are iterating over each node only once and hence the time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The only space we need is during the recursion, the maximum number of active stack calls would be equal to the height of the tree. In the case of a skewed tree, the height of the tree will be equal to <span class="math inline">\(N\)</span>, hence the space complexity is equal to <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Longest ZigZag Path in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree.</p>

<p>A ZigZag path for a binary tree is defined as follow:</p>

<ul>
	<li>Choose <strong>any </strong>node in the binary tree and a direction (right or left).</li>
	<li>If the current direction is right, move to the right child of the current node; otherwise, move to the left child.</li>
	<li>Change the direction from right to left or from left to right.</li>
	<li>Repeat the second and third steps until you can&#39;t move in the tree.</li>
</ul>

<p>Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).</p>

<p>Return <em>the longest <strong>ZigZag</strong> path contained in that tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png" style="width: 221px; height: 383px;" />
<pre>
<strong>Input:</strong> root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png" style="width: 157px; height: 329px;" />
<pre>
<strong>Input:</strong> root = [1,1,1,null,1,null,null,1,1,null,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> node of a binary tree.</p>
<p>Our task is to find the longest zigzag path contained in the tree.</p>
<hr />
<h3 id="approach-depth-first-search">Approach: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that there are only two options available from each parent node. We either go to its left or right child (if they exist).</p>
<p>Let us observe some situations in which we move from a parent node to its children.</p>
<p>Consider a parent node <code>p</code>, which itself is a left child. If <code>p</code> has a left child, <code>l</code>, we cannot combine the edges going into <code>p</code> and <code>l</code>, because they have the same direction and do not form a zigzag path. We can only begin a new zigzag path of length <code>1</code> by including the edge between <code>p</code> and <code>l</code>.</p>
<p>If <code>p</code> has a right child, <code>r</code>, we can include the edges going into <code>p</code> and <code>r</code> together because their directions are opposite and form a zigzag path. If we know the length of the zigzag path until node <code>p</code>, including <code>r</code> increases the length of the path by <code>1</code>.</p>
<p>Now assume, that node <code>p</code> itself is a right child. If it has a left child <code>l</code>, we can combine the edges going into <code>p</code> and <code>l</code>. The length of the zigzag path until <code>l</code> is equal to the length of the zigzag path until <code>p</code> plus <code>1</code>. If <code>p</code> has a right child, <code>r</code>, we must start over with only the edge between <code>p</code> and <code>r</code> forming a zigzag path of length <code>1</code>.</p>
<p>This provides us with a solution to the problem. All we have to do now is keep track of which way we should go to continue forming a zigzag path. Depending on the current direction, we either include the edge of the child in the zigzag path that includes the edge going into the parent node, or we start a new zigzag path with the edge going into the child if the current direction does not match the direction of the child node.</p>
<p>We can use a graph traversal algorithm like depth-first search (DFS) to traverse in the tree. In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p><img src="../Figures/1372/1372-1.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>To store the longest zigzag path found thus far, we define an answer variable <code>pathLength = 0</code>. We implement a <code>dfs</code> method that accepts a <code>TreeNode node</code>, a boolean <code>goLeft</code> to indicate whether we should go left for the continuation of the zigzag path, and <code>steps</code> which stores the length of the zigzag path so far.</p>
<p>It's worth noting that we can substitute any other indication for <code>goLeft</code>. We can use whether the parent node is a left or right child, or we can choose whether to continue the zigzag path to the right (similar to left).</p>
<p>In the <code>dfs</code> method, we first determine whether <code>node</code> is <code>null</code> or not. If <code>node</code> is <code>null</code>, we exit the method. If it is a valid node, we update our answer variable <code>pathLength = max(pathLength, steps)</code>.</p>
<p>If <code>goLeft</code> is <code>true</code>, the zigzag path will continue to the left. We can't go left in the next step to continue this zigzag path because we're already going left in this step. As a result, we call <code>dfs(node.left, false, steps + 1)</code>. We passed <code>steps + 1</code> because we kept going in a zigzag pattern.</p>
<p>It should be noted that if the left does not exit, this call will be returned while we check if <code>node</code> is <code>null</code> at the beginning. After the <code>null</code> node check, we update <code>pathLength</code>, so it should only update <code>pathLength</code> for valid nodes.</p>
<p>We use <code>dfs(node.right, true, 1)</code> for the right child. Because we must visit the left child the next time, we passed <code>true</code> for <code>goLeft</code>. We pass <code>1</code> for<code>steps</code> to begin a new zigzag path including only the parent to the right child edge as it cannot be merged with ongoing path.</p>
<p>If <code>goLeft</code> is set to <code>false</code>, the zigzag path will continue to the right. We use <code>dfs(node.left, false, 1)</code> for the left child because we need to start a new zigzag path from the parent to the left child edge and we can't take left again in the next step. For the right child, we call <code>dfs(node.right, true, steps + 1)</code> because we keep continuing in the zigzag pattern.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize a class-level variable <code>pathLength</code> to <code>0</code> to keep track of the longest ZigZag path found.</p>
</li>
<li>
<p>Define the <code>dfs</code> function to traverse the tree:</p>
<ul>
<li>If <code>node</code> is null, return immediately (base case).</li>
<li>Update <code>pathLength</code> to be the maximum of its current value and <code>steps</code> (tracks the current ZigZag path length).</li>
<li>If <code>goLeft</code> is <code>true</code> (current direction is left):
<ul>
<li>Call <code>dfs</code> on the left child with <code>goLeft</code> set to <code>false</code> and <code>steps + 1</code> (continuing the ZigZag path).</li>
<li>Call <code>dfs</code> on the right child with <code>goLeft</code> set to <code>true</code> and <code>steps</code> reset to <code>1</code> (starting a new path in the opposite direction).</li>
</ul>
</li>
<li>If <code>goLeft</code> is <code>false</code> (current direction is right):
<ul>
<li>Call <code>dfs</code> on the left child with <code>goLeft</code> set to <code>false</code> and <code>steps</code> reset to <code>1</code> (starting a new path in the opposite direction).</li>
<li>Call <code>dfs</code> on the right child with <code>goLeft</code> set to <code>true</code> and <code>steps + 1</code> (continuing the ZigZag path).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Define the <code>longestZigZag</code> function:</p>
<ul>
<li>Call <code>dfs</code> starting at the <code>root</code> with <code>goLeft</code> set to <code>true</code> and <code>steps</code> set to <code>0</code>.</li>
<li>Return the value of <code>pathLength</code> as the longest ZigZag path in the tree.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/RVm5UhAK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes in the given binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>Using the <code>dfs</code> function, we recursively visit both the childrens of every node once. As a result, it takes <span class="math inline">\(O(n)\)</span> time because there are <span class="math inline">\(n\)</span> nodes in total. We iterate over each edge once to visit all the all nodes, which again takes <span class="math inline">\(O(n)\)</span> operations as there are <span class="math inline">\(n - 1\)</span> edges in the tree.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The recursion stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario where each node is added to it. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>

<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&rdquo;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
<strong>Output:</strong> 6
<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [2,1], p = 2, q = 1
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
	<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>p != q</code></li>
	<li><code>p</code> and <code>q</code> will exist in the BST.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>

<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" style="width: 200px; height: 190px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>Output:</strong> 5
<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2], p = 1, q = 2
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
	<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
	<li><code>p != q</code></li>
	<li><code>p</code> and <code>q</code> will exist in the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description" target="_blank" rel="noopener noreferrer">Lowest Common Ancestor of Deepest Leaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</p>

<p>Recall that:</p>

<ul>
	<li>The node of a binary tree is a leaf if and only if it has no children</li>
	<li>The depth of the root of the tree is <code>0</code>. if the depth of a node is <code>d</code>, the depth of each of its children is <code>d + 1</code>.</li>
	<li>The lowest common ancestor of a set <code>S</code> of nodes, is the node <code>A</code> with the largest depth such that every node in <code>S</code> is in the subtree with root <code>A</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 600px; height: 510px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree, and it&#39;s the lca of itself.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest leaf node in the tree is 2, the lca of one node is itself.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
	<li>The values of the nodes in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 865: <a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank">https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem gives a binary tree and requires returning the lowest common ancestor of its deepest leaf node. The depth of the tree's root node is <span class="math inline">\(0\)</span>. We note that all nodes with the maximum depth are leaf nodes. For convenience, we refer to the lowest common ancestor of the deepest leaf nodes as the <span class="math inline">\(\textit{lca}\)</span> node.</p>
<p>We use a recursive method to perform a depth-first search, recursively traversing each node in the tree and returning the maximum depth <span class="math inline">\(d\)</span> of the current subtree and the <span class="math inline">\(\textit{lca}\)</span> node. If the current node is null, we return depth <span class="math inline">\(0\)</span> and an null node. In each search, we recursively search the left and right subtrees, and then compare the depths of the left and right subtrees:</p>
<ul>
<li>If the left subtree is deeper, the deepest leaf node is in the left subtree, we return {left subtree depth + <span class="math inline">\(1\)</span>, the <span class="math inline">\(\textit{lca}\)</span> node of the left subtree}</li>
<li>If the right subtree is deeper, the deepest leaf node is in the right subtree, we return {right subtree depth + <span class="math inline">\(1\)</span>, the <span class="math inline">\(\textit{lca}\)</span> node of the right subtree}</li>
<li>If both left and right subtrees have the same depth and both have the deepest leaf nodes, we return {left subtree depth + <span class="math inline">\(1\)</span>, current node}.</li>
</ul>
<p>Finally, we return the root node's <span class="math inline">\(\textit{lca}\)</span> node.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/V5MKhFYN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of tree nodes.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We only need to traverse all the nodes in the tree once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is mainly the recursive space, with the worst case being <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Make Costs of Paths Equal in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">greedy</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code> representing the number of nodes in a <strong>perfect binary tree</strong> consisting of nodes numbered from <code>1</code> to <code>n</code>. The root of the tree is node <code>1</code> and each node <code>i</code> in the tree has two children where the left child is the node <code>2 * i</code> and the right child is <code>2 * i + 1</code>.</p>

<p>Each node in the tree also has a <strong>cost</strong> represented by a given <strong>0-indexed</strong> integer array <code>cost</code> of size <code>n</code> where <code>cost[i]</code> is the cost of node <code>i + 1</code>. You are allowed to <strong>increment</strong> the cost of <strong>any</strong> node by <code>1</code> <strong>any</strong> number of times.</p>

<p>Return <em>the <strong>minimum</strong> number of increments you need to make the cost of paths from the root to each <strong>leaf</strong> node equal</em>.</p>

<p><strong>Note</strong>:</p>

<ul>
	<li>A <strong>perfect binary tree </strong>is a tree where each node, except the leaf nodes, has exactly 2 children.</li>
	<li>The <strong>cost of a path</strong> is the sum of costs of nodes in the path.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png" />
<pre>
<strong>Input:</strong> n = 7, cost = [1,5,2,2,3,3,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> We can do the following increments:
- Increase the cost of node 4 one time.
- Increase the cost of node 3 three times.
- Increase the cost of node 7 two times.
Each path from the root to a leaf will have a total cost of 9.
The total increments we did is 1 + 3 + 2 = 6.
It can be shown that this is the minimum answer we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png" style="width: 205px; height: 151px;" />
<pre>
<strong>Input:</strong> n = 3, cost = [5,3,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The two paths already have equal total costs, so no increments are needed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>n + 1</code> is a power of <code>2</code></li>
	<li><code>cost.length == n</code></li>
	<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>

<ol>
	<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>
	<li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li>
	<li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li>
</ol>

<p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" style="width: 302px; height: 421px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1,6,0,5]
<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]
<strong>Explanation:</strong> The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" style="width: 182px; height: 301px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> [3,null,2,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursive-solution">Approach 1: Recursive Solution</h3>
<p>The current solution is very simple. We make use of a function <code>construct(nums, l, r)</code>, which returns the maximum binary tree consisting of numbers within the indices <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span> in the given <span class="math inline">\(nums\)</span> array(excluding the <span class="math inline">\(r^{th}\)</span> element).</p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>
<p>Start with the function call <code>construct(nums, 0, n)</code>. Here, <span class="math inline">\(n\)</span> refers to the number of elements in the given <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Find the index, <span class="math inline">\(max_i\)</span>, of the largest element in the current range of indices <span class="math inline">\((l:r-1)\)</span>. Make this largest element, <span class="math inline">\(nums[max\_i]\)</span> as the local root node.</p>
</li>
<li>
<p>Determine the left child using <code>construct(nums, l, max_i)</code>. Doing this recursively finds the largest element in the subarray left to the current largest element.</p>
</li>
<li>
<p>Similarly, determine the right child using <code>construct(nums, max_i + 1, r)</code>.</p>
</li>
<li>
<p>Return the root node to the calling function.</p>
</li>
</ol>
<p><a href="https://leetcode.com/playground/3hVy3spd/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The function <code>construct</code> is called <span class="math inline">\(n\)</span> times. At each level of the recursive tree, we traverse over all the <span class="math inline">\(n\)</span> elements to find the maximum element.  In the average case, there will be a <span class="math inline">\(\log n\)</span> levels leading to a complexity of <span class="math inline">\(O\big(n\log n\big)\)</span>. In the worst case, the depth of the recursive tree can grow upto <span class="math inline">\(n\)</span>, which happens in the case of a sorted <span class="math inline">\(nums\)</span> array, giving a complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The size of the <span class="math inline">\(set\)</span> can grow upto <span class="math inline">\(n\)</span> in the worst case. In the average case, the size will be <span class="math inline">\(\log n\)</span> for <span class="math inline">\(n\)</span> elements in <span class="math inline">\(nums\)</span>, giving an average case complexity of <span class="math inline">\(O(\log n)\)</span></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-binary-tree-ii/description" target="_blank" rel="noopener noreferrer">Maximum Binary Tree II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>maximum tree</strong> is a tree where every node has a value greater than any other value in its subtree.</p>

<p>You are given the <code>root</code> of a maximum binary tree and an integer <code>val</code>.</p>

<p>Just as in the <a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank">previous problem</a>, the given tree was constructed from a list <code>a</code> (<code>root = Construct(a)</code>) recursively with the following <code>Construct(a)</code> routine:</p>

<ul>
	<li>If <code>a</code> is empty, return <code>null</code>.</li>
	<li>Otherwise, let <code>a[i]</code> be the largest element of <code>a</code>. Create a <code>root</code> node with the value <code>a[i]</code>.</li>
	<li>The left child of <code>root</code> will be <code>Construct([a[0], a[1], ..., a[i - 1]])</code>.</li>
	<li>The right child of <code>root</code> will be <code>Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code>.</li>
	<li>Return <code>root</code>.</li>
</ul>

<p>Note that we were not given <code>a</code> directly, only a root node <code>root = Construct(a)</code>.</p>

<p>Suppose <code>b</code> is a copy of <code>a</code> with the value <code>val</code> appended to it. It is guaranteed that <code>b</code> has unique values.</p>

<p>Return <code>Construct(b)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/09/maxtree1.JPG" style="width: 376px; height: 235px;" />
<pre>
<strong>Input:</strong> root = [4,1,3,null,null,2], val = 5
<strong>Output:</strong> [5,4,null,1,3,null,null,2]
<strong>Explanation:</strong> a = [1,4,2,3], b = [1,4,2,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/09/maxtree21.JPG" style="width: 358px; height: 156px;" />
<pre>
<strong>Input:</strong> root = [5,2,4,null,1], val = 3
<strong>Output:</strong> [5,2,4,null,1,null,3]
<strong>Explanation:</strong> a = [2,1,5,4], b = [2,1,5,4,3]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/09/maxtree3.JPG" style="width: 404px; height: 180px;" />
<pre>
<strong>Input:</strong> root = [5,2,3,null,1], val = 4
<strong>Output:</strong> [5,2,4,null,1,3]
<strong>Explanation:</strong> a = [2,1,5,3], b = [2,1,5,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li>All the values of the tree are <strong>unique</strong>.</li>
	<li><code>1 &lt;= val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-depth-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Depth of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>

<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" style="width: 400px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-difference-between-node-and-ancestor/description" target="_blank" rel="noopener noreferrer">Maximum Difference Between Node and Ancestor</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, find the maximum value <code>v</code> for which there exist <strong>different</strong> nodes <code>a</code> and <code>b</code> where <code>v = |a.val - b.val|</code> and <code>a</code> is an ancestor of <code>b</code>.</p>

<p>A node <code>a</code> is an ancestor of <code>b</code> if either: any child of <code>a</code> is equal to <code>b</code>&nbsp;or any child of <code>a</code> is an ancestor of <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg" style="width: 400px; height: 390px;" />
<pre>
<strong>Input:</strong> root = [8,3,10,1,6,null,14,null,null,4,7,13]
<strong>Output:</strong> 7
<strong>Explanation: </strong>We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg" style="width: 250px; height: 349px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,null,0,3]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 5000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Level Sum of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the level of its root is <code>1</code>, the level of its children is <code>2</code>, and so on.</p>

<p>Return the <strong>smallest</strong> level <code>x</code> such that the sum of all the values of nodes at level <code>x</code> is <strong>maximal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/capture.JPG" style="width: 200px; height: 175px;" />
<pre>
<strong>Input:</strong> root = [1,7,0,7,-8,null,null]
<strong>Output:</strong> 2
<strong>Explanation: </strong>
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [989,null,10250,98693,-89388,null,null,null,-32127]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a binary tree.</p>
<p>Our task is to return the smallest level <code>x</code> such that the sum of all the values of nodes at level <code>x</code> is maximal.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The task is to compute the sum of all node values at each level to get the smallest level with the maximum sum.</p>
<p>We can simply use a standard breadth-first search traversal because we need to analyze nodes by level.</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>). BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="../Figures/1161/1161-bfs1.png" alt="img" /></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">LeetCode Explore Card</a>.</p>
<p>We initialize a queue of integers and an integer <code>level = 0</code> to track the current level. In the queue, we push the <code>root</code> node.</p>
<p>We perform a level-wise traversal, incrementing <code>level</code> by <code>1</code> each time when we move to a new level. At each iteration, we remove all nodes at <code>level</code>, compute the sum of all node values at this level, and insert all their neighbouring nodes at <code>level + 1</code>.</p>
<p>Because we are popping all of the nodes at <code>level</code> and inserting all of the nodes at <code>level + 1</code>, the size of the queue will represent the number of nodes at the next level at the end of this iteration.</p>
<p>So we have two loops: the outer loop runs until the queue is empty, and the inner loop runs the number of times equal to the size of the queue to just cover the nodes at the current level. We will pop all the nodes at <code>level</code>, compute the sum of all the values, and insert all the nodes at <code>level + 1</code> into the queue.</p>
<p>Here is a visual representation of how we will iterate using the loops:</p>
<p><img src="../Figures/1161/1161-bfs2.png" alt="img" /></p>
<p>To get the answer, we compare the sum of all node values at the current level to the maximum sum of values we've already seen. If the current sum of node values is greater than what we've seen before, we update our answer to <code>level</code>, and the current sum becomes our largest sum of values seen thus far. Since we are traversing the higher levels first, by only updating the answer when the level sum is <strong>greater</strong> than what we've seen before, we handle the tiebreakers automatically.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer variable <code>maxSum</code> to keep track of the maximum sum of node values at any level. We start with a large negative value.</li>
<li>Create another variable <code>ans</code> to store the answer to the problem.</li>
<li>Create another integer variable <code>level</code> to store the current level through which we are iterating. We initialize it with <code>0</code>.</li>
<li>Initialize a queue <code>q</code> of <code>TreeNode</code> and push <code>root</code> into it.</li>
<li>Perform a BFS traversal until the queue is empty:
<ul>
<li>Increment <code>level</code> by <code>1</code> and initialize <code>sumAtCurrentLevel = 0</code> to compute the sum of all values of nodes at this level.</li>
<li>Iterate through all the nodes at <code>level</code> using only the <code>q.size()</code> number of nodes. Within this inner loop, pop out all the nodes at the current level one by one, adding their values to <code>sumAtCurrentLevel</code> and pushing the left and right children (if they exist) into the queue.</li>
<li>Realize that after traversing all of the nodes at <code>level</code>, the queue only has nodes at <code>level + 1</code>.</li>
<li>After traversing through all the nodes at <code>level</code>, we check if <code>sumAtCurrentLevel</code> is greater than <code>maxSum</code>. If <code>maxSum &lt; sumAtCurrentLevel</code>, update our answer variable to <code>ans = level</code> and set <code>maxSum = sumAtCurrentLevel</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LvBJUd6F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes in the given binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can only be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes.</li>
<li>The computation of sum of all the values of nodes at a level also takes <span class="math inline">\(O(n)\)</span> time as each node's value is used once.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>As the BFS queue stores the nodes in level-wise manner, the maximum number of nodes in the BFS queue would equal to the most number of nodes at any level. So, the best case would be <span class="math inline">\(O(1)\)</span> where all the levels have just one node.</li>
<li>The worst case would be a complete binary tree. In a complete binary tree, the last or second last level would have the most nodes (the last level can have multiple null nodes). Because we are iterating by level, the BFS queue will be most crowded when all of the nodes from the last level (or second last level) are in the queue. Assume we have a complete binary tree with height <span class="math inline">\(h\)</span> and a fully filled last level having <span class="math inline">\(2^h\)</span> nodes. All the nodes at each level add up to <span class="math inline">\(1 + 2 + 4 + 8 +... + 2^h = n\)</span>. This implies that <span class="math inline">\(2^{h + 1} - 1 = n\)</span>, and thus <span class="math inline">\(2^h = (n + 1) / 2\)</span>. Because the last level <span class="math inline">\(h\)</span> has <span class="math inline">\(2^h\)</span> nodes, the BFS queue will have <span class="math inline">\((n + 1) / 2 = O(n)\)</span> elements in the worst-case scenario.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use another traversal method, depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="../Figures/547/547-dfs.png" alt="img" /></p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
<p>Because our task is to compute the sum of all the values of nodes at each level, we can perform a DFS traversal and pass the level of each node as an extra parameter.</p>
<p>We can initialize a list of integers <code>sumOfNodesAtLevel</code>, where <code>sumOfNodesAtLevel[i]</code> stores the sum of all the values of nodes at level <code>i</code>. Whenever we visit a node at a level, say <code>l</code>, we increment the index <code>l</code> in the list by the value of the current node. According to the problem definition, the levels should begin with <code>1</code>, but to keep the list as <code>0-indexed</code>, we will begin with level <code>0</code> (the root's level) and increment our answer by <code>1</code> at the end.</p>
<p>The question that may arise is how long this list should be.</p>
<p>We know that in a DFS traversal, we either move down the tree (until we can) to a node at the next level or we backtrack to a node at a lower level. As we descend the tree, if we come across a level <code>l</code> we haven't seen before, we add the node's value to <code>sumOfNodesAtLevel</code>, which places the entry at index <code>l</code> itself. This is due to the fact that all levels from <code>0</code> to <code>l - 1</code> must have already been seen and have corresponding values in <code>sumOfNodesAtLevel</code>.</p>
<p>So, if the size of <code>sumOfNodesAtLevel</code> equals <code>l</code>, it means we've seen nodes from levels <code>0</code> to <code>l - 1</code> but not any nodes at level <code>l</code> yet. At level <code>l</code>, this is the first node we see.</p>
<p>If the level <code>l</code> is smaller than the size of <code>sumOfNodesAtLevel</code>, it means we've seen some nodes at this level before, and we simply increment <code>sumOfNodesAtLevel[l]</code> by the value of the current node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a list of integers <code>sumOfNodesAtLevel</code> to store the sum of all the values of nodes at a level. The value <code>sumOfNodesAtLevel[i]</code> stores the sum of all the values of nodes at level <code>i</code> (0-indexed). We would start our levels from <code>0</code> to keep the array <code>0-indexed</code> and finally increment our answer by <code>1</code> to align with the problem definition of the level (levels begin with <code>1</code> as stated in the problem).</li>
<li>Perform the DFS traversal over the given binary tree. We call <code>dfs(root, 0, sumOfNodesAtLevel)</code> where <code>dfs</code> is a recursive method that takes three parameters: <code>TreeNode node</code> from which the traversal begins, the level of <code>node</code>, and <code>sumOfNodesAtLevel</code>. We perform the following in this method:
<ul>
<li>If <code>node</code> is <code>null</code>, return.</li>
<li>If the size of <code>sumOfNodesAtLevel</code> equals <code>level</code>, we haven't encountered any nodes at this level. Hence, we insert <code>node.val</code> in <code>sumOfNodesAtLevel</code>. Otherwise, if we've seen this level before, we simply perform <code>sumOfNodesAtLevel[level] += node.val</code> to add <code>node.val</code> to the corresponding <code>level</code>.</li>
<li>Recursively perform DFS from <code>node.left</code>.</li>
<li>Recursively perform DFS from <code>node.right</code>.</li>
</ul>
</li>
<li>Create a variable <code>maxSum</code> to keep track of the maximum sum of node values at any level. We start with a large negative value.</li>
<li>Create another variable <code>ans</code> to store the answer to the problem.</li>
<li>Iterate over the sum of nodes of all the levels, i.e., iterate over <code>sumOfNodesAtLevel</code> and perform the following:
<ul>
<li>If <code>maxSum &lt; sumOfNodesAtLevel[i]</code>, we set <code>maxSum = sumOfNodesAtLevel[i]</code> and update <code>ans</code> to the level <code>i + 1</code> (<code>+1</code> is added to align with the definition of level).</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/YxvJa36T/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math inline">\(n\)</span> is the number of nodes in the given binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>We traverse once over each node of the tree using DFS traversal which takes <span class="math inline">\(O(n)\)</span> time. We also take <span class="math inline">\(O(1)\)</span> time to add a node's value into <code>sumOfNodesAtLevel</code> for each node, which takes <span class="math inline">\(O(n)\)</span> time for <span class="math inline">\(n\)</span> nodes.</li>
<li>The size of <code>sumOfNodesAtLevel</code> is equal to the height of tree. We iterate over all the values in <code>sumOfNodesAtLevel</code> to get the level with maximum sum of node values. In the worst-case scenario, when the tree is a straight line, the height would be <span class="math inline">\(O(n)\)</span>, requiring <span class="math inline">\(O(n)\)</span> time to iterate over <code>sumOfNodesAtLevel</code>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>The DFS traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree's height, which in the worst case would be <span class="math inline">\(O(n)\)</span> when the tree is a straight line.</li>
<li>The <code>sumOfNodesAtLevel</code> would also take linear space in the worst case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-product-of-splitted-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Product of Splitted Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.</p>

<p>Return <em>the maximum product of the sums of the two subtrees</em>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p><strong>Note</strong> that you need to maximize the answer before taking the mod and not after taking it.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png" style="width: 500px; height: 167px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 110
<strong>Explanation:</strong> Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png" style="width: 500px; height: 211px;" />
<pre>
<strong>Input:</strong> root = [1,null,2,3,4,null,null,5,6]
<strong>Output:</strong> 90
<strong>Explanation:</strong> Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-bst-in-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Sum BST in Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>binary tree</strong> <code>root</code>, return <em>the maximum sum of all keys of <strong>any</strong> sub-tree which is also a Binary Search Tree (BST)</em>.</p>

<p>Assume a BST is defined as follows:</p>

<ul>
	<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png" style="width: 320px; height: 250px;" /></p>

<pre>
<strong>Input:</strong> root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
<strong>Output:</strong> 20
<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/01/30/sample_2_1709.png" style="width: 134px; height: 180px;" /></p>

<pre>
<strong>Input:</strong> root = [4,3,null,1,2]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [-4,-2,-5]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All values are negatives. Return an empty BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>
	<li><code>-4 * 10<sup>4</sup> &lt;= Node.val &lt;= 4 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-width-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Width of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the <strong>maximum width</strong> of the given tree</em>.</p>

<p>The <strong>maximum width</strong> of a tree is the maximum <strong>width</strong> among all levels.</p>

<p>The <strong>width</strong> of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.</p>

<p>It is <strong>guaranteed</strong> that the answer will in the range of a <strong>32-bit</strong> signed integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg" style="width: 359px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,3,null,9]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The maximum width exists in the third level with length 4 (5,3,null,9).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg" style="width: 442px; height: 422px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5,null,null,9,6,null,7]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg" style="width: 289px; height: 299px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum width exists in the second level with length 2 (3,2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 3000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-bsts-to-create-single-bst/description" target="_blank" rel="noopener noreferrer">Merge BSTs to Create Single BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>n</code> <strong>BST (binary search tree) root nodes</strong> for <code>n</code> separate BSTs stored in an array <code>trees</code> (<strong>0-indexed</strong>). Each BST in <code>trees</code> has <strong>at most 3 nodes</strong>, and no two roots have the same value. In one operation, you can:</p>

<ul>
	<li>Select two <strong>distinct</strong> indices <code>i</code> and <code>j</code> such that the value stored at one of the <strong>leaves </strong>of <code>trees[i]</code> is equal to the <strong>root value</strong> of <code>trees[j]</code>.</li>
	<li>Replace the leaf node in <code>trees[i]</code> with <code>trees[j]</code>.</li>
	<li>Remove <code>trees[j]</code> from <code>trees</code>.</li>
</ul>

<p>Return<em> the <strong>root</strong> of the resulting BST if it is possible to form a valid BST after performing </em><code>n - 1</code><em> operations, or</em><em> </em><code>null</code> <i>if it is impossible to create a valid BST</i>.</p>

<p>A BST (binary search tree) is a binary tree where each node satisfies the following property:</p>

<ul>
	<li>Every node in the node&#39;s left subtree has a value&nbsp;<strong>strictly less</strong>&nbsp;than the node&#39;s value.</li>
	<li>Every node in the node&#39;s right subtree has a value&nbsp;<strong>strictly greater</strong>&nbsp;than the node&#39;s value.</li>
</ul>

<p>A leaf is a node that has no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d1.png" style="width: 450px; height: 163px;" />
<pre>
<strong>Input:</strong> trees = [[2,1],[3,2,5],[5,4]]
<strong>Output:</strong> [3,2,5,1,null,4]
<strong>Explanation:</strong>
In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].
Delete trees[0], so trees = [[3,2,5,1],[5,4]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram.png" style="width: 450px; height: 181px;" />
In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].
Delete trees[1], so trees = [[3,2,5,1,null,4]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png" style="width: 220px; height: 165px;" />
The resulting tree, shown above, is a valid BST, so return its root.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d2.png" style="width: 450px; height: 171px;" />
<pre>
<strong>Input:</strong> trees = [[5,3,8],[3,2,6]]
<strong>Output:</strong> []
<strong>Explanation:</strong>
Pick i=0 and j=1 and merge trees[1] into trees[0].
Delete trees[1], so trees = [[5,3,8,2,6]].
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png" style="width: 240px; height: 196px;" />
The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d3.png" style="width: 430px; height: 168px;" />
<pre>
<strong>Input:</strong> trees = [[5,4],[3]]
<strong>Output:</strong> []
<strong>Explanation:</strong> It is impossible to perform any operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == trees.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li>The number of nodes in each tree is in the range <code>[1, 3]</code>.</li>
	<li>Each node in the input may have children but no grandchildren.</li>
	<li>No two roots of <code>trees</code> have the same value.</li>
	<li>All the trees in the input are <strong>valid BSTs</strong>.</li>
	<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-two-binary-trees/description" target="_blank" rel="noopener noreferrer">Merge Two Binary Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>

<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>

<p>Return <em>the merged tree</em>.</p>

<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" style="width: 600px; height: 163px;" />
<pre>
<strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
<strong>Output:</strong> [3,4,5,5,4,null,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root1 = [1], root2 = [1,2]
<strong>Output:</strong> [2,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h3>
<p>We can traverse both the given trees in a preorder fashion. At every step, we check if the current node exists(isn't null) for both the trees. If so, we add the values in the current nodes of both the trees and update the value in the current node of the first tree to reflect this sum obtained. At every step, we also call the original function <code>mergeTrees()</code> with the left children and then with the right children of the current nodes of the two trees. If at any step, one of these children happens to be null, we return the child of the other tree(representing the corresponding child subtree) to be added as a child subtree to the calling parent node in the first tree. At the end, the first tree will represent the required resultant merged binary tree.</p>
<p>The following animation illustrates the process.</p>
<p>!?!../Documents/617_Merge_Trees_Recursion.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/d9nZDPEJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(m)\)</span>. A total of <span class="math inline">\(m\)</span> nodes need to be traversed. Here, <span class="math inline">\(m\)</span> represents the minimum number of nodes from the two given trees.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(m)\)</span>. The depth of the recursion tree can go upto <span class="math inline">\(m\)</span> in the case of a skewed tree. In average case, depth will be <span class="math inline">\(O(logm)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-method-accepted">Approach #2 Iterative Method [Accepted]</h3>
<p><strong>Algorithm</strong></p>
<p>In the current approach, we again traverse the two trees, but this time we make use of a <span class="math inline">\(stack\)</span> to do so instead of making use of recursion. Each entry in the <span class="math inline">\(stack\)</span> stores data in the form <span class="math inline">\([node_{tree1}, node_{tree2}]\)</span>. Here, <span class="math inline">\(node_{tree1}\)</span> and <span class="math inline">\(node_{tree2}\)</span> are the nodes of the first tree and the second tree respectively.</p>
<p>We start off by pushing the root nodes of both the trees onto the <span class="math inline">\(stack\)</span>. Then, at every step, we remove a node pair from the top of the stack. For every node pair removed, we add the values corresponding to the two nodes and update the value of the corresponding node in the first tree. Then, if the left child of the first tree exists, we push the left child(pair) of both the trees onto the stack. If the left child of the first tree doesn't exist, we append the left child(subtree) of the second tree to the current node of the first tree. We do the same for the right child pair as well.</p>
<p>If, at any step, both the current nodes are null, we continue with popping the next nodes from the <span class="math inline">\(stack\)</span>.</p>
<p>The following animation depicts the process.</p>
<p>!?!../Documents/617_Merge_Trees_Stack.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/v2TK7i2x/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We traverse over a total of <span class="math inline">\(n\)</span> nodes. Here, <span class="math inline">\(n\)</span> refers to the smaller of the number of nodes in the two trees.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The depth of stack can grow upto <span class="math inline">\(n\)</span> in case of a skewed tree.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-difference-in-bst/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Difference in BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 783: <a href="https://leetcode.com/problems/minimum-distance-between-bst-nodes/" target="_blank">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-depth-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Minimum Depth of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>

<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" style="width: 432px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-distance-between-bst-nodes/description" target="_blank" rel="noopener noreferrer">Minimum Distance Between BST Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum difference between the values of any two different nodes in the tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" style="width: 292px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [4,2,6,1,3]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" style="width: 282px; height: 301px;" />
<pre>
<strong>Input:</strong> root = [1,0,48,null,null,12,49]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 530: <a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" target="_blank">https://leetcode.com/problems/minimum-absolute-difference-in-bst/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Sort a Binary Tree by Level</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.</p>

<p>In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.</p>

<p>Return <em>the minimum number of operations needed to make the values at each level sorted in a <strong>strictly increasing order</strong></em>.</p>

<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node<em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" style="width: 500px; height: 324px;" />
<pre>
<strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 4 and 3. The 2<sup>nd</sup> level becomes [3,4].
- Swap 7 and 5. The 3<sup>rd</sup> level becomes [5,6,8,7].
- Swap 8 and 7. The 3<sup>rd</sup> level becomes [5,6,7,8].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" style="width: 400px; height: 303px;" />
<pre>
<strong>Input:</strong> root = [1,3,2,7,6,5,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
- Swap 3 and 2. The 2<sup>nd</sup> level becomes [2,3].
- Swap 7 and 4. The 3<sup>rd</sup> level becomes [4,6,5,7].
- Swap 6 and 5. The 3<sup>rd</sup> level becomes [4,5,6,7].
We used 3 operations so return 3.
It can be proven that 3 is the minimum number of operations needed.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png" style="width: 400px; height: 274px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li>All the values of the tree are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hash-map">Approach 1: Hash Map</h3>
<h4 id="intuition">Intuition</h4>
<p>Our first task is to traverse the tree level by level. This is known as a level order traversal of a tree. Level-order traversal involves exploring all the nodes at a given depth (or level) before moving to the next level. In other words, it prioritizes breadth-wise exploration of the tree before progressing depth-wise. To achieve this, we use Breadth-First Search (BFS).</p>
<p>We use a queue to perform BFS on the tree. As we process each node, we add all its children to the queue. This ensures that after all nodes at the current level are explored, the remaining elements in the queue represent all nodes at the next level. To process nodes at each level together, we can record the size of the queue at the start of each iteration and handle exactly that many nodes in the current level.</p>
<p>Once we retrieve the nodes at each level, our second task is to sort the values of the nodes at that level. While there are many efficient sorting algorithms, the problem specifically requires sorting the values with the minimum number of in-place swaps. The cycle sort algorithm meets our requirements perfectly.</p>
<p>The cycle sort algorithm works by cyclically placing each element in its correct sorted position by swapping it with the value currently in that position. For example, consider the array <code>[3, 0, 1]</code>. Since the correct position of <code>3</code> is index <code>2</code>, we swap it with the value at index <code>2</code> (i.e., <code>1</code>). After the swap, the array becomes <code>[1, 0, 3]</code>. While <code>3</code> is now in the correct position, <code>1</code> and <code>0</code> are still not. Next, we place <code>1</code> in its correct position (index <code>1</code>), and the process continues until the array is sorted. This cyclical placement gives the algorithm its name, cycle sort.</p>
<p>Returning to the problem, after obtaining the nodes of a level (in an arbitrary order), we create a sorted copy of this list based on the values of the nodes. This allows us to determine the correct sorted index for each value. To efficiently track the positions of nodes, we use a map that stores each value and its current index. As we iterate through the list of nodes, we check if a node is already in its correct position. If not, we perform a swap to move it to the correct position, updating the map accordingly. This process is repeated until all nodes in the level are sorted.</p>
<p>We accumulate the total swaps needed to sort each level. At the end of the BFS, we can return this total as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of Breadth-First Search on trees, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">Queue and BFS Explore Card 🔗</a>. This resource provides an in-depth look at the BFS algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a <code>queue</code> to store nodes for BFS traversal.</li>
<li>a variable <code>totalSwaps</code> to track the total number of operations needed.</li>
</ul>
</li>
<li>Add the <code>root</code> node to the queue to begin traversal.</li>
<li>While the queue is not empty:
<ul>
<li>Get the size of the current level using the queue size.</li>
<li>Initialize an array <code>levelValues</code> of size equal to the current level size.</li>
<li>For each node at the current level:
<ul>
<li>Remove the node from the queue.</li>
<li>Store the node's value in the <code>levelValues</code> array.</li>
<li>Add the left and right children of the current node to <code>queue</code> if they exist.</li>
</ul>
</li>
<li>Add minimum swaps needed for the current level to <code>totalSwaps</code>.</li>
<li>Continue to the next level.</li>
</ul>
</li>
<li>Return <code>totalSwaps</code> as the final answer.</li>
</ul>
<p>For calculating minimum swaps (<code>getMinSwaps</code> function):</p>
<ul>
<li>Initialize a variable <code>swaps</code> to track swaps needed for the current level.</li>
<li>Create a copy of the input array as the <code>target</code> array.</li>
<li>Sort the <code>target</code> array to get the desired order.</li>
<li>Initialize a map <code>pos</code> to store current positions of values.</li>
<li>Store positions of all values from the original array in the <code>pos</code> map.</li>
<li>For each position in the <code>original</code> array:
<ul>
<li>If the value at the current position doesn't match the <code>target</code> array:
<ul>
<li>Increment <code>swaps</code> counter.</li>
<li>Get the position of desired value from <code>pos</code>.</li>
<li>Update the position of the current value in <code>pos</code>.</li>
<li>Update value in the <code>original</code> array at swapped position.</li>
</ul>
</li>
</ul>
</li>
<li>Return total <code>swaps</code> needed for current level.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ELALCbfh/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The BFS traversal visits each node exactly once, contributing <span class="math inline">\(O(n)\)</span>. At each level, we perform sorting of the level values array which costs <span class="math inline">\(O(w \log w)\)</span> where <span class="math inline">\(w\)</span> is the width of that level.</p>
<p>The position mapping and swap calculations take <span class="math inline">\(O(w)\)</span> time. In the worst case when the tree is a complete binary tree, <span class="math inline">\(w\)</span> could be <span class="math inline">\(n/2\)</span>, making the complexity <span class="math inline">\(2 \cdot O(n) + O(n \log n) = O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The queue used for BFS will store at most <span class="math inline">\(w\)</span> nodes at any time, where <span class="math inline">\(w\)</span> is the maximum width of the tree at any level. The <code>levelValues</code> array also stores <span class="math inline">\(w\)</span> elements for the current level. The map in <code>getMinSwaps</code> stores positions for <span class="math inline">\(w\)</span> elements.</p>
<p>The temporary arrays (<code>original</code> and <code>target</code>) also use <span class="math inline">\(O(w)\)</span> space. Since all these data structures are bounded by the maximum width of the tree, the overall space complexity is <span class="math inline">\(O(w)\)</span>. In the worst case of a complete binary tree, this becomes <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bit-manipulation">Approach 2: Bit Manipulation</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we used two arrays - one for the original values and one for the sorted values. Additionally, we needed a map to keep track of the current positions of each value. This required maintaining three separate data structures and constantly updating the hash map during swaps. This approach was cumbersome and took up a lot of redundant space. Let's try to make the swapping process more space-efficient.</p>
<p>The key insight in this new approach is that we can combine a node's value and its position into a single number using bit manipulation. Since the problem guarantees that the values and positions won't exceed <span class="math inline">\(2^{20}\)</span>, 20 bits are enough to store either piece of information. Therefore, a 40-bit long integer is technically enough to store both the value and position of a node, where the high 20 bits store the value and the low 20 bits store the original position. Let's see how the encoding works with a concrete example. Say we have a node with value 9 at position 6. To encode this:</p>
<ol>
<li>First, we shift 9 left by 20 bits: <span class="math inline">\(9 << 20\)</span>. This moves all the bits of 9 to the left by 20 positions, leaving 20 zeros on the right.</li>
<li>Then we add the position: <span class="math inline">\((9 << 20) + 6\)</span>. The 6 fills in some of those right-most zeros.</li>
</ol>
<p><img src="../Figures/2471/encoding.png" alt="" /></p>
<p>When we need to get back the original position, we use a <code>MASK</code> (0xFFFFF). In binary, this mask has twenty 1's. When we perform an AND operation with the encoded value, it's like using a filter that only lets through the rightmost 20 bits — exactly where we stored our position.</p>
<p><img src="../Figures/2471/decoding.png" alt="" /></p>
<p>The rest of the algorithm is similar to the previous approach, with some simplifications to the swapping process. We iterate through the sorted array, and for each position <code>i</code>, we check if the original position (extracted using the <code>MASK</code>) matches <code>i</code>. If it doesn't match, we know we need a swap. We perform the swap and decrement <code>i</code> to recheck the current position, as the newly swapped number might also need to be moved. We keep counting the swaps over the entire BFS and return the total count at the end as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of bit manipulation techniques, check out the <a href="https://leetcode.com/explore/learn/card/bit-manipulation/">Bit Manipulation Explore Card 🔗</a>. This resource provides an in-depth look at the various bit manipulation techniques and their applications in a variety of problems.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize constants <code>SHIFT</code> and <code>MASK</code> for bit manipulation operations.</p>
</li>
<li>
<p>Initialize:</p>
<ul>
<li>a <code>queue</code> to store nodes for BFS traversal.</li>
<li>a variable <code>swaps</code> to track the total number of operations needed.</li>
</ul>
</li>
<li>
<p>Add the <code>root</code> node to <code>queue</code> to begin traversal.</p>
</li>
<li>
<p>While the <code>queue</code> is not empty:</p>
<ul>
<li>Get the size of the current level using the <code>queue</code> size.</li>
<li>Initialize an array <code>nodes</code> of type long to store encoded values and positions.</li>
<li>For each node at the current level:
<ul>
<li>Remove the node from the <code>queue</code>.</li>
<li>Encode the node's value and current position into a single long integer:
<ul>
<li>Shift the value left by 20 bits.</li>
<li>Add the current position in the lower 20 bits.</li>
</ul>
</li>
<li>Store the encoded value in the <code>nodes</code> array.</li>
<li>Add the left and right children to the <code>queue</code> if they exist.</li>
</ul>
</li>
<li>Sort the <code>nodes</code> array by values (using the higher 20 bits).</li>
<li>For each position <code>i</code> in the sorted array:
<ul>
<li>Extract the original position from the lower 20 bits using the AND operation with <code>MASK</code>.</li>
<li>If the original position doesn't match the current position:
<ul>
<li>Swap the nodes at the current and original positions.</li>
<li>Decrement <code>i</code> to recheck current position.</li>
<li>Increment the <code>swaps</code> counter.</li>
</ul>
</li>
<li>Continue until all the nodes are in the correct positions.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the total <code>swaps</code> as the final answer.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/nvkiMUoN/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The BFS traversal visits each node exactly once, contributing <span class="math inline">\(O(n)\)</span>. At each level, we sort the <code>nodes</code> array which takes <span class="math inline">\(O(w \log w)\)</span> time, where <span class="math inline">\(w\)</span> is the width of that level.</p>
<p>The swapping phase at each level takes <span class="math inline">\(O(w)\)</span> time. In the worst case of a complete binary tree, <span class="math inline">\(w\)</span> could be <span class="math inline">\(n/2\)</span>, making the complexity <span class="math inline">\(O(n) + O(n \log n) = O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>queue</code> used for the BFS will store at most <span class="math inline">\(w\)</span> nodes at any time, where <span class="math inline">\(w\)</span> is the maximum width of the tree at any level. The <code>nodes</code> array stores <span class="math inline">\(w\)</span> encoded values for the current level being processed. No additional data structures are needed since positions are encoded within the values themselves.</p>
<p>Since all space usage is bounded by the maximum width of the tree, the overall space complexity is <span class="math inline">\(O(w)\)</span>. In the worst case of a complete binary tree, this becomes <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-frequent-subtree-sum/description" target="_blank" rel="noopener noreferrer">Most Frequent Subtree Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return the most frequent <strong>subtree sum</strong>. If there is a tie, return all the values with the highest frequency in any order.</p>

<p>The <strong>subtree sum</strong> of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg" style="width: 207px; height: 183px;" />
<pre>
<strong>Input:</strong> root = [5,2,-3]
<strong>Output:</strong> [2,-3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg" style="width: 207px; height: 183px;" />
<pre>
<strong>Input:</strong> root = [5,2,-5]
<strong>Output:</strong> [2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, we have to return the array of sums of subtrees with maximum frequency.<br />
And a subtree sum is the sum of all nodes of a subtree.</p>
<p><img src="../Figures/508/Slide1.png" alt="subtree" /></p>
<p>Let's go from naive to an optimized approach for finding the frequency of all subtree sums in a given tree.</p>
<hr />
<h3 id="approach-1-pre-order-traversal">Approach 1: Pre-Order Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p>We have to find the sum of all subtrees.<br />
So, we can think of traversing the given tree in pre-order (i.e. root first, then left and right children), and for each node, we find the sum of the subtree where the current node is the root node.</p>
<p><strong>Now, how we can find the sum of all nodes of a tree, provided we have a root node?</strong><br />
Remember one thing, thinking recursively is the most easy way to solve tree problems.</p>
<p>Here, if we had the sum of left and right subtrees of the current root, then we can say the current subtree's sum will be:<br />
<code>current root's value + left subtree sum + right subtree sum</code></p>
<p><img src="../Figures/508/Slide2.png" alt="tree_sum" /></p>
<p>Thus, we can recursively find the sum of the left and right subtrees of the given node and return the current node's tree's sum.<br />
We also need some base conditions to stop the recursion. The base condition is simply the case where we can get the result without doing any computation.</p>
<p><strong>Can you tell what will be the sum of nodes of an empty tree?</strong><br />
Exactly it can be considered 0 as there are no nodes present. Thus, this is our base case.</p>
<p>Thus, our pseudocode for finding sum of all nodes of a subtree will look like:</p>
<pre><code>int findTreeSum(TreeNode root) {
    // Base condition.
    if !root {
        return 0
    }
    
    // Current root's tree's sum will be, current root's value + left subtree sum + right subtree sum.
    return root.val + findTreeSum(root.left) + findTreeSum(root.right)
}
</code></pre>
<p>Let's now look at this slideshow to better understand this.</p>
<p>!?!../Documents/508/slideshow1.json:960,540!?!</p>
<br />
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>sumFreq</code>, hashmap to store frequency count of all sums.</li>
<li><code>maxFreq</code>, variable to store the maximum frequency.</li>
<li><code>maxFreqSums</code>, array to store values of all different sums whose frequency is maximum.</li>
</ul>
</li>
<li>
<p>Iterate over each node of the given tree using pre-order traversal:</p>
<ul>
<li>Calculate the current node's subtree's sum as discussed above.</li>
<li>Increment the sum's frequency in <code>sumFreq</code>.</li>
<li>If the current subtree's sum's frequency is greater than <code>maxFreq</code>, store it's frequency in <code>maxFreq</code>.</li>
</ul>
</li>
<li>
<p>Iterate over <code>sumFreq</code> map, and push all sums in <code>maxFreqSums</code> array whose frequency is equal to <code>maxFreq</code>.</p>
</li>
<li>
<p>Return <code>maxFreqSums</code> array.</p>
</li>
</ol>
<p>!?!../Documents/508/slideshow2.json:960,540!?!</p>
<br />
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HtGHE6ZM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^{2})\)</span>.</p>
<ul>
<li>We iterate over each node of the tree and then calculate the sum of the node's subtree.</li>
<li>For finding the sum of a subtree, we traverse each node of that subtree, in worst-case, tree can be skew thus it is <span class="math inline">\(O(N)\)</span> time operation. Thus, for finding the sum of subtree for <span class="math inline">\(N\)</span> nodes, it will take <span class="math inline">\(O(N^2)\)</span> time.</li>
<li>In the end we traverse on all the unique sums, and as there are <span class="math inline">\(N\)</span> subtrees, <span class="math inline">\(N\)</span> different sums are possible, thus in worst-case we will iterate on <span class="math inline">\(N\)</span> elements.</li>
<li>Thus, overall we take <span class="math inline">\(O(N^2 + N) = O(N^2)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>Our hashmap, stores all different possible subtree sums. There are <span class="math inline">\(N\)</span> nodes, which means <span class="math inline">\(N\)</span> different subtrees are possible with different sums, thus requiring <span class="math inline">\(O(N)\)</span> space.</li>
<li>Both function's recursion call stack can take at most <span class="math inline">\(O(N)\)</span> space in case of a skew tree. Thus, in the worst-case scenario, the recursive stack space used will be <span class="math inline">\(O(N + N) = O(N)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-post-order-traversal">Approach 2: Post-Order Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>One thing we can notice is that we will repeatedly traverse to the same set of nodes again and again while traversing in the pre-order direction.<br />
Because a smaller subtree can be part of bigger subtrees.</p>
<p><img src="../Figures/508/Slide40.png" alt="tree_repeat" /></p>
<p>Now imagine if there were hundreds of layers. The smaller subtree will be traversed a lot of times.</p>
<p>We know, that if we had the sum of left and right subtrees of the current root, then we can say the current subtree's sum will be:<br />
<code>current root's value + left subtree sum + right subtree sum</code>.</p>
<p>So instead of going from root to child nodes, and repeatedly calculating the sum of the subtree of child nodes,<br />
we can traverse to child nodes first and then use the sum of the child node's subtree to get the sum of the current node's subtree.</p>
<p>Look at this slideshow to better understand this.</p>
<p>!?!../Documents/508/slideshow3.json:960,540!?!</p>
<br />
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>sumFreq</code>, hashmap to store frequency count of all sums.</li>
<li><code>maxFreq</code>, variable to store the maximum frequency.</li>
<li><code>maxFreqSums</code>, array to store values of all different sums whose frequency is maximum.</li>
</ul>
</li>
<li>
<p>Iterate over each node of the given tree using post-order traversal:</p>
<ul>
<li>Using the left and right child's tree's sum, calculate the current node's tree's sum.</li>
<li>Increment the sum's frequency in <code>sumFreq</code>.</li>
<li>If the current subtree's sum's frequency is greater than <code>maxFreq</code>, update <code>maxFreq</code> as this frequency.</li>
</ul>
</li>
<li>
<p>Iterate over <code>sumFreq</code> map, and push all sums in the <code>maxFreqSums</code> array whose frequency is equal to <code>maxFreq</code>.</p>
</li>
<li>
<p>Return <code>maxFreqSums</code> array.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/XRPVqQmt/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>We iterate over each node of the tree only once and find its subtree sum in <span class="math inline">\(O(1)\)</span> time. Thus, it takes <span class="math inline">\(O(N)\)</span> time to find all the subtree sums of a tree with <span class="math inline">\(N\)</span> nodes.</li>
<li>In the end we traverse on all the unique sums, and as there are <span class="math inline">\(N\)</span> subtrees, <span class="math inline">\(N\)</span> different sums are possible, thus in worst-case we will iterate on <span class="math inline">\(N\)</span> elements.</li>
<li>Thus, overall we take <span class="math inline">\(O(N + N) = O(N)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span>.</p>
<ul>
<li>We use a hashmap to store all different possible subtree sums. There are <span class="math inline">\(N\)</span> nodes, which means <span class="math inline">\(N\)</span> different subtrees are possible with different sums, thus requiring <span class="math inline">\(O(N)\)</span> space.</li>
<li>Recursion call stack can also take at most <span class="math inline">\(O(N)\)</span> space in case of a skew tree.</li>
<li>Thus, overall we require <span class="math inline">\(O(N + N) = O(N)\)</span> extra space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-good-leaf-nodes-pairs/description" target="_blank" rel="noopener noreferrer">Number of Good Leaf Nodes Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree and an integer <code>distance</code>. A pair of two different <strong>leaf</strong> nodes of a binary tree is said to be good if the length of <strong>the shortest path</strong> between them is less than or equal to <code>distance</code>.</p>

<p>Return <em>the number of good leaf node pairs</em> in the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/09/e1.jpg" style="width: 250px; height: 250px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4], distance = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/09/e2.jpg" style="width: 250px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7], distance = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only good pair is [2,5].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the <code>tree</code> is in the range <code>[1, 2<sup>10</sup>].</code></li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li><code>1 &lt;= distance &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the root of a binary tree, we need to find the number of distinct pairs of leaf nodes whose shortest path distance is less than the given <code>distance</code>. The shortest path length between nodes is defined as the minimum number of edges traversed.</p>
<hr />
<h3 id="approach-1-graph-conversion--bfs">Approach 1: Graph Conversion + BFS</h3>
<h3 id="intuition">Intuition</h3>
<p>Because we're interested only in the leaf nodes of the tree, we can start by using any tree traversal algorithm (pre-order, in-order, or post-order) to identify all the leaf nodes.</p>
<p>However, once we have a leaf node, traversing back up the tree to explore paths to other leaf nodes is challenging because we lack direct access to its parent/ancestor nodes. In a binary tree, each node references only its children. To overcome this, we can convert the binary tree into an undirected graph. This allows nodes to reference both their parents and children, simplifying traversal.</p>
<p>After converting the tree to a graph, we can apply graph traversal algorithms to find the shortest paths between leaf nodes. Breadth-first search (BFS) is particularly suitable for this task as it finds the shortest paths in graphs with unweighted edges. In our newly converted graph, all edges are considered unweighted since they all have equal cost. We can run BFS from each leaf node, and for each leaf node that BFS encounters within the given <code>distance</code>, we count it as a good leaf node pair.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Initialize an adjacency list to convert the tree into a graph.</li>
<li>Initialize a set to store the leaf nodes of the tree.</li>
<li>Use a helper method <code>traverseTree</code> to traverse the tree to build the graph and find the leaf nodes. Maintain the current node as well as the parent node in the parameters.
<ul>
<li>If the current node is a leaf node, add it to the set initialize in step 2.</li>
<li>In the adjacency list, add the current node to the parent node's list of neighbors. Also, add the parent node to the current node's list of neighbors.</li>
<li>Recursively call <code>traverseTree</code> for the current node's left child and right child.</li>
</ul>
</li>
<li>Initialize an <code>ans</code> variable to count the number of good leaf node pairs.</li>
<li>Iterate through each leaf node in the set:
<ul>
<li>Run BFS for the current leaf node. BFS can be terminated early once all nodes that are a <code>distance</code> away from the current leaf node are discovered. Increment <code>ans</code> for every leaf node encountered in each BFS run.</li>
</ul>
</li>
<li>Return <code>ans / 2</code>. We count each pair twice so we need to divide by 2 to get the actual count.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/5F4hkKjP/shared">code</a></p>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the size of the binary tree given by <code>root</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>Traversing the tree to build the graph and find the list of leaf nodes takes <span class="math inline">\(O(N)\)</span> time. This is because there are <code>N</code> total nodes to process and each node takes constant time to be processed (adding to the graph and set are constant time operations).</p>
<p>BFS runs for each leaf node in the binary tree. The number of leaf nodes is linearly proportional to the total size of the tree. In the worst case, each BFS traversal covers the entire graph, which takes <span class="math inline">\(O(N)\)</span> time. Therefore, the overall time complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The adjacency list, set of leaf nodes, BFS queue, and BFS seen set all require <span class="math inline">\(O(N)\)</span> space individually. Therefore, the overall space complexity remains <span class="math inline">\(O(N)\)</span></p>
</li>
</ul>
<h3 id="approach-2-post-order-traversal">Approach 2: Post-Order Traversal</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In a binary tree, the shortest path between any two nodes will always go through their lowest common ancestor (LCA). The LCA of two nodes <code>x</code> and <code>y</code> is the deepest node that is an ancestor to both <code>x</code> and <code>y</code>. Utilizing this insight, we can efficiently count the shortest paths between leaf nodes that traverse each node <code>n</code> in the tree. For every node <code>n</code>, we consider paths between all pairs of descendant leaf nodes under <code>n</code> and check if they are within the specified <code>distance</code>. Since <code>n</code> serves as the LCA for these leaf nodes, these paths are inherently the shortest.</p>
<p>To achieve this efficiently, we use a post-order traversal of the tree. In this traversal, calculations for each node <code>root</code> are performed after recursively processing its left and right subtrees. For our problem, this involves counting all shortest paths between leaf nodes passing through <code>root</code>. By leveraging results from recursive calls on the left and right subtrees, we can efficiently find the total count of such paths across the entire tree.</p>
<p>Suppose each recursive call returns the count of leaf nodes that are a distance <code>d</code> away for all possible values of <code>d</code>.</p>
<p><img src="../Figures/1530/TreeWithDistanceCounts.png" alt="Subtrees returning leaf node counts for each distance" /></p>
<p>In this illustration, the recursive call to the left subtree rooted at <code>node 4</code> returns 1 leaf node at distance 0 from <code>node 4</code>. Similarly, the recursive call to the right subtree rooted at <code>node 5</code> returns 2 leaf nodes at distance 1 from <code>node 5</code>. This allows us to compute the number of optimal shortest paths through <code>node 2</code> by iterating over distance pairs. For instance, the distance of the shortest leaf node path that goes through <code>node 2</code> is computed as <code>2 + leftSubtreeLeafNodeDistance + rightSubtreeLeafNodeDistance = 2 + 0 + 1 = 3</code>. In this scenario, because there is 1 leaf node in the left subtree and 2 leaf nodes in the right subtree, the total number of pairs for this distance is <code>numberOfLeafNodesInLeftSubtree * numberOfLeafNodesInRightSubtree = 1 * 2 = 2</code>. We only count the pairs whose shortest path distance is less than or equal to <code>distance</code> for our final answer.</p>
<p><img src="../Figures/1530/TreeWithPath.png" alt="Stitching leaf node path that goes through current node" /></p>
<p>Finally, once these computations are completed, the next step is to return the counts of leaf nodes for all distances <code>d</code> from the current node. This is achieved by shifting all the counts returned from the left and right subtree by 1. For instance, 1 leaf node that is a distance 0 from <code>node 4</code> will translate to 1 leaf node that is a distance 1 from <code>node 2</code>.</p>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Define <code>postOrder(TreeNode currentNode, int distance)</code> helper function. This function will return an array that contains the count of leaf nodes for all possible distances from <code>currentNode</code> (<code>currentNode[0]</code> to <code>currentNode[10]</code>), as well as the total number of good leaf nodes pairs rooted at <code>currentNode</code> (<code>currentNode[11]</code>).
<ul>
<li>If <code>currentNode</code> is <code>null</code>, then return an empty array with all 0s.</li>
<li>If <code>currentNode</code> is a leaf node, then return an array where the count for leaf nodes with distance 0 is set to 1.</li>
<li>Recursively call <code>postOrder</code> on the left subtree and store the result in the <code>left</code> array.</li>
<li>Recursively call <code>postOrder</code> on the right subtree and store the result in the <code>right</code> array.</li>
<li>Initialize a <code>current</code> array.</li>
<li>Shift the counts in <code>left</code> and <code>right</code> by 1 in <code>current</code>. Specifically, for each distance <code>d</code>:
<ul>
<li><code>current[d+1] = left[d] + right[d]</code>.</li>
</ul>
</li>
<li>Initialize <code>current[11]</code> to <code>left[11] + right[11]</code>. This is the total number of good leaf nodes pairs under the left and right subtrees.</li>
<li>For all distance pairs <code>(d1, d2)</code>:
<ul>
<li>If <code>2 + d1 + d2 &lt;= distance</code>, then <code>current[11] += left[d1] * right[d2]</code>.</li>
</ul>
</li>
<li>Return <code>current</code>.</li>
</ul>
</li>
<li>Return <code>postOrder(root, distance)[11]</code>, the total number of good leaf nodes pairs rooted at <code>root</code>.</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/iFMqvTzM/shared">code</a></p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the size of the binary tree rooted at <code>root</code>, <span class="math inline">\(D\)</span> be the maximum distance given by <code>distance</code>, and <span class="math inline">\(H\)</span> be the height of the binary tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot D^2)\)</span></p>
<p>The post-order traversal visits each node, which will take <span class="math inline">\(O(N)\)</span> linear time. At each node, constructing the <code>current</code> array involves iterating through the <code>left</code> and <code>right</code> arrays, and checking distance pairs to find paths within <code>distance</code>. Given the constant size (12), constructing <code>current</code> is <span class="math inline">\(O(1)\)</span>.</p>
<p>Checking distance pairs takes <span class="math inline">\(O(D^2)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(N \cdot D^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(H)\)</span></p>
<p>The recursion call stack, <code>current</code> array, <code>left</code> array, and <code>right</code> array all contribute to the space complexity. The maximum depth of the call stack will be proportional to the height of the tree. The arrays (<code>current</code>, <code>left</code>, <code>right</code>) have constant space (12 elements), <span class="math inline">\(O(1)\)</span>. Thus, the overall space complexity is <span class="math inline">\(O(H)\)</span>.</p>
</li>
</ul>
<h3 id="approach-3-post-order-traversal-with-prefix-sum-counting">Approach 3: Post-Order Traversal With Prefix Sum Counting</h3>
<h3 id="intuition-2">Intuition</h3>
<p>In the previous approach, evaluating all possible leaf node distance pairs involves an expensive <span class="math inline">\(O(N^2)\)</span> operation. This is because for each leaf node, we need to compare its distance with every other leaf node, leading to a quadratic time complexity.</p>
<p>However, we can optimize this process by recognizing that only specific pairs <span class="math inline">\((d1, d2)\)</span> need to be considered. Specifically, we are interested in pairs where <span class="math inline">\(2 + d1 + d2 \leq \text{distance}\)</span>. This condition ensures that the combined distance does not exceed the given threshold.</p>
<p>To count these pairs more efficiently, we iterate over possible values of <code>d2</code>. For each <code>d2</code>, we count all valid <code>d1</code> values that satisfy <span class="math inline">\(0 \leq d1 \leq \text{distance} - d2 - 2\)</span>. This constraint helps us focus only on pairs that meet the distance requirement.</p>
<p>The total number of good pairs for a specific <code>d2</code> can be calculated as <span class="math inline">\((\text{left}[0] \times \text{right}[d2]) + (\text{left}[1] \times \text{right}[d2]) + \ldots + (\text{left}[\text{distance} - d2 - 2] \times \text{right}[d2])\)</span>. This expression sums the products of corresponding counts of distances from the left and right subtrees.</p>
<p>To simplify, we can rewrite this sum as <span class="math inline">\(\text{right}[d2] \times (\text{left}[0] + \text{left}[1] + \ldots + \text{left}[\text{distance} - d2 - 2])\)</span>. The term inside the parentheses is a prefix sum of the left subtree distances, which we can compute efficiently.</p>
<h3 id="algorithm-2">Algorithm</h3>
<ol>
<li>Define the <code>postOrder(TreeNode currentNode, int distance)</code> helper function. This function will return an array that contains the count of leaf nodes for all possible distances from <code>currentNode</code> (<code>currentNode[0]</code> to <code>currentNode[10]</code>), as well as the total number of good leaf node pairs rooted at <code>currentNode</code> (<code>currentNode[11]</code>).
<ul>
<li>If <code>currentNode</code> is <code>null</code>, then return an empty array with all 0s.</li>
<li>If <code>currentNode</code> is a leaf node, then return an array where the count for leaf nodes with distance 0 is set to 1.</li>
<li>Recursively call <code>postOrder</code> on the left subtree and store the result in the <code>left</code> array.</li>
<li>Recursively call <code>postOrder</code> on the right subtree and store the result in the <code>right</code> array.</li>
<li>Initialize a <code>current</code> array.</li>
<li>Shift the counts in <code>left</code> and <code>right</code> by 1 in <code>current</code>. Specifically, for each distance <code>d</code>:
<ul>
<li><code>current[d+1] = left[d] + right[d]</code>.</li>
</ul>
</li>
<li>Initialize <code>current[11]</code> to <code>left[11] + right[11]</code>. This is the total number of good leaf node pairs under the left and right subtrees.</li>
<li>Initialize <code>prefixSum</code> and <code>i</code> to 0</li>
<li>For all <code>d2</code> from <code>distance - 2</code> to <code>1</code>:
<ul>
<li><code>prefixSum += left[i++]</code></li>
<li><code>current[11] += prefixSum * right[d2]</code></li>
</ul>
</li>
<li>Return <code>current</code>.</li>
</ul>
</li>
<li>Return <code>postOrder(root, distance)[11]</code>, the total number of good leaf nodes pairs rooted at <code>root</code>.</li>
</ol>
<h3 id="implementation-2">Implementation</h3>
<p><a href="https://leetcode.com/playground/FJd3EZsA/shared">code</a></p>
<h3 id="complexity-analysis-2">Complexity Analysis</h3>
<p>Let <span class="math inline">\(N\)</span> be the size of the binary tree rooted at <code>root</code>, <span class="math inline">\(D\)</span> be the maximum distance given by <code>distance</code>, and <span class="math inline">\(H\)</span> be the height of the binary tree.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \cdot D)\)</span></p>
<p>Similar to the previous approach, the post-order traversal which will take <span class="math inline">\(O(N)\)</span> time, where constructing <code>current</code> for a given node is <span class="math inline">\(O(1)\)</span>.</p>
<p>Counting all the good leaf node distance pairs will take <span class="math inline">\(O(D)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(N \cdot D)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(H)\)</span></p>
<p>Just like before, the maximum depth of the call stack will be proportional to the height of the tree. The arrays (<code>current</code>, <code>left</code>, <code>right</code>) have constant space (12 elements), <span class="math inline">\(O(1)\)</span>. Thus, the overall space complexity is <span class="math inline">\(O(H)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description" target="_blank" rel="noopener noreferrer">Number of Ways to Reorder Array to Get Same BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p>

<ul>
	<li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li>
</ul>

<p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p>

<p>Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/bb.png" style="width: 121px; height: 101px;" />
<pre>
<strong>Input:</strong> nums = [2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex1.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex4.png" style="width: 121px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no other orderings of nums that will yield the same BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All integers in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-recursion">Approach: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>We can make the following conclusions:</p>
<ul>
<li>
<p>The first element of <code>nums</code> always corresponds to the root node of the corresponding BST.</p>
</li>
<li>
<p>According to the definition of a binary search tree (BST), all elements less than the root value belong to the left subtree, while all elements greater than the root value belong to the right subtree (as shown in the figure below). Let's temporarily ignore the specific structure of the left and right subtrees for now.</p>
</li>
</ul>
<p><img src="../Figures/1569/1.png" alt="img" /></p>
<p>Let <code>dfs(nums)</code> denote the number of permutations of <code>nums</code> that result in the same BST as <code>nums</code>. When iterating over the elements of <code>nums[1:]</code>, we can construct two subtrees using the subsequences <code>left_nodes = [1, 2]</code> and <code>right_nodes = [4, 5]</code> by adding each element to either the left or right subtree of the root. As long as the <strong>relative position</strong> of the elements within <code>[1, 2]</code> or <code>[4, 5]</code> remains unchanged, rearranging their positions in <code>nums</code> does not affect the construction of the subtrees.</p>
<blockquote>
<p>It should be noted that maintaining the relative positions of the numbers in each sequence does not necessarily mean that rearranging the order will always result in a different BST. However, this issue will be addressed in the next level of the subproblem, which will be considered in <code>dfs(left_nodes)</code> or <code>dfs(right_nodes)</code> by allowing the order to be changed. In the current level of recursion <code>dfs(nums)</code>, we do not consider the issue of the next level.</p>
</blockquote>
<p><img src="../Figures/1569/6.png" alt="img" /></p>
<p>Therefore, we obtain the following recursive relation:</p>
<p><span class="math display">\[
However, it is important to note that the actual number of valid permutations may exceed the calculated number from above. This is because there are some permutations that do not alter the relative order of the nodes in `left_nodes` and `right_nodes` thus resulting in the same BST.

<br>

For instance, let's consider the original array `[3,4,5,1,2]`. Here, we use `[1, 2]` to construct the left subtree and `[4, 5]` to construct the right subtree. If we only change the positions of `1` and `2` in `nums[1:]` without altering their relative order, the subsequences used to construct the left and right subtree will still be `[1, 2]` and `[4, 5]`, resulting in the same left subtree.


![img](../Figures/1569/2.png)


This implies that we need to adjust the formula by multiplying it with a coefficient ($$P$$) that represents the number of permutations that preserve the relative order of nodes in the two subsequence `left_nodes` and `right_nodes`. This leads to the modified equation:

$$\text{dfs(nums)} = P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$


It is possible to arbitrarily select two cells to hold the nodes of the left subtree, and there are 6 permutations that generate the same `left_nodes` and `right_nodes`. Therefore, we set $$P=6$$ in the above equation.

![img](../Figures/1569/3.png)


In general, for an array of length `m` with `left` nodes in the left subtree, then the number of valid permutations is equal to the number of ways of selecting `k` cells from `m - 1` cells (excluding the first cell that represents the root). This can be expressed using the binomial coefficient formula:

$$C_{m-1}^\text{left} = \binom{m-1}{\text{left}} = \frac{(m-1)!}{\text{left}!(m-1-\text{left})!}$$



<details> <summary>
        <b> &ensp; If you are not aware of the binomial coefficient, let's get a brief idea about it (click to expand) We have hidden this section in order to keep the main content coherent. Our focus is on practical applications rather than on specific implementations and theories. </b> </summary>

<br>

To efficiently compute the binomial coefficients, we can use Pascal's triangle and precompute a table to avoid repetitive calculations. To build this table, we first determine the number of rows we need based on the size of `nums`, denoted as `m`. We create a $$m \times m$$ table to represent the first `m - 1` rows of Pascal's triangle.

The numbers in Pascal's triangle are generated by summing the two numbers directly above it. We initialize the first column and the main diagonal as `1`. We then iterate over the lower-left half of the table, starting from `table[2][1]`, and compute `table[i][j]` as the sum of `table[i - 1][j - 1]` and `table[i - 1][j]`.

![img](../Figures/1569/5.png)

After building the table, we can efficiently compute the value of $$C_n^k$$ by directly looking up `table[n][k]`.

</details>

<br>

Now we can recursively solve this problem by dividing `nums` into two subsequences `left_nodes` (of length `k`) and `right_nodes`, and the number of valid permutations is denoted as 
$$ \text{dfs(nums)} \\= P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)} \\= C_{n}^{k}\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$. 


where $$C_{n}^{k}$$ can be obtained by using the precomputed table we discussed before or built-in functions. We treat the calls to `dfs` on the two subsequences as subproblems, and recursively solve them. The algorithm always selects the first element as the root value, and the size of the input array gradually decreases as the recursion progresses.


If the input array `nums` contains one or two elements, it only has one permutation that constructs the same BST (which is `nums` itself). Thus we have `dfs(nums) = 1` when `nums.length < 3`, which are the base cases.


<br>

Take the picture below as a detailed example.

- For `nums = [5, 1, 8, 3, 7, 9, 4, 2, 6]`, we need to keep the relative order in `[1, 3, 4, 2]` and `[8, 7, 9, 6]` unchanged, there could be $$C_8^4$$ different permutations.

- Now we move on to the left subtree constructed by `[1, 3, 4, 2]`, there is no left subtree for `root = 1` so we have the coefficient as $$C_3^0$$.

- For the right subtree constructed by `[3, 2, 4]`, we have the coefficient as $$C_2^1$$.

and so on.

![img](../Figures/1569/40.png)

Therefore, the number of permutations is equal to the product of all coefficients, which is $$\text{answer} = C_8^4 \cdot C_3^0 \cdot C_3^2 \cdot C_2^1  \cdot 1 \cdot 1 \cdot 1$$. 

Lastly, don't forget to return $$(\text{answer} - 1) \% (10^9 +7)$$ as we don't count the original `nums` as a valid permutation.


<br>

#### Algorithm


1) Define a function `dfs(nums)` as the number of valid permutations.
    - If the size of `nums` is less than 3, meaning there are 0, 1, or 2 nodes, the function returns 1, as there is only one possible permutation in each of these cases.
    - Otherwise, the function selects the first element of `nums` as the value of the root node. It then partitions the remaining elements `nums[1:]` into two subsequences, `left_nodes` and `right_nodes`, representing the values of the nodes in the left and right subtrees, respectively.
    - Let `m` be the size of `nums` and `k` be the size of `left_nodes`. Return the product of `dfs(left_nodes) * dfs(right_nodes)` and $$C_n^k$$.

2) In Java or C++, we need to build a table of Pascal's of size $$m \times m$$, since there are at most $$m - 1$$ nodes in a subtree, 
    - Initialize the first column and the main diagonal of the table to `1`.
    - Iterate over each empty cell in the lower left triangle of `table` from top to bottom and from left to right. Set `table[i][j]` as `table[i - 1][j] + table[i - 1][j - 1]`.

    Return `table[n][k]` if we need to compute $$C_n^k$$.


3) Return `(dfs(nums) - 1) % (1_000_000_007)`.

#### Implementation

[code](https://leetcode.com/playground/NmZAKnGX/shared)


#### Complexity Analysis

Let $$m$$ be the size of `nums`.

* Time complexity: $$O(m^2)$$
    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built, which takes $$O(m^2)$$ time.
    - `dfs(nums)` recursively calls itself to process the left and right subtrees of the current node `nums[0]`. Since the total size of the subtrees decreases by 1 at each level of the recursion, the maximum height of the recursion tree is $$m$$. Thus the total time complexity of the recursive solution is $$O(m^2)$$ because in each call we are doing $$O(m)$$ work creating the subsequences.

    

* Space complexity: $$O(m^2)$$ or $$O(m)$$

    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built.
    - The recursive solution uses the call stack to keep track of the current subtree being processed. The maximum depth of the call stack is equal to the height of the BST constructed from the input array. In the worst case, `nums` may form a degenerate BST (e.g., a sorted array), which has a height of $$m - 1$$, and the stack can hold up to $$m - 1$$ calls, resulting in a space complexity of $$O(m)$$.

<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-in-zigzag-labelled-binary-tree/description" target="_blank" rel="noopener noreferrer">Path In Zigzag Labelled Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">math</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In an infinite binary tree where every node has two children, the nodes are labelled in row order.</p>

<p>In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/06/24/tree.png" style="width: 300px; height: 138px;" /></p>

<p>Given the <code>label</code> of a node in this tree, return the labels in the path from the root of the tree to the&nbsp;node with that <code>label</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> label = 14
<strong>Output:</strong> [1,3,4,14]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> label = 26
<strong>Output:</strong> [1,2,6,10,26]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= label &lt;= 10^6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-sum/description" target="_blank" rel="noopener noreferrer">Path Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>

<p>A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" style="width: 500px; height: 356px;" />
<pre>
<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
<strong>Output:</strong> true
<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" />
<pre>
<strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> false
<strong>Explanation:</strong> There are two root-to-leaf paths in the tree:
(1 --&gt; 2): The sum is 3.
(1 --&gt; 3): The sum is 4.
There is no root-to-leaf path with sum = 5.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [], targetSum = 0
<strong>Output:</strong> false
<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-sum-ii/description" target="_blank" rel="noopener noreferrer">Path Sum II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>

<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" style="width: 500px; height: 356px;" />
<pre>
<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]
<strong>Explanation:</strong> There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" style="width: 212px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [1,2], targetSum = 0
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
	<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-sum-iii/description" target="_blank" rel="noopener noreferrer">Path Sum III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>the number of paths where the sum of the values&nbsp;along the path equals</em>&nbsp;<code>targetSum</code>.</p>

<p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" style="width: 450px; height: 386px;" />
<pre>
<strong>Input:</strong> root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
<strong>Output:</strong> 3
<strong>Explanation:</strong> The paths that sum to 8 are shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li>
	<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
	<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]
<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description" target="_blank" rel="noopener noreferrer">Populating Next Right Pointers in Each Node II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">linked list</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree</p>

<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>

<p>Initially, all next pointers are set to <code>NULL</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" style="width: 500px; height: 171px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]
<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong></p>

<ul>
	<li>You may only use constant extra space.</li>
	<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/print-binary-tree/description" target="_blank" rel="noopener noreferrer">Print Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, construct a <strong>0-indexed</strong> <code>m x n</code> string matrix <code>res</code> that represents a <strong>formatted layout</strong> of the tree. The formatted layout matrix should be constructed using the following rules:</p>

<ul>
	<li>The <strong>height</strong> of the tree is <code>height</code>&nbsp;and the number of rows <code>m</code> should be equal to <code>height + 1</code>.</li>
	<li>The number of columns <code>n</code> should be equal to <code>2<sup>height+1</sup> - 1</code>.</li>
	<li>Place the <strong>root node</strong> in the <strong>middle</strong> of the <strong>top row</strong> (more formally, at location <code>res[0][(n-1)/2]</code>).</li>
	<li>For each node that has been placed in the matrix at position <code>res[r][c]</code>, place its <strong>left child</strong> at <code>res[r+1][c-2<sup>height-r-1</sup>]</code> and its <strong>right child</strong> at <code>res[r+1][c+2<sup>height-r-1</sup>]</code>.</li>
	<li>Continue this process until all the nodes in the tree have been placed.</li>
	<li>Any empty cells should contain the empty string <code>&quot;&quot;</code>.</li>
</ul>

<p>Return <em>the constructed matrix </em><code>res</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg" style="width: 141px; height: 181px;" />
<pre>
<strong>Input:</strong> root = [1,2]
<strong>Output:</strong> 
[[&quot;&quot;,&quot;1&quot;,&quot;&quot;],
&nbsp;[&quot;2&quot;,&quot;&quot;,&quot;&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg" style="width: 207px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,4]
<strong>Output:</strong> 
[[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;],
&nbsp;[&quot;&quot;,&quot;2&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;3&quot;,&quot;&quot;],
&nbsp;[&quot;&quot;,&quot;&quot;,&quot;4&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2<sup>10</sup>]</code>.</li>
	<li><code>-99 &lt;= Node.val &lt;= 99</code></li>
	<li>The depth of the tree will be in the range <code>[1, 10]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Pseudo-Palindromic Paths in a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be <strong>pseudo-palindromic</strong> if at least one permutation of the node values in the path is a palindrome.</p>

<p><em>Return the number of <strong>pseudo-palindromic</strong> paths going from the root node to leaf nodes.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png" style="width: 300px; height: 201px;" /></p>

<pre>
<strong>Input:</strong> root = [2,3,1,3,1,null,1]
<strong>Output:</strong> 2 
<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png" style="width: 300px; height: 314px;" /></strong></p>

<pre>
<strong>Input:</strong> root = [2,1,1,1,3,null,null,null,null,null,1]
<strong>Output:</strong> 1 
<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [9]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p><strong>Two subproblems</strong></p>
<p>The problem consists of two subproblems:</p>
<ul>
<li>
<p>Traverse the tree to build all root-to-leaf paths.</p>
</li>
<li>
<p>For each root-to-leaf path, check if it's a pseudo-palindromic path or not.</p>
</li>
</ul>
<p><img src="../Figures/1457/split.png" alt="diff" /><br />
<em>Figure 1. Two subproblems.</em></p>
<p><strong>How to traverse the tree to build all root-to-leaf paths</strong></p>
<p>There are three DFS ways to traverse the tree: preorder, postorder and inorder. Please check two minutes picture explanation if you don't remember them quite well: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line">here is the Python version</a> and <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/328601/all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines">here is the Java version</a>.</p>
<p><img src="../Figures/1457/dfs.png" alt="diff" /><br />
<em>Figure 2. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<blockquote>
<p>Root-to-leaf traversal is so-called <em>DFS preorder traversal</em>. To implement it, one has to follow the straightforward strategy Root-&gt;Left-&gt;Right.</p>
</blockquote>
<blockquote>
<p>There are three ways to implement preorder traversal: iterative, recursive, and Morris. Here we're going to implement the first two.</p>
</blockquote>
<p>Iterative and recursive approaches here do the job in one pass, but they both need up to <span class="math inline">\(\mathcal{O}(H)\)</span> space to keep the stack, where <span class="math inline">\(H\)</span> is a tree height.</p>
<p><strong>How to check if the path is pseudo-palindromic or not</strong></p>
<blockquote>
<p>It's quite evident that the path is pseudo-palindromic if it has at most one digit with an odd frequency.</p>
</blockquote>
<p>How to check that?</p>
<p>The straightforward way is to save each root-to-leaf path into a list and then check each digit for parity.</p>
<p><a href="https://leetcode.com/playground/Sd5dj9ZY/shared">code</a></p>
<p>This method requires keeping each root-to-leaf path, and that becomes space-consuming for the large trees. To save space, let's compute the parity on the fly using bitwise operators.</p>
<blockquote>
<p>The idea is to keep the frequency of digit <code>1</code> in the first bit, <code>2</code> in the second bit, etc: <code>path ^= (1 &lt;&lt; node.val)</code>.</p>
</blockquote>
<p><a href="(https://wiki.python.org/moin/BitwiseOperators)">Left shift operator</a> is used to define the bit, and <a href="https://leetcode.com/problems/single-number-ii/solution/">XOR operator</a> - to compute the digit frequency.</p>
<p><img src="../Figures/1457/xor.png" alt="diff" /><br />
<em>Figure 3. XOR of zero and a bit results in that bit. XOR of two equal bits (even if they are zeros) results in a zero. Hence, one could see the bit in a path only if it appears an odd number of times.</em></p>
<p><a href="https://leetcode.com/playground/Lf7nxpsk/shared">code</a></p>
<p>Now, to ensure that at most one digit has an odd frequency, one has to check that <code>path</code> is a <a href="https://leetcode.com/problems/power-of-two/solution/">power of two</a>, <em>i.e.</em>, at most one bit is set to one. That could be done by turning off (= setting to 0) the rightmost 1-bit: <code>path &amp; (path - 1) == 0</code>. You might want to check the article <a href="https://leetcode.com/problems/power-of-two/solution/">Power of Two</a> for the detailed explanation of this bitwise trick.</p>
<p><img src="../Figures/1457/turn_off.png" alt="diff" /><br />
<em>Figure 4. <code>x &amp; (x - 1)</code> is a way to set the rightmost 1-bit to zero, <em>i.e.</em>, <code>x &amp; (x - 1) == 0</code> for the power of two. To subtract 1 means to change the rightmost 1-bit to 0 and to set all the lower bits to 1. Now AND operator: the rightmost 1-bit will be turned off because <code>1 &amp; 0 = 0</code>, and all the lower bits as well.</em></p>
<p><a href="https://leetcode.com/playground/AGbMsChr/shared">code</a></p>
<br />
<br />
<hr />
<h3 id="approach-1-iterative-preorder-traversal">Approach 1: Iterative Preorder Traversal.</h3>
<p><strong>Intuition</strong></p>
<p>Note: The visual below shows how a stack is used for an inorder traversal. The algorithm and implementation use a preorder traversal. These are both methods for depth-first search, and the only difference is the order in which the nodes are handled.</p>
<p>!?!../Documents/1457_LIS.json:1000,310!?!</p>
<p>Here we implement standard iterative preorder traversal with the stack:</p>
<ul>
<li>
<p>Initialize the counter to zero.</p>
</li>
<li>
<p>Push root into the stack.</p>
</li>
<li>
<p>While the stack is not empty:</p>
<ul>
<li>
<p>Pop out a node from the stack and update the current number.</p>
</li>
<li>
<p>If the node is a leaf, update the root-to-leaf path, check it for being pseudo-palindromic, and update the count.</p>
</li>
<li>
<p>Push right and left child nodes into the stack.</p>
</li>
</ul>
</li>
<li>
<p>Return count.</p>
</li>
</ul>
<p><strong>Implementation</strong></p>
<p>Note, that <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">Javadocs recommends using ArrayDeque, and not Stack as a stack implementation</a>.</p>
<p><a href="https://leetcode.com/playground/CiKngyXi/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node, where <span class="math inline">\(N\)</span> is a number of nodes.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(H)\)</span> to keep the stack, where <span class="math inline">\(H\)</span> is a tree height.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive-preorder-traversal">Approach 2: Recursive Preorder Traversal.</h3>
<p>Iterative approach 1 could be converted into a recursive one.</p>
<p>Recursive preorder traversal is extremely simple: follow Root-&gt;Left-&gt;Right direction, <em>i.e.</em>, do all the business with the node (<em>i.e.</em>, update the current path and the counter), and then do the recursive calls for the left and right child nodes.</p>
<p>P.S. Here is the difference between <em>preorder</em> and the other DFS recursive traversals.</p>
<p><img src="../Figures/1457/dfs.png" alt="diff" /><br />
<em>Figure 5. The nodes are enumerated in the order of visits. To compare different DFS strategies, follow <code>1-2-3-4-5</code> direction.</em></p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/BExGA3yJ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> since one has to visit each node, check if at most one digit has an odd frequency.</p>
</li>
<li>
<p>Space complexity: up to <span class="math inline">\(\mathcal{O}(H)\)</span> to keep the recursion stack, where <span class="math inline">\(H\)</span> is a tree height.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="further-reading">Further Reading</h3>
<p>The problem could be solved in constant space using the Morris inorder traversal algorithm, as it was done in <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/solution/">Sum Root-to-Leaf Numbers</a>. It is unlikely that one can come up with a Morris Traversal solution during an interview, but it is worth knowing anyway.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-of-bst/description" target="_blank" rel="noopener noreferrer">Range Sum of BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> node of a binary search tree and two integers <code>low</code> and <code>high</code>, return <em>the sum of values of all nodes with a value in the <strong>inclusive</strong> range </em><code>[low, high]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" style="width: 400px; height: 222px;" />
<pre>
<strong>Input:</strong> root = [10,5,15,3,7,null,18], low = 7, high = 15
<strong>Output:</strong> 32
<strong>Explanation:</strong> Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" style="width: 400px; height: 335px;" />
<pre>
<strong>Input:</strong> root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
<strong>Output:</strong> 23
<strong>Explanation:</strong> Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>
	<li>All <code>Node.val</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/recover-a-tree-from-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Recover a Tree From Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We run a&nbsp;preorder&nbsp;depth-first search (DFS) on the <code>root</code> of a binary tree.</p>

<p>At each node in this traversal, we output <code>D</code> dashes (where <code>D</code> is the depth of this node), then we output the value of this node.&nbsp; If the depth of a node is <code>D</code>, the depth of its immediate child is <code>D + 1</code>.&nbsp; The depth of the <code>root</code> node is <code>0</code>.</p>

<p>If a node has only one child, that child is guaranteed to be <strong>the left child</strong>.</p>

<p>Given the output <code>traversal</code> of this traversal, recover the tree and return <em>its</em> <code>root</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/10/recover_tree_ex1.png" style="width: 423px; height: 200px;" />
<pre>
<strong>Input:</strong> traversal = &quot;1-2--3--4-5--6--7&quot;
<strong>Output:</strong> [1,2,5,3,4,6,7]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/10/recover_tree_ex2.png" style="width: 432px; height: 250px;" />
<pre>
<strong>Input:</strong> traversal = &quot;1-2--3---4-5--6---7&quot;
<strong>Output:</strong> [1,2,5,3,null,6,null,4,null,7]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/09/10/recover_tree_ex3.png" style="width: 305px; height: 250px;" />
<pre>
<strong>Input:</strong> traversal = &quot;1-401--349---90--88&quot;
<strong>Output:</strong> [1,401,null,349,88,90]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the original tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string representation of a preorder traversal of a binary tree, where each node is represented as <code>D</code> dashes followed by its value. The number of dashes <code>D</code> indicates the depth of the node in the tree, with the root having depth <code>0</code>. Each node may have one or two children, and if a node has only one child, it is always the left child. Our task is to reconstruct the original binary tree from this traversal string.</p>
<p>Since preorder traversal follows the <strong>root → left → right</strong> order, we process the nodes in sequence and assign them to their correct positions.</p>
<p>For example, given <code>traversal = &quot;1-2--3--4-5--6--7&quot;</code>, we can break it down as follows:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000080">1</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Root</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">2</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Left</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">1</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">|</span>  <span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">3</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Left</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">|</span>  <span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">4</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Right</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">5</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Right</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">1</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">6</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Left</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">5</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">|</span><span style="color:#000080">-</span> <span style="color:#000080">7</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000080">Depth</span> <span style="color:#000080">2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000080">Right</span> <span style="color:#000080">child</span> <span style="color:#000080">of</span> <span style="color:#000080">5</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre><p>This means the tree structure is:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>       <span style="color:#000080">1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">\</span>
</span></span><span style="display:flex;"><span>     <span style="color:#000080">2</span>   <span style="color:#000080">5</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">\</span>  <span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">\</span>
</span></span><span style="display:flex;"><span>   <span style="color:#000080">3</span>   <span style="color:#000080">4</span> <span style="color:#000080">6</span>  <span style="color:#000080">7</span>
</span></span></code></pre><p>The output should be: <code>[1, 2, 5, 3, 4, 6, 7]</code>.</p>
<p>Before diving into specific approaches, let’s first build a high-level strategy that applies to all the approaches.</p>
<ol>
<li><strong>Depth determines hierarchy</strong></li>
</ol>
<p>Each node’s position in the tree is determined by the number of dashes (<code>-</code>) before its value:</p>
<ul>
<li>A node with depth <code>D</code> is the child of the last node with depth <code>D - 1</code>.</li>
<li>If a node has a sibling, it appears immediately after its left sibling in the traversal.</li>
<li>If a node does not have a sibling, it is the only child of its parent.</li>
</ul>
<p>This means that the structure of the tree is fully determined by depth information, without requiring additional information like explicit left/right indicators. Because nodes appear before their children in preorder, we can sequentially assign them to their parents without needing to look ahead or backtrack significantly.</p>
<ol start="2">
<li><strong>Maintaining a Structure to Track Parent-Child Relationships</strong></li>
</ol>
<p>To efficiently determine the correct parent for each node, we need a mechanism to track nodes at different depths. There are two main ways to do this:</p>
<ul>
<li>Using Recursion: We can recursively parse the string and build the tree.</li>
<li>Using Stack: We maintain a stack where each node is pushed when encountered. When we process a new node, we find its correct parent by checking the stack for the most recent node with <code>depth - 1</code>.</li>
</ul>
<p>Regardless of the approach, the core idea is the same: When we encounter a new node, we determine its depth. We find the last node at <code>depth - 1</code> and attach the new node as its child. Then we ensure that the first child assigned to a parent is the left child, and the second (if present) is the right child.</p>
<hr />
<h3 id="approach-1-brute-force-recursive-with-string-manipulation">Approach 1: Brute Force (Recursive with String Manipulation)</h3>
<h4 id="intuition">Intuition</h4>
<p>The simplest way to reconstruct a tree from a string is to process the input step by step as the input is in the format of preorder traversal. We know that each number in the string represents a node in the tree, and the number of dashes before it tells us how deep it should be.</p>
<p>To build the tree, first, we count the number of dashes (-). The more dashes we see, the deeper the node is in the tree. After counting the dashes, we extract the number that follows. This number becomes the value of a new node.</p>
<p>Once we have a node, we need to figure out where to place it in the tree. Since the nodes appear in depth-first (preorder) order in the string, we know that every new node belongs as a child of the most recently encountered node that has space for a child. If a node is at a greater depth than the previous one, it must be its left child. If it's at the same depth as the last node, it means we have moved to a new subtree, and it should be attached as a right child instead.</p>
<p>To implement this, we use recursion. A helper function takes the string and the current index, processes the node at that position, and then calls itself to construct the left and right children. This recursion follows the same logic as a depth-first traversal of a tree. If the function encounters a node at the wrong depth, it stops and returns, ensuring that nodes are placed correctly.</p>
<blockquote>
<p>For a more comprehensive understanding of recursion, check out the <a href="https://leetcode.com/explore/learn/card/recursion-i/">Recursion Explore Card 🔗</a>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Start with <code>index = 0</code> and call the recursive <code>helper</code> function with <code>depth = 0</code>.</p>
</li>
<li>
<p>In <code>helper</code> function:</p>
<ul>
<li>
<p>If <code>index</code> exceeds the length of <code>traversal</code>, return <code>nullptr</code>.</p>
</li>
<li>
<p>Count the number of dashes (<code>dashCount</code>) at <code>index</code>:</p>
<ul>
<li>Iterate while the character at <code>index + dashCount</code> is <code>'-'</code>.</li>
<li>Increase <code>dashCount</code> accordingly.</li>
</ul>
</li>
<li>
<p>If <code>dashCount</code> does not match <code>depth</code>, return <code>nullptr</code> (ensures correct tree structure).</p>
</li>
<li>
<p>Move <code>index</code> past the dashes.</p>
</li>
<li>
<p>Extract the numeric value for the node:</p>
<ul>
<li>Initialize <code>value = 0</code>.</li>
<li>While <code>index</code> points to a digit, update <code>value</code> using <code>value * 10 + (digit)</code>.</li>
<li>Increment <code>index</code> for each digit processed.</li>
</ul>
</li>
<li>
<p>Create a new <code>TreeNode</code> with the extracted value.</p>
</li>
<li>
<p>Recursively construct left and right children:</p>
<ul>
<li>Call <code>helper</code> with <code>depth + 1</code> for the left subtree.</li>
<li>Call <code>helper</code> with <code>depth + 1</code> for the right subtree.</li>
</ul>
</li>
<li>
<p>Return the constructed <code>TreeNode</code>.</p>
</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dFsKLqhx/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We traverse the input string exactly once while parsing node values and dashes. Each character is processed a constant number of times. However, the depth of the tree impacts the reconstruction process. In the worst case, when the tree is skewed, finding the correct parent for each node involves scanning up to <span class="math inline">\(O(n)\)</span> previous nodes, leading to an overall <span class="math inline">\(O(n^2)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursion depth is determined by the depth of the tree, which in the worst case (a skewed tree) can be <span class="math inline">\(O(n)\)</span>, leading to an <span class="math inline">\(O(n)\)</span> recursive call stack space. Additionally, we allocate <span class="math inline">\(O(n)\)</span> new <code>TreeNode</code> objects, contributing to an extra <span class="math inline">\(O(n)\)</span> memory usage.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-approach-with-stack-single-pass">Approach 2: Iterative Approach with Stack (Single Pass)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Recursion is useful, but it can be slow because it involves extra function calls and memory overhead. A more efficient way to process the string is to use a stack to keep track of nodes as we build the tree.</p>
<p>Think of the stack as a way to remember where we are in the tree. Each time we find a new node, we check how deep it should be by counting dashes. If the stack already has more nodes than this depth, it means we have finished processing a subtree, so we remove nodes from the stack until we reach the correct depth. The node left at the top of the stack is the parent of the new node.</p>
<p>Since the stack always holds the path from the root to the current node, its length at any point represents how deep we are in the tree. When we encounter a new node, we count the dashes to determine its depth. If the stack is longer than the depth, it means we need to move up in the tree, so we remove nodes from the stack until it matches the correct depth.</p>
<p>Once we identify the parent, we decide whether to attach the new node as its left or right child. If the left child doesn’t exist, we set it as the left child. Otherwise, it must be the right child. Finally, we push the new node onto the stack because it might have its own children in later steps.</p>
<p>The algorithm is visualized below:</p>
<p><img src="../Figures/1028/approach__4.png" alt="approach__4" /></p>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/">Stack Explore Card 🔗</a>.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a <code>stack</code> to keep track of nodes at different depths.</p>
</li>
<li>
<p>Initialize <code>index</code> to 0 for traversing the <code>traversal</code> string.</p>
</li>
<li>
<p>Iterate while <code>index</code> is within the bounds of <code>traversal</code>:</p>
<ul>
<li>Count the number of dashes (<code>-</code>) to determine the <code>depth</code> of the current node.</li>
<li>Extract the numerical value of the node by iterating through the digits.</li>
<li>Create a new <code>TreeNode</code> with the extracted value.</li>
<li>Adjust the <code>stack</code> to ensure it aligns with the correct depth by popping elements if necessary.</li>
<li>Attach the newly created node to its parent:
<ul>
<li>If the top node of the stack has no left child, assign the new node as the left child.</li>
<li>Otherwise, assign it as the right child.</li>
</ul>
</li>
<li>Push the new node onto the stack.</li>
</ul>
</li>
<li>
<p>Ensure the root node is correctly identified by popping extra elements from the stack until only one remains.</p>
</li>
<li>
<p>Return the remaining node in the stack as the root of the reconstructed tree.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/aTogXeZG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We traverse the input string exactly once while counting dashes and extracting node values. Each character is processed a constant number of times, contributing <span class="math inline">\(O(n)\)</span>.</p>
<p>However, in the worst case (a skewed tree), finding the correct parent node may require scanning up to <span class="math inline">\(O(n)\)</span> previous nodes. This results in an additional <span class="math inline">\(O(n)\)</span> factor, leading to an overall <span class="math inline">\(O(n^2)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The maximum depth of the tree determines the maximum size of the stack. In the worst case (a skewed tree), the depth can be <span class="math inline">\(O(n)\)</span>, leading to an <span class="math inline">\(O(n)\)</span> stack size.</p>
<p>Additionally, we allocate <span class="math inline">\(O(n)\)</span> <code>TreeNode</code> objects, contributing to an extra <span class="math inline">\(O(n)\)</span> memory usage.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-iterative-approach-with-list">Approach 3: Iterative Approach with List</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of using a stack, we can implement the solution using a list, as some may find list operations more intuitive. Both a stack and a list perform similar operations, such as appending elements to the end and removing them in a last-in, first-out (LIFO) manner. As a result, the overall time and space complexity remain the same. The choice between the two is mainly a matter of readability and personal preference rather than performance. In fact, in Python 3, there will be negligible difference between the two approaches since both utilize a list for storage.</p>
<p>We traverse the input while keeping track of depth using dashes. Whenever we encounter a digit, we extract the node value directly and create a new node. Instead of using a stack, we maintain a <code>levels</code> list where <code>levels[depth]</code> always holds the last node at that depth.</p>
<p>After extracting a node’s value, we update <code>levels</code> to ensure that the new node is correctly positioned. If a node at the same depth already exists, we replace it; otherwise, we append the new node. The parent of the new node is always stored at <code>levels[depth - 1]</code>, ensuring that the tree structure remains correct as we attach nodes to their left or right children.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>levels</code> array to track the last node at each depth level.</p>
</li>
<li>
<p>Set <code>index</code> to 0 and <code>n</code> to the length of <code>traversal</code>.</p>
</li>
<li>
<p>Iterate while <code>index &lt; n</code>:</p>
<ul>
<li>
<p>Count <code>depth</code> by counting consecutive dashes (<code>-</code>).</p>
</li>
<li>
<p>Extract <code>value</code> by reading digits until a non-digit character is encountered.</p>
</li>
<li>
<p>Create a new <code>TreeNode</code> with the extracted <code>value</code>.</p>
</li>
<li>
<p>If <code>depth</code> is smaller than <code>levels.size()</code>, replace <code>levels[depth]</code> with the new node.</p>
</li>
<li>
<p>Otherwise, append the new node to <code>levels</code>.</p>
</li>
<li>
<p>If <code>depth &gt; 0</code>, attach the new node as a child:</p>
<ul>
<li>Retrieve its <code>parent</code> from <code>levels[depth - 1]</code>.</li>
<li>If <code>parent-&gt;left</code> is null, assign the new node to <code>parent-&gt;left</code>.</li>
<li>Otherwise, assign the new node to <code>parent-&gt;right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>levels[0]</code> as the root of the reconstructed tree.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/fUWWjT7L/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We traverse the input string exactly once to count dashes and extract numeric values. Each character is processed a constant number of times, contributing <span class="math inline">\(O(n)\)</span>.</p>
<p>However, in the worst case (a skewed tree), maintaining the list of levels and finding the correct parent may require scanning up to <span class="math inline">\(O(n)\)</span> previous nodes. This results in an additional <span class="math inline">\(O(n)\)</span> factor, leading to an overall <span class="math inline">\(O(n^2)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The levels list keeps track of at most <span class="math inline">\(O(h)\)</span> nodes, where the tree height <span class="math inline">\(h\)</span> can be at most <span class="math inline">\(O(n)\)</span> in the worst case. Additionally, we allocate <span class="math inline">\(O(n)\)</span> <code>TreeNode</code> objects for the tree itself.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/recover-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Recover Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [1,3,null,null,2]
<strong>Output:</strong> [3,1,null,null,2]
<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" style="width: 581px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,1,4,null,null,2]
<strong>Output:</strong> [2,1,4,null,null,3]
<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-odd-levels-of-binary-tree/description" target="_blank" rel="noopener noreferrer">Reverse Odd Levels of Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a <strong>perfect</strong> binary tree, reverse the node values at each <strong>odd</strong> level of the tree.</p>

<ul>
	<li>For example, suppose the node values at level 3 are <code>[2,1,3,4,7,11,29,18]</code>, then it should become <code>[18,29,11,7,4,3,1,2]</code>.</li>
</ul>

<p>Return <em>the root of the reversed tree</em>.</p>

<p>A binary tree is <strong>perfect</strong> if all parent nodes have two children and all leaves are on the same level.</p>

<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" style="width: 626px; height: 191px;" />
<pre>
<strong>Input:</strong> root = [2,3,5,8,13,21,34]
<strong>Output:</strong> [2,5,3,8,13,21,34]
<strong>Explanation:</strong> 
The tree has only one odd level.
The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" style="width: 591px; height: 111px;" />
<pre>
<strong>Input:</strong> root = [7,13,11]
<strong>Output:</strong> [7,11,13]
<strong>Explanation:</strong> 
The nodes at level 1 are 13, 11, which are reversed and become 11, 13.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]
<strong>Output:</strong> [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]
<strong>Explanation:</strong> 
The odd levels have non-zero values.
The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.
The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 2<sup>14</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>root</code> is a <strong>perfect</strong> binary tree.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the <code>root</code> of a perfect binary tree, and our task is to return the <code>root</code> after reversing the values at the odd levels of the tree.</p>
<blockquote>
<p>A binary tree is considered perfect if all parent nodes have exactly two children and all leaves are on the same level.<br />
The level of a node is defined as the number of edges along the path between it and the root node.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The structure of binary trees is inherently recursive; that is, each node's left and right children can themselves be considered the roots of smaller binary trees. This allows us to traverse the tree using recursion, breaking the problem into smaller, independent subproblems.</p>
<p>As we traverse the tree recursively, we process the left and right children of the current <code>root</code>. For nodes at even levels, we swap the values at their left and right child nodes to reverse the arrangement of nodes below their level, while leaving the children of odd levels unchanged.</p>
<p>Let's discuss the implementation of the recursive function <code>traverseDFS(node, leftChild, rightChild, int level)</code>:</p>
<ul>
<li>
<p>Base case: If <code>leftChild</code> or <code>rightChild</code> is null, then we can stop the recursive traversal for further child nodes.</p>
</li>
<li>
<p>Even level: If the current level is even, swap the values rooted at <code>leftChild</code> and <code>rightChild</code>.</p>
</li>
<li>
<p>Perfect binary tree: Since the binary tree is perfect, it is symmetrical in nature. Therefore, to reverse the levels, we would want to swap the left value of the left child with the right value of the right child, and the right value of the left child with the left value of the right child. This can be illustrated using the slideshow shown below:</p>
</li>
</ul>
<p>!?!../Documents/2415/slideshow.json:960,540!?!</p>
<blockquote>
<p>For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/">DFS Explore Card 🔗</a>. This resource provides an in-depth look at DFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<p>Main function - <code>reverseOddLevels(Node root)</code></p>
<ul>
<li>Call <code>traverseDFS</code> with the left and right children of the root, starting at level 0.</li>
</ul>
<p><code>traverseDFS</code> function:</p>
<ul>
<li>
<p>If either <code>leftChild</code> or <code>rightChild</code> is null, return immediately (base case).</p>
</li>
<li>
<p>If the current <code>level</code> is even (odd-level swapping occurs at 0-based indexing):</p>
<ul>
<li>Swap the values of <code>leftChild</code> and <code>rightChild</code> using a temporary variable.</li>
</ul>
</li>
<li>
<p>Recursively call <code>traverseDFS</code> for the next level:</p>
<ul>
<li>Call <code>traverseDFS</code> with <code>leftChild.left</code> and <code>rightChild.right</code> (mirroring structure).</li>
<li>Call <code>traverseDFS</code> with <code>leftChild.right</code> and <code>rightChild.left</code> (mirroring structure).</li>
</ul>
</li>
<li>
<p>Continue recursion until all levels of the tree are processed.</p>
</li>
<li>
<p>Return the updated <code>root</code> after all odd levels are reversed.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/GrucV3hM/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the given tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, the algorithm visits each node exactly once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>. The swapping at each recursive step takes constant time. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log n))\)</span></p>
<p>The space complexity is determined by the recursion depth of the DFS. Since we are given a perfect binary tree, the height of the tree is bounded by <span class="math inline">\(\log n\)</span>. Therefore, the space complexity is given by <span class="math inline">\(O(\log n))\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of DFS, we can use a breadth-first search (BFS) to traverse the tree level by level and reverse values at odd levels. We start by adding the root node to a queue, which helps manage nodes at each level.</p>
<p>For each level, we will pop all the nodes currently in the queue, which represent the nodes at the current level. Then, we will push their children to the queue to represent the next level. This ensures that the queue always contains the nodes for just one level at a time. When processing odd levels, we will collect the values of the nodes in an array, reverse that array, and then update the nodes' values with the reversed values. This step only happens for odd levels, while even levels remain unchanged.</p>
<p>This process continues until all levels are traversed. Finally, we return the root with the values at odd levels reversed.</p>
<blockquote>
<p>For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card 🔗</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a queue <code>queue</code> to store the level-order traversal of the tree. Initialize it with the <code>root</code> node.</li>
<li>Initialize a variable <code>level</code> to <code>0</code> to keep track of the current tree level.</li>
<li>Perform BFS traversal:
<ul>
<li>While the <code>queue</code> is not empty, process the nodes level by level:
<ul>
<li>Retrieve the size of the current level using the queue size.</li>
<li>Create a list, <code>currentLevelNodes</code>, to store all nodes at the current level.</li>
<li>Iterate over all nodes in the current level:
<ul>
<li>Dequeue each node and add it to <code>currentLevelNodes</code>.</li>
<li>Enqueue its left and right children (if they exist) to the queue for the next level.</li>
</ul>
</li>
<li>Check if the current level is odd:
<ul>
<li>If <code>level % 2 == 1</code>, reverse the values of nodes in <code>currentLevelNodes</code>.</li>
<li>Use two pointers (<code>left</code> and <code>right</code>) to swap values from the leftmost and rightmost ends of the list.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment the <code>level</code> counter after processing each level.</li>
<li>Return the <code>root</code> node after completing the traversal and reversing odd levels.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/LQ6yoTvx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the tree, processing each level of nodes. The main loop performs BFS traversal, visiting each node exactly once, which results in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Additionally, at each level, the algorithm checks if it is odd and reverses the node values if necessary. This operation occurs for each node in the queue and takes constant time per node. The overall time complexity is dominated by the BFS traversal, resulting in <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space used by the algorithm is determined by the queue that holds the nodes at each level during BFS traversal. At most, the queue will hold all the nodes at one level, which is bounded by the number of nodes in the tree, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Other space requirements are constant and do not contribute significantly to the space complexity. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/root-equals-sum-of-children/description" target="_blank" rel="noopener noreferrer">Root Equals Sum of Children</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary tree</strong> that consists of exactly <code>3</code> nodes: the root, its left child, and its right child.</p>

<p>Return <code>true</code> <em>if the value of the root is equal to the <strong>sum</strong> of the values of its two children, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png" style="width: 281px; height: 199px;" />
<pre>
<strong>Input:</strong> root = [10,4,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> The values of the root, its left child, and its right child are 10, 4, and 6, respectively.
10 is equal to 4 + 6, so we return true.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png" style="width: 281px; height: 199px;" />
<pre>
<strong>Input:</strong> root = [5,3,1]
<strong>Output:</strong> false
<strong>Explanation:</strong> The values of the root, its left child, and its right child are 5, 3, and 1, respectively.
5 is not equal to 3 + 1, so we return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The tree consists only of the root, its left child, and its right child.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/same-tree/description" target="_blank" rel="noopener noreferrer">Same Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>

<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" style="width: 622px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2,3], q = [1,2,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" style="width: 382px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2], q = [1,null,2]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" style="width: 622px; height: 182px;" />
<pre>
<strong>Input:</strong> p = [1,2,1], q = [1,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-in-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Search in a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>

<p>Find the node in the BST that the node&#39;s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 2
<strong>Output:</strong> [2,1,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" style="width: 422px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [4,2,7,1,3], val = 5
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>
	<li><code>root</code> is a binary search tree.</li>
	<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/second-minimum-node-in-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Second Minimum Node In a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node&#39;s value is the smaller value among its two sub-nodes. More formally, the property&nbsp;<code>root.val = min(root.left.val, root.right.val)</code>&nbsp;always holds.</p>

<p>Given such a binary tree, you need to output the <b>second minimum</b> value in the set made of all the nodes&#39; value in the whole tree.</p>

<p>If no such second minimum value exists, output -1 instead.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg" style="width: 431px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [2,2,5,null,null,5,7]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The smallest value is 2, the second smallest value is 5.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg" style="width: 321px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [2,2,2]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The smallest value is 2, but there isn&#39;t any second smallest value.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 25]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>root.val == min(root.left.val, root.right.val)</code>&nbsp;for each internal node of the tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/serialize-and-deserialize-binary-tree/description" target="_blank" rel="noopener noreferrer">Serialize and Deserialize Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>

<p><strong>Clarification:</strong> The input/output format is the same as <a href="https://support.leetcode.com/hc/en-us/articles/32442719377939-How-to-create-test-cases-on-LeetCode#h_01J5EGREAW3NAEJ14XC07GRW1A" target="_blank">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,null,null,4,5]
<strong>Output:</strong> [1,2,3,null,null,4,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/serialize-and-deserialize-bst/description" target="_blank" rel="noopener noreferrer">Serialize and Deserialize BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">design</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>

<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>

<p><b>The encoded string should be as compact as possible.</b></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,1,3]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-string-starting-from-leaf/description" target="_blank" rel="noopener noreferrer">Smallest String Starting From Leaf</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree where each node has a value in the range <code>[0, 25]</code> representing the letters <code>&#39;a&#39;</code> to <code>&#39;z&#39;</code>.</p>

<p>Return <em>the <strong>lexicographically smallest</strong> string that starts at a leaf of this tree and ends at the root</em>.</p>

<p>As a reminder, any shorter prefix of a string is <strong>lexicographically smaller</strong>.</p>

<ul>
	<li>For example, <code>&quot;ab&quot;</code> is lexicographically smaller than <code>&quot;aba&quot;</code>.</li>
</ul>

<p>A leaf of a node is a node that has no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/30/tree1.png" style="width: 534px; height: 358px;" />
<pre>
<strong>Input:</strong> root = [0,1,2,3,4,3,4]
<strong>Output:</strong> &quot;dba&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/30/tree2.png" style="width: 534px; height: 358px;" />
<pre>
<strong>Input:</strong> root = [25,1,3,1,3,0,2]
<strong>Output:</strong> &quot;adz&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/01/tree3.png" style="height: 490px; width: 468px;" />
<pre>
<strong>Input:</strong> root = [2,2,1,null,1,0,null,0]
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 8500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 25</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given the root of a binary tree, where each node has a value in the range <code>[0, 25]</code> representing the letters <code>'a'</code> to <code>'z'</code>. The task is to find the lexicographically smallest string that starts at a leaf node and ends at the root of the binary tree.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>The string should start from a leaf node and end at the root node.</li>
<li>The string should be the smallest lexicographically, where a shorter prefix is considered smaller than a longer prefix of equal lexicographical size.</li>
<li>The input values are numbers and represent characters from <code>'a'</code> to <code>'z'</code>, and the output needs to be returned as a string of characters.</li>
</ol>
<p>This article includes tree traversal. If you're not familiar with tree traversal, check out our <a href="https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/">tree traversal explore card</a>.</p>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A common approach to solving this problem is to use a depth-first search (DFS), exploring the tree from the leaf nodes to the root and keeping track of the current string. The idea is to recursively explore all possible paths while maintaining the lexicographically smallest string encountered along the way.</p>
<p>During traversal, we ensure that we visit all nodes to avoid missing any potential lexicographically smallest string. To achieve this, we maintain track of the current values traversed to construct the current string.</p>
<p>As we explore different paths, we check if the current string is lexicographically smaller than the previously encountered smallest string. If the current string is lexicographically smaller, we update it; otherwise, we continue our exploration.</p>
<p>The following is an illustration demonstrating the depth first search approach:</p>
<p>!?!../Documents/988/depth_first_search.json:636,301!?!</p>
<blockquote>
<p><strong>Note:</strong> You may wonder whether a greedy algorithm that assumes that each local optimal step will eventually lead to a globally optimal solution could solve this problem. Consider the test case [4,0,1,1]. In this scenario, a greedy approach would fail to produce the correct result. Similarly, in the case of [25,1,null,0,0,1,null,null,null,0], the expected answer is &quot;ababz&quot;, but the greedy solution would result in &quot;abz&quot;.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty string <code>smallestString</code> to store the lexicographically smallest string.</p>
</li>
<li>
<p>Call the helper function <code>dfs(root, &quot;&quot;)</code>.</p>
<ul>
<li>The <code>dfs</code> function takes the current node <code>root</code> and the current string <code>currentString</code> as parameters.</li>
</ul>
</li>
<li>
<p>Inside the <code>dfs</code> function:</p>
<ul>
<li>If the current node <code>root</code> is NULL, return (base case).</li>
<li>Construct the <code>currentString</code> by appending the character corresponding to the current node's value to the beginning of the <code>currentString</code>.</li>
<li>If the current node <code>root</code> is a leaf node:
<ul>
<li>If <code>smallestString</code> is empty or if the <code>currentString</code> is lexicographically smaller than <code>smallestString</code>:<br />
- Update <code>smallestString</code> to be the <code>currentString</code>.</li>
</ul>
</li>
<li>Recursively call <code>dfs</code> on the left child of the current node (if it exists).</li>
<li>Recursively call <code>dfs</code> on the right child of the current node (if it exists).</li>
</ul>
</li>
<li>
<p>After the <code>dfs</code> function call, return the <code>smallestString</code>.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Characters are represented as integers using ASCII values. For lowercase letters, the ASCII values start from 97 for <code>'a'</code>, 98 for <code>'b'</code>, and so on.</p>
<ul>
<li>Now, consider the expression <code>char(root-&gt;val + 'a')</code>. Here, <code>root-&gt;val</code> represents some integer value. Adding it to 'a' (which is 97) essentially shifts it to the corresponding position in the alphabet. For example, if <code>root-&gt;val</code> is 0, then <code>root-&gt;val + 'a'</code> becomes 97 ('a' in ASCII), resulting in the character 'a'. Similarly, if <code>root-&gt;val</code> is 1, then <code>root-&gt;val + 'a'</code> becomes 98 ('b' in ASCII), resulting in the character 'b', and so on. So, the expression <code>char(root-&gt;val + 'a')</code> converts the integer value <code>root-&gt;val</code> into its corresponding lowercase alphabetical character.</li>
</ul>
</blockquote>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QJn69ay9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>During each node visit in DFS, a new string is constructed by concatenating characters. Since string concatenation takes <span class="math inline">\(O(n)\)</span> time, where <code>n</code> is the length of the resulting string, and the length of the string grows with each recursive call, the time complexity of constructing and comparing each string in the worst case(skewed tree) is <span class="math inline">\(O(n)\)</span>. Additionally, each node in the tree is visited once.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>This space is utilized for the recursive function calls on the call stack during the DFS traversal, which is equal to the height of the tree. In the worst-case scenario, when the tree is completely unbalanced (skewed), the height of the tree can be equal to the number of nodes, resulting in <span class="math inline">\(O(n)\)</span> space complexity.</p>
<p>In addition to the recursive call stack, the algorithm creates and stores a string for each node. In the worst-case scenario, where the tree is completely unbalanced and each node visit results in a new string, the total space required to store these strings becomes <span class="math inline">\(O(n \cdot n)\)</span>.</p>
<p>Thus, the overall space complexity of the algorithm is <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs-approach">Approach 2: Breadth First Search (BFS) Approach</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Apart from DFS, we can also utilize the BFS approach to achieve the same outcome. In BFS, we implement a level-order traversal method, where we traverse the nodes level by level. Initially, we initialize an empty string to store the smallest path found so far and a queue to facilitate BFS traversal.</p>
<p>Given that the tree contains integer values that need to be returned as characters, we append nodes to the queue during traversal. Each node is accompanied by its value, converted to characters.</p>
<p>During each iteration, if the current node has a left child, we append it to the queue. Additionally, we concatenate the current string with the character representation of its value and include it in the queue. Likewise, if the current node has a right child, we follow the same procedure.</p>
<p>Within each iteration, we pop the node from the front of the queue along with its corresponding string. If the node is a leaf node (i.e., it lacks both left and right children), we compare its corresponding string with the current smallest string found. If it's lexicographically smaller, we update the smallest string accordingly.</p>
<p>Once the queue becomes empty, which signifies the completion of traversal for all paths from the root to the leaf nodes, the smallest string found represents the lexicographically smallest path from the root to a leaf node in the binary tree.</p>
<p>The following is an illustration demonstrating the breadth first search approach:</p>
<p>!?!../Documents/988/bfs.json:741,291!?!</p>
<blockquote>
<p><strong>Note:</strong> One advantage of DFS over BFS is its ability to avoid the need to create new string versions for each state. Instead, it allows for continuous appending and removal from a single string as child nodes are traversed. This eliminates the need to maintain multiple string states within the queue, simplifying the process compared to the BFS approach.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty string, <code>smallestString</code>, to store the lexicographically smallest string.</li>
<li>Initialize an empty queue, <code>nodeQueue</code>, for storing node-value pairs.</li>
<li>Add the root node and its value, converted to a character, to the back of the <code>nodeQueue</code>.</li>
<li>While the <code>nodeQueue</code> is not empty:
<ul>
<li>Pop the front node and its corresponding string from the <code>nodeQueue</code>.</li>
<li>If the current node is a leaf node and if <code>smallestString</code> is empty or the current string <code>currentString</code> is lexicographically smaller than <code>smallestString</code>, update <code>smallestString</code> to be the current string <code>currentString</code>.</li>
<li>If the current node has a left child:
<ul>
<li>Add the left child and the string obtained by prepending the left child's value to <code>currentString</code> to the back of the <code>nodeQueue</code>.</li>
</ul>
</li>
<li>If the current node has a right child:
<ul>
<li>Add the right child and the string obtained by prepending the right child's value to <code>currentString</code> to the back of the <code>nodeQueue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the string <code>smallestString</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ci8dSWxd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>In each iteration of the BFS traversal, a new string is created by concatenating characters. As string concatenation takes <span class="math inline">\(O(n)\)</span> time, where n is the length of the resulting string, the time complexity of constructing and comparing each string in worst case(skewed tree) will take <span class="math inline">\(O(n)\)</span>. Additionally, each node in the tree is visited once.</p>
<p>Therefore, the overall time complexity of the BFS traversal becomes <span class="math inline">\(O(n \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot n)\)</span></p>
<p>At any given time during the BFS traversal, the deque could contain up to the maximum number of nodes at any level of the tree, which can be at most the number of nodes in the last level of the tree.</p>
<p>Additionally, the size of each string stored in the deque can be up to <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the space complexity in the worst-case scenario (where the tree is completely unbalanced) would be <span class="math inline">\(O(n \cdot n)\)</span>, considering the space required to store both nodes and strings.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description" target="_blank" rel="noopener noreferrer">Smallest Subtree with all the Deepest Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, the depth of each node is <strong>the shortest distance to the root</strong>.</p>

<p>Return <em>the smallest subtree</em> such that it contains <strong>all the deepest nodes</strong> in the original tree.</p>

<p>A node is called <strong>the deepest</strong> if it has the largest depth possible among any node in the entire tree.</p>

<p>The <strong>subtree</strong> of a node is a tree consisting of that node, plus the set of all descendants of that node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 600px; height: 510px;" />
<pre>
<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree will be in the range <code>[1, 500]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 500</code></li>
	<li>The values of the nodes in the tree are <strong>unique</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1123: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank">https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-paint-deepest-nodes">Approach 1: Paint Deepest Nodes</h3>
<p><strong>Intuition</strong></p>
<p>We try a straightforward approach that has two phases.</p>
<p>The first phase is to identify the nodes of the tree that are deepest.  To do this, we have to annotate the depth of each node.  We can do this with a depth first search.</p>
<p>Afterwards, we will use that annotation to help us find the answer:</p>
<ul>
<li>
<p>If the <code>node</code> in question has maximum depth, it is the answer.</p>
</li>
<li>
<p>If both the left and right child of a <code>node</code> have a deepest descendant, then the answer is this parent <code>node</code>.</p>
</li>
<li>
<p>Otherwise, if some child has a deepest descendant, then the answer is that child.</p>
</li>
<li>
<p>Otherwise, the answer for this subtree doesn't exist.</p>
</li>
</ul>
<p><strong>Algorithm</strong></p>
<p>In the first phase, we use a depth first search <code>dfs</code> to annotate our nodes.</p>
<p>In the second phase, we also use a depth first search <code>answer(node)</code>, returning the answer for the subtree at that <code>node</code>, and using the rules above to build our answer from the answers of the children of <code>node</code>.</p>
<p>Note that in this approach, the <code>answer</code> function returns answers that have the deepest nodes of the <em>entire</em> tree, not just the subtree being considered.</p>
<p><a href="https://leetcode.com/playground/YbCjTSPT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<p><strong>Intuition</strong></p>
<p>We can combine both depth first searches in <em>Approach #1</em> into an approach that does both steps in one pass.  We will have some function <code>dfs(node)</code> that returns both the answer for this subtree, and the distance from <code>node</code> to the deepest nodes in this subtree.</p>
<p><strong>Algorithm</strong></p>
<p>The <code>Result</code> (on some subtree) returned by our (depth-first search) recursion will have two parts:</p>
<ul>
<li><code>Result.node</code>: the largest depth node that is equal to or an ancestor of all the deepest nodes of this subtree.</li>
<li><code>Result.dist</code>: the number of nodes in the path from the root of this subtree, to the deepest node in this subtree.</li>
</ul>
<p>We can calculate these answers disjointly for <code>dfs(node)</code>:</p>
<ul>
<li>
<p>To calculate the <code>Result.node</code> of our answer:</p>
<ul>
<li>
<p>If one <code>childResult</code> has deeper nodes, then <code>childResult.node</code> will be the answer.</p>
</li>
<li>
<p>If they both have the same depth nodes, then <code>node</code> will be the answer.</p>
</li>
</ul>
</li>
<li>
<p>The <code>Result.dist</code> of our answer is always 1 more than the largest <code>childResult.dist</code> we have.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/4tLcM433/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description" target="_blank" rel="noopener noreferrer">Step-By-Step Directions From a Binary Tree Node to Another</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a <strong>binary tree</strong> with <code>n</code> nodes. Each node is uniquely assigned a value from <code>1</code> to <code>n</code>. You are also given an integer <code>startValue</code> representing the value of the start node <code>s</code>, and a different integer <code>destValue</code> representing the value of the destination node <code>t</code>.</p>

<p>Find the <strong>shortest path</strong> starting from node <code>s</code> and ending at node <code>t</code>. Generate step-by-step directions of such path as a string consisting of only the <strong>uppercase</strong> letters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;U&#39;</code>. Each letter indicates a specific direction:</p>

<ul>
	<li><code>&#39;L&#39;</code> means to go from a node to its <strong>left child</strong> node.</li>
	<li><code>&#39;R&#39;</code> means to go from a node to its <strong>right child</strong> node.</li>
	<li><code>&#39;U&#39;</code> means to go from a node to its <strong>parent</strong> node.</li>
</ul>

<p>Return <em>the step-by-step directions of the <strong>shortest path</strong> from node </em><code>s</code><em> to node</em> <code>t</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/15/eg1.png" style="width: 214px; height: 163px;" />
<pre>
<strong>Input:</strong> root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
<strong>Output:</strong> &quot;UURL&quot;
<strong>Explanation:</strong> The shortest path is: 3 &rarr; 1 &rarr; 5 &rarr; 2 &rarr; 6.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/15/eg2.png" style="width: 74px; height: 102px;" />
<pre>
<strong>Input:</strong> root = [2,1], startValue = 2, destValue = 1
<strong>Output:</strong> &quot;L&quot;
<strong>Explanation:</strong> The shortest path is: 2 &rarr; 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is <code>n</code>.</li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= n</code></li>
	<li>All the values in the tree are <strong>unique</strong>.</li>
	<li><code>1 &lt;= startValue, destValue &lt;= n</code></li>
	<li><code>startValue != destValue</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-bfs--dfs">Approach 1: BFS + DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem requires finding the shortest path between two given nodes using step-by-step directions. Shortest path problems are common in graph theory, and several efficient algorithms can be learned to solve them. Let's explore solving the problem with one of these algorithms.</p>
<p>To apply one of these algorithms, we first must convert the tree to a bidirectional graph. In a binary tree, each node can connect to its children but not directly to its parent. To facilitate all the movement from a node to its parent, we commonly use a <code>parent</code> table. This table stores the parent of each node, built by traversing the tree and marking each node's children with their respective parent.</p>
<p>With the ability to traverse the tree in any direction, we first locate the starting node. Once we've identified it, we can then proceed to calculate the shortest path.</p>
<p>To efficiently determine the shortest path, we use a breadth-first search (BFS) to explore nodes at the current depth before moving deeper. For those unfamiliar with BFS, the LeetCode <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/">Explore Card</a> provides a helpful introduction.</p>
<p>During the BFS traversal, we use a map <code>pathTracker</code> to record the path taken to each node. In <code>pathTracker</code>, each key represents a node, while its corresponding value is a pair containing the parent node and the direction from that parent. Upon reaching the destination node, we backtrack using <code>pathTracker</code> to trace the path back to the start node. The path string is constructed by appending directions from <code>pathTracker</code> and moving to the parent node stored in the tuple.</p>
<p>This process continues until we reach the start node. Since directions are recorded in reverse order during backtracking, we reverse the path string to obtain the correct sequence of directions from the start node to the destination node. Finally, we return this reversed string as the result.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main method <code>getDirections</code>:</p>
<ul>
<li>Initialize a map <code>parentMap</code> to store parent nodes for each node in the tree.</li>
<li>Find the <code>startNode</code> using the <code>findStartNode</code> method, which recursively searches the tree for the node with <code>startValue</code>.</li>
<li>Populate <code>parentMap</code> using the <code>populateParentMap</code> method, which traverses the tree and maps each child node to its parent.</li>
<li>For the BFS, initialize
<ul>
<li>A queue containing the <code>startNode</code>.</li>
<li>A set <code>visitedNodes</code> to keep track of visited nodes to avoid cycles.</li>
<li>A map <code>pathTracker</code> to record the path taken by the BFS.</li>
</ul>
</li>
<li>While the queue is not empty:
<ul>
<li>Dequeue a TreeNode from the queue.</li>
<li>If the current node's value matches <code>destValue</code>, we have found our path. Call <code>backtrackPath</code> and return the path calculated by it.</li>
</ul>
</li>
<li>If <code>parentMap</code> contains a parent for the current node and it hasn't been visited, enqueue the parent node and add an entry to <code>pathTracker</code> with the current node as the key and a pair containing the parent node and direction 'U' as the value.</li>
<li>If the left child exists and hasn't been visited, enqueue the left child and add an entry to <code>pathTracker</code> with the current node as the key and a pair containing the left child and direction 'L' as the value.</li>
<li>If the right child exists and hasn't been visited, enqueue the right child and add an entry to <code>pathTracker</code> with the current node as the key and a pair containing the right child and direction 'R' as the value.</li>
<li>If the destination node is never reached, an empty string is returned.</li>
</ul>
<p>Helper method <code>backtrackPath</code>:</p>
<ul>
<li>Define <code>backtrackPath</code> with parameters: destination <code>node</code> (TreeNode) and <code>pathTracker</code> map.</li>
<li>Initialize an empty string <code>path</code>.</li>
<li>While <code>node</code> exists in <code>pathTracker</code>:
<ul>
<li>Retrieve the parent node and direction from <code>pathTracker</code>.</li>
<li>Append the direction to <code>path</code>.</li>
<li>Set <code>node</code> to the parent node.</li>
</ul>
</li>
<li>Reverse and return <code>path</code>.</li>
</ul>
<p>Helper method <code>populateParentMap</code>:</p>
<ul>
<li>Define <code>populateParentMap</code> with parameters: current <code>node</code> (TreeNode) and <code>parentMap</code>.</li>
<li>If <code>node</code> is <code>null</code>, return.</li>
<li>If left or right children exist, add them to <code>parentMap</code> with <code>node</code> as their parent.</li>
<li>Recurse on left and right children.</li>
</ul>
<p>Helper method <code>findStartNode</code>:</p>
<ul>
<li>Define <code>findStartNode</code> with parameters: current <code>node</code> (TreeNode) and <code>startValue</code>.</li>
<li>If <code>node</code> is <code>null</code>, return.</li>
<li>If <code>node</code>'s value matches <code>startValue</code>, return <code>node</code>.</li>
<li>Recursively search the left subtree. If a node is found, return it.</li>
<li>Otherwise, search the right subtree and return the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FRpYHkx3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>findStartNode</code> method traverses the tree once to find the start node, which has a worst case time complexity of <span class="math inline">\(O(n)\)</span> (skewed tree).</p>
<p>The <code>populateParentMap</code> method visits each node once to populate the map. It has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>In the worst case, the BFS to find the path might visit all nodes of the tree. Inside the BFS loop, the operations on the set and map are <span class="math inline">\(O(1)\)</span> on average. Thus, the time complexity of the BFS remains <span class="math inline">\(O(n)\)</span>.</p>
<p>The <code>backtrackPath</code> method can take at most <span class="math inline">\(O(n)\)</span> time to traverse over the entire length of the resultant path, which can be of length <span class="math inline">\(n\)</span> in the worst case.</p>
<p>The time complexity of the entire algorithm is sum of these individual complexities, which is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>parentMap</code> stores the parent information for each node, taking <span class="math inline">\(O(n)\)</span> space.</p>
<p>The <code>backtrackPath</code> method stores the length of the final path, which can have a maximum length of <span class="math inline">\(n\)</span>.</p>
<p>The recursive call stacks in the <code>findStartNode</code> and <code>populateParentMap</code> methods can have a worst case space complexity of <span class="math inline">\(O(n)\)</span> (e.g. a skewed tree).</p>
<p>The queue for the BFS can contain up to <span class="math inline">\(n/2\)</span> nodes in the worst case (for a complete binary tree). So, it has a space complexity of <span class="math inline">\(O(n/2)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>. The <code>visitedNodes</code> set and <code>pathTracker</code> map used in the BFS uses another <span class="math inline">\(O(n)\)</span> space each.</p>
<p>Thus, the overall space complexity of the algorithm is <span class="math inline">\(6 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-lca--dfs">Approach 2: LCA + DFS</h3>
<h4 id="intuition-1">Intuition</h4>
<p>A more optimal method exists to solve a tree problem that doesn't involve converting it to a bidirectional graph. Let's try to solve it as a tree this time.</p>
<p>If we trace paths from the root to the two nodes, we see that these paths share a common segment until a certain point, after which they diverge. This last intersection is the Lowest Common Ancestor (LCA). Since it is the last shared point, any path connecting the two nodes must pass through this LCA. We won't discuss the methods to find the LCA in a binary tree in this article, as it is a separate and popular problem. Here we will be focusing on the application of it. If you are unfamiliar with LCA, check out <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">Lowest Common Ancestor of a Binary Tree</a>.</p>
<p>Check out how the LCA is a part of the common paths for the start and destination nodes in this image:</p>
<p><img src="../Figures/2096/image1.png" alt="LCA Image" /></p>
<p>The path between the start node and the destination node can be divided into two parts: the path from the start node to the LCA and the path from the LCA to the destination node. The path from the start node to the LCA consists only of the direction 'U' since all moves are from a child node to a parent node.</p>
<p>To find these paths, we use depth-first search starting from the LCA and moving towards the target nodes. Initially, we explore the left subtree appending 'L' to the path. Upon finding the target node, we return immediately. If not found, we backtrack by replacing 'L' with 'R' to explore the right subtree. If the target node isn't found in either subtree, we backtrack to the parent node. This recursive process continues until the target node is located.</p>
<p>Check out this slideshow to better understand how to find the path for a node:</p>
<p>!?!../Documents/2096/slideshow.json:1244,1008!?!</p>
<p>Now that we have the directions to both the start and destination nodes from the LCA, we can piece together the full path. We transform the path from the LCA to the start node by replacing all directions with &quot;U&quot; and prepend it to the path to the destination node. The resulting sequence gives the step-by-step directions from the start node to the end node in the binary tree</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>getDirections</code>:</p>
<ul>
<li>Find the <code>lowestCommonAncestor</code> of <code>startValue</code> and <code>destValue</code> using the <code>findLowestCommonAncestor</code> method.</li>
<li>Initialize <code>pathToStart</code> and <code>pathToDest</code> to store paths from the LCA to the start and destination nodes, respectively.</li>
<li>Call <code>findPath</code> to determine these paths.</li>
<li>Initialize <code>directions</code> to store the final result.</li>
<li>Add &quot;U&quot; for each step in <code>pathToStart</code>.</li>
<li>Append <code>pathToDest</code> to <code>directions</code>.</li>
<li>Return <code>directions</code>, which contains the step-by-step directions from the start node to the destination node.</li>
</ul>
<p>Helper method <code>findLowestCommonAncestor</code>:</p>
<ul>
<li>Define <code>findLowestCommonAncestor</code> with parameters: <code>node</code>, <code>value1</code>, and <code>value2</code>.</li>
<li>If <code>node</code> is null, return <code>null</code>.</li>
<li>If <code>node</code>'s value matches <code>value1</code> or <code>value2</code>, return <code>node</code>.</li>
<li>Recursively search for the LCA in the left and right subtrees, storing results in <code>leftLCA</code> and <code>rightLCA</code>.</li>
<li>If <code>leftLCA</code> is null, return <code>rightLCA</code>.</li>
<li>If <code>rightLCA</code> is null, return <code>leftLCA</code>.</li>
<li>If both <code>leftLCA</code> and <code>rightLCA</code> contain nodes, the current node is the lowest common ancestor. Return <code>node</code>.</li>
</ul>
<p>Helper method <code>findPath</code>:</p>
<ul>
<li>Define <code>findPath</code> with parameters: <code>node</code>, <code>targetValue</code>, and <code>path</code>.</li>
<li>If <code>node</code> is null, return <code>false</code>.</li>
<li>If <code>node</code>'s value matches <code>targetValue</code>, return <code>true</code>.</li>
<li>Append &quot;L&quot; to <code>path</code> and search the left subtree. If the target node is found, return <code>true</code>.</li>
<li>If not found, remove the last character from <code>path</code>.</li>
<li>Append &quot;R&quot; to <code>path</code> and search the right subtree. If the target node is found, return <code>true</code>.</li>
<li>If not found, remove the last character from <code>path</code>.</li>
<li>Return <code>false</code> if the target node is not found in either subtree.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/NTY9QGUk/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the total number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>findLowestCommonAncestor</code> method is called once and traverses the tree to find the LCA, which takes <span class="math inline">\(O(n)\)</span> time in the worst case.</p>
<p>The <code>findPath</code> method is called twice, once for the path from the LCA to <code>startValue</code> and once for the path to <code>destValue</code>. Each call can traverse up to the height of the tree, which is <span class="math inline">\(n\)</span> in the worst case (e.g., a skewed tree), making the total time complexity for both calls <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
<p>Adding &quot;U&quot; for all upward movements and constructing the final path also takes <span class="math inline">\(O(n)\)</span> time. Therefore, the total time complexity of the entire algorithm is <span class="math inline">\(3 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive call stacks for <code>findLowestCommonAncestor</code> and <code>findPath</code> can each have a space complexity of <span class="math inline">\(O(n)\)</span> in the worst case. The variables <code>pathToStart</code>, <code>pathToDest</code>, and <code>directions</code> can store a path of length up to the height of the tree, which is <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Combining all elements, the algorithm has a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-lca--dfs-optimized">Approach 3: LCA + DFS (Optimized)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of focusing on finding the LCA and identifying paths from the LCA to both nodes, we can directly find the full paths from the root to each node and then trim off their common part ourselves. This approach eliminates the need to explicitly find the LCA, resulting in significantly shorter and simpler code.</p>
<p>We'll use the <code>findPath</code> method from our previous approach to determine the paths from the root to both the start and end nodes. After obtaining these paths, we identify and remove their common initial segment. Then, we adjust the remaining portion of the start node's path by replacing each step with &quot;U&quot; to indicate upward movement. Finally, we concatenate this adjusted path with the unique part of the end node's path, giving us the step-by-step directions from the start node to the end node.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>getDirections</code>:</p>
<ul>
<li>Initialize <code>startPath</code> and <code>destPath</code> to store paths from the root to the start node and the destination node, respectively.</li>
<li>Determine <code>startPath</code> and <code>destPath</code> using <code>findPath</code>.</li>
<li>Initialize <code>directions</code> to store the resultant directions.</li>
<li>Compare <code>startPath</code> and <code>endPath</code> to find the length of common path. Store it in <code>commonPathLength</code>.</li>
<li>Iterate through the difference between the length of <code>startPath</code> and <code>commonPathLength</code>. For each step, add &quot;U&quot; to <code>directions</code>.</li>
<li>From <code>destPath</code>, add the directions from index <code>commonPathLength</code> to the end of the string to <code>directions</code>.</li>
<li>Return <code>directions</code>.</li>
</ul>
<p>Helper method <code>findPath</code>:</p>
<ul>
<li>Define <code>findPath</code> with parameters: <code>node</code>, <code>targetValue</code>, and <code>path</code>.</li>
<li>If <code>node</code> is <code>null</code>, return <code>false</code>.</li>
<li>If <code>node.val == targetValue</code>, return <code>true</code>.</li>
<li>Add &quot;L&quot; to <code>path</code> and search the left subtree recursively. If the target node is found, return <code>true</code>.</li>
<li>If not found, remove the last character from <code>path</code>.</li>
<li>Add &quot;R&quot; to <code>path</code> and search the right subtree recursively. If the target node is found, return <code>true</code>.</li>
<li>If not found, remove the last character from <code>path</code>.</li>
<li>Return <code>false</code> if the target node was not found in either subtrees.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NenqfY3B/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of nodes in the tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>findPath</code> method is called twice, once for the start node and once for the destination node. Each call may traverse the entire tree in the worst case (skewed tree), making the time complexity <span class="math inline">\(2 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
<p>To construct the final result, we iterate over the entire lengths of <code>startPath</code> and <code>destPath</code>, each of which could have a complexity of <span class="math inline">\(O(n)\)</span> in the worst case.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n) + O(n)\)</span>, simplifying to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The recursive call stack of the <code>findPath</code> method can have a space complexity of <span class="math inline">\(O(n)\)</span> in the worst case. The variables <code>startPath</code>, <code>destPath</code>, and <code>directions</code> can each have a length equal to the height of the tree, which is <span class="math inline">\(n\)</span> in the worst case (skewed tree).</p>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(4 \cdot O(n)\)</span>, or <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subtree-of-another-tree/description" target="_blank" rel="noopener noreferrer">Subtree of Another Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">string matching</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of<code> subRoot</code> and <code>false</code> otherwise.</p>

<p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node&#39;s descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" style="width: 532px; height: 400px;" />
<pre>
<strong>Input:</strong> root = [3,4,5,1,2], subRoot = [4,1,2]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" style="width: 502px; height: 458px;" />
<pre>
<strong>Input:</strong> root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the <code>root</code> tree is in the range <code>[1, 2000]</code>.</li>
	<li>The number of nodes in the <code>subRoot</code> tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= root.val &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= subRoot.val &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-left-leaves/description" target="_blank" rel="noopener noreferrer">Sum of Left Leaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>

<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" style="width: 277px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 24
<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description" target="_blank" rel="noopener noreferrer">Sum of Nodes with Even-Valued Grandparent</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, return <em>the sum of values of nodes with an <strong>even-valued grandparent</strong></em>. If there are no nodes with an <strong>even-valued grandparent</strong>, return <code>0</code>.</p>

<p>A <strong>grandparent</strong> of a node is the parent of its parent if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg" style="width: 504px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
<strong>Output:</strong> 18
<strong>Explanation:</strong> The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg" style="width: 64px; height: 65px;" />
<pre>
<strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<p>We are given a binary tree, and we need to return the sum of nodes that has even values grandparent. The grandparent of a node is the parent of its immediate parent.</p>
<p>We need to iterate over the nodes in the binary tree in a way that we can find the value of its grandparent. We can then check if the value of its grandparent is even, and if so, add the value of that node to the answer. One way to iterate a tree is Depth-First Search, i.e., DFS. We can recursively iterate over the nodes in the tree in depth wise manner, but keeping two extra pieces of information: the value of its immediate parent, and the value of its grandparent. This enables us to decide whether the value of the current node should be added to the answer.</p>
<p>How will we find the value of parent and grandparent for each node? We can start with the root node and which has neither the parent nor the grandparent node. We can use arbitrary odd values to represent their values so that we don't add the root value to the answer. The value of the parent node for the child node and the value of the grandparent node can be obtained as the current node's value and the parent node's value of the current node, respectively.</p>
<p><img src="../Figures/1315/1315A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define the method <code>solve()</code> that takes the TreeNode <code>root</code>, the parent value <code>parent</code> and the grandparent value <code>gParent</code>. This method returns the number of nodes with even-valued grandparent under the subtree of node <code>root.</code></li>
<li>Call the recursive function <code>solve()</code> with the root node and <code>-1</code> as the parent value  <code>parent</code> and grandparent value <code>gParent</code></li>
<li>If the <code>root</code> is null, then we can return <code>0</code> as the sum.</li>
<li>Recursively iterate over the left and right child with parent value as <code>root</code> and grandparent value as <code>parent</code>.</li>
<li>If the value of <code>gParent</code> is even, then add the value of <code>root</code> to the answer.</li>
<li>Return the sum for the left and right child and the value for the current node.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/DqPDwS7k/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need to iterate over every node only once with parent and grandparent values in the recursive function. Hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The only space required is the stack recursion calls, the maximum number of active stack calls would be equal to <span class="math inline">\(O(N)\)</span> when the tree is skewed and there is one function call for each of the nodes in the recursive stack. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
 <br/>
<hr />
<h3 id="approach-2--breadth-first-search-bfs">Approach 2:  Breadth-First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>The other way to iterate over the nodes in a binary tree is using Breadth-First Search. We will iterate over the nodes in a breadth-wise manner, and for each node, we need to find a way to determine if it has a grandparent with an even value.</p>
<p>Since we will iterate over the nodes in an iterative manner using BFS, we have to use a different method to find the grandparent. What if, instead of checking the ancestor nodes of each node, we look for the grandchildren nodes of each node? This way, we don't have to keep the parent and grandparent values as we did before.</p>
<p>As shown below we will check the four grandchildren for each node which has an even value, we will add the value of all these grandchildren to the answer.</p>
<p><img src="../Figures/1315/1315B.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize an empty queue <code>q</code>, and a variable <code>sum</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over the queue while it's not empty and for each node:</p>
<ol>
<li>Pop the node from the queue as <code>curr</code>.</li>
<li>If the value of <code>curr</code> is even, then check the grandchildren of this node and add the values to the variable <code>sum</code>.</li>
<li>Add the left and right child of the node <code>curr</code> if they are not null.</li>
</ol>
</li>
<li>
<p>Return <code>sum</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/KRsZnFWh/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of nodes in the binary tree.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The outer while loop continues if there are nodes in the queue. Each node will be added to the queue and popped from the queue only once. If its value is even, we will keep popping the node and check its four grandchildren. All these operations are constant in terms of time complexity. Hence the total time complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We need a queue to store the nodes at a particular level of the binary tree. The number of nodes in different levels of a full binary tree will be <code>${1, 2, 4, 8......2^{N - 1}}$</code>, with total nodes equal to <span class="math inline">\(2^N\)</span>, therefore, the maximum number of nodes at a time in the queue will be of the order <span class="math inline">\(O(N)\)</span>. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/description" target="_blank" rel="noopener noreferrer">Sum of Root To Leaf Binary Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree where each node has a value <code>0</code> or <code>1</code>. Each root-to-leaf path represents a binary number starting with the most significant bit.</p>

<ul>
	<li>For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</li>
</ul>

<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return <em>the sum of these numbers</em>.</p>

<p>The test cases are generated so that the answer fits in a <strong>32-bits</strong> integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" style="width: 400px; height: 263px;" />
<pre>
<strong>Input:</strong> root = [1,0,1,0,1,0,1]
<strong>Output:</strong> 22
<strong>Explanation: </strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> root = [0]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>Node.val</code> is <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-root-to-leaf-numbers/description" target="_blank" rel="noopener noreferrer">Sum Root to Leaf Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>

<p>Each root-to-leaf path in the tree represents a number.</p>

<ul>
	<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>
</ul>

<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>

<p>A <strong>leaf</strong> node is a node with no children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" style="width: 212px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 25
<strong>Explanation:</strong>
The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
Therefore, sum = 12 + 13 = <code>25</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" style="width: 292px; height: 302px;" />
<pre>
<strong>Input:</strong> root = [4,9,0,5,1]
<strong>Output:</strong> 1026
<strong>Explanation:</strong>
The root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.
The root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.
The root-to-leaf path <code>4-&gt;0</code> represents the number 40.
Therefore, sum = 495 + 491 + 40 = <code>1026</code>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
	<li>The depth of the tree will not exceed <code>10</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/symmetric-tree/description" target="_blank" rel="noopener noreferrer">Symmetric Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" style="width: 354px; height: 291px;" />
<pre>
<strong>Input:</strong> root = [1,2,2,3,4,4,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" style="width: 308px; height: 258px;" />
<pre>
<strong>Input:</strong> root = [1,2,2,null,3,null,3]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you solve it both recursively and iteratively?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trim-a-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Trim a Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>

<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" style="width: 450px; height: 126px;" />
<pre>
<strong>Input:</strong> root = [1,0,2], low = 1, high = 2
<strong>Output:</strong> [1,null,2]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" style="width: 450px; height: 277px;" />
<pre>
<strong>Input:</strong> root = [3,0,4,null,2,null,null,1], low = 1, high = 3
<strong>Output:</strong> [3,2,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li>The value of each node in the tree is <strong>unique</strong>.</li>
	<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
	<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-iv-input-is-a-bst/description" target="_blank" rel="noopener noreferrer">Two Sum IV - Input is a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true</code> <em>if there exist two elements in the BST such that their sum is equal to</em> <code>k</code>, <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>root</code> is guaranteed to be a <strong>valid</strong> binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-binary-search-trees/description" target="_blank" rel="noopener noreferrer">Unique Binary Search Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">math</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-binary-search-trees-ii/description" target="_blank" rel="noopener noreferrer">Unique Binary Search Trees II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">backtracking</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" style="width: 600px; height: 148px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, our task is to return all unique BSTs (binary search trees) that have exactly <code>n</code> nodes of unique values from <code>1</code> to <code>n</code>.</p>
<hr />
<h3 id="approach-1-recursive-dynamic-programming">Approach 1: Recursive Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>In each node of a binary search tree (BST), all values in the left subtree are smaller and all values in the right subtree are greater.</p>
<p>To find all the possible permutations of BSTs with <code>n</code> nodes, we can lock one node as the <code>root</code> node and split <code>n - 1</code> nodes between the left and right subtrees in all the possible ways. Let's say we place a node with value <code>i</code> as the root node and place <code>i - 1</code> nodes having values from <code>1</code> to <code>i - 1</code> in the left subtree. (If <code>i == 1</code>, the left child is null). Similarly, we place the remaining <code>n - i</code> nodes having values from <code>i + 1</code> to <code>n</code> in the right subtree. (If <code>i == n</code>, the right child is null).</p>
<p>Now, we create a list of nodes called <code>leftSubTrees</code> for all the possible BSTs that could be the left subtree. Similarly, we create a list of nodes called <code>rightSubTrees</code> for all the BSTs that could be the right subtree.</p>
<blockquote>
<p>In a BST, every subtree is also a BST.</p>
</blockquote>
<p>We iterate over both the lists and for each node pair <code>l</code> in <code>leftSubTrees</code> and <code>r</code> in <code>rightSubTrees</code>, we create a new <code>root</code> node with value <code>i</code> and set the left and right child of <code>root</code> to <code>l</code> and <code>r</code> respectively to form all the BSTs with the root node as <code>i</code>.</p>
<p>We can iterate over the root's value from <code>i = 1</code> to <code>n</code> and repeat the process for each root value to get all the BSTs.</p>
<p>You may notice that the subproblem of finding the arrays <code>leftSubTrees</code> and <code>rightSubTrees</code> are similar to the original problem. We can implement this approach using recursion as we are breaking down a problem with <code>n</code> nodes to smaller, repetitive subproblems with <code>i - 1</code> and <code>n - i</code> nodes (for <code>i = 1</code> till <code>n</code>) to compute the answer for <code>n</code> nodes. We only need the range of node values as the parameters to create the BSTs with nodes having values in that range.</p>
<p>We implement a recursive function <code>allPossibleBST(start, end)</code> where <code>start</code> and <code>end</code> correspond to the range of node values that should be present in the BSTs created by this call. For a root node with value <code>i</code>, we will find all the left subtrees using <code>leftSubTrees = allPossibleBST(start, i - 1)</code> and also compute all the right subtrees using <code>rightSubTrees = allPossibleBST(i + 1, right)</code>. Finally, we iterate over all pairs between <code>leftSubTrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair.</p>
<p>The base case of this function is when <code>start &gt; end</code>. We have no values in our range and thus we will return <code>null</code> (an empty tree).</p>
<p>Here is a visual representation of the recursion tree with <code>3</code> nodes:</p>
<p><img src="../Figures/95/95-1.png" alt="img" /></p>
<p>Several subproblems, such as <code>allPossibleBST(1, 1)</code>, <code>allPossibleBST(3, 3)</code>, etc., are solved multiple times in the small partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from a range of nodes values to the list of root nodes of all possible BSTs that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of <code>TreeNode</code>. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hash map <code>memo</code> where <code>memo[(start, end)]</code> contains the list of root nodes of all possible BSTs with the range of node values from <code>start</code> to <code>end</code>.</li>
<li>We implement a recursive function <code>allPossibleBST</code> which takes the starting range of node values <code>start</code>, ending range <code>end</code>, and <code>memo</code> as parameters. It returns a list of <code>TreeNode</code> corresponding to all the BSTs that can be formed with this range of node values. We call <code>allPossibleBST(1, n, memo)</code> and perform the following:
<ul>
<li>We declare a list of <code>TreeNode</code> called <code>res</code> to store the list of root nodes of all possible BSTs.</li>
<li>If <code>start &gt; end</code>, we push <code>null</code> to <code>res</code> and return it.</li>
<li>If we already have solved this subproblem, i.e., <code>memo</code> contains the pair <code>(start, end)</code>, we return <code>memo[(start, end)]</code>.</li>
<li>Select the root node value from <code>i = start</code> to <code>end</code> incrementing <code>i</code> by <code>1</code> after each iteration. We recursively call <code>leftSubtrees = llPossibleBST(start, i - 1, memo)</code> and <code>rightSubTrees = allPossibleBST(i + 1, end, memo)</code>. We iterate over all pairs between <code>leftSubtrees</code> and <code>rightSubTrees</code> and create a new root with value <code>i</code> for each pair. We push <code>root</code> of the new formed BST into <code>res</code>.</li>
<li>Set <code>memo[(start, end)] = res</code> and return <code>res</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FiZegYw8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Note, the time and space complexity of this problem is difficult to derive. In an interview, you should do your best to find an upper bound. The level of analysis here would not be expected in an interview.</p>
<p>The number of unique BSTs that can be formed with <code>n</code> nodes is <span class="math inline">\(G(n)\)</span> where <span class="math inline">\(G(n)\)</span> is the <span class="math inline">\(n^{th}\)</span> <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>. <span class="math inline">\(G(n) = O(\dfrac{4^{n}}{n^{1.5}})\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>There are <span class="math inline">\(G(n) = \dfrac{4^n}{n^{1.5}}\)</span> BSTs in our answer. Each of these BSTs has <span class="math inline">\(n\)</span> nodes, so it cost us <span class="math inline">\(O(n)\)</span> to build each one. This gives us a time complexity of <span class="math inline">\(O(n \cdot G(n)) = O(\dfrac{4^n}{\sqrt{n}})\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<p>We use some space for the recursion call stack, but the majority of the space used by the algorithm is storing the lists of BSTs in <code>memo</code>. Let's analyze how many nodes are stored in <code>memo</code>.</p>
<p>The number of nodes in a range <code>start, end</code> is <code>end - start + 1</code>. Let <span class="math inline">\(k = \text{end} - \text{start} + 1\)</span> represent this formula.</p>
<p>There are <span class="math inline">\(n\)</span> states <code>start, end</code> with one node, that is <span class="math inline">\(k = 1\)</span>.</p>
<p>There are <span class="math inline">\(n - 1\)</span> states <code>start, end</code> with two nodes, that is <span class="math inline">\(k = 2\)</span>.</p>
<p>There are <span class="math inline">\(n - 2\)</span> states <code>start, end</code> with three nodes, that is <span class="math inline">\(k = 3\)</span>.</p>
<p>This continues until there is only one state with <span class="math inline">\(n\)</span> nodes (the original input). In general, a value of <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states.</p>
<p>For a given state with value <span class="math inline">\(k\)</span>, there are <span class="math inline">\(G(k) = \dfrac{4^k}{k^{1.5}}\)</span> BSTs. Each of these BSTs has <span class="math inline">\(k\)</span> nodes, and thus takes up <span class="math inline">\(k \cdot G(k) = \dfrac{4^k}{\sqrt{k}}\)</span> space in <code>memo</code>.</p>
<p>A given value <span class="math inline">\(k\)</span> has <span class="math inline">\(n - k + 1\)</span> states and thus takes up <span class="math inline">\((n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}\)</span> space. In our algorithm, <span class="math inline">\(k\)</span> ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span>.</p>
<p>The space complexity is the summation for all values of <span class="math inline">\(k\)</span>:</p>
<p><span class="math inline">\(\Large{\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]}}\)</span></p>
<p>This is a difficult sum to compute and involves higher-level mathematics. Using a program like WolframAlpha, we find that the sum is equal to:</p>
<p><span class="math inline">\(4^{1 + n} \cdot \Phi(4, -0.5, 1 + n) - 4^{1 + n} \cdot (1 + n) \cdot \Phi(4, 0.5, 1 + n) - \text{Li}_{-0.5}(4) + \text{Li}_{0.5}(4) + n \cdot \text{Li}_{0.5}(4)\)</span></p>
<p>Where <span class="math inline">\(\Phi\)</span> is the <a href="https://en.wikipedia.org/wiki/Lerch_zeta_function">Lerch transcendent</a> and <span class="math inline">\(\text{Li}_n(x)\)</span> is the <a href="https://en.wikipedia.org/wiki/Polylogarithm">polylogarithm function</a>. Needless to say, computing this sum by hand is not necessary in an interview. Even reaching the summation expression would likely impress any interviewer.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.</p>
<p>We create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of all BSTs that have node values ranging from <code>i</code> to <code>j</code>. Note that <code>dp[i][j] = allPossibleBST(i, j)</code> from the previous approach.</p>
<p>When <code>i = j</code>, the range contains only one node with value <code>i</code>. We push a single node with value <code>i</code> in the list <code>dp[i][i]</code> for all the values of <code>i</code> from <code>1</code> to <code>n</code>. This acts as the base case of our solution while we move in bottom to top manner.</p>
<p>We form the answer with a smaller number of nodes having consecutive node values and move on to form answers for a bigger number of nodes. We run an outer loop from <code>numberOfNodes = 2</code> to <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. This loop controls the total number of nodes under consideration.</p>
<p>We further need to choose a node value we start with. Let's call it <code>start</code>. As we have <code>numberOfNodes</code> nodes under consideration with consecutive values, the maximum node value in such a BST would be <code>end = start + numberOfNodes - 1</code>. We will move <code>start</code> from <code>1</code> to <code>n - numberOfNodes + 1</code>.</p>
<p>Now we have the <code>start</code> value and the <code>end</code> value, we can implement the same logic that we did in the <code>allPossibleBST</code> function from the previous approach. Lock a value <code>i</code>, find all left and right subtrees, and then iterate over each <code>left, right</code> pair and create a new root with value <code>i</code> for each pair.</p>
<p>As we move from bottom to top, we will have a list of all the root nodes for all BSTs for every range of node values with lesser nodes.</p>
<p>Locking a value <code>i</code> as the root node, we can find all left subtrees in <code>dp[start][i - 1]</code> and all right subtrees in <code>dp[i + 1][end]</code>. If <code>i == start</code>, the left subtree would be empty. Similarly, if <code>i == end</code>, the right subtree would be empty. We can handle these cases separately.</p>
<p>We run an outer loop from <code>numberOfNodes = 2</code> to <code>n</code>. We run an inner loop that selects the starting node value. It runs from <code>start = 1</code> to <code>n - numberOfNodes + 1</code>. We define <code>end = start + numberOfNodes - 1</code>. We run a third nested loop that selects the root of the BSTs under consideration. It runs from <code>i = start</code> to <code>end</code>.</p>
<p>We then iterate over the both the lists of left and right subtrees. For each root node <code>l</code> of the left subtree and <code>r</code> of the right subtree, we create a new <code>root</code> node with value <code>i</code> and set the left and right child to <code>l</code> and <code>r</code> respectively to form all the BSTs with root node as <code>i</code>. We also push each BST into <code>dp[start][end]</code> to be used later to build answer for other <code>dp</code> states with larger number of nodes.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create a 3D list <code>dp[n + 1][n + 1]</code> where <code>dp[i][j]</code> will store a list of root nodes for all possible BSTs using <code>j - i + 1</code> nodes with values from <code>i</code> to <code>j</code> nodes.</li>
<li>We initialize each list <code>dp[i][i]</code> to a <code>TreeNode</code> having value <code>i</code> for <code>i = 0</code> to <code>n</code>.</li>
<li>Iterate from <code>numberOfNodes = 2</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>start = 1</code> to <code>n - numberOfNodes + 1</code> incrementing <code>start</code> by <code>1</code>. We create an integer variable <code>end = start + numberOfNodes - 1</code> which stores the highest node value of the BSTs that will be formed. We run another loop from <code>i = start</code> to <code>end</code> to use all the permutations as the root node value. We perform the following in this loop:
<ul>
<li>We create a list of <code>TreeNode</code> called <code>leftSubtrees</code> which will store all the BSTs that can be formed with node values from <code>start</code> to <code>i - 1</code>. If <code>i == start</code>, we just add <code>null</code> to <code>leftSubtrees</code>, else <code>leftSubtrees == dp[start][i - 1]</code>.</li>
<li>Similarly, we create a list of <code>TreeNode</code> called <code>rightSubtrees</code> which will store all the BSTs that can be formed with node values from <code>i + 1</code> to <code>end</code>. If <code>i == end</code>, we just add <code>null</code> to <code>rightSubtrees</code>, else <code>rightSubtrees == dp[i + 1][end]</code>.</li>
<li>We form a new BST by creating a new node which acts as a root node with value <code>i</code>. For each element <code>left</code> in <code>leftSubtrees</code> and <code>right</code> in <code>rightSubtrees</code>, we set <code>root.left = left</code> and <code>root.right = right</code>. Finally, we add <code>root</code> to <code>dp[start][end]</code>.</li>
</ul>
</li>
<li>Return <code>dp[1][n]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/hj8MdGva/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>The time complexity of this approach will be similar to the <strong>time complexity</strong> of the first approach because we are iterating over the same <code>dp</code> states in bottom-up manner as compared to the previous approach where we used top-down approach with memoization.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}{[(n - k + 1) \cdot  \dfrac{4^k}{\sqrt{k}}]})\)</span>.</p>
<ul>
<li>The space complexity would also be the number of BSTs stored in the <code>dp</code> list which is equal to the number of BSTs stored in <code>memo</code> in the worst-case. Hence, we have the same space complexity as the first approach.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-with-space-optimization">Approach 3: Dynamic Programming with Space Optimization</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We used a 3D list where we used <code>dp[start][end]</code> to store all the BSTs having <code>end - start + 1</code> nodes with range from <code>start</code> to <code>end</code>. Let's think if we can reduce the 3D <code>dp</code> list to a 2D list.</p>
<p>If we compare all the BSTs that can be created from a set of consecutive values from <code>start</code> to <code>end</code> to those that can be created with the same number of nodes from a set of values starting at <code>1</code> and ending at <code>end - start + 1</code>, we will find that <strong>the structure of all the BSTs created with the above two ranges would be identical</strong>. The only difference is an offset of <code>start - 1</code> in the node values.</p>
<p>Here's a visual representation of BSTs with 3 nodes from range <code>[1, 3]</code> and all BSTs with range <code>[4, 6]</code>:</p>
<p><img src="../Figures/95/95-2.png" alt="img" /></p>
<p>We can see the structure of all the BSTs created with the above two ranges are identical.</p>
<p>So, we can just store the BSTs for all the ranges starting from <code>1</code> and add the offset to convert them to required ranges.</p>
<p>We create a 2D list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of all BSTs with <code>i</code> nodes having values from <code>1</code> to <code>i</code>. <code>dp[n]</code> would be the answer to the problem. Similar to the above approach, we will move in bottom to top manner.</p>
<p>We push a <code>null</code> node (empty tree) to <code>dp[0]</code> which acts as the base case.</p>
<p>To get the list of root nodes for all possible BSTs with <code>numberOfNodes</code> nodes, we would split the <code>numberOfNodes</code> nodes with <code>i - 1</code> nodes with values <code>1</code> to <code>i - 1</code> in the left subtree, a root node with value <code>i</code> and the remaining <code>numberOfNodes - i</code> nodes with values <code>i + 1</code> to <code>numberOfNodes</code> in the right subtree where <code>1 &lt;= i &lt;= numberOfNodes</code>. Note that we do not need the starting of the range here, unlike the previous approach. It is always <code>1</code>.</p>
<p>As we are executing in bottom-up manner and figuring out the answer for <code>numberOfNodes</code> nodes, we will already have the list of root nodes for all BSTs with <code>i - 1</code> and <code>numberOfNodes - i</code> nodes (for all values of <code>i = 1</code> to <code>numberOfNodes</code>).</p>
<p>However, you may realize that <code>dp[i - 1]</code> will give all the BSTs having values from <code>1</code> to <code>i - 1</code> which is exactly what we want but <code>dp[numberOfNodes - i]</code> will give all the BSTs having values from <code>1</code> to <code>numberOfNodes - i</code> which isn't what we want. We want the right subtree to have <code>numberOfNodes - i</code> nodes but the range of nodes should be from <code>i + 1</code> to <code>numberOfNodes</code>. If we add the offset <code>(i + 1) - 1 = i</code> to all the nodes, it would solve this as we would now have trees with <code>numberOfNodes - i</code> nodes from values <code>i + 1</code> to <code>numberOfNodes</code>. Let us form the BSTs now.</p>
<p>Similar to the previous approach, we create a new instance of <code>TreeNode</code> called <code>root</code> with the value <code>i</code>. We set the left child of <code>root</code> to an element in <code>dp[i - 1]</code>.</p>
<p>Now, let's set the right child of <code>root</code>. We know every element in <code>dp[numberOfNodes - i]</code> is a root node that stores a BST with <code>numberOfNodes - 1</code> nodes having values from <code>1</code> to <code>numberOfNodes - i</code>. To set the right child of <code>root</code>, we create a new tree exactly similar to the tree stored by an element of <code>dp[numberOfNodes - i]</code> but increment all the node values of the new tree by <code>i</code>. We then set the right child of <code>root</code> to this newer tree.</p>
<p>The required tree with <code>i</code> offset can be created by using a recursive function <code>clone</code> in which we pass a <code>TreeNode node</code> which corresponds to an element in <code>dp[numberOfNodes - i]</code> and an integer <code>offset</code>. We create a new <code>TreeNode clonedNode</code> with value <code>node.val + offset</code>. We then recursively set the left and the right child of <code>clonedNode</code> by performing <code>clonedNode.left = clone(node.left, offset)</code> and <code>clonedNode.right = clone(node.right, offset)</code>. Finally, return <code>clonedNode</code>.</p>
<p>It is important to note that we are creating new trees to set the right child of <code>root</code> to preserve the original trees as it might be used directly (as <code>dp[i - 1]</code>) in some other iteration of <code>i</code> and <code>numberOfNodes</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible BSTs using <code>i</code> nodes. We initialize each list <code>dp[i]</code> to an empty list for <code>i = 0</code> to <code>n</code>.</li>
<li>We push a <code>null</code> node (empty tree) into <code>dp[0]</code> because with <code>n = 0</code> we can't have any BST. This forms the base case.</li>
<li>Iterate from <code>numberOfNodes = 1</code> till <code>numberOfNodes = n</code> incrementing <code>numberOfNodes</code> by <code>1</code> after each iteration. We start an inner loop from <code>i = 1</code> to <code>numberOfNodes</code> incrementing <code>i</code> by <code>1</code>. We perform the following in this loop:
<ul>
<li>Create a variable <code>j = numberOfNodes - i - 1</code>. It presents the number of nodes in the right subtree under consideration.</li>
<li>We can form a new BST by creating a new node which acts as a root node with value <code>i</code>. We assign its left child to any element in <code>dp[i]</code> and right child to a new tree where tree is similar to an element in <code>dp[j]</code> but all node values are incremented by <code>i</code>. As a result, we need two loops to iterate through the lists <code>dp[i]</code> and <code>dp[j]</code>. We create a new <code>root</code> node with value <code>i</code>. For each element <code>left</code> in <code>dp[i]</code> and <code>right</code> in <code>dp[j]</code>, we set <code>root.left = left</code> and <code>root.right = clone(right, i)</code>. Finally, we add <code>root</code> to <code>dp[numberOfNodes]</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/a8x29E6y/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\dfrac{4^n}{\sqrt{n}})\)</span>.</p>
<ul>
<li>In this approach we are not storing all the BSTs with all the ranges. We are just storing BSTs starting from range <code>1</code>. However, we are creating all the BSTs for all the ranges from <code>[start, end]</code> (for <code>1 &lt;= start, end  &lt;= 1</code>) using the <code>clone</code> method by iterating over the BSTs starting with range <code>1</code>.</li>
<li>As a result, the time complexity should be similar to the previous approach as we are generating the same number of BSTs.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</p>
<ul>
<li>For any state <code>dp[k]</code>, we are storing all the BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. We know there are <span class="math inline">\(G(k)\)</span> BSTs that can be formed with <span class="math inline">\(k\)</span> nodes. As we have <span class="math inline">\(1\)</span> to <span class="math inline">\(n\)</span> states, the total space consumed would be <span class="math inline">\(O(\sum_{k=1}^{n} k \cdot G(k))\)</span> = <span class="math inline">\(O(\sum_{k=1}^{n}\dfrac{4^k}{{\sqrt{k}}})\)</span>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/univalued-binary-tree/description" target="_blank" rel="noopener noreferrer">Univalued Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A binary tree is <strong>uni-valued</strong> if every node in the tree has the same value.</p>

<p>Given the <code>root</code> of a binary tree, return <code>true</code><em> if the given tree is <strong>uni-valued</strong>, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png" style="width: 265px; height: 172px;" />
<pre>
<strong>Input:</strong> root = [1,1,1,1,1,null,1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png" style="width: 198px; height: 169px;" />
<pre>
<strong>Input:</strong> root = [2,2,2,5,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
	<li><code>0 &lt;= Node.val &lt; 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Let's output all the values of the array.  After, we can check that they are all equal.</p>
<p>To output all the values of the array, we perform a depth-first search.</p>
<p><a href="https://leetcode.com/playground/YmASBunM/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>A tree is univalued if both its children are univalued, plus the root node has the same value as the child nodes.</p>
<p>We can write our function recursively.  <code>left_correct</code> will represent that the left child is correct: ie., that it is univalued, and the root value is equal to the left child's value.  <code>right_correct</code> will represent the same thing for the right child.  We need both of these properties to be true.</p>
<p><a href="https://leetcode.com/playground/gRV5CroQ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the given tree.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(H)\)</span>, where <span class="math inline">\(H\)</span> is the height of the given tree.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-search-tree/description" target="_blank" rel="noopener noreferrer">Validate Binary Search Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>

<p>A <strong>valid BST</strong> is defined as follows:</p>

<ul>
	<li>The left <span data-keyword="subtree">subtree</span> of a node contains only nodes with keys&nbsp;<strong>strictly less than</strong> the node&#39;s key.</li>
	<li>The right subtree of a node contains only nodes with keys <strong>strictly greater than</strong> the node&#39;s key.</li>
	<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" />
<pre>
<strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" />
<pre>
<strong>Input:</strong> root = [5,1,4,null,null,3,6]
<strong>Output:</strong> false
<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/validate-binary-tree-nodes/description" target="_blank" rel="noopener noreferrer">Validate Binary Tree Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">tree</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> binary tree nodes numbered from <code>0</code> to <code>n - 1</code> where node <code>i</code> has two children <code>leftChild[i]</code> and <code>rightChild[i]</code>, return <code>true</code> if and only if <strong>all</strong> the given nodes form <strong>exactly one</strong> valid binary tree.</p>

<p>If node <code>i</code> has no left child then <code>leftChild[i]</code> will equal <code>-1</code>, similarly for the right child.</p>

<p>Note that the nodes have no values and that we only use the node numbers in this problem.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png" style="width: 195px; height: 287px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png" style="width: 183px; height: 272px;" />
<pre>
<strong>Input:</strong> n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png" style="width: 82px; height: 174px;" />
<pre>
<strong>Input:</strong> n = 2, leftChild = [1,0], rightChild = [-1,-1]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == leftChild.length == rightChild.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Before we go into the approaches, let's first talk about what makes a binary tree valid.</p>
<blockquote>
<p>Note that while this is not a formal definition of a binary tree, these rules are sufficient for solving the problem.</p>
</blockquote>
<p><strong>A binary tree must have a root. This is a node with no incoming edges - that is, the root has no parent.</strong></p>
<p><img src="../Figures/1361/1.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p><img src="../Figures/1361/2.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>The tree must be connected - every node must be reachable from one node (the root).</strong></p>
<p><img src="../Figures/1361/3.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p><strong>There cannot be a cycle.</strong></p>
<p><img src="../Figures/1361/4.png" alt="invalid tree example" /><br />
<br><br />
<br></p>
<p>To solve this problem, we can check the nodes given to us against these rules.</p>
<blockquote>
<p>You may notice that some of these rules imply each other. For example, if a binary tree had a root, it would have a cycle only if it was not connected, or there was a node with more than one parent.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth First Search (DFS)</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">LeetCode Explore Card</a> for more information on it!</p>
</blockquote>
<p>One way to solve this problem would be to perform a DFS on the tree and check that all the rules are followed. Before we can start a DFS, we need to locate the root. Let's define a function <code>findRoot</code> that helps us find the root.</p>
<p>As mentioned above, the root has no parent - this also means that the root is not the child of any nodes. The input arrays <code>leftChild</code> and <code>rightChild</code> describe all children, so the root would not appear in these arrays. We can simply use a for loop from <code>0</code> to <code>n - 1</code> and for each number, check if it is present in <code>leftChild</code> or <code>rightChild</code>. If it's not present in either, then we can return it as the root. If we don't find any root, we can return <code>-1</code>.</p>
<p>To improve efficiency, we will convert <code>leftChild</code> and <code>rightChild</code> to a set for <span class="math inline">\(O(1)\)</span> checks.</p>
<p><a href="https://leetcode.com/playground/iV5vT2dM/shared">code</a></p>
<p>We will start by obtaining <code>root = findRoot()</code>. If <code>root = -1</code>, there is no node without a parent, and we can immediately return false as the tree is invalid.</p>
<p>Once we have the root, we can start a DFS from it. We will implement the DFS iteratively with a stack. How can we validate the tree? First of all, if we see a node multiple times during the DFS, it means a node has multiple parents (and there could be a cycle). We will use a set <code>seen</code> that keeps track of all the nodes we have seen so far during the traversal. When we move to a <code>child</code>, if <code>child</code> is already in <code>seen</code>, we can immediately return false since we would be visiting <code>child</code> for the second time.</p>
<p>Once the DFS finishes, every node we visited will be in <code>seen</code>. If the tree is connected, then the length of <code>seen</code> will be equal to <code>n</code>. If <code>seen.length != n</code>, it means that some nodes were not visited, and thus the tree must be disconnected. Thus, we can return <code>seen.length == n</code> at the end of the algorithm.</p>
<p>This process is sufficient in validating a binary tree:</p>
<ol>
<li>If a binary tree does not have a root, then <code>findRoot</code> will return <code>-1</code>.</li>
<li>If there is a node with more than one parent, then we will detect it with <code>seen</code>.</li>
<li>If the tree is disconnected, then <code>seen</code> will hold less than <code>n</code> nodes at the end.</li>
<li>If there is a cycle, then we will detect it with <code>seen</code>.</li>
</ol>
<p>Any other scenario we don't explicitly check for will be caught by some other rule. For example, the second rule we stated was:</p>
<p><strong>Every node other than the root must have exactly one parent.</strong></p>
<p>You may be thinking: we are explicitly checking the case when a node has multiple parents with <code>seen</code>, but what if there is a node with no parent other than the <code>root</code>? That is, what if there are multiple roots? In that scenario, <code>findRoot</code> would give us the root with the lowest value. We would perform a DFS from there, and never reach any of the other roots. Then at the end, <code>seen</code> would have less than <code>n</code> nodes.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>stack</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the top of the stack as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the stack and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the DFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/W65UxZEa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a DFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>stack</code> and <code>seen</code> during the DFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth First Search (BFS)</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes an interviewer may ask you to implement both BFS and DFS. This approach is the same as the previous one, except we will use BFS to perform the traversal instead of DFS.</p>
<p>BFS uses a queue instead of a stack. If you are not familiar with BFS traversal, we suggest you read our relevant <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/">LeetCode Explore Card</a>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>findRoot</code> that gives us the root, as described above.</li>
<li>Obtain <code>root = findRoot()</code>. If <code>root == -1</code>, then <code>return false</code>.</li>
<li>Initialize a <code>queue</code> and set <code>seen</code> with <code>root</code> in them.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Pop the front of the queue as <code>node</code>.</li>
<li>Iterate over the children of <code>node</code>, given in <code>leftChild[node]</code> and <code>rightChild[node]</code>. For each <code>child</code>:
<ul>
<li>If <code>child == -1</code>, then ignore it as it means there is no child.</li>
<li>If <code>child</code> is in <code>seen</code>, <code>return false</code>.</li>
<li>Push <code>child</code> to the queue and add it to <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After the BFS, <code>return seen.length == n</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8LE3ZeZN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>To find the root, we convert <code>leftChild</code> and <code>rightChild</code> to a set, which costs <span class="math inline">\(O(n)\)</span>. Then, we iterate over all nodes, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Once we have the root, we perform a BFS that costs <span class="math inline">\(O(n)\)</span> as we never visit a node more than once. Note that an efficient queue implementation with <span class="math inline">\(O(1)\)</span> operations is required to achieve this complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> space when converting <code>leftChild</code> and <code>rightChild</code> to a set to find the root. We also require <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code> during the BFS.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union Find</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a more advanced, but interesting way to approach this problem. We have included it for the sake of completeness. It is unlikely you will be expected to implement this approach in an interview if you have already used one of the previous approaches, so we will not delve into great detail in this approach.</p>
</blockquote>
<p>A disjoint-set data structure (also called a union–find), is a data structure that stores a collection of disjoint (non-overlapping) sets. Union-find provides us with the following methods:</p>
<ol>
<li><code>find</code>: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.</li>
<li><code>union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Leetcode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Initially, all nodes belong to their own subset. We will iterate over all <code>(parent, child)</code> pairs given in <code>leftChild</code> and <code>rightChild</code> and attempt a <code>union</code>. We want to assign the subset of <code>child</code> to the subset of <code>parent</code>. For each call to <code>union(parent, child)</code>, we can see if the tree is invalid with the following checks:</p>
<ol>
<li>If <code>find(child) != child</code>, then <code>child</code> must have been assigned a parent earlier, and thus <code>child</code> has multiple parents.</li>
<li>If <code>parent</code> and <code>child</code> already belong to the same subset, then there must be a directed path from <code>child</code> to <code>parent</code> as <code>parent</code> must have been assigned to the subset of <code>child</code> earlier, and thus there exists a cycle.</li>
</ol>
<p>After performing all <code>union</code> operations successfully between parents and their children, there should only be one component in the union-find data structure. We can track the number of components by subtracting one from the count on each successful <code>union</code> operation, and then check whether the final count of components is equal to 1.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a union-find data structure <code>uf</code> that implements <code>find(node)</code> and <code>union(parent, child)</code>. It should also track the number of <code>components</code>.
<ul>
<li>In <code>union</code>, we return a boolean indicating if the union was successful. A union is unsuccessful if the parent of <code>child</code> is not <code>child</code>, or the parent of <code>parent</code> is <code>child</code>.</li>
<li>If <code>union</code> is successful, we assign the subset of <code>child</code> to the subset of <code>parent</code> and decrement the number of <code>components</code>.</li>
</ul>
</li>
<li>Iterate <code>node</code> from <code>0</code> until <code>n</code>:
<ul>
<li>Iterate over the children of <code>node</code> as <code>child</code>:
<ul>
<li>If <code>child == - 1</code>, ignore it.</li>
<li>Otherwise, perform a <code>union(node, child)</code>. If it returns false, then <code>return false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>uf.components == 1</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note: In C++, <code>union</code> is a reserved keyword and cannot be redefined. Therefore, we need to rename the <code>union</code> method, and we call it <code>join</code> here.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/c33bCEGR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>For <span class="math inline">\(T\)</span> operations, the amortized time complexity of the union-find algorithm with path compression and union-by rank is <span class="math inline">\(O(\alpha(T))\)</span>. Here, <span class="math inline">\(\alpha(T)\)</span> is the inverse Ackermann function that grows so slowly, that it doesn't exceed <span class="math inline">\(4\)</span> for all reasonable <span class="math inline">\(T\)</span> (approximately <span class="math inline">\( T < 10^{600}\)</span>). You can read more about the complexity of union-find <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity">here</a>. Because the function grows so slowly, we consider it to be <span class="math inline">\(O(1)\)</span>.</p>
<p>You may have noticed that we didn't use union-by-rank optimization as in other DSU problems. The reason for this is that the structure of this problem is not like a regular graph. More specifically, if a pair of nodes <code>(parent, child)</code> is considered valid for union, only the eligible tree root node is considered as the new child, and it will always have a rank of 0. Therefore, during the union process, the rank of all nodes will not exceed 1. As for the possibility of nodes having a rank greater than 1, it would be filtered out as required by the problem statement and won't occur. Therefore, we don't need to use union-by-rank in this problem. We encourage readers to build test cases and try them out.</p>
<p>Initializing the <code>UnionFind</code> data structure costs <span class="math inline">\(O(n)\)</span>. Then, we simply iterate over each node once and perform some union-find operations at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>UnionFind</code> data structure keeps a <code>parents</code> array that takes <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Verify Preorder Serialization of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg" style="width: 362px; height: 293px;" />
<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>

<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>

<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>

<p>You may assume that the input format is always valid.</p>

<ul>
	<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>
</ul>

<p><strong>Note:&nbsp;</strong>You are not allowed to reconstruct the tree.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> preorder = "1,#"
<strong>Output:</strong> false
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> preorder = "9,#,#,1"
<strong>Output:</strong> false
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>
	<li><code>preorder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description" target="_blank" rel="noopener noreferrer">Vertical Order Traversal of a Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.</p>

<p>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.</p>

<p>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.</p>

<p>Return <em>the <strong>vertical order traversal</strong> of the binary tree</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" style="width: 431px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[9],[3,15],[20],[7]]
<strong>Explanation:</strong>
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" style="width: 512px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" style="width: 512px; height: 304px;" />
<pre>
<strong>Input:</strong> root = [1,2,3,4,6,5,7]
<strong>Output:</strong> [[4],[2],[1,5,6],[3],[7]]
<strong>Explanation:</strong>
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>