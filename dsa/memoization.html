<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memoization - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>memoization</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">42</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">All Possible Full Binary Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Can I Win</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Cat and Mouse</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Cat and Mouse II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Climbing Stairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Count All Possible Routes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Count Visited Nodes in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Different Ways to Add Parentheses</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Fibonacci Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Find Number of Ways to Reach the K-th Stair</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Integer Replacement</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Largest Color Value in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Least Operators to Express Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Length of Longest V-Shaped Diagonal Segment</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Longest Binary Subsequence Less Than or Equal to K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Longest Increasing Path in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Maximize Grid Happiness</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Maximum Number of Groups Getting Fresh Donuts</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Maximum Number of Operations With the Same Score II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Maximum Points After Collecting Coins From All Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Maximum Strictly Increasing Cells in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Minimum Number of Days to Eat N Oranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Minimum Number of Operations to Make X and Y Equal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Minimum One Bit Operations to Make Integers Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">N-th Tribonacci Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Number of Distinct Roll Sequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Number of Increasing Paths in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Number of Ways of Cutting a Pizza</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Number of Ways to Reorder Array to Get Same BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Panda and Numbers</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-30" class="toc-link">Partition to K Equal Sum Subsets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Remove Boxes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Selling Pieces of Wood</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Shopping Offers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Sliding Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Sort Integers by The Power Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Stickers to Spell Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">The Earliest and Latest Rounds Where Players Compete</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">The Score of Students Solving Math Expression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Word Break</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Word Break II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Zuma Game</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-possible-full-binary-trees/description" target="_blank" rel="noopener noreferrer">All Possible Full Binary Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary-tree</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span> <span class="topic-badge">recursion</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, return <em>a list of all possible <strong>full binary trees</strong> with</em> <code>n</code> <em>nodes</em>. Each node of each tree in the answer must have <code>Node.val == 0</code>.</p>

<p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in <strong>any order</strong>.</p>

<p>A <strong>full binary tree</strong> is a binary tree where each node has exactly <code>0</code> or <code>2</code> children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" style="width: 700px; height: 400px;" />
<pre>
<strong>Input:</strong> n = 7
<strong>Output:</strong> [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[0,0,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an integer <code>n</code>, our task is to return a list of root nodes of all possible full binary trees with <code>n</code> nodes.</p>
<hr />
<h3 id="approach-1-recursion--memoization-top-down-dp">Approach 1: Recursion + Memoization (Top-Down DP)</h3>
<h4 id="intuition">Intuition</h4>
<p>As stated in the description, each node in a full binary tree has either <code>0</code> or <code>2</code> children. Because there is a root node, a full binary tree will always have an <strong>odd</strong> number of nodes (root node + even child nodes).</p>
<p>To find all the possible permutations of full binary trees with <code>n</code> nodes, we can use one node as the <code>root</code> node and split the other <code>n - 1</code> nodes between the left and right subtrees in all possible ways. Let us say we place <code>i</code> nodes in the left subtree and <code>n - i - 1</code> in the right subtree.</p>
<p>Now, we create a list of root nodes called <code>left</code> for all possible full binary trees that can be formed using <code>i</code> nodes. Similarly, we create a list of root nodes called <code>right</code> for all the full binary trees using <code>n - i - 1</code> nodes. We can now create a new full binary tree by choosing one element from <code>left</code> to be the left child and one element from <code>right</code> to be the right child. To generate all full binary trees, we will iterate over all pairs between <code>left, right</code>.</p>
<p>As we know any full binary tree must have an odd number of nodes, <code>i</code> and <code>n - 1 - i</code> should be odd as well to form full binary trees that are being used as the left and right subtrees. As a result, we move the value of <code>i</code> from <code>i = 1</code> till <code>n - 1</code> incrementing <code>i</code> by <code>2</code> each time so that we just loop on odd numbers of <code>i</code>. Since we have odd <code>n</code> and odd <code>i</code>, <code>n - 1 - i</code> would also be an odd number.</p>
<p>Notice that generating the lists <code>left</code> and <code>right</code> is the same as the original problem, just with a different value of <code>n</code>. We can implement this approach using recursion as we are breaking down a problem with <code>n</code> nodes to smaller, repetitive subproblems with <code>i</code> and <code>n - i - 1</code> nodes (for <code>i = 1</code> till <code>n - 1</code>, incrementing <code>i</code> by <code>2</code>) to compute the answer for <code>n</code> nodes.</p>
<p>We can convert the given method <code>allPossibleFBT</code> in the implementation into a recursive function as we only need the number of nodes as the parameter to create a list of nodes for all possible full binary tree using recursion. Here is a visual representation of the recursion tree with <code>7</code> nodes:</p>
<p><img src="../Figures/894/894-1.png" alt="img" /></p>
<p>Several subproblems, such as <code>allPossibleFBT(3)</code>, <code>allPossibleFBT(5)</code>, etc., are solved multiple times in the partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a hashmap that stores the mapping from the number of nodes to the list of root nodes of all possible full binary trees that can be formed with the same number of nodes. When we encounter the same subproblem again, we simply refer to this map to get the required list of <code>TreeNode</code>. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a hash map <code>memo</code> where <code>memo[i]</code> contains the list of root nodes of all possible full binary trees with <code>i</code> nodes.</li>
<li>If <code>n</code> is even, we return an empty list as we cannot form any full binary tree with even number of nodes.</li>
<li>If <code>n == 1</code>, we simply return a list with single node.</li>
<li>If we already have solved this subproblem, i.e., <code>memo</code> contains the key <code>n</code>, we return <code>memo[n]</code>.</li>
<li>We have odd <code>n</code>. We declare a list of <code>TreeNode</code> called <code>res</code> to store the list of root nodes of all possible full binary trees with <code>n</code> nodes.</li>
<li>Iterate from <code>i = 1</code> to <code>n - 1</code> incrementing <code>i</code> by <code>2</code> after each iteration:
<ul>
<li>Create a list of <code>TreeNode</code> called <code>left</code> to store the root nodes for all possible full binary trees using <code>i</code> nodes. We perform <code>left = allPossibleFBT(i)</code>.</li>
<li>Create a list of <code>TreeNode</code> called <code>right</code> to store the root nodes for all possible full binary trees using <code>n - 1 - i</code> nodes. We perform <code>right = allPossibleFBT(n - i - 1)</code>.</li>
<li>Iterate over both the lists <code>left</code> and <code>right</code> using two loops. For each element <code>count</code> in <code>left</code> and <code>r</code> in <code>right</code>, we create a new <code>root</code> node and set <code>root.left = l</code> and <code>root.right = r</code>. We add <code>root</code> into our answer variable <code>res</code>.</li>
</ul>
</li>
<li>Set <code>memo[n]</code> equal to <code>res</code>.</li>
<li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/KpYEVWSK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Note, the time and space complexity of this problem is difficult to derive exactly. In an interview, do your best to calculate an upper bound while explaining your thought process.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{n/2})\)</span>.</p>
<ul>
<li>The maximum number of nodes that can be in the left subtree of a full binary tree with <code>n </code>nodes is <code>n - 2</code>, since one node is the root of the tree and one node must be in the right subtree. Therefore, the total number of possible full binary trees with <code>n</code> nodes can be calculated by considering all possible combinations of the number of nodes in the left and right subtrees, such that the sum of the number of nodes in the left and right subtrees is equal to <code>n - 1</code>.</li>
<li>We can express the total number of possible full binary trees with <code>n</code> nodes as a recurrence relation <code>T(n) = T(1) * T(n - 2) + T(3) * T(n - 4) + ... + T(n - 2) * T(1)</code>, where the summation goes over all odd numbers from <code>1</code> to <code>n - 2</code>. Solving this recurrence relation using dynamic programming shows that <code>T(n)</code> is equal to the <span class="math inline">\(n^{th}\)</span> <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>, which is bounded by <span class="math inline">\(2^{n/2}\)</span>.</li>
<li>Our implementation generates all of these trees taking <span class="math inline">\(O(2^{n/2})\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</p>
<ul>
<li>The algorithm uses memoization to store the results of subproblems. Specifically, it uses a hash map called <code>memo</code> to store the results of subproblems that have already been solved.</li>
<li>For every subproblem with <code>n</code> nodes, the algorithm may need to store up to <span class="math inline">\(2^{n/2}\)</span> <code>TreeNode</code> objects in the <code>memo</code> hash map. This is because there can be up to <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes, and the algorithm needs to store all of them in order to return the result for the subproblem with <code>n</code> number of nodes. There are maximum of <code>n/2</code> subproblems (with nodes <code>1</code>, <code>3</code>, .. <code>n - 1</code>) and hence the space complexity of the algorithm is <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem. We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems iteratively first, then use them to build answers to larger problems.</p>
<p>We create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible full binary trees using <code>i</code> nodes. This is analogous to what <code>memo[i]</code> was in the previous approach.</p>
<p>We push a single node to <code>dp[1]</code> which acts as the base case.</p>
<p>We form the answer with a smaller number of nodes and move on to form answers for a bigger number of nodes. We run an outer loop from <code>count = 3</code> to <code>count = n</code> incrementing <code>count</code> by <code>2</code> after each iteration. This loop controls the total number of nodes <code>count</code> under consideration. Please keep in mind that we are only iterating over odd numbers of nodes because the answer for even numbers of nodes is an empty list. Note that here, <code>count</code> represents <code>n</code> in the previous approach. We have to use a different variable name since we are now implementing the algorithm iteratively and <code>n</code> is static per test case.</p>
<p>To get the list of root nodes for all possible full binary trees with <code>count</code> nodes, we would split the <code>count</code> nodes with <code>i</code> nodes in the left subtree and <code>count - i - 1</code> in the right subtree in the same manner as described previously. As we are executing in bottom-up manner, we will already have the list of root nodes for all possible full binary trees with <code>i</code> and <code>count - i - 1</code> nodes.</p>
<p>We create a new instance of <code>TreeNode</code> called <code>root</code> and set the left child of <code>root</code> to an element in <code>dp[i]</code> and set the right child of <code>root</code> to an element in <code>dp[l - i - 1]</code> to form a new full binary tree with <code>count</code> nodes. We will iterate over all the elements in <code>dp[i]</code> and <code>dp[count - i - 1]</code> to form all the full binary trees in this split.</p>
<p>We would run an inner loop to move <code>i</code> from <code>1</code> to <code>count - 2</code> (one node is used as root, <code>count - 2</code> nodes are used in the left subtree, leaving at least one node for the right subtree) incrementing <code>i</code> by <code>2</code> to split the <code>count</code> nodes in all the possible ways between the left and right subtree.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>If <code>n</code> is even, we return an empty list as we cannot form any full binary tree with even number of nodes.</li>
<li>Create a list <code>dp[n + 1]</code> where <code>dp[i]</code> will store a list of root nodes for all possible full binary trees using <code>i</code> nodes. We initialize each list <code>dp[i]</code> to an empty list for <code>i = 0</code> to <code>n</code>.</li>
<li>We push a single node into <code>dp[1]</code> because with <code>n = 1</code> we can just have a root node in the tree.</li>
<li>Iterate from <code>count = 3</code> till <code>count = n</code> incrementing <code>count</code> by <code>2</code> after each iteration. The outer loop corresponds to the total number of nodes under consideration. We start an inner loop from <code>i = 1</code> to <code>count - 2</code> incrementing <code>i</code> by <code>2</code> which represents the number of nodes in the left subtree under consideration. We perform the following in this loop:
<ul>
<li>Create a variable <code>j = n - i - 1</code>. It presents the number of nodes in the right subtree under consideration.</li>
<li>We can form a new full binary tree by creating a new node which acts as a root node and assigning its left child to any element in <code>dp[i]</code> and right child to any element in <code>dp[j]</code>. As a result, we iterate over both the lists <code>dp[i]</code> and <code>dp[j]</code> using two loops. For each element <code>left</code> in <code>dp[i]</code> and <code>right</code> in <code>dp[j]</code>, we create a new <code>root</code> node and set <code>root.left = left</code> and <code>root.right = right</code> to form all the full binary trees in this split. We add <code>root</code> to <code>dp[count]</code>.</li>
</ul>
</li>
<li>Return <code>dp[n]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Vxs5u5PG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^{n/2})\)</span>.</p>
<ul>
<li>There are a maximum of <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes (where <code>n</code> is an odd number) and the algorithm generates all of them without solving any subproblem twice. The time complexity is similar to the previous approach.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^{n/2})\)</span>.</p>
<ul>
<li>Similar to the <code>memo</code> hash map used in the previous approach, <code>dp[i]</code> will store the list of root nodes for all possible full binary trees with <code>i</code> nodes. As there can be a maximum of <span class="math inline">\(2^{n/2}\)</span> possible full binary trees with <code>n</code> nodes, <code>dp</code> will consume <span class="math inline">\(O(n \cdot 2^{n/2})\)</span> space to store the list of nodes corresponding to all the number of nodes from <code>1</code> to <code>n</code>.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/can-i-win/description" target="_blank" rel="noopener noreferrer">Can I Win</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from <code>1</code> to <code>10</code>. The player who first causes the running total to <strong>reach or exceed</strong> 100 wins.</p>

<p>What if we change the game so that players <strong>cannot</strong> re-use integers?</p>

<p>For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.</p>

<p>Given two integers <code>maxChoosableInteger</code> and <code>desiredTotal</code>, return <code>true</code> if the first player to move can force a win, otherwise, return <code>false</code>. Assume both players play <strong>optimally</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 11
<strong>Output:</strong> false
<strong>Explanation:</strong>
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 0
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 1
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>
	<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse/description" target="_blank" rel="noopener noreferrer">Cat and Mouse</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>

<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>

<p>The mouse starts at node <code>1</code> and goes first, the cat starts at node <code>2</code> and goes second, and there is a hole at node <code>0</code>.</p>

<p>During each player&#39;s turn, they <strong>must</strong> travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node 1, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>

<p>Additionally, it is not allowed for the Cat to travel to the Hole (node <code>0</code>).</p>

<p>Then, the game can end in three&nbsp;ways:</p>

<ul>
	<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>
	<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>
	<li>If ever a position is repeated (i.e., the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw.</li>
</ul>

<p>Given a <code>graph</code>, and assuming both players play optimally, return</p>

<ul>
	<li><code>1</code>&nbsp;if the mouse wins the game,</li>
	<li><code>2</code>&nbsp;if the cat wins the game, or</li>
	<li><code>0</code>&nbsp;if the game is a draw.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0],[3],[0,2]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= graph.length &lt;= 50</code></li>
	<li><code>1&nbsp;&lt;= graph[i].length &lt; graph.length</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
	<li><code>graph[i][j] != i</code></li>
	<li><code>graph[i]</code> is unique.</li>
	<li>The mouse and the cat can always move.&nbsp;</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-minimax--percolate-from-resolved-states">Approach 1: Minimax / Percolate from Resolved States</h3>
<p><strong>Intuition</strong></p>
<p>The state of the game can be represented as <code>(m, c, t)</code> where <code>m</code> is the location of the mouse, <code>c</code> is the location of the cat, and <code>t</code> is <code>1</code> if it is the mouse's move, else <code>2</code>.  Let's call these states <em>nodes</em>.  These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.</p>
<p>Some of these nodes are already resolved: if the mouse is at the hole <code>(m = 0)</code>, then the mouse wins; if the cat is where the mouse is <code>(c = m)</code>, then the cat wins.  Let's say that nodes will either be colored <span class="math inline">\(\small\text{MOUSE}\)</span>, <span class="math inline">\(\small\text{CAT}\)</span>, or <span class="math inline">\(\small\text{DRAW}\)</span> depending on which player is assured victory.</p>
<p>As in a standard minimax algorithm, the Mouse player will prefer <span class="math inline">\(\small\text{MOUSE}\)</span> nodes first, <span class="math inline">\(\small\text{DRAW}\)</span> nodes second, and <span class="math inline">\(\small\text{CAT}\)</span> nodes last, and the Cat player prefers these nodes in the opposite order.</p>
<p><strong>Algorithm</strong></p>
<p>We will color each <code>node</code> marked <span class="math inline">\(\small\text{DRAW}\)</span> according to the following rule.  (We'll suppose the <code>node</code> has <code>node.turn = Mouse</code>: the other case is similar.)</p>
<ul>
<li>
<p>(&quot;Immediate coloring&quot;):  If there is a child that is colored <span class="math inline">\(\small\text{MOUSE}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{MOUSE}\)</span>.</p>
</li>
<li>
<p>(&quot;Eventual coloring&quot;):  If all children are colored <span class="math inline">\(\small\text{CAT}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{CAT}\)</span>.</p>
</li>
</ul>
<p>We will repeatedly do this kind of coloring until no <code>node</code> satisfies the above conditions.  To perform this coloring efficiently, we will use a queue and perform a <em>bottom-up percolation</em>:</p>
<ul>
<li>
<p>Enqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)</p>
</li>
<li>
<p>For every <code>node</code> in the queue, for each <code>parent</code> of that <code>node</code>:</p>
<ul>
<li>
<p>Do an immediate coloring of <code>parent</code> if you can.</p>
</li>
<li>
<p>If you can't, then decrement the side-count of the number of children marked <span class="math inline">\(\small\text{DRAW}\)</span>.  If it becomes zero, then do an &quot;eventual coloring&quot; of this parent.</p>
</li>
<li>
<p>All <code>parents</code> that were colored in this manner get enqueued to the queue.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Proof of Correctness</strong></p>
<p>Our proof is similar to a proof that minimax works.</p>
<p>Say we cannot color any nodes any more, and say from any node colored <span class="math inline">\(\small\text{CAT}\)</span> or <span class="math inline">\(\small\text{MOUSE}\)</span> we need at most <span class="math inline">\(K\)</span> moves to win.  If say, some node marked <span class="math inline">\(\small\text{DRAW}\)</span> is actually a win for Mouse, it must have been with <span class="math inline">\(> K\)</span> moves.  Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored <span class="math inline">\(\small\text{MOUSE}\)</span> (as eventually the Mouse reaches the Hole.)  Thus, there must have been some transition <span class="math inline">\(\small\text{DRAW} \rightarrow \small\text{MOUSE}\)</span> along this path.</p>
<p>If this transition occurred at a <code>node</code> with <code>node.turn = Mouse</code>, then it breaks our immediate coloring rule.  If it occured with <code>node.turn = Cat</code>, and all children of <code>node</code> have color <span class="math inline">\(\small\text{MOUSE}\)</span>, then it breaks our eventual coloring rule.  If some child has color <span class="math inline">\(\small\text{CAT}\)</span>, then it breaks our immediate coloring rule.  Thus, in this case <code>node</code> will have some child with <span class="math inline">\(\small\text{DRAW}\)</span>, which breaks our optimal play assumption, as moving to this child ends the game in <span class="math inline">\(> K\)</span> moves, whereas moving to the colored neighbor ends the game in <span class="math inline">\(\leq K\)</span> moves.</p>
<p><a href="https://leetcode.com/playground/TQVY6JML/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^3)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the graph.  There are <span class="math inline">\(O(N^2)\)</span> states, and each state has an outdegree of <span class="math inline">\(N\)</span>, as there are at most <span class="math inline">\(N\)</span> different moves.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N^2)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse-ii/description" target="_blank" rel="noopener noreferrer">Cat and Mouse II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game is played by a cat and a mouse named Cat and Mouse.</p>

<p>The environment is represented by a <code>grid</code> of size <code>rows x cols</code>, where each element is a wall, floor, player (Cat, Mouse), or food.</p>

<ul>
	<li>Players are represented by the characters <code>&#39;C&#39;</code>(Cat)<code>,&#39;M&#39;</code>(Mouse).</li>
	<li>Floors are represented by the character <code>&#39;.&#39;</code> and can be walked on.</li>
	<li>Walls are represented by the character <code>&#39;#&#39;</code> and cannot be walked on.</li>
	<li>Food is represented by the character <code>&#39;F&#39;</code> and can be walked on.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
</ul>

<p>Mouse and Cat play according to the following rules:</p>

<ul>
	<li>Mouse <strong>moves first</strong>, then they take turns to move.</li>
	<li>During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the <code>grid</code>.</li>
	<li><code>catJump, mouseJump</code> are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.</li>
	<li>Staying in the same position is allowed.</li>
	<li>Mouse can jump over Cat.</li>
</ul>

<p>The game can end in 4 ways:</p>

<ul>
	<li>If Cat occupies the same position as Mouse, Cat wins.</li>
	<li>If Cat reaches the food first, Cat wins.</li>
	<li>If Mouse reaches the food first, Mouse wins.</li>
	<li>If Mouse cannot get to the food within 1000 turns, Cat wins.</li>
</ul>

<p>Given a <code>rows x cols</code> matrix <code>grid</code> and two integers <code>catJump</code> and <code>mouseJump</code>, return <code>true</code><em> if Mouse can win the game if both Cat and Mouse play optimally, otherwise return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_111_1955.png" style="width: 580px; height: 239px;" />
<pre>
<strong>Input:</strong> grid = [&quot;####F&quot;,&quot;#C...&quot;,&quot;M....&quot;], catJump = 1, mouseJump = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_2_1955.png" style="width: 580px; height: 175px;" />
<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == grid.length</code></li>
	<li><code>cols = grid[i].length</code></li>
	<li><code>1 &lt;= rows, cols &lt;= 8</code></li>
	<li><code>grid[i][j]</code> consist only of characters <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, <code>&#39;F&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39;#&#39;</code>.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
	<li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/climbing-stairs/description" target="_blank" rel="noopener noreferrer">Climbing Stairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>

<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-all-possible-routes/description" target="_blank" rel="noopener noreferrer">Count All Possible Routes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>distinct</strong> positive integers locations where <code>locations[i]</code> represents the position of city <code>i</code>. You are also given integers <code>start</code>, <code>finish</code> and <code>fuel</code> representing the starting city, ending city, and the initial amount of fuel you have, respectively.</p>

<p>At each step, if you are at city <code>i</code>, you can pick any city <code>j</code> such that <code>j != i</code> and <code>0 &lt;= j &lt; locations.length</code> and move to city <code>j</code>. Moving from city <code>i</code> to city <code>j</code> reduces the amount of fuel you have by <code>|locations[i] - locations[j]|</code>. Please notice that <code>|x|</code> denotes the absolute value of <code>x</code>.</p>

<p>Notice that <code>fuel</code> <strong>cannot</strong> become negative at any point in time, and that you are <strong>allowed</strong> to visit any city more than once (including <code>start</code> and <code>finish</code>).</p>

<p>Return <em>the count of all possible routes from </em><code>start</code> <em>to</em> <code>finish</code>. Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> The following are all possible routes, each uses 5 units of fuel:
1 -&gt; 3
1 -&gt; 2 -&gt; 3
1 -&gt; 4 -&gt; 3
1 -&gt; 4 -&gt; 2 -&gt; 3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> locations = [4,3,1], start = 1, finish = 0, fuel = 6
<strong>Output:</strong> 5
<strong>Explanation:</strong> The following are all possible routes:
1 -&gt; 0, used fuel = 1
1 -&gt; 2 -&gt; 0, used fuel = 5
1 -&gt; 2 -&gt; 1 -&gt; 0, used fuel = 5
1 -&gt; 0 -&gt; 1 -&gt; 0, used fuel = 3
1 -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 1 -&gt; 0, used fuel = 5
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> locations = [5,2,1], start = 0, finish = 2, fuel = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= locations.length &lt;= 100</code></li>
	<li><code>1 &lt;= locations[i] &lt;= 10<sup>9</sup></code></li>
	<li>All integers in <code>locations</code> are <strong>distinct</strong>.</li>
	<li><code>0 &lt;= start, finish &lt; locations.length</code></li>
	<li><code>1 &lt;= fuel &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-visited-nodes-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Count Visited Nodes in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed</strong> graph consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and <code>n</code> directed edges.</p>

<p>You are given a <strong>0-indexed</strong> array <code>edges</code> where <code>edges[i]</code> indicates that there is an edge from node <code>i</code> to node <code>edges[i]</code>.</p>

<p>Consider the following process on the graph:</p>

<ul>
	<li>You start from a node <code>x</code> and keep visiting other nodes through edges until you reach a node that you have already visited before on this <strong>same</strong> process.</li>
</ul>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the number of <strong>different</strong> nodes that you will visit if you perform the process starting from node </em><code>i</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/31/graaphdrawio-1.png" />
<pre>
<strong>Input:</strong> edges = [1,2,0,0]
<strong>Output:</strong> [3,3,3,4]
<strong>Explanation:</strong> We perform the process starting from each node in the following way:
- Starting from node 0, we visit the nodes 0 -&gt; 1 -&gt; 2 -&gt; 0. The number of different nodes we visit is 3.
- Starting from node 1, we visit the nodes 1 -&gt; 2 -&gt; 0 -&gt; 1. The number of different nodes we visit is 3.
- Starting from node 2, we visit the nodes 2 -&gt; 0 -&gt; 1 -&gt; 2. The number of different nodes we visit is 3.
- Starting from node 3, we visit the nodes 3 -&gt; 0 -&gt; 1 -&gt; 2 -&gt; 0. The number of different nodes we visit is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/31/graaph2drawio.png" style="width: 191px; height: 251px;" />
<pre>
<strong>Input:</strong> edges = [1,2,3,4,0]
<strong>Output:</strong> [5,5,5,5,5]
<strong>Explanation:</strong> Starting from any node we can visit every node in the graph in the process.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges[i] &lt;= n - 1</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/different-ways-to-add-parentheses/description" target="_blank" rel="noopener noreferrer">Different Ways to Add Parentheses</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">recursion</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>

<p>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10<sup>4</sup></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;2-1-1&quot;
<strong>Output:</strong> [0,2]
<strong>Explanation:</strong>
((2-1)-1) = 0 
(2-(1-1)) = 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> expression = &quot;2*3-4*5&quot;
<strong>Output:</strong> [-34,-14,-10,-10,10]
<strong>Explanation:</strong>
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= expression.length &lt;= 20</code></li>
	<li><code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.</li>
	<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>
	<li>The integer values in the input expression do not have a leading <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> denoting the sign.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>expression</code> containing:</p>
<ol>
<li>Numbers from 0 - 99.</li>
<li>Operators (+, -, *)</li>
</ol>
<p>Our task is to determine all possible results obtainable by grouping the numbers and operators in various ways.</p>
<hr />
<h3 id="approach-1-recursion">Approach 1: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>When we add parentheses to an expression, they group parts of the expression, telling us to evaluate those parts first. To decide where to place these parentheses, we look at each operator in the expression. Each operator offers a chance to split the expression into two smaller parts: everything before the operator and everything after it. These smaller parts are similar to our original problem, so we use recursion to solve them.</p>
<p>We start by defining our base cases, where we can return a result without further recursion:</p>
<ol>
<li>If the expression is empty, return an empty list.</li>
<li>If the expression is a single digit, return a list with that number.</li>
<li>If the expression has two characters and the first is a digit, the second must also be a digit. We convert the expression to a number and return it in a list.</li>
</ol>
<p>For longer expressions, we find operators to split the expression. We iterate through each character, and when we find an operator, we recursively evaluate the parts before and after it. We store the results of these evaluations in separate lists. Then, we combine the results from the left and right parts using the operator and store the final values in a list.</p>
<p>Here’s a visual example of how a recursion subtree might look:</p>
<p><img src="../Figures/241/subtree.png" alt="" /></p>
<p>By the end of the process, the <code>results</code> list will contain all possible results from grouping the numbers and operators in the expression.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a list <code>results</code> to store the possible outcomes.</li>
<li>If the input string is empty, return the empty <code>results</code> list.</li>
<li>Check if <code>expression</code> is a single character:
<ul>
<li>If so, convert it to an integer and add it to <code>results</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
</li>
<li>Check if <code>expression</code> has only two characters and starts with a digit:
<ul>
<li>If so, convert the entire string to an integer and add it to <code>results</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
</li>
<li>Iterate through each character of <code>expression</code>:
<ul>
<li>Set the current character as <code>currentChar</code>.</li>
<li>If <code>currentChar</code> is a digit, continue to the next iteration.</li>
<li>Recursively call <code>diffWaysToCompute</code> for the left part of <code>expression</code> (from indices <code>0</code> to <code>i-1</code>) and set it to a list <code>leftResults</code>.</li>
<li>Recursively call <code>diffWaysToCompute</code> for the right part of <code>expression</code> (from indices <code>i+1</code> to the end) and set it to a list <code>rightResults</code>.</li>
<li>Iterate through <code>leftValue</code> in <code>leftResults</code>:
<ul>
<li>For each <code>leftValue</code>, iterate through each <code>rightValue</code> in the <code>rightResults</code>:
<ul>
<li>Initialize a variable <code>computedResult</code> to store the result of the current operation.</li>
<li>Perform the operation (addition, subtraction, or multiplication) based on the current character.</li>
<li>Add the <code>computedResult</code> to the <code>results</code> list.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>results</code> as our answer.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/a5L9xDMj/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the the length of the input string <code>expression</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>For each sub-expression, we iterate through the string to identify the operators, which takes <span class="math inline">\(O(n)\)</span> time. However, the key aspect is the recursive combination of results from the left and right sub-expressions. The number of results grows exponentially because each sub-expression produces multiple results, and combining these results takes <span class="math inline">\(O(k \times l)\)</span>, where <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span> are the numbers of results from the left and right sub-problems, respectively.</p>
<p>There were some suggestions to model the number of results using Catalan numbers which we deemed as incorrect. Catalan numbers apply when counting distinct ways to fully parenthesize an expression or structure. In this problem, however, we're not just counting valid ways to split the expression but also calculating and combining all possible results. This introduces exponential growth in the number of possible results, not the polynomial growth typical of Catalan numbers. The number of combinations grows exponentially with the depth of recursive splitting, which means the overall complexity is driven by the exponential growth in results.</p>
<p>Thus, the time complexity of the algorithm is <span class="math inline">\(O(n \cdot 2^n)\)</span>, where the <span class="math inline">\(O(2^n)\)</span> factor reflects the exponential growth in the number of ways to combine results from sub-expressions.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The algorithm stores the intermediate results at each step. Since the total number of results can be equal to the <span class="math inline">\(O(2^n)\)</span>, the space complexity of the algorithm is <span class="math inline">\(O(2^n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-memoization">Approach 2: Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When dealing with complex expressions, we often find ourselves repeating the same calculations. Take the expression <code>2 + 2 - 2 - 2 - 2</code>. You could group it in different ways:</p>
<ol>
<li><code>((2 + 2) - (2 - 2) - 2)</code></li>
<li><code>((2 + 2) - 2 - (2 - 2))</code></li>
</ol>
<p>As you can see, the sub-expression (2 + 2) is evaluated more than once.</p>
<p>To avoid this, we can store the results of these sub-calculations. This way, if we hit the same sub-problem again, we can use the stored result instead of recalculating it, which speeds things up.</p>
<p>Another issue with the previous method was that it repeatedly created substrings of the expression. Since creating a substring takes <span class="math inline">\(O(n)\)</span> time, where <span class="math inline">\(n\)</span> is the length of the string, this can be quite slow. Instead, we’ll pass the entire <code>expression</code> to each recursive call and use <code>start</code> and <code>end</code> indices to specify the part we're interested in. This avoids the costly substring operations.</p>
<p>In our updated approach, each state in the recursion is defined by the <code>start</code> and <code>end</code> indices. We use a 2D array for memoization, where each cell <code>memo[i][j]</code> holds the list of possible results for the sub-expression from index <code>i</code> to index <code>j</code>.</p>
<blockquote>
<p>Note: There is an alternative way to apply memoization in this problem. Consider the expression &quot;2-2-2&quot;. This can be grouped in two ways: <code>(2 - 2) - 2</code> and <code>2 - (2 - 2)</code>. As you can see, the expression &quot;2 - 2&quot; is being evaluated repeatedly, even though the instances do not share the same indices.</p>
<p>To memoize this, we need to store the substring itself as the state of the sub-problem. This can be achieved by using a map with the substring as the key and the list of results as the value. Whenever we encounter the same substring, we can return the result from the map.</p>
<p>While this approach leads us to identify and cache more sub-problems, it forces us to use substrings in our recursion. In an interview setting, you can highlight both approaches and discuss their advantages and disadvantages for extra credit.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>diffWaysToCompute</code>:</p>
<ul>
<li>Initialize a 2D array <code>memo</code> to store computed results for sub-expressions.</li>
<li>Call the <code>computeResults</code> method with the full expression range and return the result.</li>
</ul>
<p>Helper method <code>computeResults(expression, memo, start, end)</code>:</p>
<ul>
<li>Check if the result for the range <code>[start, end]</code> is memoized. If so, return the memoized result.</li>
<li>Initialize a list <code>results</code> to store computed values for the current sub-expression.</li>
<li>Check if the current range is a single digit:
<ul>
<li>
<ul>
<li>If so, convert <code>expression</code> to an integer and add it to <code>results</code>.</li>
</ul>
</li>
<li>Return <code>results</code>.</li>
</ul>
</li>
<li>Check if the current range is a two-digit number:
<ul>
<li>If so, compute its value and add it to <code>results</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
</li>
<li>Iterate through each character in the current range of the expression:
<ul>
<li>Skip the current iteration if the character is a digit.</li>
<li>Recursively call <code>computeResults</code> for the left part of the expression up to the current character (from <code>start</code> to <code>i-1</code>). Store the result in <code>leftResults</code>.</li>
<li>Recursively call <code>computeResults</code> for the right part of the expression after the current character (from <code>i+1</code> to <code>end</code>). Store the result in <code>rightResults</code>.</li>
<li>Iterate through each <code>leftValue</code> in the <code>leftResults</code>:
<ul>
<li>For each <code>leftValue</code>, iterate through each <code>rightValue</code> in <code>rightResults</code>:
<ul>
<li>Perform the operation (addition, subtraction, or multiplication) based on the current character.</li>
<li>Add the computed result to the <code>results</code> list.</li>
</ul>
</li>
</ul>
</li>
<li>Store the result in <code>memo</code> for the range <code>[start, end]</code>.</li>
</ul>
</li>
<li>Return the <code>results</code> list.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/4xf4Rnor/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the the length of the input string <code>expression</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The algorithm uses memoization to store the results of sub-problems, ensuring that each sub-problem is evaluated exactly once. There are at most <span class="math inline">\(O(n^2)\)</span> possible sub-problems, as each sub-problem is defined by its start and end indices, both ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>.</p>
<p>Despite the efficiency gains from memoization, the time complexity is still dominated by the recursive nature of the algorithm. The recursion tree expands exponentially, with a growth factor of <span class="math inline">\(O(2^n)\)</span>.</p>
<p>Thus, the overall time complexity remains <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 \cdot 2^n)\)</span></p>
<p>The space complexity is <span class="math inline">\(O(n^2 \cdot 2^n)\)</span>, where <span class="math inline">\(O(n^2)\)</span> comes from the memoization table storing results for all sub-problems, and <span class="math inline">\(O(2^n)\)</span> accounts for the space required to store the exponentially growing number of results for each sub-problem. The recursion stack depth is at most <span class="math inline">\(O(n)\)</span>, which is dominated by the exponential complexity and can therefore be omitted from the overall space complexity analysis.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-tabulation">Approach 3: Tabulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Recursive solutions can use up a lot of stack space, which might lead to stack overflow errors. To avoid this, we'll switch to an iterative approach and build our solution step by step.</p>
<p>We’ll use a 2-D array, called <code>dp</code>, to keep track of intermediate results. This table will have dimensions <code>n x n</code>, where <code>n</code> is the length of our input <code>expression</code>. Each cell <code>dp[i][j]</code> will store all possible results for the sub-expression starting at index <code>i</code> and ending at index <code>j</code>. For instance, <code>dp[0][2]</code> will hold all possible results for the first three characters of the expression.</p>
<p>First, we need to fill in our base cases. We loop through the <code>expression</code> to identify all single-digit and double-digit numbers.</p>
<ol>
<li>For single-digit numbers, add the digit's value to <code>dp[i][i]</code>.</li>
<li>For double-digit numbers, add the number's value to <code>dp[i][i+1]</code>.</li>
</ol>
<p>Next, we handle longer sub-expressions. We start with lengths of 3 and go up to the length of the <code>expression</code>. For each length, we consider all possible starting points in the expression. This double loop structure ensures we consider all possible substrings of <code>expression</code>. For each sub-expression, we try different ways to split it. We go through each character and, when we find an operator, split the expression at that point. We then combine the results from the left and right parts using the operator.</p>
<p>After we've filled our entire <code>dp</code> table, the cell <code>dp[0][n-1]</code> contains all possible results for the entire expression. We can return this list as our final answer.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>diffWaysToCompute</code>:</p>
<ul>
<li>Initialize a variable <code>n</code> to store the length of the input string <code>expression</code>.</li>
<li>Create a 2D array <code>dp</code> of lists to store the results of sub-problems.</li>
<li>Initialize the base cases using the <code>initializeBaseCases</code> method.</li>
<li>Iterate through all possible sub-expression lengths, starting from <code>3</code> up to <code>n</code>.
<ul>
<li>For each length, iterate through all possible <code>start</code> positions of the sub-expression.</li>
<li>Set <code>end</code> as <code>start + length - 1</code>.</li>
<li>Calculate the results for the sub-expression <code>[start, end]</code> using the <code>processSubexpression</code> method.</li>
</ul>
</li>
<li>Return <code>dp[0][n-1]</code>, which contains all possible results for the entire <code>expression</code>.</li>
</ul>
<p>Helper method <code>initializeBaseCases(expression, dp)</code>:</p>
<ul>
<li>Initialize the <code>dp</code> array.</li>
<li>Handle base cases by iterating through the <code>expression</code>:
<ul>
<li>For single digits, add the digit value to <code>dp[i][i]</code>.</li>
<li>For two-digit numbers, add the number value to <code>dp[i][i+1]</code>.</li>
</ul>
</li>
</ul>
<p>Helper method <code>processSubexpression(expression, dp, start, end)</code>:</p>
<ul>
<li>Try all possible <code>split</code> positions from <code>start</code> to <code>end</code>:
<ul>
<li>If the character is numeric, continue to the next iteration</li>
<li>If not, retrieve the results of the left sub-expression from <code>dp[start][split-1]</code> and assign it to <code>leftResults</code>.</li>
<li>Retrieve the results of the right sub-expression from <code>dp[split+1][end]</code> and assign it to <code>rightResults</code>.</li>
<li>Call <code>computeResults</code> with <code>leftResults</code>, <code>rightResults</code>, and the operator at the <code>split</code> position.</li>
</ul>
</li>
</ul>
<p>Helper method <code>computeResults(op, leftResults, rightResults, results)</code>:</p>
<ul>
<li>For each combination of <code>leftResults</code> and <code>rightResults</code>:
<ul>
<li>Perform the operation specified by <code>op</code>.</li>
<li>Add the result to <code>results</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/3Gw7Y5ZR/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the the length of the input string <code>expression</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Similar to the memoization approach, the algorithm evaluates each sub-problem exactly once. Thus, the time complexity remains the same as Approach 2: <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 \cdot 2^n)\)</span></p>
<p>The space complexity is similar to the previous approach, with one key difference: the absence of the recursive stack space.</p>
<p>However, the <code>dp</code> table dominates the space complexity anyway, keeping the overall space complexity as <span class="math inline">\(O(n^2 \cdot 2^n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fibonacci-number/description" target="_blank" rel="noopener noreferrer">Fibonacci Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>

<pre>
F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n &gt; 1.
</pre>

<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-number-of-ways-to-reach-the-k-th-stair/description" target="_blank" rel="noopener noreferrer">Find Number of Ways to Reach the K-th Stair</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>non-negative</strong> integer <code>k</code>. There exists a staircase with an infinite number of stairs, with the <strong>lowest</strong> stair numbered 0.</p>

<p>Alice has an integer <code>jump</code>, with an initial value of 0. She starts on stair 1 and wants to reach stair <code>k</code> using <strong>any</strong> number of <strong>operations</strong>. If she is on stair <code>i</code>, in one <strong>operation</strong> she can:</p>

<ul>
	<li>Go down to stair <code>i - 1</code>. This operation <strong>cannot</strong> be used consecutively or on stair 0.</li>
	<li>Go up to stair <code>i + 2<sup>jump</sup></code>. And then, <code>jump</code> becomes <code>jump + 1</code>.</li>
</ul>

<p>Return the <em>total</em> number of ways Alice can reach stair <code>k</code>.</p>

<p><strong>Note</strong> that it is possible that Alice reaches the stair <code>k</code>, and performs some operations to reach the stair <code>k</code> again.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">k = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The 2 possible ways of reaching stair 0 are:</p>

<ul>
	<li>Alice starts at stair 1.
	<ul>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
	</ul>
	</li>
	<li>Alice starts at stair 1.
	<ul>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
		<li>Using an operation of the second type, she goes up 2<sup>0</sup> stairs to reach stair 1.</li>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
	</ul>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The 4 possible ways of reaching stair 1 are:</p>

<ul>
	<li>Alice starts at stair 1. Alice is at stair 1.</li>
	<li>Alice starts at stair 1.
	<ul>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
		<li>Using an operation of the second type, she goes up 2<sup>0</sup> stairs to reach stair 1.</li>
	</ul>
	</li>
	<li>Alice starts at stair 1.
	<ul>
		<li>Using an operation of the second type, she goes up 2<sup>0</sup> stairs to reach stair 2.</li>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 1.</li>
	</ul>
	</li>
	<li>Alice starts at stair 1.
	<ul>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
		<li>Using an operation of the second type, she goes up 2<sup>0</sup> stairs to reach stair 1.</li>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 0.</li>
		<li>Using an operation of the second type, she goes up 2<sup>1</sup> stairs to reach stair 2.</li>
		<li>Using an operation of the first type, she goes down 1 stair to reach stair 1.</li>
	</ul>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/integer-replacement/description" target="_blank" rel="noopener noreferrer">Integer Replacement</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>,&nbsp;you can apply one of the following&nbsp;operations:</p>

<ol>
	<li>If <code>n</code> is even, replace <code>n</code> with <code>n / 2</code>.</li>
	<li>If <code>n</code> is odd, replace <code>n</code> with either <code>n + 1</code> or <code>n - 1</code>.</li>
</ol>

<p>Return <em>the minimum number of operations needed for</em> <code>n</code> <em>to become</em> <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 8
<strong>Output:</strong> 3
<strong>Explanation:</strong> 8 -&gt; 4 -&gt; 2 -&gt; 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 7
<strong>Output:</strong> 4
<strong>Explanation: </strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-color-value-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Largest Color Value in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>

<p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>

<p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is a cycle from 0 to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == colors.length</code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>colors</code> consists of lowercase English letters.</li>
	<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/least-operators-to-express-number/description" target="_blank" rel="noopener noreferrer">Least Operators to Express Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a single positive integer <code>x</code>, we will write an expression of the form <code>x (op1) x (op2) x (op3) x ...</code> where each operator <code>op1</code>, <code>op2</code>, etc. is either addition, subtraction, multiplication, or division (<code>+</code>, <code>-</code>, <code>*</code>, or <code>/)</code>. For example, with <code>x = 3</code>, we might write <code>3 * 3 / 3 + 3 - 3</code> which is a value of <font face="monospace">3</font>.</p>

<p>When writing such an expression, we adhere to the following conventions:</p>

<ul>
	<li>The division operator (<code>/</code>) returns rational numbers.</li>
	<li>There are no parentheses placed anywhere.</li>
	<li>We use the usual order of operations: multiplication and division happen before addition and subtraction.</li>
	<li>It is not allowed to use the unary negation operator (<code>-</code>). For example, &quot;<code>x - x</code>&quot; is a valid expression as it only uses subtraction, but &quot;<code>-x + x</code>&quot; is not because it uses negation.</li>
</ul>

<p>We would like to write an expression with the least number of operators such that the expression equals the given <code>target</code>. Return the least number of operators used.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 3, target = 19
<strong>Output:</strong> 5
<strong>Explanation:</strong> 3 * 3 + 3 * 3 + 3 / 3.
The expression contains 5 operations.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 5, target = 501
<strong>Output:</strong> 8
<strong>Explanation:</strong> 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.
The expression contains 8 operations.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> x = 100, target = 100000000
<strong>Output:</strong> 3
<strong>Explanation:</strong> 100 * 100 * 100 * 100.
The expression contains 3 operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= x &lt;= 100</code></li>
	<li><code>1 &lt;= target &lt;= 2 * 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/description" target="_blank" rel="noopener noreferrer">Length of Longest V-Shaped Diagonal Segment</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer matrix <code>grid</code> of size <code>n x m</code>, where each element is either <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<p>A <strong>V-shaped diagonal segment</strong> is defined as:</p>

<ul>
	<li>The segment starts with <code>1</code>.</li>
	<li>The subsequent elements follow this infinite sequence: <code>2, 0, 2, 0, ...</code>.</li>
	<li>The segment:
	<ul>
		<li>Starts <strong>along</strong> a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).</li>
		<li>Continues the<strong> sequence</strong> in the same diagonal direction.</li>
		<li>Makes<strong> at most one clockwise 90-degree</strong><strong> turn</strong> to another diagonal direction while <strong>maintaining</strong> the sequence.</li>
	</ul>
	</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/11/length_of_longest3.jpg" style="width: 481px; height: 202px;" /></p>

<p>Return the <strong>length</strong> of the <strong>longest</strong> <strong>V-shaped diagonal segment</strong>. If no valid segment <em>exists</em>, return 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_1-2.jpg" style="width: 201px; height: 192px;" /></p>

<p>The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: <code>(0,2) &rarr; (1,3) &rarr; (2,4)</code>, takes a <strong>90-degree clockwise turn</strong> at <code>(2,4)</code>, and continues as <code>(3,3) &rarr; (4,2)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_2.jpg" style="width: 201px; height: 201px;" /></strong></p>

<p>The longest V-shaped diagonal segment has a length of 4 and follows these coordinates: <code>(2,3) &rarr; (3,2)</code>, takes a <strong>90-degree clockwise turn</strong> at <code>(3,2)</code>, and continues as <code>(2,1) &rarr; (1,0)</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_3.jpg" style="width: 201px; height: 201px;" /></strong></p>

<p>The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: <code>(0,0) &rarr; (1,1) &rarr; (2,2) &rarr; (3,3) &rarr; (4,4)</code>.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The longest V-shaped diagonal segment has a length of 1 and follows these coordinates: <code>(0,0)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>m == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code> or <code>2</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-memoization-search">Approach: Memoization Search</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, the definition of a V-shaped diagonal segment is as follows:</p>
<ul>
<li>The starting element of the V-shaped diagonal segment must be <span class="math inline">\(1\)</span>, and the subsequent elements must alternate according to the sequence <span class="math inline">\([2,0,2,0,\cdots]\)</span>. In other words, the <strong>access sequence</strong> of elements must be <span class="math inline">\([1,2,0,2,0,\cdots]\)</span>.</li>
<li>Starting from one diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right), and continuing along that same diagonal, it is allowed to make at most one clockwise <span class="math inline">\(90^\circ\)</span> turn into another diagonal direction while still maintaining the sequence pattern.</li>
</ul>
<p>There are a total of <span class="math inline">\(4\)</span> diagonal directions: from the upper left to the lower right, from the upper right to the lower left, from the lower right to the upper left, and from the lower left to the upper right. The corresponding coordinate offsets are <span class="math inline">\((1,1), (1,-1), (-1,-1), (-1,1)\)</span>. We use subscripts <span class="math inline">\(0\)</span> to <span class="math inline">\(3\)</span> to represent these directions. If the current direction is <span class="math inline">\(d\)</span> and it is rotated counterclockwise by <span class="math inline">\(90^\circ\)</span>, then the new diagonal direction is <span class="math inline">\((d+1)\bmod 4\)</span>. Careful analysis shows that once the starting position and the initial diagonal direction of a V-shaped diagonal segment are determined, the maximum possible segment length depends on the longest valid continuation from the following position. At this point, dynamic programming can be applied to compute the maximum length of a V-shaped diagonal segment starting from each point.</p>
<p>For convenience, we use a top-down memoization search. Let <span class="math inline">\(\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target})\)</span> represent the maximum length of a V-shaped diagonal segment starting from position <span class="math inline">\((x,y)\)</span>, where the current diagonal direction is <span class="math inline">\(\textit{direction}\)</span>, the expected element value is <span class="math inline">\(\textit{target}\)</span>, and the current rotation state is <span class="math inline">\(\textit{turn}\)</span>. We maintain <span class="math inline">\(\textit{memo}\)</span> to record the maximum values of all substates, and initialize all states to <span class="math inline">\(-1\)</span> for ease of calculation. Since adjacent elements must follow the V-shaped sequence pattern, we also need to verify whether the current element’s value is valid given the previous one. This is an important detail in the search.</p>
<p>The calculation process of <span class="math inline">\(\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target})\)</span> is as follows:</p>
<ul>
<li>
<p>From the previous position <span class="math inline">\((x,y)\)</span>, the next position <span class="math inline">\((nx,ny)\)</span> is computed using the offset corresponding to <span class="math inline">\(\textit{direction}\)</span>. We then check whether <span class="math inline">\((nx,ny)\)</span> is within bounds and whether <span class="math inline">\(\textit{grid}[nx][ny]\)</span> equals <span class="math inline">\(\textit{target}\)</span>. If it goes out of bounds or does not match the target, the path is invalid and we return <span class="math inline">\(0\)</span>.</p>
</li>
<li>
<p>If the path continues without rotation, the next call is <span class="math inline">\(\text{dfs}(nx,ny,\textit{direction},\textit{turn},2-\textit{target})\)</span>. If the path rotates, the next call is <span class="math inline">\(\text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn},2-\textit{target})\)</span>. The maximum length starting from <span class="math inline">\((nx,ny)\)</span> is the maximum of these two cases, plus <span class="math inline">\(1\)</span>. Thus, the recurrence is:</p>
<p><span class="math display">\[\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target}) = \max\big(\text{dfs}(nx,ny,\textit{direction},\textit{turn},2-\textit{target}), \text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn},2-\textit{target})\big) + 1
\]</span></p>
</li>
</ul>
<p>Since the target value of each element can be derived directly from its position relative to the previous element, we do not need to store the target in the memoization state. This simplifies the recurrence to:</p>
<p><span class="math display">\[\text{dfs}(x,y,\textit{direction},\textit{turn}) = \max\big(\text{dfs}(nx,ny,\textit{direction},\textit{turn}), \text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn})\big) + 1
\]</span></p>
<p>Finally, since the starting element of any valid V-shaped diagonal segment must be <span class="math inline">\(1\)</span>, we iterate through the grid, launch DFS from every position where the element equals <span class="math inline">\(1\)</span>, and compute the maximum length among all V-shaped diagonal segments.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Q9einiX9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m,n\)</span> be the number of rows and columns of the given matrix <span class="math inline">\(\textit{grid}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>There are <span class="math inline">\(O(m \cdot n)\)</span> substates in the memoization search, and each state takes <span class="math inline">\(O(1)\)</span> time to compute.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(mn)\)</span>.</p>
<p>Both the memoization table and the recursion stack require <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/description" target="_blank" rel="noopener noreferrer">Longest Binary Subsequence Less Than or Equal to K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary string <code>s</code> and a positive integer <code>k</code>.</p>

<p>Return <em>the length of the <strong>longest</strong> subsequence of </em><code>s</code><em> that makes up a <strong>binary</strong> number less than or equal to</em> <code>k</code>.</p>

<p>Note:</p>

<ul>
	<li>The subsequence can contain <strong>leading zeroes</strong>.</li>
	<li>The empty string is considered to be equal to <code>0</code>.</li>
	<li>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;1001010&quot;, k = 5
<strong>Output:</strong> 5
<strong>Explanation:</strong> The longest subsequence of s that makes up a binary number less than or equal to 5 is &quot;00010&quot;, as this number is equal to 2 in decimal.
Note that &quot;00100&quot; and &quot;00101&quot; are also possible, which are equal to 4 and 5 in decimal, respectively.
The length of this subsequence is 5, so 5 is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;00101001&quot;, k = 1
<strong>Output:</strong> 6
<strong>Explanation:</strong> &quot;000001&quot; is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.
The length of this subsequence is 6, so 6 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-greedy">Approach: Greedy</h3>
<h4 id="intuition">Intuition</h4>
<p>The task is to select the longest subsequence of <span class="math inline">\(s\)</span> such that the binary value of this subsequence is less than or equal to <span class="math inline">\(k\)</span>. The first instinct is to select as many <span class="math inline">\(0\)</span>s as possible, because compared to <span class="math inline">\(1\)</span>, a <span class="math inline">\(0\)</span> contributes nothing to the binary value.</p>
<p>So, is it okay to include all the <span class="math inline">\(0\)</span>s? Yes, because choosing a <span class="math inline">\(0\)</span> is always better than choosing a <span class="math inline">\(1\)</span>. Suppose we’ve already selected a subsequence and now want to add a <span class="math inline">\(0\)</span> to it. While the <span class="math inline">\(0\)</span> itself does not increase the binary value, it does double the contribution of any <span class="math inline">\(1\)</span>s already present by shifting them to higher positions. However, if needed, we can simply remove the highest-order <span class="math inline">\(1\)</span> to maintain the binary value, keeping the total length the same. Therefore, adding a <span class="math inline">\(0\)</span> is always beneficial or at least non-harmful compared to adding a <span class="math inline">\(1\)</span>.</p>
<p>After adding all the <span class="math inline">\(0\)</span>s, we then try to include as many <span class="math inline">\(1\)</span>s as possible. To do this, we start from the least significant bit and add <span class="math inline">\(1\)</span>s greedily, ensuring the binary value always remains <span class="math inline">\(\leq k\)</span>. Since <span class="math inline">\(k\)</span> restricts the maximum binary value, we can precompute the highest bit position that can be set to <span class="math inline">\(1\)</span>, avoiding the need to recalculate the contribution of that bit each time.</p>
<p>With these two strategies, we identify all positions that can be added to the subsequence and return the result.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/F9B5znsG/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(s\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We only need to traverse the string once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Only a few additional variables are needed.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-path-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Longest Increasing Path in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>

<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-grid-happiness/description" target="_blank" rel="noopener noreferrer">Maximize Grid Happiness</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given four integers, <code>m</code>, <code>n</code>, <code>introvertsCount</code>, and <code>extrovertsCount</code>. You have an <code>m x n</code> grid, and there are two types of people: introverts and extroverts. There are <code>introvertsCount</code> introverts and <code>extrovertsCount</code> extroverts.</p>

<p>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you <strong>do not</strong> have to have all the people living in the grid.</p>

<p>The <strong>happiness</strong> of each person is calculated as follows:</p>

<ul>
	<li>Introverts <strong>start</strong> with <code>120</code> happiness and <strong>lose</strong> <code>30</code> happiness for each neighbor (introvert or extrovert).</li>
	<li>Extroverts <strong>start</strong> with <code>40</code> happiness and <strong>gain</strong> <code>20</code> happiness for each neighbor (introvert or extrovert).</li>
</ul>

<p>Neighbors live in the directly adjacent cells north, east, south, and west of a person&#39;s cell.</p>

<p>The <strong>grid happiness</strong> is the <strong>sum</strong> of each person&#39;s happiness. Return<em> the <strong>maximum possible grid happiness</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png" style="width: 261px; height: 121px;" />
<pre>
<strong>Input:</strong> m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
<strong>Output:</strong> 240
<strong>Explanation:</strong> Assume the grid is 1-indexed with coordinates (row, column).
We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).
- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.
The above figure shows the grid in this example with each person&#39;s happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
<strong>Output:</strong> 260
<strong>Explanation:</strong> Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).
- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
<strong>Output:</strong> 240
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 5</code></li>
	<li><code>0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/description" target="_blank" rel="noopener noreferrer">Maximum Number of Groups Getting Fresh Donuts</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a donuts shop that bakes donuts in batches of <code>batchSize</code>. They have a rule where they must serve <strong>all</strong> of the donuts of a batch before serving any donuts of the next batch. You are given an integer <code>batchSize</code> and an integer array <code>groups</code>, where <code>groups[i]</code> denotes that there is a group of <code>groups[i]</code> customers that will visit the shop. Each customer will get exactly one donut.</p>

<p>When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.</p>

<p>You can freely rearrange the ordering of the groups. Return <em>the <strong>maximum</strong> possible number of happy groups after rearranging the groups.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> batchSize = 3, groups = [1,2,3,4,5,6]
<strong>Output:</strong> 4
<strong>Explanation:</strong> You can arrange the groups as [6,2,4,5,1,3]. Then the 1<sup>st</sup>, 2<sup>nd</sup>, 4<sup>th</sup>, and 6<sup>th</sup> groups will be happy.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> batchSize = 4, groups = [1,3,2,5,2,2,1,6]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= batchSize &lt;= 9</code></li>
	<li><code>1 &lt;= groups.length &lt;= 30</code></li>
	<li><code>1 &lt;= groups[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-operations-with-the-same-score-ii/description" target="_blank" rel="noopener noreferrer">Maximum Number of Operations With the Same Score II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers called <code>nums</code>, you can perform <strong>any</strong> of the following operation while <code>nums</code> contains <strong>at least</strong> <code>2</code> elements:</p>

<ul>
	<li>Choose the first two elements of <code>nums</code> and delete them.</li>
	<li>Choose the last two elements of <code>nums</code> and delete them.</li>
	<li>Choose the first and the last elements of <code>nums</code> and delete them.</li>
</ul>

<p>The<strong> score</strong> of the operation is the sum of the deleted elements.</p>

<p>Your task is to find the <strong>maximum</strong> number of operations that can be performed, such that <strong>all operations have the same score</strong>.</p>

<p>Return <em>the <strong>maximum</strong> number of operations possible that satisfy the condition mentioned above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [1,2,3,4].
- Delete the first and the last elements, with score 1 + 4 = 5, nums = [2,3].
- Delete the first and the last elements, with score 2 + 3 = 5, nums = [].
We are unable to perform any more operations as nums is empty.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,6,1,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].
- Delete the last two elements, with score 1 + 4 = 5, nums = [6].
It can be proven that we can perform at most 2 operations.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes/description" target="_blank" rel="noopener noreferrer">Maximum Points After Collecting Coins From All Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an undirected tree rooted at node <code>0</code> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given a 2D <strong>integer</strong> array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given a <strong>0-indexed</strong> array <code>coins</code> of size <code>n</code> where <code>coins[i]</code> indicates the number of coins in the vertex <code>i</code>, and an integer <code>k</code>.</p>

<p>Starting from the root, you have to collect all the coins such that the coins at a node can only be collected if the coins of its ancestors have been already collected.</p>

<p>Coins at <code>node<sub>i</sub></code> can be collected in one of the following ways:</p>

<ul>
	<li>Collect all the coins, but you will get <code>coins[i] - k</code> points. If <code>coins[i] - k</code> is negative then you will lose <code>abs(coins[i] - k)</code> points.</li>
	<li>Collect all the coins, but you will get <code>floor(coins[i] / 2)</code> points. If this way is used, then for all the <code>node<sub>j</sub></code> present in the subtree of <code>node<sub>i</sub></code>, <code>coins[j]</code> will get reduced to <code>floor(coins[j] / 2)</code>.</li>
</ul>

<p>Return <em>the <strong>maximum points</strong> you can get after collecting the coins from <strong>all</strong> the tree nodes.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/09/18/ex1-copy.png" style="width: 60px; height: 316px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem;" />
<pre>
<strong>Input:</strong> edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
<strong>Output:</strong> 11                        
<strong>Explanation:</strong> 
Collect all the coins from node 0 using the first way. Total points = 10 - 5 = 5.
Collect all the coins from node 1 using the first way. Total points = 5 + (10 - 5) = 10.
Collect all the coins from node 2 using the second way so coins left at node 3 will be floor(3 / 2) = 1. Total points = 10 + floor(3 / 2) = 11.
Collect all the coins from node 3 using the second way. Total points = 11 + floor(1 / 2) = 11.
It can be shown that the maximum points we can get after collecting coins from all the nodes is 11. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong class="example"> <img alt="" src="https://assets.leetcode.com/uploads/2023/09/18/ex2.png" style="width: 140px; height: 147px; padding: 10px; background: #fff; border-radius: .5rem;" /></strong>

<pre>
<strong>Input:</strong> edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
<strong>Output:</strong> 16
<strong>Explanation:</strong> 
Coins will be collected from all the nodes using the first way. Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == coins.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code><font face="monospace">0 &lt;= coins[i] &lt;= 10<sup>4</sup></font></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code><font face="monospace">0 &lt;= edges[i][0], edges[i][1] &lt; n</font></code></li>
	<li><code><font face="monospace">0 &lt;= k &lt;= 10<sup>4</sup></font></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Maximum Strictly Increasing Cells in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>1-indexed</strong>&nbsp;<code>m x n</code> integer matrix <code>mat</code>, you can select any cell in the matrix as your <strong>starting cell</strong>.</p>

<p>From the starting cell, you can move to any other cell <strong>in the</strong> <strong>same row or column</strong>, but only if the value of the destination cell is <strong>strictly greater</strong> than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p>

<p>Your task is to find the <strong>maximum number of cells</strong> that you can visit in the matrix by starting from some cell.</p>

<p>Return <em>an integer denoting the maximum number of cells that can be visited.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[1,1],[1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Since the cells must be strictly increasing, we can only visit one cell in this example. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png" style="width: 350px; height: 250px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1,6],[-9,5,7]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length&nbsp;</code></li>
	<li><code>n == mat[i].length&nbsp;</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/description" target="_blank" rel="noopener noreferrer">Minimum Number of Days to Eat N Oranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> oranges in the kitchen and you decided to eat some of these oranges every day as follows:</p>

<ul>
	<li>Eat one orange.</li>
	<li>If the number of remaining oranges <code>n</code> is divisible by <code>2</code> then you can eat <code>n / 2</code> oranges.</li>
	<li>If the number of remaining oranges <code>n</code> is divisible by <code>3</code> then you can eat <code>2 * (n / 3)</code> oranges.</li>
</ul>

<p>You can only choose one of the actions per day.</p>

<p>Given the integer <code>n</code>, return <em>the minimum number of days to eat</em> <code>n</code> <em>oranges</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> You have 10 oranges.
Day 1: Eat 1 orange,  10 - 1 = 9.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. 
Day 4: Eat the last orange  1 - 1  = 0.
You need at least 4 days to eat the 10 oranges.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 6
<strong>Output:</strong> 3
<strong>Explanation:</strong> You have 6 oranges.
Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).
Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.
You need at least 3 days to eat the 6 oranges.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-make-x-and-y-equal/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Make X and Y Equal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integers <code>x</code> and <code>y</code>.</p>

<p>In one operation, you can do one of the four following operations:</p>

<ol>
	<li>Divide <code>x</code> by <code>11</code> if <code>x</code> is a multiple of <code>11</code>.</li>
	<li>Divide <code>x</code> by <code>5</code> if <code>x</code> is a multiple of <code>5</code>.</li>
	<li>Decrement <code>x</code> by <code>1</code>.</li>
	<li>Increment <code>x</code> by <code>1</code>.</li>
</ol>

<p>Return <em>the <strong>minimum</strong> number of operations required to make </em> <code>x</code> <i>and</i> <code>y</code> equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> x = 26, y = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can make 26 equal to 1 by applying the following operations: 
1. Decrement x by 1
2. Divide x by 5
3. Divide x by 5
It can be shown that 3 is the minimum number of operations required to make 26 equal to 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> x = 54, y = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can make 54 equal to 2 by applying the following operations: 
1. Increment x by 1
2. Divide x by 11 
3. Divide x by 5
4. Increment x by 1
It can be shown that 4 is the minimum number of operations required to make 54 equal to 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> x = 25, y = 30
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can make 25 equal to 30 by applying the following operations: 
1. Increment x by 1
2. Increment x by 1
3. Increment x by 1
4. Increment x by 1
5. Increment x by 1
It can be shown that 5 is the minimum number of operations required to make 25 equal to 30.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/description" target="_blank" rel="noopener noreferrer">Minimum One Bit Operations to Make Integers Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer <code>n</code>, you must transform it into <code>0</code> using the following operations any number of times:</p>

<ul>
	<li>Change the rightmost (<code>0<sup>th</sup></code>) bit in the binary representation of <code>n</code>.</li>
	<li>Change the <code>i<sup>th</sup></code> bit in the binary representation of <code>n</code> if the <code>(i-1)<sup>th</sup></code> bit is set to <code>1</code> and the <code>(i-2)<sup>th</sup></code> through <code>0<sup>th</sup></code> bits are set to <code>0</code>.</li>
</ul>

<p>Return <em>the minimum number of operations to transform </em><code>n</code><em> into </em><code>0</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> The binary representation of 3 is &quot;11&quot;.
&quot;<u>1</u>1&quot; -&gt; &quot;<u>0</u>1&quot; with the 2<sup>nd</sup> operation since the 0<sup>th</sup> bit is 1.
&quot;0<u>1</u>&quot; -&gt; &quot;0<u>0</u>&quot; with the 1<sup>st</sup> operation.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 6
<strong>Output:</strong> 4
<strong>Explanation:</strong> The binary representation of 6 is &quot;110&quot;.
&quot;<u>1</u>10&quot; -&gt; &quot;<u>0</u>10&quot; with the 2<sup>nd</sup> operation since the 1<sup>st</sup> bit is 1 and 0<sup>th</sup> through 0<sup>th</sup> bits are 0.
&quot;01<u>0</u>&quot; -&gt; &quot;01<u>1</u>&quot; with the 1<sup>st</sup> operation.
&quot;0<u>1</u>1&quot; -&gt; &quot;0<u>0</u>1&quot; with the 2<sup>nd</sup> operation since the 0<sup>th</sup> bit is 1.
&quot;00<u>1</u>&quot; -&gt; &quot;00<u>0</u>&quot; with the 1<sup>st</sup> operation.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-math-and-recursion">Approach 1: Math and Recursion</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>This is a very difficult problem! In this article, we will assume that you are familiar with the basics of bit manipulation, recursion, and mathematical analysis.</p>
</blockquote>
<p>We need to develop a strategy that allows us to set bits to 0. The first observation we can make is that other than the rightmost bit, a bit can only be changed with the second operation. Thus, if we want to change a given bit (other than the rightmost one) to 0, we <strong>must</strong> first convert the number into the appropriate form. For example, let's say we have <code>n = 19</code>, which is <code>10011</code> in binary. If we want to unset the leftmost (most significant) bit, we must convert the number into <code>11000</code> first, and then perform the second operation.</p>
<p>Let's start by considering the simplest case. How many operations do we need to reduce <code>n</code> to <code>0</code> when <code>n</code> is a power of 2? We have <span class="math inline">\(n = 2^k\)</span>, where <span class="math inline">\(k\)</span> is some non-negative integer. In binary, the number has one bit set to <code>1</code>, and the rest are <code>0</code>. Let's use <span class="math inline">\(n = 16 = 2^4\)</span> as an example. In binary, <span class="math inline">\(n\)</span> is <span class="math inline">\(10000\)</span>, and we have <span class="math inline">\(k = 4\)</span>.</p>
<p>There are 3 steps to reducing <code>n</code> to <code>0</code> when it is a power of 2:</p>
<ol>
<li>First, we need to set the bit at position <code>k - 1</code>. In our example with <code>n = 16</code>, we need to set the bit at position <code>3</code>, thus <code>n</code> becomes <span class="math inline">\(11000\)</span></li>
<li>Next, we use the second operation to unset the most significant bit (at position <code>k</code>). Now, <code>n</code> becomes <span class="math inline">\(01000\)</span></li>
<li>Finally, we need to reduce the remaining number to <code>0</code> by unsetting the bit at position <code>k - 1</code></li>
</ol>
<p><img src="../Figures/1611/1.png" alt="img" /><br />
<br></p>
<p>Notice that after step 2, <code>n</code> is a new power of <code>2</code> and thus step 3 is the same problem (<strong>how many operations do we need to reduce a power of 2 to <code>0</code>?</strong>) with a smaller input. We have identified a recursive relationship.</p>
<blockquote>
<p>Before we continue, we must talk about another <strong>critical observation</strong>.</p>
<p>Both operations are <strong>reversible</strong>. Because each of the two operations flips only one bit, if we can transform <code>a</code> into <code>b</code> with a single operation <code>O1</code>, it means we can reverse the process by applying the same type of operation to <code>b</code> flipping the same bit, to get back to <code>a</code>.</p>
</blockquote>
<details><summary><b>Click here to see a brief proof of the critical observation</b></summary>
<p>Without loss of generality, let's assume that:</p>
<ul>
<li><code>a --- O1 ---&gt; b</code></li>
<li><code>b --- O2 ---&gt; c</code></li>
<li><code>c --- O3 ---&gt; d</code></li>
<li>...</li>
<li><code>y --- On ---&gt; z</code></li>
</ul>
<p>So, if a sequence of operations <code>[O1, O2, ..., On]</code> is the minimum number of steps to transform <code>a</code> into <code>z</code>, then we can also use the reversed sequence <code>[On, ..., O2, O1]</code> to transform <code>z</code> into <code>a</code> and this sequence is also the minimum number of steps to accomplish this.</p>
<p>To prove the above statement, let's employ a proof by contradiction:</p>
<ul>
<li>Given that <code>[O1, O2, ..., On]</code> is the minimum number of steps to transform <code>a</code> into <code>z</code>, let's assume that the sequence <code>[On, ..., O2, O1]</code> <strong>is not</strong> the minimum steps required to transform <code>z</code> into <code>a</code>.</li>
<li>Now, if this is the case, there must exist some other sequence, say <code>[Xm, ..., X2, X1]</code>, that requires fewer steps to transform <code>z</code> into <code>a</code>.</li>
<li>We can use the reversed sequence <code>[X1, X2, ..., Xm]</code> to transform <code>a</code> to <code>z</code>, and since it requires fewer steps than <code>[O1, O2, ..., On]</code>, this contradicts our initial assumption.</li>
<li>Therefore, our assumption that <code>[On, ..., O2, O1]</code> is not the minimum number of steps to transform <code>z</code> into <code>a</code> must be false.</li>
</ul>
</details>
<br>
<blockquote>
<p>To sum up, the minimum number of operations for converting <code>x</code> to <code>y</code> for arbitrary <code>x, y</code> is always the same as the minimum number of operations for converting <code>y</code> to <code>x</code>.</p>
<p>We will make use of this observation heavily throughout the rest of the article.</p>
</blockquote>
<p>Let <span class="math inline">\(f(k)\)</span> equal the number of operations required to reduce <span class="math inline">\(2^k\)</span> to <code>0</code>. We will use this definition of <span class="math inline">\(f\)</span> throughout the article. What is the value of <span class="math inline">\(f(k)\)</span>? It would be the sum of the 3 steps above. Let's analyze each step separately.</p>
<ol>
<li>When we start step 1, the <span class="math inline">\(k\)</span> bits to the right of the most significant bit are all <code>0</code>. After step 1, the <span class="math inline">\(k\)</span> bits to the right represent <span class="math inline">\(2^{k - 1}\)</span>, because we set the bit at position <span class="math inline">\(k - 1\)</span>. As you can see, step 1 is actually just converting <code>0</code> to <span class="math inline">\(2^{k - 1}\)</span>. From the critical observation, we know that this will cost the same number of operations as converting <span class="math inline">\(2^{k - 1}\)</span> to <code>0</code>. Thus, step 1 costs <span class="math inline">\(f(k - 1)\)</span> operations</li>
</ol>
<p><img src="../Figures/1611/2.png" alt="img" /><br />
<br></p>
<ol start="2">
<li>Step 2 costs one operation</li>
</ol>
<p><img src="../Figures/1611/3.png" alt="img" /><br />
<br></p>
<ol start="3">
<li>The remaining number is <span class="math inline">\(2^{k - 1}\)</span>. Reducing this to <code>0</code> will cost <span class="math inline">\(f(k - 1)\)</span> operations</li>
</ol>
<p><img src="../Figures/1611/4.png" alt="img" /><br />
<br></p>
<p>Summing these values, we have</p>
<p><span class="math display">\[
$$f(k) = 2 \cdot f(k - 1) + 1$$

The base case of this recurrence is when $$k = 0$$. We have $$n = 2^0 = 1$$, which requires using the first operation once. Thus, $$f(0) = 1$$.

[code](https://leetcode.com/playground/kUwoBJ5N/shared)

Calculating $$f(k)$$ will cost $$O(k)$$, although we could improve it to $$O(1)$$ with memoization (but then we would need more space and general overhead). Is there a way we can calculate $$f(k)$$ more efficiently?

With some analysis, we can show that $$f(k) = 2^{k + 1} - 1$$. 

The value of our base case is $$f(0) = 1$$, which can conveniently be written in the form $$2^k - 1$$ where $$k$$ is a non-negative integer, i.e. its value is a power of 2 minus one. When we plug this back into $$f$$, we get $$2 \cdot (2^k - 1) + 1 = 2^{k + 1} - 1$$. Without loss of generality, we have another power of two minus one.

As you can see, plugging a power of two minus one into our recurrence simply gives us the next power of two minus one. Because our base case is a power of two minus one, all values of $$f$$ will be a power of two minus one, specifically $$f(k) = 2^{k + 1} - 1$$. This method is commonly known as mathematical induction.

We can easily verify this formula by looking at values of $$f$$.

| k | breakdown | value of f(k) |
|:---:|:---:|:--------:|
|  0  | base case  | $$1 = 2^1 - 1$$ |
|  1  | 2 * f(0) + 1  | $$3 = 2^2 - 1$$ |
|  2  | 2 * f(1) + 1 = 2 * 3 + 1  | $$7 = 2^3 - 1$$ |
|  3  | 2 * f(2) + 1 = 2 * 7 + 1  | $$15 = 2^4 - 1$$ |
|  4  | 2 * f(3) + 1 = 2 * 15 + 1 | $$31 = 2^5 - 1$$ |
|  5  | 2 * f(4) + 1 = 2 * 31 + 1  | $$63 = 2^6 - 1$$ |

<br>

---

Finally, we have concluded that the number of operations to reduce a power of two $$2^k$$ is $$2^{k + 1} - 1$$. But this does not solve the problem, because `n` is not necessarily a power of two!

However, we can split the problem into two parts. The first part will be to identify the most significant bit. Let's say this bit is at position `k`. Then we can consider this bit on its own, and we have a value of $$2^k$$. We know reducing this value will cost us $$2^{k + 1} - 1$$ operations.

The remaining part will be all the bits to the right. Let's call the value of this remaining part $$n'$$. We can get this value as $$n' = n \oplus 2^k$$, where $$\oplus$$ is the XOR operation.

How many operations do we need to reduce $$n'$$ to `0`? It's the original problem with a smaller input! We can simply recursively call the function with $$n'$$. The base case of this recursion is when $$n' = 0$$, we require $$0$$ operations.

![img](../Figures/1611/5.png)
<br>

For the sake of brevity, let's denote $$A(x)$$ as the number of operations to reduce an arbitrary $$x$$ to `0`. Thus, it would cost $$A(n')$$ to solve the subproblem.

You may be thinking: the answer is $$f(k) + A(n')$$. However, it's actually $$f(k) - A(n')$$. Why?

---

**Proof**

> As a reminder:
> 
> $$k$$ is the position of the most significant bit in $$n$$
>
> $$f(k)$$ is the number of operations required to reduce $$2^k$$ to $$0$$
>
> $$n'$$ is the value of $$n$$ with the most significant bit removed
>
> $$A(x)$$ is the number of operations required to reduce an arbitrary $$x$$ to $$0$$

1. Let's say that we start with `0` and convert it to $$2^k$$. This requires $$f(k)$$ operations (remember the critical observation!)
2. Next, we convert $$2^k$$ to $$n$$. By the critical observation, this is equivalent to converting $$n$$ to $$2^k$$, which is in turn equivalent to reducing $$n'$$ to `0`. This is because all the bits in $$2^k$$ are `0` except for the bit at position `k`, which by definition is not considered in $$n'$$. We know that this conversion costs $$A(n')$$ operations
3. Finally, we reduce $$n$$ to `0`. Let's say this costs $$\text{ans}$$ operations

At the beginning of step 1 we have `0` and at the end of step 1 we have $$2^k$$. At the beginning of step 2 we have $$2^k$$ and at the end of step 3 we have `0`. Thus, step 2 and step 3 reverses the operations done by step 1, and by the critical observation, step 1 requires the same number of operations as step 2 and 3.

We have $$f(k) = A(n') + \text{ans}$$. We defined $$\text{ans}$$ as the answer to the problem, and we can rearrange: $$\text{ans} = f(k) - A(n')$$.

![img](../Figures/1611/6.png)
<br>

You may be thinking: we can also consider that it requires $$f(k) + A(n')$$ steps to convert `0` to `n`, then $$\text{ans}$$ steps to convert `n` back to `0`. Why can't we write  $$\text{ans} = f(k) + A(n')$$ instead?

We certainly could, and this "pathing" would be a perfectly valid way to use the operations to convert `0` to `n` or vice versa. However, the problem is asking for the minimum operations possible. As $$A(n') \geq 0$$, $$f(k) - A(n') \leq f(k) + A(n')$$ (see below for further explanation).

---

**Explanation**

While the argument we have presented here is convincing, it is not very intuitive! It is tough to understand, but the key idea is that during the $$f(k)$$ steps where we reduce $$2^k$$, the original number $$n$$ is actually in the middle of the process! That is, if you were to actually perform the operations to reduce $$2^k$$ to $$0$$, you would actually have the value $$n$$ after some operations.

Recall our function $$f$$ that determined the number of operations required to reduce a power of two. The first step in reducing a power of two was to set the bit at position $$k - 1$$, and it cost $$f(k - 1)$$ operations to do so.

However, these $$f(k - 1)$$ operations were performed under the assumption that we start with all the bits being `0` (since $$f$$ was defined in the context of powers of two).

With $$n$$, we may start with some bits set. These bits being set represent progress toward these $$f(k - 1)$$ operations!

For example, let's say we want to reduce $$2^3$$ which is $$1000$$ in binary. Step 1 would be to convert the number to $$1100$$. This is equivalent to converting $$0000$$ to $$0100$$, which we know requires $$f(2)$$ operations.

What if we have $$n = 10$$, which is $$1010$$ in binary? Converting this number to $$1100$$ is equivalent to converting $$0010$$ to $$0100$$. This will require less than $$f(2)$$ operations because we already have a bit set, which is progress! Basically, $$0010$$ is "closer" to $$0100$$ than $$0000$$ is to $$0100$$.

Because of the critical observation, the progress is equal to $$A(n')$$, since that is exactly the difference between the initial state of $$n$$ and the context in which $$f$$ was defined.

> To summarize the logic, it is more expensive to reduce $$2^k$$ than it is to reduce $$n$$.
>
> The reason we use $$2^k$$ in our algorithm is that we needed to break `n` into a subproblem so that we could solve it with recursion, $$2^k$$ has only one set bit, and this simple structure facilitates our recursive relationships. As we found a formula for reducing $$2^k$$, it was convenient for us to break $$n$$ into two subproblems: reducing $$2^k$$ and reducing $$n'$$.
>
> If we were to actually carry out the operations to go from `0` to `n` optimally, we would not first convert `0` to $$2^k$$ then $$2^k$$ to $$n$$. Although this would be valid, it would require $$f(k) + A(n')$$ operations and be a suboptimal strategy. Instead, we would go straight from `0` to `n`, since `n` is "on the way" to $$2^k$$. If we were to keep going until $$2^k$$, it would cost us $$A(n')$$ operations (equivalent to reducing $$n'$$).
>
> That's why we subtract $$A(n')$$ from $$f(k)$$. Because it would take us $$f(k)$$ operations to get to $$2^k$$, but we don't go to $$2^k$$. We go to $$n$$, which is $$A(n')$$ operations closer.

---

This **finally** leads us to our solution. First, we check for our base case. If `n == 0`, simply `return 0`. Otherwise, we identify `k`, the position of the most significant bit. This can be done using a while loop. Once we have `k`, we know the answer is $$f(k) - A(n')$$, where:

- $$f(k) = 2^{k + 1} - 1$$
- $$A(n') = \text{minimumOneBitOperations}(n \oplus \text{curr})$$, where $$\oplus$$ is the XOR operator and `curr` $$=2^k$$

**Algorithm**

1. If `n == 0`, return `0`.
2. Initialize `k = 0`, `curr = 1`. Here, `curr` represents $$2^k$$.
3. While `curr * 2 <= n`:
    - Multiply `curr` by `2`.
    - Increment `k`.
4. Return $$2^{k + 1} - 1 - \text{minimumOneBitOperations}(n \oplus \text{curr})$$.

**Implementation**

[code](https://leetcode.com/playground/FKapKhuS/shared)

**Complexity Analysis**

* Time complexity: $$O(\log^2{}n)$$

    The worst case scenario is when $$n$$ can be written in the form $$2^k - 1$$. The while loop to find the most significant bit will iterate $$\log{}n$$ times. Then, we call the function again with the most significant bit removed. The while loop will then iterate $$(\log{}n) - 1$$ times. In the next function call, it will iterate $$(\log{}n) - 2$$ times, and so on.

    In total, there would be $$1 + 2 + 3 + ... + \log{}n$$ iterations. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums) for $$\log{}n$$, which is equal to $$\frac{\log{}n \cdot ((\log{}n) + 1)}{2} = O(\log^2{}n)$$.

    In addition, exponentiation has a logarithmic time complexity, which cannot be ignored in an analysis such as this.

* Space complexity: $$O(\log{}n)$$

    The recursion call stack can have a max depth of $$O(\log{}n)$$. 
    
<br/>

---

### Approach 2: Iteration

**Intuition**

The same idea from the first approach can be implemented iteratively, in the opposite direction. Instead of reducing $$n$$ to `0`, we will try to convert `0` to $$n$$, which, as we know, is equivalent and requires the same minimum number of steps.

We start by considering the least significant bit of `n` and iterate toward the most significant bit. Let's say the current bit we are focusing on is at position $$k$$.

Let's say the least significant set bit is at position $$k_0$$. We know it represents $$2^{k_0}$$ by definition (as it is the least significant set bit, every other bit to the right must be 0). We also know that we require $$2^{k_0 + 1} - 1$$ operations to convert `0` to this power of two.

Consider the next bit on the left is at position $$k_1$$. To convert `0` to $$2^{k_1}$$ would require $$2^{k_1 + 1} - 1$$ operations. However, this bit does not exactly represent $$2^{k_1}$$ in the full context of `n`, since we have the bit at position $$k_0$$.

Thankfully, we learned in the previous approach that the bit being set at position $$k_0$$ actually represents progress toward the conversion to $$2^{k_1}$$. In fact, everything to the right of the current $$k$$ is analogous to $$n'$$ from the previous approach. Thus, we can subtract $$A(n')$$ from $$2^{k_1 + 1} - 1$$ to get the number of operations required to convert `0` to `n` up to $$k_1$$.

Let's continue: the next bit on the left is at position $$k_2$$. To convert `0` to $$2^{k_2}$$ would require $$2^{k_2 + 1} - 1$$ operations. Everything to the right (the bits at $$k_0$$ and $$k_1$$) represents $$n'$$ and gives us $$A(n')$$ progress toward creating `n` up to $$k_2$$.

The question is: what is the value of $$A(n')$$ at each step and how do we continuously update our answer as we iterate over the bits of `n`? We will use the following variables in our code:

1. `k`, this represents the current bit's position
2. `mask`, this represents $$2^k$$
3. `ans`, this represents the answer to the problem when considering `n` only up to the $$k^{th}$$ bit

When we are finished with the bit at $$k_i$$ and move to the bit at $$k_{i + 1}$$, `ans` now represents $$A(n')$$! Remember that $$A(n')$$ is the number of operations needed to solve the problem for $$n'$$, and $$n'$$ ignores the $$k^{th}$$ bit. When we move forward, `ans` is "outdated" and represents the answer for $$n'$$, which is exactly $$A(n')$$!

For any given $$k$$, if the $$k^{th}$$ bit is set, we can update `ans` as:

$$2^{k + 1} - 1 - \text{ans}$$

We can check if the $$k^{th}$$ bit is set by ANDing `n` with `mask`. After each iteration, we increment `k` and left shift `mask`.

**Algorithm**

1. Initialize `ans = 0`, `k = 0`, `mask = 1`.
2. While `mask <= n`:
    - If the bit from `mask` is set in `n`, that is, `n & mask != 0`, update `ans` as $$2^{k + 1} - 1 - \text{ans}$$.
    - Left shift `mask` once.
    - Increment `k`.
3. Return `ans`.

**Implementation**

[code](https://leetcode.com/playground/Pf5AeDUS/shared)

**Complexity Analysis**

* Time complexity: $$O(\log^2{}n)$$

    The while loop will iterate $$\log{}n$$ times. For each set bit, it will perform an exponentiation that costs $$O(\log{}n)$$.

    This algorithm shares the same worst-case scenario as the previous approach. When $$n = 2^k - 1$$, the cost of exponentiation would be $$1 + 2 + 3 + ... + \log{}n$$. This is the partial sum of [this series](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums) for $$\log{}n$$, which is equal to $$\frac{\log{}n \cdot ((\log{}n) + 1)}{2} = O(\log^2{}n)$$.

* Space complexity: $$O(1)$$

    This may be controversial. We aren't using any extra space other than a few integers. However, `mask` grows to a value linear with $$n$$. One could argue that such a value uses $$O(\log{}n)$$ space, although `mask` never has more than one bit set.

    We have written the space complexity as constant here as it is a standard convention to consider integers as using $$O(1)$$ space. However, there is nuance to consider when the nature of the problem focuses on bits.
    
<br/>

---

### Approach 3: Gray Code

**Intuition**

> Note: this approach is very advanced. You would not be expected to derive this approach in an interview. We have included it for the sake of completeness.

A [Gray code](https://en.wikipedia.org/wiki/Gray_code), named after Frank Gray, is an ordering of binary numbers such that every successive number in the ordering differs by only one bit.

You may notice that the two operations given in the problem are capable only of changing exactly one bit at a time. Thus, any sequence of numbers generated by these operations **must** also be a Gray code!

Although there can be many Gray codes, the standard encoding actually follows the exact same ordering as one that would be produced by the operations given in this problem.

Thus, this problem is actually equivalent to finding the index of $$n$$ in the standard Gray code sequence that starts from `0`, since reducing `n` to `0` is equivalent to converting `0` to `n`.

The [Wikipedia article](https://en.wikipedia.org/wiki/Gray_code#Converting_to_and_from_Gray_code) provides a very efficient algorithm to do this. As this approach (and certainly the derivation) is outside the scope of an interview, we will not discuss it in detail here. Interested users are encouraged to read through the Wikipedia article to learn more.

**Algorithm**

1. Initialize `ans = n`.
2. XOR `ans` with `ans >> 16`.
3. XOR `ans` with `ans >> 8`.
4. XOR `ans` with `ans >> 4`.
5. XOR `ans` with `ans >> 2`.
6. XOR `ans` with `ans >> 1`.
7. Return `ans`.

**Implementation**

[code](https://leetcode.com/playground/JLyEpXYe/shared)

**Complexity Analysis**

* Time complexity: $$O(\log{}n)$$

    The bit operations require logarithmic time. As we are always performing 10 operations (5 XORs, 5 shifts), the time complexity is $$O(\log{}n)$$.

    However, we should note that the reason we are able to hardcode these 5 lines is because we know the input is a 32-bit integer. What if we wanted to develop an algorithm that could handle an arbitrarily large integer?

    The number of logarithmic-time operations we would require is logarithmic with the number of bits, which is logarithmic with $$n$$. Thus, the time complexity would be $$O(\log{}(\log{}n) \cdot \log{}n)$$.
    
    As $$\log{}(\log{}n)$$ grows extremely slowly, this is a very efficient algorithm. For $$\log{}(\log{}n)$$ to grow to even a value of `100` would require `n` to have $$2^{100}$$ bits, a number so large it could not be explicitly written in any physical format within the observable universe. As such, this term could be considered a constant for any practical value of `n`.

* Space complexity: $$O(1)$$

    We aren't using any extra space. The previous approach's analysis does not apply here since we don't count the answer as part of the space complexity.
    
<br/>

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/n-th-tribonacci-number/description" target="_blank" rel="noopener noreferrer">N-th Tribonacci Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The Tribonacci sequence T<sub>n</sub> is defined as follows:&nbsp;</p>

<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n &gt;= 0.</p>

<p>Given <code>n</code>, return the value of T<sub>n</sub>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong>
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 25
<strong>Output:</strong> 1389537
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 37</code></li>
	<li>The answer is guaranteed to fit within a 32-bit integer, ie. <code>answer &lt;= 2^31 - 1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-distinct-roll-sequences/description" target="_blank" rel="noopener noreferrer">Number of Distinct Roll Sequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>. You roll a fair 6-sided dice <code>n</code> times. Determine the total number of <strong>distinct</strong> sequences of rolls possible such that the following conditions are satisfied:</p>

<ol>
	<li>The <strong>greatest common divisor</strong> of any <strong>adjacent</strong> values in the sequence is equal to <code>1</code>.</li>
	<li>There is <strong>at least</strong> a gap of <code>2</code> rolls between <strong>equal</strong> valued rolls. More formally, if the value of the <code>i<sup>th</sup></code> roll is <strong>equal</strong> to the value of the <code>j<sup>th</sup></code> roll, then <code>abs(i - j) &gt; 2</code>.</li>
</ol>

<p>Return <em>the<strong> total number</strong> of distinct sequences possible</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two sequences are considered distinct if at least one element is different.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 184
<strong>Explanation:</strong> Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.
Some invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).
(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).
(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.
There are a total of 184 distinct sequences possible, so we return 184.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> 22
<strong>Explanation:</strong> Some of the possible sequences are (1, 2), (2, 1), (3, 2).
Some invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.
There are a total of 22 distinct sequences possible, so we return 22.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-increasing-paths-in-a-grid/description" target="_blank" rel="noopener noreferrer">Number of Increasing Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>

<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" style="width: 181px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,1],[3,4]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].
- Paths with length 3: [1 -&gt; 3 -&gt; 4].
The total number of paths is 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -&gt; 2].
The total number of paths is 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description" target="_blank" rel="noopener noreferrer">Number of Ways of Cutting a Pizza</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a rectangular pizza represented as a <code>rows x cols</code>&nbsp;matrix containing the following characters: <code>&#39;A&#39;</code> (an apple) and <code>&#39;.&#39;</code> (empty cell) and given the integer <code>k</code>. You have to cut the pizza into <code>k</code> pieces using <code>k-1</code> cuts.&nbsp;</p>

<p>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.</p>

<p><em>Return the number of ways of cutting the pizza such that each piece contains <strong>at least</strong> one apple.&nbsp;</em>Since the answer can be a huge number, return this modulo 10^9 + 7.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png" style="width: 500px; height: 378px;" /></strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 3 
<strong>Explanation:</strong> The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
	<li><code>rows ==&nbsp;pizza.length</code></li>
	<li><code>cols ==&nbsp;pizza[i].length</code></li>
	<li><code>1 &lt;= k &lt;= 10</code></li>
	<li><code>pizza</code> consists of characters <code>&#39;A&#39;</code>&nbsp;and <code>&#39;.&#39;</code> only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description" target="_blank" rel="noopener noreferrer">Number of Ways to Reorder Array to Get Same BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search-tree</span> <span class="topic-badge">binary-tree</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">tree</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p>

<ul>
	<li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li>
</ul>

<p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p>

<p>Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/bb.png" style="width: 121px; height: 101px;" />
<pre>
<strong>Input:</strong> nums = [2,1,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex1.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/12/ex4.png" style="width: 121px; height: 161px;" />
<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are no other orderings of nums that will yield the same BST.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
	<li>All integers in <code>nums</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-recursion">Approach: Recursion</h3>
<h4 id="intuition">Intuition</h4>
<p>We can make the following conclusions:</p>
<ul>
<li>
<p>The first element of <code>nums</code> always corresponds to the root node of the corresponding BST.</p>
</li>
<li>
<p>According to the definition of a binary search tree (BST), all elements less than the root value belong to the left subtree, while all elements greater than the root value belong to the right subtree (as shown in the figure below). Let's temporarily ignore the specific structure of the left and right subtrees for now.</p>
</li>
</ul>
<p><img src="../Figures/1569/1.png" alt="img" /></p>
<p>Let <code>dfs(nums)</code> denote the number of permutations of <code>nums</code> that result in the same BST as <code>nums</code>. When iterating over the elements of <code>nums[1:]</code>, we can construct two subtrees using the subsequences <code>left_nodes = [1, 2]</code> and <code>right_nodes = [4, 5]</code> by adding each element to either the left or right subtree of the root. As long as the <strong>relative position</strong> of the elements within <code>[1, 2]</code> or <code>[4, 5]</code> remains unchanged, rearranging their positions in <code>nums</code> does not affect the construction of the subtrees.</p>
<blockquote>
<p>It should be noted that maintaining the relative positions of the numbers in each sequence does not necessarily mean that rearranging the order will always result in a different BST. However, this issue will be addressed in the next level of the subproblem, which will be considered in <code>dfs(left_nodes)</code> or <code>dfs(right_nodes)</code> by allowing the order to be changed. In the current level of recursion <code>dfs(nums)</code>, we do not consider the issue of the next level.</p>
</blockquote>
<p><img src="../Figures/1569/6.png" alt="img" /></p>
<p>Therefore, we obtain the following recursive relation:</p>
<p><span class="math display">\[
However, it is important to note that the actual number of valid permutations may exceed the calculated number from above. This is because there are some permutations that do not alter the relative order of the nodes in `left_nodes` and `right_nodes` thus resulting in the same BST.

<br>

For instance, let's consider the original array `[3,4,5,1,2]`. Here, we use `[1, 2]` to construct the left subtree and `[4, 5]` to construct the right subtree. If we only change the positions of `1` and `2` in `nums[1:]` without altering their relative order, the subsequences used to construct the left and right subtree will still be `[1, 2]` and `[4, 5]`, resulting in the same left subtree.


![img](../Figures/1569/2.png)


This implies that we need to adjust the formula by multiplying it with a coefficient ($$P$$) that represents the number of permutations that preserve the relative order of nodes in the two subsequence `left_nodes` and `right_nodes`. This leads to the modified equation:

$$\text{dfs(nums)} = P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$


It is possible to arbitrarily select two cells to hold the nodes of the left subtree, and there are 6 permutations that generate the same `left_nodes` and `right_nodes`. Therefore, we set $$P=6$$ in the above equation.

![img](../Figures/1569/3.png)


In general, for an array of length `m` with `left` nodes in the left subtree, then the number of valid permutations is equal to the number of ways of selecting `k` cells from `m - 1` cells (excluding the first cell that represents the root). This can be expressed using the binomial coefficient formula:

$$C_{m-1}^\text{left} = \binom{m-1}{\text{left}} = \frac{(m-1)!}{\text{left}!(m-1-\text{left})!}$$



<details> <summary>
        <b> &ensp; If you are not aware of the binomial coefficient, let's get a brief idea about it (click to expand) We have hidden this section in order to keep the main content coherent. Our focus is on practical applications rather than on specific implementations and theories. </b> </summary>

<br>

To efficiently compute the binomial coefficients, we can use Pascal's triangle and precompute a table to avoid repetitive calculations. To build this table, we first determine the number of rows we need based on the size of `nums`, denoted as `m`. We create a $$m \times m$$ table to represent the first `m - 1` rows of Pascal's triangle.

The numbers in Pascal's triangle are generated by summing the two numbers directly above it. We initialize the first column and the main diagonal as `1`. We then iterate over the lower-left half of the table, starting from `table[2][1]`, and compute `table[i][j]` as the sum of `table[i - 1][j - 1]` and `table[i - 1][j]`.

![img](../Figures/1569/5.png)

After building the table, we can efficiently compute the value of $$C_n^k$$ by directly looking up `table[n][k]`.

</details>

<br>

Now we can recursively solve this problem by dividing `nums` into two subsequences `left_nodes` (of length `k`) and `right_nodes`, and the number of valid permutations is denoted as 
$$ \text{dfs(nums)} \\= P\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)} \\= C_{n}^{k}\cdot \text{dfs(left\_nodes)} \cdot \text{dfs(right\_nodes)}$$. 


where $$C_{n}^{k}$$ can be obtained by using the precomputed table we discussed before or built-in functions. We treat the calls to `dfs` on the two subsequences as subproblems, and recursively solve them. The algorithm always selects the first element as the root value, and the size of the input array gradually decreases as the recursion progresses.


If the input array `nums` contains one or two elements, it only has one permutation that constructs the same BST (which is `nums` itself). Thus we have `dfs(nums) = 1` when `nums.length < 3`, which are the base cases.


<br>

Take the picture below as a detailed example.

- For `nums = [5, 1, 8, 3, 7, 9, 4, 2, 6]`, we need to keep the relative order in `[1, 3, 4, 2]` and `[8, 7, 9, 6]` unchanged, there could be $$C_8^4$$ different permutations.

- Now we move on to the left subtree constructed by `[1, 3, 4, 2]`, there is no left subtree for `root = 1` so we have the coefficient as $$C_3^0$$.

- For the right subtree constructed by `[3, 2, 4]`, we have the coefficient as $$C_2^1$$.

and so on.

![img](../Figures/1569/40.png)

Therefore, the number of permutations is equal to the product of all coefficients, which is $$\text{answer} = C_8^4 \cdot C_3^0 \cdot C_3^2 \cdot C_2^1  \cdot 1 \cdot 1 \cdot 1$$. 

Lastly, don't forget to return $$(\text{answer} - 1) \% (10^9 +7)$$ as we don't count the original `nums` as a valid permutation.


<br>

#### Algorithm


1) Define a function `dfs(nums)` as the number of valid permutations.
    - If the size of `nums` is less than 3, meaning there are 0, 1, or 2 nodes, the function returns 1, as there is only one possible permutation in each of these cases.
    - Otherwise, the function selects the first element of `nums` as the value of the root node. It then partitions the remaining elements `nums[1:]` into two subsequences, `left_nodes` and `right_nodes`, representing the values of the nodes in the left and right subtrees, respectively.
    - Let `m` be the size of `nums` and `k` be the size of `left_nodes`. Return the product of `dfs(left_nodes) * dfs(right_nodes)` and $$C_n^k$$.

2) In Java or C++, we need to build a table of Pascal's of size $$m \times m$$, since there are at most $$m - 1$$ nodes in a subtree, 
    - Initialize the first column and the main diagonal of the table to `1`.
    - Iterate over each empty cell in the lower left triangle of `table` from top to bottom and from left to right. Set `table[i][j]` as `table[i - 1][j] + table[i - 1][j - 1]`.

    Return `table[n][k]` if we need to compute $$C_n^k$$.


3) Return `(dfs(nums) - 1) % (1_000_000_007)`.

#### Implementation

[code](https://leetcode.com/playground/NmZAKnGX/shared)


#### Complexity Analysis

Let $$m$$ be the size of `nums`.

* Time complexity: $$O(m^2)$$
    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built, which takes $$O(m^2)$$ time.
    - `dfs(nums)` recursively calls itself to process the left and right subtrees of the current node `nums[0]`. Since the total size of the subtrees decreases by 1 at each level of the recursion, the maximum height of the recursion tree is $$m$$. Thus the total time complexity of the recursive solution is $$O(m^2)$$ because in each call we are doing $$O(m)$$ work creating the subsequences.

    

* Space complexity: $$O(m^2)$$ or $$O(m)$$

    - In Java or C++, a table of Pascal's triangle of size $$m \times m$$ is built.
    - The recursive solution uses the call stack to keep track of the current subtree being processed. The maximum depth of the call stack is equal to the height of the BST constructed from the input array. In the worst case, `nums` may form a degenerate BST (e.g., a sorted array), which has a height of $$m - 1$$, and the stack can hold up to $$m - 1$$ calls, resulting in a space complexity of $$O(m)$$.

<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/panda-and-numbers/" target="_blank" rel="noopener noreferrer">Panda and Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">medium</span> <span class="topic-badge">memoization</span> <span class="topic-badge">open</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Panda is fond of numbers. Given a number, he subtracts it with squares of any one particular digit of that number to get new numbers. This operation can be applied any number of times (possibly zero) till he obtains a <strong>pandatic number</strong>. If he is able to reach to a pandatic number then he wins. A pandatic number is a number which can be expressed in the form <strong><em>A</em></strong><sup><strong><em>A</em></strong></sup>, where <strong><em>A</em></strong> is a positive integer.  </p>
<p><strong>Input Format:</strong><br />
The first line will contain <strong><em>T</em></strong>, the number of test cases.<br />
Then <strong><em>T</em></strong> lines follow, each containing an integer <strong><em>N</em></strong>.  </p>
<p><strong>Output Format:</strong> <br />
For each test case, output whether it's possible for panda to reach a pandatic number by doing the operations as described. If it's possible print "<strong>Yes</strong>" (without quotes), otherwise print "<strong>No</strong>" (without quotes).    </p>
<p><strong>Constraints:</strong> </p>
<ul>
<li><strong>Subtask 1: (10 points)</strong><br />
<strong><em>1 &lt;= T</em></strong> &lt;= <strong><em>10<sup>3</sup></em></strong><br />
<strong><em>1 &lt;= N</em></strong> &lt;= <strong><em>10<sup>3</sup></em></strong> </li>
<li><strong>Subtask 2: (90 points)</strong><br />
<strong><em>1 &lt;= T</em></strong> &lt;= <strong><em>10<sup>5</sup></em></strong><br />
<strong><em>1 &lt;= N</em></strong> &lt;= <strong><em>10<sup>6</sup></em></strong> </li>
</ul></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Case 1: 1 is a pandatic number, hence the answer is "Yes".
Case 2: 3 is not a pandatic number, the answer for this is "No". 3 - 3<sup>3</sup> = -6 is also not a "pandatic number". Hence the final answer is "No".<br />
Case 3: 13 is not a pandatic number.
13 - 1<sup>2</sup> = 12 is not a pandatic number. 
13 - 3<sup>2</sup> = 4 is a pandatic number.
.
.
.
Hence the final answer is "Yes". </p></div>
				</div>
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-to-k-equal-sum-subsets/description" target="_blank" rel="noopener noreferrer">Partition to K Equal Sum Subsets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-boxes/description" target="_blank" rel="noopener noreferrer">Remove Boxes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given several <code>boxes</code> with different colors represented by different positive numbers.</p>

<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of <code>k</code> boxes, <code>k &gt;= 1</code>), remove them and get <code>k * k</code> points.</p>

<p>Return <em>the maximum points you can get</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> boxes = [1,3,2,2,2,3,4,3,1]
<strong>Output:</strong> 23
<strong>Explanation:</strong>
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----&gt; [1, 3, 3, 3, 1] (1*1=1 points) 
----&gt; [1, 1] (3*3=9 points) 
----&gt; [] (2*2=4 points)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> boxes = [1,1,1]
<strong>Output:</strong> 9
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> boxes = [1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= boxes.length &lt;= 100</code></li>
	<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/selling-pieces-of-wood/description" target="_blank" rel="noopener noreferrer">Selling Pieces of Wood</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>m</code> and <code>n</code> that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array <code>prices</code>, where <code>prices[i] = [h<sub>i</sub>, w<sub>i</sub>, price<sub>i</sub>]</code> indicates you can sell a rectangular piece of wood of height <code>h<sub>i</sub></code> and width <code>w<sub>i</sub></code> for <code>price<sub>i</sub></code> dollars.</p>

<p>To cut a piece of wood, you must make a vertical or horizontal cut across the <strong>entire</strong> height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to <code>prices</code>. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you <strong>cannot</strong> rotate a piece to swap its height and width.</p>

<p>Return <em>the <strong>maximum</strong> money you can earn after cutting an </em><code>m x n</code><em> piece of wood</em>.</p>

<p>Note that you can cut the piece of wood as many times as you want.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/27/ex1.png" style="width: 239px; height: 150px;" />
<pre>
<strong>Input:</strong> m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]
<strong>Output:</strong> 19
<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:
- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.
- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.
This obtains a total of 14 + 3 + 2 = 19 money earned.
It can be shown that 19 is the maximum amount of money that can be earned.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/27/ex2new.png" style="width: 250px; height: 175px;" />
<pre>
<strong>Input:</strong> m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]
<strong>Output:</strong> 32
<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:
- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.
This obtains a total of 30 + 2 = 32 money earned.
It can be shown that 32 is the maximum amount of money that can be earned.
Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>1 &lt;= prices.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>prices[i].length == 3</code></li>
	<li><code>1 &lt;= h<sub>i</sub> &lt;= m</code></li>
	<li><code>1 &lt;= w<sub>i</sub> &lt;= n</code></li>
	<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li>All the shapes of wood <code>(h<sub>i</sub>, w<sub>i</sub>)</code> are pairwise <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shopping-offers/description" target="_blank" rel="noopener noreferrer">Shopping Offers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In LeetCode Store, there are <code>n</code> items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>

<p>You are given an integer array <code>price</code> where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> item, and an integer array <code>needs</code> where <code>needs[i]</code> is the number of pieces of the <code>i<sup>th</sup></code> item you want to buy.</p>

<p>You are also given an array <code>special</code> where <code>special[i]</code> is of size <code>n + 1</code> where <code>special[i][j]</code> is the number of pieces of the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> offer and <code>special[i][n]</code> (i.e., the last integer in the array) is the price of the <code>i<sup>th</sup></code> offer.</p>

<p>Return <em>the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers</em>. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
<strong>Output:</strong> 14
<strong>Explanation:</strong> There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == price.length == needs.length</code></li>
	<li><code>1 &lt;= n &lt;= 6</code></li>
	<li><code>0 &lt;= price[i], needs[i] &lt;= 10</code></li>
	<li><code>1 &lt;= special.length &lt;= 100</code></li>
	<li><code>special[i].length == n + 1</code></li>
	<li><code>0 &lt;= special[i][j] &lt;= 50</code></li>
	<li>The input is generated that at least one of <code>special[i][j]</code> is non-zero for <code>0 &lt;= j &lt;= n - 1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sliding-puzzle/description" target="_blank" rel="noopener noreferrer">Sliding Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On an <code>2 x 3</code> board, there are five tiles labeled from <code>1</code> to <code>5</code>, and an empty square represented by <code>0</code>. A <strong>move</strong> consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>

<p>The state of the board is solved if and only if the board is <code>[[1,2,3],[4,5,0]]</code>.</p>

<p>Given the puzzle board <code>board</code>, return <em>the least number of moves required so that the state of the board is solved</em>. If it is impossible for the state of the board to be solved, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[4,0,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Swap the 0 and the 5 in one move.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[5,4,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No number of moves will make the board solved.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[4,1,2],[5,0,3]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 2</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>
	<li>Each value <code>board[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute-force approach is feasible due to the problem's small constraints. We can explore all possible board states and track the number of moves taken to reach each one. Once we reach the solved state, we return the move count.</p>
<p>The first step is to identify the possible moves from each board position. Each move shifts the '0' (blank square) in one of the four cardinal directions. To simplify, we’ll flatten the 2-D board to a 1-D string by appending the first row to the second. The moves at each square are now converted as given below, where each index represents the position of the zero, and lists the indices in the 1-D string it can go to:</p>
<p><img src="../Figures/773/2dto1d.png" alt="" /></p>
<p>The above figure demonstrates how each tile position is mapped to an index in the 1-D string, and how the tile movements are simulated in the string.</p>
<p>We'll use depth-first search (DFS) to explore all board states. DFS is well-suited here because it allows us to explore each possible path to the solution one by one, fully exploring each path before backtracking. Starting from the initial board state as a flattened string, we maintain a <code>visited</code> map, where each board state is a key, and the value is the number of moves taken to reach it. In our DFS, if the current state already exists in the map with fewer moves, we return early. Otherwise, we update the map with the current move count and explore all possible moves.</p>
<p>Next, we can put the current state in the map with the current move count and start exploring all possible moves from this position. We modify the board based on the next move and recursively call the DFS function to explore further.</p>
<p>After exploring all moves, if the solved state appears in the map, we return its move count; if not, we return -1, as solving the board is impossible.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a 2-D array <code>directions</code> which represents the possible moves for the empty tile (<code>0</code>) at each position on a flattened 1D representation of the <span class="math inline">\(2 \times 3\)</span> board.</li>
</ul>
<p>Main method <code>slidingPuzzle</code>:</p>
<ul>
<li>Initialize a string <code>startState</code> to represent the initial state of the board in a 1-D string format.</li>
<li>Iterate over each cell in the 2-D board and append each element to <code>startState</code>.</li>
<li>Initialize a map <code>visited</code> to store each unique state of the board encountered during the search.</li>
<li>Call a helper function <code>dfs</code> on <code>startState</code>, passing <code>visited</code>, the index of <code>0</code> in <code>startState</code>, and a move count initialized to <code>0</code>.</li>
<li>Return the minimum moves required to reach the solved state (<code>&quot;123450&quot;</code>), or -1 if the state was not found in <code>visited</code>.</li>
</ul>
<p>Helper method <code>dfs</code>:</p>
<ul>
<li>Check if the <code>state</code> has already been visited with fewer or equal moves than the current count (<code>moves</code>).
<ul>
<li>If so, skip further exploration of this path.</li>
</ul>
</li>
<li>Update <code>visited</code> with the current state and move count.</li>
<li>For each adjacent position <code>nextPos</code> in <code>directions</code>:
<ul>
<li>Swap the characters at <code>zeroPos</code> and <code>nextPos</code> in <code>state</code>.</li>
<li>Recursively call <code>dfs</code> on the newly generated state with <code>moves</code> incremented by 1.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7xoehmiw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<blockquote>
<p>Note: The values of m and n are fixed by the problem constraints, so their complexities can be considered constant. However, we have kept them as variables for clarity and better understanding.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span></p>
<p>In DFS, each of the <span class="math inline">\((m \cdot n)!\)</span> possible board states can be revisited multiple times due to different move sequences, as DFS doesn’t prioritize the shortest path and may explore all possible paths, reaching the same state repeatedly. Since each state has up to four possible moves on a 2D board, DFS could re-explore each configuration from different directions, leading to up to <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span> recursive calls. Generating each new configuration requires <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Thus, the time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The DFS approach requires storing each of the <span class="math inline">\((m \cdot n)!\)</span> unique states in a <code>visited</code> map to avoid recalculations when a state is reached with the same or fewer moves. In the worst case, the DFS call stack can reach a maximum depth of <span class="math inline">\(O((m \cdot n)!)\)</span>, giving a space complexity of <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The DFS approach explores all possible board states before reaching the final state, which can be inefficient. Although we might find the solution early, DFS will still continue to explore all paths, potentially with non-optimal move counts. To address this, we switch to Breadth-First Search (BFS). BFS is better suited in scenarios like this because it explores all states at the current move level before going deeper, ensuring that the first time it reaches the goal, it has found the shortest path.</p>
<p>Our setup remains similar: we convert the board to a 1-D string and use a set to track visited states. A queue will handle the BFS traversal, starting from the initial state. The queue’s structure works well to support BFS’s layered exploration, since each level is processed sequentially and we stop as soon as we reach the goal.</p>
<p>We then loop while the queue is not empty, processing all states at the current move count. If we encounter the final state, we return the current move count as the answer. Otherwise, we explore all possible moves from the current state, modify the board accordingly, and, if unvisited, add the new state to the queue for further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define an array <code>directions</code> to map the possible moves for the empty tile (<code>0</code>) at each position.</li>
<li>Initialize a string:
<ul>
<li><code>target</code> to &quot;123450&quot;, representing the goal state of the board.</li>
<li><code>startState</code> to store the initial configuration of the board in string form.</li>
</ul>
</li>
<li>Iterate through each row and column of <code>board</code>:
<ul>
<li>Append each tile value to <code>startState</code> to create a single string representing the initial board state.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a set <code>visited</code> to store all the board states already processed to prevent redundant calculations.</li>
<li>a <code>queue</code> for the Breadth-First Search (BFS) traversal.</li>
<li>an integer <code>moves</code> to 0, which will track the number of moves taken to reach the goal state.</li>
</ul>
</li>
<li>Add <code>startState</code> to <code>visited</code> to mark it as processed.</li>
<li>Start a while loop that continues as long as <code>queue</code> is not empty:
<ul>
<li>Store the current size of <code>queue</code> in <code>size</code>. For each item in the current level:
<ul>
<li>Remove the front element of <code>queue</code> and assign it to <code>currentState</code>.</li>
<li>Check if <code>currentState</code> matches <code>target</code>. If it does, return <code>moves</code> as the minimum moves required to reach the solved state.</li>
<li>Set <code>zeroPos</code> to the position of zero in <code>currentState</code>.</li>
<li>For each valid new position <code>newPos</code> in <code>directions[zeroPos]</code>:
<ul>
<li>Generate <code>nextState</code> by swapping <code>zeroPos</code> and <code>newPos</code>.</li>
<li>If <code>nextState</code> is already in <code>visited</code>, skip it to avoid redundant processing.</li>
<li>Otherwise, add <code>nextState</code> to both <code>visited</code> and <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>moves</code> to continue to the next level of BFS.</li>
</ul>
</li>
<li>If <code>queue</code> becomes empty without reaching the target, return -1, indicating the puzzle is unsolvable.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2hGW2Z7j/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span></p>
<p>The algorithm uses Breadth-First Search (BFS) to explore all possible board configurations. With <span class="math inline">\((m \cdot n)!\)</span> unique configurations, BFS may process each configuration once. Each configuration requires checking moves and generating new ones, taking <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The space complexity is determined by the <code>visited</code> set and the BFS queue, each of which can hold up to <span class="math inline">\((m \cdot n)!\)</span> unique configurations in the worst case. Therefore, the space complexity is <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-integers-by-the-power-value/description" target="_blank" rel="noopener noreferrer">Sort Integers by The Power Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The power of an integer <code>x</code> is defined as the number of steps needed to transform <code>x</code> into <code>1</code> using the following steps:</p>

<ul>
	<li>if <code>x</code> is even then <code>x = x / 2</code></li>
	<li>if <code>x</code> is odd then <code>x = 3 * x + 1</code></li>
</ul>

<p>For example, the power of <code>x = 3</code> is <code>7</code> because <code>3</code> needs <code>7</code> steps to become <code>1</code> (<code>3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1</code>).</p>

<p>Given three integers <code>lo</code>, <code>hi</code> and <code>k</code>. The task is to sort all integers in the interval <code>[lo, hi]</code> by the power value in <strong>ascending order</strong>, if two or more integers have <strong>the same</strong> power value sort them by <strong>ascending order</strong>.</p>

<p>Return the <code>k<sup>th</sup></code> integer in the range <code>[lo, hi]</code> sorted by the power value.</p>

<p>Notice that for any integer <code>x</code> <code>(lo &lt;= x &lt;= hi)</code> it is <strong>guaranteed</strong> that <code>x</code> will transform into <code>1</code> using these steps and that the power of <code>x</code> is will <strong>fit</strong> in a 32-bit signed integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lo = 12, hi = 15, k = 2
<strong>Output:</strong> 13
<strong>Explanation:</strong> The power of 12 is 9 (12 --&gt; 6 --&gt; 3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1)
The power of 13 is 9
The power of 14 is 17
The power of 15 is 17
The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.
Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lo = 7, hi = 11, k = 4
<strong>Output:</strong> 7
<strong>Explanation:</strong> The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].
The interval sorted by power is [8, 10, 11, 7, 9].
The fourth number in the sorted array is 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= hi - lo + 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stickers-to-spell-word/description" target="_blank" rel="noopener noreferrer">Stickers to Spell Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>n</code> different types of <code>stickers</code>. Each sticker has a lowercase English word on it.</p>

<p>You would like to spell out the given string <code>target</code> by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.</p>

<p>Return <em>the minimum number of stickers that you need to spell out </em><code>target</code>. If the task is impossible, return <code>-1</code>.</p>

<p><strong>Note:</strong> In all test cases, all words were chosen randomly from the <code>1000</code> most common US English words, and <code>target</code> was chosen as a concatenation of two random words.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;with&quot;,&quot;example&quot;,&quot;science&quot;], target = &quot;thehat&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong>
We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.
After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.
Also, this is the minimum number of stickers necessary to form the target string.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> stickers = [&quot;notice&quot;,&quot;possible&quot;], target = &quot;basicbasic&quot;
<strong>Output:</strong> -1
Explanation:
We cannot form the target &quot;basicbasic&quot; from cutting letters from the given stickers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == stickers.length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= target.length &lt;= 15</code></li>
	<li><code>stickers[i]</code> and <code>target</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-optimized-exhaustive-search">Approach 1: Optimized Exhaustive Search</h3>
<br>
<p><strong>Intuition</strong></p>
<p>A natural answer is to exhaustively search for combinations of stickers. Because the data is randomized, there are many heuristics available to us that will make this faster.</p>
<ul>
<li>
<p>For all stickers, we can ignore any letters that are not in the target word.</p>
</li>
<li>
<p>When our candidate's answer won't be smaller than an answer we have already found, we can stop searching this path.</p>
</li>
<li>
<p>We should try to have our exhaustive search bound to the answer as soon as possible, so the effect described in the above point happens more often.</p>
</li>
<li>
<p>When a sticker dominates another, we shouldn't include the dominant sticker in our sticker collection.  [Here, we say a sticker <code>A</code> dominates <code>B</code> if <code>A.count(letter) &gt;= B.count(letter)</code> for all letters.]</p>
</li>
</ul>
<br>
<p><strong>Algorithm</strong></p>
<p>Firstly, for each sticker, let's create a count of that sticker (a mapping <code>letter -&gt; sticker.count(letter)</code>) that does not consider letters not in the target word.  Let <code>A</code> be an array of these counts.  Also, let's create <code>t_count</code>, a count of our <code>target</code> word.</p>
<p>Secondly, let's remove dominated stickers. Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren't dominated are included in our collection.</p>
<p>We are now ready to begin our exhaustive search. A call to <code>search(ans)</code> denotes that we want to decide the minimum number of stickers we can use in <code>A</code> to satisfy the target count <code>t_count</code>. <code>ans</code> will store the currently formed answer, and <code>best</code> will store the current best answer.</p>
<p>If our current answer can't beat our current best answer, we should stop searching.  Also, if there are no stickers left and our target is satisfied, we should update our answer.</p>
<p>Otherwise, we want to know the maximum number of these stickers we can use. For example, if this sticker is <code>'abb'</code> and our target is <code>'aaabbbbccccc'</code>, then we could use a maximum of 3 stickers.  This is the maximum of <code>math.ceil(target.count(letter) / sticker.count(letter))</code>, taken over all <code>letter</code>s in <code>sticker</code>.  Let's call this quantity <code>used</code>.</p>
<p>After, for the sticker we are currently considering, we try to use <code>used</code> of them, then <code>used - 1</code>, <code>used - 2</code>, and so on. The reason we do it in this order is so that we can arrive at a value for <code>best</code> more quickly, which will stop other branches of our exhaustive search from continuing.</p>
<p>The Python version of this solution showcases using <code>collections.Counter</code> as a way to simplify some code sections, whereas the Java solution sticks to arrays.</p>
<p><a href="https://leetcode.com/playground/KP3fS7G3/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: Let <span class="math inline">\(N\)</span> be the number of stickers, and <span class="math inline">\(T\)</span> be the number of letters in the target word. A bound for time complexity is <span class="math inline">\(O(N^{T+1} T^2)\)</span>: for each sticker, we'll have to try using it up to <span class="math inline">\(T+1\)</span> times, and updating our target count costs <span class="math inline">\(O(T)\)</span>, which we do up to <span class="math inline">\(T\)</span> times. Alternatively, since the answer is bounded at <span class="math inline">\(T\)</span>, we can prove that we can only search up to <span class="math inline">\(\binom{N+T-1}{T-1}\)</span> times. This would be <span class="math inline">\(O(\binom{N+T-1}{T-1} T^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N+T)\)</span>, to store <code>stickersCount</code>, <code>targetCount</code>, and handle the recursive call stack when calling <code>search</code>.</p>
</li>
</ul>
<br>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<br>
<p><strong>Intuition</strong></p>
<p>Suppose we need <code>dp[state]</code> stickers to satisfy all <code>target[i]</code>'s for which the <code>i</code>-th bit of <code>state</code> is set. We would like to know <code>dp[(1 &lt;&lt; len(target)) - 1]</code>.</p>
<br>
<p><strong>Algorithm</strong></p>
<p>For each <code>state</code>, let's work with it as <code>now</code> and look at what happens to it after applying a sticker. For each letter in the sticker that can satisfy an unset bit of <code>state</code>, we set the bit (<code>now |= 1 &lt;&lt; i</code>). In the end, we know <code>now</code> is the result of applying that sticker to <code>state</code>, and we update our <code>dp</code> appropriately.</p>
<p>When using Python, we will need some extra techniques from <em>Approach #1</em> to pass in time.</p>
<p><a href="https://leetcode.com/playground/JTZ2SYco/shared">code</a></p>
<br>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(2^T * S * T)\)</span> where <span class="math inline">\(S\)</span> is the total number of letters in all stickers, and <span class="math inline">\(T\)</span> is the number of letters in the target word. We can examine each loop carefully to arrive at this conclusion.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(2^T)\)</span>, the space used by <code>dp</code>.</p>
</li>
</ul>
<br></div>
				</div>
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/description" target="_blank" rel="noopener noreferrer">The Earliest and Latest Rounds Where Players Compete</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a tournament where <code>n</code> players are participating. The players are standing in a single row and are numbered from <code>1</code> to <code>n</code> based on their <strong>initial</strong> standing position (player <code>1</code> is the first player in the row, player <code>2</code> is the second player in the row, etc.).</p>

<p>The tournament consists of multiple rounds (starting from round number <code>1</code>). In each round, the <code>i<sup>th</sup></code> player from the front of the row competes against the <code>i<sup>th</sup></code> player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.</p>

<ul>
	<li>For example, if the row consists of players <code>1, 2, 4, 6, 7</code>

	<ul>
		<li>Player <code>1</code> competes against player <code>7</code>.</li>
		<li>Player <code>2</code> competes against player <code>6</code>.</li>
		<li>Player <code>4</code> automatically advances to the next round.</li>
	</ul>
	</li>
</ul>

<p>After each round is over, the winners are lined back up in the row based on the <strong>original ordering</strong> assigned to them initially (ascending order).</p>

<p>The players numbered <code>firstPlayer</code> and <code>secondPlayer</code> are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may <strong>choose</strong> the outcome of this round.</p>

<p>Given the integers <code>n</code>, <code>firstPlayer</code>, and <code>secondPlayer</code>, return <em>an integer array containing two values, the <strong>earliest</strong> possible round number and the&nbsp;<strong>latest</strong> possible round number in which these two players will compete against each other, respectively</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 11, firstPlayer = 2, secondPlayer = 4
<strong>Output:</strong> [3,4]
<strong>Explanation:</strong>
One possible scenario which leads to the earliest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 2, 3, 4, 5, 6, 11
Third round: 2, 3, 4
One possible scenario which leads to the latest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 1, 2, 3, 4, 5, 6
Third round: 1, 2, 4
Fourth round: 2, 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, firstPlayer = 1, secondPlayer = 5
<strong>Output:</strong> [1,1]
<strong>Explanation:</strong> The players numbered 1 and 5 compete in the first round.
There is no way to make them compete in any other round.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 28</code></li>
	<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-analyze-fundamentally-different-standing-situations--memoized-search">Approach: Analyze Fundamentally Different Standing Situations + Memoized Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can represent the earliest round number of the competition between the two best athletes, who are the <span class="math inline">\(f\)</span>th and <span class="math inline">\(s\)</span>th athletes from the left in a row, with <span class="math inline">\(n\)</span> people remaining as <span class="math inline">\(F(n, f, s)\)</span>.</p>
<p>Similarly, we use <span class="math inline">\(G(n, f, s)\)</span> to represent the latest round in which they compete.</p>
<p>How is state transition carried out?</p>
<p><strong>We only consider situations with fundamentally different relative positions.</strong></p>
<p>If we simply use <span class="math inline">\(F(n, f, s)\)</span> for state transitions, the resulting algorithm and code would become quite complex. For example, we need to consider whether <span class="math inline">\(f\)</span> is on the left (i.e., counting from the front), in the middle (i.e., skipping a turn), or on the right (i.e., counting from the back). We must also consider several possibilities for <span class="math inline">\(s\)</span>, which makes the state transition equations rather cumbersome.</p>
<p>We can consider analyzing the <strong>essentially different positioning situations</strong> and obtain the following table:</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><span class="math inline">\(s\)</span> on the left</th>
<th align="center"><span class="math inline">\(s\)</span> in the middle</th>
<th align="center"><span class="math inline">\(s\)</span> on the right</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><span class="math inline">\(f\)</span> on the left</td>
<td align="center">maintain unchanged</td>
<td align="center">maintain unchanged</td>
<td align="center">maintain unchanged</td>
</tr>
<tr>
<td align="center"><span class="math inline">\(f\)</span> in the middle</td>
<td align="center">equivalent to &quot;<span class="math inline">\(f\)</span> on the left, <span class="math inline">\(s\)</span> in the middle&quot;</td>
<td align="center">There is no such situation</td>
<td align="center">equivalent to &quot;<span class="math inline">\(f\)</span> on the left, <span class="math inline">\(s\)</span> in the middle&quot;</td>
</tr>
<tr>
<td align="center"><span class="math inline">\(f\)</span> on the right</td>
<td align="center">equivalent to &quot;<span class="math inline">\(f\)</span> on the left，<span class="math inline">\(s\)</span> on the right&quot;</td>
<td align="center">equivalent to &quot;<span class="math inline">\(f\)</span> on the left, <span class="math inline">\(s\)</span> in the middle&quot;</td>
<td align="center">equivalent to &quot;<span class="math inline">\(f\)</span> on the left, <span class="math inline">\(s\)</span> on the left&quot;</td>
</tr>
</tbody>
</table>
<p>The correctness is based on the following invariants:</p>
<ul>
<li>
<p><span class="math inline">\(F(n, f, s) = F(n, s, f)\)</span> holds true. That is, swapping the positions of the two best athletes does not change the result.</p>
</li>
<li>
<p><span class="math inline">\(F(n, f, s) = F(n, n+1-s, n+1-f)\)</span> holds true. Since each <span class="math inline">\(i\)</span>-th athlete from the front competes with the <span class="math inline">\(i\)</span>-th athlete from the back, flipping the entire arrangement does not affect the outcome.</p>
</li>
</ul>
<p>We use these two transformation rules to ensure that in <span class="math inline">\(F(n, f, s)\)</span>, <span class="math inline">\(f\)</span> is always less than <span class="math inline">\(s\)</span>. Therefore, <span class="math inline">\(f\)</span> must be on the left, while <span class="math inline">\(s\)</span> can be on the left, in the middle, or on the right. In this way, we reduce the original <span class="math inline">\(8\)</span> cases to <span class="math inline">\(3\)</span> cases.</p>
<p>For <span class="math inline">\(G(n, f, s)\)</span>, the approach is completely the same.</p>
<p><strong>Design of state transition equations</strong></p>
<p>Since we know that <span class="math inline">\(f\)</span> is definitely on the left, we can then design the state transition equations separately according to whether <span class="math inline">\(s\)</span> is on the left, in the middle, or on the right.</p>
<p><img src="https://assets.leetcode.com/users/images/9d5dad1d-f8de-42ab-b09c-9dfc4acf03e9_1751855251.8339484.png" alt="fig1" /></p>
<p>If <span class="math inline">\(s\)</span> is on the left, as shown in the figure above:</p>
<ul>
<li>
<p><span class="math inline">\(f\)</span> has <span class="math inline">\(f-1\)</span> athletes on the left, who will compete with the corresponding athletes on the right, leaving <span class="math inline">\([0, f-1]\)</span> athletes.</p>
</li>
<li>
<p><span class="math inline">\(f\)</span> and <span class="math inline">\(s\)</span> have <span class="math inline">\(s-f-1\)</span> athletes in between, who will compete with the corresponding athletes on the right, leaving <span class="math inline">\([0, s-f-1]\)</span> athletes remaining.</p>
</li>
</ul>
<p>If there are <span class="math inline">\(f-1\)</span> athletes remaining and <span class="math inline">\(i\)</span> of them, and <span class="math inline">\(s-f-1\)</span> athletes remaining and <span class="math inline">\(j\)</span> of them, then in the next round, the two best athletes are located at positions <span class="math inline">\(i+1\)</span> and <span class="math inline">\(i+j+2\)</span>, respectively, and the total number of remaining athletes is <span class="math inline">\(\lfloor \dfrac{n+1}{2} \rfloor\)</span>, where <span class="math inline">\(\lfloor x \rfloor\)</span> denotes the floor function of <span class="math inline">\(x\)</span>. Therefore, we can obtain the state transition equation:</p>
<p><span class="math display">\[F(n, f, s) = \left( \min_{i\in [0,f-1], j \in [0, s-f-1]} F(\lfloor \frac{n+1}{2} \rfloor, i + 1, i + j + 2) \right) + 1
\]</span></p>
<p><img src="https://assets.leetcode.com/users/images/a12e8679-7c89-4fee-94c4-f5d6634a11da_1751855272.3308604.png" alt="fig2" /></p>
<p>If <span class="math inline">\(s\)</span> is in the middle, as shown in the figure above, the state transition equation is the same as in the case where <span class="math inline">\(s\)</span> is on the left.</p>
<p>If <span class="math inline">\(s\)</span> is on the right, the situation will be more complicated, and there will be three cases:</p>
<ul>
<li>
<p>In the simplest case, <span class="math inline">\(f\)</span> and <span class="math inline">\(s\)</span> just match each other, that is, <span class="math inline">\(f+s=n+1\)</span>, then <span class="math inline">\(F(n, f, s)=1\)</span>.</p>
</li>
<li>
<p>In addition, if the one-on-one competition in this round is between <span class="math inline">\(s\)</span> and <span class="math inline">\(s'=n+1-s\)</span>, then <span class="math inline">\(f < s'\)</span> is one case, and <span class="math inline">\(f > s'\)</span> is another case.</p>
</li>
</ul>
<p><img src="https://assets.leetcode.com/users/images/0a0b1d94-1be0-4f45-b118-f05bb85413bb_1751855288.4432793.png" alt="fig3" /></p>
<p>However, we can know that according to the analysis similar to the previous section &quot;Essentially Different Positioning Situations,&quot; we change <span class="math inline">\(f\)</span> to <span class="math inline">\(n+1-s\)</span>, and <span class="math inline">\(s\)</span> to <span class="math inline">\(n+1-f\)</span>. In this way, <span class="math inline">\(f\)</span> is still less than <span class="math inline">\(s\)</span>, and <span class="math inline">\(f\)</span> is also less than <span class="math inline">\(s'\)</span> now. Therefore, we only need to consider the case where <span class="math inline">\(f < s'\)</span>, as shown in the figure above:</p>
<ul>
<li>
<p><span class="math inline">\(f\)</span> has <span class="math inline">\(f-1\)</span> athletes on the left, who will compete with the corresponding athletes on the right, leaving <span class="math inline">\([0, f-1]\)</span> athletes.</p>
</li>
<li>
<p><span class="math inline">\(f\)</span> and <span class="math inline">\(s'\)</span> have <span class="math inline">\(s'-f-1\)</span> athletes in between, who will compete with the corresponding athletes on the right, leaving <span class="math inline">\([0, s'-f-1]\)</span> athletes remaining.</p>
</li>
<li>
<p><span class="math inline">\(s'\)</span> will definitely lose to <span class="math inline">\(s\)</span>.</p>
</li>
<li>
<p>There are <span class="math inline">\(n - 2s'\)</span> athletes between <span class="math inline">\(s'\)</span> and <span class="math inline">\(s\)</span>. If <span class="math inline">\(n - 2s'\)</span> is even, they compete in pairs, leaving <span class="math inline">\(\dfrac{n - 2s'}{2}\)</span> athletes; if <span class="math inline">\(n - 2s'\)</span> is odd, one person is eliminated by default, and the remaining athletes compete in pairs, leaving <span class="math inline">\(\dfrac{n - 2s' + 1}{2}\)</span> athletes. Therefore, regardless of whether <span class="math inline">\(n - 2s'\)</span> is odd or even, there will always be <span class="math inline">\(\lfloor \dfrac{n - 2s' + 1}{2} \rfloor\)</span> athletes between <span class="math inline">\(s'\)</span> and <span class="math inline">\(s\)</span>.</p>
</li>
</ul>
<p>If there are <span class="math inline">\(f-1\)</span> athletes and we keep <span class="math inline">\(i\)</span> of them, and <span class="math inline">\(s'-f-1\)</span> athletes and we keep <span class="math inline">\(j\)</span> of them, then in the next round, the two best athletes are respectively located at positions <span class="math inline">\(i+1\)</span> and <span class="math inline">\(i+j+\lfloor \dfrac{n-2s'+1}{2} \rfloor+2\)</span>. Therefore, we can obtain the state transition equation:</p>
<p><span class="math display">\[F(n, f, s) = \left( \min_{i\in [0,f-1], j \in [0, s'-f-1]} F(\lfloor \frac{n+1}{2} \rfloor, i + 1, i+j+\lfloor \dfrac{n-2s'+1}{2} \rfloor+2) \right) + 1
\]</span></p>
<p>So we have obtained all the state transition equations for <span class="math inline">\(F\)</span>. For <span class="math inline">\(G\)</span>, we just need to change all the <span class="math inline">\(\min\)</span> to <span class="math inline">\(\max\)</span>.</p>
<p><strong>Details</strong></p>
<p>In the section on &quot;Essentially Different Positioning Situations,&quot; we mentioned two transformation rules. So, when exactly should we apply each transformation rule, based on the actual values of <span class="math inline">\(n\)</span>, <span class="math inline">\(f\)</span>, and <span class="math inline">\(s\)</span> (rather than the abstract labels &quot;left,&quot; &quot;middle,&quot; or &quot;right&quot;)?</p>
<p>There are many design methods here, and we introduce a relatively simple one, the method used in the solution code:</p>
<ul>
<li>
<p>Firstly, we use top-down memoization search instead of dynamic programming for state transition, which makes the code more concise and intuitive, and does not require consideration of the order of state evaluation.</p>
</li>
<li>
<p>The entry of the memoized search is <span class="math inline">\(F(n, \textit{firstPlayer}, \textit{secondPlayer})\)</span>. Before starting the memoized search, we first transform it using the transformation rule <span class="math inline">\(F(n, f, s) = F(n, s, f)\)</span> to ensure that <span class="math inline">\(\textit{firstPlayer}\)</span> is always less than <span class="math inline">\(\textit{secondPlayer}\)</span>. In this way, since the other transformation rule <span class="math inline">\(F(n, f, s) = F(n, n+1-s, n+1-f)\)</span> does not change the size relationship between <span class="math inline">\(f\)</span> and <span class="math inline">\(s\)</span>, in the subsequent memoized search, <span class="math inline">\(f < s\)</span> is always true, and we do not need to use the transformation rule <span class="math inline">\(F(n, f, s) = F(n, s, f)\)</span> anymore.</p>
</li>
<li>
<p>In the previous table, there are <span class="math inline">\(5\)</span> cases that we need to transform, which are: &quot;f is in the middle, s is on the left&quot;, &quot;f is in the middle, s is on the right&quot;, &quot;f is on the right, s is on the left&quot;, &quot;f is on the right, s is in the middle&quot;, and &quot;f is on the right, s is on the right&quot;. Since we have already ensured that <span class="math inline">\(f < s\)</span> always holds, there are only <span class="math inline">\(2\)</span> cases left to handle, namely: &quot;f is in the middle, s is on the right&quot; and &quot;f is on the right, s is on the right&quot;. In addition, in the section &quot;Design of State Transition Equations&quot;, we also found another case that needs to be handled, that is, &quot;f is on the left, s is on the right, and <span class="math inline">\(f > s' = n + 1 - s\)</span>&quot;.</p>
</li>
</ul>
<p>So, can these three cases be unified? For the last case, we have <span class="math inline">\(f+s > n+1\)</span>, and both &quot;f in the middle, s on the right&quot; and &quot;f on the right, s on the right&quot; also satisfy <span class="math inline">\(f+s > n+1\)</span>, and all cases that do not require transformation do not satisfy <span class="math inline">\(f+s > n+1\)</span>. Therefore, we only need to use the transformation rule <span class="math inline">\(F(n, f, s) = F(n, n+1-s, n+1-f)\)</span> once when <span class="math inline">\(f+s > n+1\)</span>.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/abtQw2aU/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^4 \log n)\)</span>.</p>
<p>In the state <span class="math inline">\(F(n, f, s)\)</span> (the same for <span class="math inline">\(G(n, f, s)\)</span>), the range of each dimension is <span class="math inline">\(O(n)\)</span>, and each state requires <span class="math inline">\(O(n^2)\)</span> time to enumerate all possible states that can be transferred to, thus the overall time complexity of the algorithm is <span class="math inline">\(O(n^5)\)</span>.</p>
<p>However, we can find that the number of values taken by <span class="math inline">\(n\)</span> in <span class="math inline">\(F(n, f, s)\)</span> is finite. During the process of memoization search, <span class="math inline">\(n\)</span> will become <span class="math inline">\(\lfloor \dfrac{n+1}{2} \rfloor\)</span> and continue to recurse downward, so the number of values taken by <span class="math inline">\(n\)</span> is only <span class="math inline">\(O(\log n)\)</span>, that is, the total time complexity is <span class="math inline">\(O(n^4 \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 \log n)\)</span> or <span class="math inline">\(O(n^3)\)</span>.</p>
<p>The space required for storing all states. In C++ code, we use an array to store all states, even though the number of possible values for <span class="math inline">\(n\)</span> is only <span class="math inline">\(O(\log n)\)</span>, we still need to allocate <span class="math inline">\(O(n)\)</span> space for the first dimension. In the Python code, the @cache uses a tuple as the key of a dictionary to store the values of all states, and the number of states is <span class="math inline">\(O(n^2 \log n)\)</span>, so the space used is also <span class="math inline">\(O(n^2 \log n)\)</span>.</p>
<p>In addition, since the LeetCode platform calculates the running time by summing the running times of all test data, all test data will be tested in one run. <strong>In this problem, the memoized storage results can be shared between different test cases</strong>. Therefore, the command to clear the memoized results in the code (such as <span class="math inline">\(\texttt{memset}\)</span> in <span class="math inline">\(\texttt{C++}\)</span> or <span class="math inline">\(\texttt{cache\_clear}\)</span> in <span class="math inline">\(\texttt{Python}\)</span>) can be omitted.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-score-of-students-solving-math-expression/description" target="_blank" rel="noopener noreferrer">The Score of Students Solving Math Expression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> that contains digits <code>0-9</code>, addition symbols <code>&#39;+&#39;</code>, and multiplication symbols <code>&#39;*&#39;</code> <strong>only</strong>, representing a <strong>valid</strong> math expression of <strong>single digit numbers</strong> (e.g., <code>3+5*2</code>). This expression was given to <code>n</code> elementary school students. The students were instructed to get the answer of the expression by following this <strong>order of operations</strong>:</p>

<ol>
	<li>Compute <strong>multiplication</strong>, reading from <strong>left to right</strong>; Then,</li>
	<li>Compute <strong>addition</strong>, reading from <strong>left to right</strong>.</li>
</ol>

<p>You are given an integer array <code>answers</code> of length <code>n</code>, which are the submitted answers of the students in no particular order. You are asked to grade the <code>answers</code>, by following these <strong>rules</strong>:</p>

<ul>
	<li>If an answer <strong>equals</strong> the correct answer of the expression, this student will be rewarded <code>5</code> points;</li>
	<li>Otherwise, if the answer <strong>could be interpreted</strong> as if the student applied the operators <strong>in the wrong order</strong> but had <strong>correct arithmetic</strong>, this student will be rewarded <code>2</code> points;</li>
	<li>Otherwise, this student will be rewarded <code>0</code> points.</li>
</ul>

<p>Return <em>the sum of the points of the students</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png" style="width: 678px; height: 109px;" />
<pre>
<strong>Input:</strong> s = &quot;7+3*1*2&quot;, answers = [20,13,42]
<strong>Output:</strong> 7
<strong>Explanation:</strong> As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,<u><strong>13</strong></u>,42]
A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [<u><strong>20</strong></u>,13,42]
The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;3+5*2&quot;, answers = [13,0,10,13,13,16,16]
<strong>Output:</strong> 19
<strong>Explanation:</strong> The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [<strong><u>13</u></strong>,0,10,<strong><u>13</u></strong>,<strong><u>13</u></strong>,16,16]
A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,<strong><u>16</u></strong>,<strong><u>16</u></strong>]
The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;6+0*1&quot;, answers = [12,9,6,4,8,6]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The correct answer of the expression is 6.
If a student had incorrectly done (6+0)*1, the answer would also be 6.
By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.
The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= s.length &lt;= 31</code></li>
	<li><code>s</code> represents a valid expression that contains only digits <code>0-9</code>, <code>&#39;+&#39;</code>, and <code>&#39;*&#39;</code> only.</li>
	<li>All the integer operands in the expression are in the <strong>inclusive</strong> range <code>[0, 9]</code>.</li>
	<li><code>1 &lt;=</code> The count of all operators (<code>&#39;+&#39;</code> and <code>&#39;*&#39;</code>) in the math expression <code>&lt;= 15</code></li>
	<li>Test data are generated such that the correct answer of the expression is in the range of <code>[0, 1000]</code>.</li>
	<li>Test data are generated such that value never exceeds 10<sup>9</sup> in intermediate steps of multiplication.</li>
	<li><code>n == answers.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-break/description" target="_blank" rel="noopener noreferrer">Word Break</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>

<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 300</code></li>
	<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
	<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
	<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
	<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h3>
<p><strong>Intuition</strong></p>
<p>Let's imagine the indices of <code>s</code> as a graph. Each index can be thought of as a node, which represents building <code>s</code> up to the index.</p>
<p>Adding a word to an existing string is like an edge between nodes. For a node <code>start</code>, we can move to node <code>end</code> if the substring of <code>s</code> between <code>start, end</code> exists in <code>wordDict</code>.</p>
<p>For example, let's say we have <code>s = &quot;leetcode&quot;</code> and <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code>. We are currently at node <code>4</code>, which implies that we have built <code>&quot;leet&quot;</code> (the first 4 characters of <code>s</code>). We can move to node <code>8</code>, because the substring of <code>s</code> with indices <code>[4, 8)</code> is <code>&quot;code&quot;</code>, which is in <code>wordDict</code>.</p>
<p>We start at node <code>0</code>, which represents the empty string. We want to reach node <code>s.length</code>, which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not familiar with BFS, check out the relevant <a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/">Explore Card</a>.</p>
<p>At each node <code>start</code>, we iterate over all the nodes <code>end</code> that come after <code>start</code>. For each <code>end</code>, we check if the substring between <code>start, end</code> is in <code>wordDict</code>. If it is, we can add <code>end</code> to the queue.</p>
<p>We will first convert <code>wordDict</code> into a set so that we can perform the checks in constant time. We will also use a data structure <code>seen</code> to prevent us from visiting a node more than once.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Convert <code>wordDict</code> into a set <code>words</code>.</li>
<li>Initialize a <code>queue</code> with <code>0</code> and a set <code>seen</code>.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Remove the first element, <code>start</code>.</li>
<li>If <code>start == s.length</code>, return <code>true</code>.</li>
<li>Iterate <code>end</code> from <code>start + 1</code> up to and including <code>s.length</code>. For each <code>end</code>, if <code>end</code> has not been visited yet,
<ul>
<li>Check the substring starting at <code>start</code> and ending before <code>end</code>. If it is in <code>words</code>, add <code>end</code> to the queue and mark it in <code>seen</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>false</code> if the BFS finishes without reaching the final node.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/evkSf6sx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>, <span class="math inline">\(m\)</span> as the length of <code>wordDict</code>, and <span class="math inline">\(k\)</span> as the average length of the words in <code>wordDict</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3 + m \cdot k)\)</span></p>
<p>There are <span class="math inline">\(O(n)\)</span> nodes. Because of <code>seen</code>, we never visit a node more than once. At each node, we iterate over the nodes in front of the current node, of which there are <span class="math inline">\(O(n)\)</span>. For each node <code>end</code>, we create a substring, which also costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, handling a node costs <span class="math inline">\(O(n^2)\)</span>, so the BFS could cost up to <span class="math inline">\(O(n^3)\)</span>. Finally, we also spent <span class="math inline">\(O(m \cdot k)\)</span> to create the set <code>words</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m \cdot k)\)</span></p>
<p>We use <span class="math inline">\(O(n)\)</span> space for <code>queue</code> and <code>seen</code>. We use <span class="math inline">\(O(m \cdot k)\)</span> space for the set <code>words</code>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-top-down-dynamic-programming">Approach 2: Top-Down Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you're not familiar with dynamic programming, we recommend checking out the <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming explore card</a>. This problem is on the difficult side, so we will assume that readers are already familiar with the principles of DP.</p>
</blockquote>
<p>Let's have a function <code>dp</code> that returns a boolean indicating if it is possible to build <code>s</code> up to and including the index <code>i</code>.</p>
<p>For example, given <code>s = &quot;leetcode&quot;</code> and <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code>, <code>dp(3)</code> would return <code>true</code>. <code>s</code> up to index <code>3</code> is <code>&quot;leet&quot;</code>, and we can build <code>&quot;leet&quot;</code> using the words in <code>wordDict</code>. The answer to the problem would be <code>dp(s.length - 1)</code>, which represents if we can build <code>s</code>.</p>
<p>The base case of this function is when <code>i &lt; 0</code>. This would represent an empty string, and we can always build an empty string by doing nothing. Therefore, <code>dp(i) = true</code> for <code>i &lt; 0</code>.</p>
<p>Given an index <code>i</code>, we need a recurrence relation to determine if <code>dp(i)</code> is <code>true</code> or <code>false</code>. For <code>dp(i)</code> to be <code>true</code>, there are two requirements:</p>
<ol>
<li>First, there needs to be a <code>word</code> from <code>wordDict</code> that <strong>ends</strong> at index <code>i</code>. Given a <code>word</code>, the substring of <code>s</code> from indices <code>i - word.length + 1</code> up to and including <code>i</code> should match <code>word</code>. We can check every <code>word</code> for this.</li>
<li>If we manage to find a <code>word</code> that <strong>ends</strong> at index <code>i</code>, we would need to add it on top of another string (since we are building <code>s</code> by joining words together one by one). We need to make sure that the string we are adding onto is also buildable. If we find a <code>word</code> that passes the first check, it means <code>word</code> would start at index <code>i - word.length + 1</code>. The index before that is <code>i - word.length</code>. To check if the string ending at that index is buildable, we can refer to <code>dp(i - word.length)</code>.</li>
</ol>
<p>This gives us our recurrence relation:</p>
<p><span class="math display">\[
That is, there exists any `word` that satisfies both of the listed conditions.

We can implement a recursive function `dp(i)` that implements the base cases and recurrence. We need to use memoization to avoid repeated computation.

!?!../Documents/139.json:960,540!?!

**Algorithm**

1. Declare a data structure `memo` that stores the values of `dp` for each index.
2. Create a function `dp(i)`:
    - If `i < 0`, return `true`.
    - If we already calculated `i`, return the value stored in `memo`.
    - Iterate over `wordDict`. For each `word`:
        - Check the substring of `s` ending at `i` with the same length as `word`. If the substring matches, and `dp(i - word.length)` is `true`, return `true`.
    - If no `word` satisfying the criteria was found, return `false`.
3. Return `dp(s.length - 1)`.

**Implementation**

> In Python, the <a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener noreferrer">functools</a> module provides super handy tools that automatically memoize a function for us. We're going to use the `@cache` decorator in the Python implementation.
>
> In Java and C++, we will use an array `memo` to save values. `memo[i] = -1` if we haven't calculated yet, `memo[i] = 0` if `dp(i) = false`, and `memo[i] = 1` if `dp(i) = true`.

[code](https://leetcode.com/playground/4pvUY8Eg/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n \cdot m \cdot k)$$

    There are $$n$$ states of `dp(i)`. Because of memoization, we only calculate each state once. To calculate a state, we iterate over $$m$$ words, and for each word perform some substring operations which costs $$O(k)$$. Therefore, calculating a state costs $$O(m \cdot k)$$, and we need to calculate $$O(n)$$ states. 

* Space complexity: $$O(n)$$

    The data structure we use for memoization and the recursion call stack can use up to $$O(n)$$ space.
    
<br/>

---

### Approach 3: Bottom-Up Dynamic Programming

**Intuition**

The same algorithm can be implemented iteratively. Instead of using a function `dp(i)`, we will use an array `dp` where `dp[i]` represents the same thing that `dp(i)` did. We can use the same recurrence relation:

$$\large{\text{dp[i]} = \text{any}(\text{s}[\text{i - word.length + 1, i}] == \text{word \&\& dp[i - \text{word.length}]})}$$

In top-down, we started at the top (`s.length - 1`) and work our way down to the base cases. In bottom-up, we start at the bottom `(i = 0)` and work our way up to the top.

Before we check `dp[i - word.length]`, we should check if `i == word.length - 1`. This would mean that the current `word` we are placing to end at index `i` is the first word. `i - word.length` would be negative, so we need to separately check this case.

**Algorithm**

1. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.
2. Iterate `i` over the indices of `s`. At each `i`:
    - Iterate over each `word` in `wordDict`:
        - Check if `i == word.length - 1` or `dp[i - word.length] = true`.
        - If so, and the substring of `s` ending at `i` with the same length as `word` matches, set `dp[i] = true` and `break`.
3. Return `dp[s.length - 1]`.

**Implementation**

[code](https://leetcode.com/playground/EWiwhkJC/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n \cdot m \cdot k)$$

    The logic behind the time complexity is identical to the previous approach. It costs us $$O(m \cdot k)$$ to calculate each state, and we calculate $$O(n)$$ states in total. 

* Space complexity: $$O(n)$$

    We use an array `dp` of length $$n$$.
    
<br/>

---

### Approach 4: Trie Optimization 

**Intuition**

In the previous approach, we iterated over each state `i` and then calculated `dp[i]`. To calculate a given `dp[i]`, we did the following:

- Iterate over every `word` in `wordDict`
- Check if each `word` ended at the current index

This cost us $$O(m \cdot k)$$. In the problem constraints, we can see that the maximum value of $$m \cdot k$$ is `20,000`, so this is expensive. We can optimize the time it takes to calculate a given `dp[i]` by using a trie.

A trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we highly recommend you read the official solution to [this problem](https://leetcode.com/problems/implement-trie-prefix-tree/solution) before proceeding with this approach.

To summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from the root to any node represents the string that is built by the nodes on the path. The root represents the empty string.

<img src="../Figures/139/4.png" width="960"> <br>

We can start by building a trie from the words in `wordDict`. Each trie node will have an additional attribute `isWord` which indicates if the current node represents a word from `wordDict`. Then, we will calculate the same `dp` array as in the previous approach. We will calculate each state as follows:

- First, check if `i == 0` (placing first word) or `dp[i - 1]` (we could build the string up to this point). If neither are true, move on to the next state `i + 1`.
- Otherwise, we see if `dp[i]` can be `true`. Initialize a node `curr` at the `root` of the trie.
- Start iterating with a variable `j` from index `i`. For each character `s[j]`, check if we can traverse the trie.
- If we can't traverse the trie, it means no words exist starting at index `i` and ending at index `j` or beyond. We can break from the loop and move on to the next state `i + 1`.
- If we can traverse the trie, we move to the child node. We check the child's `isWord` attribute. If it is `true`, it means there is a word in `wordDict` starting at index `i` and ending at index `j`. We set `dp[j] = true`.
- We continue traversing the trie until we reach a dead end or `j` reaches the end of the string.

This allows us to handle each state in $$O(n)$$ instead of $$O(m \cdot k)$$, which is a big improvement since $$n \leq 300$$.

**Algorithm**

1. Build a trie from `wordDict`. Each node should also have an `isWord` attribute. Store the root of the trie in `root`.
2. Initialize an array `dp` with the same length as `s` and all values initially set to `false`.
3. Iterate `i` over the indices of `s`. At each `i`:
    - Check if `i == 0` or `dp[i - 1] = true`. If not, continue to the next `i`.
    - Set `curr = root`. Iterate `j` over the indices of `s`, starting from `i`. At each `j`,
        - Get the character at index `j` as `c = s[j]`.
        - If `c` is not in the children of `curr`, we can `break` from the loop.
        - Otherwise, move `curr` to the child labeled `c`.
        - If `curr.isWord`, set `dp[j] = true`.
4. Return `dp[s.length - 1]`.

**Implementation**

[code](https://leetcode.com/playground/FhHxmwHE/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n^2 + m \cdot k)$$

    Building the trie involves iterating over all characters of all words. This costs $$O(m \cdot k)$$.

    Once we build the trie, we calculate `dp`. For each `i`, we iterate over all the indices after `i`. We have a basic nested for loop which costs $$O(n^2)$$ to handle all `dp[i]`.

* Space complexity: $$O(n + m \cdot k)$$

    The `dp` array takes $$O(n)$$ space. The trie can have up to $$m \cdot k$$ nodes in it.
    
<br/>

---

### Approach 5: A Different DP

**Intuition**

> In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is the one covered in the video.

Here, we let `dp[i]` hold the answer to the question: "is it possible to form `s` up to a length of `i`? To find the answer for each index, instead of iterating over the words in `wordDict` and checking if a `word` ends at the current index `i`, we will instead iterate over **all substrings that end before index `i`**. If we find one of these substrings is in `wordDict` **and** we can form the string prior to the substring, then `dp[i] = true`.

The reason we are checking for **before** index `i` is because we have slightly changed our `dp` definition here. In the previous problem, `i` represented the index of the last character. Here, `i` represents the length, so we are offset by one.

Before starting the DP, we first convert `wordsDict` to a set so that we can perform the checks in $O(1)$. The rest of the algorithm follows similarly to the previous approaches.

**Algorithm**

1. Convert `wordsDict` to a set `words`.
2. Initialize an array `dp` of length `n + 1` with all values set to `false`.
3. Iterate `i` from `1` until and including `n`. Here, `i` represents the length of the string starting from the beginning.
    - Iterate `j` from `0` until `i`. Here, `j` represents the first index of the substring we are checking.
    - If `dp[j]` is true AND the substring `s[j:i]` is in `words`, set `dp[i] = true` and break. Note that `s[j:i]` represents the substring starting at `j` and ending at `i - 1`.
4. Return `dp[n]`.

**Implementation**

[code](https://leetcode.com/playground/eiTDAMA4/shared)

**Complexity Analysis**

Given $$n$$ as the length of `s`, $$m$$ as the length of `wordDict`, and $$k$$ as the average length of the words in `wordDict`,

* Time complexity: $$O(n^3 + m \cdot k)$$

    First, we spend $$O(m \cdot k)$$ to convert `wordDict` into a set. Then we have a nested loop over `n`, which iterates $$O(n^2)$$ times. For each iteration, we have a substring operation which could cost up to $$O(n)$$. Thus this nested loop costs $$O(n^3)$$.

* Space complexity: $$O(n + m \cdot k)$$

    The `dp` array takes $$O(n)$$ space. The set `words` takes up $$O(m \cdot k)$$ space.
    
<br/>

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-break-ii/description" target="_blank" rel="noopener noreferrer">Word Break II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">memoization</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>

<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]
<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]
<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]
<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 20</code></li>
	<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
	<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
	<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
	<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
	<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have a string <code>s</code> and a dictionary of strings <code>wordDict</code>. The task is to add spaces in <code>s</code> to construct valid sentences where each word is present in <code>wordDict</code> and return all possible valid sentences. The same word from the dictionary can be reused multiple times.</p>
<p>This problem is an extension of <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a>, where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with <a href="https://leetcode.com/problems/word-break/description/">Problem 139. Word Break I</a> as well as <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Problem 208. Implement Trie Prefix Tree</a>, as those questions provide the foundational concepts and intuition necessary for solving this problem.</p>
<p>Here, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms.</p>
<p>To gain an understanding of their underlying mechanisms, we suggest you check out these explore cards:</p>
<ol>
<li><a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/">Backtracking Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/dynamic-programming/">Dynamic Programming Explore Card</a>.</li>
<li><a href="https://leetcode.com/explore/learn/card/trie/">Trie Explore Card</a>.</li>
</ol>
<hr />
<h3 id="approach-1-backtracking">Approach 1: Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>Initially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string.</p>
<p>At each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one.</p>
<p>If we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index.</p>
<p>The backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions.</p>
<p>The process is visualized below:</p>
<p><img src="../Figures/140/backtrack.png" alt="backtrack" /></p>
<h4 id="algorithm">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty array <code>results</code> to store valid sentences.</li>
<li>Initialize an empty string <code>currentSentence</code> to keep track of the sentence being constructed.</li>
<li>Call the <code>backtrack</code> function with the input string <code>s</code>, <code>wordSet</code>, <code>currentSentence</code>, <code>results</code>, and a starting index set to 0, the beginning of the input string.</li>
<li>Return <code>results</code>.</li>
</ul>
<p><strong><code>backtrack</code> Function:</strong></p>
<ul>
<li>Base Case: If the <code>startIndex</code> is equal to the length of the string, add the <code>currentSentence</code> to <code>results</code> and return as it means that <code>currentSentence</code> represents a valid sentence.</li>
<li>Iterate over possible <code>endIndex</code> values from <code>startIndex + 1</code> to the end of the string.
<ul>
<li>Extract the substring <code>word</code> from <code>startIndex</code> to <code>endIndex - 1</code>.</li>
<li>If <code>word</code> is found in <code>wordSet</code>:
<ul>
<li>Store the current <code>currentSentence</code> in <code>originalSentence</code>.</li>
<li>Append <code>word</code> to <code>currentSentence</code> (with a space if needed).</li>
<li>Recursively call <code>backtrack</code> with the updated <code>currentSentence</code> and <code>endIndex</code>.</li>
<li>Reset <code>currentSentence</code> to its original value (<code>originalSentence</code>) to backtrack and try the next <code>endIndex</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return from the <code>backtrack</code> function.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/izdRa3p9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has <span class="math inline">\(2^n\)</span> leaf nodes, resulting in an exponential time complexity. For each leaf node, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>Since each position in the string can be a split point or not, and for <span class="math inline">\(n\)</span> positions, there are <span class="math inline">\(2^n\)</span> possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming---memoization">Approach 2: Dynamic Programming - Memoization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.</p>
<p>We use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a dictionary or hash table).</p>
<p>If the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.</p>
<p>By memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong><code>wordBreak</code> Function:</strong></p>
<ul>
<li>Convert the <code>wordDict</code> array into an unordered set <code>wordSet</code> for efficient lookups.</li>
<li>Initialize an empty unordered map <code>memoization</code> to store the results of subproblems.</li>
<li>Call the <code>dfs</code> function with the input string <code>s</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
</ul>
<p><strong><code>dfs</code> Function:</strong></p>
<ul>
<li>Check if the answer for the current <code>remainingStr</code>(the remaining part of the string to be processed) are already in <code>memoization</code>. If so, return them.</li>
<li>Base Case: If <code>remainingStr</code> is empty, it means that all characters have been processed. An empty string represents a valid sentence so return an array containing the empty string.</li>
<li>Initialize an empty array <code>results</code>.</li>
<li>Iterate from 1 to the length of <code>remainingStr</code>:
<ul>
<li>Extract the substring <code>currentWord</code> from 0 to <code>i</code> to check if it is a valid word.</li>
<li>If <code>currentWord</code> is found in <code>wordSet</code>:
<ul>
<li>Recursively call <code>dfs</code> with <code>remainingStr.substr(i)</code>, <code>wordSet</code>, and <code>memoization</code>.</li>
<li>Append <code>currentWord</code> and the recursive results to <code>results</code>(with a space if needed) to form valid sentences.</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>results</code> for <code>remainingStr</code> in <code>memoization</code>.</li>
<li>Return <code>results</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ri3aMwXd/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still unique <span class="math inline">\(2^n\)</span> possible substrings that need to be explored, leading to an exponential time complexity. For each subproblem, <span class="math inline">\(O(n)\)</span> work is performed, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The recursion stack can grow up to a depth of <span class="math inline">\(n\)</span>, where each recursive call consumes additional space for storing the current state.</p>
<p>The memoization map needs to store the results for all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> substrings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming---tabulation">Approach 3: Dynamic Programming - Tabulation</h3>
<h4 id="intuition-2">Intuition</h4>
<p>While memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table (or map) of valid sentences for each starting index in the string.</p>
<p>The tabulation approach is often more efficient than backtracking and memoization in terms of time and space complexity because it avoids the overhead of recursive calls and stack usage. It also eliminates the need for a separate memoization map, as the table itself serves as the storage for the subproblem solutions.</p>
<p>The tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning. At each step, we construct all possible sentences that can be formed starting from the current index by checking if substrings form valid words in the dictionary.</p>
<p>If a valid word is found, we combine it with the valid sentences formed from the remaining substring. This process continues until we reach the beginning of the string, building up the table of valid sentences for each starting index.</p>
<p>The key idea behind tabulation is that we ensure all subproblems are solved before they are needed, enabling the construction of complete solutions in an organized manner. By iterating from the end to the beginning of the string, we guarantee that the necessary subproblems have already been solved when we need them.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize an empty unordered map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string to the beginning (<code>startIdx</code> from <code>s.size()</code> to 0):
<ul>
<li>Initialize an empty array <code>validSentences</code> to store all valid sentences starting from that index.</li>
<li>Iterate from <code>startIdx</code> to the end of the string (<code>endIdx</code>):
<ul>
<li>Extract the substring <code>currentWord</code> from <code>startIdx</code> to <code>endIdx</code>.</li>
<li>If <code>currentWord</code> is a valid word in <code>wordDict</code>:
<ul>
<li>If <code>endIdx</code> is the last index, add <code>currentWord</code> to <code>validSentences</code>.</li>
<li>Else, append <code>currentWord</code> to each sentence formed by the remaining substring (<code>sentencesFromNextIndex</code>) from <code>dp[endIdx + 1]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>validSentences</code> in <code>dp[startIdx]</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code> (valid sentences formed from the entire string).</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/140/tabulation.json:976,631!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/gWJckozB/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Similar to memoization, the tabulation approach still needs to explore all possible substrings, which can be up to <span class="math inline">\(2^n\)</span> in the worst case, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed to explore each substring, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The dynamic programming table or map needs to store the valid sentences for all possible starting indices, which can be up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span> in the worst case, resulting in an exponential space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-trie-optimization">Approach 4: Trie Optimization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>While the previous approaches focus on optimizing the search and computation process, we can also consider leveraging efficient data structures to enhance the word lookup process. This leads us to the trie-based approach, which uses a trie data structure to store the word dictionary, allowing efficient word lookup and prefix matching.</p>
<blockquote>
<p>The trie, also known as a prefix tree, is a tree-based data structure where each node represents a character in a word, and the path from the root to a leaf node represents a complete word. This structure is particularly useful for problems involving word segmentation because it allows for efficient prefix matching.</p>
</blockquote>
<p>Here, we first build a trie from the dictionary words. Each word is represented as a path in the trie, where each node corresponds to a character in the word.</p>
<p>By using the trie, we can quickly determine whether a substring can form a valid word without having to perform linear searches or set lookups. This reduces the search space and improves the efficiency of the algorithm.</p>
<p>In this approach, instead of recursively exploring the remaining substring and using memoization, we iterate from the end of the input string to the beginning (in reverse order). For each starting index (<code>startIdx</code>), we attempt to find valid sentences that can be formed from that index by iterating through the string and checking if the current substring forms a valid word using the trie data structure.<br />
When a valid word is encountered in the trie, we append it to the list of valid sentences for the current starting index. If the current valid word is not the last word in the sentence, we combine it with the valid sentences formed from the next index (<code>endIdx + 1</code>), which are retrieved from the <code>dp</code> dictionary.</p>
<p>The valid sentences for each starting index are stored in the <code>dp</code> dictionary, ensuring that previously computed results are reused. By using tabulation and storing the valid sentences for each starting index, we avoid redundant computations and achieve significant time and space efficiency improvements compared to the standard backtracking method with memoization.</p>
<p>The trie-based approach offers advantages in terms of efficient word lookup and prefix matching, making it particularly suitable for problems involving word segmentation or string manipulation. However, it comes with the additional overhead of constructing and maintaining the trie data structure, which can be more memory-intensive for large dictionaries.</p>
<h4 id="algorithm-3">Algorithm</h4>
<p><strong>Initialize TrieNode Structure</strong></p>
<ul>
<li>Each TrieNode has two properties:</li>
<li><code>isEnd</code>: A boolean value indicating if the node marks the end of a word.</li>
<li><code>children</code>: An array of size 26 (for lowercase English letters) to store pointers to child nodes.</li>
<li>The constructor initializes <code>isEnd</code> to <code>false</code> and all elements in <code>children</code> to <code>null</code>.</li>
</ul>
<p><strong>Trie Class</strong></p>
<ul>
<li>The Trie class has a <code>root</code> pointer of type <code>TrieNode</code>.</li>
<li>The constructor initializes the <code>root</code> with a new <code>TrieNode</code> object.</li>
<li>The <code>insert</code> function:</li>
<li>Takes a string <code>word</code> as input.</li>
<li>Starts from the <code>root</code> node.</li>
<li>For each character <code>c</code> in the <code>word</code>:
<ul>
<li>Calculate the index corresponding to the character.</li>
<li>If the child node at the calculated index doesn't exist, create a new <code>TrieNode</code> and assign it to that index.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>After processing all characters, mark the current node's <code>isEnd</code> as <code>true</code>.</li>
</ul>
<p><strong>wordBreak Function</strong></p>
<ul>
<li>Create a <code>Trie</code> object.</li>
<li>Insert all words from <code>wordDict</code> into the trie using the <code>insert</code> function.</li>
<li>Initialize a map <code>dp</code> to store the results of subproblems.</li>
<li>Iterate from the end of the string <code>s</code> to the beginning (in reverse order).</li>
<li>For each starting index <code>startIdx</code>:
<ul>
<li>Initialize a vector <code>validSentences</code> to store valid sentences starting from <code>startIdx</code>.</li>
<li>Initialize a <code>current_node</code> pointer to the <code>root</code> of the trie.</li>
<li>Iterate from <code>startIdx</code> to the end of the string.
<ul>
<li>For each character <code>c</code> in the string:
<ul>
<li>Calculate the index corresponding to <code>c</code>.</li>
<li>Check if the child node at the calculated index exists in the trie.</li>
<li>If the child node doesn't exist, break out of the inner loop. This means that the current substring cannot form a valid word, so there is no need to continue checking the remaining characters.</li>
<li>Move to the child node.</li>
</ul>
</li>
<li>Check if the current node's <code>isEnd</code> is <code>true</code>, indicating a valid word.</li>
<li>If a valid word is found:
<ul>
<li>Extract the current word from the string using <code>substr</code>.</li>
<li>If it's the last word in the sentence (<code>endIdx</code> is the last index):
<ul>
<li>Add the current word to <code>validSentences</code>.</li>
</ul>
</li>
<li>If it's not the last word:
<ul>
<li>Retrieve the valid sentences formed by the remaining substring from <code>dp[endIdx + 1]</code>.</li>
<li>Combine the current word with each sentence and add it to <code>validSentences</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Store the <code>validSentences</code> for the current <code>startIdx</code> in <code>dp</code>.</li>
</ul>
</li>
<li>Return the valid sentences stored in <code>dp[0]</code>, which represents the valid sentences formed from the entire string.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/YBoyT88T/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>Even though the trie-based approach uses an efficient data structure for word lookup, it still needs to explore all possible ways to break the string into words. In the worst case, there are <span class="math inline">\(2^n\)</span> unique possible partitions, leading to an exponential time complexity. <span class="math inline">\(O(n)\)</span> work is performed for each partition, so the overall complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot 2^n)\)</span></p>
<p>The trie data structure itself can have a maximum of <span class="math inline">\(2^n\)</span> nodes in the worst case, where each character in the string represents a separate word. Additionally, the tabulation map used in this approach can also store up to <span class="math inline">\(2^n\)</span> strings of size <span class="math inline">\(n\)</span>, resulting in an overall exponential space complexity.</p>
</li>
</ul>
<hr />
<p><strong>Further Thoughts On Complexity Analysis:</strong></p>
<p>The complexity of this problem cannot be reduced from <span class="math inline">\(n \cdot 2^n\)</span>; the worst-case scenario will still be <span class="math inline">\((n \cdot 2^n)\)</span>. However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case.</p>
<p>Consider the input <code>&quot;aaaaaa&quot;</code>, with <code>wordDict = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;, &quot;aaaaa&quot;]</code>.<br />
Every possible partition is a valid sentence, and there are <span class="math inline">\(2^{n-1}\)</span> such partitions. The algorithms cannot perform better than this since they must generate all valid sentences. The cost of iterating over cached results will be exponential, as every possible partition will be cached, resulting in the same runtime as regular backtracking. Likewise, the space complexity will also be <span class="math inline">\(O(n \cdot 2^n)\)</span> for the same reason—every partition is stored in memory.</p>
<p>Another way to explain why the worst-case complexity is <span class="math inline">\(O(n \cdot 2^n)\)</span> for all the algorithms is that, given an array of length <span class="math inline">\(n\)</span>, there are <span class="math inline">\(n+1\)</span> ways/intervals to partition it into two parts. Each interval has two choices: to split or not to split. In the worst case, we will have to check all possibilities, which results in a time complexity of <span class="math inline">\(O(n \cdot 2^{n+1})\)</span>, which simplifies to <span class="math inline">\(O(n \cdot 2^n)\)</span>. This analysis is extremely similar to palindrome partitioning.</p>
<p>Overall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need.</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zuma-game/description" target="_blank" rel="noopener noreferrer">Zuma Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">memoization</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a variation of the game Zuma.</p>

<p>In this variation of Zuma, there is a <strong>single row</strong> of colored balls on a board, where each ball can be colored red <code>&#39;R&#39;</code>, yellow <code>&#39;Y&#39;</code>, blue <code>&#39;B&#39;</code>, green <code>&#39;G&#39;</code>, or white <code>&#39;W&#39;</code>. You also have several colored balls in your hand.</p>

<p>Your goal is to <strong>clear all</strong> of the balls from the board. On each turn:</p>

<ul>
	<li>Pick <strong>any</strong> ball from your hand and insert it in between two balls in the row or on either end of the row.</li>
	<li>If there is a group of <strong>three or more consecutive balls</strong> of the <strong>same color</strong>, remove the group of balls from the board.
	<ul>
		<li>If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.</li>
	</ul>
	</li>
	<li>If there are no more balls on the board, then you win the game.</li>
	<li>Repeat this process until you either win or do not have any more balls in your hand.</li>
</ul>

<p>Given a string <code>board</code>, representing the row of balls on the board, and a string <code>hand</code>, representing the balls in your hand, return <em>the <strong>minimum</strong> number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WRRBBW&quot;, hand = &quot;RB&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to clear all the balls. The best you can do is:
- Insert &#39;R&#39; so the board becomes WRR<u>R</u>BBW. W<u>RRR</u>BBW -&gt; WBBW.
- Insert &#39;B&#39; so the board becomes WBB<u>B</u>W. W<u>BBB</u>W -&gt; WW.
There are still balls remaining on the board, and you are out of balls to insert.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;WWRRBBWW&quot;, hand = &quot;WRBRW&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;R&#39; so the board becomes WWRR<u>R</u>BBWW. WW<u>RRR</u>BBWW -&gt; WWBBWW.
- Insert &#39;B&#39; so the board becomes WWBB<u>B</u>WW. WW<u>BBB</u>WW -&gt; <u>WWWW</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> board = &quot;G&quot;, hand = &quot;GGGGG&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> To make the board empty:
- Insert &#39;G&#39; so the board becomes G<u>G</u>.
- Insert &#39;G&#39; so the board becomes GG<u>G</u>. <u>GGG</u> -&gt; empty.
2 balls from your hand were needed to clear the board.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= board.length &lt;= 16</code></li>
	<li><code>1 &lt;= hand.length &lt;= 5</code></li>
	<li><code>board</code> and <code>hand</code> consist of the characters <code>&#39;R&#39;</code>, <code>&#39;Y&#39;</code>, <code>&#39;B&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;W&#39;</code>.</li>
	<li>The initial row of balls on the board will <strong>not</strong> have any groups of three or more consecutive balls of the same color.</li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>