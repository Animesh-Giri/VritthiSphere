<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>monotonic stack - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>monotonic stack</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">55</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">132 Pattern</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Apply Operations to Maximize Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Beautiful Towers I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Beautiful Towers II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Car Fleet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Car Fleet II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Construct Binary Search Tree from Preorder Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Count Non-Decreasing Subarrays After K Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Count Submatrices With All Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Create Maximum Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Daily Temperatures</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Final Prices With a Special Discount in a Shop</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Find Building Where Alice and Bob Can Meet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Find Maximum Non-decreasing Array Length</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Find the Most Competitive Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Find the Number of Subarrays Where Boundary Elements Are Maximum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Largest Rectangle in Histogram</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Longest Well-Performing Interval</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Make Array Non-decreasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Max Chunks To Make Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Max Chunks To Make Sorted II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Maximal Rectangle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Maximum and Minimum Sums of at Most Size K Subarrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Maximum Balanced Shipments</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Maximum Binary Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Maximum Score of a Good Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Maximum Subarray Min-Product</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Maximum Sum Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Maximum Width Ramp</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Minimum Cost Tree From Leaf Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Minimum Number of Increments on Subarrays to Form a Target Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Minimum Number of Visited Cells in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Minimum Operations to Convert All Elements to Zero</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Minimum Operations to Make Array Equal to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Next Greater Element I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Next Greater Element II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Next Greater Element IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Next Greater Node In Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Number of Visible People in a Queue</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Odd Even Jump</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Online Stock Span</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Remove Duplicate Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-42" class="toc-link">Remove K Digits</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Remove Nodes From Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Shortest Subarray to be Removed to Make Array Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Shortest Unsorted Continuous Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Smallest K-Length Subsequence With Occurrences of a Letter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Smallest Subsequence of Distinct Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Steps to Make Array Non-decreasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Subarray With Elements Greater Than Varying Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Sum of Subarray Minimums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Sum of Subarray Ranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Sum of Total Strength of Wizards</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">The Number of Weak Characters in the Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Trapping Rain Water</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/132-pattern/description" target="_blank" rel="noopener noreferrer">132 Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>

<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no 132 pattern in the sequence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,3,2,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The simplest solution is to consider every triplet <span class="math inline">\((i, j, k)\)</span> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/hGnnTJMn/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Three loops are used to consider every possible triplet. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force">Approach 2: Better Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <span class="math inline">\(nums[j]\)</span> chosen as 2nd element in the 132 pattern, if we don't consider <span class="math inline">\(nums[k]\)</span>(the 3rd element) for the time being, our job is to find out the first element, <span class="math inline">\(nums[i]$$(\)</span>i&lt;j<span class="math inline">\() which is lesser than \)</span>nums[j]$$.</p>
<p>Now, assume that we have somehow found a <span class="math inline">\(nums[i],nums[j]\)</span> pair. Our task now reduces to finding out a <span class="math inline">\(nums[k]$$(\)</span>Kk&gt;j&gt;i)<span class="math inline">\(, which falls in the range \)</span>(nums[i], nums[j])<span class="math inline">\(. Now, to maximize the likelihood of a \)</span>nums[k]$$ falling in this range, we need to increase this range as much as possible.</p>
<p>Since, we started off by fixing a <span class="math inline">\(nums[j]\)</span>, the only option in our hand is to choose a minimum value of <span class="math inline">\(nums[i]\)</span> given a particular <span class="math inline">\(nums[j]\)</span>. Once, this pair <span class="math inline">\(nums[i],nums[j]\)</span>, has been found out, we simply need to traverse beyond the index <span class="math inline">\(j\)</span> to find if a <span class="math inline">\(nums[k]\)</span> exists for this pair satisfying the 132 criteria.</p>
<p>Based on the above observations, while traversing over the <span class="math inline">\(nums\)</span> array choosing various values of <span class="math inline">\(nums[j]\)</span>, we simultaneously keep a track of the minimum element found so far(excluding <span class="math inline">\(nums[j]\)</span>). This minimum element always serves as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. Thus, we only need to traverse beyond the <span class="math inline">\(j^{th}\)</span> index to check the <span class="math inline">\(nums[k]\)</span>'s to determine if any of them satisfies the 132 criteria.</p>
<p><a href="https://leetcode.com/playground/4Mv4ZmY8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Two loops are used to find the <span class="math inline">\(nums[j],nums[k]\)</span> pairs. Here, <span class="math inline">\(n\)</span> refers to the size of <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant extra space is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-3-searching-intervals">Approach 3: Searching Intervals</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed in the last approach, once we've fixed a <span class="math inline">\(nums[i],nums[j]\)</span> pair, we just need to determine a <span class="math inline">\(nums[k]\)</span> which falls in the range <span class="math inline">\((nums[i],nums[j])\)</span>. Further, to maximize the likelihood of any arbitrary <span class="math inline">\(nums[k]\)</span> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <span class="math inline">\(nums[i]\)</span>. But, it'll be a better choice, if we can somehow work out on <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To do so, we can look at the given <span class="math inline">\(nums\)</span> array in the form of a graph, as shown below:</p>
<p><img src="../Figures/456/456_132_Pattern.PNG" alt="Graph" /></p>
<p>From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <span class="math inline">\(nums[i],nums[j]\)</span> pair,  as discussed above, to maximize the range <span class="math inline">\(nums[i], nums[j]\)</span>, at any instant, while traversing the <span class="math inline">\(nums\)</span> array, will be the points at the endpoints of a local rising slope. Thus, once we've found such points, we can traverse over the <span class="math inline">\(nums\)</span> array to find a <span class="math inline">\(nums[k]\)</span> satisfying the given 132 criteria.</p>
<p>To find these points at the ends of a local rising slope, we can traverse over the given <span class="math inline">\(nums\)</span> array. While traversing, we can keep a track of the minimum point found after the last peak(<span class="math inline">\(nums[s]\)</span>).</p>
<p>Now, whenever we encounter a falling slope, say, at index <span class="math inline">\(i\)</span>, we know, that <span class="math inline">\(nums[i-1]\)</span> was the endpoint of the last rising slope found. Thus, we can scan over the <span class="math inline">\(k\)</span> indices(k&gt;i), to find a 132 pattern.</p>
<p>But, instead of traversing over <span class="math inline">\(nums\)</span> to find a <span class="math inline">\(k\)</span> satisfying the 132 pattern for every such rising slope, we can store this range <span class="math inline">\((nums[s], nums[i-1])\)</span>(acting as <span class="math inline">\((nums[i], nums[j])\)</span>) in, say an <span class="math inline">\(intervals\)</span> array.</p>
<p>While traversing over the <span class="math inline">\(nums\)</span> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <span class="math inline">\(intervals\)</span> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range.</p>
<p>If no such element is found till the end, we need to return a False value.</p>
<p><a href="https://leetcode.com/playground/Zy6HRCyV/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. We traverse over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to find the slopes. But for every element, we also need to traverse over the <span class="math inline">\(intervals\)</span> to check if any element falls in any range found so far. This array can contain at most <span class="math inline">\((n/2)\)</span> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.<code>[5 6 4 7 3 8 2 9]</code>).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(intervals\)</span> array can contain at most <span class="math inline">\(n/2\)</span> pairs, in the worst case(alternate increasing-decreasing sequence).<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-4-stack">Approach 4: Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In Approach 2, we found out <span class="math inline">\(nums[i]\)</span> corresponding to a particular <span class="math inline">\(nums[j]\)</span> directly without having to consider every pair possible in <span class="math inline">\(nums\)</span> to find this <span class="math inline">\(nums[i],nums[j]\)</span> pair. If we do some preprocessing, we can make the process of finding a <span class="math inline">\(nums[k]\)</span> corresponding to this <span class="math inline">\(nums[i],nums[j]\)</span> pair also easy.</p>
<p>The preprocessing required is to just find the best <span class="math inline">\(nums[i]\)</span> value corresponding to every <span class="math inline">\(nums[j]\)</span> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <span class="math inline">\(j^{th}\)</span> element which acts as the <span class="math inline">\(nums[i]\)</span> for the current <span class="math inline">\(nums[j]\)</span>. We maintain thes values in a <span class="math inline">\(min\)</span> array. Thus, <span class="math inline">\(min[j]\)</span> now refers to the best <span class="math inline">\(nums[i]\)</span> value for a particular <span class="math inline">\(nums[j]\)</span>.</p>
<p>Now, we traverse back from the end of the <span class="math inline">\(nums\)</span> array to find the <span class="math inline">\(nums[k]\)</span>'s. Suppose, we keep a track of the <span class="math inline">\(nums[k]\)</span> values which can potentially satisfy the 132 criteria for the current <span class="math inline">\(nums[j]\)</span>. We know, one of the conditions to be satisfied by such a <span class="math inline">\(nums[k]\)</span> is that it must be greater than <span class="math inline">\(nums[i]\)</span>. Or in other words, we can also say that it must be greater than <span class="math inline">\(min[j]\)</span> for a particular <span class="math inline">\(nums[j]\)</span> chosen.</p>
<p>Once it is ensured that the elements left for competing for the <span class="math inline">\(nums[k]\)</span> are all greater than <span class="math inline">\(min[j]\)</span>(or <span class="math inline">\(nums[i]\)</span>), our only task is to ensure that it should be lesser than <span class="math inline">\(nums[j]\)</span>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements.</p>
<p>If this element, <span class="math inline">\(nums[k]\)</span> satisfies <span class="math inline">\(nums[k] < nums[j]\)</span>, we've found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <span class="math inline">\(nums[min]\)</span> and thus greater than or equal to <span class="math inline">\(nums[j]\)</span> as well.</p>
<p>To keep a track of these potential <span class="math inline">\(nums[k]\)</span> values for a particular <span class="math inline">\(nums[i],nums[j]\)</span> considered currently, we maintain a <span class="math inline">\(stack\)</span> on which these potential <span class="math inline">\(nums[k]\)</span>'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <span class="math inline">\(stack\)</span>, but they'll be sorted automatically as we'll discuss along with the process.</p>
<p>After creating a <span class="math inline">\(min\)</span> array, we start traversing the <span class="math inline">\(nums[j]\)</span> array in a backward manner. Let's say, we are currently at the <span class="math inline">\(j^{th}\)</span> element and let's also assume that the <span class="math inline">\(stack\)</span> is sorted right now. Now, firstly, we check if <span class="math inline">\(nums[j] > min[j]\)</span>. If not, we continue with the <span class="math inline">\((j-1)^{th}\)</span> element and the <span class="math inline">\(stack\)</span> remains sorted. If not, we keep on popping the elements from the top of the <span class="math inline">\(stack\)</span> till we find an element, <span class="math inline">\(stack[top]\)</span> such that, <span class="math inline">\(stack[top] > min[j]\)</span>(or <span class="math inline">\(stack[top] > nums[i]\)</span>).</p>
<p>Once the popping is done, we're sure that all the elements pending on the <span class="math inline">\(stack\)</span> are greater than <span class="math inline">\(nums[i]\)</span> and are thus, the potential candidates for <span class="math inline">\(nums[k]\)</span> satisfying the 132 criteria. We can also note that the elements which have been popped from the <span class="math inline">\(stack\)</span>, all satisfy <span class="math inline">\(stack[top] &leq; min[j]\)</span>.</p>
<p>Since, in the <span class="math inline">\(min\)</span> array, <span class="math inline">\(min[p] &leq; min[q]\)</span>, for every <span class="math inline">\(p > q\)</span>, these popped elements also satisfy <span class="math inline">\(stack[top] &leq; min[k]\)</span>, for all <span class="math inline">\(0 &leq; k < j\)</span>. Thus, they are not the potential <span class="math inline">\(nums[k]\)</span> candidates for even the preceding elements. Even after  doing the popping, the <span class="math inline">\(stack\)</span> remains sorted.</p>
<p>After the popping is done, we've got the minimum element from amongst all the potential <span class="math inline">\(nums[k]\)</span>'s on the top of the <span class="math inline">\(stack\)</span>(as per the assumption). We can check if it is less than or equal to <span class="math inline">\(nums[j]\)</span> to satisfy the 132 criteria(we've already checked <span class="math inline">\(stack[top] > nums[i]\)</span>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <span class="math inline">\(j\)</span>, <span class="math inline">\(nums[j] > min[j]\)</span>. Thus, the element <span class="math inline">\(nums[j]\)</span> could be a potential <span class="math inline">\(nums[k]\)</span> value, for the preceding <span class="math inline">\(nums[i]'s\)</span>.</p>
<p>Thus, we push it over the <span class="math inline">\(stack\)</span>. We can note that, we need to push this element <span class="math inline">\(nums[j]\)</span> on the <span class="math inline">\(stack\)</span> only when it didn't satisfy <span class="math inline">\(stack[top]<nums[j]\)</span>. Thus, <span class="math inline">\(nums[j] &leq; stack[top]\)</span>. Thus, even after pushing this element on the <span class="math inline">\(stack\)</span>, the <span class="math inline">\(stack\)</span> remains sorted. Thus, we've seen by induction, that the <span class="math inline">\(stack\)</span> always remains sorted.</p>
<p>Also, note that in case <span class="math inline">\(nums[j] &leq; min[j]\)</span>, we don't push <span class="math inline">\(nums[j]\)</span> onto the <span class="math inline">\(stack\)</span>. This is because this <span class="math inline">\(nums[j]\)</span> isn't greater than even the minimum element lying towards its left and thus can't act as <span class="math inline">\(nums[k]\)</span> in the future.</p>
<p>If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p>
<p>The following animation better illustrates the process.</p>
<p>!?!../Documents/456_132_Pattern.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/kueGKV2B/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. During this process, we also push and pop the elements on the <span class="math inline">\(stack\)</span>. But, we can note that at most <span class="math inline">\(n\)</span> elements can be pushed and popped off the <span class="math inline">\(stack\)</span> in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The <span class="math inline">\(stack\)</span> can grow upto a maximum depth of <span class="math inline">\(n\)</span>. Furhter, <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-5-binary-search">Approach 5: Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've made use of a separate <span class="math inline">\(stack\)</span> to push and pop the <span class="math inline">\(nums[k]\)</span>'s. But, we can also note that when we reach the index <span class="math inline">\(j\)</span> while scanning backwards for finding <span class="math inline">\(nums[k]\)</span>, the <span class="math inline">\(stack\)</span> can contain at most <span class="math inline">\(n-j-1\)</span> elements. Here, <span class="math inline">\(n\)</span> refers to the number of elements in <span class="math inline">\(nums\)</span> array.</p>
<p>We can also note that this is the same number of elements which lie beyond the <span class="math inline">\(j^{th}\)</span> index in <span class="math inline">\(nums\)</span> array. We also know that these elements lying beyond the <span class="math inline">\(j^{th}\)</span> index won't be needed in the future ever again. Thus, we can make use of this space in <span class="math inline">\(nums\)</span> array instead of using a separate <span class="math inline">\(stack\)</span>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p>
<p>We can try to go for another optimization here. Since, we've got an array for storing the potential <span class="math inline">\(nums[k]\)</span> values now, we need not do the popping process for a <span class="math inline">\(min[j]\)</span> to find an element just larger than <span class="math inline">\(min[j]\)</span> from amongst these potential values.</p>
<p>Instead, we can make use of Binary Search to directly find an element, which is just larger than <span class="math inline">\(min[j]\)</span> in the required interval, if it exists. If such an element is found, we can compare it with <span class="math inline">\(nums[j]\)</span> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p>
<p><a href="https://leetcode.com/playground/8yeXd5nB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(n \log n\big)\)</span>. Filling <span class="math inline">\(min\)</span> array requires <span class="math inline">\(O(n)\)</span> time. The second traversal is done over the whole <span class="math inline">\(nums\)</span> array of length <span class="math inline">\(n\)</span>. For every current <span class="math inline">\(nums[j]\)</span> we need to do the Binary Search, which requires <span class="math inline">\(O\big(\log n\big)\)</span>. In the worst case, this Binary Search will be done for all the <span class="math inline">\(n\)</span> elements, and the required element won't be found in any case, leading to a complexity of <span class="math inline">\(O\big(n \log n\big)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-6-using-array-as-a-stack">Approach 6: Using Array as a Stack</h3>
<p><strong>Algorithm</strong></p>
<p>In the last approach, we've seen that in the worst case, the required element won't be found for all the <span class="math inline">\(n\)</span> elements and thus Binary Search is done at every step increasing the time complexity.</p>
<p>To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <span class="math inline">\(k\)</span>) which aren't greater than <span class="math inline">\(nums[i]$$(\)</span>min[j]<span class="math inline">\(). Thus, in case no element is larger than \)</span>min[j]<span class="math inline">\( the index $$k\)</span> reaches the last element.</p>
<p>Now, at every step, only <span class="math inline">\(nums[j]\)</span> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p>
<p>This approach is inspired by <a href="https://leetcode.com/fun4leetcode/">@fun4leetcode</a></p>
<p><a href="https://leetcode.com/playground/gN3j3eSo/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. We travesre over the <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> once to fill the <span class="math inline">\(min\)</span> array. After this, we traverse over <span class="math inline">\(nums\)</span> to find the <span class="math inline">\(nums[k]\)</span>. At most <span class="math inline">\(n\)</span> elements can be put in and out of the <span class="math inline">\(nums\)</span> array in total. Thus, the second traversal requires only <span class="math inline">\(O(n)\)</span> time.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(min\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-maximize-score/description" target="_blank" rel="noopener noreferrer">Apply Operations to Maximize Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">number-theory</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of <code>n</code> positive integers and an integer <code>k</code>.</p>

<p>Initially, you start with a score of <code>1</code>. You have to maximize your score by applying the following operation at most <code>k</code> times:</p>

<ul>
	<li>Choose any <strong>non-empty</strong> subarray <code>nums[l, ..., r]</code> that you haven&#39;t chosen previously.</li>
	<li>Choose an element <code>x</code> of <code>nums[l, ..., r]</code> with the highest <strong>prime score</strong>. If multiple such elements exist, choose the one with the smallest index.</li>
	<li>Multiply your score by <code>x</code>.</li>
</ul>

<p>Here, <code>nums[l, ..., r]</code> denotes the subarray of <code>nums</code> starting at index <code>l</code> and ending at the index <code>r</code>, both ends being inclusive.</p>

<p>The <strong>prime score</strong> of an integer <code>x</code> is equal to the number of distinct prime factors of <code>x</code>. For example, the prime score of <code>300</code> is <code>3</code> since <code>300 = 2 * 2 * 3 * 5 * 5</code>.</p>

<p>Return <em>the <strong>maximum possible score</strong> after applying at most </em><code>k</code><em> operations</em>.</p>

<p>Since the answer may be large, return it modulo <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,3,9,3,8], k = 2
<strong>Output:</strong> 81
<strong>Explanation:</strong> To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [19,12,14,6,10,18], k = 3
<strong>Output:</strong> 4788
<strong>Explanation:</strong> To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10<sup>9</sup>)</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array of positive integers <code>nums</code>, a number <code>k</code>, and the ability to perform the following operation at most <code>k</code> times:</p>
<ul>
<li>Select any non-empty subarray that has <strong>not been chosen before</strong>.</li>
<li>Identify the number in this subarray with the highest <em>prime score</em>. The prime score of a number <code>num</code> is defined as the number of distinct prime factors of <code>num</code>. For example, <code>60</code> has a prime score of <code>3</code> because <code>60 = 2 × 2 × 3 × 5</code>, whereas <code>24 = 2 × 2 × 2 × 3</code> has a prime score of <code>2</code>. If the selected subarray contains only <code>60</code> and <code>24</code>, we choose <code>60</code>. If multiple numbers have the same prime score, we select the one that appears first in the subarray.</li>
<li>Multiply the current score by the chosen number. The score starts at <code>1</code>.</li>
</ul>
<p>Our task is to determine the greatest possible score we can achieve by performing the operation at most <code>k</code> times. Since the result may be large, we return it modulo <code>10^9 + 7</code>.</p>
<p>An important observation is that since the array consists of positive integers, multiplying the current score by any of them can only increase or maintain its value. Therefore, it is always optimal to perform all <code>k</code> allowed operations. Notice that the constraint <code>k &lt;= (n + 1) * n / 2</code> ensures that there are always enough unique subarrays to apply the operations on.</p>
<p>Now, consider a variation of the problem where we are not restricted to choosing a previously unselected subarray for each operation. What would be the optimal strategy to maximize our score? Intuitively, we would always select the subarray containing the greatest element, repeating this choice <code>k</code> times. This is valid because, in subarrays of length <code>1</code>, the largest element would have the highest prime score and would always be chosen.</p>
<p>However, in our original problem, we cannot repeatedly select the same subarray. We could start by choosing the subarray containing the maximum element, but what happens next? While there may still be subarrays that include this maximum element, we cannot be certain that it has the highest prime score in each of them.</p>
<hr />
<h3 id="approach-1-monotonic-stack--priority-queue">Approach 1: Monotonic Stack &amp; Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>For convenience, let the element with the highest prime score in a subarray be the &quot;dominant&quot; element of that subarray.</p>
</blockquote>
<p>To address the challenge described above, it is helpful to calculate the number of subarrays each number is dominant in. With this information, we can start with the largest element and apply the operation to all subarrays where it remains dominant. We then repeat this for the second-largest element, and so on, until no further operations can be performed.</p>
<p>First, we need an efficient way to calculate the prime score of a number <code>n</code>. To do this, we iterate over all numbers in the range <code>[2, sqrt(n)]</code>. If we find a number <code>p</code> that divides <code>n</code>, we increment the prime score and remove all occurrences of <code>p</code> in <code>n</code> by repeatedly dividing <code>n</code> by <code>p</code> until it is no longer possible. Notice that we don't need to check if <code>p</code> is prime to increment the prime score because any composite number (e.g., <code>9</code>, <code>15</code>) will have had its smaller prime factors removed earlier and therefore will not divide <code>n</code>. Finally, if <code>n &gt;= 2</code>, <code>n</code> must be prime, so we increment the score once more.</p>
<p>Now, notice that a number remains dominant until another element with a greater prime score appears either to its left or right. To efficiently determine this region, we use a monotonic decreasing stack, which helps identify the nearest elements with a higher prime score on both sides.</p>
<p>To better understand monotonic stacks, you can try solving <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element I</a> first. It’s a great prerequisite for this problem!</p>
<p>A monotonic stack is a data structure that maintains a specific order as elements are inserted. In this case, we need a monotonically decreasing stack based on prime scores, meaning each new element can only be added if it has a lower prime score than the one at the top. If the top element has a greater prime score, we pop it from the stack. When the current element causes another to be popped, it means it is the first element with a higher prime score to the right. Conversely, if we reach an element in the stack with a greater prime score than the current one, that element is the first with a higher prime score to the left.</p>
<p>!?!../Documents/2818/2818_monotonic_decreasing_stack.json:960,540!?!</p>
<p>After finding the indices of the nearest elements with a higher prime score on the left and right, <code>prevDominant[i]</code> and <code>nextDominant[i]</code>, we can compute the number of subarrays in which the <code>i-th</code> element is dominant.</p>
<p>For the left boundary, we have <code>i - prevDominant[i]</code> choices, and for each of them, we have <code>nextDominant[i] - i</code> choices for the right boundary. This gives a total of: <code>(i - prevDominant[i]) * (nextDominant[i] - i)</code> subarrays, where the <code>i-th</code> element is dominant.</p>
<p><img src="../Figures/2818/2818_number_of_subarrays.png" alt="Visual Representation of All Valid Subarrays" /></p>
<p>Finally, we need an efficient way to determine the next element on which we will apply operations across all subarrays where it is dominant. Since we need to process elements in decreasing order to maximize the score, a priority queue (max-heap) is a useful data structure. It allows us to quickly extract the largest element and then remove it to move on to the next one.</p>
<blockquote>
<p>If you need a refresher on heaps, check out the <a href="https://leetcode.com/problem-list/heap-priority-queue/">Heap Explore Card</a> to review their functionality and common patterns.</p>
</blockquote>
<p>To sum up, the algorithm follows these steps:</p>
<ol>
<li>Calculate the prime score for each number in <code>nums</code>.</li>
<li>Use a monotonic stack to determine the <code>prevDominant[i]</code> and <code>nextDominant[i]</code> indices for each <code>nums[i]</code>.</li>
<li>Compute the number of subarrays in which each number is dominant.</li>
<li>Use a priority queue to process the numbers in decreasing order and apply operations to all subarrays where they are dominant.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of the <code>nums</code> array.</li>
<li>an array, called <code>primeScores</code> of size <code>n</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to calculate the prime scores:
<ul>
<li>Set <code>num</code> to <code>nums[index]</code>.</li>
<li>For each <code>factor</code> in range <code>[2, sqrt(num)]</code>:
<ul>
<li>If <code>factor</code> divides <code>num</code>:
<ul>
<li>Increment <code>primeScores[index]</code> by <code>1</code>.</li>
<li>Remove all occurrences of <code>factor</code> in <code>num</code> by repeatedly dividing by <code>factor</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>num &gt;= 2</code>, <code>num</code> is prime, so increment <code>primeScores[index]</code> one more time.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>two arrays <code>nextDominant</code> and <code>prevDominant</code> to store the indices of the nearest elements with a higher prime score on both sides of each number. Set all elements in <code>nextDominant</code> to <code>n</code> and all values of <code>prevDominant</code> to <code>-1</code>.</li>
<li>an empty stack <code>decreasingPrimeScoreStack</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to fill the <code>nextDominant</code> and <code>prevDominant</code> arrays:
<ul>
<li>While the stack is not empty and the element at index <code>decreasingPrimeScoreStack.top()</code> has a lower prime score than <code>nums[index]</code>:
<ul>
<li>Pop the top element of the stack as <code>topIndex</code>.</li>
<li>Set <code>nextDominant[topIndex]</code> to the current <code>index</code>.</li>
</ul>
</li>
<li>If the stack is not empty, set <code>prevDominant[index]</code> to the index at the top of the stack.</li>
<li>Push <code>index</code> into the stack.</li>
</ul>
</li>
<li>Initialize an array of size <code>n</code> called <code>numOfSubarrays</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to count the number of subarrays in which each element is dominant:
<ul>
<li>Calculate <code>numOfSubarrays[index]</code> as <code>(nextDominant[index] - index) * (index - prevDominant[index])</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a priority queue, <code>processingQueue</code> of pairs <code>(value, index)</code> and insert all elements of <code>nums</code> into it.</li>
<li><code>score</code> to <code>1</code>.</li>
</ul>
</li>
<li>While <code>k &gt; 0</code>, meaning that we are still allowed to perform operations:
<ul>
<li>Pop the front element of the queue as <code>[num, index]</code>.</li>
<li>Calculate the number of <code>operations</code> that we will perform on subarrays in which <code>num</code> is dominant, as <code>min(k, subarrays[index])</code>.</li>
<li>Multiply <code>score</code> by <code>num ^ operations</code> using modular exponentiation.</li>
<li>Decrement <code>k</code> by <code>operations</code>.</li>
</ul>
</li>
<li>Return <code>score</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/L5dp8Mfa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array, <span class="math inline">\(k\)</span> the number of operations and <span class="math inline">\(m\)</span> the largest element in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times (\sqrt{m} + \log{n}))\)</span></p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>First, we calculate the prime scores of each number in <code>nums</code>. This is done by iterating over all numbers in the range <span class="math inline">\([2, \sqrt{\text{num}}]\)</span> and removing all occurrences of each factor in <span class="math inline">\(\text{num}\)</span>. In the worst case (when <span class="math inline">\(\text{num}\)</span> is prime), the outer loop runs <span class="math inline">\(\sqrt{\text{num}}\)</span> times, and therefore the time complexity of this step is <span class="math inline">\(O(n \times \sqrt{m})\)</span>.</li>
<li>Next, we fill the <code>nextDominant</code> and <code>prevDominant</code> arrays in <span class="math inline">\(O(n)\)</span> time, since each index is inserted and removed from the stack at most once. The calculation of the number of subarrays where each element is dominant takes an additional <span class="math inline">\(O(n)\)</span> time, since it only involves looping over <code>nums</code> and performing constant-time (arithmetic) operations in each iteration.</li>
<li>Finally, we create a priority queue where each element is inserted and removed at most once. The time complexity of this step is <span class="math inline">\(O(n \log{n})\)</span>, since both insertion and removal from a priority queue take <span class="math inline">\(O(\log{n})\)</span> time. To calculate the result, we use binary exponentiation, which runs in <span class="math inline">\(O(\log{\text{exponent}})\)</span> time. Since the exponent represents the number of operations, the total time complexity of the binary exponentiation steps is <span class="math inline">\(O(\log{k})\)</span>, which is bounded by <span class="math inline">\(O(n \log{n})\)</span>.</li>
</ol>
<p>As a result, the overall time complexity of the algorithm is <span class="math inline">\(O(n \times (\sqrt{m} + \log{n}))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>All data structures we use, including <code>primeScores</code>, <code>nextDominant</code>, and <code>prevDominant</code> arrays, as well as <code>decreasingPrimeScoreStack</code> and <code>processingQueue</code>, grow linearly with the size of the input array. Therefore, the algorithm requires <span class="math inline">\(O(n)\)</span> auxiliary space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sieve-of-eratosthenes--sorting">Approach 2: Sieve of Eratosthenes &amp; Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we will follow the same logic as the previous one, but we will focus on different strategies for executing the two main steps: calculating the prime scores and determining the processing order of the elements.</p>
<p>To calculate the prime score of each number in <code>nums</code>, we will use the &quot;Sieve of Eratosthenes,&quot; an ancient and efficient method for finding all primes in a range <code>[1, n]</code>. The sieve works by iteratively marking the multiples of each prime number, starting from <code>2</code>. For each prime <code>p</code>, it marks all multiples of <code>p</code> as non-prime (composite). This process continues up to <code>sqrt(n)</code>, as any composite number greater than this will have already been marked by smaller primes. The remaining unmarked numbers are primes. Using this information, we can then iterate over each number and count how many smaller primes divide it evenly.</p>
<p>Next, we will again use a monotonic stack to identify the regions where each number is dominant in any subarray.</p>
<p>Finally, in the previous approach, we used a priority queue to quickly access the largest remaining element. However, a priority queue is only necessary when the insertion and removal of elements disrupt the order. In this case, since we process the elements in decreasing order, we can use a sorted array instead, which simplifies the process.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define a helper function <code>getPrimes(limit)</code>:
<ul>
<li>Initialize:
<ul>
<li>an array of size <code>limit + 1</code>, called <code>isPrime</code> and set all values to <code>true</code>.</li>
<li>an empty array, called <code>primes</code>.</li>
</ul>
</li>
<li>For each <code>number</code> in range: <code>[2, limit]</code>:
<ul>
<li>If <code>number</code> is not prime, continue.</li>
<li>Otherwise, push <code>number</code> into <code>primes</code>.</li>
<li>Mark every multiple of <code>number</code> in range <code>[number * number, limit]</code> as not prime.</li>
</ul>
</li>
<li>Return <code>primes</code>.</li>
</ul>
</li>
<li>In the main <code>maximumScore(nums, k)</code> function:
<ul>
<li>Initialize:
<ul>
<li><code>n</code> to the size of the <code>nums</code> array.</li>
<li>an array, called <code>primeScores</code> of size <code>n</code>.</li>
</ul>
</li>
<li>Store the greatest element of <code>nums</code> in <code>maxElement</code>.</li>
<li>Find all <code>primes</code> up to <code>maxElement</code> by calling <code>getPrimes(maxElement)</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to calculate the prime scores:
<ul>
<li>Set <code>num = nums[index]</code>.</li>
<li>For each <code>prime</code> in <code>primes</code>:
<ul>
<li>If <code>prime * prime &gt; num</code>, no more primes divide <code>num</code>, so break.</li>
<li>If <code>num % prime != 0</code>, continue to the next prime.</li>
<li>Increment <code>primeScores[index]</code> by <code>1</code>.</li>
<li>While <code>num</code> is divisible by <code>prime</code>, divide <code>num</code> by <code>prime</code>.</li>
</ul>
</li>
<li>If <code>num &gt; 1</code>, <code>num</code> is prime, so increment <code>primeScores[index]</code> by <code>1</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>two arrays <code>nextDominant</code> and <code>prevDominant</code> to store the indices of the nearest elements with a higher prime score on both sides of each number. Set all elements in <code>nextDominant</code> to <code>n</code> and all values of <code>prevDominant</code> to <code>-1</code>.</li>
<li>an empty stack <code>decreasingPrimeScoreStack</code>.</li>
</ul>
</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to fill the <code>nextDominant</code> and <code>prevDominant</code> arrays:
<ul>
<li>While the stack is not empty and the element at index <code>decreasingPrimeScoreStack.top()</code> has a lower prime score than <code>nums[index]</code>:
<ul>
<li>Pop the top element of the stack as <code>topIndex</code>.</li>
<li>Set <code>nextDominant[topIndex]</code> to the current <code>index</code>.</li>
</ul>
</li>
<li>If the stack is not empty, set <code>prevDominant[index]</code> to the index at the top of the stack.</li>
<li>Push <code>index</code> into the stack.</li>
</ul>
</li>
<li>Initialize an array of size <code>n</code>, called <code>numOfSubarrays</code>.</li>
<li>Iterate over <code>nums</code> with <code>index</code> from <code>0</code> to <code>n - 1</code> to count the number of subarrays in which each element is dominant:
<ul>
<li>Calculate <code>numOfSubarrays[index]</code> as <code>(nextDominant[index] - index) * (index - prevDominant[index])</code>.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>an array <code>sortedArray</code> of pairs <code>(value, index)</code> and push all elements of <code>nums</code> into it.</li>
<li><code>score</code> to <code>1</code>.</li>
<li><code>processingIndex</code> to <code>0</code>.</li>
</ul>
</li>
<li>Sort <code>sortedArray</code> in decreasing order of <code>value</code>.</li>
<li>While <code>k &gt; 0</code>, meaning that we are still allowed to perform operations:
<ul>
<li>Get the element of the <code>sortedArray</code> at <code>processingIndex</code> as <code>[num, index]</code>.</li>
<li>Increment <code>processingIndex</code> by <code>1</code> to continue to the next element.</li>
<li>Calculate the number of <code>operations</code> that we will perform on subarrays in which <code>num</code> is dominant, as <code>min(k, subarrays[index])</code>.</li>
<li>Multiply <code>score</code> by <code>num ^ operations</code>, using modular exponentiation.</li>
<li>Decrement <code>k</code> by <code>operations</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>score</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/W9WKyk3v/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of <code>nums</code> array, <span class="math inline">\(k\)</span> the number of operations and <span class="math inline">\(m\)</span> the largest element in <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O\left(n \times \left(\log{n} + \frac{\sqrt{m}}{\log{m}} + \log{k}\right) + m \log{\log{m}}\right)\)</span></p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>
<p>We first use the Sieve of Eratosthenes to find all primes in the range <span class="math inline">\([1, m]\)</span>, which takes <span class="math inline">\(O(m \log \log m)\)</span> time to compute the primes up to <span class="math inline">\(m\)</span>.</p>
</li>
<li>
<p>For each number in <code>nums</code>, we iterate over the list of primes up to <span class="math inline">\(\sqrt{m}\)</span>. The number of primes up to <span class="math inline">\(\sqrt{m}\)</span> is approximately <span class="math inline">\(\frac{\sqrt{m}}{\log{m}}\)</span>, so the prime factorization of each number takes <span class="math inline">\(O(\frac{\sqrt{m}}{\log{m}})\)</span> time, and for all numbers in <code>nums</code>, this takes <span class="math inline">\(O(n \times \frac{\sqrt{m}}{\log{m}})\)</span>.</p>
</li>
<li>
<p>Filling the <code>nextDominant</code> and <code>prevDominant</code> arrays takes <span class="math inline">\(O(n)\)</span> time, as each index is processed at most once, and the number of subarrays is calculated in constant time for each index, which also takes <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Sorting the <code>sortedArray</code> takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
</li>
<li>
<p>Binary exponentiation is performed to compute the result, which takes <span class="math inline">\(O(\log{k})\)</span> time for each operation. Since the loop runs at most <span class="math inline">\(n\)</span> times, the total time complexity for the exponentiation step is <span class="math inline">\(O(n \log k)\)</span>.</p>
</li>
</ol>
<p>Therefore, the overall time complexity is: <span class="math inline">\(O\left(n \times \left(\log{n} + \frac{\sqrt{m}}{\log{m}} + \log{k}\right) + m \log{\log{m}}\right)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>We use an array <code>isPrime</code> of size <span class="math inline">\(O(m)\)</span> to mark numbers as prime or not. Additionally, several data structures such as <code>primes</code>, <code>primeScores</code>, <code>nextDominant</code>, <code>prevDominant</code>, and <code>sortedArray</code> are used, all of which grow linearly with the size of the input array, <span class="math inline">\(O(n)\)</span>.</p>
<p>The space required for sorting depends on the language:</p>
<ul>
<li>In Java, the space complexity is <span class="math inline">\(O(\log n)\)</span> due to Quick Sort.</li>
<li>In C++, it is <span class="math inline">\(O(\log n)\)</span> for the hybrid sort.</li>
<li>In Python, it is <span class="math inline">\(O(n)\)</span> due to Timsort.</li>
</ul>
<p>Therefore, the total space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-towers-i/description" target="_blank" rel="noopener noreferrer">Beautiful Towers I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>heights</code> of <code>n</code> integers representing the number of bricks in <code>n</code> consecutive towers. Your task is to remove some bricks to form a <strong>mountain-shaped</strong> tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.</p>

<p>Return the <strong>maximum possible sum</strong> of heights of a mountain-shaped tower arrangement.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [5,3,4,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights =&nbsp;[5,3,3,1,1]</code>, the peak is at index 0.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [6,5,3,9,2,7]</span></p>

<p><strong>Output:</strong> <span class="example-io">22</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights =&nbsp;[3,3,3,9,2,2]</code>, the peak is at index 3.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">heights = [3,2,5,5,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">18</span></p>

<p><strong>Explanation:</strong></p>

<p>We remove some bricks to make <code>heights = [2,2,5,5,2,2]</code>, the peak is at index 2 or 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == heights.length &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/beautiful-towers-ii/description" target="_blank" rel="noopener noreferrer">Beautiful Towers II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>maxHeights</code> of <code>n</code> integers.</p>

<p>You are tasked with building <code>n</code> towers in the coordinate line. The <code>i<sup>th</sup></code> tower is built at coordinate <code>i</code> and has a height of <code>heights[i]</code>.</p>

<p>A configuration of towers is <strong>beautiful</strong> if the following conditions hold:</p>

<ol>
	<li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li>
	<li><code>heights</code> is a <strong>mountain</strong> array.</li>
</ol>

<p>Array <code>heights</code> is a <strong>mountain</strong> if there exists an index <code>i</code> such that:</p>

<ul>
	<li>For all <code>0 &lt; j &lt;= i</code>, <code>heights[j - 1] &lt;= heights[j]</code></li>
	<li>For all <code>i &lt;= k &lt; n - 1</code>, <code>heights[k + 1] &lt;= heights[k]</code></li>
</ul>

<p>Return <em>the <strong>maximum possible sum of heights</strong> of a beautiful configuration of towers</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [5,3,4,1,1]
<strong>Output:</strong> 13
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [5,3,3,1,1]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]  
- heights is a mountain of peak i = 0.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 13.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [6,5,3,9,2,7]
<strong>Output:</strong> 22
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [3,3,3,9,2,2]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights is a mountain of peak i = 3.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 22.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> maxHeights = [3,2,5,5,2,3]
<strong>Output:</strong> 18
<strong>Explanation:</strong> One beautiful configuration with a maximum sum is heights = [2,2,5,5,2,2]. This configuration is beautiful since:
- 1 &lt;= heights[i] &lt;= maxHeights[i]
- heights is a mountain of peak i = 2. 
Note that, for this configuration, i = 3 can also be considered a peak.
It can be shown that there exists no other beautiful configuration with a sum of heights greater than 18.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == maxHeights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= maxHeights[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/car-fleet/description" target="_blank" rel="noopener noreferrer">Car Fleet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cars at given miles away from the starting mile 0, traveling to reach the mile <code>target</code>.</p>

<p>You are given two integer arrays&nbsp;<code>position</code> and <code>speed</code>, both of length <code>n</code>, where <code>position[i]</code> is the starting mile of the <code>i<sup>th</sup></code> car and <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> car in miles per hour.</p>

<p>A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</p>

<p>A <strong>car fleet</strong> is a car or cars driving next to each other. The speed of the car fleet is the <strong>minimum</strong> speed of any car in the fleet.</p>

<p>If a car catches up to a car fleet at the mile <code>target</code>, it will still be considered as part of the car fleet.</p>

<p>Return the number of car fleets that will arrive at the destination.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at <code>target</code>.</li>
	<li>The car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself.</li>
	<li>The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches <code>target</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 10, position = [3], speed = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>
There is only one car, hence there is only one fleet.</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">target = 100, position = [0,2,4], speed = [4,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The car starting at 4 (speed 1) travels to 5.</li>
	<li>Then, the fleet at 4 (speed 2) and the car at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches <code>target</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == position.length == speed.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>
	<li><code>0 &lt;= position[i] &lt; target</code></li>
	<li>All the values of <code>position</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/car-fleet-ii/description" target="_blank" rel="noopener noreferrer">Car Fleet II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> cars traveling at different speeds in the same direction along a one-lane road. You are given an array <code>cars</code> of length <code>n</code>, where <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> represents:</p>

<ul>
	<li><code>position<sub>i</sub></code> is the distance between the <code>i<sup>th</sup></code> car and the beginning of the road in meters. It is guaranteed that <code>position<sub>i</sub> &lt; position<sub>i+1</sub></code>.</li>
	<li><code>speed<sub>i</sub></code> is the initial speed of the <code>i<sup>th</sup></code> car in meters per second.</li>
</ul>

<p>For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the <strong>slowest</strong> car in the fleet.</p>

<p>Return an array <code>answer</code>, where <code>answer[i]</code> is the time, in seconds, at which the <code>i<sup>th</sup></code> car collides with the next car, or <code>-1</code> if the car does not collide with the next car. Answers within <code>10<sup>-5</sup></code> of the actual answers are accepted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> cars = [[1,2],[2,1],[4,3],[7,2]]
<strong>Output:</strong> [1.00000,-1.00000,3.00000,-1.00000]
<strong>Explanation:</strong> After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> cars = [[3,4],[5,4],[6,3],[9,1]]
<strong>Output:</strong> [2.00000,1.00000,1.50000,-1.00000]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= cars.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= position<sub>i</sub>, speed<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
	<li><code>position<sub>i</sub> &lt; position<sub>i+1</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description" target="_blank" rel="noopener noreferrer">Construct Binary Search Tree from Preorder Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p>

<p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p>

<p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p>

<p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" style="height: 386px; width: 590px;" />
<pre>
<strong>Input:</strong> preorder = [8,5,1,7,10,12]
<strong>Output:</strong> [8,5,10,1,7,null,12]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> preorder = [1,3]
<strong>Output:</strong> [1,null,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
	<li><code>1 &lt;= preorder[i] &lt;= 1000</code></li>
	<li>All the values of <code>preorder</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-non-decreasing-subarrays-after-k-operations/description" target="_blank" rel="noopener noreferrer">Count Non-Decreasing Subarrays After K Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">queue</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of <code>n</code> integers and an integer <code>k</code>.</p>

<p>For each subarray of <code>nums</code>, you can apply <strong>up to</strong> <code>k</code> operations on it. In each operation, you increment any element of the subarray by 1.</p>

<p><strong>Note</strong> that each subarray is considered independently, meaning changes made to one subarray do not persist to another.</p>

<p>Return the number of subarrays that you can make <strong>non-decreasing</strong> ​​​​​after performing at most <code>k</code> operations.</p>

<p>An array is said to be <strong>non-decreasing</strong> if each element is greater than or equal to its previous element, if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [6,3,1,2,4,4], k = 7</span></p>

<p><strong>Output:</strong> <span class="example-io">17</span></p>

<p><strong>Explanation:</strong></p>

<p>Out of all 21 possible subarrays of <code>nums</code>, only the subarrays <code>[6, 3, 1]</code>, <code>[6, 3, 1, 2]</code>, <code>[6, 3, 1, 2, 4]</code> and <code>[6, 3, 1, 2, 4, 4]</code> cannot be made non-decreasing after applying up to k = 7 operations. Thus, the number of non-decreasing subarrays is <code>21 - 4 = 17</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [6,3,1,3,6], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarray <code>[3, 1, 3, 6]</code> along with all subarrays of <code>nums</code> with three or fewer elements, except <code>[6, 3, 1]</code>, can be made non-decreasing after <code>k</code> operations. There are 5 subarrays of a single element, 4 subarrays of two elements, and 2 subarrays of three elements except <code>[6, 3, 1]</code>, so there are <code>1 + 5 + 4 + 2 = 12</code> subarrays that can be made non-decreasing.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-all-ones/description" target="_blank" rel="noopener noreferrer">Count Submatrices With All Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, <em>return the number of <strong>submatrices</strong> that have all ones</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[1,0,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 150</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-enumeration">Approach 1: Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>A straightforward idea is to enumerate each position <span class="math inline">\((i,j)\)</span> in the matrix and count how many submatrices with this position as the bottom-right corner have all elements equal to <span class="math inline">\(1\)</span>. By doing this, we can count the number of submatrices that meet the condition without repetition or omission. After enumeration, the question is: how do we count the number of submatrices that meet the condition?</p>
<p>We preprocess a <span class="math inline">\(\textit{row}\)</span> array, where <span class="math inline">\(\textit{row}[i][j]\)</span> represents the number of consecutive <span class="math inline">\(1\)</span>s extending to the left from position <span class="math inline">\((i,j)\)</span> in the matrix. The recursive formula is straightforward:</p>
<p><span class="math display">\[row[i][j]=\begin{cases}
0, & \quad mat[i][j]= 0 \\
row[i][j-1]+1, & \quad mat[i][j]= 1
\end{cases}
\]</span></p>
<p>Once we have the <span class="math inline">\(\textit{row}\)</span> array, if we want to count the number of subrectangles with <span class="math inline">\((i,j)\)</span> as the bottom-right corner that satisfy the condition, we can enumerate the height of the subrectangles and check how many of them are valid. We start this enumeration from the <span class="math inline">\(i\)</span>-th row and move upward. For the <span class="math inline">\(i\)</span>-th row, there are <span class="math inline">\(\textit{row}[i][j]\)</span> subrectangles that satisfy the condition. For the <span class="math inline">\(i-1\)</span>-th row, there are <span class="math inline">\(\texttt{min}(\textit{row}[i][j], \textit{row}[i-1][j])\)</span> subrectangles, because both rows must consist entirely of <span class="math inline">\(1\)</span>s to satisfy the condition. The same logic applies to higher rows, where we continuously take the minimum value to ensure the condition holds. Enumerating from bottom to top allows us to update the minimum in constant time.</p>
<p>Following this idea, for each bottom-right point <span class="math inline">\((i,j)\)</span>, the number of valid subrectangles can be calculated in linear time. After traversing all points, we obtain the total number of subrectangles that satisfy the condition.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/G6ziSppd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows of the matrix and <span class="math inline">\(n\)</span> be the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m^2\times n)\)</span>.</p>
<p>The code involves a triple loop.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m\times n)\)</span>.</p>
<p>An <span class="math inline">\(m \times n\)</span> matrix is needed for enumeration.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The goal is to count the number of submatrices in which all elements are <span class="math inline">\(1\)</span>. Similar to the first approach, we can still <strong>enumerate the bottom-right corner of each submatrix</strong>, but here we use a more efficient counting method with a monotonic stack. The method works as follows:</p>
<ol>
<li>
<p><strong>Process each row as the base.</strong><br />
Convert each row of the matrix into a histogram height array <span class="math inline">\(\textit{heights}\)</span>, where <span class="math inline">\(\textit{heights}[j]\)</span> represents the number of consecutive <span class="math inline">\(1\)</span>s extending upward in column <span class="math inline">\(j\)</span>, with the current row as the bottom.<br />
For example, if the current row is treated as the base, then <span class="math inline">\(\textit{heights}[j]\)</span> tells us how tall the column of <span class="math inline">\(1\)</span>s is at position <span class="math inline">\(j\)</span>.</p>
</li>
<li>
<p><strong>Enumerate each column as the right boundary.</strong><br />
For each row, once the heights are calculated, we use a monotonic stack to find the nearest column on the left of each <span class="math inline">\(\textit{heights}[j]\)</span> that has a smaller height. This gives us the left boundary for rectangles ending at <span class="math inline">\(j\)</span>.</p>
</li>
<li>
<p><strong>Count subrectangles using the left and right boundaries.</strong><br />
Suppose the right boundary is at <span class="math inline">\(j\)</span>, and the nearest smaller height on the left is at <span class="math inline">\(i\)</span> (found using the monotonic stack). Then:</p>
</li>
</ol>
<ul>
<li>If the left boundary is less than or equal to <span class="math inline">\(i\)</span>, the subrectangles ending at <span class="math inline">\(i\)</span> have already been counted. Extending them to <span class="math inline">\(j\)</span> adds no new subrectangles.</li>
<li>If the left boundary is greater than <span class="math inline">\(i\)</span>, then it can range from <span class="math inline">\(i+1\)</span> to <span class="math inline">\(j\)</span>, giving <span class="math inline">\((j - i)\)</span> possible positions. Each position can form <span class="math inline">\(\textit{heights}[j]\)</span> subrectangles of different heights, so in total we add <span class="math inline">\((j-i) \times \textit{heights}[j]\)</span> subrectangles.</li>
</ul>
<ol start="4">
<li><strong>Accumulate the result.</strong><br />
By summing over all right boundaries in each row, we obtain the total number of submatrices in the matrix with all elements equal to <span class="math inline">\(1\)</span>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HQpwvjNm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows of the matrix and <span class="math inline">\(n\)</span> be the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m\times n)\)</span>.</p>
<p>For each row, we update the <span class="math inline">\(\textit{heights}\)</span> array in <span class="math inline">\(O(n)\)</span> time, so processing all <span class="math inline">\(m\)</span> rows takes <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Within each row, we use a monotonic stack to find the left and right boundaries of each column. Since every element enters and leaves the stack at most once, the stack operations for one row take <span class="math inline">\(O(n)\)</span> time. Repeating this across all <span class="math inline">\(m\)</span> rows gives a total of <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Combining both parts, the overall time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/create-maximum-number/description" target="_blank" rel="noopener noreferrer">Create Maximum Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>

<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>

<p>Return an array of the <code>k</code> digits representing the answer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
<strong>Output:</strong> [9,8,6,5,3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5
<strong>Output:</strong> [6,7,6,0,4]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3
<strong>Output:</strong> [9,8,9]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == nums1.length</code></li>
	<li><code>n == nums2.length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>
	<li><code>1 &lt;= k &lt;= m + n</code></li>
	<li><code>nums1</code> and <code>nums2</code> do not have leading zeros.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/daily-temperatures/description" target="_blank" rel="noopener noreferrer">Daily Temperatures</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>temperatures</code> represents the daily temperatures, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is the number of days you have to wait after the</em> <code>i<sup>th</sup></code> <em>day to get a warmer temperature</em>. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> temperatures = [73,74,75,71,69,72,76,73]
<strong>Output:</strong> [1,1,4,2,1,1,0,0]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> temperatures = [30,40,50,60]
<strong>Output:</strong> [1,1,1,0]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> temperatures = [30,60,90]
<strong>Output:</strong> [1,1,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>
	<li><code>30 &lt;=&nbsp;temperatures[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description" target="_blank" rel="noopener noreferrer">Final Prices With a Special Discount in a Shop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of the <code>i<sup>th</sup></code> item in a shop.</p>

<p>There is a special discount for items in the shop. If you buy the <code>i<sup>th</sup></code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the minimum index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>. Otherwise, you will not receive any discount at all.</p>

<p>Return an integer array <code>answer</code> where <code>answer[i]</code> is the final price you will pay for the <code>i<sup>th</sup></code> item of the shop, considering the special discount.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> prices = [8,4,6,2,3]
<strong>Output:</strong> [4,2,4,2,3]
<strong>Explanation:</strong> 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.
For items 3 and 4 you will not receive any discount at all.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> prices = [1,2,3,4,5]
<strong>Output:</strong> [1,2,3,4,5]
<strong>Explanation:</strong> In this case, for all items, you will not receive any discount at all.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> prices = [10,1,1,6]
<strong>Output:</strong> [9,0,1,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= prices.length &lt;= 500</code></li>
	<li><code>1 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have an integer array <code>prices</code> listing the prices of items from a shop. Items can receive a special discount based on the price of the next item on the list that is less than or equal to it (if such an item exists). In other words, the discount for <code>prices[i]</code> is <code>prices[j]</code>, where <code>j &gt; i</code>, <code>prices[j] &lt;= prices[i]</code>, and <code>j</code> is the smallest such index that satisfies these conditions.</p>
<p>The task is to calculate the final price for each item, after applying this special discount, and return these final prices in an array called answer.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Since the constraints are small, we can solve this problem using a brute-force approach. For each item in the <code>prices</code> array, we need to find a price that is smaller or equal to it and appears later in the array. This price will be our discount amount. We then subtract this discount from the original price to get the final discounted price.</p>
<p>To implement this, let's start by creating a copy of the <code>prices</code> array called <code>result</code>. We'll loop through the <code>prices</code> array and apply the discount we find for each element to the corresponding element in the <code>result</code> array.</p>
<p>For each element in the <code>prices</code> array, we'll run another loop starting from the next element to the right. If we find a price that is less than or equal to the current element, we'll subtract this price from the original price in the <code>result</code> array and stop looking further. If we don't find any suitable discount after checking all subsequent prices, the item's price in the <code>result</code> array will remain unchanged.</p>
<p>After processing all the prices in this manner, the <code>result</code> array will contain the final discounted prices for each item. We can then return this array as our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable <code>n</code> to store the length of the input <code>prices</code> array.</li>
<li>Initialize a <code>result</code> array by creating a copy of the input <code>prices</code> array. This ensures we have a copy of the original <code>prices</code> to work with.</li>
<li>Start an outer loop that iterates from <code>0</code> to <code>n - 1</code>, with loop variable <code>i</code>:
<ul>
<li>Start an inner loop that iterates from index <code>i + 1</code> to <code>n - 1</code>, with loop variable <code>j</code>.
<ul>
<li>If <code>prices[j]</code> is less than or equal to <code>prices[i]</code>:
<ul>
<li>Calculate the discounted price by subtracting <code>prices[j]</code> from <code>prices[i]</code>.</li>
<li>Store the calculated discounted price in <code>result[i]</code>.</li>
<li>Break the inner loop as we have found the first valid discount.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>result</code> array containing all final prices after discounts.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cotSxu8J/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>prices</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses two nested loops. The outer loop iterates through each element of the array, and for each element, the inner loop can potentially iterate through all remaining elements. In the worst case, where prices are in strictly increasing order, for each element <code>i</code>, we need to check all elements from <code>i + 1</code> to <code>n - 1</code>. Thus, the time complexity is quadratic, <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm creates a new array <code>result</code> of the same size as the input array to store the final prices. Besides this, only a constant amount of extra space is used for loop variables and temporary calculations.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's focus on a key part of the problem: for any given item, we need to find the first price that is smaller or equal to it and comes after it. This is similar to a classic problem known as finding the &quot;next smaller element,&quot; which can be efficiently solved using a stack. But why does a stack work so well here?</p>
<p>Imagine we are processing prices from left to right. At each step, we need to determine if the current price can serve as a discount for any previous prices. The stack helps us keep track of those previous prices that haven't found their discount yet.</p>
<p>The key intuition is that when we find a price that is smaller than some earlier prices, it must be the discount for those earlier prices that are larger than it. We only care about the most recent of these prices because we want the first available discount.</p>
<p>So, for each element, our stack must contain all the most recent prices before that element that are greater than it. This implies that each element present in the stack must be in increasing order of value. This is called a monotonic stack.</p>
<p>When we encounter an element that is smaller than the top of the stack, this means a discount can be applied to the stack element. We continue popping prices from the stack and applying the discount until the stack is empty or the top price is less than the current price. Then, we push the current price to the top of the stack, to wait for a discount which may come further down. This way, we can both apply discounts and also maintain the monotonic property of the stack.</p>
<p>To implement this idea, we'll maintain a <code>stack</code> of indices (not prices, since we need the positions to apply discounts). We iterate over the <code>prices</code> array and check if the current price is less than or equal to the price at the top of the <code>stack</code>. If it is, the current element can be used as a discount to the elements waiting in the <code>stack</code>. We remove each larger price from the <code>stack</code> and apply the discount, then add the current price to the <code>stack</code>. Any prices left on the <code>stack</code> at the end of the main loop had no discount available.</p>
<p>The slideshow below demonstrates this algorithm in action:</p>
<p>!?!../Documents/1475/slideshow.json:916,756!?!</p>
<br>
<blockquote>
<p>Note: If you are unfamiliar with the workings of monotonic stacks, try out these problems to practice:</p>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-element-i/">496. Next Greater Element I 🔗</a></li>
<li><a href="https://leetcode.com/problems/next-greater-element-ii/">503. Next Greater Element II 🔗</a></li>
<li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures 🔗</a></li>
</ul>
</blockquote>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card 🔗</a>. This resource provides an in-depth look at the stack data structure, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a <code>result</code> array by creating a copy of the input <code>prices</code> array to store the discounted prices.</li>
<li>an empty <code>stack</code> that will store indices of prices.</li>
</ul>
</li>
<li>For each index <code>i</code> of the prices array:
<ul>
<li>Start a while loop that continues as long as:
<ol>
<li>The <code>stack</code> is not empty, AND</li>
<li>The price at the index stored at the <code>stack</code>'s top is greater than or equal to the current price</li>
</ol>
<ul>
<li>Inside the while loop, pop the top index from the <code>stack</code>.</li>
<li>Calculate the discounted price by subtracting the current price from the price at the popped index.</li>
<li>Store the result in the <code>result</code> array at the popped index.</li>
</ul>
</li>
<li>Add the current index <code>i</code> to the stack.</li>
</ul>
</li>
<li>Return the <code>result</code> array containing all final prices after discounts.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/EMaz6crS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input array <code>prices</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array once with a single loop. Although there is a while loop inside, each element can be pushed and popped from the <code>stack</code> exactly once. This means the total number of operations on the <code>stack</code> across all iterations is at most <span class="math inline">\(2 \cdot n\)</span> (<span class="math inline">\(n\)</span> pushes and <span class="math inline">\(n\)</span> pops).</p>
<p>Thus, the time complexity is <span class="math inline">\(O(2 \cdot n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a <code>result</code> array of size <span class="math inline">\(n\)</span> to store the final prices. Additionally, in the worst case scenario (when prices are in strictly increasing order), the stack could store all <span class="math inline">\(n\)</span> indices.</p>
<p>Thus, the total space complexity is linear, <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-building-where-alice-and-bob-can-meet/description" target="_blank" rel="noopener noreferrer">Find Building Where Alice and Bob Can Meet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>heights</code> of positive integers, where <code>heights[i]</code> represents the height of the <code>i<sup>th</sup></code> building.</p>

<p>If a person is in building <code>i</code>, they can move to any other building <code>j</code> if and only if <code>i &lt; j</code> and <code>heights[i] &lt; heights[j]</code>.</p>

<p>You are also given another array <code>queries</code> where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>. On the <code>i<sup>th</sup></code> query, Alice is in building <code>a<sub>i</sub></code> while Bob is in building <code>b<sub>i</sub></code>.</p>

<p>Return <em>an array</em> <code>ans</code> <em>where</em> <code>ans[i]</code> <em>is <strong>the index of the leftmost building</strong> where Alice and Bob can meet on the</em> <code>i<sup>th</sup></code> <em>query</em>. <em>If Alice and Bob cannot move to a common building on query</em> <code>i</code>, <em>set</em> <code>ans[i]</code> <em>to</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
<strong>Output:</strong> [2,5,-1,5,2]
<strong>Explanation:</strong> In the first query, Alice and Bob can move to building 2 since heights[0] &lt; heights[2] and heights[1] &lt; heights[2]. 
In the second query, Alice and Bob can move to building 5 since heights[0] &lt; heights[5] and heights[3] &lt; heights[5]. 
In the third query, Alice cannot meet Bob since Alice cannot move to any other building.
In the fourth query, Alice and Bob can move to building 5 since heights[3] &lt; heights[5] and heights[4] &lt; heights[5].
In the fifth query, Alice and Bob are already in the same building.  
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
<strong>Output:</strong> [7,6,-1,4,6]
<strong>Explanation:</strong> In the first query, Alice can directly move to Bob&#39;s building since heights[0] &lt; heights[7].
In the second query, Alice and Bob can move to building 6 since heights[3] &lt; heights[6] and heights[5] &lt; heights[6].
In the third query, Alice cannot meet Bob since Bob cannot move to any other building.
In the fourth query, Alice and Bob can move to building 4 since heights[3] &lt; heights[4] and heights[0] &lt; heights[4].
In the fifth query, Alice can directly move to Bob&#39;s building since heights[1] &lt; heights[6].
For ans[i] != -1, It can be shown that ans[i] is the leftmost building where Alice and Bob can meet.
For ans[i] == -1, It can be shown that there is no building where Alice and Bob can meet.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= heights.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= heights.length - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>heights</code> and an array of pairs <code>queries</code>, where each pair is of the form <span class="math inline">\([a_i, b_i]\)</span>, representing the positions of Alice and Bob at indices <code>i</code> and <code>j</code>, respectively. For each query, the task is to find the closest value to the right in the <code>heights</code> array that is greater than the <code>heights</code> at both the given positions.</p>
<p>In other words, given indices <code>i</code> and <code>j</code>, we need to find the first value in the <code>heights</code> array that is greater than the values at <code>heights[i]</code> and <code>heights[j]</code>. If no such value exists, return -1.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Let’s start by breaking down the problem into simpler terms. Suppose <code>queries</code> only contained single integer indices. The goal would then be to find, for each index, the first building to the right in the <code>heights</code> array that is taller than the building at that index. Instead of scanning the array repeatedly for each query, we can preprocess the <code>heights</code> array to store this &quot;next taller building&quot; information in advance.</p>
<p>The key insight here is that for each building, the next taller building to its right depends only on the heights of the buildings that come after it. Using a monotonic stack, we can compute this efficiently. By traversing the <code>heights</code> array from right to left, we maintain a stack of indices in decreasing order of heights. For the current building, any shorter or equal buildings already in the stack cannot be the answer, so we remove them. If the stack is not empty, the top element gives the position of the next taller building. If the stack is empty, it means no taller building exists to the right, so we store <code>-1</code>. This preprocessing step allows us to handle single queries in constant time. For a better understanding of this idea, you can refer to <a href="https://leetcode.com/problems/next-greater-element-ii/">Next Greater Element - II</a>, which applies a similar technique.</p>
<p>Now, let’s extend this idea to handle queries that are pairs of values. In this scenario, the task is to find the first height to the right in the <code>heights</code> array that is greater than both values in each pair. Here the key realization is that the answer for a pair depends on the larger of the two values since a building must be taller than both. This simplifies the problem by reducing it to a comparison with a single threshold for each query.</p>
<p>While traversing the <code>heights</code> array, we use a monotonic stack to maintain all elements greater than the current height, with the nearest greater height at the top of the stack. When processing a query, the stack already contains all elements greater than the current height.</p>
<p>For each query pair, we use binary search on the stack to quickly find the first element greater than the larger value in the pair. This ensures that each query is processed in <span class="math inline">\(O(\log n)\)</span> time.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main function - <code>leftmostBuildingQueries(heights, queries)</code></p>
<ol>
<li>Create a list <code>newQueries</code> where each index stores the list of queries that require this index as the maximum index of the query pair. Each query is stored as a pair containing the required height (<code>heights[a]</code>) and the query index.</li>
<li>Initialize a monotonic stack <code>monoStack</code> to keep track of building heights and their indices in decreasing order of height while iterating from right to left in the <code>heights</code> array.</li>
<li>Initialize an array <code>result</code> to store the answers for each query, with all elements initially set to <code>-1</code>.</li>
<li>Iterate over the <code>queries</code>:
<ul>
<li>For each query, extract the two indices <code>a</code> and <code>b</code>.</li>
<li>If <code>a &gt; b</code>, swap the indices to ensure <code>a &lt;= b</code>.</li>
<li>If <code>heights[b] &gt; heights[a]</code> or <code>a == b</code>, set <code>result[currQuery] = b</code>.</li>
<li>Otherwise, add the query to <code>newQueries[b]</code> with its required height (<code>heights[a]</code>) and the query index.</li>
</ul>
</li>
<li>Iterate over the indices of the <code>heights</code> array from right to left:
<ul>
<li>For each query stored at the current index in <code>newQueries</code>, use binary search on the <code>monoStack</code> to find the first building with a height greater than the query's required height. If such a building exists, set the result for the query to the index of this building.</li>
<li>Remove all elements from the top of the <code>monoStack</code> where the height is less than or equal to the current height, as they are no longer relevant.</li>
<li>Push the current height and index onto the <code>monoStack</code>.</li>
</ul>
</li>
<li>Return the <code>result</code> array.</li>
</ol>
<p>Helper Binary Search function - <code>search(height, monoStack)</code></p>
<ol>
<li>Initialize two pointers <code>left = 0</code> and <code>right = size of monoStack - 1</code>. Set a variable <code>ans = -1</code> to store the search result.</li>
<li>Perform a binary search:
<ul>
<li>Calculate <code>mid = (left + right) / 2</code>.</li>
<li>If the height at <code>monoStack[mid]</code> is greater than the required height:
<ul>
<li>Update <code>ans = max(ans, mid)</code> and set <code>left = mid + 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>, which will be the index of the first building with a height greater than the required height. If no such building exists, <code>ans</code> remains <code>-1</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AFfMGimL/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log n + n)\)</span></p>
<p>The algorithm  processes each query using binary search on the monotonic stack, which takes <span class="math inline">\(O(\log n)\)</span> per query. With <span class="math inline">\(q\)</span> queries, the total query processing time is <span class="math inline">\(O(q \cdot \log n)\)</span>. Apart from this, we also iterate through the <code>heights</code> and <code>queries</code> arrays, that takes <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(q)\)</span> time, respectively.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(q \cdot \log n + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a monotonic stack to store building indices, requiring <span class="math inline">\(O(n)\)</span> space. It also stores queries in the <code>newQueries</code> array and results in the <code>result</code> array, each taking <span class="math inline">\(O(q)\)</span> space.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we calculated the answer using a monotonic stack. Each query asks for the closest index to the right with a value greater than both elements in the query pair. Instead of processing each query one at a time, we can optimize by checking, for each index in the <code>heights</code> array, if it can serve as the answer for any query.</p>
<p>To do this efficiently, we can iterate through the <code>heights</code> array from left to right. For each index, we look for query pairs where both indices are smaller than the current index, and both values in the pair are smaller than the value at the current index. To make this process faster, we prioritize assigning answers to the smallest query pairs first.</p>
<p>By maintaining the query pairs sorted based on their maximum value and index up to the current position, we can process them more efficiently.</p>
<p>To implement this idea, we process the <code>heights</code> array while managing the queries by storing them in a 2D array of arrays, where each subarray holds the queries for the corresponding building.</p>
<p>We begin by sorting and mapping the queries to track the index and values that we need. Using a priority queue, we store queries based on their maximum value and index. This helps us quickly retrieve the smallest index for processing.</p>
<p>As we move through the <code>heights</code> array, we pop the queries from the queue. For each query, if the current index is greater than both indices of the query, we assign the current index as the answer and store it. We also check if new queries, whose maximum index matches the current one, should be added to the queue for future processing.</p>
<p>This allows us to handle queries without reprocessing them repeatedly.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>storeQueries</code> as a 2D array of arrays to store queries for each building.</p>
</li>
<li>
<p>Initialize <code>maxIndex</code> as a priority queue to track the queries that need to be answered based on building heights.</p>
</li>
<li>
<p>Initialize <code>result</code> as an array of <code>-1</code> to store the answers for each query.</p>
</li>
<li>
<p>Loop through each query:</p>
<ul>
<li>For each query <code>(a, b)</code>:
<ul>
<li>If the height of building <code>a</code> is less than building <code>b</code> and <code>a</code> is smaller than <code>b</code>, set <code>result[currQuery]</code> to <code>b</code> (building <code>b</code> is the answer).</li>
<li>If the height of building <code>a</code> is greater than building <code>b</code> and <code>a</code> is greater than <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (building <code>a</code> is the answer).</li>
<li>If <code>a</code> is equal to <code>b</code>, set <code>result[currQuery]</code> to <code>a</code> (both are the same building).</li>
<li>Otherwise, store the query in <code>storeQueries[max(a, b)]</code> for future processing.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Loop through each building index <code>index</code>:</p>
<ul>
<li>While the priority queue <code>maxIndex</code> has elements and the minimum value in <code>maxIndex</code> is smaller than the current building height:
<ul>
<li>Set the corresponding query's result in <code>result</code> and pop the element from <code>maxIndex</code> (this query is answered).</li>
</ul>
</li>
<li>Push new queries from <code>storeQueries[index]</code> into <code>maxIndex</code>, sorting them by height.</li>
</ul>
</li>
<li>
<p>Return the <code>result</code> array containing the answers to all queries.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gobEvzsi/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>heights</code> and <span class="math inline">\(q\)</span> be the number of queries in the <code>queries</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(q \cdot \log q + n)\)</span></p>
<p>The algorithm first iterates over the <code>queries</code> array to map the maximum indices and heights in <code>storeQueries</code>, taking <span class="math inline">\(O(q)\)</span> time. It then processes each index in the <code>heights</code> array, updating results via a priority queue. Insertion and deletion operations in the priority queue take <span class="math inline">\(O(\log q)\)</span> each, with at most <span class="math inline">\(q\)</span> queries processed. For each index, the algorithm checks and pushes relevant queries from <code>storeQueries</code>, resulting in an overall <span class="math inline">\(O(n)\)</span> time for all iterations.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(q \cdot \log q + n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n + q)\)</span></p>
<p>The algorithm uses a array <code>storeQueries</code> to store query mappings, which requires <span class="math inline">\(O(n)\)</span> space, as each element corresponds to an index in <code>heights</code>. Additionally, a priority queue <code>maxIndex</code> is used to handle queries, which at most can store <span class="math inline">\(O(q)\)</span> elements. The <code>result</code> array also requires <span class="math inline">\(O(q)\)</span> space to store the answers.</p>
<p>Therefore, the total space complexity is <span class="math inline">\(O(n + q)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-maximum-non-decreasing-array-length/description" target="_blank" rel="noopener noreferrer">Find Maximum Non-decreasing Array Length</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">queue</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>You can perform any number of operations, where each operation involves selecting a <strong>subarray</strong> of the array and replacing it with the <strong>sum</strong> of its elements. For example, if the given array is <code>[1,3,5,6]</code> and you select subarray <code>[3,5]</code> the array will convert to <code>[1,8,6]</code>.</p>

<p>Return <em>the </em><strong><em>maximum</em></strong><em> length of a </em><strong><em>non-decreasing</em></strong><em> array that can be made after applying operations.</em></p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,2,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> This array with length 3 is not non-decreasing.
We have two ways to make the array length two.
First, choosing subarray [2,2] converts the array to [5,4].
Second, choosing subarray [5,2] converts the array to [7,2].
In these two ways the array is not non-decreasing.
And if we choose subarray [5,2,2] and replace it with [9] it becomes non-decreasing. 
So the answer is 1.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The array is non-decreasing. So the answer is 4.
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,3,2,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Replacing [3,2] with [5] converts the given array to [4,5,6] that is non-decreasing.
Because the given array is not non-decreasing, the maximum<!-- notionvc: 3447a505-d1ee-4411-8cae-e52162f53a55 --> possible answer is 3.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-most-competitive-subsequence/description" target="_blank" rel="noopener noreferrer">Find the Most Competitive Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and a positive integer <code>k</code>, return <em>the most<strong> competitive</strong> subsequence of </em><code>nums</code> <em>of size </em><code>k</code>.</p>

<p>An array&#39;s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.</p>

<p>We define that a subsequence <code>a</code> is more <strong>competitive</strong> than a subsequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, subsequence <code>a</code> has a number <strong>less</strong> than the corresponding number in <code>b</code>. For example, <code>[1,3,4]</code> is more competitive than <code>[1,3,5]</code> because the first position they differ is at the final number, and <code>4</code> is less than <code>5</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,6], k = 2
<strong>Output:</strong> [2,6]
<strong>Explanation:</strong> Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,3,3,5,4,9,6], k = 4
<strong>Output:</strong> [2,3,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/description" target="_blank" rel="noopener noreferrer">Find the Number of Subarrays Where Boundary Elements Are Maximum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>Return the number of <span data-keyword="subarray-nonempty">subarrays</span> of <code>nums</code>, where the <strong>first</strong> and the <strong>last</strong> elements of the subarray are <em>equal</em> to the <strong>largest</strong> element in the subarray.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,4,3,3,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<strong><u>1</u></strong>,4,3,3,2]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</li>
	<li>subarray <code>[1,<u><strong>4</strong></u>,3,3,2]</code>, with its largest element 4. The first element is 4 and the last element is also 4.</li>
	<li>subarray <code>[1,4,<u><strong>3</strong></u>,3,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,<u><strong>3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[1,4,3,3,<u><strong>2</strong></u>]</code>, with its largest element 2. The first element is 2 and the last element is also 2.</li>
	<li>subarray <code>[1,4,<u><strong>3,3</strong></u>,2]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>There are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:</p>

<ul>
	<li>subarray <code>[<u><strong>3</strong></u>,3,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<strong><u>3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,3,<u><strong>3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<strong><u>3,3</u></strong>,3]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[3,<u><strong>3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
	<li>subarray <code>[<u><strong>3,3,3</strong></u>]</code>, with its largest element 3. The first element is 3 and the last element is also 3.</li>
</ul>

<p>Hence, we return 6.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is a single subarray of <code>nums</code> which is <code>[<strong><u>1</u></strong>]</code>, with its largest element 1. The first element is 1 and the last element is also 1.</p>

<p>Hence, we return 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-rectangle-in-histogram/description" target="_blank" rel="noopener noreferrer">Largest Rectangle in Histogram</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" style="width: 522px; height: 242px;" />
<pre>
<strong>Input:</strong> heights = [2,1,5,6,2,3]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" style="width: 202px; height: 362px;" />
<pre>
<strong>Input:</strong> heights = [2,4]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-well-performing-interval/description" target="_blank" rel="noopener noreferrer">Longest Well-Performing Interval</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We are given <code>hours</code>, a list of the number of hours worked per day for a given employee.</p>

<p>A day is considered to be a <em>tiring day</em> if and only if the number of hours worked is (strictly) greater than <code>8</code>.</p>

<p>A <em>well-performing interval</em> is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</p>

<p>Return the length of the longest well-performing interval.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> hours = [9,9,6,0,6,6,9]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The longest well-performing interval is [9,9,6].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> hours = [6,6,6]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= hours.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= hours[i] &lt;= 16</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-array-non-decreasing/description" target="_blank" rel="noopener noreferrer">Make Array Non-decreasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. In one operation, you can select a <span data-keyword="subarray-nonempty">subarray</span> and replace it with a single element equal to its <strong>maximum</strong> value.</p>

<p>Return the <strong>maximum possible size</strong> of the array after performing zero or more operations such that the resulting array is <strong>non-decreasing</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [4,2,5,3,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One way to achieve the maximum size is:</p>

<ol>
	<li>Replace subarray <code>nums[1..2] = [2, 5]</code> with <code>5</code> &rarr; <code>[4, 5, 3, 5]</code>.</li>
	<li>Replace subarray <code>nums[2..3] = [3, 5]</code> with <code>5</code> &rarr; <code>[4, 5, 5]</code>.</li>
</ol>

<p>The final array <code>[4, 5, 5]</code> is non-decreasing with size <font face="monospace">3.</font></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>No operation is needed as the array <code>[1,2,3]</code> is already non-decreasing.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-chunks-to-make-sorted/description" target="_blank" rel="noopener noreferrer">Max Chunks To Make Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code> of length <code>n</code> that represents a permutation of the integers in the range <code>[0, n - 1]</code>.</p>

<p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p>

<p>Return <em>the largest number of chunks we can make to sort the array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [4,3,2,1,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&#39;t sorted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,0,2,3,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>0 &lt;= arr[i] &lt; n</code></li>
	<li>All the elements of <code>arr</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>arr</code> of length <code>n</code> that contains the numbers <code>0</code>, <code>1</code>, ... , <code>n - 1</code> in random order. According to the problem description, three operations are to be performed:</p>
<ol>
<li>Split the array into a number of <em>chunks</em> (i.e., segments).</li>
<li>Sort each segment separately in increasing order.</li>
<li>Concatenate all segments <strong>in the same order</strong> as they appear in the original array.</li>
</ol>
<p>Our task is to find the highest possible number of chunks we can split the array into such that each chunk can be sorted independently and still be concatenated to match the sorted version of the entire array.</p>
<p>A key observation here is that a split is valid if and only if each segment contains numbers strictly greater than those in the previous segment. In other words, the minimum value of each segment must be greater than the maximum value of the previous segment.</p>
<hr />
<h3 id="approach-1-prefixmax-and-suffixmin-arrays">Approach 1: PrefixMax and SuffixMin Arrays</h3>
<h4 id="intuition">Intuition</h4>
<p>Building on the above observation, we further notice that for each number in the array, we have two options: we can either include it in the same chunk as the previous number or create a new chunk for it. However, we must consider the limitation that a new chunk at index <span class="math inline">\(i\)</span> can only be created if all the numbers in the current and previous chunks (the &quot;prefix&quot; of the array) are smaller than all the numbers in the following chunks (the &quot;suffix&quot; of the array). This is equivalent to checking whether:</p>
<p><span class="math display">\[\begin{aligned}
max(prefix[0:i]) < min(suffix[i:n]).
\end{aligned}
\]</span></p>
<p>Since we aim to find the largest possible number of chunks, we will choose the second option (i.e., create a new chunk) whenever the above condition is satisfied. Therefore, the problem reduces to counting how many indices in the array satisfy this condition.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>prefixMax</code> and <code>suffixMin</code> arrays to <code>arr</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>1</code> to <code>n - 1</code>:
<ul>
<li>Set <code>prefixMax[i] = max(prefixMax[i], prefixMax[i-1])</code>.</li>
</ul>
</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>n - 2</code> to <code>0</code>:
<ul>
<li>Set <code>suffixMin[i] = min(suffixMin[i], suffixMin[i+1])</code>.</li>
</ul>
</li>
<li>Initialize <code>chunks</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Check if <code>i == 0</code> (create a chunk for the first element) or <code>suffixMin[i] &gt; prefixMax[i - 1]</code>.
<ul>
<li>If true, increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DUP4x9QQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The initialization of the <code>prefixMax</code> and <code>suffixMin</code> arrays, as well as the computation of <code>chunks</code>, each requires a single pass through the array <code>arr</code>, taking <span class="math inline">\(O(n)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n) + O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>prefixMax</code> and <code>suffixMin</code> arrays require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-sums">Approach 2: Prefix Sums</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An important observation is that a segment of the array can form a valid chunk if, when sorted, it matches the corresponding segment in the fully sorted version of the array.</p>
<p>Since the numbers in <code>arr</code> belong to the range <code>[0, n - 1]</code>, we can simplify the problem by using the property of sums. Specifically, for any index, it suffices to check whether the sum of the elements in <code>arr</code> up to that index is equal to the sum of the elements in the corresponding prefix of the sorted array.</p>
<p>If these sums are equal, it guarantees that the elements in the current segment of <code>arr</code> match the elements in the corresponding segment of the sorted array (possibly in a different order). When this condition is satisfied, we can form a new chunk — either starting from the beginning of the array or the end of the previous chunk.</p>
<p>For example, consider <code>arr = [1, 2, 0, 3, 4]</code> and the sorted version <code>sortedArr = [0, 1, 2, 3, 4]</code>. We find the valid segments as follows:</p>
<ul>
<li>Segment <code>[0, 0]</code> is not valid, since <code>sum = 1</code> and <code>sortedSum = 0</code>.</li>
<li>Segment <code>[0, 1]</code> is not valid, since <code>sum = 1 + 2 = 3</code> and <code>sortedSum = 0 + 1 = 1</code>.</li>
<li>Segment <code>[0, 2]</code> is valid, since <code>sum = 1 + 2 + 0 = 3</code> and <code>sortedSum = 0 + 1 + 2 = 3</code>.</li>
<li>Segment <code>[3, 3]</code> is valid, because <code>sum = 1 + 2 + 0 + 3 = 6</code> and <code>sortedSum = 0 + 1 + 2 + 3 = 6</code>.</li>
<li>Segment <code>[4, 4]</code> is valid, because <code>sum = 1 + 2 + 0 + 3 + 4 = 10</code> and <code>sortedSum = 0 + 1 + 2 + 3 + 4 = 10</code>.</li>
</ul>
<p>Therefore, the answer here is 3.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>chunks</code>, <code>prefixSum</code>, and <code>sortedPrefixSum</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Increment <code>prefixSum</code> by <code>arr[i]</code>.</li>
<li>Increment <code>sortedPrefixSum</code> by <code>i</code>.</li>
<li>Check if <code>prefixSum == sortedPrefixSum</code>:
<ul>
<li>If so, increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DBPgzN5d/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array <code>arr</code> once and perform constant-time operations on each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are only using a fixed number of variables which does not depend on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-monotonic-increasing-stack">Approach 3: Monotonic Increasing Stack</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The main idea of this approach is that if a number in the array is less than any number in the previous chunks, this number cannot create a new chunk, as we cannot swap elements from different chunks to fix their relative order. We will iterate over the array and maintain a stack to represent the maximum values of the chunks created so far. As we loop over the array, we decide whether the current element (<code>arr[i]</code>) can start a new chunk or should merge with an existing chunk. We handle two cases:</p>
<ol>
<li><code>arr[i] &gt; stack.top</code>: If the current element is greater than the top of the stack, it means it can start a new chunk because it’s larger than all previous chunks. We push <code>arr[i]</code> into the stack to represent a new chunk.</li>
<li><code>arr[i] &lt; stack.top</code>: If the current element is smaller the top of the stack, it cannot form a new chunk. Instead, it must merge with one or more existing chunks. To merge, remove all chunks from the stack whose maximum values are greater than the current element. Then, push back the maximum value of the merged chunks to maintain the stack sorted.</li>
</ol>
<p>Let's take a look at an example, where <code>arr = [1, 2, 0, 3, 4]</code>. Initially the stack is empty: <code>stack = []</code>.</p>
<ul>
<li>We then push <code>1</code> into the stack: <code>stack = [1]</code>.</li>
<li><code>2 &gt; 1</code>, we push <code>2</code> into the stack: <code>stack = [1, 2]</code>.</li>
<li><code>0 &lt; 2</code>, <code>0 &lt; 1</code>, we pop <code>2</code> and <code>1</code> from the stack. We push <code>2</code> back into the stack, as it the maximum element of the current chunk: <code>stack = [2]</code>.</li>
<li><code>3 &gt; 2</code>, we push <code>3</code> into the stack: <code>stack = [2, 3]</code>.</li>
<li><code>4 &gt; 3</code>, we push <code>4</code> into the stack: <code>stack = [2, 3, 4]</code>.</li>
</ul>
<p>Now recall that at each point the elements in the stack represent the maximum elements of the chunks created so far. Therefore, at the end of the iteration, the size of the stack equals the maximum number of chunks that can be formed.</p>
<blockquote>
<p>For a more comprehensive understanding of stacks, check out the <a href="https://leetcode.com/explore/learn/card/queue-stack/">Stack Explore Card</a>. This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>monotonicStack</code> to an empty stack.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>If the <code>monotonicStack</code> is empty or <code>arr[i]</code> is greater than the top of the stack:
<ul>
<li>Push <code>arr[i]</code> into the <code>monotonicStack</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Initialize <code>maxElement</code> to the top element of the <code>monotonicStack</code>.</li>
<li>While the <code>monotonicStack</code> is not empty and the top element is greater than <code>arr[i]</code>:
<ul>
<li>Pop the top element from the <code>monotonicStack</code>.</li>
</ul>
</li>
<li>Push <code>maxElement</code> into the <code>monotonicStack</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the size of the <code>monotonicStack</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/XVZvpjGz/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array, and during each iteration, we either push an element into the <code>monotonicStack</code> (constant-time operation) or pop elements from the stack using the inner while loop. Notice that the number of times the while loop runs in a single iteration corresponds to the size of the current chunk being merged. The total number of pop operations across all iterations is therefore equal to the sum of the sizes of the chunks which is the total number of elements in the array. Hence the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case (i.e., <code>arr</code> is in increasing order), the stack contains <span class="math inline">\(n\)</span> elements, so the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-maximum-element">Approach 4: Maximum Element</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Similarly to the second approach, we will use a condition to determine when a segment can be considered a valid chunk. Here, we iterate through the array while keeping track of the maximum element we've encountered up to the current index.</p>
<p>Now, consider the case where the current index <span class="math inline">\(i\)</span>, is equal to the maximum element encountered so far, <span class="math inline">\(\text{maxElement}\)</span>. This condition means that all elements preceding index <span class="math inline">\(i\)</span> are less than <span class="math inline">\(\text{maxElement}\)</span>. Since the array is a permutation of integers in the range <span class="math inline">\([0, n - 1]\)</span>, it also guarantees that all integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(\text{maxElement}\)</span> must appear in the array before index <span class="math inline">\(i\)</span>. Therefore, whenever the current index matches the maximum value so far (i.e., <span class="math inline">\(i == \text{maxElement}\)</span>), we increment the count of chunks.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>arr</code> array.</li>
<li>Initialize <code>chunks</code> and <code>maxElement</code> to <code>0</code>.</li>
<li>Iterate over <code>arr</code> with <code>i</code> from <code>0</code> to <code>n - 1</code>:
<ul>
<li>Update <code>maxElement</code> to <code>max(maxElement, arr[i])</code>.</li>
<li>If <code>maxElement == i</code>:
<ul>
<li>Increment <code>chunks</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>chunks</code>.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZvF2KSk7/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate over the array <code>arr</code> once and perform constant-time operations on each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are only using a fixed number of variables which does not depend on the input size.</p>
</li>
</ul>
<hr />
<p><strong>Follow Up:</strong> Want to challenge yourself further? Try out the harder version of the problem: <a href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/">Max Chunks To Make Sorted II</a></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-chunks-to-make-sorted-ii/description" target="_blank" rel="noopener noreferrer">Max Chunks To Make Sorted II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code>.</p>

<p>We split <code>arr</code> into some number of <strong>chunks</strong> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.</p>

<p>Return <em>the largest number of chunks we can make to sort the array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,3,4,4]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 2000</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximal-rectangle/description" target="_blank" rel="noopener noreferrer">Maximal Rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;0&quot;]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == matrix.length</code></li>
	<li><code>cols == matrix[i].length</code></li>
	<li><code>1 &lt;= row, cols &lt;= 200</code></li>
	<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-and-minimum-sums-of-at-most-size-k-subarrays/description" target="_blank" rel="noopener noreferrer">Maximum and Minimum Sums of at Most Size K Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and a <strong>positive</strong> integer <code>k</code>. Return the sum of the <strong>maximum</strong> and <strong>minimum</strong> elements of all <span data-keyword="subarray-nonempty">subarrays</span> with <strong>at most</strong> <code>k</code> elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">20</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarrays of <code>nums</code> with at most 2 elements are:</p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;"><b>Subarray</b></th>
			<th style="border: 1px solid black;">Minimum</th>
			<th style="border: 1px solid black;">Maximum</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[2]</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[3]</code></td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">6</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, 2]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[2, 3]</code></td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Final Total</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">20</td>
		</tr>
	</tbody>
</table>

<p>The output would be 20.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,-3,1], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">-6</span></p>

<p><strong>Explanation:</strong></p>

<p>The subarrays of <code>nums</code> with at most 2 elements are:</p>

<table style="border: 1px solid black;">
	<tbody>
		<tr>
			<th style="border: 1px solid black;"><b>Subarray</b></th>
			<th style="border: 1px solid black;">Minimum</th>
			<th style="border: 1px solid black;">Maximum</th>
			<th style="border: 1px solid black;">Sum</th>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[-3]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">-6</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1]</code></td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[1, -3]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">-2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><code>[-3, 1]</code></td>
			<td style="border: 1px solid black;">-3</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">-2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;"><strong>Final Total</strong></td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">&nbsp;</td>
			<td style="border: 1px solid black;">-6</td>
		</tr>
	</tbody>
</table>

<p>The output would be -6.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 80000</code></li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-balanced-shipments/description" target="_blank" rel="noopener noreferrer">Maximum Balanced Shipments</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="365" data-start="23">You are given an integer array <code data-end="62" data-start="54">weight</code> of length <code data-end="76" data-start="73">n</code>, representing the weights of <code data-end="109" data-start="106">n</code> parcels arranged in a straight line. A <strong data-end="161" data-start="149">shipment</strong> is defined as a contiguous subarray of parcels. A shipment is considered <strong data-end="247" data-start="235">balanced</strong> if the weight of the <strong data-end="284" data-start="269">last parcel</strong> is <strong>strictly less</strong> than the <strong data-end="329" data-start="311">maximum weight</strong> among all parcels in that shipment.</p>

<p data-end="528" data-start="371">Select a set of <strong data-end="406" data-start="387">non-overlapping</strong>, contiguous, balanced shipments such that <strong data-end="496" data-start="449">each parcel appears in at most one shipment</strong> (parcels may remain unshipped).</p>

<p data-end="587" data-start="507">Return the <strong data-end="545" data-start="518">maximum possible number</strong> of balanced shipments that can be formed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">weight = [2,5,1,4,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p data-end="136" data-start="62">We can form the maximum of two balanced shipments as follows:</p>

<ul>
	<li data-end="163" data-start="140">Shipment 1: <code>[2, 5, 1]</code>

	<ul>
		<li data-end="195" data-start="168">Maximum parcel weight = 5</li>
		<li data-end="275" data-start="200">Last parcel weight = 1, which is strictly less than 5. Thus, it&#39;s balanced.</li>
	</ul>
	</li>
	<li data-end="299" data-start="279">Shipment 2: <code>[4, 3]</code>
	<ul>
		<li data-end="331" data-start="304">Maximum parcel weight = 4</li>
		<li data-end="411" data-start="336">Last parcel weight = 3, which is strictly less than 4. Thus, it&#39;s balanced.</li>
	</ul>
	</li>
</ul>

<p data-end="519" data-start="413">It is impossible to partition the parcels to achieve more than two balanced shipments, so the answer is 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">weight = [4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p data-end="635" data-start="574">No balanced shipment can be formed in this case:</p>

<ul>
	<li data-end="772" data-start="639">A shipment <code>[4, 4]</code> has maximum weight 4 and the last parcel&#39;s weight is also 4, which is not strictly less. Thus, it&#39;s not balanced.</li>
	<li data-end="885" data-start="775">Single-parcel shipments <code>[4]</code> have the last parcel weight equal to the maximum parcel weight, thus not balanced.</li>
</ul>

<p data-end="958" data-is-last-node="" data-is-only-node="" data-start="887">As there is no way to form even one balanced shipment, the answer is 0.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="8706" data-start="8671"><code data-end="8704" data-start="8671">2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li data-end="8733" data-start="8709"><code data-end="8733" data-start="8709">1 &lt;= weight[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-binary-tree/description" target="_blank" rel="noopener noreferrer">Maximum Binary Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>

<ol>
	<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>
	<li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li>
	<li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li>
</ol>

<p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" style="width: 302px; height: 421px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1,6,0,5]
<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]
<strong>Explanation:</strong> The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" style="width: 182px; height: 301px;" />
<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> [3,null,2,null,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
	<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-recursive-solution">Approach 1: Recursive Solution</h3>
<p>The current solution is very simple. We make use of a function <code>construct(nums, l, r)</code>, which returns the maximum binary tree consisting of numbers within the indices <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span> in the given <span class="math inline">\(nums\)</span> array(excluding the <span class="math inline">\(r^{th}\)</span> element).</p>
<p>The algorithm consists of the following steps:</p>
<ol>
<li>
<p>Start with the function call <code>construct(nums, 0, n)</code>. Here, <span class="math inline">\(n\)</span> refers to the number of elements in the given <span class="math inline">\(nums\)</span> array.</p>
</li>
<li>
<p>Find the index, <span class="math inline">\(max_i\)</span>, of the largest element in the current range of indices <span class="math inline">\((l:r-1)\)</span>. Make this largest element, <span class="math inline">\(nums[max\_i]\)</span> as the local root node.</p>
</li>
<li>
<p>Determine the left child using <code>construct(nums, l, max_i)</code>. Doing this recursively finds the largest element in the subarray left to the current largest element.</p>
</li>
<li>
<p>Similarly, determine the right child using <code>construct(nums, max_i + 1, r)</code>.</p>
</li>
<li>
<p>Return the root node to the calling function.</p>
</li>
</ol>
<p><a href="https://leetcode.com/playground/3hVy3spd/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The function <code>construct</code> is called <span class="math inline">\(n\)</span> times. At each level of the recursive tree, we traverse over all the <span class="math inline">\(n\)</span> elements to find the maximum element.  In the average case, there will be a <span class="math inline">\(\log n\)</span> levels leading to a complexity of <span class="math inline">\(O\big(n\log n\big)\)</span>. In the worst case, the depth of the recursive tree can grow upto <span class="math inline">\(n\)</span>, which happens in the case of a sorted <span class="math inline">\(nums\)</span> array, giving a complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. The size of the <span class="math inline">\(set\)</span> can grow upto <span class="math inline">\(n\)</span> in the worst case. In the average case, the size will be <span class="math inline">\(\log n\)</span> for <span class="math inline">\(n\)</span> elements in <span class="math inline">\(nums\)</span>, giving an average case complexity of <span class="math inline">\(O(\log n)\)</span></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-a-good-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Score of a Good Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> <strong>(0-indexed)</strong> and an integer <code>k</code>.</p>

<p>The <strong>score</strong> of a subarray <code>(i, j)</code> is defined as <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>. A <strong>good</strong> subarray is a subarray where <code>i &lt;= k &lt;= j</code>.</p>

<p>Return <em>the maximum possible <strong>score</strong> of a <strong>good</strong> subarray.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3,7,4,5], k = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,4,5,4,1,1,1], k = 0
<strong>Output:</strong> 20
<strong>Explanation:</strong> The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>The score of a subarray is its length multiplied by its minimum element. In this problem, we must find the maximum score of all subarrays that contain <code>nums[k]</code>.</p>
<p>How can we improve our score? When we take more elements we increase the length of the subarray, which helps the score. However, we may find new minimums, which would decrease our score.</p>
<p>We can start by separating the array - numbers to the left of <code>k</code> and numbers to the right of <code>k</code> (and including <code>k</code>).</p>
<p><img src="../Figures/1793/1.png" alt="img" /><br />
<br></p>
<p>Notice that <code>k</code> is the meeting point of these sections. If we want to take elements in the left section, we start from the end of the left section and move toward the beginning. If we want to take elements in the right section, we start from the beginning and move toward the end.</p>
<p>Of course, each element we take will increase our length by <code>1</code>. But how will it affect our minimum? To compute this quickly, we can create new arrays for each section. These arrays will represent the minimum element we have seen in the section if we started from <code>k</code>.</p>
<p><img src="../Figures/1793/2.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we took two elements from the left section. We can quickly see that the minimum element from the left section is <code>3</code> using these arrays. Similarly, if we took all elements from the right section, we could quickly see that the minimum element from the right section is <code>4</code>.</p>
<blockquote>
<p>We will call these arrays that allow us to find the minimums <code>left</code> and <code>right</code>.</p>
</blockquote>
<p>Now that we have these arrays, how can we solve the problem? Because <code>nums[k]</code> is in the right section, we will iterate over the entire right section and try to take each element. Let's say we take some number of elements from the right section, and the minimum is <code>x</code>. How many elements can we take from the left section without changing <code>x</code> as the minimum? We must only take elements from the left that are greater than or equal to <code>x</code>.</p>
<p>Let's switch to another example. For a given array, assuming we have already built the <code>left</code> and <code>right</code> arrays using the previous method.</p>
<p><img src="../Figures/1793/3.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we take four elements from the right section. The minimum is <code>5</code>. How many elements can we take from the left section without changing the minimum? Two. This gives us a total size of <code>4 + 2 = 6</code>, and a total score of <code>6 * 5 = 30</code>.</p>
<p>How do we quickly find the number of elements we can take from the left section? Note that when we are building the array <code>left</code> from right to left, each time we go left we encounter a new number that is only likely to lower the minimum value, and the further to the left we go, the smaller the minimum value becomes, i.e., <code>left</code> is already sorted from smallest to largest. Therefore, we can perform a binary search to identify how many elements we can take.</p>
<p>This brings us to our solution. We iterate with <code>j</code> over each index of <code>right</code> and assign <code>currMin = right[j]</code>, which represents the minimum of our subarray. We then perform a binary search to find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code>. Once we have <code>i</code>, we can calculate the size of our subarray, and thus the score. We take the maximum of all scores.</p>
<p>How do we calculate the size of our subarray given <code>i</code> and <code>j</code>?</p>
<p><img src="../Figures/1793/4.png" alt="img" /><br />
<br></p>
<p>Because the right section starts at index <code>k</code>, its indices are offset by <code>k</code> from the real indices. Thus, in the original array, <code>right[j]</code> points to index <code>k + j</code>. The left section is not offset at all, so <code>i</code> is correctly positioned. The size of a subarray bounded by <code>[left, right]</code> is <code>right - left + 1</code>. Thus, the size of our subarray <code>[i, k + j]</code> is <code>(k + j) - i + 1</code>. We can multiply this by <code>right[j]</code> to calculate our score.</p>
<p>You may have noticed: this algorithm assumes that in the optimal subarray, the minimum value is in the right section. But what if this assumption is wrong, and its actually in the left section? We can check the left section by simply reversing the array and then applying the same algorithm to it. Note that when we reverse the array, <code>k</code> will change. After reversal, the original <code>k</code> will be at <code>nums.length - k - 1</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>solve(nums, k)</code> that runs our algorithm:
<ul>
<li>Set <code>n = nums.length</code>, <code>left</code> to an array of length <code>k</code>, and <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k - 1</code> until <code>0</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and set <code>left[i] = currMin</code>.</li>
<li>Initialize an empty array <code>right</code> and reset <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k</code> until <code>n - 1</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and push <code>currMin</code> to <code>right</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>j</code> over the indices of <code>right</code>:
<ul>
<li>Set <code>currMin = right[j]</code>.</li>
<li>Find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code> using binary search.</li>
<li>Calculate <code>size = (k + j) - i - 1</code>.</li>
<li>Update <code>ans</code> with <code>currMin * size</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = solve(nums, k)</code>.</li>
<li>Reverse <code>nums</code>.</li>
<li>Return the larger of <code>ans, solve(nums, nums.length - k - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AePxSPjG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> time to create <code>left</code> and <code>right</code>. Then, we iterate over the indices of <code>right</code>, which is not more than <span class="math inline">\(O(n)\)</span> iterations. At each iteration, we perform a binary search over <code>left</code>, which does not cost more than <span class="math inline">\(O(\log{}n)\)</span>. Thus, <code>solve</code> costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>, and we call it twice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code> and <code>right</code> have a combined length of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<p><strong>Intuition</strong></p>
<p>In this approach, we will use a similar idea as in the previous approach. For a given index <code>i</code>, if we treat <code>nums[i]</code> as the minimum element, we need to know how many elements we can take on the left and right such that we do not take any elements less than <code>nums[i]</code>.</p>
<blockquote>
<p>You might be thinking: what if <code>nums[k]</code> is not included? We will get to that after presenting the full idea of the approach.</p>
</blockquote>
<p>Essentially, we need to know how far away the next lesser element is on both sides. If we have this information for all indices, we can quickly calculate the maximum score possible by treating every <code>nums[i]</code> as the minimum, since in the optimal solution, one of the indices must be the minimum.</p>
<p>There is a very similar problem called <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element</a>. The logic is identical, except that we are looking for the next smaller element. We can accomplish this using a monotonic stack.</p>
<details><summary><b>If you aren't familiar with monotonic stacks, click here.</b></summary>
<p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>increasing</strong> stack, i.e. the elements in the stack are always sorted in ascending order.</p>
<p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the largest value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the stack is greater than <code>num</code>, we pop from it. Since there may be multiple elements greater than <code>num</code> in the stack, we need to use a while loop to &quot;clean&quot; the stack before pushing <code>num</code>.</p>
<p>Only once there are no elements in the stack greater than <code>num</code> will we push <code>num</code>.</p>
</details>
<br>
<p>We will create an array <code>left</code>, where <code>left[i]</code> has the index of the first element to the left of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>Similarly, we will create an array <code>right</code> where <code>right[i]</code> has the index of the first element to the right of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>So how do we calculate <code>right</code>? Let's say that we are iterating over <code>nums</code> from the left and we have a chain of increasing numbers:</p>
<p><img src="../Figures/1793/5.png" alt="img" /><br />
<br></p>
<p>As you can see in the example, we have 6 increasing numbers, and then a <code>1</code> that is less than all of them. This <code>1</code> (at index 6) should be the value of <code>right</code> for all the indices of the increasing numbers. If we maintain a monotonic increasing stack, then this <code>1</code> will cause all those numbers to be popped out.</p>
<p>With a monotonic increasing stack, whenever we see an element that is smaller than the top of the stack, it is guaranteed to be the first smaller element for the element at the top of the stack. This is exactly what we are looking for.</p>
<p>To calculate <code>left</code>, we use the exact same process, except we iterate backward starting from the end of <code>nums</code>.</p>
<p>Note that because we need to remember what indices to update when we pop from the stack, we will store indices on the stack instead of the elements themselves. We can easily find the values by referencing <code>nums</code>.</p>
<p>We will initialize the values of <code>left</code> to <code>-1</code> and the values of <code>right</code> to <code>n</code>. This way, the math will still work out later if there are elements that do not have any lower values to the left or right.</p>
<p>Once we have <code>left</code> and <code>right</code>, we can iterate over all indices <code>i</code> and try to find a maximum score. Remember that the subarray must contain index <code>k</code>. Thus, we can only use an index <code>i</code> as the minimum if <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>.</p>
<p>When we treat an index <code>i</code> as the minimum, what score can we achieve? Our window starts one index after <code>left[i]</code> because including <code>left[i]</code> would create a new minimum. Similarly, our window ends one index before <code>right[i]</code>. Thus, we need to subtract <code>2</code> from the normal subarray size formula. This gives us a subarray size of <code>right[i] - left[i] - 1</code>. We multiply this size by <code>nums[i]</code> to get our score.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left</code> as an array of length <code>n</code> with values of <code>-1</code>, and an empty <code>stack</code>.</li>
<li>Iterate <code>i</code> from <code>n - 1</code> until <code>0</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>left[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>right</code> as an array of length <code>n</code> with values of <code>n</code> and reset <code>stack</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>right[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>If <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>, update <code>ans</code> with <code>nums[i] * (right[i] - left[i] - 1)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/N4kEkyfF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>It costs <span class="math inline">\(O(n)\)</span> to calculate <code>left</code> and <code>right</code>. We iterate over each index once and perform amortized <span class="math inline">\(O(1)\)</span> work at each iteration. The reason it amortizes to <span class="math inline">\(O(1)\)</span>, despite the while loop, is because the while loop can run a maximum of <span class="math inline">\(n\)</span> times across all iterations, and each index can only be pushed onto and popped from the stack once.</p>
<p>To calculate <code>ans</code>, we iterate over the indices once and perform <span class="math inline">\(O(1)\)</span> work at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code>, <code>right</code>, and <code>stack</code> all require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes the simplest approach is the best! The optimal subarray must contain index <code>k</code>, so it makes sense to consider the subarray with only <code>nums[k]</code> as a starting point.</p>
<p>From here, how do we expand the subarray? We can either add an element to the left or an element to the right. Let's say we have two pointers, <code>left</code> and <code>right</code> that represent our subarray. Which direction should we go?</p>
<p>If we move left, it's equivalent to adding <code>nums[left - 1]</code> to our subarray. If we move right, it's equivalent to adding <code>nums[right + 1]</code> to our subarray. We should move in the direction of the greater element.</p>
<p>At each step, we update <code>currMin</code> which is initially set to <code>nums[k]</code>, and try to update <code>ans</code> which is also initially set to <code>nums[k]</code>. We can update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is larger.</p>
<p>This greedy process is very similar to the one used to solve <a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a>. But why does it work? We will use a proof by contradiction to demonstrate that not doing it this way wouldn't result in a higher value either.</p>
<p>At each step, we choose between having our subarray as <code>[left - 1, right]</code> or <code>[left, right + 1]</code>. Let's assume that <code>nums[left - 1] &gt; nums[right + 1]</code> and the optimal subarray has not been found yet. The optimal subarray must include <code>nums[left - 1]</code>. If it doesn't, then it must include <code>nums[right + 1]</code>, since we could only move right to &quot;avoid&quot; <code>nums[left - 1]</code>. However, any subarray that includes <code>nums[right + 1]</code> could also include <code>nums[left - 1]</code> without affecting the minimum, while also increasing the length of the subarray and thus the score. Thus, it is impossible for the optimal subarray to include <code>nums[right + 1]</code> and not <code>nums[left - 1]</code>, and in general the optimal subarray must include <code>nums[left - 1]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>To implement the while loop, we will iterate until we have exhausted the array. If one of the pointers is out of bounds, we will consider the element it points to as <code>0</code>.</p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left = k</code>, <code>right = k</code>, <code>ans = nums[k]</code>, and <code>currMin = nums[k]</code>.</li>
<li>While <code>left &gt; 0</code> or <code>right &lt; n - 1</code>:
<ul>
<li>Compare <code>nums[left - 1]</code> with <code>nums[right + 1]</code>:
<ul>
<li>If <code>nums[right + 1]</code> is greater, increment <code>right</code> and update <code>currMin</code> with <code>nums[right]</code> if it is lower.</li>
<li>Otherwise, decrement <code>left</code> and update <code>currMin</code> with <code>nums[left]</code> if it is lower.</li>
</ul>
</li>
<li>Update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is greater.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ayvayDq2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>At each iteration, our <code>left</code> or <code>right</code> pointers move closer to the edges of the array by <code>1</code>. Thus, we perform <span class="math inline">\(O(n)\)</span> iterations. Each iteration costs <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-subarray-min-product/description" target="_blank" rel="noopener noreferrer">Maximum Subarray Min-Product</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>min-product</strong> of an array is equal to the <strong>minimum value</strong> in the array <strong>multiplied by</strong> the array&#39;s <strong>sum</strong>.</p>

<ul>
	<li>For example, the array <code>[3,2,5]</code> (minimum value is <code>2</code>) has a min-product of <code>2 * (3+2+5) = 2 * 10 = 20</code>.</li>
</ul>

<p>Given an array of integers <code>nums</code>, return <em>the <strong>maximum min-product</strong> of any <strong>non-empty subarray</strong> of </em><code>nums</code>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Note that the min-product should be maximized <strong>before</strong> performing the modulo operation. Testcases are generated such that the maximum min-product <strong>without</strong> modulo will fit in a <strong>64-bit signed integer</strong>.</p>

<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,<u>2,3,2</u>]
<strong>Output:</strong> 14
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,<u>3,3</u>,1,2]
<strong>Output:</strong> 18
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,<u>5,6,4</u>,2]
<strong>Output:</strong> 60
<strong>Explanation:</strong> The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-queries/description" target="_blank" rel="noopener noreferrer">Maximum Sum Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">segment tree</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, each of length <code>n</code>, and a <strong>1-indexed 2D array</strong> <code>queries</code> where <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p>

<p>For the <code>i<sup>th</sup></code> query, find the <strong>maximum value</strong> of <code>nums1[j] + nums2[j]</code> among all indices <code>j</code> <code>(0 &lt;= j &lt; n)</code>, where <code>nums1[j] &gt;= x<sub>i</sub></code> and <code>nums2[j] &gt;= y<sub>i</sub></code>, or <strong>-1</strong> if there is no <code>j</code> satisfying the constraints.</p>

<p>Return <em>an array </em><code>answer</code><em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]
<strong>Output:</strong> [6,10,7]
<strong>Explanation:</strong> 
For the 1st query <code node="[object Object]">x<sub>i</sub> = 4</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 1</code>, we can select index&nbsp;<code node="[object Object]">j = 0</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 4</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 1</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 6, and we can show that 6 is the maximum we can obtain.

For the 2nd query <code node="[object Object]">x<sub>i</sub> = 1</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 3</code>, we can select index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 1</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 3</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 10, and we can show that 10 is the maximum we can obtain. 

For the 3rd query <code node="[object Object]">x<sub>i</sub> = 2</code>&nbsp;and&nbsp;<code node="[object Object]">y<sub>i</sub> = 5</code>, we can select index&nbsp;<code node="[object Object]">j = 3</code>&nbsp;since&nbsp;<code node="[object Object]">nums1[j] &gt;= 2</code>&nbsp;and&nbsp;<code node="[object Object]">nums2[j] &gt;= 5</code>. The sum&nbsp;<code node="[object Object]">nums1[j] + nums2[j]</code>&nbsp;is 7, and we can show that 7 is the maximum we can obtain.

Therefore, we return&nbsp;<code node="[object Object]">[6,10,7]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]
<strong>Output:</strong> [9,9,9]
<strong>Explanation:</strong> For this example, we can use index&nbsp;<code node="[object Object]">j = 2</code>&nbsp;for all the queries since it satisfies the constraints for each query.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> There is one query in this example with <code node="[object Object]">x<sub>i</sub></code> = 3 and <code node="[object Object]">y<sub>i</sub></code> = 3. For every index, j, either nums1[j] &lt; <code node="[object Object]">x<sub>i</sub></code> or nums2[j] &lt; <code node="[object Object]">y<sub>i</sub></code>. Hence, there is no solution. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums1.length == nums2.length</code>&nbsp;</li>
	<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length ==&nbsp;2</code></li>
	<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>
	<li><code>y<sub>i</sub> == queries[i][2]</code></li>
	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-width-ramp/description" target="_blank" rel="noopener noreferrer">Maximum Width Ramp</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>ramp</strong> in an integer array <code>nums</code> is a pair <code>(i, j)</code> for which <code>i &lt; j</code> and <code>nums[i] &lt;= nums[j]</code>. The <strong>width</strong> of such a ramp is <code>j - i</code>.</p>

<p>Given an integer array <code>nums</code>, return <em>the maximum width of a <strong>ramp</strong> in </em><code>nums</code>. If there is no <strong>ramp</strong> in <code>nums</code>, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,0,8,2,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,8,1,0,1,9,4,0,4,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach 1: Brute Force (Time Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>For this problem, we need to efficiently find two indices <code>i</code> and <code>j</code> such that <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>.</p>
<p>The brute force approach is to check every possible pair <code>(i, j)</code> where <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>, and compute the maximum ramp width.</p>
<p>For each valid pair, compute the width <code>j - i</code> and update the maximum width if necessary.</p>
<p>However, this brute force approach will not work due to the constraints below:</p>
<ul>
<li><span class="math inline">\(2 \leq \text{nums.length} \leq 5 \times 10^4\)</span></li>
<li><span class="math inline">\(0 \leq \text{nums}[i] \leq 5 \times 10^4\)</span></li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and <code>maxWidth</code> to 0.</li>
<li>Use a nested loop to iterate through all pairs <code>(i, j)</code> where:
<ul>
<li>The outer loop variable <code>i</code> goes from <code>0</code> to <code>n - 1</code>.</li>
<li>The inner loop variable <code>j</code> goes from <code>i + 1</code> to <code>n - 1</code>.</li>
</ul>
</li>
<li>For each pair <code>(i, j)</code>:
<ul>
<li>Check if <code>nums[i]</code> is less than or equal to <code>nums[j]</code>.
<ul>
<li>If true, calculate the width as <code>j - i</code>.</li>
<li>Update <code>maxWidth</code> with the maximum value between the current <code>maxWidth</code> and the calculated width.</li>
</ul>
</li>
</ul>
</li>
<li>After checking all pairs, return <code>maxWidth</code> as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/E2gfxGiq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a nested loop where the outer loop iterates <span class="math inline">\(n\)</span> times and the inner loop can iterate up to <span class="math inline">\(n - 1\)</span> times for each iteration of the outer loop. This results in a total of <span class="math inline">\(\frac{n(n-1)}{2}\)</span> iterations, leading to a quadratic time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only requires a few integer variables (<code>n</code> and <code>maxWidth</code>) regardless of the size of the input array <code>nums</code>. There are no data structures used that would grow with the size of the input. Hence, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting">Approach 2: Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, comparing <code>nums[i]</code> with <code>nums[j]</code> needed to be done for all pairs since <code>nums</code> is not sorted in order. This leads to an inefficient solution.</p>
<p>To make our solution more efficient, we can sort the indices of the array based on the values of <code>nums</code>. This way, when processing indices in the sorted order, each value is guaranteed to be greater than or equal to the values of previously processed indices.</p>
<p>Once the indices are sorted, we track the smallest index we've seen so far as we move through the sorted list. For each index we encounter, we calculate the difference between the current index and the smallest one. This difference represents a potential ramp width, and we update our maximum width as we go.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Find the size of the input array <code>nums</code> and initialize a array <code>indices</code> of the same size to hold the indices.</li>
<li>Initialize the <code>indices</code> array and fill it with values from <code>0</code> to <code>n-1</code> (each index corresponding to its position in <code>nums</code>).</li>
<li>Sort the <code>indices</code> based on the values in <code>nums</code>:
<ul>
<li>Use a custom comparator to ensure stability while sorting:
<ul>
<li>Compare values in <code>nums</code> for the corresponding indices.</li>
<li>If the values are equal, maintain the original order of the indices.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>minIndex</code> to <code>n</code> (a value larger than any possible index) to track the minimum index encountered so far.</li>
<li>Initialize <code>maxWidth</code> to <code>0</code> to store the maximum width ramp found.</li>
<li>Iterate over the sorted <code>indices</code>:
<ul>
<li>Update <code>maxWidth</code> to be the maximum of its current value and the difference between the current index (<code>indices[i]</code>) and <code>minIndex</code>.</li>
<li>Update <code>minIndex</code> to be the minimum of its current value and the current index (<code>indices[i]</code>).</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DqjkzxEw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The most significant factor in the time complexity comes from the sorting operation on the <code>indices</code> array. Sorting takes <span class="math inline">\(O(n \log n)\)</span> time. The subsequent loop that calculates the maximum width ramp runs in <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is dominated by the sorting step, resulting in <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + S) = O(n)\)</span></p>
<p>The space complexity is primarily determined by the additional <code>indices</code> array that stores the indices of the <code>nums</code> array, which requires <span class="math inline">\(O(n)\)</span> space. Other variables used in the algorithm are of constant space, leading to an overall space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The other additional space used is for the sorting algorithm. The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointers">Approach 3: Two Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another way to approach the problem is to recognize that if we could process the indices in such a way that we can easily compare their relative positions, it might help us avoid unnecessary comparisons.</p>
<p>We can notice that it would be helpful to know the maximum value from each index to the end of the array.  Given this information, we can easily check if the ramp condition is satisfied for any left index while iterating from the start of the array. Thus, we initialize <code>rightMax</code> where each element at index <code>i</code> stores the maximum value from index <code>i</code> to the last index. We populate this array in reverse order. Starting from the end of the <code>nums</code> array, we set the last element of <code>rightMax</code> to be equal to the last element of <code>nums</code>. For all previous indices, we store the maximum of the current value in <code>nums[i]</code> and the value at <code>rightMax[i + 1]</code>. This ensures that each index in <code>rightMax</code> contains the highest value from that index to the end of the original array.</p>
<p>With <code>rightMax</code> constructed, we can proceed with our two-pointer approach. We initialize one pointer (<code>left</code>) at the start of the array and another pointer (<code>right</code>) that we will move through the array. As we iterate:</p>
<ul>
<li>We check if the condition <span class="math inline">\(nums[left] \leq rightMax[right]\)</span> holds. If true, we calculate the ramp width as <code>right - left</code> and update our maximum width if this is the largest we’ve seen.</li>
<li>If the condition is not satisfied, it means the value at <code>nums[left]</code> is too large to form a ramp with <code>rightMax[right]</code>, so we increment the <code>left</code> pointer to try and find a smaller value.</li>
</ul>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> as the size of the input vector <code>nums</code>.</li>
<li>Create a <code>rightMax</code> array of the same size to store the maximum values from the right side of <code>nums</code>.</li>
<li>Fill the <code>rightMax</code> array:
<ul>
<li>Set <code>rightMax[n - 1]</code> to <code>nums[n - 1]</code> (the last element).</li>
<li>Iterate backward from the second-to-last element to the first:
<ul>
<li>For each index <code>i</code>, set <code>rightMax[i]</code> to the maximum of <code>rightMax[i + 1]</code> and <code>nums[i]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize two pointers, <code>left</code> and <code>right</code>, both starting at 0, and a variable <code>maxWidth</code> initialized to 0.</li>
<li>Traverse the array using <code>left</code> and <code>right</code> pointers:
<ul>
<li>While <code>right</code> is less than <code>n</code>:
<ul>
<li>Move the <code>left</code> pointer forward while the current value at <code>nums[left]</code> exceeds the corresponding value in <code>rightMax[right]</code>.</li>
<li>Calculate the current width as <code>right - left</code> and update <code>maxWidth</code> to the maximum of <code>maxWidth</code> and the current width.</li>
<li>Increment the <code>right</code> pointer.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/CFRwxcEm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm consists of two main parts. The first loop fills the <code>rightMax</code> array, which takes <span class="math inline">\(O(n)\)</span> time since it iterates through the <code>nums</code> array once. The second part uses a two-pointer technique to traverse the <code>nums</code> array and the <code>rightMax</code> array, where both pointers traverse the array at most <span class="math inline">\(n\)</span> times. Thus, the total time taken is linear in terms of the size of the input array, leading to an overall time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the additional storage used, which in this case is the <code>rightMax</code> array. This array also has a size of <span class="math inline">\(n\)</span>, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. Other variables used (like <code>left</code>, <code>right</code>, and <code>maxWidth</code>) take constant space, <span class="math inline">\(O(1)\)</span>, but they do not contribute to the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-monotonic-stack">Approach 4: Monotonic Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We notice that for any element <span class="math inline">\(nums[i]\)</span>, we'd like to consider the indices of all elements <span class="math inline">\(nums[j]\)</span> preceding <span class="math inline">\(nums[i]\)</span> such that <span class="math inline">\(nums[j] < nums[i]\)</span>. We can efficiently find all these indices by maintaining a monotonic stack. The key observation is that this problem involves finding valid pairs where an earlier index has a smaller or equal value than a later index, making it a perfect candidate for a monotonic stack. This way, whenever we encounter a value in <span class="math inline">\(nums\)</span> that is greater than the element at the index in top of our stack, we can pop all the indices from the stack to find left indices that can form valid pairs.</p>
<p>As we iterate over the array, we push indices onto a stack only if the value at the current index is smaller than or equal to the value at the index on top of the stack. This ensures that the stack contains a list of potential starting points for ramps, in decreasing order of value. The key insight is that when we encounter a larger value, we begin popping indices from the stack. For each index popped, we calculate the ramp width formed with the current index and check if it exceeds the maximum width we have tracked. Since the values on the stack are always decreasing, popping an index means that we have found a ramp where the condition <span class="math inline">\(nums[i] \leq nums[j]\)</span> is satisfied.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/962/monotonic.json:1025,535!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and create an empty stack <code>indicesStack</code>.</li>
<li>Iterate through the array from index 0 to <code>n-1</code>.
<ul>
<li>If <code>indicesStack</code> is empty or the value at the top index of the stack is greater than the current value <code>nums[i]</code>, push <code>i</code> onto the stack.</li>
<li>This ensures the stack contains indices in increasing order of their corresponding values in <code>nums</code>.</li>
</ul>
</li>
<li>Initialize <code>maxWidth</code> to 0.</li>
<li>Iterate through the array from index <code>n-1</code> down to 0.
<ul>
<li>While the stack is not empty and the value at the index on the top of the stack is less than or equal to <code>nums[j]</code>:</li>
<li>Update <code>maxWidth</code> to the maximum of its current value and the width calculated as <code>j - indicesStack.top()</code>.</li>
<li>Pop the index from the stack, as it has already been processed.</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/bUmS9o8r/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates through the <code>nums</code> array once, pushing indices onto the stack. This operation takes <span class="math inline">\(O(n)\)</span> time in the worst case since each index is pushed at most once. The second loop also iterates through the <code>nums</code> array, but each index is popped from the stack at most once. Hence, both loops combined result in a total of <span class="math inline">\(O(n)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity arises primarily from the stack that holds indices. In the worst case, where all elements are in strictly increasing order, all <span class="math inline">\(n\)</span> indices could be pushed onto the stack. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span> in this scenario.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-tree-from-leaf-values/description" target="_blank" rel="noopener noreferrer">Minimum Cost Tree From Leaf Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of positive integers, consider all binary trees such that:</p>

<ul>
	<li>Each node has either <code>0</code> or <code>2</code> children;</li>
	<li>The values of <code>arr</code> correspond to the values of each <strong>leaf</strong> in an in-order traversal of the tree.</li>
	<li>The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.</li>
</ul>

<p>Among all possible binary trees considered, return <em>the smallest possible sum of the values of each non-leaf node</em>. It is guaranteed this sum fits into a <strong>32-bit</strong> integer.</p>

<p>A node is a <strong>leaf</strong> if and only if it has zero children.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg" style="width: 500px; height: 169px;" />
<pre>
<strong>Input:</strong> arr = [6,2,4]
<strong>Output:</strong> 32
<strong>Explanation:</strong> There are two possible trees shown.
The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg" style="width: 224px; height: 145px;" />
<pre>
<strong>Input:</strong> arr = [4,11]
<strong>Output:</strong> 44
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 40</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 15</code></li>
	<li>It is guaranteed that the answer fits into a <strong>32-bit</strong> signed integer (i.e., it is less than 2<sup>31</sup>).</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description" target="_blank" rel="noopener noreferrer">Minimum Number of Increments on Subarrays to Form a Target Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>target</code>. You have an integer array <code>initial</code> of the same size as <code>target</code> with all elements initially zeros.</p>

<p>In one operation you can choose <strong>any</strong> subarray from <code>initial</code> and increment each value by one.</p>

<p>Return <em>the minimum number of operations to form a </em><code>target</code><em> array from </em><code>initial</code>.</p>

<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> target = [1,2,3,2,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We need at least 3 operations to form the target array from the initial array.
[<strong><u>0,0,0,0,0</u></strong>] increment 1 from index 0 to 4 (inclusive).
[1,<strong><u>1,1,1</u></strong>,1] increment 1 from index 1 to 3 (inclusive).
[1,2,<strong><u>2</u></strong>,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> target = [3,1,1,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> [<strong><u>0,0,0,0</u></strong>] -&gt; [1,1,1,<strong><u>1</u></strong>] -&gt; [<strong><u>1</u></strong>,1,1,2] -&gt; [<strong><u>2</u></strong>,1,1,2] -&gt; [3,1,1,2]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> target = [3,1,5,4,2]
<strong>Output:</strong> 7
<strong>Explanation:</strong> [<strong><u>0,0,0,0,0</u></strong>] -&gt; [<strong><u>1</u></strong>,1,1,1,1] -&gt; [<strong><u>2</u></strong>,1,1,1,1] -&gt; [3,1,<strong><u>1,1,1</u></strong>] -&gt; [3,1,<strong><u>2,2</u></strong>,2] -&gt; [3,1,<strong><u>3,3</u></strong>,2] -&gt; [3,1,<strong><u>4</u></strong>,4,2] -&gt; [3,1,5,4,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= target[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Number of Visited Cells in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" style="width: 181px; height: 81px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Convert All Elements to Zero</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>nums</code> of size <code>n</code>, consisting of <strong>non-negative</strong> integers. Your task is to apply some (possibly zero) operations on the array so that <strong>all</strong> elements become 0.</p>

<p>In one operation, you can select a <span data-keyword="subarray">subarray</span> <code>[i, j]</code> (where <code>0 &lt;= i &lt;= j &lt; n</code>) and set all occurrences of the <strong>minimum</strong> <strong>non-negative</strong> integer in that subarray to 0.</p>

<p>Return the <strong>minimum</strong> number of operations required to make all elements in the array 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [0,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select the subarray <code>[1,1]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,1,2,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select subarray <code>[1,3]</code> (which is <code>[1,2,1]</code>), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in <code>[3,0,2,0]</code>.</li>
	<li>Select subarray <code>[2,2]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[3,0,0,0]</code>.</li>
	<li>Select subarray <code>[0,0]</code> (which is <code>[3]</code>), where the minimum non-negative integer is 3. Setting all occurrences of 3 to 0 results in <code>[0,0,0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 3.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,1,2,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Select subarray <code>[0,5]</code> (which is <code>[1,2,1,2,1,2]</code>), where the minimum non-negative integer is 1. Setting all occurrences of 1 to 0 results in <code>[0,2,0,2,0,2]</code>.</li>
	<li>Select subarray <code>[1,1]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,2,0,2]</code>.</li>
	<li>Select subarray <code>[3,3]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,0,0,2]</code>.</li>
	<li>Select subarray <code>[5,5]</code> (which is <code>[2]</code>), where the minimum non-negative integer is 2. Setting all occurrences of 2 to 0 results in <code>[0,0,0,0,0,0]</code>.</li>
	<li>Thus, the minimum number of operations required is 4.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-array-equal-to-target/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make Array Equal to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integer arrays <code>nums</code> and <code>target</code>, of the same length.</p>

<p>In a single operation, you can select any subarray of <code>nums</code> and increment each element within that subarray by 1 or decrement each element within that subarray by 1.</p>

<p>Return the <strong>minimum</strong> number of operations required to make <code>nums</code> equal to the array <code>target</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [3,5,1,2], target = [4,6,2,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>We will perform the following operations to make <code>nums</code> equal to <code>target</code>:<br />
- Increment&nbsp;<code>nums[0..3]</code> by 1, <code>nums = [4,6,2,3]</code>.<br />
- Increment&nbsp;<code>nums[3..3]</code> by 1, <code>nums = [4,6,2,4]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,2], target = [2,1,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>We will perform the following operations to make <code>nums</code> equal to <code>target</code>:<br />
- Increment&nbsp;<code>nums[0..0]</code> by 1, <code>nums = [2,3,2]</code>.<br />
- Decrement&nbsp;<code>nums[1..1]</code> by 1, <code>nums = [2,2,2]</code>.<br />
- Decrement&nbsp;<code>nums[1..1]</code> by 1, <code>nums = [2,1,2]</code>.<br />
- Increment&nbsp;<code>nums[2..2]</code> by 1, <code>nums = [2,1,3]</code>.<br />
- Increment&nbsp;<code>nums[2..2]</code> by 1, <code>nums = [2,1,4]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == target.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-i/description" target="_blank" rel="noopener noreferrer">Next Greater Element I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>next greater element</strong> of some element <code>x</code> in an array is the <strong>first greater</strong> element that is <strong>to the right</strong> of <code>x</code> in the same array.</p>

<p>You are given two <strong>distinct 0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p>

<p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the <strong>next greater element</strong> of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.</p>

<p>Return <em>an array </em><code>ans</code><em> of length </em><code>nums1.length</code><em> such that </em><code>ans[i]</code><em> is the <strong>next greater element</strong> as described above.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]
<strong>Output:</strong> [-1,3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,4], nums2 = [1,2,3,4]
<strong>Output:</strong> [3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>
	<li>All integers in <code>nums1</code> and <code>nums2</code> are <strong>unique</strong>.</li>
	<li>All the integers of <code>nums1</code> also appear in <code>nums2</code>.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you find an <code>O(nums1.length + nums2.length)</code> solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-ii/description" target="_blank" rel="noopener noreferrer">Next Greater Element II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code>nums</code>.</p>

<p>The <strong>next greater number</strong> of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return <code>-1</code> for this number.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,1]
<strong>Output:</strong> [2,-1,2]
Explanation: The first 1&#39;s next greater number is 2; 
The number 2 can&#39;t find next greater number. 
The second 1&#39;s next greater number needs to search circularly, which is also 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,3]
<strong>Output:</strong> [2,3,4,-1,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-using-double-length-array-time-limit-exceeded">Approach 1: Brute Force (using Double Length Array) [Time Limit Exceeded]</h3>
<h4 id="algorithm">Algorithm</h4>
<p>In this method, we make use of an array <span class="math inline">\(doublenums\)</span> which is formed by concatenating two copies of the given <span class="math inline">\(nums\)</span> array one after the other. Now, when we need to find out the next greater element for <span class="math inline">\(nums[i]\)</span>, we can simply scan all the elements <span class="math inline">\(doublenums[j]\)</span>, such that <span class="math inline">\(i < j < length(doublenums)\)</span>. The first element found satisfying the given condition is the required result for <span class="math inline">\(nums[i]\)</span>. If no such element is found, we put a <span class="math inline">\(\text{-1}\)</span> at the appropriate position in the <span class="math inline">\(res\)</span> array.</p>
<p><a href="https://leetcode.com/playground/tRcR8Lx3/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The complete <span class="math inline">\(doublenums\)</span> array(of size <span class="math inline">\(\text{2n}\)</span>) is scanned for all the elements of <span class="math inline">\(nums\)</span> in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(doublenums\)</span> array of size <span class="math inline">\(\text{2n}\)</span> is used. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(\text{n}\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force-accepted">Approach 2: Better Brute Force [Accepted]</h3>
<h4 id="algorithm-1">Algorithm</h4>
<p>Instead of making a double length copy of <span class="math inline">\(nums\)</span> array , we can traverse circularly in the <span class="math inline">\(nums\)</span> array by making use of the <span class="math inline">\( \text{modulus}\)</span> operator. For every element <span class="math inline">\(nums[i]\)</span>, we start searching in the <span class="math inline">\(nums\)</span> array(of length <span class="math inline">\(n\)</span>) from the index <span class="math inline">\((i+1)%n\)</span> and look at the next (circularly) <span class="math inline">\(n-1\)</span> elements. For <span class="math inline">\(nums[i]\)</span> we do so by scanning over <span class="math inline">\(nums[j]\)</span>, such that<br />
<span class="math inline">\((i+1)%n &leq; j &leq; (i+(n-1))%n\)</span>, and we look for the first greater element found. If no such element is found, we put a <span class="math inline">\(\text{-1}\)</span> at the appropriate position in the <span class="math inline">\(res\)</span> array.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/LCG759JD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. The complete <span class="math inline">\(nums\)</span> array of size <span class="math inline">\(n\)</span> is scanned for all the elements of <span class="math inline">\(nums\)</span> in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-stack-accepted">Approach 3: Using Stack [Accepted]</h3>
<h4 id="algorithm-2">Algorithm</h4>
<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from <span class="math inline">\(nums\)</span> array.  The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the <span class="math inline">\(nums\)</span> array. The description of the method will make the above statement clearer.</p>
<p>We start traversing the <span class="math inline">\(nums\)</span> array from right towards the left. For an element <span class="math inline">\(nums[i]\)</span> encountered, we pop all the elements<br />
<span class="math inline">\(stack[top]\)</span> from the stack such that <span class="math inline">\(nums\big[stack[top]\big] \le nums[i]\)</span>. We continue the popping till we encounter a <span class="math inline">\(stack[top]\)</span> satisfying <span class="math inline">\(nums\big[stack[top]\big] > nums[i]\)</span>. Now, it is obvious that the current <span class="math inline">\(stack[top]\)</span> only can act as the<br />
Next Greater Element for <span class="math inline">\(nums[i]\)</span>(right now, considering only the elements lying to the right of <span class="math inline">\(nums[i]\)</span>).</p>
<p>If no element remains on the top of the stack, it means no larger element than <span class="math inline">\(nums[i]\)</span> exists to its right. Along with this, we also push the index of the element just encountered(<span class="math inline">\(nums[i]\)</span>), i.e. <span class="math inline">\(i\)</span> over the top of the stack, so that <span class="math inline">\(nums[i]\)</span>(or <span class="math inline">\(stack[top]\)</span>) now acts as the Next Greater Element for the elements lying to its left.</p>
<p>We go through two such passes over the complete <span class="math inline">\(nums\)</span> array. This is done so as to complete a circular traversal over the <span class="math inline">\(nums\)</span> array. The first pass could make some wrong entries in the <span class="math inline">\(res\)</span> array since it considers only the elements lying to the right of <span class="math inline">\(nums[i]\)</span>, without a circular traversal. But, these entries are corrected in the second pass.</p>
<p>Further, to ensure the correctness of the method, let's look at the following cases.</p>
<p>Assume that <span class="math inline">\(nums[j]\)</span> is the correct Next Greater Element for <span class="math inline">\(nums[i]\)</span>, such that <span class="math inline">\(i < j &le; stack[top]\)</span>. Now, whenever we encounter <span class="math inline">\(nums[j]\)</span>, if <span class="math inline">\(nums[j] > nums\big[stack[top]\big]\)</span>, it would have already popped the previous <span class="math inline">\(stack[top]\)</span> and <span class="math inline">\(j\)</span> would have become the topmost element. On the other hand, if  <span class="math inline">\(nums[j] < nums\big[stack[top]\big]\)</span>, it would have become the topmost element by being pushed above the previous <span class="math inline">\(stack[top]\)</span>. In both the cases, if <span class="math inline">\(nums[j] > nums[i]\)</span>, it will be correctly determined to be the Next Greater Element.</p>
<p>The following example makes the procedure clear:</p>
<!--![Next_Greater_Element_II](../Figures/503_Next_Greater_Element_II.gif)-->
<p>!?!../Documents/503_Next_Greater2.json:1000,563!?!</p>
<p>As the animation above depicts, after the first pass, there are a number of wrong entries(marked as <span class="math inline">\(\text{-1}\)</span>) in the <span class="math inline">\(res\)</span> array, because only the elements lying to the corresponding right(non-circular) have been considered till now. But, after the second pass, the correct values are substituted.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/in37fqRd/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n)\)</span>. Only two traversals of the <span class="math inline">\(nums\)</span> array are done. Further, at most <span class="math inline">\(\text{2n}\)</span> elements are pushed and popped from the stack.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(n)\)</span>. A stack of size <span class="math inline">\(n\)</span> is used. <span class="math inline">\(res\)</span> array of size <span class="math inline">\(n\)</span> is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-iv/description" target="_blank" rel="noopener noreferrer">Next Greater Element IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of non-negative integers <code>nums</code>. For each integer in <code>nums</code>, you must find its respective <strong>second greater</strong> integer.</p>

<p>The <strong>second greater</strong> integer of <code>nums[i]</code> is <code>nums[j]</code> such that:</p>

<ul>
	<li><code>j &gt; i</code></li>
	<li><code>nums[j] &gt; nums[i]</code></li>
	<li>There exists <strong>exactly one</strong> index <code>k</code> such that <code>nums[k] &gt; nums[i]</code> and <code>i &lt; k &lt; j</code>.</li>
</ul>

<p>If there is no such <code>nums[j]</code>, the second greater integer is considered to be <code>-1</code>.</p>

<ul>
	<li>For example, in the array <code>[1, 2, 4, 3]</code>, the second greater integer of <code>1</code> is <code>4</code>, <code>2</code> is <code>3</code>,&nbsp;and that of <code>3</code> and <code>4</code> is <code>-1</code>.</li>
</ul>

<p>Return<em> an integer array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the second greater integer of </em><code>nums[i]</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,4,0,9,6]
<strong>Output:</strong> [9,6,6,-1,-1]
<strong>Explanation:</strong>
0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.
1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.
2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.
3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.
4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.
Thus, we return [9,6,6,-1,-1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3]
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong>
We return [-1,-1] since neither integer has any integer greater than it.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-node-in-linked-list/description" target="_blank" rel="noopener noreferrer">Next Greater Node In Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list with <code>n</code> nodes.</p>

<p>For each node in the list, find the value of the <strong>next greater node</strong>. That is, for each node, find the value of the first node that is next to it and has a <strong>strictly larger</strong> value than it.</p>

<p>Return an integer array <code>answer</code> where <code>answer[i]</code> is the value of the next greater node of the <code>i<sup>th</sup></code> node (<strong>1-indexed</strong>). If the <code>i<sup>th</sup></code> node does not have a next greater node, set <code>answer[i] = 0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg" style="width: 304px; height: 133px;" />
<pre>
<strong>Input:</strong> head = [2,1,5]
<strong>Output:</strong> [5,5,0]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg" style="width: 500px; height: 113px;" />
<pre>
<strong>Input:</strong> head = [2,7,4,3,5]
<strong>Output:</strong> [7,0,5,5,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We start by copying the individual node values in the linked list <code>head</code> into an array (let's call it <code>values</code>), which is easier to access and makes the problem a bit more intuitive.</p>
<p><img src="../Figures/1019/1019-1.png" alt="img" /></p>
<p>Now the problem becomes, for each value in the array, we need to find the next larger element on its right side.</p>
<hr />
<h3 id="approach-1-monotonic-stack">Approach 1: Monotonic Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with the most straightforward approach: brute force. That is, to iterate over all elements after <code>values[i]</code> until finding the first larger element for <code>values[i]</code>. This approach has two nested loops, so it may not pass all test cases.</p>
<p>Instead of using one iteration for each value, can we finish finding all the first larger values in a single traverse? The answer is YES!</p>
<p>Note that we are looking for the <strong>next</strong> greater value. If the value we are currently visiting (<code>values[i]</code>) is larger than the value <code>values[smaller]</code> on the top of the stack, we can pop <code>smaller</code> from the stack to prevent it from being visited again later, and let <code>values[i]</code> be <code>values[smaller]</code>'s next greater value.</p>
<p><img src="../Figures/1019/1019-ex.png" alt="img" /></p>
<p>When will the above process stop? When the stack is empty, or <code>values[i]</code> is not larger than the top element of the stack, we can safely push <code>i</code> to stack and move on to the next index <code>i + 1</code>. Similarly, if we encounter any value that is larger than <code>values[i]</code>, we can use it to pop <code>i</code> from the stack.</p>
<p>Since we want to set the next greater value for each index, we would better push the index <code>i</code> instead of the value <code>values[i]</code> to the stack, so that every time we pop an index from the stack, we can directly update the next greater value for this index. After the iteration over the array stops, indexes left in the stack stand for values that don't have such next greater values, we can just set their next greater values as 0.</p>
<p>Refer to the following slides as an example:</p>
<p>!?!../Documents/1019/s1.json:601,301!?!</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Traverse through the linked list <code>head</code>, and use an array <code>values</code> to store the values of nodes.</li>
<li>Initialize an array <code>answer</code> with the same size as <code>values</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>values</code>, before we push each index <code>i</code> to <code>stack</code>:
<ul>
<li>If the value represented by the top element of <code>stack</code> (let's call it <code>values[smaller]</code>) is smaller than <code>values[i]</code>, it means that <code>values[i]</code> is <code>values[smaller]</code>'s larger value. So we pop <code>smaller</code> from the <code>stack</code>, update <code>answer[smaller] = values[i]</code> and repeat this step.</li>
<li>Otherwise, it means there is no value smaller than <code>values[i]</code>, we add <code>values[i]</code> to stack and repeat step 3.</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8kCjQAdo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code> to record all values in <code>values</code>, it takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>We then iterate over <code>values</code> which takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>During the iteration, there may be multiple operations on the stack, however, each index is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We used an array <code>values</code> to store the values of eery node in <code>head</code> which takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>We used a stack <code>stack</code> to maintain a non-increasing sequence, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack-1-pass">Approach 2: Monotonic Stack, 1 Pass</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can further reduce the number of iterations. In the previous approach, we store node values from the linked list <code>head</code> into <code>values</code> by the first iteration and find the next greater value in the second iteration. Here we only use one iteration by recording the value from the <code>head</code> and updating <code>stack</code> in the same iteration step!</p>
<p>Compared to approach 1, the differences are as follows:</p>
<ul>
<li>We don't know the size of the linked list <code>head</code>, thus we can't initialize an array of equal size. Instead, we start with an empty array <code>answer</code> and increment its size during the iteration.</li>
<li>We don't use the array <code>values</code> to store all values from <code>head</code>, so we should store both the index and the value of each node to <code>stack</code>. Then we can get the value of each node from the index without referring to <code>values</code>.</li>
</ul>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an empty <code>answer</code> and an empty stack <code>stack</code> to store the previous indexes.</li>
<li>Iterate over <code>head</code> starting with index <code>i = 0</code>, for each current node, and compare the value of <code>head.val</code> with the element <code>[i, val]</code> on the top of the stack, if <code>head.val &gt; val</code>, pop the top element <code>[top_i, val]</code> from the stack and update <code>answer[top_i] = head.val</code>.</li>
<li>Push the <code>[i, head.val]</code> to the top of <code>stack</code>.</li>
<li>Add <code>0</code> to <code>answer</code>, which is the default next larger value for <code>head.val</code>.</li>
<li>Repeat step 2 until we finish the iteration.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/iRUQDkZx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the linked list <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over <code>head</code>. During the iteration, there may be multiple operations on the stack, however, each index <code>cnt</code> is pushed to and popped from the stack at most once, so the total time in the worst-case scenario is <span class="math inline">\(O(n)\)</span>.</li>
<li>Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We only used a stack <code>stack</code>, there may be up to <span class="math inline">\(n\)</span> elements in <code>stack</code> thus it also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-visible-people-in-a-queue/description" target="_blank" rel="noopener noreferrer">Number of Visible People in a Queue</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> people standing in a queue, and they numbered from <code>0</code> to <code>n - 1</code> in <strong>left to right</strong> order. You are given an array <code>heights</code> of <strong>distinct</strong> integers where <code>heights[i]</code> represents the height of the <code>i<sup>th</sup></code> person.</p>

<p>A person can <strong>see</strong> another person to their right in the queue if everybody in between is <strong>shorter</strong> than both of them. More formally, the <code>i<sup>th</sup></code> person can see the <code>j<sup>th</sup></code> person if <code>i &lt; j</code> and <code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>.</p>

<p>Return <em>an array </em><code>answer</code><em> of length </em><code>n</code><em> where </em><code>answer[i]</code><em> is the <strong>number of people</strong> the </em><code>i<sup>th</sup></code><em> person can <strong>see</strong> to their right in the queue</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg" style="width: 600px; height: 247px;" /></p>

<pre>
<strong>Input:</strong> heights = [10,6,8,5,11,9]
<strong>Output:</strong> [3,1,2,1,1,0]
<strong>Explanation:</strong>
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [5,1,2,3,10]
<strong>Output:</strong> [4,1,1,1,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == heights.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>
	<li>All the values of <code>heights</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/odd-even-jump/description" target="_blank" rel="noopener noreferrer">Odd Even Jump</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>arr</code>. From some starting index, you can make a series of jumps. The (1<sup>st</sup>, 3<sup>rd</sup>, 5<sup>th</sup>, ...) jumps in the series are called <strong>odd-numbered jumps</strong>, and the (2<sup>nd</sup>, 4<sup>th</sup>, 6<sup>th</sup>, ...) jumps in the series are called <strong>even-numbered jumps</strong>. Note that the <strong>jumps</strong> are numbered, not the indices.</p>

<p>You may jump forward from index <code>i</code> to index <code>j</code> (with <code>i &lt; j</code>) in the following way:</p>

<ul>
	<li>During <strong>odd-numbered jumps</strong> (i.e., jumps 1, 3, 5, ...), you jump to the index <code>j</code> such that <code>arr[i] &lt;= arr[j]</code> and <code>arr[j]</code> is the smallest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
	<li>During <strong>even-numbered jumps</strong> (i.e., jumps 2, 4, 6, ...), you jump to the index <code>j</code> such that <code>arr[i] &gt;= arr[j]</code> and <code>arr[j]</code> is the largest possible value. If there are multiple such indices <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
	<li>It may be the case that for some index <code>i</code>, there are no legal jumps.</li>
</ul>

<p>A starting index is <strong>good</strong> if, starting from that index, you can reach the end of the array (index <code>arr.length - 1</code>) by jumping some number of times (possibly 0 or more than once).</p>

<p>Return <em>the number of <strong>good</strong> starting indices</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,13,12,14,15]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.
From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.
From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.
From starting index i = 4, we have reached the end already.
In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of
jumps.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,3,1,1,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:
During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].
During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3
During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].
We can&#39;t jump from i = 3 to i = 4, so the starting index i = 0 is not good.
In a similar manner, we can deduce that:
From starting index i = 1, we jump to i = 4, so we reach the end.
From starting index i = 2, we jump to i = 3, and then we can&#39;t jump anymore.
From starting index i = 3, we jump to i = 4, so we reach the end.
From starting index i = 4, we are already at the end.
In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some
number of jumps.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,1,3,4,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can reach the end from starting indices 1, 2, and 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt; 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/online-stock-span/description" target="_blank" rel="noopener noreferrer">Online Stock Span</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Design an algorithm that collects daily price quotes for some stock and returns <strong>the span</strong> of that stock&#39;s price for the current day.</p>

<p>The <strong>span</strong> of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p>

<ul>
	<li>For example, if the prices of the stock in the last four days is <code>[7,2,1,2]</code> and the price of the stock today is <code>2</code>, then the span of today is <code>4</code> because starting from today, the price of the stock was less than or equal <code>2</code> for <code>4</code> consecutive days.</li>
	<li>Also, if the prices of the stock in the last four days is <code>[7,34,1,2]</code> and the price of the stock today is <code>8</code>, then the span of today is <code>3</code> because starting from today, the price of the stock was less than or equal <code>8</code> for <code>3</code> consecutive days.</li>
</ul>

<p>Implement the <code>StockSpanner</code> class:</p>

<ul>
	<li><code>StockSpanner()</code> Initializes the object of the class.</li>
	<li><code>int next(int price)</code> Returns the <strong>span</strong> of the stock&#39;s price given that today&#39;s price is <code>price</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]
[[], [100], [80], [60], [70], [60], [75], [85]]
<strong>Output</strong>
[null, 1, 1, 1, 2, 1, 4, 6]

<strong>Explanation</strong>
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price.
stockSpanner.next(85);  // return 6
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>next</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicate-letters/description" target="_blank" rel="noopener noreferrer">Remove Duplicate Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <span data-keyword="lexicographically-smaller-string"><strong>the smallest in lexicographical order</strong></span> among all possible results.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcabc&quot;
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbacdcbc&quot;
<strong>Output:</strong> &quot;acdb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1081: <a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-k-digits/description" target="_blank" rel="noopener noreferrer">Remove K Digits</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;1432219&quot;, k = 3
<strong>Output:</strong> &quot;1219&quot;
<strong>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;10200&quot;, k = 1
<strong>Output:</strong> &quot;200&quot;
<strong>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;10&quot;, k = 2
<strong>Output:</strong> &quot;0&quot;
<strong>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code></li>
	<li><code>num</code> consists of only digits.</li>
	<li><code>num</code> does not have any leading zeros except for the zero itself.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-nodes-from-linked-list/description" target="_blank" rel="noopener noreferrer">Remove Nodes From Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list.</p>

<p>Remove every node which has a node with a greater value anywhere to the right side of it.</p>

<p>Return <em>the </em><code>head</code><em> of the modified linked list.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png" style="width: 631px; height: 51px;" />
<pre>
<strong>Input:</strong> head = [5,2,13,3,8]
<strong>Output:</strong> [13,8]
<strong>Explanation:</strong> The nodes that should be removed are 5, 2 and 3.
- Node 13 is to the right of node 5.
- Node 13 is to the right of node 2.
- Node 8 is to the right of node 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1,1,1,1]
<strong>Output:</strong> [1,1,1,1]
<strong>Explanation:</strong> Every node has value 1, so no nodes are removed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the given list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the head of a linked list, the task is to remove every node that has a node with a greater value anywhere on its right side. This means that after processing the linked list, every node will only have nodes with smaller values to their right, or the linked list should be in decreasing order.</p>
<p><strong>Key Observations</strong></p>
<ol>
<li>The nodes in the linked list have positive values.</li>
<li>There may be duplicate values.</li>
<li>We manipulate the list by deleting values, not by sorting it.</li>
</ol>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>A challenge associated with this problem is that, for a given node, we need to not only delete the node directly to the right if it has a larger value but also delete all other nodes to the right that have larger values. The brute force approach involves iterating through the linked list using nested loops, comparing the value of each node with the nodes that follow it, and deleting any nodes whose values are smaller than the following nodes. However, this approach is inefficient, with a quadratic time complexity.</p>
<p>The resultant linked list should be in decreasing order. We can leverage this fact to develop a more efficient solution.</p>
<p>A list in decreasing order, if reversed, is in increasing order.</p>
<p>If we reverse the list, the node values should be in increasing order after deleting nodes. We can delete any nodes whose values are smaller than the nodes before them. This strategy ensures efficient deletion of all nodes that have nodes with a greater value to their right (in the original order) without using nested loops.</p>
<p>The list we are given is a singly linked list, so we can't easily traverse it in reverse from tail to head.</p>
<p>Whenever a problem requires reversing a sequence, it is worth considering using a stack.</p>
<p>Stacks are a First-In-Last-Out (FILO) data structure, meaning that the first items added to the stack are the last ones removed. Consequently, if you push a sequence of items into a stack and then remove them, the sequence will be reversed. Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
<p>We start by adding all of the nodes to a stack.</p>
<p>Next, we create a new linked list to store the result. We keep track of the maximum node value encountered so far using the variable <code>maximum</code>.</p>
<p>Then, we pop each node from the stack. If the node's value is not smaller than the <code>maximum</code>, we create a new node with that value and add it to the <code>resultList</code>. Since the linked list is reversed, we build the <code>resultList</code> from back to front, continuously adding new nodes to the beginning.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an empty <code>stack</code> to be used for reversing the nodes.</li>
<li>Set a pointer <code>current</code> to <code>head</code>.</li>
<li>While <code>current</code> is not <code>Null</code>:
<ul>
<li>Add <code>current</code> to the <code>stack</code>.</li>
<li>Set <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>Initialize a variable <code>maximum</code> to <code>current.val</code>.</li>
<li>Create a new ListNode <code>resultList</code> with <code>maximum</code> as its value.</li>
<li>While the <code>stack</code> is not empty:
<ul>
<li>Pop the node from the top of the <code>stack</code> and set <code>current</code> to that node.</li>
<li>If <code>current.val</code> &lt; <code>maximum</code>:
<ul>
<li>Continue; this node does not need to be added to the <code>resultList</code>.</li>
</ul>
</li>
<li>Otherwise, add a new node to the front of the <code>resultList</code>:
<ul>
<li>Create a new ListNode <code>newNode</code> with <code>current.val</code> as its value.</li>
<li>Set <code>newNode.next</code> to <code>resultList</code>.</li>
<li>Set <code>resultList</code> to <code>newNode</code>.</li>
<li>Update <code>maximum</code> to <code>current.val</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>resultList</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow2.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/2CTMtkxy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Adding the nodes from the original linked list to the stack takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Removing nodes from the stack and adding them to the result takes <span class="math inline">\(O(n)\)</span>, as each node is popped from the stack exactly once.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(2n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We add each of the nodes from the original linked list to the <code>stack</code>, making its size <span class="math inline">\(n\)</span>.</p>
<p>We only use <code>resultList</code> to store the result, so it does not contribute to the space complexity.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursion">Approach 2: Recursion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The nodes we retain in the linked list must meet the following criteria: Each node's value is not smaller than the values of the following nodes.</p>
<p>Linked lists are often manipulated using recursion. This problem is an excellent candidate for recursion because it can be broken down into subproblems that collectively solve the main problem.</p>
<p>Consider a node <span class="math inline">\(B\)</span> situated in the middle of the linked list, where all subsequent nodes have values less than or equal to <span class="math inline">\(B\)</span>'s value. If node <span class="math inline">\(B\)</span> satisfies this criterion, its value is not smaller than the values of the following nodes. For the node <span class="math inline">\(A\)</span> directly preceding <span class="math inline">\(B\)</span>, if <span class="math inline">\(A\)</span> is not smaller than <span class="math inline">\(B\)</span>, then <span class="math inline">\(A\)</span> is also not smaller than any nodes following <span class="math inline">\(B\)</span>. This holds due to the transitive property: if <span class="math inline">\(a \geq b\)</span> and <span class="math inline">\(b \geq c\)</span>, then <span class="math inline">\(a \geq c\)</span>.</p>
<p>This means that if we've solved the subproblem for nodes to the right of a given node in the linked list, we can efficiently solve the problem for that node.</p>
<p>Let`s begin by discussing the base cases:</p>
<ol>
<li>
<p>The linked list is empty:</p>
<ul>
<li>An empty list meets the criteria, so we return the <code>head</code>.</li>
</ul>
</li>
<li>
<p>The linked list has only one node:</p>
<ul>
<li>A list with one node also meets the criteria, because there are no following nodes. Again, we return the <code>head</code>.</li>
</ul>
</li>
</ol>
<p>We can develop a strategy for handling longer lists by thinking about handling a linked list with two nodes.</p>
<p>For a linked list with two nodes, there are two cases for the <code>head</code> node:</p>
<ol>
<li>
<p>The <code>head</code> node's value is the same size or larger than the next node's value.</p>
<ul>
<li>This linked list meets the criteria. Return the list.</li>
</ul>
</li>
<li>
<p>The <code>head</code> node's value is smaller than the next node's value.</p>
<ul>
<li>We need to delete <code>head</code>. Return the next node.</li>
</ul>
</li>
</ol>
<p>For linked lists with more than two nodes, the main adjustment we need to make is to check the rest of the linked list.</p>
<p>The challenge we face is ensuring that <code>head.next</code> is set to the correct next node. Does the next node also need to be deleted? Are there other nodes later in the linked list that have values that are greater than <code>head</code>?</p>
<p>Instead of simply setting <code>head</code> to <code>head.next</code> to progress to the next node, we recursively call <code>removeNodes(head.next)</code>. This recursive function removes nodes with greater values anywhere to the right. This ensures that <code>head</code> is set to the correct node and that the rest of the linked list also meets the criteria.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Base Case: If <code>head</code> or <code>head.next</code> is <code>Null</code>, return <code>head</code>.</li>
<li>Recursive Call: Set <code>nextNode</code> to <code>removeNodes(head.next)</code>.</li>
<li>Comparison: If <code>head.val</code> is less than <code>nextNode.val</code>, we need to remove <code>head</code>. Return <code>nextNode</code>.</li>
<li>Otherwise, set <code>head</code> to <code>head.next</code> and then return <code>head</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/L2EFsxaF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We call <code>removeNodes()</code> once for each node in the original linked list. The other operations inside the function all take constant time, so the time complexity is dominated by the recursive calls. Thus, the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Since we make <span class="math inline">\(n\)</span> recursive calls to <code>removeNodes()</code>, the call stack can grow up to size <span class="math inline">\(n\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-reverse-twice">Approach 3: Reverse Twice</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The first approach used a stack to reverse the linked list, resulting in linear auxiliary space. However, instead of using a stack, we can write a function to reverse the nodes in place, avoiding the need for auxiliary space. This task is explored in the problem <a href="https://leetcode.com/problems/reverse-linked-list/description/">Reverse Linked List</a>. The basic idea is to set each node's next field to point to the previous node.</p>
<p>After reversing the linked list, the node values will be in increasing order, allowing us to delete any nodes whose values are smaller than the nodes preceding them.</p>
<p>To facilitate this process, we maintain the maximum node value found so far using the variable <code>maximum</code>.</p>
<p>We traverse each node, <code>current</code>, in the reversed linked list and update the <code>maximum</code> value accordingly. If the value of the <code>current</code> node is smaller than the <code>maximum</code>, we delete <code>current</code>. Deleting nodes in place requires us to track the previous node so that we can correctly link it to the next node if we delete the <code>current</code> node.</p>
<p>Once we have traversed the linked list to delete the nodes, we have a linked list that is in increasing order.</p>
<p>However, since the desired result should be in decreasing order, we reverse the modified linked list and then return it.</p>
<blockquote>
<p><strong>Interview Tip: In-place Algorithms</strong></p>
<p>This approach modifies the input. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.</p>
<p>Here are a couple of situations where an in-place algorithm might not be suitable.</p>
<ol>
<li>
<p>The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.</p>
</li>
<li>
<p>Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</p>
</li>
</ol>
<p>In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Define a function <code>reverseList</code> that takes the head of a linked list as input and reverses it, returning the new head.
<ul>
<li>Initialize three pointers, <code>prev</code> to <code>null</code>, <code>current</code> to <code>head</code>, and <code>nextTemp</code> to <code>null</code>.</li>
<li>While <code>current</code> is not <code>null</code>:
<ul>
<li>Set <code>nextTemp</code> to <code>current.next</code>.</li>
<li>Reverse the order of the nodes by setting <code>current.next</code> to <code>prev</code>.</li>
<li>Progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>nextTemp</code>.</li>
</ul>
</li>
<li>Return <code>prev</code>.</li>
</ul>
</li>
<li>Reverse the original linked list using <code>reverseList(head)</code>. Set <code>head</code> to the reversed linked list.</li>
<li>Initialize a variable <code>maximum</code> to <code>0</code>.</li>
<li>Initialize two pointers, <code>prev</code> to <code>null</code> and <code>current</code> to <code>head</code>.</li>
<li>Delete the nodes that are smaller than the node before them. While <code>current</code> is not <code>null</code>:
<ul>
<li>Update <code>maximum</code> to the max between <code>maximum</code> and <code>current.val</code>.</li>
<li>If <code>current.val</code> is less than <code>maximum</code>, delete <code>current</code>.
<ul>
<li>Skip the current node by setting <code>prev.next</code> to <code>current.next</code>.</li>
<li>Set a pointer <code>deleted</code> to <code>current</code>.</li>
<li>Move <code>current</code> to <code>current.next</code> to progress to the next node.</li>
<li>Set <code>deleted.next</code> to <code>null</code> to remove any additional pointers to the new <code>current</code> node.</li>
</ul>
</li>
<li>Otherwise, if <code>current.val</code> is not less than <code>maximum</code>, retain <code>current</code> and progress both pointers by setting <code>prev</code> to <code>current</code> and <code>current</code> to <code>current.next</code>.</li>
</ul>
</li>
<li>Reverse and return the modified linked list using <code>reverseList(head)</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2487/2487_slideshow3.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/aq46D8sp/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the original linked list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Reversing the original linked list takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Traversing the reversed original linked list and removing nodes takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Reversing the modified linked list takes an additional <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(3n)\)</span>, which simplifies to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a few variables and pointers that use constant extra space. Since we don't use any data structures that grow with input size, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description" target="_blank" rel="noopener noreferrer">Shortest Subarray to be Removed to Make Array Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, remove a subarray (can be empty) from <code>arr</code> such that the remaining elements in <code>arr</code> are <strong>non-decreasing</strong>.</p>

<p>Return <em>the length of the shortest subarray to remove</em>.</p>

<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,10,4,2,3,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array is already non-decreasing. We do not need to remove any elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array <code>arr</code>, we want to return the size of the smallest possible subarray we can remove to make the remaining elements sorted in non-decreasing order. It's acceptable to return an empty subarray if the elements are already sorted correctly.</p>
<p><img src="../Figures/1574/shortest_subarray_to_be_removed.png" alt="Test cases split into 3 parts" /></p>
<p>We can think of <code>arr</code> as being composed of 3 parts. The first part is a block of numbers in sorted order (blue region in the image above), followed by a block of numbers that breaks the sorted order (yellow region), and then finally another block of numbers in sorted order (green region).</p>
<p>For the nontrivial cases depicted above, we know that the subarray to remove resides somewhere in the middle of the array. Here, there can be multiple possibilities for what the middle elements can be. For the first example in the image, one option is to remove the block <code>[2, 3, 10, 4]</code>, leaving the remaining sorted sequence <code>[1, 2, 3, 5]</code>. Another option is to remove the block <code>[10, 4, 2]</code>, leaving another valid sequence <code>[1, 2, 3, 3, 5]</code>. The question then boils down to how we can find the smallest middle block of numbers to remove.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the shortest subarray that, if removed, would make the array sorted. To do this, we must understand the problem from a few perspectives and break it down logically.</p>
<h5 id="1-identifying-the-longest-non-decreasing-subarrays">1. Identifying the Longest Non-Decreasing Subarrays</h5>
<p>The first thing to consider is that the array might already be mostly sorted, but just have a small portion that disrupts the order. This means that if we could find the longest part of the array that is already non-decreasing from the left and from the right, we would be left with just a small part in the middle that needs to be removed to make the entire array sorted.</p>
<p>The concept is to iterate through the array, looking for the longest continuous subarray that follows the non-decreasing order. We start from the left and move right, stopping when we hit a decrease. This is the first natural choice because if we can identify the longest subarray from the left, we know the part from the right must complement it or be the part we need to focus on.</p>
<p>Similarly, we do the same thing from the right side. This parallelism helps us understand both ends of the array and figure out where the sorting breaks down. These steps build on each other, showing us the boundaries within which we need to find the subarray to remove.</p>
<h5 id="2-the-case-where-the-array-is-already-sorted">2. The Case Where the Array is Already Sorted</h5>
<p>Now that we know how to find the longest non-decreasing subarrays from both ends, we need to think about the case where the array is already sorted. In this case, there’s no need to remove anything. So, we check if the left and right pointers (or indices) overlap or meet. If they do, the entire array is already sorted, and our work is done. This is an important insight because it helps us immediately return 0 when there’s no need to remove any subarray, avoiding unnecessary work.</p>
<h5 id="3-the-core-problem-what-to-remove">3. The Core Problem: What to Remove?</h5>
<p>If the array is not sorted, we are left with the task of determining the shortest subarray that can be removed to make the array sorted. We could remove just the left part, just the right part, or try merging the two non-decreasing sections.</p>
<p>Now, this might seem a bit tricky at first, but if we look closely, we can use the fact that if a section on the left is non-decreasing and a section on the right is also non-decreasing, there may still be a possibility of merging these sections by removing the middle. The relationship between the two sections plays a critical role. Specifically, we want to find a point where elements in the right section are greater than or equal to elements in the left section after considering the removal of the middle portion.</p>
<h5 id="4-the-final-search">4. The Final Search</h5>
<p>This leads us to the next part on how do we efficiently find where the two sections can merge? A naive approach might involve checking all pairs of elements, but that could be inefficient. Instead, we use binary search to find the smallest index in the right part of the array where the element is greater than or equal to the last element of the left part. By doing this, we can quickly pinpoint where the array can be &quot;joined&quot; back together, minimizing the subarray to remove.</p>
<p>This binary search approach leverages the sorted nature of the two subarrays. Since we know both the left and right subarrays are sorted, binary search allows us to find this boundary in logarithmic time, which is much more efficient than checking each element.</p>
<p>Finally, the solution is to take the minimum length of the subarrays that can be removed, whether that’s the left part, the right part, or the middle part (which we find through binary search).</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>arr</code>, <code>left</code> as 0, and <code>right</code> as <code>n - 1</code>.</p>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the left:</p>
<ul>
<li>While <code>left + 1 &lt; n</code> and <code>arr[left] &lt;= arr[left + 1]</code>, increment <code>left</code> to expand the left subarray.</li>
</ul>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the right:</p>
<ul>
<li>While <code>right - 1 &gt;= 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code> to expand the right subarray.</li>
</ul>
</li>
<li>
<p>If the entire array is already sorted (i.e., <code>left &gt;= right</code>), return <code>0</code> as no subarray removal is needed.</p>
</li>
<li>
<p>Initialize <code>ans</code> to the smaller of removing the left or right part completely:</p>
<ul>
<li><code>ans = min(n - (left + 1), right)</code></li>
</ul>
</li>
<li>
<p>Try to merge the left and right parts:</p>
<ul>
<li>For each index <code>i</code> from 0 to <code>left</code>, use binary search (<code>helperBinarySearch</code>) to find the smallest index <code>j</code> where <code>arr[j] &gt;= arr[i]</code>.</li>
<li>Update <code>ans</code> as the minimum of <code>ans</code> and the difference <code>j - (i + 1)</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>, the length of the shortest subarray that can be removed to make the array sorted.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/haaC2UUS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>The first two <code>while</code> loops each run in <span class="math inline">\(O(N)\)</span> time to find the longest non-decreasing subarrays from the left and right.</p>
<p>After that, the <code>for</code> loop iterates up to <code>N</code> times, where for each iteration, a binary search is performed. Since binary search runs in <span class="math inline">\(O(\log N)\)</span> time, the total time complexity for the loop is <span class="math inline">\(O(N \log N)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the <span class="math inline">\(O(N \log N)\)</span> component.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is mainly determined by the space required to store the input array <code>arr</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can optimize the solution further by replacing binary search (<span class="math inline">\(O(N \log N)\)</span>) with a more efficient two-pointer approach, reducing the complexity to <span class="math inline">\(O(N)\)</span>.</p>
<p>A key insight in the diagram below is that the unsorted yellow region must always be part of the removed subarray, as it breaks the sorted order. In other words, the remaining sorted array will always consist of a prefix of the blue subarray (from the first element up to some index), followed by a suffix of the green subarray (from the last element down to some index).</p>
<p><img src="../Figures/1574/two_pointers.png" alt="2 pointers" /></p>
<p>To consider all possibilities, use two pointers, <code>left</code> and <code>right</code>. The pointers represent the prefix blue array <code>arr[0:left]</code> and suffix green array <code>arr[right:]</code> consisting of the remaining sorted array we are considering. Initially, <code>left</code> is set to 0, meaning we’re considering keeping the first element of the blue array. <code>Right</code> is set to the index of the start of the green subarray, meaning we consider keeping the entirety of the green subarray.</p>
<p>Using this two-pointer method, for each position of <code>left</code>, we search for the smallest <code>right</code> where <code>arr[left] &lt;= arr[right]</code>. If this condition holds, then we have found a valid subarray candidate to remove—the subarray between <code>arr[left]</code> and <code>arr[right]</code>, which has a length of <code>right - left - 1</code>. If <code>arr[left] &gt; arr[right]</code>, we increment <code>right</code> to find the next possible match. Once a valid <code>right</code> is found, we advance <code>left</code> to the next element, repeating the process.</p>
<details>
  <summary>Why <code>arr[left] <= arr[right]</code> is Important (Click Here!)</summary>
  </br>
  <p><strong>Sorted Left Portion:</strong> The elements before left (i.e.,  <code>arr[0:left]</code>) are already sorted. Therefore,  <code>arr[left-1]</code> is the largest element in this prefix.</p>
  <p><strong>Sorted Right Portion:</strong> The elements from right onwards (i.e., <code>arr[right:]</code>) are sorted as well. Thus, <code>arr[right]</code> is the smallest element in the suffix.</p>
  <p>For the two sorted sections to form one valid sorted sequence when combined, we need the largest element in the left portion (<code>arr[left-1]</code>) to be less than or equal to the smallest element in the right portion (<code>arr[right]</code>), because:</p>
  <ul>
    <li>If <code>arr[left-1]</code> is greater than <code>arr[right]</code>, it means that after removing the unsorted middle section, the combined array would not be sorted.</li>
    <li>If <code>arr[left-1] <= arr[right]</code>, it guarantees that the largest element from the left side is smaller than or equal to the smallest element from the right side, ensuring the merged sequence is still sorted.</li>
  </ul>
</details>
</br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize our <code>right</code> pointer to the last index of <code>arr</code>.</li>
<li>We want to start our two-pointer process with <code>right</code> pointing to the start of the green sorted subarray. So we want to update <code>right</code> to the right index:
<ul>
<li>While <code>right &gt; 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code></li>
</ul>
</li>
<li>We initialize our <code>ans = right</code>. We note that the biggest subarray that can be removed is the entire subarray preceding <code>right</code>. Thus, the maximum size subarray to be removed is <code>right</code>.</li>
<li>We initialize our <code>left</code> pointer to <code>0</code>, the start of the blue sorted subarray.</li>
<li>While <code>left &lt; right</code> and <code>left</code> is still in the blue region: <code>left == 0 || arr[left - 1] &lt;= arr[left]</code>:
<ul>
<li>Find the right number after arr[left]:
<ul>
<li>While <code>right &lt; arr.length</code> and <code>arr[left] &gt; arr[right]</code>, increment <code>right</code></li>
</ul>
</li>
<li>Save length of the removed subarray: <code>ans = min(ans, right - left - 1)</code></li>
<li>Increment <code>left</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QgsqkvCG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>In the worst case for our two pointer algorithm, <code>left</code> will traverse through the entire blue sorted region once, and <code>right</code> will traverse through the entire <code>green</code> sorted region once. Thus, the time complexity grows linearly with the size of <code>arr</code>: <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use two pointers to store indices and do not have any auxiliary data structures, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-unsorted-continuous-subarray/description" target="_blank" rel="noopener noreferrer">Shortest Unsorted Continuous Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, you need to find one <b>continuous subarray</b> such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.</p>

<p>Return <em>the shortest such subarray and output its length</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,6,4,8,10,9,15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time complexity?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/description" target="_blank" rel="noopener noreferrer">Smallest K-Length Subsequence With Occurrences of a Letter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>, an integer <code>k</code>, a letter <code>letter</code>, and an integer <code>repetition</code>.</p>

<p>Return <em>the <strong>lexicographically smallest</strong> subsequence of</em> <code>s</code><em> of length</em> <code>k</code> <em>that has the letter</em> <code>letter</code> <em>appear <strong>at least</strong></em> <code>repetition</code> <em>times</em>. The test cases are generated so that the <code>letter</code> appears in <code>s</code> <strong>at least</strong> <code>repetition</code> times.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>A string <code>a</code> is <strong>lexicographically smaller</strong> than a string <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leet&quot;, k = 3, letter = &quot;e&quot;, repetition = 1
<strong>Output:</strong> &quot;eet&quot;
<strong>Explanation:</strong> There are four subsequences of length 3 that have the letter &#39;e&#39; appear at least 1 time:
- &quot;lee&quot; (from &quot;<strong><u>lee</u></strong>t&quot;)
- &quot;let&quot; (from &quot;<strong><u>le</u></strong>e<u><strong>t</strong></u>&quot;)
- &quot;let&quot; (from &quot;<u><strong>l</strong></u>e<u><strong>et</strong></u>&quot;)
- &quot;eet&quot; (from &quot;l<u><strong>eet</strong></u>&quot;)
The lexicographically smallest subsequence among them is &quot;eet&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="example-2" src="https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-subsequence.png" style="width: 339px; height: 67px;" />
<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, k = 4, letter = &quot;e&quot;, repetition = 2
<strong>Output:</strong> &quot;ecde&quot;
<strong>Explanation:</strong> &quot;ecde&quot; is the lexicographically smallest subsequence of length 4 that has the letter &quot;e&quot; appear at least 2 times.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bb&quot;, k = 2, letter = &quot;b&quot;, repetition = 2
<strong>Output:</strong> &quot;bb&quot;
<strong>Explanation:</strong> &quot;bb&quot; is the only subsequence of length 2 that has the letter &quot;b&quot; appear at least 2 times.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
	<li><code>letter</code> is a lowercase English letter, and appears in <code>s</code> at least <code>repetition</code> times.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/smallest-subsequence-of-distinct-characters/description" target="_blank" rel="noopener noreferrer">Smallest Subsequence of Distinct Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the </em><span data-keyword="lexicographically-smaller-string"><em>lexicographically smallest</em></span> <span data-keyword="subsequence-string"><em>subsequence</em></span><em> of</em> <code>s</code> <em>that contains all the distinct characters of</em> <code>s</code> <em>exactly once</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bcabc&quot;
<strong>Output:</strong> &quot;abc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbacdcbc&quot;
<strong>Output:</strong> &quot;acdb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<strong>Note:</strong> This question is the same as 316: <a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank">https://leetcode.com/problems/remove-duplicate-letters/</a></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/steps-to-make-array-non-decreasing/description" target="_blank" rel="noopener noreferrer">Steps to Make Array Non-decreasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked list</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one step, <strong>remove</strong> all elements <code>nums[i]</code> where <code>nums[i - 1] &gt; nums[i]</code> for all <code>0 &lt; i &lt; nums.length</code>.</p>

<p>Return <em>the number of steps performed until </em><code>nums</code><em> becomes a <strong>non-decreasing</strong> array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The following are the steps performed:
- Step 1: [5,<strong><u>3</u></strong>,4,4,7,<u><strong>3</strong></u>,6,11,<u><strong>8</strong></u>,<u><strong>5</strong></u>,11] becomes [5,4,4,7,6,11,11]
- Step 2: [5,<u><strong>4</strong></u>,4,7,<u><strong>6</strong></u>,11,11] becomes [5,4,7,11,11]
- Step 3: [5,<u><strong>4</strong></u>,7,11,11] becomes [5,7,11,11]
[5,7,11,11] is a non-decreasing array. Therefore, we return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,7,7,13]
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums is already a non-decreasing array. Therefore, we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/description" target="_blank" rel="noopener noreferrer">Subarray With Elements Greater Than Varying Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>threshold</code>.</p>

<p>Find any subarray of <code>nums</code> of length <code>k</code> such that <strong>every</strong> element in the subarray is <strong>greater</strong> than <code>threshold / k</code>.</p>

<p>Return<em> the <strong>size</strong> of <strong>any</strong> such subarray</em>. If there is no such subarray, return <code>-1</code>.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,3,1], threshold = 6
<strong>Output:</strong> 3
<strong>Explanation:</strong> The subarray [3,4,3] has a size of 3, and every element is greater than 6 / 3 = 2.
Note that this is the only valid subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,6,5,8], threshold = 7
<strong>Output:</strong> 1
<strong>Explanation:</strong> The subarray [8] has a size of 1, and 8 &gt; 7 / 1 = 7. So 1 is returned.
Note that the subarray [6,5] has a size of 2, and every element is greater than 7 / 2 = 3.5. 
Similarly, the subarrays [6,5,6], [6,5,6,5], [6,5,6,5,8] also satisfy the given conditions.
Therefore, 2, 3, 4, or 5 may also be returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-subarray-minimums/description" target="_blank" rel="noopener noreferrer">Sum of Subarray Minimums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers arr, find the sum of <code>min(b)</code>, where <code>b</code> ranges over every (contiguous) subarray of <code>arr</code>. Since the answer may be large, return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,2,4]
<strong>Output:</strong> 17
<strong>Explanation:</strong> 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [11,81,94,43,3]
<strong>Output:</strong> 444
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-subarray-ranges/description" target="_blank" rel="noopener noreferrer">Sum of Subarray Ranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code>. The <strong>range</strong> of a subarray of <code>nums</code> is the difference between the largest and smallest element in the subarray.</p>

<p>Return <em>the <strong>sum of all</strong> subarray ranges of </em><code>nums</code><em>.</em></p>

<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0 
[2], range = 2 - 2 = 0
[3], range = 3 - 3 = 0
[1,2], range = 2 - 1 = 1
[2,3], range = 3 - 2 = 1
[1,2,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,3]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 6 subarrays of nums are the following:
[1], range = largest - smallest = 1 - 1 = 0
[3], range = 3 - 3 = 0
[3], range = 3 - 3 = 0
[1,3], range = 3 - 1 = 2
[3,3], range = 3 - 3 = 0
[1,3,3], range = 3 - 1 = 2
So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,-2,-3,4,1]
<strong>Output:</strong> 59
<strong>Explanation:</strong> The sum of all subarray ranges of nums is 59.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow-up:</strong> Could you find a solution with <code>O(n)</code> time complexity?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Define the <strong>range</strong> of a subarray as the difference between the largest and smallest element in the subarray:</p>
<p><img src="../Figures/2104/2104-ex.png" alt="img" /></p>
<p>The task is to find the sum of all subarray ranges of the given array <code>nums</code>.</p>
<hr />
<h3 id="approach-1-two-loops">Approach 1: Two Loops</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's start with a brute force solution, that is, to find and iterate over all subarrays of <code>nums</code>, and get the sum of their ranges.</p>
<ol>
<li>Set <code>answer = 0</code>.</li>
<li>Iterate over every left index of subarrays <code>left</code>.</li>
<li>With every fixed <code>left</code>, iterate over every right index <code>right</code> of subarrays.</li>
<li>For each subarray <code>[left, right]</code>, iterate over it to find its minimum value <code>minVal</code> and maximum value <code>maxVal</code>.</li>
<li>Increment <code>answer</code> by <code>maxVal - minVal</code>.</li>
</ol>
<p>This approach contains three nested loops which make the time complexity quite high, so it may not pass all test cases. But we can consider this as a prompt for better approaches!</p>
<p>Note that for a fixed <code>left</code> index, two adjacent arrays only differ by one element. Suppose the previous array is <code>[left, right]</code> and the new array is <code>[left, right + 1]</code>, we can get the <code>minVal, maxVal</code> for the new subarray, by updating <code>minVal, maxVal</code> of the previous array using <code>nums[right + 1]</code>.</p>
<ul>
<li><code>minVal = min(minVal, nums[right + 1])</code></li>
<li><code>maxVal = max(maxVal, nums[right + 1])</code></li>
</ul>
<p>Therefore, the average time for finding the range of one subarray is reduced to <span class="math inline">\(O(1)\)</span>. Please refer to the following picture.</p>
<p><img src="../Figures/2104/2104-s2.png" alt="img" /></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Set <code>answer = 0</code>.</li>
<li>Iterate over every left index of subarrays <code>left</code>.</li>
<li>With every fixed <code>left</code>, initialize <code>minVal = maxVal = nums[left]</code>, iterate over every right index <code>right</code> of subarrays.</li>
<li>For each right index <code>right</code>, update <code>minVal</code> and <code>maxVal</code> by <code>nums[right]</code>. Then update <code>answer += maxVal - minVal</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fcRRFV5u/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>We have two nested iterations over <code>nums</code>.</li>
<li>In each step, we update <code>minVal, maxVal</code> and <code>answer</code>, it takes constant time.</li>
<li>To sum up, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>We only need to update three variables <code>minVal</code>, <code>maxVal</code> and <code>answer</code>.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>From the definition of the sum of all subarray ranges:</p>
<p><span class="math display">\[
> It implies that we can calculate these two partial sums separately.

Let's think of this problem differently, instead of finding each subarray and getting its `minVal` and `maxVal`, we focus on each number. If we can find that, for each number `nums[i]`, the number of subarrays having `nums[i]` as its **minimum value** is `minTime[i]`. Then the sum of `minVal` can be rewritten as:

$$\sum\limits_{k} minVal_{k} = \sum\limits_{i = 1}^{n} minTime[i]\ \cdot\ nums[i]$$

For example, we have found `minTime = [1, 4, 1]` for the array `[X, Y, Z]` by some means (which will be explained in detail soon), then the sum of `minVal` is `1 * X + 4 * Y + 1 * Z`. We don't need to know exactly which array holds which value as the minimum, but only the number of times each number is taken as the minimum!


> Now the task becomes finding `minTime[i]` for each index `i`.

Notice that `minTime[i]` depends on:

- The number of consecutive elements **larger than or equal to** `nums[i]` on its left side. In other words, to find the index `left` where the value is **less than** `nums[i]`.

- The number of consecutive elements **larger than or equal to** `nums[i]` on its right side. In other words, to find the index `right` where the value is **strictly less than** `nums[i]`.

Now we have (i - left) positions to put the starting position of the subarray, and (right - i) positions to put the ending position of the subarray. Therefore, we have (i - left) * (right - i) valid subarrays in total, so we can calculate `minTime[i]` as follows:

$$minTime[i] = (right - i) \cdot (i - left)$$
$$range_i = minTime[i] \cdot nums[i]$$

In the array shown below, `nums[3] = 4` has `left = 0` and `right = 6`, thus the number of subarrays having `nums[3]` as the minimum is `minTime[3] = (6 - 3) *  (3 - 0) = 9`, meaning that there are 9 subarays having `nums[3]` as the minimum.


![img](../Figures/2104/2104-stack1.png)



To calculate `minTime[i]` for every index, we can use a stack to maintain a monotonically increasing sequence during the iteration over `nums`:

- What is the left index `left`? The element on `nums[i]`'s left in the stack.

- What is the right index `right`? The element we are using to pop `nums[i]` from the stack. 

In other words, `minTime[i]` is not calculated when we add `nums[i]` to the stack, but when we **pop** `nums[i]` from the stack, because only then are the left and right indexes clear to us. Then we can calculate `minTime[i]` using: $$minTime[i] = (right - i) \cdot (i - left)$$. As shown in the picture below, when we encounter `nums[6] = 1`, we should pop `nums[3] = 4` from the stack, which is the time to calculate `minTime[3]`.

![img](../Figures/2104/2104-stack2.png)

> How to handle the edge cases?

- If the stack is empty after we pop `nums[i]` from it, we can't find the any index as the left boundary, so we set the left index as `-1`, which means that all the numbers on `nums[i]`'s left are within the range `[left, i]`.

- In order to pop the remaining elements from the stack after the iteration over `nums` stops, we set the right boundaries of all the remaining elements as `n`, which means that all the numbers on `nums[i]`'s right are within the range `[i, right]`. That's why we iterate from `i = 0` to `i = n`: to use `i = n` as the right boundary index to pop all the remaining elements from the stack.



> Will there by any duplicated calculation? 

One might think, what if there are identical values that are close or adjacent, do we double count any subarray? The answer is NO! Although several identical values `A` may be adjacent to each other, the subarrays of the previous `A` will never take the following `A` as their minimum. As shown in the picture below, subarrays using the first `4` as the minimum don't cross the second `4`, thus we won't double count any subarray!

![img](../Figures/2104/2104-edge.png)


> With each subproblem solved, we can move on to the results!

Please take the following slides as an example of getting the total sum of `minVal`. 

!?!../Documents/2104/s1.json:601,301!?!

Note that this iteration is to get the sum of `minVal`. We also need to find the sum of `maxVal` in a similar way, by reversing the comparison condition, then get the sum of ranges using the first equation in this chapter. The job is done!

> If you are not much familiar with stack, we suggest you read our [Leetcode Explore Card](https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/1369/) and have some knowledge of it beforehand.

<br>

#### Algorithm

1) Initialize an empty stack `stack`, get the size of `nums` as `n`.
2) Iterate over every index from `0` to `n` (inclusive). For each index `right`, if either of the following two condition is met: 
    - `index = n`
    - `stack` is not empty and `nums[mid] >= nums[right]`, where `mid` is its top value: 

    go to step 3.
    Otherwise, repeat step 2.
3) Calculate the number of subarrays with `nums[mid]` as its minimum value:
    - Pop `mid` from stack.
    - If `stack` is empty, set `left = -1`, otherwise, `left` equals the top element from `stack`.
    - Increment `answer` by `(right - mid) * (mid - left)`.
    - Repeat step 2.


#### Implementation

[code](https://leetcode.com/playground/2ENJNW6U/shared)


#### Complexity Analysis

Let $$n$$ be the size of the input array `nums`.

* Time complexity: $$O(n)$$

    - To find the total sum of `minVal`, we only need one iteration over `nums`, and each number will be added to and popped from `stack` once, these also apply for finding `maxVal`.
    - Therefore the overall time complexity is $$O(n)$$.
    

* Space complexity: $$O(n)$$

    - We use a (monotonic) stack to keep the increasing (decreasing) sequence, in the worst-case scenario, there may be $$O(n)$$ numbers in the stack, which takes $$O(n)$$ space. 


<br/>\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-total-strength-of-wizards/description" target="_blank" rel="noopener noreferrer">Sum of Total Strength of Wizards</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>As the ruler of a kingdom, you have an army of wizards at your command.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>strength</code>, where <code>strength[i]</code> denotes the strength of the <code>i<sup>th</sup></code> wizard. For a <strong>contiguous</strong> group of wizards (i.e. the wizards&#39; strengths form a <strong>subarray</strong> of <code>strength</code>), the <strong>total strength</strong> is defined as the <strong>product</strong> of the following two values:</p>

<ul>
	<li>The strength of the <strong>weakest</strong> wizard in the group.</li>
	<li>The <strong>total</strong> of all the individual strengths of the wizards in the group.</li>
</ul>

<p>Return <em>the <strong>sum</strong> of the total strengths of <strong>all</strong> contiguous groups of wizards</em>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>subarray</strong> is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> strength = [1,3,1,2]
<strong>Output:</strong> 44
<strong>Explanation:</strong> The following are all the contiguous groups of wizards:
- [1] from [<u><strong>1</strong></u>,3,1,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [3] from [1,<u><strong>3</strong></u>,1,2] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9
- [1] from [1,3,<u><strong>1</strong></u>,2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1
- [2] from [1,3,1,<u><strong>2</strong></u>] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4
- [1,3] from [<u><strong>1,3</strong></u>,1,2] has a total strength of min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [3,1] from [1,<u><strong>3,1</strong></u>,2] has a total strength of min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,2] from [1,3,<u><strong>1,2</strong></u>] has a total strength of min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [1,3,1] from [<u><strong>1,3,1</strong></u>,2] has a total strength of min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [3,1,2] from [1,<u><strong>3,1,2</strong></u>] has a total strength of min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [1,3,1,2] from [<u><strong>1,3,1,2</strong></u>] has a total strength of min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> strength = [5,4,6]
<strong>Output:</strong> 213
<strong>Explanation:</strong> The following are all the contiguous groups of wizards: 
- [5] from [<u><strong>5</strong></u>,4,6] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25
- [4] from [5,<u><strong>4</strong></u>,6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16
- [6] from [5,4,<u><strong>6</strong></u>] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36
- [5,4] from [<u><strong>5,4</strong></u>,6] has a total strength of min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [4,6] from [5,<u><strong>4,6</strong></u>] has a total strength of min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [5,4,6] from [<u><strong>5,4,6</strong></u>] has a total strength of min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-number-of-weak-characters-in-the-game/description" target="_blank" rel="noopener noreferrer">The Number of Weak Characters in the Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a game that contains multiple characters, and each of the characters has <strong>two</strong> main properties: <strong>attack</strong> and <strong>defense</strong>. You are given a 2D integer array <code>properties</code> where <code>properties[i] = [attack<sub>i</sub>, defense<sub>i</sub>]</code> represents the properties of the <code>i<sup>th</sup></code> character in the game.</p>

<p>A character is said to be <strong>weak</strong> if any other character has <strong>both</strong> attack and defense levels <strong>strictly greater</strong> than this character&#39;s attack and defense levels. More formally, a character <code>i</code> is said to be <strong>weak</strong> if there exists another character <code>j</code> where <code>attack<sub>j</sub> &gt; attack<sub>i</sub></code> and <code>defense<sub>j</sub> &gt; defense<sub>i</sub></code>.</p>

<p>Return <em>the number of <strong>weak</strong> characters</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> properties = [[5,5],[6,3],[3,6]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> No character has strictly greater attack and defense than the other.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> properties = [[2,2],[3,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The first character is weak because the second character has a strictly greater attack and defense.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> properties = [[1,5],[10,4],[4,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The third character is weak because the second character has a strictly greater attack and defense.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= properties.length &lt;= 10<sup>5</sup></code></li>
	<li><code>properties[i].length == 2</code></li>
	<li><code>1 &lt;= attack<sub>i</sub>, defense<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trapping-rain-water/description" target="_blank" rel="noopener noreferrer">Trapping Rain Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" style="width: 412px; height: 161px;" />
<pre>
<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> height = [4,2,0,3,2,5]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == height.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>