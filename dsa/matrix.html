<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matrix - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>matrix</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">362</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>ðŸ“‹ Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">01 Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">2D Hopscotch</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-2" class="toc-link">Addition of two square matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">Adventure in a Maze</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-4" class="toc-link">Anti Diagonal Traversal of Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-5" class="toc-link">As Far from Land as Possible</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Available Captures for Rook</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Battleships in a Board</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Binary Matrix with at most K 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-9" class="toc-link">Boolean Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-10" class="toc-link">Boundary Elements of Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-11" class="toc-link">Brackets in Matrix Chain Multiplication</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-12" class="toc-link">Bricks Falling When Hit</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Broken blocks</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-14" class="toc-link">Build a Matrix With Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Cat and Mouse II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Check if Every Row and Column Contains All Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Check if Grid Satisfies Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Check if Matrix Is X-Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Check if Move is Legal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link"> Check if There Is a Valid Parentheses String Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Check if There is a Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Check if Word Can Be Placed In Crossword</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Check Knight Tour Configuration</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Cherry Pickup</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Cherry Pickup II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Coins of Geekland</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-27" class="toc-link">Coloring A Border</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Column Sum in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-29" class="toc-link">Compute Before Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-30" class="toc-link">Construct 2D Grid Matching Graph Layout</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-31" class="toc-link">Construct Product Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Construct Quad Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Contain Virus</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Convert 1D Array Into 2D Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Count Cells in Overlapping Horizontal and Vertical Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-36" class="toc-link">Count Fertile Pyramids in a Land</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Count Islands With Total Value Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">Count Negative Numbers in a Sorted Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Count number of free cell</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-40" class="toc-link">Count Occurrences in a Fully Sorted Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-41" class="toc-link">Count pairs Sum in matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-42" class="toc-link">Count Paths With the Given XOR Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Count Servers that Communicate</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-44" class="toc-link">Count Sorted Rows</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-45" class="toc-link">Count Square Submatrices with All Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Count Sub Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Count Submatrices With All Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-48" class="toc-link">Count Submatrices With Equal Frequency of X and Y</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Count Submatrices with Top-Left Element and Sum Less Than k</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-50" class="toc-link">Count Unguarded Cells in the Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Count zeros in a sorted matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-52" class="toc-link">Coverage of all Zeros in a Binary Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-53" class="toc-link">Create a spiral matrix of N*M size from given array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-54" class="toc-link">Cut Off Trees for Golf Event</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Cyclically Rotating a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Delete Greatest Value in Each Row</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Design Neighbor Sum Service</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Design Spreadsheet</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Detect Cycles in 2D Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-60" class="toc-link">Determinant of a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-61" class="toc-link">Determine Whether Matrix Can Be Obtained By Rotation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Diagonal sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-63" class="toc-link">Diagonal Traverse</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Difference Between Ones and Zeros in Row and Column</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Difference of Number of Distinct Values on Diagonals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Disconnect Path in a Binary Matrix by at Most One Flip</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Distance of nearest cell having 1</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-68" class="toc-link">Dungeon Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Equal Row and Column Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-70" class="toc-link">Equal Sum Grid Partition I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-71" class="toc-link">Equal Sum Grid Partition II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Escape the Spreading Fire</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Exit Point in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-74" class="toc-link">Expectation</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-75" class="toc-link">Fill a Special Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Find a Good Subset of the Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Find All Groups of Farmland</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Find all possible paths from top to bottom</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-79" class="toc-link">Find a Peak Element II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Find a Safe Walk Through a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-81" class="toc-link">Find Champion I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Find difference between sum of diagonals</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-83" class="toc-link">Find duplicate rows in a binary matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-84" class="toc-link">Find kth element of spiral matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-85" class="toc-link">Find Kth Largest XOR Coordinate Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">Find Minimum Time to Reach Last Room I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Find Minimum Time to Reach Last Room II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Find Missing and Repeated Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Find number of closed islands</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-90" class="toc-link">Find perimeter of shapes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-91" class="toc-link">Find rectangle with corners as 1</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-92" class="toc-link">Find the Grid of Region Average</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Find the Kth Smallest Sum of a Matrix With Sorted Rows</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Find the Maximum Number of Fruits Collected</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Find the Minimum Area to Cover All Ones I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Find the Minimum Area to Cover All Ones II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Find the Peak Element in a 2D Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-98" class="toc-link">Find the Safest Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Find the string in grid</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-100" class="toc-link">Find the String with LCP</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Find the Width of Columns of a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Find Valid Matrix Given Row and Column Sums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Find whether path exist</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-104" class="toc-link">Find Winner on a Tic Tac Toe Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">First Completely Painted Row or Column</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Flip Columns For Maximum Number of Equal Rows</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Flipping an Image</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Flip Square Submatrix Vertically</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Flood Fill</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Flood fill Algorithm</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-111" class="toc-link">Form coils in a matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-112" class="toc-link">Game of Life</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Geeks Island</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-114" class="toc-link">Geek&#39;s Village and Wells</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-115" class="toc-link">Generalised Fibonacci numbers</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-116" class="toc-link">Generate a matrix with each row and column of given sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-117" class="toc-link">Get Biggest Three Rhombus Sums in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Grid Game</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Grid Path 2</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-120" class="toc-link">Grid Teleportation Traversal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Help a Thief!!!</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-122" class="toc-link">Identical Matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-123" class="toc-link">Image Overlap</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Image Smoother</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Increment Submatrices by One</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-126" class="toc-link">Interchanging the rows of a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-127" class="toc-link">Island Perimeter</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Is Sudoku Valid</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-129" class="toc-link">K Highest Ranked Items Within a Price Range</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Knight in Geekland</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-131" class="toc-link">Kronecker Product</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-132" class="toc-link">Kth smallest element in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-133" class="toc-link">Kth Smallest Element in a Sorted Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Largest 1-Bordered Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Largest Local Values in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Largest Magic Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Largest rectangle of 1s with swapping of columns allowed</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-138" class="toc-link">Largest rectangular sub-matrix whose sum is 0</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-139" class="toc-link">Largest Square with Sum at Most K</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-140" class="toc-link">Largest Submatrix With Rearrangements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Largest subsquare surrounded by X</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-142" class="toc-link">Last cell in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-143" class="toc-link">Last Day Where You Can Still Cross</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Length of Longest V-Shaped Diagonal Segment</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Let&#39;s Play!!!</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-146" class="toc-link">Letters Collection</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-147" class="toc-link">Longest Increasing Path in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Longest Possible Route in a Matrix with Hurdles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-149" class="toc-link">Lucky Numbers in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Magic Square</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-151" class="toc-link">Magic Squares In Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Make a Square with the Same Color</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Make Matrix Beautiful</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-154" class="toc-link">Make Zeroes</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-155" class="toc-link">Making A Large Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">Making A Large Island</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-157" class="toc-link">Map of Highest Peak</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-158" class="toc-link">Matrix Block Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Matrix Boundary Traversal</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-160" class="toc-link">Matrix Cells in Distance Order</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-161" class="toc-link">Matrix Chain Multiplication</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-162" class="toc-link">Matrix Diagonal Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-163" class="toc-link">Matrix Exponentiation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-164" class="toc-link">Matrix Game - 1</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-165" class="toc-link">Matrix Operations</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-166" class="toc-link">Matrix Similarity After Cyclic Shifts</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-167" class="toc-link">Max Area of Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Maximal Rectangle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Maximal Square</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Maximum Amount of Money Robot Can Earn</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Maximum Difference Score in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Maximum Matrix Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-173" class="toc-link">Maximum Non Negative Product in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Maximum no of 1&#39;s row</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-175" class="toc-link">Maximum Number of coins</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-176" class="toc-link">Maximum Number of Fish in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Maximum Number of Moves in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Maximum Number of Points From Grid Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Maximum Number of Points with Cost</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-180" class="toc-link">Maximum path sum in matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-181" class="toc-link">Maximum Points Tourist Can Earn</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Maximum Rows Covered by Columns</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-183" class="toc-link">Maximum Score From Grid Operations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-184" class="toc-link">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-185" class="toc-link">Maximum Spending After Buying Items</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Maximum Strictly Increasing Cells in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Maximum Students Taking Exam</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Maximum Sum of an Hourglass</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Maximum sum of hour glass</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-190" class="toc-link">Maximum sum Rectangle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-191" class="toc-link">Maximum Sum With at Most K Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-192" class="toc-link">Maximum Trailing Zeros in a Cornered Path</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-193" class="toc-link">Maximum Value Sum by Placing Three Rooks I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-194" class="toc-link">Maximum Value Sum by Placing Three Rooks II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">Max Increase to Keep City Skyline</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Max  rectangle</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-197" class="toc-link">Max Sum of Rectangle No Larger Than K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-198" class="toc-link">Median in a row-wise sorted Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-199" class="toc-link">Minesweeper</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-200" class="toc-link">Minimize the Difference Between Target and Chosen Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Minimum Absolute Difference in Sliding Submatrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-202" class="toc-link">Minimum Cost Path with Alternating Directions II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-203" class="toc-link">Minimum Cost to Connect Two Groups of Points</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-204" class="toc-link">Minimum Cost to Make at Least One Valid Path in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-205" class="toc-link">Minimum Falling Path Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-206" class="toc-link">Minimum Falling Path Sum II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-207" class="toc-link">Minimum Moves to Clean the Classroom</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-208" class="toc-link">Minimum Moves to Move a Box to Their Target Location</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-209" class="toc-link">Minimum Moves to Reach Target with Rotations</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-210" class="toc-link">Minimum Moves to Spread Stones Over Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-211" class="toc-link">Minimum Number of Days to Disconnect Island</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-212" class="toc-link">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-213" class="toc-link">Minimum Number of Flips to Make Binary Grid Palindromic I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-214" class="toc-link">Minimum Number of Flips to Make Binary Grid Palindromic II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-215" class="toc-link">Minimum Number of Operations to Satisfy Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-216" class="toc-link">Minimum Number of Visited Cells in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-217" class="toc-link">Minimum Obstacle Removal to Reach Corner</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-218" class="toc-link">Minimum Operations to Make a Uni-Value Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-219" class="toc-link">Minimum Operations to Make Columns Strictly Increasing</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-220" class="toc-link">Minimum Operations to Write the Letter Y on a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-221" class="toc-link">Minimum Path Cost in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-222" class="toc-link">Minimum Path Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-223" class="toc-link">Minimum Swaps to Arrange a Binary Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-224" class="toc-link">Minimum Time to Visit a Cell In a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-225" class="toc-link">Missing number in matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-226" class="toc-link">Modify the Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-227" class="toc-link">Most Frequent Prime</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-228" class="toc-link">Multiply 2 matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-229" class="toc-link">Multiply Matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-230" class="toc-link">Multiply the matrices</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-231" class="toc-link">Nearest Exit from Entrance in Maze</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-232" class="toc-link">Number of Closed Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-233" class="toc-link">Number of Enclaves</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-234" class="toc-link">Number Of Enclaves</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-235" class="toc-link">Number of Increasing Paths in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-236" class="toc-link">Number of Islands</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-237" class="toc-link">Number of Laser Beams in a Bank</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-238" class="toc-link">Number of Palindromic paths in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-239" class="toc-link">Number of paths in a matrix with k coins</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-240" class="toc-link">Number of Paths with Max Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-241" class="toc-link">Number of Submatrices That Sum to Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-242" class="toc-link">Number of submatrix have sum X</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-243" class="toc-link">Number of Ways of Cutting a Pizza</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-244" class="toc-link">Pacific Atlantic Water Flow</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-245" class="toc-link">Paths in Matrix Whose Sum Is Divisible by K</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-246" class="toc-link">Paths to reach origin</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-247" class="toc-link">Path with Maximum Gold</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-248" class="toc-link">Path With Minimum Effort</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-249" class="toc-link">Predict the Column</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-250" class="toc-link">Prefix Sum of Matrix (Or 2D Array)</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-251" class="toc-link">Prime In Diagonal</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-252" class="toc-link">Primitive Typing</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-253" class="toc-link">Print Diagonally</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-254" class="toc-link">Printing patterns</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-255" class="toc-link">Print matrix in diagonal pattern</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-256" class="toc-link">Print Matrix in snake Pattern</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-257" class="toc-link">Projection Area of 3D Shapes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-258" class="toc-link">Queens That Can Attack the King</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-259" class="toc-link">Queries on a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-260" class="toc-link">Range Sum Query 2D - Immutable</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-261" class="toc-link">Rank Transform of a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-262" class="toc-link">Rat Maze With Multiple Jumps</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-263" class="toc-link">Reconstruct a 2-Row Binary Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-264" class="toc-link">Regions Cut By Slashes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-265" class="toc-link">Replace O&#39;s with X&#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-266" class="toc-link">Reshape the Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-267" class="toc-link">Retroactive Integers</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-268" class="toc-link">Reverse Spiral Form of Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-269" class="toc-link">Reversing the columns of a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-270" class="toc-link">Rhezo and Special Gift</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-271" class="toc-link">Richest Customer Wealth</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-272" class="toc-link">Rohan&#39;s Love for Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-273" class="toc-link">Rotate a Matrix by 180 Counterclockwise</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-274" class="toc-link">Rotate by 90 degree</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-275" class="toc-link">Rotate Each Row of Matrix K Times</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-276" class="toc-link">Rotate Image</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-277" class="toc-link">Rotate matrix elements clockwise</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-278" class="toc-link">Rotating the Box</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-279" class="toc-link">Rotten Oranges</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-280" class="toc-link">Rotting Oranges</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-281" class="toc-link">Row Sum in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-282" class="toc-link">Row with max 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-283" class="toc-link">Row with Max 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-284" class="toc-link">Row With Maximum Ones</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-285" class="toc-link">Row with Minimum 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-286" class="toc-link">Save The Nation</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-287" class="toc-link">Score After Flipping Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-288" class="toc-link">Search a 2D Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-289" class="toc-link">Search a 2D Matrix II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-290" class="toc-link">Search in a  Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-291" class="toc-link">Search in a Row-Column sorted matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-292" class="toc-link">Search in a row-wise sorted matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-293" class="toc-link">Search in a sorted Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-294" class="toc-link">Search in fully rotated sorted 2D matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-295" class="toc-link">Select Cells in Grid With Maximum Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-296" class="toc-link">Set Matrix Zeroes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-297" class="toc-link">Set Matrix Zeros</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-298" class="toc-link">Shift 2D Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-299" class="toc-link">Shortest Bridge</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-300" class="toc-link">Shortest Distance in a Binary Maze</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-301" class="toc-link">Shortest Path by Removing K walls</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-302" class="toc-link">Shortest Path in a Grid with Obstacles Elimination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-303" class="toc-link">Shortest Path in Binary Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-304" class="toc-link">Shortest Path to Get All Keys</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-305" class="toc-link">Shortest Source to Destination Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-306" class="toc-link">Sliding Puzzle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-307" class="toc-link">Snakes and Ladders</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-308" class="toc-link">Solve the Sudoku</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-309" class="toc-link">Sort a 2D vector diagonally</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-310" class="toc-link">Sorted matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-311" class="toc-link">Sort Matrix by Diagonals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-312" class="toc-link">Sort the Matrix Diagonally</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-313" class="toc-link">Sort the Students by Their Kth Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-314" class="toc-link">Special Positions in a Binary Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-315" class="toc-link">Spirally traversing a matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-316" class="toc-link">Spiral Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-317" class="toc-link">Spiral Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-318" class="toc-link">Spiral Matrix II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-319" class="toc-link">Spiral Matrix III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-320" class="toc-link">Spiral Matrix IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-321" class="toc-link">Squares in a Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-322" class="toc-link">Stamping the Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-323" class="toc-link">Starting Point</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-324" class="toc-link">Strange Printer II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-325" class="toc-link">Subrectangle Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-326" class="toc-link">Sudoku Solver</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-327" class="toc-link">Sum in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-328" class="toc-link">Summed Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-329" class="toc-link">Sum of a series</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-330" class="toc-link">Sum of elements in a matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-331" class="toc-link">Sum of upper and lower triangles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-332" class="toc-link">Sums of i-th row and i-th column</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-333" class="toc-link">Surface Area of 3D Shapes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-334" class="toc-link">Surrounded Regions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-335" class="toc-link">Surround the 1&#39;s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-336" class="toc-link">Swap  diagonals</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-337" class="toc-link">Swapping Triangles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-338" class="toc-link">Swim in Rising Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-339" class="toc-link">The K Weakest Rows in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-340" class="toc-link">The Palindrome Pattern</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-341" class="toc-link">Toeplitz matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-342" class="toc-link">Toeplitz Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-343" class="toc-link">Trace Path</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-344" class="toc-link">Transform to Chessboard</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-345" class="toc-link">Transpose Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-346" class="toc-link">Transpose of Matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-347" class="toc-link">Trapping Rain Water II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-348" class="toc-link">Travelling Salesman Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-349" class="toc-link">Turtle&#39;s Path</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-350" class="toc-link">Unique Paths II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-351" class="toc-link">Unique Paths III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-352" class="toc-link">Unique Paths in a Grid</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-353" class="toc-link">Unique rows in boolean matrix</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-354" class="toc-link">Valid Sudoku</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-355" class="toc-link">Valid Tic-Tac-Toe State</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-356" class="toc-link">Water Overflow</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-357" class="toc-link">Where Will the Ball Fall</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-358" class="toc-link">Word Search</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-359" class="toc-link">Word Search II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-360" class="toc-link">Zeus and Fibonacci</a> <span class="toc-platform">HackerEarth</span></li>
<li><a href="#question-361" class="toc-link">Zigzag Grid Traversal With Skip</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/01-matrix/description" target="_blank" rel="noopener noreferrer">01 Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, return <em>the distance of the nearest </em><code>0</code><em> for each cell</em>.</p>

<p>The distance between two cells sharing a common edge is <code>1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[0,0,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[1,1,1]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[1,2,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one <code>0</code> in <code>mat</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 1765: <a href="https://leetcode.com/problems/map-of-highest-peak/description/" target="_blank">https://leetcode.com/problems/map-of-highest-peak/</a></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/hopscotch4857/1" target="_blank" rel="noopener noreferrer">2D Hopscotch</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">cpp</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Aakriti, Avantika and Mehak are playing 2D Hopscotch. The arena is in the form of a n*m 2D matrix. But the position of the cells is slightly modified as shown below.&nbsp;<br />
<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/hopscotch-1.jpg" /></p>

<p>Mehak starts the game from tile (i,j) while Avantika and Aakriti direct her. In each turn Mehak will collect all the stones present (1 or 2) steps away from where she is standing. Avantika can direct Mehak to take 1 step and and Aakriti can direct Mehak to take 2 steps.&nbsp;<br />
If the director ty is known to you as ty = 0 being Avantika and 1 being Aakriti, find the number of stones that Mehak will collect.&nbsp;</p>

<p><br />
<strong>Example 1:</strong></p>

<pre>
<strong>Input: </strong>
n = 3, m = 3
mat = {{5, 9, 7}, 
       {6, 4, 5}, 
       {8, 1, 2}}
ty = 0, 
i = 1, j = 1
<strong>Output:</strong> 31
<strong>Explaination: </strong>
ty=0, so Avantika is the director. 
ie- Mehak will move only one step in 
any direction to collect the stones.
(0,1), (1,0), (1,2), (2,1), (2,2), (2,0) 
are at a distance of 1 from (1,1). 
Adding them 9+6+5+8+1+2=31.</pre>

<p><br />
<strong>Example 2:</strong></p>

<pre>
<strong>Input: </strong>
n = 3, m = 3
mat = {{5, 9, 7}, 
       {6, 4, 5}, 
       {8, 1, 2}}
ty = 1, 
i = 1, j = 1
<strong>Output:</strong> 12
<strong>Explaination: </strong>
ty=1, so Aakriti is the director. 
ie- Mehak can move 2 steps. 
(0,0) and (0,2) are the only tiles that 
are at a distance of two from (1,1). 
Adding them gives 5+7=12.</pre>

<p><br />
<strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>hopscotch() </strong>which takes n, m, mat, ty, i and j as input parameters and returns the number of collected stones.</p>

<p><br />
<strong>Expected Time Complexity:</strong> O(1)<br />
<strong>Expected Auxiliary Space: </strong>O(1)</p>

<p><br />
<strong>Constraints:</strong><br />
1 &le; n, m &le; 1000000<br />
0 &le; i &lt; n<br />
0 &le; j &lt; m&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/addition-of-two-square-matrices4916/1" target="_blank" rel="noopener noreferrer">Addition of two square matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two square matrices, a[][] and b[][], each of size n x n. Your task is to compute the sum of these two matrices and store the result in the matrix a[][] itself.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>a[][] = [[1, 2], [3, 4]],
       b[][] = [[4, 3], [2, 1]]
<strong>Output: </strong>[[5, 5], [5, 5]]<br /><strong>Explanation:</strong> The will be: [[5, 5], [5, 5]] on adding the corresponding elements of both matrices.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>a[][] = [[7, 8], [9, 10]],
       b[][] = [[1, 2], [3, 4]]
<strong>Output: </strong></span><span style="font-size: 18px;">[[8, 10], [12, 14]]<br /><strong>Explanation:</strong> The result will be </span><span style="font-size: 14pt;">[[8, 10], [12, 14]] after adding the corresponding elements of both matrices</span><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.</span>&nbsp;</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/adventure-in-a-maze2051/1" target="_blank" rel="noopener noreferrer">Adventure in a Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You have got&nbsp;a maze, which is a n*n&nbsp;Grid. Every cell of the maze contains these numbers 1, 2 or 3.&nbsp;<br />If it contains&nbsp;</span><span style="font-size: 18px;">1 :</span><span style="font-size: 18px;"> means we can go Right from that cell only.<br />If it contains&nbsp;</span><span style="font-size: 18px;">2 :</span><span style="font-size: 18px;"> means we can go Down from that cell only.<br />If it contains&nbsp;</span><span style="font-size: 18px;">3 :</span><span style="font-size: 18px;"> means we can go Right and Down to both paths from that cell.</span><br /><span style="font-size: 18px;">We cant go out of the maze at any time.<br />Initially, You are on the Top Left Corner of The maze(Entry). And, You need to go to the Bottom Right Corner of the Maze(Exit).<br />You need to find the total number of paths from Entry to Exit Point.<br />There may be many paths but you need to select that path which contains the maximum number of Adventure.<br />The Adventure on a path is calculated by taking the sum of all the cell values thatlies</span><span style="font-size: 18px;"> in the path.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>matrix = {{1,1,3,2,1},{3,2,2,1,2},
{1,3,3,1,3},{1,2,3,1,2},{1,1,1,3,1}}
<strong>Output: </strong>{4,18}
<strong>Explanation: </strong>There are total 4 Paths Available 
out of which The Max Adventure is 18. Total 
possible Adventures are 18,17,17,16. Of these 
18 is the maximum.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>FindWays()&nbsp;</strong>which takes matrix as input parameter and returns a list containg total number of ways to reach at (n, n) modulo 10<sup>9</sup>&nbsp;+ 7 and maximum number of Adventure.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n<sup>2</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-diagonally1623/1" target="_blank" rel="noopener noreferrer">Anti Diagonal Traversal of Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">misc</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Give a N*N square <strong>matrix</strong>, return an array of its <strong>anti-diagonals </strong>in top-leftmost to bottom-rightmost order. In an element of a <strong>anti-diagonal (i, j)</strong>, surrounding elements will be <strong>(i+1, j-1)</strong> and <strong>(i-1, j+1)</strong>. Look at the examples for more clarity.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 2
matrix[][] = 1 2<br />            3 4
<strong>Output:</strong>
1 2 3 4
<strong>Explanation:</strong>
List of anti-diagnoals in order is<br />{1}, {2, 3}, {4}</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 3
matrix[][] = 3 2 3<br />            4 5 1<br />            7 8 9<br /><strong>Output:</strong>
3 2 4 3 5 7 1 8 9</span></pre>
<pre><strong>Explanation:</strong>
List of anti-diagnoals in order is<br />{3}, {2, 4}, {3, 5, 7}, {1, 8}, {9}</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You dont need to read input or print anything. Complete the function <strong>antiDiagonal</strong><strong>Pattern()</strong> that takes <strong>matrix </strong>as input parameter and returns a <strong>list of integers </strong>in order of the values visited in the anti-Diagonal&nbsp;pattern.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N * N)<br /><strong>Expected Auxiliary Space:</strong> O(N * N)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 100<br />0 &lt;= mat[i][j] &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/as-far-from-land-as-possible/description" target="_blank" rel="noopener noreferrer">As Far from Land as Possible</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> <code>grid</code>&nbsp;containing only values <code>0</code> and <code>1</code>, where&nbsp;<code>0</code> represents water&nbsp;and <code>1</code> represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.&nbsp;If no land or water exists in the grid, return <code>-1</code>.</p>

<p>The distance used in this problem is the Manhattan distance:&nbsp;the distance between two cells <code>(x0, y0)</code> and <code>(x1, y1)</code> is <code>|x0 - x1| + |y0 - y1|</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/1336_ex1.JPG" style="width: 185px; height: 87px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,1],[0,0,0],[1,0,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The cell (1, 1) is as far as possible from all the land with distance 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/05/03/1336_ex2.JPG" style="width: 184px; height: 87px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The cell (2, 2) is as far as possible from all the land with distance 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>
	<li><code>grid[i][j]</code>&nbsp;is <code>0</code> or <code>1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/available-captures-for-rook/description" target="_blank" rel="noopener noreferrer">Available Captures for Rook</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>8 x 8</code> <strong>matrix</strong> representing a chessboard. There is <strong>exactly one</strong> white rook represented by <code>&#39;R&#39;</code>, some number of white bishops <code>&#39;B&#39;</code>, and some number of black pawns <code>&#39;p&#39;</code>. Empty squares are represented by <code>&#39;.&#39;</code>.</p>

<p>A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece <em>or</em> the edge of the board. A rook is <strong>attacking</strong> a pawn if it can move to the pawn&#39;s square in one move.</p>

<p>Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.</p>

<p>Return the <strong>number of pawns</strong> the white rook is <strong>attacking</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_1_improved.PNG" style="width: 300px; height: 305px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>In this example, the rook is attacking all the pawns.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/19/1253_example_2_improved.PNG" style="width: 300px; height: 306px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The bishops are blocking the rook from attacking any of the pawns.</p>
</div>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_3_improved.PNG" style="width: 300px; height: 305px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The rook is attacking the pawns at positions b5, d6, and f5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 8</code></li>
	<li><code>board[i].length == 8</code></li>
	<li><code>board[i][j]</code> is either <code>&#39;R&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;B&#39;</code>, or <code>&#39;p&#39;</code></li>
	<li>There is exactly one cell with <code>board[i][j] == &#39;R&#39;</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/battleships-in-a-board/description" target="_blank" rel="noopener noreferrer">Battleships in a Board</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix <code>board</code> where each cell is a battleship <code>&#39;X&#39;</code> or empty <code>&#39;.&#39;</code>, return <em>the number of the <strong>battleships</strong> on</em> <code>board</code>.</p>

<p><strong>Battleships</strong> can only be placed horizontally or vertically on <code>board</code>. In other words, they can only be made of the shape <code>1 x k</code> (<code>1</code> row, <code>k</code> columns) or <code>k x 1</code> (<code>k</code> rows, <code>1</code> column), where <code>k</code> can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img height="333" src="https://assets.leetcode.com/uploads/2024/06/21/image.png" width="333" />
<pre>
<strong>Input:</strong> board = [[&quot;X&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = [[&quot;.&quot;]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>board[i][j]</code> is either <code>&#39;.&#39;</code> or <code>&#39;X&#39;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you do it in one-pass, using only <code>O(1)</code> extra memory and without modifying the values <code>board</code>?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-square-in-a-binary-matrix-with-at-most-k-1s-for-multiple-queries/1" target="_blank" rel="noopener noreferrer">Binary Matrix with at most K 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">divideandconquer</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix <strong>M</strong> with <strong>R </strong>rows and <strong>C</strong> columns, where each element of the matrix will be 0 or 1. Find the largest square that can be formed with center <strong>(i, j)</strong> and contains atmost <strong>K</strong> 1s. There are Q queries, a single query has two integers denoting the centre (i,j) of the square.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>R = 4, C = 5
M = {{1, 0, 1, 0, 0}&nbsp;
     {1, 0, 1, 1, 1}&nbsp;
     {1, 1, 1, 1, 1}&nbsp;
     {1, 0, 0, 1, 0}}
K = 9, Q = 1
q_i[] = {1}
q_j[] = {2}
<strong>Output:
</strong>3
<strong>Explanation:</strong>
Maximum length square with center
at (1, 2)&nbsp;that can be formed is of
3 length from (0, 1) to (2, 3).</span>
</pre>
<div><span style="font-size: 18px;"><strong>Example 2:</strong></span></div>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>R = 3, C = 3
M = {{1, 1, 1}&nbsp;
     {1, 1, 1}&nbsp;
     {1, 1, 1}}
K = 9, Q = 2
q_i[] = {1, 2}
q_j[] = {1, 2}
<strong>Output :</strong>
3 1</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>largestSquare()</strong>&nbsp;which takes 2 integers R, and C followed by a list of lists M denoting the binary matrix and then three integers i,j, and K as input and returns a list of integers denting the largest Square possible for each query.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(R*C + Q*log(MIN_DIST)), <br /></span><span style="font-size: 18px;"><strong>Expected Auxiliary Space:</strong> O(R*C)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; R,C &le; 500<br />1 &le; Q &le; 10<sup>4</sup><br />0 &le; K &le; R*C<br />0 &le; i &lt; R<br />0 &le; j &lt; C</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/boolean-matrix-problem-1587115620/1" target="_blank" rel="noopener noreferrer">Boolean Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a boolean matrix <strong>mat[],</strong> where each cell contains either 0 or 1, modify it such that if a matrix cell matrix[i][j] is 1 then all the cells in its i</span><sup>th</sup><span style="font-size: 18px;">&nbsp;row and j</span><sup>th</sup><span style="font-size: 18px;">&nbsp;column will become 1.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">mat</span>[][] = [[1, 0], [0, 0]]
<strong>Output: </strong>[[1, 1], [1, 0]] </span>
<span style="font-size: 18px;"><strong>Explanation: </strong>Only cell that has 1 is at (0,0) so all cells in row 0 are modified to 1 and all cells in column 0 are modified to 1.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">mat</span>[][] = [[1, 0, 0], [1, 0, 0], [1, 0, 0], [0, 0, 0]]</span>
<span style="font-size: 18px;"><strong>Output: </strong>[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 0, 0]]</span>
<span style="font-size: 18px;"><strong>Explanation: </strong>The position of cells that have 1 in the original matrix are (0, 0), (1, 0) and (2, 0). Therefore, all cells in row 0, 1, 2 are and column 0 are modified to 1. </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">mat</span>[][] = [[0, 0], [0, 0]]
<strong>Output: </strong>[[0, 0], [0, 0]] </span>
<span style="font-size: 18px;"><strong>Explanation: </strong>There is no cell that contains 1, so mat[] will remain the same.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size(), mat[0].size() &le; 10<sup>3</sup><br />0 &le; mat[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/boundary-elements-of-matrix1102/1" target="_blank" rel="noopener noreferrer">Boundary Elements of Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an <strong>n</strong><strong>xn</strong>&nbsp;matrix .In the given matrix, you have to find&nbsp;the <strong>boundary&nbsp;elements</strong> of the matrix.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>[[1, 2, 3] 
&nbsp;       [4, 5, 6] 
        [7, 8, 9]]
<strong>Output: </strong>1 2 3 4 6 7 8 9</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: [[</strong>1, 2]
        [3, 4]]
<strong>Output: </strong>1 2 3 4</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anything. Your task is to complete the function&nbsp;<strong>BoundaryElements()</strong>&nbsp;which takes matrix as input parameter and returns a list containing the boundary elements of the matrix in the same order in which they appear in the input matrix.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br />
<strong>Expected Space Complexity:&nbsp;</strong>O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n &lt;= 100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/brackets-in-matrix-chain-multiplication1024/1" target="_blank" rel="noopener noreferrer">Brackets in Matrix Chain Multiplication</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;of length&nbsp;<strong>n&nbsp;</strong>used to denote the dimensions of a series of&nbsp;<strong>matrices</strong>&nbsp;such that the dimension of&nbsp;<strong>i'th</strong>&nbsp;matrix is&nbsp;<strong>arr[i] * arr[i+1]</strong>. There are a total of&nbsp;<strong>n-1</strong>&nbsp;matrices. Find the most efficient way to multiply these matrices together.&nbsp;<br />As in&nbsp;<a href="https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/" target="_blank" rel="noopener"><em><strong>MCM</strong></em></a>, you were returning the most effective count but this time return the&nbsp;<strong>string</strong>&nbsp;which is formed of&nbsp;<strong>A - Z&nbsp;</strong>(only Uppercase) denoting matrices &amp;&nbsp;<strong>Brackets</strong>(&nbsp;<strong>"("</strong>&nbsp;<strong>")"</strong>&nbsp;) denoting multiplication symbols. For example, if n =11, the matrixes can be denoted as A - K as n&lt;=26 &amp; brackets as multiplication symbols.</span></p>
<p><span style="font-size: 14pt;"><strong>NOTE:</strong></span></p>
<ol>
<li><span style="font-size: 14pt;">Each multiplication is denoted by putting&nbsp;<strong>open &amp; closed</strong>&nbsp;brackets to the matrices multiplied &amp; also, please note that the order of matrix multiplication matters, as matrix multiplication is non-commutative&nbsp;<strong>A*B != B*A</strong></span></li>
<li><span style="font-size: 18.6667px;">As there can be&nbsp;</span><strong style="font-size: 18.6667px;">multiple</strong><span style="font-size: 18.6667px;"> possible answers, the console would print "</span><strong style="font-size: 18.6667px;">true</strong><span style="font-size: 18.6667px;">" for the&nbsp;</span><strong style="font-size: 18.6667px;">correct</strong><span style="font-size: 18.6667px;"> string and "</span><strong style="font-size: 18.6667px;">false</strong><span style="font-size: 18.6667px;">" for the&nbsp;</span><strong style="font-size: 18.6667px;">incorrect</strong><span style="font-size: 18.6667px;">&nbsp;string. You need to only return a&nbsp;</span><strong style="font-size: 18.6667px;">string</strong><span style="font-size: 18.6667px;">&nbsp;that performs a minimum number of multiplications.</span></li>
</ol>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr[] = [40, 20, 30, 10, 30]
<strong>Output:</strong> true
<strong>Explanation:</strong> Let's divide this into matrix(only 4 are possible) </span><span style="font-size: 14pt;">[ [40, 20] -&gt; A</span><span style="font-size: 14pt;">, [20, 30] -&gt; B, [30, 10] -&gt;C, [10, 30] -&gt; D ]<br />First we perform multiplication of B &amp; C -&gt; (BC), then we multiply A to (BC) -&gt; (A(BC)), then we multiply D to (A(BC)) -&gt; ((A(BC))D)<br />so the solution returned the string <strong>((A(BC))D)</strong>,</span> <span style="font-size: 14pt;">which performs minimum multiplications. The total number of multiplications are 20*30*10 + 40*20*10 + 40*10*30 = 26,000.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> arr[] = [10, 20, 30]
</span><strong style="font-size: 14pt;">Output:</strong><span style="font-size: 14pt;"> true
</span><strong style="font-size: 14pt;">Explanation:</strong><span style="font-size: 14pt;"> </span>There is only one way to multiply two matrices: (AB): The cost for the multiplication will be 6000
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr = [3, 3, 3]
<strong>Output:</strong> true
<strong>Explanation:</strong> The solution returned the string <strong>(AB)</strong>, which performs minimum multiplications. The total number of multiplications are (3*3*3) = 27.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />2 &le; arr.size() &le; 26&nbsp;<br />1 &le; arr[i] &le; 100&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bricks-falling-when-hit/description" target="_blank" rel="noopener noreferrer">Bricks Falling When Hit</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary <code>grid</code>, where each <code>1</code> represents a brick and <code>0</code> represents an empty space. A brick is <strong>stable</strong> if:</p>

<ul>
	<li>It is directly connected to the top of the grid, or</li>
	<li>At least one other brick in its four adjacent cells is <strong>stable</strong>.</li>
</ul>

<p>You are also given an array <code>hits</code>, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location <code>hits[i] = (row<sub>i</sub>, col<sub>i</sub>)</code>. The brick on that location&nbsp;(if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will <strong>fall</strong>. Once a brick falls, it is <strong>immediately</strong> erased from the <code>grid</code> (i.e., it does not land on other stable bricks).</p>

<p>Return <em>an array </em><code>result</code><em>, where each </em><code>result[i]</code><em> is the number of bricks that will <strong>fall</strong> after the </em><code>i<sup>th</sup></code><em> erasure is applied.</em></p>

<p><strong>Note</strong> that an erasure may refer to a location with no brick, and if it does, no bricks drop.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
<strong>Output:</strong> [2]
<strong>Explanation: </strong>Starting with the grid:
[[1,0,0,0],
 [<u>1</u>,1,1,0]]
We erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,<u>1</u>,<u>1</u>,0]]
The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:
[[1,0,0,0],
 [0,0,0,0]]
Hence the result is [2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
<strong>Output:</strong> [0,0]
<strong>Explanation: </strong>Starting with the grid:
[[1,0,0,0],
 [1,<u>1</u>,0,0]]
We erase the underlined brick at (1,1), resulting in the grid:
[[1,0,0,0],
 [1,0,0,0]]
All remaining bricks are still stable, so no bricks fall. The grid remains the same:
[[1,0,0,0],
 [<u>1</u>,0,0,0]]
Next, we erase the underlined brick at (1,0), resulting in the grid:
[[1,0,0,0],
 [0,0,0,0]]
Once again, all remaining bricks are still stable, so no bricks fall.
Hence the result is [0,0].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>hits[i].length == 2</code></li>
	<li><code>0 &lt;= x<sub>i&nbsp;</sub>&lt;= m - 1</code></li>
	<li><code>0 &lt;=&nbsp;y<sub>i</sub> &lt;= n - 1</code></li>
	<li>All <code>(x<sub>i</sub>, y<sub>i</sub>)</code> are unique.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-reverse-time-and-union-find-accepted">Approach #1: Reverse Time and Union-Find [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>The problem is about knowing information about the connected components of a graph as we cut vertices.  In particular, we'll like to know the size of the &quot;roof&quot; (component touching the top edge) between each cut.  Here, a cut refers to the erasure of a vertex.</p>
<p>As we may know, a useful data structure for joining connected components is a disjoint set union structure.  The key idea in this problem is that we can use this structure if we work in reverse: instead of looking at the graph as a series of sequential cuts, we'll look at the graph after all the cuts, and reverse each cut.</p>
<p><strong>Algorithm</strong></p>
<p>We'll modify our typical disjoint-set-union structure to include a <code>dsu.size</code> operation, that tells us the size of this component.  The way we do this is whenever we make a component point to a new parent, we'll also send it's size to that parent.</p>
<p>We'll also include <code>dsu.top</code>, which tells us the size of the &quot;roof&quot;, or the component connected to the top edge.  We use an <em>ephemeral</em> &quot;source&quot; node with label <code>R * C</code> where all nodes on the top edge (with row number <code>0</code>) are connected to the source node.</p>
<p>For more information on DSU, please look at <em>Approach #2</em> in the <a href="https://leetcode.com/articles/redundant-connection/">article here</a>.</p>
<p>Next, we'll introduce <code>A</code>, the grid after all the cuts have happened, and initialize our disjoint union structure on the graph induced by <code>A</code> (nodes are grid squares with a brick; edges between 4-directionally adjacent nodes).</p>
<p>After, if we get an cut at <code>(r, c)</code> but the original <code>grid[r][c]</code> was always <code>0</code>, then we couldn't have had a meaningful cut - the number of dropped bricks is <code>0</code>.</p>
<p>Otherwise, we'll look at the size of the new roof after adding this brick at <code>(r, c)</code>, and compare them to find the number of dropped bricks.</p>
<p>Since we were working in reverse time order, we should reverse our working answer to arrive at our final answer.</p>
<p><a href="https://leetcode.com/playground/Lna6PTkh/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N \cdot \alpha(N))\)</span>, where <span class="math inline">\(N = R \cdot C\)</span> is the number of grid squares, and <span class="math inline">\(\alpha\)</span> is the <a href="https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Inverse-Ackermann function</a>. We will insert at most <span class="math inline">\(N\)</span> nodes into the disjoint-set data structure which will require <span class="math inline">\(O(N \cdot \alpha(N))\)</span> time.  There will also be at most <span class="math inline">\(Q\)</span> hits where we must add a brick into the disjoint-set data structure which will require <span class="math inline">\(O(Q \cdot \alpha(N))\)</span> time. Since each hit location is unique, <span class="math inline">\(Q\)</span> must be less than or equal to <span class="math inline">\(N\)</span>, so we can simplify the time complexity to <span class="math inline">\(O(N \cdot \alpha(N))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/broken-blocks0022/1" target="_blank" rel="noopener noreferrer">Broken blocks</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">In the game of Broken Blocks, the player is allowed to move on <strong>m x n</strong>&nbsp;blocks i.e. <strong>m&nbsp;</strong>levels and <strong>n&nbsp;</strong>stone blocks on each level such that one level is vertically above the previous level (as in a staircase), with some of its stone blocks replaced by wooden blocks.<br />The player at the start of the game is present on the ground level (which should&nbsp;be considered as level 0 or it can be considered as level -1). The player can start from <strong>any</strong> of the blocks present on the <strong>level 0</strong> and start moving further to next levels. The player can only move to the stone-block just above to the present stone-block or diagonally to the left or to the right. The player cant move on the same level.<br />If the player steps on any of the wooden block (denoted by <strong>-1</strong>), he will fall off the board and die as the wood-block will not able to hold players weight. Each of the stone-block has some gold coins present on it (wooden blocks doesnt have any coins on them). If at any point the player cant move to further level due to any reason, the game ends and his present total coin score will be considered.<br />The players aim is to collect as many gold coins as he can without falling off the board.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>matrix = {{2,5,6},{-1,3,2},{4,-1,5}}
<strong>Output: </strong>14
<strong>Explanation: </strong>Assume 0-based indexing.The matrix 
is:
2 5 6 (level 0)
-1 3 2 (level 1)
4 -1 5 (lever 2)
The player can collect maximum number of coins 
by moving through:matrix[0][2] + matrix[1][1] 
+ matrix[2][2] = 6 + 3 + 5 = 14 coins.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>matrix = {{-1,2,3,4},{5,-1,-1,2},
{4,3,-1,-1}}
<strong>Output: </strong>11
<strong>Explanation: </strong></span><span style="font-size: 18px;">The matrix is:
-1 2 3 4(level 0)
5 -1 -1 2(level 1)
4 3 -1 1(level 2)
The player can collect maximum number of coins 
by moving through:a[0][1] + a[1][0] + a[2][0] 
= 2 + 5 + 4 = 11 coins.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>MaxGold()&nbsp;</strong>which takes matrix as input parameter and returns the maximum number of gold coins.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints</strong></span></p>
<p><span style="font-size: 18px;">1&lt;=n,m&lt;=1000</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m)</span><br /><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong>&nbsp;O(1)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/build-a-matrix-with-conditions/description" target="_blank" rel="noopener noreferrer">Build a Matrix With Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>positive</strong> integer <code>k</code>. You are also given:</p>

<ul>
	<li>a 2D integer array <code>rowConditions</code> of size <code>n</code> where <code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>, and</li>
	<li>a 2D integer array <code>colConditions</code> of size <code>m</code> where <code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>.</li>
</ul>

<p>The two arrays contain integers from <code>1</code> to <code>k</code>.</p>

<p>You have to build a <code>k x k</code> matrix that contains each of the numbers from <code>1</code> to <code>k</code> <strong>exactly once</strong>. The remaining cells should have the value <code>0</code>.</p>

<p>The matrix should also satisfy the following conditions:</p>

<ul>
	<li>The number <code>above<sub>i</sub></code> should appear in a <strong>row</strong> that is strictly <strong>above</strong> the row at which the number <code>below<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>n - 1</code>.</li>
	<li>The number <code>left<sub>i</sub></code> should appear in a <strong>column</strong> that is strictly <strong>left</strong> of the column at which the number <code>right<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>m - 1</code>.</li>
</ul>

<p>Return <em><strong>any</strong> matrix that satisfies the conditions</em>. If no answer exists, return an empty matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png" style="width: 211px; height: 211px;" />
<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
<strong>Output:</strong> [[3,0,0],[0,0,1],[0,2,0]]
<strong>Explanation:</strong> The diagram above shows a valid example of a matrix that satisfies all the conditions.
The row conditions are the following:
- Number 1 is in row <u>1</u>, and number 2 is in row <u>2</u>, so 1 is above 2 in the matrix.
- Number 3 is in row <u>0</u>, and number 2 is in row <u>2</u>, so 3 is above 2 in the matrix.
The column conditions are the following:
- Number 2 is in column <u>1</u>, and number 1 is in column <u>2</u>, so 2 is left of 1 in the matrix.
- Number 3 is in column <u>0</u>, and number 2 is in column <u>1</u>, so 3 is left of 2 in the matrix.
Note that there may be multiple correct answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
<strong>Output:</strong> []
<strong>Explanation:</strong> From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.
No matrix can satisfy all the conditions, so we return the empty matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= 400</code></li>
	<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>
	<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>
	<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>
	<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>
	<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer <code>k</code> and two 2D integer arrays <code>rowConditions</code> and <code>colConditions</code>. The constructed matrix's size should be <code>k x k</code> containing each value from <code>1</code> to <code>k</code> exactly once. <code>rowConditions</code> contains tuples of the form: <code>[above, below]</code> for every index <code>i</code>, which denotes that the integer <code>above</code> should appear in a row strictly above the integer <code>below</code>. Similarly, in <code>colConditions</code>, the tuples are of the form <code>[left, right]</code> and denote that <code>left</code> should appear in a column strictly to the left of <code>right</code>. We need to return any matrix that satisfies these conditions.</p>
<p>Let's say that <code>rowConditions</code> is given by <code>[1,2],[2,3],[3,4]</code> for <code>k=4</code>. This implies that 1 should appear above 2, 2 should appear above 3, and 3 should appear above 4 in the matrix. Therefore, <code>[1,2,3,4]</code> is the only solution possible for the row arrangement. Now, observe that any possible column arrangement can be used to create this row solution i.e. if we have found the solution arrays for rows and columns we can merge them to create the desired matrix.</p>
<p>Therefore, we can solve this problem for rows and columns, by calculating their solutions independently and then merging those solutions in a matrix as given above. Let's try to calculate the solution array for <code>rowConditions</code> first by representing the information in the form of a graph:</p>
<ul>
<li>Let <code>G(V,E)</code> represent directed, unweighted graphs.</li>
<li>Each value from <code>1</code> to <code>k</code> would represent a vertex in the graph.</li>
<li>The edges are modeled after the prerequisite relationship between the numbers. So, a pair <code>[a,b]</code> in the <code>rowConditions</code> array means <code>a</code> must appear before <code>b</code>. The graph represents this as a directed edge <code>a âž” b</code>.</li>
<li>If the graph would be acyclic, then an ordering would always be possible. Since it's mentioned that such an ordering may not always be possible, we may have a cyclic graph.</li>
</ul>
<p>We are trying to order nodes based on the edges such that if <code>a-&gt;b</code> is an edge, <code>a</code> must appear before <code>b</code> in the ordering. Such an ordering of subjects is referred to as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorted Order</a>. There are two approaches that we will be looking at in this article to solve this problem.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>During depth-first traversal in a graph, starting from node <code>A</code>, DFS explores all paths stemming from <code>A</code> before completing its recursion for <code>A</code> and moving to other nodes. Consequently, all nodes in these paths have <code>A</code> as an ancestor, making <code>A</code> a prerequisite for all paths originating from it.</p>
<p>Now, we know how to get all the integers that have a particular integer as a prerequisite. If a valid ordering of integers is possible, the node <code>A</code> would come before all the other sets of integers that have it as a prerequisite. This idea for solving the problem can be explored using a depth-first search.</p>
<p>Initialize a recursive function given by <code>dfs</code> where the recursive stack will contain the topologically sorted order of the nodes in our graph.</p>
<p>For each node in our graph, we will run a depth-first search in case that node was not already visited in some other node's DFS traversal. Once the processing of all the neighbors is done, we will add this node to the stack. We are using the recursion stack to simulate the ordering we need.</p>
<p>Once all the nodes have been processed, we will return the nodes as they are returned in the recursion stack from top to bottom.</p>
<p>Now that we have topologically sorted arrays for both <code>rowConditions</code> and <code>colConditions</code>, how can we utilize them to construct the matrix? Each row and column should correspond to their respective sorted arrays. Therefore, the value at position <code>matrix[i][j]</code> is derived from <code>rowConditions[i]</code> and <code>colConditions[j]</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions,k)</code> and <code>topoSort(colConditions,k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create a <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] == orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges,n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, and an empty array <code>order</code>. Also, initialize a <code>visited</code> array and a boolean <code>hasCycle</code> variable with <code>false</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> denoting an edge from <code>a</code> to <code>b</code>.</li>
<li>For all nodes with an index from <code>1</code> to <code>n</code>:
<ul>
<li>If the current node is not visited, perform <code>dfs(i, adj, visited, order, hasCycle)</code>. If the <code>hasCycle</code> value is <code>true</code>, return an empty array.</li>
</ul>
</li>
<li>Reverse the <code>order</code> array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p><strong><code>dfs(node, adj, visited, order, hasCycle)</code></strong></p>
<ol>
<li>Set <code>visited[node]</code> to <code>1</code>.</li>
<li>Iterate over all neighbors of <code>node</code>:
<ul>
<li>If <code>visited[neighbor] == 0</code>, perform <code>dfs(neighbor, adj, visited, order, hasCycle)</code>. If <code>hasCycle</code> is true, return.</li>
<li>If <code>visited[neighbor] == 1</code>, set <code>hasCycle</code> to true, return.</li>
</ul>
</li>
<li>Set <code>visited[node]</code> as <code>2</code>.</li>
<li>Push <code>node</code> in <code>order</code> array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HcR3PUwv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>. The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-kahns-algorithm">Approach 2: Kahn's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Kahnâ€™s algorithm works by keeping track of the number of incoming edges into each node (in-degree). It works by repeatedly visiting the nodes with an in-degree of zero and deleting all the edges associated with it leading to a decrement of in-degree for the nodes whose incoming edges are deleted. This process continues until no elements with zero in-degree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>After constructing the graph, we can push all the nodes with in-degree 0 to a queue. These nodes represent integers that are not constrained by the position of other integers. In a queue, push these integers first, since they can be completed without any prerequisites.</p>
<p>Now, iterate over all the queue elements, push them in the topologically sorted array, and reduce the in-degree by 1 of each direct neighbor of the current node. If the in-degree of the direct neighbor becomes 0, push it in the queue. Repeat the process till you have visited all the nodes with zero in-degree.</p>
<p>For example, let's say the given graph has three edges: <code>1 -&gt; 2</code>, <code>2 -&gt; 3</code>, and <code>1 -&gt; 3</code>. In this graph, the in-degree of each node represents the number of prerequisites that must be completed before reaching that node:</p>
<ul>
<li>Node <code>1</code> has an in-degree of <code>0</code></li>
<li>Node <code>2</code> has an in-degree of <code>1</code></li>
<li>Node <code>3</code> has an in-degree of <code>2</code></li>
</ul>
<p>We start with node <code>1</code>, as it has no prerequisites. We add it to our queue and process it first. Node <code>1</code> is a direct prerequisite for both nodes <code>2</code> and <code>3</code>, so we decrement their in-degrees:</p>
<ul>
<li>Node <code>2</code>'s in-degree becomes <code>0</code></li>
<li>Node <code>3</code>'s in-degree becomes <code>1</code></li>
</ul>
<p>Now we can add node <code>2</code> to our queue, as its in-degree is <code>0</code>. Processing node <code>2</code>, we decrement the in-degree of its neighbor, node <code>3</code>:</p>
<ul>
<li>Node <code>3</code>'s in-degree becomes <code>0</code></li>
</ul>
<p>Finally, we add node <code>3</code> to our queue and process it.</p>
<p>The resulting topologically sorted order is <code>1 -&gt; 2 -&gt; 3</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions, k)</code> and <code>topoSort(colConditions, k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] = orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges, n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, an array <code>deg</code> with size <code>n+1</code>, and an empty array <code>order</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> (denoting an edge from <code>a</code> to <code>b</code>). Also, increment the in-degree of <code>b</code> in the <code>deg</code> array.</li>
<li>Initialize a queue <code>q</code> and push all nodes with in-degree values 0 to the queue.</li>
<li>While <code>q</code> is not empty:
<ul>
<li>Store the front element of <code>q</code> in <code>f</code> and pop it.</li>
<li>Push <code>f</code> in <code>order</code>.</li>
<li>Decrement <code>n</code> by 1.</li>
<li>Iterate through each neighbor of <code>f</code>:
<ul>
<li>Decrement the in-degree of the neighbor. If the in-degree becomes 0, push it in <code>q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>n</code> is not equal to 0, return an empty array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p>!?!../Documents/2392/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7Ckf6TjR/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse-ii/description" target="_blank" rel="noopener noreferrer">Cat and Mouse II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game is played by a cat and a mouse named Cat and Mouse.</p>

<p>The environment is represented by a <code>grid</code> of size <code>rows x cols</code>, where each element is a wall, floor, player (Cat, Mouse), or food.</p>

<ul>
	<li>Players are represented by the characters <code>&#39;C&#39;</code>(Cat)<code>,&#39;M&#39;</code>(Mouse).</li>
	<li>Floors are represented by the character <code>&#39;.&#39;</code> and can be walked on.</li>
	<li>Walls are represented by the character <code>&#39;#&#39;</code> and cannot be walked on.</li>
	<li>Food is represented by the character <code>&#39;F&#39;</code> and can be walked on.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
</ul>

<p>Mouse and Cat play according to the following rules:</p>

<ul>
	<li>Mouse <strong>moves first</strong>, then they take turns to move.</li>
	<li>During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the <code>grid</code>.</li>
	<li><code>catJump, mouseJump</code> are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.</li>
	<li>Staying in the same position is allowed.</li>
	<li>Mouse can jump over Cat.</li>
</ul>

<p>The game can end in 4 ways:</p>

<ul>
	<li>If Cat occupies the same position as Mouse, Cat wins.</li>
	<li>If Cat reaches the food first, Cat wins.</li>
	<li>If Mouse reaches the food first, Mouse wins.</li>
	<li>If Mouse cannot get to the food within 1000 turns, Cat wins.</li>
</ul>

<p>Given a <code>rows x cols</code> matrix <code>grid</code> and two integers <code>catJump</code> and <code>mouseJump</code>, return <code>true</code><em> if Mouse can win the game if both Cat and Mouse play optimally, otherwise return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_111_1955.png" style="width: 580px; height: 239px;" />
<pre>
<strong>Input:</strong> grid = [&quot;####F&quot;,&quot;#C...&quot;,&quot;M....&quot;], catJump = 1, mouseJump = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_2_1955.png" style="width: 580px; height: 175px;" />
<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == grid.length</code></li>
	<li><code>cols = grid[i].length</code></li>
	<li><code>1 &lt;= rows, cols &lt;= 8</code></li>
	<li><code>grid[i][j]</code> consist only of characters <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, <code>&#39;F&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39;#&#39;</code>.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
	<li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/description" target="_blank" rel="noopener noreferrer">Check if Every Row and Column Contains All Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <code>n x n</code> matrix is <strong>valid</strong> if every row and every column contains <strong>all</strong> the integers from <code>1</code> to <code>n</code> (<strong>inclusive</strong>).</p>

<p>Given an <code>n x n</code> integer matrix <code>matrix</code>, return <code>true</code> <em>if the matrix is <strong>valid</strong>.</em> Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png" style="width: 250px; height: 251px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3],[3,1,2],[2,3,1]]
<strong>Output:</strong> true
<strong>Explanation:</strong> In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.
Hence, we return true.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png" style="width: 250px; height: 251px;" />
<pre>
<strong>Input:</strong> matrix = [[1,1,1],[1,2,3],[1,2,3]]
<strong>Output:</strong> false
<strong>Explanation:</strong> In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.
Hence, we return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-grid-satisfies-conditions/description" target="_blank" rel="noopener noreferrer">Check if Grid Satisfies Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> of size <code>m x n</code>. You need to check if each cell <code>grid[i][j]</code> is:</p>

<ul>
	<li>Equal to the cell below it, i.e. <code>grid[i][j] == grid[i + 1][j]</code> (if it exists).</li>
	<li>Different from the cell to its right, i.e. <code>grid[i][j] != grid[i][j + 1]</code> (if it exists).</li>
</ul>

<p>Return <code>true</code> if <strong>all</strong> the cells satisfy these conditions, otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,2],[1,0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/15/examplechanged.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>

<p>All the cells in the grid satisfy the conditions.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[0,0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/03/27/example21.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>

<p>All cells in the first row are equal.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[2],[3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/31/changed.png" style="width: 86px; height: 277px;padding: 10px; background: #fff; border-radius: .5rem;" /></p>

<p>Cells in the first column have different values.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-matrix-is-x-matrix/description" target="_blank" rel="noopener noreferrer">Check if Matrix Is X-Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A square matrix is said to be an <strong>X-Matrix</strong> if <strong>both</strong> of the following conditions hold:</p>

<ol>
	<li>All the elements in the diagonals of the matrix are <strong>non-zero</strong>.</li>
	<li>All other elements are 0.</li>
</ol>

<p>Given a 2D integer array <code>grid</code> of size <code>n x n</code> representing a square matrix, return <code>true</code><em> if </em><code>grid</code><em> is an X-Matrix</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg" style="width: 311px; height: 320px;" />
<pre>
<strong>Input:</strong> grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> Refer to the diagram above. 
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is an X-Matrix.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg" style="width: 238px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[5,7,0],[0,3,1],[0,5,0]]
<strong>Output:</strong> false
<strong>Explanation:</strong> Refer to the diagram above.
An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.
Thus, grid is not an X-Matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>3 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-move-is-legal/description" target="_blank" rel="noopener noreferrer">Check if Move is Legal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>8 x 8</code> grid <code>board</code>, where <code>board[r][c]</code> represents the cell <code>(r, c)</code> on a game board. On the board, free cells are represented by <code>&#39;.&#39;</code>, white cells are represented by <code>&#39;W&#39;</code>, and black cells are represented by <code>&#39;B&#39;</code>.</p>

<p>Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only <strong>legal</strong> if, after changing it, the cell becomes the <strong>endpoint of a good line</strong> (horizontal, vertical, or diagonal).</p>

<p>A <strong>good line</strong> is a line of <strong>three or more cells (including the endpoints)</strong> where the endpoints of the line are <strong>one color</strong>, and the remaining cells in the middle are the <strong>opposite color</strong> (no cells in the line are free). You can find examples for good lines in the figure below:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/22/goodlines5.png" style="width: 500px; height: 312px;" />
<p>Given two integers <code>rMove</code> and <code>cMove</code> and a character <code>color</code> representing the color you are playing as (white or black), return <code>true</code> <em>if changing cell </em><code>(rMove, cMove)</code> <em>to color</em> <code>color</code> <em>is a <strong>legal</strong> move, or </em><code>false</code><em> if it is not legal</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/10/grid11.png" style="width: 350px; height: 350px;" />
<pre>
<strong>Input:</strong> board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;W&quot;,&quot;B&quot;,&quot;B&quot;,&quot;.&quot;,&quot;W&quot;,&quot;W&quot;,&quot;W&quot;,&quot;B&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]], rMove = 4, cMove = 3, color = &quot;B&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> &#39;.&#39;, &#39;W&#39;, and &#39;B&#39; are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an &#39;X&#39;.
The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/10/grid2.png" style="width: 350px; height: 351px;" />
<pre>
<strong>Input:</strong> board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;W&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;W&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;]], rMove = 4, cMove = 4, color = &quot;W&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == board[r].length == 8</code></li>
	<li><code>0 &lt;= rMove, cMove &lt; 8</code></li>
	<li><code>board[rMove][cMove] == &#39;.&#39;</code></li>
	<li><code>color</code> is either <code>&#39;B&#39;</code> or <code>&#39;W&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/description" target="_blank" rel="noopener noreferrer"> Check if There Is a Valid Parentheses String Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is <strong>valid</strong> if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>

<ul>
	<li>It is <code>()</code>.</li>
	<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>
	<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>
</ul>

<p>You are given an <code>m x n</code> matrix of parentheses <code>grid</code>. A <strong>valid parentheses string path</strong> in the grid is a path satisfying <strong>all</strong> of the following conditions:</p>

<ul>
	<li>The path starts from the upper left cell <code>(0, 0)</code>.</li>
	<li>The path ends at the bottom-right cell <code>(m - 1, n - 1)</code>.</li>
	<li>The path only ever moves <strong>down</strong> or <strong>right</strong>.</li>
	<li>The resulting parentheses string formed by the path is <strong>valid</strong>.</li>
</ul>

<p>Return <code>true</code> <em>if there exists a <strong>valid parentheses string path</strong> in the grid.</em> Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png" style="width: 521px; height: 300px;" />
<pre>
<strong>Input:</strong> grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram shows two possible paths that form valid parentheses strings.
The first path shown results in the valid parentheses string &quot;()(())&quot;.
The second path shown results in the valid parentheses string &quot;((()))&quot;.
Note that there may be other valid parentheses string paths.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png" style="width: 165px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]
<strong>Output:</strong> false
<strong>Explanation:</strong> The two possible paths form the parentheses strings &quot;))(&quot; and &quot;)((&quot;. Since neither of them are valid parentheses strings, we return false.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Check if There is a Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> <code>grid</code>. Each cell of <code>grid</code> represents a street. The street of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means a street connecting the left cell and the right cell.</li>
	<li><code>2</code> which means a street connecting the upper cell and the lower cell.</li>
	<li><code>3</code> which means a street connecting the left cell and the lower cell.</li>
	<li><code>4</code> which means a street connecting the right cell and the lower cell.</li>
	<li><code>5</code> which means a street connecting the left cell and the upper cell.</li>
	<li><code>6</code> which means a street connecting the right cell and the upper cell.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/main.png" style="width: 450px; height: 708px;" />
<p>You will initially start at the street of the upper-left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code>. <strong>The path should only follow the streets</strong>.</p>

<p><strong>Notice</strong> that you are <strong>not allowed</strong> to change any street.</p>

<p>Return <code>true</code><em> if there is a valid path in the grid or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e1.png" style="width: 455px; height: 311px;" />
<pre>
<strong>Input:</strong> grid = [[2,4,3],[6,5,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/03/05/e2.png" style="width: 455px; height: 293px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,1],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-word-can-be-placed-in-crossword/description" target="_blank" rel="noopener noreferrer">Check if Word Can Be Placed In Crossword</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>board</code>, representing the<strong> current </strong>state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), <code>&#39; &#39;</code> to represent any <strong>empty </strong>cells, and <code>&#39;#&#39;</code> to represent any <strong>blocked</strong> cells.</p>

<p>A word can be placed<strong> horizontally</strong> (left to right <strong>or</strong> right to left) or <strong>vertically</strong> (top to bottom <strong>or</strong> bottom to top) in the board if:</p>

<ul>
	<li>It does not occupy a cell containing the character <code>&#39;#&#39;</code>.</li>
	<li>The cell each letter is placed in must either be <code>&#39; &#39;</code> (empty) or <strong>match</strong> the letter already on the <code>board</code>.</li>
	<li>There must not be any empty cells <code>&#39; &#39;</code> or other lowercase letters <strong>directly left or right</strong><strong> </strong>of the word if the word was placed <strong>horizontally</strong>.</li>
	<li>There must not be any empty cells <code>&#39; &#39;</code> or other lowercase letters <strong>directly above or below</strong> the word if the word was placed <strong>vertically</strong>.</li>
</ul>

<p>Given a string <code>word</code>, return <code>true</code><em> if </em><code>word</code><em> can be placed in </em><code>board</code><em>, or </em><code>false</code><em> <strong>otherwise</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/04/crossword-ex1-1.png" style="width: 478px; height: 180px;" />
<pre>
<strong>Input:</strong> board = [[&quot;#&quot;, &quot; &quot;, &quot;#&quot;], [&quot; &quot;, &quot; &quot;, &quot;#&quot;], [&quot;#&quot;, &quot;c&quot;, &quot; &quot;]], word = &quot;abc&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The word &quot;abc&quot; can be placed as shown above (top to bottom).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/04/crossword-ex2-1.png" style="width: 180px; height: 180px;" />
<pre>
<strong>Input:</strong> board = [[&quot; &quot;, &quot;#&quot;, &quot;a&quot;], [&quot; &quot;, &quot;#&quot;, &quot;c&quot;], [&quot; &quot;, &quot;#&quot;, &quot;a&quot;]], word = &quot;ac&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to place the word because there will always be a space/letter above or below it.</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/04/crossword-ex3-1.png" style="width: 478px; height: 180px;" />
<pre>
<strong>Input:</strong> board = [[&quot;#&quot;, &quot; &quot;, &quot;#&quot;], [&quot; &quot;, &quot; &quot;, &quot;#&quot;], [&quot;#&quot;, &quot; &quot;, &quot;c&quot;]], word = &quot;ca&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> The word &quot;ca&quot; can be placed as shown above (right to left). 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>board[i][j]</code> will be <code>&#39; &#39;</code>, <code>&#39;#&#39;</code>, or a lowercase English letter.</li>
	<li><code>1 &lt;= word.length &lt;= max(m, n)</code></li>
	<li><code>word</code> will contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-knight-tour-configuration/description" target="_blank" rel="noopener noreferrer">Check Knight Tour Configuration</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a knight on an <code>n x n</code> chessboard. In a valid configuration, the knight starts <strong>at the top-left cell</strong> of the board and visits every cell on the board <strong>exactly once</strong>.</p>

<p>You are given an <code>n x n</code> integer matrix <code>grid</code> consisting of distinct integers from the range <code>[0, n * n - 1]</code> where <code>grid[row][col]</code> indicates that the cell <code>(row, col)</code> is the <code>grid[row][col]<sup>th</sup></code> cell that the knight visited. The moves are <strong>0-indexed</strong>.</p>

<p>Return <code>true</code> <em>if</em> <code>grid</code> <em>represents a valid configuration of the knight&#39;s movements or</em> <code>false</code> <em>otherwise</em>.</p>

<p><strong>Note</strong> that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" style="width: 300px; height: 300px;" />
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png" style="width: 251px; height: 251px;" />
<pre>
<strong>Input:</strong> grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
<strong>Output:</strong> true
<strong>Explanation:</strong> The above diagram represents the grid. It can be shown that it is a valid configuration.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png" style="width: 151px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[0,3,6],[5,8,1],[2,7,4]]
<strong>Output:</strong> false
<strong>Explanation:</strong> The above diagram represents the grid. The 8<sup>th</sup> move of the knight is not valid considering its position after the 7<sup>th</sup> move.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>3 &lt;= n &lt;= 7</code></li>
	<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>
	<li>All integers in <code>grid</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cherry-pickup/description" target="_blank" rel="noopener noreferrer">Cherry Pickup</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> <code>grid</code> representing a field of cherries, each cell is one of three possible integers.</p>

<ul>
	<li><code>0</code> means the cell is empty, so you can pass through,</li>
	<li><code>1</code> means the cell contains a cherry that you can pick up and pass through, or</li>
	<li><code>-1</code> means the cell contains a thorn that blocks your way.</li>
</ul>

<p>Return <em>the maximum number of cherries you can collect by following the rules below</em>:</p>

<ul>
	<li>Starting at the position <code>(0, 0)</code> and reaching <code>(n - 1, n - 1)</code> by moving right or down through valid path cells (cells with value <code>0</code> or <code>1</code>).</li>
	<li>After reaching <code>(n - 1, n - 1)</code>, returning to <code>(0, 0)</code> by moving left or up through valid path cells.</li>
	<li>When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell <code>0</code>.</li>
	<li>If there is no valid path between <code>(0, 0)</code> and <code>(n - 1, n - 1)</code>, then no cherries can be collected.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,-1],[1,0,-1],[1,1,1]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The player started at (0, 0) and went down, down, right right to reach (2, 2).
4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].
Then, the player went left, up, up, left to return home, picking up one more cherry.
The total number of cherries picked up is 5, and this is the maximum possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>grid[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>1</code>.</li>
	<li><code>grid[0][0] != -1</code></li>
	<li><code>grid[n - 1][n - 1] != -1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-greedy-wrong-answer">Approach #1: Greedy [Wrong Answer]</h3>
<p><strong>Intuition</strong></p>
<p>Let's find the most cherries we can pick up with one path, pick them up, and then find the most cherries we can pick up with a second path on the remaining field.</p>
<p>Though a counter example might be hard to think of, this approach fails to find the best answer to this case:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#099">11100</span>
</span></span><span style="display:flex;"><span><span style="color:#099">00101</span>
</span></span><span style="display:flex;"><span><span style="color:#099">10100</span>
</span></span><span style="display:flex;"><span><span style="color:#099">00100</span>
</span></span><span style="display:flex;"><span><span style="color:#099">00111</span>
</span></span></code></pre><p><strong>Algorithm</strong></p>
<p>We can use dynamic programming to find the most number of cherries <code>dp[i][j]</code> that can be picked up from any location <code>(i, j)</code> to the bottom right corner. This is a classic question very similar to <a href="https://leetcode.com/problems/minimum-path-sum/description/">Minimum Path Sum</a>, refer to the link if you are not familiar with this type of question.</p>
<p>After, we can find a first path that maximizes the number of cherries taken by using our completed <code>dp</code> as an oracle for deciding where to move. We'll choose the move that allows us to pick up more cherries (based on comparing <code>dp[i + 1][j]</code> and <code>dp[i][j + 1]</code>).</p>
<p>After taking the cherries from that path (and removing them from the grid), we'll take the cherries again.</p>
<p><a href="https://leetcode.com/playground/Kb7FdHhT/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>grid</code>. Our dynamic programming consists of two for-loops of length <code>N</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N^2)\)</span>, the size of <code>dp</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming-top-down-accepted">Approach #2: Dynamic Programming (Top Down) [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Instead of walking from end to beginning, let's reverse the second leg of the path, so we are only considering two paths from the beginning to the end.</p>
<p>Notice after <code>t</code> steps, each position <code>(r, c)</code> we could be, is on the line <code>r + c = t</code>. So if we have two people at positions <code>(r1, c1)</code> and <code>(r2, c2)</code>, then <code>r2 = r1 + c1 - c2</code>.  That means the variables <code>r1, c1, c2</code> uniquely determine 2 people who have walked the same <code>r1 + c1</code> number of steps.  This sets us up for dynamic programming quite nicely.</p>
<p><strong>Algorithm</strong></p>
<p>Let <code>dp[r1][c1][c2]</code> be the most number of cherries obtained by two people starting at <code>(r1, c1)</code> and <code>(r2, c2)</code> and walking towards <code>(N - 1, N - 1)</code> picking up cherries, where <code>r2 = r1 + c1 - c2</code>.</p>
<p>If <code>grid[r1][c1]</code> and <code>grid[r2][c2]</code> are not thorns, then the value of <code>dp[r1][c1][c2]</code> is <code>(grid[r1][c1] + grid[r2][c2])</code>, plus the maximum of <code>dp[r1 + 1][c1][c2]</code>, <code>dp[r1][c1 + 1][c2]</code>, <code>dp[r1 + 1][c1][c2 + 1]</code>, <code>dp[r1][c1 + 1][c2 + 1]</code> as appropriate.  We should also be careful to not double count in case <code>(r1, c1) == (r2, c2)</code>.</p>
<p>Why did we say it was the maximum of <code>dp[r + 1][c1][c2]</code> etc.?  It corresponds to the 4 possibilities for persons 1 and 2 moving down and right:</p>
<ul>
<li>Person 1 down and person 2 down: <code>dp[r1 + 1][c1][c2]</code>;</li>
<li>Person 1 right and person 2 down: <code>dp[r1][c1 + 1][c2]</code>;</li>
<li>Person 1 down and person 2 right: <code>dp[r1 + 1][c1][c2 + 1]</code>;</li>
<li>Person 1 right and person 2 right: <code>dp[r1][c1 + 1][c2 + 1]</code>;</li>
</ul>
<p><a href="https://leetcode.com/playground/PD3QUTAd/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^3)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>grid</code>. Our dynamic programming has <span class="math inline">\(N^3\)</span> states, and each state is calculated once.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N^3)\)</span>, the size of <code>memo</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-dynamic-programming-bottom-up-accepted">Approach #3: Dynamic Programming (Bottom Up) [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Like in <em>Approach #2</em>, we have the idea of dynamic programming.</p>
<p>Say <code>r1 + c1 = t</code> is the <code>t</code>-th layer.  Since our recursion only references the next layer, we only need to keep two layers in memory at a time.</p>
<p><strong>Algorithm</strong></p>
<p>At time <code>t</code>, let <code>dp[c1][c2]</code> be the most cherries that we can pick up for two people going from <code>(0, 0)</code> to <code>(r1, c1)</code> and <code>(0, 0)</code> to <code>(r2, c2)</code>, where <code>r1 = t-c1, r2 = t-c2</code>.  Our dynamic program proceeds similarly to <em>Approach #2</em>.</p>
<p><a href="https://leetcode.com/playground/YiZFJWvZ/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N^3)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>grid</code>. We have three for-loops of size <span class="math inline">\(N\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N^2)\)</span>, the sizes of <code>dp</code> and <code>dp2</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cherry-pickup-ii/description" target="_blank" rel="noopener noreferrer">Cherry Pickup II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries where <code>grid[i][j]</code> represents the number of cherries that you can collect from the <code>(i, j)</code> cell.</p>

<p>You have two robots that can collect cherries for you:</p>

<ul>
	<li><strong>Robot #1</strong> is located at the <strong>top-left corner</strong> <code>(0, 0)</code>, and</li>
	<li><strong>Robot #2</strong> is located at the <strong>top-right corner</strong> <code>(0, cols - 1)</code>.</li>
</ul>

<p>Return <em>the maximum number of cherries collection using both robots by following the rules below</em>:</p>

<ul>
	<li>From a cell <code>(i, j)</code>, robots can move to cell <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code>.</li>
	<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.</li>
	<li>When both robots stay in the same cell, only one takes the cherries.</li>
	<li>Both robots cannot move outside of the grid at any moment.</li>
	<li>Both robots should reach the bottom row in <code>grid</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png" style="width: 374px; height: 501px;" />
<pre>
<strong>Input:</strong> grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png" style="width: 500px; height: 452px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
<strong>Output:</strong> 28
<strong>Explanation:</strong> Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == grid.length</code></li>
	<li><code>cols == grid[i].length</code></li>
	<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/coins-of-geekland--141631/1" target="_blank" rel="noopener noreferrer">Coins of Geekland</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">In Geekland there is a grid&nbsp;of coins of size <strong>N x</strong> <strong>N</strong>. You have to find the maximum sum of coins in any&nbsp;sub-grid&nbsp;of size<strong> K x K</strong>.<br /><strong>Note:</strong> Coins of the negative denomination are&nbsp;also possible at Geekland.</span><br /><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N = 5, K = 3 
mat[[]] = {1, 1, 1, 1, 1}&nbsp;
          {2, 2, 2, 2, 2}&nbsp;
          {3, 8, 6, 7, 3}&nbsp;
          {4, 4, 4, 4, 4}&nbsp;
          {5, 5, 5, 5, 5}</span>
<span style="font-size: 18px;"><strong>Output:</strong> 48</span>
<span style="font-size: 18px;"><strong>Explanation:</strong> {8, 6, 7}
             {4, 4, 4}
             {5, 5, 5}
has the maximum sum</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>N = 1, K = 1
mat[[]] = {{4}} </span>
<span style="font-size: 18px;"><strong>Output:</strong> 4</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task: </strong>&nbsp;<br />You don't need to read input or print anything. Complete the function <strong>Maximum_Sum()</strong> which takes the matrix mat[], size of Matrix N, and value K as input parameters and returns the maximum sum.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; K&nbsp;&le; N &le; 10<sup>3</sup><br />-5*10<sup>5</sup> &le; mat[i][j] &le; 5*10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/coloring-a-border/description" target="_blank" rel="noopener noreferrer">Coloring A Border</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, and three integers <code>row</code>, <code>col</code>, and <code>color</code>. Each value in the grid represents the color of the grid square at that location.</p>

<p>Two squares are called <strong>adjacent</strong> if they are next to each other in any of the 4 directions.</p>

<p>Two squares belong to the same <strong>connected component</strong> if they have the same color and they are adjacent.</p>

<p>The <strong>border of a connected component</strong> is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).</p>

<p>You should color the <strong>border</strong> of the <strong>connected component</strong> that contains the square <code>grid[row][col]</code> with <code>color</code>.</p>

<p>Return <em>the final grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
<strong>Output:</strong> [[3,3],[3,2]]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
<strong>Output:</strong> [[1,3,3],[2,3,3]]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
<strong>Output:</strong> [[2,2,2],[2,1,2],[2,2,2]]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j], color &lt;= 1000</code></li>
	<li><code>0 &lt;= row &lt; m</code></li>
	<li><code>0 &lt;= col &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/column-sum-in-a-matrix/1" target="_blank" rel="noopener noreferrer">Column Sum in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2-D integer matrix&nbsp;<strong>mat[][]</strong>&nbsp;of size&nbsp;<strong>n</strong>*<strong>m</strong>. Return a list of integers where&nbsp;<strong>list[i]&nbsp;</strong>represents the sum of elements of the&nbsp;<strong>i<sup>th</sup>&nbsp;</strong>column of the matrix.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br /></span><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">[12, 15, 18]<br /><strong>Explanation: </strong>Column 1 -&gt; 1+4+7=12, Column 2 -&gt; 2+5+8=15, Column 3 -&gt; 3+6+9=18 </span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">mat = [[1, 2], [10, 2], [3, 3]]<br /></span><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">[14, 7]<br /><strong>Explanation: </strong>Column 1 -&gt; 1+10+3=14, Column 2 -&gt; 2+2+3=7 </span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &nbsp;&lt;= &nbsp;n, m &nbsp;&lt;= &nbsp;1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/compute-before-matrix--170637/1" target="_blank" rel="noopener noreferrer">Compute Before Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">For a given 2D Matrix&nbsp;<strong>before,</strong>&nbsp;the corresponding cell (x, y) of the <strong>after</strong> matrix is calculated as follows:&nbsp;</span></p>

<div style="background:#eee;border:1px solid #ccc;padding:5px 10px;">
<pre>
<span style="font-size:18px">res = 0;
for(i = 0; i &lt;= x; i++){
    for( j = 0; j &lt;= y; j++){              
&nbsp;       res += before(i,j);
    }
}
after(x,y) = res;
</span></pre>
</div>

<p>&nbsp;</p>

<p><span style="font-size:18px">Given an&nbsp;<strong>N*M&nbsp;</strong>2D-Matrix&nbsp;<strong>after,</strong>&nbsp;your task is to find the corresponding&nbsp;<strong>before&nbsp;</strong>matrix for the given matrix.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 2, M = 3
after[][] = {{1, 3, 6},
&nbsp;           {3, 7, 11}}
<strong>Output:</strong>
1 2 3
2 2 1
<strong>Explanation:</strong>
The before matrix for the given after matrix
matrix is {{1, 2, 3}, {2, 2, 1}}.
Reason:
According to the code given in problem,
</span><span style="font-size:18px">after(0,0) = before(0,0) = 1
after(0,1) = before(0,0) + before(0,1)
= 1 + 2 = 3.
after(0, 2) = before(0,0) + before(0, 1)
+ before(0, 2) = 1 + 2 + 3 = 6.
Similarly we can calculate values for every
cell of the after matrix.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>
N = 1, M = 3
after[][] = {{1, 3, 5}}
<strong>Output:</strong>
1 2 2
<strong>Explanation: </strong>
The before matrix for the given after matrix
is {{1, 2, 2}}.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
Complete the function <strong>c</strong><strong>omputeBeforeMatrix() </strong>which takes the integers <strong>N</strong>, <strong>M,&nbsp;</strong>and the 2D Matrix&nbsp;<strong>after</strong>&nbsp;as the input parameters, and returns the before matrix of the given after matrix.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N, M, after[i][j]&nbsp; &le;&nbsp; 10<sup>9</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-2d-grid-matching-graph-layout/description" target="_blank" rel="noopener noreferrer">Construct 2D Grid Matching Graph Layout</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>edges</code> representing an <strong>undirected</strong> graph having <code>n</code> nodes, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>.</p>

<p>Construct a 2D grid that satisfies these conditions:</p>

<ul>
	<li>The grid contains <strong>all nodes</strong> from <code>0</code> to <code>n - 1</code> in its cells, with each node appearing exactly <strong>once</strong>.</li>
	<li>Two nodes should be in adjacent grid cells (<strong>horizontally</strong> or <strong>vertically</strong>) <strong>if and only if</strong> there is an edge between them in <code>edges</code>.</li>
</ul>

<p>It is guaranteed that <code>edges</code> can form a 2D grid that satisfies the conditions.</p>

<p>Return a 2D integer array satisfying the conditions above. If there are multiple solutions, return <em>any</em> of them.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 4, edges = [[0,1],[0,2],[1,3],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[3,1],[2,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-07-59.png" style="width: 133px; height: 92px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 5, edges = [[0,1],[1,3],[2,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[4,2,3,1,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-06-02.png" style="width: 325px; height: 50px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[8,6,3],[7,4,2],[1,0,5]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/11/screenshot-from-2024-08-11-14-06-38.png" style="width: 198px; height: 133px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code></li>
	<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>
	<li>All the edges are distinct.</li>
	<li>The input is generated such that <code>edges</code> can form a 2D grid that satisfies the conditions.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-product-matrix/description" target="_blank" rel="noopener noreferrer">Construct Product Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> 2D integer matrix <code><font face="monospace">grid</font></code><font face="monospace"> </font>of size <code>n * m</code>, we define a <strong>0-indexed</strong> 2D matrix <code>p</code> of size <code>n * m</code> as the <strong>product</strong> matrix of <code>grid</code> if the following condition is met:</p>

<ul>
	<li>Each element <code>p[i][j]</code> is calculated as the product of all elements in <code>grid</code> except for the element <code>grid[i][j]</code>. This product is then taken modulo <code><font face="monospace">12345</font></code>.</li>
</ul>

<p>Return <em>the product matrix of</em> <code><font face="monospace">grid</font></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,2],[3,4]]
<strong>Output:</strong> [[24,12],[8,6]]
<strong>Explanation:</strong> p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24
p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12
p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8
p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6
So the answer is [[24,12],[8,6]].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[12345],[2],[1]]
<strong>Output:</strong> [[2],[0],[0]]
<strong>Explanation:</strong> p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.
p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.
p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.
So the answer is [[2],[0],[0]].</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == grid.length&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m == grid[i].length&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= n * m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/construct-quad-tree/description" target="_blank" rel="noopener noreferrer">Construct Quad Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">matrix</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>n * n</code> matrix <code>grid</code> of <code>0&#39;s</code> and <code>1&#39;s</code> only. We want to represent <code>grid</code> with a Quad-Tree.</p>

<p>Return <em>the root of the Quad-Tree representing </em><code>grid</code>.</p>

<p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p>

<ul>
	<li><code>val</code>: True if the node represents a grid of 1&#39;s or False if the node represents a grid of 0&#39;s. Notice that you can assign the <code>val</code> to True or False when <code>isLeaf</code> is False, and both are accepted in the answer.</li>
	<li><code>isLeaf</code>: True if the node is a leaf node on the tree or False if the node has four children.</li>
</ul>

<pre>
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}</pre>

<p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p>

<ol>
	<li>If the current grid has the same value (i.e all <code>1&#39;s</code> or all <code>0&#39;s</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.</li>
	<li>If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.</li>
	<li>Recurse for each of the children with the proper sub-grid.</li>
</ol>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" style="width: 777px; height: 181px;" />
<p>If you want to know more about the Quad-Tree, you can refer to the <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a>.</p>

<p><strong>Quad-Tree format:</strong></p>

<p>You don&#39;t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.</p>

<p>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.</p>

<p>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" style="width: 777px; height: 99px;" />
<pre>
<strong>Input:</strong> grid = [[0,1],[1,0]]
<strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]
<strong>Explanation:</strong> The explanation of this example is shown below:
Notice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" style="width: 777px; height: 186px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" style="width: 777px; height: 343px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]
<strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
<strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.
The topLeft, bottomLeft and bottomRight each has the same value.
The topRight have different values so we divide it into 4 sub-grids where each has the same value.
Explanation is shown in the photo below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" style="width: 777px; height: 328px;" />
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>n == 2<sup>x</sup></code> where <code>0 &lt;= x &lt;= 6</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/contain-virus/description" target="_blank" rel="noopener noreferrer">Contain Virus</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>

<p>The world is modeled as an <code>m x n</code> binary grid <code>isInfected</code>, where <code>isInfected[i][j] == 0</code> represents uninfected cells, and <code>isInfected[i][j] == 1</code> represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two <strong>4-directionally</strong> adjacent cells, on the shared boundary.</p>

<p>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There <strong>will never be a tie</strong>.</p>

<p>Return <em>the number of walls used to quarantine all the infected regions</em>. If the world will become fully infected, return the number of walls used.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg" style="width: 500px; height: 255px;" />
<pre>
<strong>Input:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg" style="width: 500px; height: 257px;" />
On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg" style="width: 500px; height: 261px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg" style="width: 653px; height: 253px;" />
<pre>
<strong>Input:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> The region on the left only builds two new walls.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;isInfected.length</code></li>
	<li><code>n ==&nbsp;isInfected[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>isInfected[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is always a contiguous viral region throughout the described process that will <strong>infect strictly more uncontaminated squares</strong> in the next round.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/convert-1d-array-into-2d-array/description" target="_blank" rel="noopener noreferrer">Convert 1D Array Into 2D Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 1-dimensional (1D) integer array <code>original</code>, and two integers, <code>m</code> and <code>n</code>. You are tasked with creating a 2-dimensional (2D) array with <code> m</code> rows and <code>n</code> columns using <strong>all</strong> the elements from <code>original</code>.</p>

<p>The elements from indices <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>) of <code>original</code> should form the first row of the constructed 2D array, the elements from indices <code>n</code> to <code>2 * n - 1</code> (<strong>inclusive</strong>) should form the second row of the constructed 2D array, and so on.</p>

<p>Return <em>an </em><code>m x n</code><em> 2D array constructed according to the above procedure, or an empty 2D array if it is impossible</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png" style="width: 500px; height: 174px;" />
<pre>
<strong>Input:</strong> original = [1,2,3,4], m = 2, n = 2
<strong>Output:</strong> [[1,2],[3,4]]
<strong>Explanation:</strong> The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> original = [1,2,3], m = 1, n = 3
<strong>Output:</strong> [[1,2,3]]
<strong>Explanation:</strong> The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> original = [1,2], m = 1, n = 1
<strong>Output:</strong> []
<strong>Explanation:</strong> There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-simulation">Approach 1: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem statement implies that the length of <code>original</code> must equal <span class="math inline">\(m \times n\)</span>, the total number of elements required to fill the matrix. So, we'll start by checking if it's possible to construct the array and return an empty array if not.</p>
<p>Next, we'll simulate filling the 2D matrix row by row using nested loops.</p>
<ul>
<li>Row (<code>i</code>): The row index <code>i</code> is directly controlled by the outer loop, which ranges from <code>0</code> to <code>m-1</code>. Each time the outer loop increments <code>i</code>, it moves to the next row.</li>
<li>Column (<code>j</code>): The column index <code>j</code> is controlled by the inner loop, which ranges from <code>0</code> to <code>n-1</code>. As the inner loop increments <code>j</code>, it moves across the columns of the current row.</li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Check if the length of the <code>original</code> array is equal to <code>m * n</code>:
<ul>
<li>If not, return an empty 2D array.</li>
</ul>
</li>
<li>Initialize a 2D array <code>resultArray</code> of dimensions <span class="math inline">\(m \times n\)</span>.</li>
<li>Create a variable <code>index</code> to keep track of the current position in the <code>original</code> array.</li>
<li>Iterate through each row <code>i</code> of <code>resultArray</code>:
<ul>
<li>For each row, iterate through each column <code>j</code>:
<ul>
<li>Assign the element at the current <code>index</code> of the <code>original</code> array to <code>resultArray[i][j]</code>.</li>
<li>Increment <code>index</code> to move to the next element in <code>original</code>.</li>
</ul>
</li>
</ul>
</li>
<li>After filling all elements, return the <code>resultArray</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HBp53fPq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the number of rows and columns in <code>resultArray</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm initializes a 2D array and fills it using nested loops. The outer loop runs <span class="math inline">\(m\)</span> times and the inner loop runs <span class="math inline">\(n\)</span> times. Thus, the total number of iterations is <span class="math inline">\(m \times n\)</span>, which equals a time complexity of <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The output array has a space complexity of <span class="math inline">\(O(m \times n)\)</span>. However, we do not consider input and output space as part of our space complexity calculations. Thus, the space complexity of the algorithm is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-math">Approach 2: Math</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's look for a pattern we can use to directly map elements from the <code>original</code> array to the 2D matrix using one loop instead of two.</p>
<p>We know that the length of each row is <code>n</code>, so the first <code>n</code> elements will be in row one, the next <code>n</code> elements will be in the row two, and so on. We can use this pattern to efficiently determine the row index for each element using integer division (also known as floor division): the element at index <code>i</code> in <code>original</code> belongs in row <code>i / n</code>. Have a look at the below illustration:</p>
<p><img src="../Figures//2022/row_example.png" alt="" /></p>
<p>To determine the column position of an element in the 2D matrix, we can use the remainder of its index in the 1D array when divided by the number of elements in each row of the 2D matrix. This method works because the remainder cycles through <code>0</code> to <code>n-1</code> as you move through the 1D array, matching the columns in each row of the 2D matrix:</p>
<p><img src="../Figures//2022/col_example.png" alt="" /></p>
<p>Given this mathematical relationship, we can directly populate the matrix by iterating through the <code>original</code> array and placing each element at the corresponding <code>(i / n, i % n)</code> position in the matrix:</p>
<p><img src="../Figures//2022/final_matrix.png" alt="" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Check if the length of the <code>original</code> array is equal to <code>m * n</code>:
<ul>
<li>If it isn't, return an empty 2D array.</li>
</ul>
</li>
<li>Initialize a 2-D array <code>resultArray</code> with dimensions <span class="math inline">\(m \times n\)</span>.</li>
<li>Loop over each index <code>i</code> in <code>original</code>:
<ul>
<li>Set <code>resultArray[i / n][i % n]</code> to <code>original[i]</code>.</li>
</ul>
</li>
<li>Return <code>resultArray</code> as our answer.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ADTEAtgK/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the number of rows and columns in <code>resultArray</code>, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm iteratively fills every cell in the <code>resultArray</code>, which takes <span class="math inline">\(O(m \times n)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The output array takes <span class="math inline">\(O(m \times n)\)</span> space. However, we do not consider input and output space as part of our space complexity calculations. Thus, the space complexity of the algorithm is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-cells-in-overlapping-horizontal-and-vertical-substrings/description" target="_blank" rel="noopener noreferrer">Count Cells in Overlapping Horizontal and Vertical Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-function</span> <span class="topic-badge">matrix</span> <span class="topic-badge">rolling-hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string-matching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of characters and a string <code>pattern</code>.</p>

<p>A <strong data-end="264" data-start="240">horizontal substring</strong> is a contiguous sequence of characters read from left to right. If the end of a row is reached before the substring is complete, it wraps to the first column of the next row and continues as needed. You do <strong>not</strong> wrap from the bottom row back to the top.</p>

<p>A <strong data-end="484" data-start="462">vertical substring</strong> is a contiguous sequence of characters read from top to bottom. If the bottom of a column is reached before the substring is complete, it wraps to the first row of the next column and continues as needed. You do <strong>not</strong> wrap from the last column back to the first.</p>

<p>Count the number of cells in the matrix that satisfy the following condition:</p>

<ul>
	<li>The cell must be part of <strong>at least</strong> one horizontal substring and <strong>at least</strong> one vertical substring, where <strong>both</strong> substrings are equal to the given <code>pattern</code>.</li>
</ul>

<p>Return the count of these cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridtwosubstringsdrawio.png" style="width: 150px; height: 187px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;abaca&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The pattern <code>&quot;abaca&quot;</code> appears once as a horizontal substring (colored blue) and once as a vertical substring (colored red), intersecting at one cell (colored purple).</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/03/gridexample2fixeddrawio.png" style="width: 150px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;c&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]], pattern = &quot;aba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>The cells colored above are all part of at least one horizontal and one vertical substring matching the pattern <code>&quot;aba&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;a&quot;]], pattern = &quot;a&quot;</span></p>

<p><strong>Output:</strong> 1</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= pattern.length &lt;= m * n</code></li>
	<li><code>grid</code> and <code>pattern</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-fertile-pyramids-in-a-land/description" target="_blank" rel="noopener noreferrer">Count Fertile Pyramids in a Land</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A farmer has a <strong>rectangular grid</strong> of land with <code>m</code> rows and <code>n</code> columns that can be divided into unit cells. Each cell is either <strong>fertile</strong> (represented by a <code>1</code>) or <strong>barren</strong> (represented by a <code>0</code>). All cells outside the grid are considered barren.</p>

<p>A <strong>pyramidal plot</strong> of land can be defined as a set of cells with the following criteria:</p>

<ol>
	<li>The number of cells in the set has to be <strong>greater than </strong><code>1</code> and all cells must be <strong>fertile</strong>.</li>
	<li>The <strong>apex</strong> of a pyramid is the <strong>topmost</strong> cell of the pyramid. The <strong>height</strong> of a pyramid is the number of rows it covers. Let <code>(r, c)</code> be the apex of the pyramid, and its height be <code>h</code>. Then, the plot comprises of cells <code>(i, j)</code> where <code>r &lt;= i &lt;= r + h - 1</code> <strong>and</strong> <code>c - (i - r) &lt;= j &lt;= c + (i - r)</code>.</li>
</ol>

<p>An <strong>inverse pyramidal plot</strong> of land can be defined as a set of cells with similar criteria:</p>

<ol>
	<li>The number of cells in the set has to be <strong>greater than </strong><code>1</code> and all cells must be <strong>fertile</strong>.</li>
	<li>The <strong>apex</strong> of an inverse pyramid is the <strong>bottommost</strong> cell of the inverse pyramid. The <strong>height</strong> of an inverse pyramid is the number of rows it covers. Let <code>(r, c)</code> be the apex of the pyramid, and its height be <code>h</code>. Then, the plot comprises of cells <code>(i, j)</code> where <code>r - h + 1 &lt;= i &lt;= r</code> <strong>and</strong> <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code>.</li>
</ol>

<p>Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.</p>
<img src="https://assets.leetcode.com/uploads/2021/11/08/image.png" style="width: 700px; height: 156px;" />
<p>Given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code> representing the farmland, return <em>the <strong>total number</strong> of pyramidal and inverse pyramidal plots that can be found in</em> <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/22/1.JPG" style="width: 575px; height: 109px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[1,1,1,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The 2 possible pyramidal plots are shown in blue and red respectively.
There are no inverse pyramidal plots in this grid. 
Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/22/2.JPG" style="width: 502px; height: 120px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. 
Hence the total number of plots is 1 + 1 = 2.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/22/3.JPG" style="width: 676px; height: 148px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.
There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.
The total number of plots is 7 + 6 = 13.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-islands-with-total-value-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Count Islands With Total Value Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> and a positive integer <code>k</code>. An <strong>island</strong> is a group of <strong>positive</strong> integers (representing land) that are <strong>4-directionally</strong> connected (horizontally or vertically).</p>

<p>The <strong>total value</strong> of an island is the sum of the values of all cells in the island.</p>

<p>Return the number of islands with a total value <strong>divisible by</strong> <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example1griddrawio-1.png" style="width: 200px; height: 200px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,2,1,0,0],[0,5,0,0,5],[0,0,1,0,0],[0,1,4,7,0],[0,2,0,0,8]], k = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains four islands. The islands highlighted in blue have a total value that is divisible by 5, while the islands highlighted in red do not.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/06/example2griddrawio.png" style="width: 200px; height: 150px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,0,3,0], [0,3,0,3], [3,0,3,0]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The grid contains six islands, each with a total value that is divisible by 3.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description" target="_blank" rel="noopener noreferrer">Count Negative Numbers in a Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>grid</code> which is sorted in non-increasing order both row-wise and column-wise, return <em>the number of <strong>negative</strong> numbers in</em> <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> There are 8 negatives number in the matrix.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[3,2],[1,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you find an <code>O(n + m)</code> solution?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-number-of-free-cell--170646/1" target="_blank" rel="noopener noreferrer">Count number of free cell</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Suppose you have a Matrix size <strong>n*n</strong>, and given an integer <strong>k</strong> and a set of coordinates <strong>arr</strong>&nbsp;of size&nbsp;<strong>k*2</strong>. Initially, the matrix contains only 0. You are given k tasks and for each task, you are given two coordinates (r = arr[i][0],c = arr[i][1]) [1 based index r and c]. Where coordinates (r,c) denotes r<sup>th&nbsp;</sup>row and c<sup>th&nbsp;</sup>column of the given matrix.</span></p>

<p><span style="font-size:18px">You have to perform each task sequentially in the given order. F</span><span style="font-size:18px">or each task, You have to put 1 in all cells of r<sup>th</sup> row&nbsp; and all cells of c<sup>th</sup> column.</span></p>

<p><span style="font-size:18px">After each task, You have to calculate the number of 0 present in the matrix and return it.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>n = 3, k= 3
arr =
{{2, 2},
 {2, 3},
 {3, 2}}
<strong>Output: </strong>4 2 1<strong>
Explanation: 
</strong>After 1st Operation, all the 2nd row
and all the 2nd column will be filled by
1. So remaning cell with value 0 will be 4
After 2nd Operation, all the 2nd row and all
the 3rd column will be filled by 1. So 
remaning cell with value 0 will be 2<strong>.
</strong>After 3rd Operation cells having value 0 will
be 1.</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>n = 2, k = 2
arr = 
{{1, 2},
 {1, 1}}
<strong>Output: </strong>1 0
<strong>Explanation: 
</strong>After 1st Operation, all the 1st row and 
all the 2nd column will be filled by 1. 
So remaning cell with value 0 will be 1.
After 2nd Operation, all the 1st row and 
all the 1st column will be filled by 1. 
So remaning cell with value 0 will be 0<strong>. </strong></span>
</pre>

<p><span style="font-size:18px"><strong>Your&nbsp;Task:</strong><br />
The task is to complete the function <strong>countZero</strong>(), which takes parameter&nbsp;<strong>n,&nbsp;</strong>size of<br />
the matrix, k no of operation and array <strong>arr[][],&nbsp;</strong>which denotes the position of the cells.</span><br />
<span style="font-size:18px">You have to return an array that contains all the results.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity: </strong>O( k ).<br />
<strong>Expected Auxiliary Space:</strong> O( n+n+k ).</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n, k &lt;= 10<sup>5</sup></span><br />
<span style="font-size:18px">1 &lt;= r, c&nbsp;&lt;= n</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-occurrences-in-a-fully-sorted-matrix/1" target="_blank" rel="noopener noreferrer">Count Occurrences in a Fully Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;"><span style="font-size: 14pt;">Given a sorted 2D matrix</span><strong style="font-size: 14pt;">&nbsp;mat</strong><span style="font-size: 14pt;">[][] of size&nbsp;</span><strong style="font-size: 14pt;">n x m&nbsp;</strong><span style="font-size: 14pt;">and</span><strong style="font-size: 14pt;">&nbsp;</strong><span style="font-size: 14pt;">a number&nbsp;</span><strong style="font-size: 14pt;">x.</strong><span style="font-size: 14pt;"> C</span><span style="font-size: 18.6667px;">ount the number of times <strong>x</strong> appears in the matrix.</span><br /><strong style="font-size: 14pt;">Note:</strong><span style="font-size: 14pt;">&nbsp;In a sorted matrix, each row is sorted in increasing order, and the first element of the&nbsp;</span><strong style="font-size: 14pt;">i</strong><sup style="font-size: 14pt;">th</sup><span style="font-size: 14pt;">&nbsp;row (</span><strong style="font-size: 14pt;">i</strong><span style="font-size: 14pt;">!=0) is greater than or equal to the last element of the (</span><strong style="font-size: 14pt;">i-1</strong><span style="font-size: 14pt;">)</span><sup style="font-size: 14pt;">th&nbsp;</sup><span style="font-size: 14pt;">row.</span></span><br style="font-size: 18px;" /><br /><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 3, 5], [6, 7, 8], [10, 10, 12]], x = 10
<strong>Output</strong>: 2
<strong>Explanation</strong>: The number 10 appears twice in the matrix at mat[2][0] and mat[2][1].
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 4], [5, 6, 7], [8, 9, 10]], x = 3<br /><strong>Output</strong>: 0
<strong>Explanation</strong>: The number 3 is not present in the matrix at any position, so the result is 0.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[2, 5, 7], [7, 7, 7], [7, 8, 8]], x = 7</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: 5
<strong>Explanation</strong>: The number 7 appears 5 times in the matrix at mat[0][2], mat[1][0], mat[1][1], mat[1][2] and mat[2][0].</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; n, m &le; 1000<br />1 &le; mat[i][j] &le; 10<sup>9</sup><br />1 &le; x &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-pairs-sum-in-matrices4332/1" target="_blank" rel="noopener noreferrer">Count pairs Sum in matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;">Given two matrices </span><strong style="font-size: 18px;">mat1[][]</strong><span style="font-size: 18px;"> and </span><strong style="font-size: 18px;">mat2[][]</strong><span style="font-size: 18px;"> of size n x n, where the elements in each matrix are arranged in strictly <strong>ascending order</strong>.&nbsp;</span></span><span style="font-size: 18px;">Specifically, <strong>each row</strong> is sorted from <strong>left to right</strong>, and the last element of a row is <strong>smaller</strong> than the first element of the next row.</span><span style="font-size: 18px;"> <br /></span><span style="font-size: 18px;">You're given a target value&nbsp;</span><strong style="font-size: 18px;">x</strong><span style="font-size: 18px;">, your task is to find and <strong>count</strong></span><strong style="font-size: 18px;"> </strong><span style="font-size: 18px;">all pairs</span> <strong style="font-size: 18px;">{a, b} </strong><span style="font-size: 18px;">such that </span><strong style="font-size: 18px;">a </strong><span style="font-size: 18px;">is from </span><strong style="font-size: 18px;">mat1 </strong><span style="font-size: 18px;">and </span><strong style="font-size: 18px;">b </strong><span style="font-size: 18px;">is from </span><strong style="font-size: 18px;">mat2 </strong><span style="font-size: 18px;">where the sum of </span><strong style="font-size: 18px;">a +</strong><span style="font-size: 18px;">&nbsp;</span><strong style="font-size: 18px;">b</strong><span style="font-size: 18px;"> is equal to </span><strong style="font-size: 18px;">x</strong><span style="font-size: 18px;">.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> n = 3, x = 21,<br />mat1[][] = [[1, 5, 6], [8, 10, 11], [15, 16, 18]],
mat2[][] = [[2, 4, 7], [9, 10, 12], [13, 16, 20]]
<strong>OUTPUT: </strong>4
<strong>Explanation: </strong>The pairs whose sum is found to be 21 are (1, 20), (5, 16), (8, 13) and (11, 10).</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, x = 10,
mat1[][] = [[1, 2], [3, 4]]
mat2[][] = [[4, 5], [6, 7]]
<strong>Output: </strong>2
<strong>Explanation: </strong>The pairs whose sum found to be 10 are (4, 6) and (3, 7).</span></pre>
<p><span style="font-size: 20px;"><strong>Constraints:<br /></strong></span><span style="font-size: 20px;">1 &le; n &le; 100<br /></span><span style="font-size: 20px;">1 &le; x &le; 10<sup>5</sup><br /></span><span style="font-size: 20px;">1 &le; mat1[i][j] , mat2[i][j] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-paths-with-the-given-xor-value/description" target="_blank" rel="noopener noreferrer">Count Paths With the Given XOR Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>grid</code> with size <code>m x n</code>. You are also given an integer <code>k</code>.</p>

<p>Your task is to calculate the number of paths you can take from the top-left cell <code>(0, 0)</code> to the bottom-right cell <code>(m - 1, n - 1)</code> satisfying the following <strong>constraints</strong>:</p>

<ul>
	<li>You can either move to the right or down. Formally, from the cell <code>(i, j)</code> you may move to the cell <code>(i, j + 1)</code> or to the cell <code>(i + 1, j)</code> if the target cell <em>exists</em>.</li>
	<li>The <code>XOR</code> of all the numbers on the path must be <strong>equal</strong> to <code>k</code>.</li>
</ul>

<p>Return the total number of such paths.</p>

<p>Since the answer can be very large, return the result <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2, 1, 5], [7, 10, 0], [12, 6, 4]], k = 11</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>The 3 paths are:</p>

<ul>
	<li><code>(0, 0) &rarr; (1, 0) &rarr; (2, 0) &rarr; (2, 1) &rarr; (2, 2)</code></li>
	<li><code>(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (1, 2) &rarr; (2, 2)</code></li>
	<li><code>(0, 0) &rarr; (0, 1) &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2)</code></li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>The 5 paths are:</p>

<ul>
	<li><code>(0, 0) &rarr; (1, 0) &rarr; (2, 0) &rarr; (2, 1) &rarr; (2, 2) &rarr; (2, 3)</code></li>
	<li><code>(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2) &rarr; (2, 3)</code></li>
	<li><code>(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (1, 2) &rarr; (1, 3) &rarr; (2, 3)</code></li>
	<li><code>(0, 0) &rarr; (0, 1) &rarr; (1, 1) &rarr; (1, 2) &rarr; (2, 2) &rarr; (2, 3)</code></li>
	<li><code>(0, 0) &rarr; (0, 1) &rarr; (0, 2) &rarr; (1, 2) &rarr; (2, 2) &rarr; (2, 3)</code></li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1, 1, 1, 2], [3, 0, 3, 2], [3, 0, 2, 2]], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 300</code></li>
	<li><code>1 &lt;= n == grid[r].length &lt;= 300</code></li>
	<li><code>0 &lt;= grid[r][c] &lt; 16</code></li>
	<li><code>0 &lt;= k &lt; 16</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-servers-that-communicate/description" target="_blank" rel="noopener noreferrer">Count Servers that Communicate</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">counting</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a map of a server center, represented as a <code>m * n</code> integer matrix&nbsp;<code>grid</code>, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.<br />
<br />
Return the number of servers&nbsp;that communicate with any other server.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" style="width: 202px; height: 203px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 0
<b>Explanation:</b>&nbsp;No servers can communicate with others.</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/11/13/untitled-diagram-4.jpg" style="width: 203px; height: 203px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[1,1]]
<strong>Output:</strong> 3
<b>Explanation:</b>&nbsp;All three servers can communicate with at least one other server.
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-1-3.jpg" style="width: 443px; height: 443px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]
<strong>Output:</strong> 4
<b>Explanation:</b>&nbsp;The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 250</code></li>
	<li><code>1 &lt;= n &lt;= 250</code></li>
	<li><code>grid[i][j] == 0 or 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid representing a server center in the form of a matrix of size <code>m x n</code>. Each cell of the matrix contains either a <code>1</code>, indicating the presence of a server, or a <code>0</code>, indicating an empty space.</p>
<p>We need to return the number of servers that can communicate with at least one other server. This excludes servers that are isolated, i.e., those that do not share a row or column with any other server.</p>
<p>The first thing to note is that a server can communicate with another server if they are located either in the same row or the same column. Thus, the key observation here is that we only need to check rows and columns to determine if a server is communicable. If thereâ€™s at least one other server in the same row or column, then this server is communicable.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that each cell either contains a server (represented by <code>1</code>) or is empty (represented by <code>0</code>). So, we start by going through each cell to see if there is a server at that position. If the current cell contains a server, we then check if this server can communicate with any other server. If it can, we count it as communicable.</p>
<p>Once we find a server, we check if there is any other server in the same row that can communicate with it. We do this by iterating through all the other cells in the same row. If we find another server in the same row, we can immediately mark it as communicable.</p>
<p>If we do not find any other server in the row, we proceed to check the column. We iterate through all the other rows in the same column to see if there is another server. If a server is found in the same column, we know this server can communicate and is communicable.</p>
<p>As soon as we determine that a server can communicate (either in the same row or column), we increment the total communicable servers count. Once we finish checking the entire grid, we return the count of communicable servers.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in the grid.</p>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will keep track of the count of communicable servers.</p>
</li>
<li>
<p>Traverse through the grid:</p>
<ul>
<li>For each server at position <code>(row, col)</code> where <code>grid[row][col] == 1</code>:
<ul>
<li>Set <code>canCommunicate</code> to <code>false</code>.</li>
<li>Check for communication in the same row:
<ul>
<li>Iterate through each column <code>otherCol</code> in the same row:
<ul>
<li>If <code>otherCol</code> is not equal to <code>col</code> and <code>grid[row][otherCol] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
<li>If no communication was found in the same row, check for communication in the same column:
<ul>
<li>Iterate through each row <code>otherRow</code> in the same column:
<ul>
<li>If <code>otherRow</code> is not equal to <code>row</code> and <code>grid[otherRow][col] == 1</code>, set <code>canCommunicate</code> to <code>true</code> and break the loop.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>canCommunicate</code> is <code>true</code>, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/DouY2Fzd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span></p>
<p>The algorithm traverses through each cell in the grid using nested loops, where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). For each cell containing a server (<code>grid[row][col] == 1</code>), it performs two additional checks:</p>
<ol>
<li>It checks the entire row to see if there is another server in the same row. This involves iterating over <span class="math inline">\(n\)</span> columns.</li>
<li>If no server is found in the same row, it checks the entire column to see if there is another server in the same column. This involves iterating over <span class="math inline">\(m\)</span> rows.</li>
</ol>
<p>Since these checks are performed for each server, the worst-case time complexity is <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only maintains a few variables (<code>numRows</code>, <code>numCols</code>, <code>communicableServersCount</code>, <code>canCommunicate</code>, etc.). No additional data structures are used that scale with the input size. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-track-using-two-arrays">Approach 2: Track Using Two Arrays</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To optimize the checking process, the first step is to count how many servers exist in each row and each column before we start checking individual servers.</p>
<p>We donâ€™t need to check the entire row and column every time for every server. Instead, we can track the number of servers in each row and column using two arrays: <code>rowCounts</code> and <code>colCounts</code>. We loop over the grid once, and for each server (<code>grid[row][col] == 1</code>), we increment the count for the corresponding row and column. This precomputes how many servers are present in each row and column.</p>
<p>The advantage of this approach is that we know in advance how many servers are in a given row or column, so when we encounter a server, we can quickly determine if itâ€™s communicable by checking these precomputed values.</p>
<p>Once we have the counts of servers in each row and column, the next task is to identify which servers are communicable. For a server at position <code>(row, col)</code>, we need to check:</p>
<ul>
<li>If the row has more than one server (i.e., <code>rowCounts[row] &gt; 1</code>), which means there are other servers in the same row.</li>
<li>If the column has more than one server (i.e., <code>colCounts[col] &gt; 1</code>), which means there are other servers in the same column.</li>
</ul>
<p>If either condition is true, the server can communicate, and we increment the count of communicable servers.</p>
<p>Once weâ€™ve checked all servers and counted the communicable ones, we simply return the count.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize two arrays, <code>rowCounts</code> and <code>colCounts</code>, of appropriate sizes to keep track of the server counts in each row and column.</p>
</li>
<li>
<p>Count servers in each row and column:</p>
<ul>
<li>Iterate through each row (<code>row</code>), and for each row, iterate through each column (<code>col</code>):
<ul>
<li>If thereâ€™s a server at <code>grid[row][col]</code>, increment the corresponding values in <code>rowCounts[row]</code> and <code>colCounts[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize <code>communicableServersCount</code> to <code>0</code>, which will store the count of servers that can communicate.</p>
</li>
<li>
<p>Count servers that can communicate (i.e., those in the same row or column as another server):</p>
<ul>
<li>Iterate again through each row and column:
<ul>
<li>If thereâ€™s a server at <code>grid[row][col]</code>, check if it can communicate with another server (i.e., if <code>rowCounts[row] &gt; 1</code> or <code>colCounts[col] &gt; 1</code>).</li>
<li>If so, increment <code>communicableServersCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7NwwDvo6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The first nested loop iterates over each row in the grid to count the number of servers in each row and column. The outer loop runs <span class="math inline">\(m\)</span> times (for each row), and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second nested loop also iterates over each row in the grid to determine if a server can communicate with others in its row or column. This again involves an outer loop running <span class="math inline">\(m\)</span> times and an inner loop running <span class="math inline">\(n\)</span> times, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Since both loops are independent and each has a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional arrays:<br />
- <code>rowCounts</code> of size <span class="math inline">\(n\)</span> (number of columns) to store the count of servers in each column.<br />
- <code>colCounts</code> of size <span class="math inline">\(m\)</span> (number of rows) to store the count of servers in each row.</p>
<p>The space required for these arrays is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-server-grouping">Approach 3: Server Grouping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 2, we were repeatedly scanning the entire row and column for each server to check if there were any other servers for communication. While this method works, it is somewhat redundant since we perform the same checks multiple times. The goal now is to micro-optimize the process.</p>
<p>Instead of directly checking the count of servers in every row and column each time we find a server, we aim to track the necessary information during our first pass so that in the second pass, we can make decisions more quickly. This will reduce some runtime redundancy.</p>
<p>We begin by initializing a <code>colCount</code> array, where each entry tracks the number of servers in that row. By maintaining this count, we can easily find if a server can communicate based on the number of servers in the same row.</p>
<p>In addition to counting the servers in each row and column, we use another array, <code>lastServerInRow</code>, to track the position of the last server in each column. This is crucial because if a column has multiple servers, we donâ€™t need to check the entire column again. Instead, we can focus on whether the last server in a column is part of a communicable set (i.e., a row or column with multiple servers). For example, if <code>lastServerInRow[0]</code> is 3, it means the last server in column 0 is at row 3. If this server can communicate, it indicates that there are other servers in that column, and we can mark it as communicable without needing to scan all rows again.</p>
<p>Now we process each server in the grid by iterating over the rows and columns. For each server we encounter, we:</p>
<ul>
<li>Increment the count for that row in the <code>colCount</code> array.</li>
<li>Track the position of the last server in the <code>lastServerInRow</code> array.</li>
</ul>
<p>Thus, we gather all the necessary information about how many servers are in each row and column and the position of the last server.</p>
<p>After collecting this information, we use the <code>colCount</code> and <code>lastServerInRow</code> arrays to identify communicable servers. For each server in the grid, we check if the count of servers in the same row is greater than 1. If it is, we know that this server can communicate with another server in the same row. Similarly, we check if the serverâ€™s column has more than one server using the <code>lastServerInRow</code> array. If the server is part of a communicable set (i.e., there are other servers in the same row or column), we increase the count of communicable servers.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1267/server_grouping.json:760,532!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>communicableServersCount</code> to 0 to keep track of servers that can communicate.</li>
<li>Initialize <code>colCount</code> to store the count of servers in each row, and <code>lastServerInRow</code> to track the last server in each column.</li>
</ul>
<h5 id="first-pass-count-servers-in-each-row-and-column">First Pass: Count servers in each row and column</h5>
<ol>
<li>Iterate through each row (<code>row</code>):
<ul>
<li>For each row, initialize <code>serverCountInRow</code> to 0 to track the number of servers in that row.</li>
<li>Iterate through each column (<code>col</code>):
<ul>
<li>If a server is found at <code>grid[row][col]</code>, increment <code>serverCountInRow</code>, update <code>colCount[col]</code>, and set <code>lastServerInRow[col]</code> to <code>row</code>.</li>
</ul>
</li>
<li>If the row has more than one server, increment <code>communicableServersCount</code> by the number of servers in the row and set <code>lastServerInRow[col]</code> to -1 (indicating no servers to communicate in that column).</li>
</ul>
</li>
</ol>
<h5 id="second-pass-check-if-servers-can-communicate">Second Pass: Check if servers can communicate</h5>
<ol start="2">
<li>Iterate again through each column (<code>col</code>):
<ul>
<li>If there is a server at <code>lastServerInRow[col]</code> and the count of servers in the corresponding row (<code>colCount[lastServerInRow[col]]</code>) is greater than one, increment <code>communicableServersCount</code> by 1.</li>
</ul>
</li>
</ol>
<ul>
<li>Finally, return <code>communicableServersCount</code>, the total count of servers that can communicate.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/8eyTWJqP/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm performs two passes over the grid. In the first pass, it iterates over each cell in the grid to count the number of servers in each row and column. This involves nested loops where the outer loop runs <span class="math inline">\(m\)</span> times (for each row) and the inner loop runs <span class="math inline">\(n\)</span> times (for each column). This results in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The second pass iterates over the rows to check if servers can communicate based on the counts computed in the first pass. This pass runs in <span class="math inline">\(O(m)\)</span> time. Since <span class="math inline">\(O(m \cdot n)\)</span> dominates <span class="math inline">\(O(m)\)</span>, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p>The algorithm uses two additional data structures: <code>colCount</code> and <code>lastServerInRow</code>. The <code>colCount</code> array has a size of <span class="math inline">\(n\)</span> (number of columns), and the <code>lastServerInRow</code> array has a size of <span class="math inline">\(m\)</span> (number of rows). Therefore, the space complexity is <span class="math inline">\(O(m + n)\)</span>.</p>
<p>The space used by the input grid is not counted towards the space complexity as it is part of the input.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized">Approach 4: Space Optimized</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of keeping an array to track the position of the last server in each column, we just count the number of servers directly in each row and perform a simple check when a single server is found, leveraging the grid's structure itself.</p>
<p>We start by iterating over each row in the grid. For each row, we count how many servers are present. As we count, we also keep track of the column index of the first server encountered. This is important because if thereâ€™s only one server in the row, we need to check if thereâ€™s any other server in the same column.</p>
<p>Once the row is processed, we check if there are multiple servers in that row. If there are, we conclude that all servers in that row can communicate with each other, so we add the count of servers in that row to the total communicable servers count.</p>
<p>If thereâ€™s exactly one server in the row, we then check all the other rows to see if thereâ€™s any server in the same column as that single server. If such a server exists, then the lone server in that row is communicable, and we add it to the total count.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>cols</code> to the dimensions of the grid, and <code>communicableServersCount</code> to <code>0</code>, which will store the total count of communicable servers.</p>
</li>
<li>
<p>Iterate through each row (<code>rowIndex</code>):</p>
<ul>
<li>
<p>Initialize <code>rowCounts</code> to count the number of servers in the current row, and <code>serverColumnIndex</code> to store the column index of the first server in the row.</p>
</li>
<li>
<p>Count the servers in the current row:</p>
<ul>
<li>Iterate through each column (<code>colIndex</code>):
<ul>
<li>If there's a server (<code>grid[rowIndex][colIndex]</code>), update <code>serverColumnIndex</code> if it is the first server found, and increment <code>rowCounts</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check if the row has more than one server (<code>rowCounts != 1</code>), meaning servers in the row can communicate. If not, check for a server in the same column (<code>serverColumnIndex</code>) in other rows.</p>
</li>
<li>
<p>If the server can communicate (either because there are multiple servers in the row or another server exists in the same column in another row), add <code>rowCounts</code> to <code>communicableServersCount</code>.</p>
</li>
</ul>
</li>
<li>
<p>After iterating through all rows, return <code>communicableServersCount</code>, the total count of servers that can communicate.</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/89oda5wC/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The algorithm iterates over each cell in the grid once to count the number of servers in each row and determine if they can communicate. For each row, it takes <span class="math inline">\(O(n)\)</span> time to count the servers and <span class="math inline">\(O(m)\)</span> time to check if a server in a row can communicate with another server in the same column. Since there are <span class="math inline">\(m\)</span> rows, the total time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>The nested loops and the checks for communication contribute to this time complexity. The outer loop runs <span class="math inline">\(m\)</span> times, and the inner loops run <span class="math inline">\(n\)</span> times and <span class="math inline">\(m\)</span> times respectively, leading to the overall time complexity of <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm does not allocate any additional memory that depends on the size of the input grid. All operations are performed in-place using a fixed number of variables.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-sorted-rows2702/1" target="_blank" rel="noopener noreferrer">Count Sorted Rows</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given two integers N and M and a matrix of dimensions N*M.&nbsp;Count all the rows in a matrix that are sorted either in strictly increasing order or in strictly decreasing order.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3,M=3
Mat=[[1,2,3],[6,5,4],[7,9,8]]
<strong>Output:</strong>
2
<strong>Explanation:</strong>
The first row is sorted in strictly 
increasing order while the second row 
is sorted in strictly decreasing order.</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3,M=3
Mat=[[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong>
3
<strong>Explanation:</strong>
All the rows are sorted in strictly 
increasing order.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything.Your task is to complete the function <strong>sortedCount() </strong>which takes the two integers N,M and the matrix Mat as input parameters and returns the number of rows which are sorted in either strictly increasing order or strictly decreasing order.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N*M)<br />
<strong>Expected Auxillary Space:</strong>O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N,M,Mat[i][j]&lt;=1000</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-square-submatrices-with-all-ones/description" target="_blank" rel="noopener noreferrer">Count Square Submatrices with All Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m * n</code> matrix of ones and zeros, return how many <strong>square</strong> submatrices have all ones.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix =
[
&nbsp; [0,1,1,1],
&nbsp; [1,1,1,1],
&nbsp; [0,1,1,1]
]
<strong>Output:</strong> 15
<strong>Explanation:</strong> 
There are <strong>10</strong> squares of side 1.
There are <strong>4</strong> squares of side 2.
There is  <strong>1</strong> square of side 3.
Total number of squares = 10 + 4 + 1 = <strong>15</strong>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
<strong>Output:</strong> 7
<strong>Explanation:</strong> 
There are <b>6</b> squares of side 1.  
There is <strong>1</strong> square of side 2. 
Total number of squares = 6 + 1 = <b>7</b>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length&nbsp;&lt;= 300</code></li>
	<li><code>1 &lt;= arr[0].length&nbsp;&lt;= 300</code></li>
	<li><code>0 &lt;= arr[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the number of square submatrices containing only ones in a binary matrix. A square submatrix has equal rows and columns, such as <code>1x1</code>, <code>2x2</code>, <code>3x3</code>, and so on.</p>
<ol>
<li>1x1 submatrices: Each cell with only a <code>1</code> contributes directly to the count.</li>
<li>Larger submatrices: For submatrices larger than <code>1x1</code>, the size of the largest square submatrix with its bottom right corner at <code>(i, j)</code> determines the count of possible square submatrices.</li>
</ol>
<p><img src="../Figures/1277re/Slide1re.png" alt="slide1" /></p>
<p>For a <code>2x2</code> square ending at <code>(i, j)</code>, the following conditions must be met:</p>
<ul>
<li>The cell at <code>(i, j)</code> must be <code>1</code>.</li>
<li>The cells above <code>(i-1, j)</code>, to the left <code>(i, j-1)</code>, and diagonally <code>(i-1, j-1)</code> must also be <code>1</code>.</li>
</ul>
<p><img src="../Figures/1277re/Slide2re.png" alt="slide2" /></p>
<p>Similarly, for a <code>3x3</code> square:</p>
<ul>
<li>The <code>2x2</code> square formed by the neighbors <code>(i-1, j-1)</code>, <code>(i-1, j)</code>, and <code>(i, j-1)</code> must be valid.</li>
</ul>
<p><img src="../Figures/1277re/Slide3re.png" alt="slide3" /></p>
<p>Thus, constructing larger submatrices relies on the existence of smaller valid ones.</p>
<hr />
<h3 id="approach-1-bottom-up-approach">Approach 1: Bottom-up Approach</h3>
<h4 id="intuition">Intuition</h4>
<p>We initialize another matrix (<code>dp</code>) with the same dimensions as the original one initialized with all 0â€™s.</p>
<p><code>dp(i,j)</code> represents the side length of the maximum square whose bottom right corner is the cell with index <code>(i,j)</code> in the original matrix.</p>
<p>Starting from index <code>(0,0)</code>, for every 1 found in the original matrix, we update the value of the current element as:</p>
<p><span class="math display">\[\text{dp}(i+1,\  j+1) = \min \big( \text{dp}(i,\  j+1),\  \text{dp}(i+1,\  j),\  \text{dp}(i,\  j) \big) + 1.
\]</span></p>
<p>We store the sizes of the largest squares in the <code>dp</code> array. This gives the side length of the maximal squares upto every index filled with all 1s. The required result is the sum of the sizes of these squares, so we can accumulate them and return the result.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create a 2D DP table <code>dp</code> of size <code>(row+1) x (col+1)</code> to store the size of the largest square submatrices ending at each cell <code>(i, j)</code>.</li>
<li>This extra row and column (initialized to 0) help handle boundary conditions and simplify the logic for edge cases.</li>
<li>Initialize a variable <code>ans</code> to keep track of the total number of square submatrices with all 1s.</li>
<li>Traverse the input matrix using a nested loop:
<ul>
<li>Outer loop iterates over the rows (<code>i</code> from 0 to <code>row-1</code>).
<ul>
<li>Inner loop iterates over the columns (<code>j</code> from 0 to <code>col-1</code>):
<ul>
<li>For each cell <code>matrix[i][j]</code>, if the value is 1, calculate the size of the square submatrix ending at that cell.</li>
<li>Use the following relation to fill the <code>dp</code> matrix: <code>dp[i+1][j+1] = min(dp[i][j+1],dp[i+1][j],dp[i][j])+1</code></li>
<li>Add this value to the total count <code>ans</code>, which keeps track of all squares found so far.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>ans</code>, which represents the total number of square submatrices filled with 1s.</li>
</ol>
<p>!?!../Documents/1277-re/slideshow1_rename.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Dc4KocxB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(row\)</span> and <span class="math inline">\(col\)</span> be the number of rows and columns in the matrix respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(row \cdot col)\)</span></p>
<p>The solution iterates through every cell in the matrix using two nested loops. Since the matrix has dimensions <code>row x col</code>, the total number of cells is <code>row x col</code>.</p>
<p>Inside the loop, we perform constant-time operations (computing the minimum of three values and updating the result).</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(row \cdot col)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(row \cdot col)\)</span>.</p>
<p>The space complexity is dominated by the 2D DP table <code>dp</code>, which is of size <code>(row+1) x (col+1)</code>. This extra row and column are used to handle boundary conditions.</p>
<p>Therefore, the total space required is <span class="math inline">\(O(row \cdot col)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-top-down-dynamic-programming">Approach 2: Top-Down Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also approach this problem using recursion, breaking it down into smaller subproblems. At each cell <code>(i, j)</code>, the size of the largest square submatrix depends on the sizes of the submatrices at its neighboring cells: <code>(i-1, j)</code>, <code>(i, j-1)</code>, and <code>(i-1, j-1)</code>. This recursive structure enables us to tackle the problem incrementally.</p>
<p>To optimize, we can convert the recursive approach into a dynamic programming (DP) solution. The DP table will store results of subproblems, preventing redundant calculations and improving time complexity.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><code>solve(i, j, grid, dp)</code> function:</p>
<ol>
<li>If the current cell <code>grid[i][j]</code> is outside the bounds of the grid or is 0, return 0. This means no square submatrices can be formed from this cell.</li>
<li>If a cell's result is already computed (i.e., <code>dp[i][j]</code> != -1), return the memoized value to avoid redundant calculations.</li>
<li>For each cell <code>(i, j)</code>, recursively calculate the size of the square submatrices:
<ul>
<li>right: Check the cell to the right <code>(i, j+1)</code>.</li>
<li>diagonal: Check the cell to the diagonal below <code>(i+1, j+1)</code>.</li>
<li>below: Check the cell below <code>(i+1, j)</code>.</li>
</ul>
</li>
<li>For a given cell <code>(i, j)</code>, store the result as <code>1 + min(right, diagonal, below)</code> in the <code>dp</code> table. This accounts for the size of the largest square submatrix that can end at this cell, including the current cell itself.</li>
</ol>
<p>Main function:</p>
<ol>
<li>Initialize a DP table:
<ul>
<li>Create a <code>dp</code> table (2D vector) of the same size as the input grid, and initialize it with -1 to indicate unvisited cells.</li>
</ul>
</li>
<li>Use a nested loop to iterate through each cell in the grid. For each cell <code>(i, j)</code>, call the recursive function <code>solve(i, j)</code> to compute the size of the largest square submatrices ending at that cell and add it to the total count.</li>
<li>Finally, return the total number of square submatrices with all 1s.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/jX6Cbaqu/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(row\)</span> and <span class="math inline">\(col\)</span> be the number of rows and columns in the matrix respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(row \cdot col)\)</span></p>
<p>The <code>solve(i, j)</code> function is called for each cell in the grid. However, due to memoization, the value for each cell is computed only once, and the result is stored in the <code>dp</code> table. This prevents recomputation for the same cell.</p>
<p>Hence, there are <code>row * col</code> calls to the function, where <code>row</code> is the number of rows, and <code>col</code> is the number of columns.</p>
<p>For each cell <code>(i, j)</code>, the function makes constant time calculations for its neighbors: <code>right</code>, <code>diagonal</code>, and <code>below</code>. Each of these operations takes constant time <code>O(1)</code>.</p>
<p>Thus, the overall time complexity is <code>O(row * col)</code>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(row \cdot col)\)</span></p>
<p>The <code>dp</code> table is a 2D array of size <code>row * col</code> used to store the memoized results. This requires <code>O(row * col)</code> space.</p>
<p>The recursion depth is bounded by the number of rows <code>row</code> or columns <code>col</code> in the worst case, depending on how far the recursion can go in the grid. This requires <code>O(max(row, col))</code> space for the call stack.</p>
<p>Thus, the overall space complexity is <code>O(row * col)</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-optimized-dynamic-programming">Approach 3: Optimized Dynamic Programming</h3>
<h4 id="intuition-2">Intuition</h4>
<p>From the previous approach we can observe that calculating the size of the largest square submatrix ending at a given cell <code>(i, j)</code> only depends on three values: the size of the largest square ending at <code>(i, j-1)</code> (left), <code>(i-1, j)</code> (top), and <code>(i-1, j-1)</code> (top-left). These values are sufficient to determine the size of the square submatrix ending at <code>(i, j)</code> using the relation:</p>
<p><span class="math inline">\(dp[j] = 1 + \min(dp[j-1], dp[j], \text{prev})\)</span></p>
<p>where <code>prev</code> stores the value of <code>dp[j]</code> from the previous row, effectively representing the top-left neighbor in the matrix.</p>
<p>With this dependency in mind, we can optimize the traditional 2D dynamic programming table to a 1D array. Instead of maintaining the entire DP table, we use a single array <code>dp</code>, where each element corresponds to the size of the largest square submatrix ending at a column in the current row. To handle the dependency on the top-left neighbor, we maintain an additional variable <code>prev</code> to store the value of <code>dp[j]</code> before it is updated in the current iteration.</p>
<p>We initialize the <code>dp</code> array with all zeros since initially, no square submatrices have been identified. As we iterate through the matrix row by row, we update the <code>dp</code> array for each element in the current row. If the matrix element at <code>(i-1, j-1)</code> is <code>1</code>, it means that this cell can contribute to forming a square. In that case, we calculate the size of the square using the relation mentioned earlier. If the element is <code>0</code>, the size of the square at that cell is reset to <code>0</code>.</p>
<p>The <code>prev</code> variable is updated during each iteration to store the value of <code>dp[j]</code> before it is modified. This ensures that the dependency on the top-left neighbor is correctly accounted for in the current calculation. After updating the value of <code>dp[j]</code>, we add it to the <code>result</code> variable, which accumulates the total number of square submatrices in the matrix.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create a 1D DP table <code>dp</code> of size <code>(row+1) x (col+1)</code> to store the size of the largest square submatrices ending at each cell <code>(i, j)</code>.</li>
<li>This extra column (initialized to 0) helps handle boundary conditions and simplify the logic for edge cases.</li>
<li>Initialize a variable <code>result</code> to keep track of the total count of square submatrices and a variable <code>prev</code> to store the value of the top-left diagonal element for the DP computation.</li>
<li>Traverse the input matrix using a nested loop:
<ul>
<li>Outer loop iterates over the rows (<code>i</code> from 0 to <code>row-1</code>).
<ul>
<li>Inner loop iterates over the columns (<code>j</code> from 0 to <code>col-1</code>):
<ul>
<li>For each cell <code>matrix[i][j]</code>, if the value is 1:
<ul>
<li>Temporarily store the current value of <code>dp[j]</code> in a variable <code>temp</code>.</li>
<li>Update <code>dp[j]</code> using the formula <code>dp[j] = 1 + min(prev, min(dp[j-1], dp[j]))</code>.</li>
<li>Update <code>prev </code>to the value stored in <code>temp</code>.</li>
<li>Add <code>dp[j]</code> to <code>result</code> to increment the count of square submatrices.</li>
</ul>
</li>
<li>Otherwise, set <code>dp[j]</code> to 0 as no square submatrix ends at this cell.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>result</code>, which represents the total number of square submatrices filled with 1s.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/JFiPdsqk/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(row\)</span> and <span class="math inline">\(col\)</span> be the number of rows and columns in the matrix respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(row \cdot col)\)</span></p>
<p>The solution iterates through every cell in the matrix using two nested loops. Since the matrix has dimensions <code>row x col</code>, the total number of cells is <code>row x col</code>.</p>
<p>Inside the loop, we perform constant-time operations (computing the minimum of three values and updating the result).</p>
<p>Thus, the overall time complexity is <span class="math inline">\(O(row \cdot col)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(col)\)</span></p>
<p>The space complexity is dominated by the DP array <code>dp</code>, which is of size <code>(col+1)</code>. This extra column is used to handle boundary conditions.</p>
<p>Therefore, the total space required is <span class="math inline">\(O(col)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-sub-islands/description" target="_blank" rel="noopener noreferrer">Count Sub Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An <strong>island</strong> is a group of <code>1</code>&#39;s connected <strong>4-directionally</strong> (horizontal or vertical). Any cells outside of the grid are considered water cells.</p>

<p>An island in <code>grid2</code> is considered a <strong>sub-island </strong>if there is an island in <code>grid1</code> that contains <strong>all</strong> the cells that make up <strong>this</strong> island in <code>grid2</code>.</p>

<p>Return the <em><strong>number</strong> of islands in </em><code>grid2</code> <em>that are considered <strong>sub-islands</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/test1.png" style="width: 493px; height: 205px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png" style="width: 491px; height: 201px;" />
<pre>
<strong>Input:</strong> grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
<strong>Output:</strong> 2 
<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid1.length == grid2.length</code></li>
	<li><code>n == grid1[i].length == grid2[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two binary matrices, <code>grid1</code> and <code>grid2</code>, both of size <code>m x n</code>, where 1 represents land and 0 represents water. An island is a group of connected 1s, connected horizontally or vertically. The task is to find how many islands in <code>grid2</code> are also sub-islands of <code>grid1</code>. An island in <code>grid2</code> is considered a sub-island if every land cell of the island is part of an island in <code>grid1</code>.</p>
<p><img src="../Figures/1905/Slide-1a.png" alt="slide1a" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see all the land cells of the island of <code>grid2</code> lie on one island in grid1.</p>
<p><img src="../Figures/1905/Slide-1b.png" alt="slide1b" /></p>
<br />
<p>Let's consider another island of the <code>grid2</code>, now, is this a sub-island?</p>
<p><img src="../Figures/1905/Slide-1c.png" alt="slide1c" /></p>
<br />
<p>If we overlap this image with <code>grid1</code>, we can see two land cells are lying on the water cell, thus this island can't be considered a sub-island.</p>
<p><img src="../Figures/1905/Slide-1d.png" alt="slide1d" /></p>
<br />
<p>The above images hint that; to check whether an island of <code>grid2</code> is a sub-island in <code>grid1</code>, we can start traversing on each land cell of the current island of <code>grid2</code> and for each land cell there should be a land cell in <code>grid1</code> at the same position (at same <code>(x, y)</code> index in grids).</p>
<p>Each grid cell is connected to its adjacent neighbors 4-directionally (horizontal or vertical), this grid problem can be visualized as a graph traversal problem, where each cell is a node and the 4-directions are edges connecting those nodes.</p>
<p><img src="../Figures/1905/Slide-1e.png" alt="slide1e" /></p>
<br />
<p>We will iterate on each cell of the <code>grid2</code>, if the current cell is a land cell we traverse the whole island of <code>grid2</code> containing the current land cell. While traversing over the entire island we keep track if, for each land cell of the island of <code>grid2</code>, the <code>grid1</code> also has a land cell at the respective position using a boolean variable. After iteration on the current island is completed this boolean variable will denote if the island is a sub-island or not.</p>
<br />
<p>The following slideshow will give you an idea about this approach:</p>
<p>!?!../Documents/1905/slideshow1.json:1900,1600!?!</p>
<p>There are different techniques to traverse a graph, in this article we will cover some of them in brief, we assume you already have a good knowledge about them,<br />
if you are new to the graph traversal algorithms we recommend you read the following Leetcode articles before proceeding:</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/3883/">Breadth-First Search</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/3882/">Depth-First Search</a></li>
<li><a href="https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide">Union Find</a></li>
</ul>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Breadth-first search is used to traverse graphs level by level, and in this problem, each cell in the grid represents a node, with 4-directional connections as edges. In this context, each cell in the grid represents a node, and the horizontal and vertical connections between cells are the edges. The goal is to check if an island in <code>grid2</code> is a sub-island of <code>grid1</code>. We start BFS from each unvisited land cell in <code>grid2</code> and verify if all corresponding cells in <code>grid1</code> are also land cells. If we encounter a land cell in <code>grid2</code> where the corresponding cell in <code>grid1</code> is water, the island in <code>grid2</code> is not a sub-island.</p>
<p>We iterate through each cell in <code>grid2</code>, initiating BFS from each unvisited land cell to explore the island. During the traversal, we use a boolean flag <code>isSubIsland</code> to track if all corresponding cells in <code>grid1</code> are land. If the flag remains <code>true</code> after the traversal, we increment our sub-island count.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> which returns a boolean value indicating whether the island of <code>grid2</code> containing cell at position <code>(x, y)</code> is a sub-island in <code>grid1</code> or not. This method will utilize the BFS algorithm to traverse all cells of the island of the <code>grid2</code>:
<ul>
<li>Initialize a variable <code>isSubIsland</code> to <code>true</code>, indicating whether the island of <code>grid2</code> is a sub-island or not.</li>
<li>Initialize a queue, push the starting cell <code>(x, y)</code> in queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the current cell from the queue.</li>
<li>If the cell in <code>grid1</code> at the same position as the current cell of <code>grid2</code> is not a land cell then this island can't be a sub-island so we will mark the <code>isSubIsland</code> flag as <code>false</code>.</li>
<li>Next, we move in all 4 directions one by one using the <code>directions</code> array. If the cell at the next position <code>(nextX, nextY)</code> lies inside the <code>grid2</code>, was not visited earlier, and is also a land cell, then we will traverse on this cell, hence, push it in the queue and mark it as visited.</li>
</ul>
</li>
<li>When we traverse all cells of the current island we return <code>isSubIsland</code>.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as the <code>grid2</code> matrix to mark visited land cells.</li>
<li>Initialize a variable <code>subIslandsCount</code> to <code>0</code>, to count the total number of islands in <code>grid2</code> which are also sub-islands.</li>
<li>Iterate on all cells of the <code>grid2</code> using nested for loop, if the current cell is never visited, is a land cell in <code>grid2</code>, and is a sub-island then increment the <code>subIslandsCount</code> by <code>1</code>.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/mVB8kFHK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform BFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the queue.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Depth-first search (DFS) explores as far as possible along each branch before backtracking, making it effective for checking if an island in <code>grid2</code> is a sub-island of <code>grid1</code>.</p>
<p>We start by iterating through each cell in <code>grid2</code>. Upon encountering an unvisited land cell, we initiate a DFS to mark all connected land cells as visited. During the traversal, we compare each cell in <code>grid2</code> with the corresponding cell in <code>grid1</code>. If any land cell in <code>grid2</code> maps to a water cell in <code>grid1</code>, the island is disqualified. If the island passes the check, it is counted as a sub-island.</p>
<p>DFS is ideal for this task because it efficiently handles deep, recursive exploration, avoiding the need for additional data structures like a queue.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create an array <code>directions</code> for the four movement directions: up, down, left, and right, representing changes in <code>(x, y)</code> coordinates.</li>
<li>Define a helper method <code>isCellLand(x, y, grid)</code> to check if the cell at <code>(x, y)</code> in <code>grid</code> is a land cell.</li>
<li>Define a helper method <code>isSubIsland(x, y, grid1, grid2, visited)</code> to determine if the island in <code>grid2</code> containing cell <code>(x, y)</code> is a sub-island of <code>grid1</code>. This method uses DFS to:
<ul>
<li>Initialize <code>isSubIsland</code> as <code>true</code>.</li>
<li>Check if the corresponding cell in <code>grid1</code> is land; if not, set <code>isSubIsland</code> to <code>false</code>.</li>
<li>Move in all four directions. For each valid, unvisited land cell in <code>grid2</code>, recursively check if itâ€™s part of a sub-island and update <code>isSubIsland</code> accordingly.</li>
<li>Return <code>isSubIsland</code> after traversing the island.</li>
</ul>
</li>
<li>Initialize a boolean <code>visited</code> matrix of the same size as <code>grid2</code> to keep track of visited cells.</li>
<li>Initialize <code>subIslandsCount</code> to <code>0</code> to count sub-islands.</li>
<li>Iterate through all cells of <code>grid2</code>. For each unvisited land cell, use <code>isSubIsland</code> to check if it's a sub-island of <code>grid1</code>. Increment <code>subIslandsCount</code> if it is.</li>
<li>Return <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VSRKGot2/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each grid cell and perform DFS to traverse all land cells of all the islands. Each land cell is only traversed once. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional grid <code>visited</code> of size <span class="math inline">\(m * n\)</span> and push the land cells in the recursive stack.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find">Approach 3: Union-Find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Union-Find, or Disjoint Set Union (DSU), is a data structure that efficiently manages disjoint subsets, supporting quick union and find operations. Itâ€™s well-suited for problems where you need to determine if elements are in the same subset or to merge subsets. The key idea is to treat each island as a separate set and unite these sets based on connectivity.</p>
<p>In the context of this problem, we start by representing each land cell in both grids as a node in a graph. The main challenge is to determine whether an island in <code>grid2</code> is a sub-island of <code>grid1</code>, which means all cells of an island in <code>grid2</code> must also belong to the corresponding island in <code>grid1</code>. To implement this, we can follow these steps:</p>
<p>First, we initialize a Union-Find data structure where each cell initially belongs to its own set. As we iterate through the grid, we union adjacent land cells (cells with value <code>1</code>) in <code>grid2</code>. This results in a partitioning of the grid into distinct islands, where each island is represented by its parent node in the Union-Find structure.</p>
<p>After unionizing all possible cells within each grid, the next step is to compare the islands in <code>grid2</code> with the corresponding islands in <code>grid1</code>. As we discussed in the overview section, for each land cell in <code>grid2</code> there should be a corresponding land cell at the same position in <code>grid1</code> as well. If any land cell in an island of <code>grid2</code> does not have a corresponding land cell in <code>grid1</code>, the entire island containing that land cell is disqualified as a sub-island and we mark the parent cell of that island of <code>grid2</code> as not a sub-island.</p>
<p>Union-Find allows us to efficiently manage and compare these islands by providing quick union operations to group cells and find operations to identify the root of any given cell. Additionally, the process is optimized by two key techniques: path compression and union by rank. Path compression ensures that during the find operation, each node on the path to the root directly connects to the root, making future find operations faster. Union by rank helps to keep the tree representing each set shallow by always attaching the smaller tree under the root of the larger tree during union operations.</p>
<p>By the end of the process, the number of valid sub-islands can be determined by counting how many islands in <code>grid2</code> satisfy the condition of being entirely contained within the corresponding islands in <code>grid1</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Create an array of <code>directions</code> storing the up, down, left, and right direction movements which is the change in the <code>(x, y)</code> position value of the cell while moving.</li>
<li>Create a helper method <code>isCellLand(x, y, grid)</code> which returns a boolean value indicating whether the cell at position <code>(x, y)</code> in <code>grid</code> is a land cell or not.</li>
<li>Create a class <code>UnionFind</code> which initialized two arrays <code>rank</code> and <code>parent</code> with size <code>n</code>. Initially rank of all elements is <code>0</code> and the parent is the element itself.
<ul>
<li>Create a method <code>int find(int u)</code>, which returns the <code>parent</code> of element <code>u</code> using the path compression technique.</li>
<li>Create a method <code>void unionSets(int u, int v)</code>, which joins two components of elements <code>u</code> and <code>v</code> into one based on their parent's ranks.</li>
</ul>
</li>
<li>Create a helper method <code>convertToIndex(int x, int y, int totalCols)</code> which converts and returns the 2-dimensional position to a 1-dimensional index.</li>
<li>Initialize a <code>UnionFind</code> object <code>uf</code> with size the same as <code>grid2</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> using nested for loop, and join the adjacent cells to the current land cell if they are also a land cell.</li>
<li>Initialize a boolean array <code>isSubIsland</code> with the size same as <code>grid2</code> initially storing <code>true</code>.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if the respective cell in the <code>grid1</code> isn't a land cell then mark the <code>parent</code> node of the current land cell's island as <code>false</code> in the <code>isSubIsland</code> array.</li>
<li>Iterate on all land cells of the <code>grid2</code> and if <code>isSubIsland</code> for the parent cell is <code>true</code> count the sub-island, i.e. increment <code>subIslandsCount</code> by <code>1</code> and mark it as <code>false</code> to prevent counting it multiple times.</li>
<li>At the end return, <code>subIslandsCount</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/jhroFs5M/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> represent the number of rows and columns, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We iterate on each land cell of the grid and perform union operations with its adjacent cells. In the worst case, we may traverse all cells of the grid.</p>
<p>Thus, in the worst case time complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m * n)\)</span></p>
<p>We create an additional object <code>uf</code> and a boolean array <code>isSubIsland</code> of size <span class="math inline">\(m * n\)</span>.</p>
<p>Thus, in the worst case space complexity will be <span class="math inline">\(O(m * n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-all-ones/description" target="_blank" rel="noopener noreferrer">Count Submatrices With All Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, <em>return the number of <strong>submatrices</strong> that have all ones</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[1,0,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
<strong>Output:</strong> 24
<strong>Explanation:</strong> 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 150</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-1-enumeration">Approach 1: Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>A straightforward idea is to enumerate each position <span class="math inline">\((i,j)\)</span> in the matrix and count how many submatrices with this position as the bottom-right corner have all elements equal to <span class="math inline">\(1\)</span>. By doing this, we can count the number of submatrices that meet the condition without repetition or omission. After enumeration, the question is: how do we count the number of submatrices that meet the condition?</p>
<p>We preprocess a <span class="math inline">\(\textit{row}\)</span> array, where <span class="math inline">\(\textit{row}[i][j]\)</span> represents the number of consecutive <span class="math inline">\(1\)</span>s extending to the left from position <span class="math inline">\((i,j)\)</span> in the matrix. The recursive formula is straightforward:</p>
<p><span class="math display">\[row[i][j]=\begin{cases}
0, & \quad mat[i][j]= 0 \\
row[i][j-1]+1, & \quad mat[i][j]= 1
\end{cases}
\]</span></p>
<p>Once we have the <span class="math inline">\(\textit{row}\)</span> array, if we want to count the number of subrectangles with <span class="math inline">\((i,j)\)</span> as the bottom-right corner that satisfy the condition, we can enumerate the height of the subrectangles and check how many of them are valid. We start this enumeration from the <span class="math inline">\(i\)</span>-th row and move upward. For the <span class="math inline">\(i\)</span>-th row, there are <span class="math inline">\(\textit{row}[i][j]\)</span> subrectangles that satisfy the condition. For the <span class="math inline">\(i-1\)</span>-th row, there are <span class="math inline">\(\texttt{min}(\textit{row}[i][j], \textit{row}[i-1][j])\)</span> subrectangles, because both rows must consist entirely of <span class="math inline">\(1\)</span>s to satisfy the condition. The same logic applies to higher rows, where we continuously take the minimum value to ensure the condition holds. Enumerating from bottom to top allows us to update the minimum in constant time.</p>
<p>Following this idea, for each bottom-right point <span class="math inline">\((i,j)\)</span>, the number of valid subrectangles can be calculated in linear time. After traversing all points, we obtain the total number of subrectangles that satisfy the condition.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/G6ziSppd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows of the matrix and <span class="math inline">\(n\)</span> be the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m^2\times n)\)</span>.</p>
<p>The code involves a triple loop.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m\times n)\)</span>.</p>
<p>An <span class="math inline">\(m \times n\)</span> matrix is needed for enumeration.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The goal is to count the number of submatrices in which all elements are <span class="math inline">\(1\)</span>. Similar to the first approach, we can still <strong>enumerate the bottom-right corner of each submatrix</strong>, but here we use a more efficient counting method with a monotonic stack. The method works as follows:</p>
<ol>
<li>
<p><strong>Process each row as the base.</strong><br />
Convert each row of the matrix into a histogram height array <span class="math inline">\(\textit{heights}\)</span>, where <span class="math inline">\(\textit{heights}[j]\)</span> represents the number of consecutive <span class="math inline">\(1\)</span>s extending upward in column <span class="math inline">\(j\)</span>, with the current row as the bottom.<br />
For example, if the current row is treated as the base, then <span class="math inline">\(\textit{heights}[j]\)</span> tells us how tall the column of <span class="math inline">\(1\)</span>s is at position <span class="math inline">\(j\)</span>.</p>
</li>
<li>
<p><strong>Enumerate each column as the right boundary.</strong><br />
For each row, once the heights are calculated, we use a monotonic stack to find the nearest column on the left of each <span class="math inline">\(\textit{heights}[j]\)</span> that has a smaller height. This gives us the left boundary for rectangles ending at <span class="math inline">\(j\)</span>.</p>
</li>
<li>
<p><strong>Count subrectangles using the left and right boundaries.</strong><br />
Suppose the right boundary is at <span class="math inline">\(j\)</span>, and the nearest smaller height on the left is at <span class="math inline">\(i\)</span> (found using the monotonic stack). Then:</p>
</li>
</ol>
<ul>
<li>If the left boundary is less than or equal to <span class="math inline">\(i\)</span>, the subrectangles ending at <span class="math inline">\(i\)</span> have already been counted. Extending them to <span class="math inline">\(j\)</span> adds no new subrectangles.</li>
<li>If the left boundary is greater than <span class="math inline">\(i\)</span>, then it can range from <span class="math inline">\(i+1\)</span> to <span class="math inline">\(j\)</span>, giving <span class="math inline">\((j - i)\)</span> possible positions. Each position can form <span class="math inline">\(\textit{heights}[j]\)</span> subrectangles of different heights, so in total we add <span class="math inline">\((j-i) \times \textit{heights}[j]\)</span> subrectangles.</li>
</ul>
<ol start="4">
<li><strong>Accumulate the result.</strong><br />
By summing over all right boundaries in each row, we obtain the total number of submatrices in the matrix with all elements equal to <span class="math inline">\(1\)</span>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HQpwvjNm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows of the matrix and <span class="math inline">\(n\)</span> be the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m\times n)\)</span>.</p>
<p>For each row, we update the <span class="math inline">\(\textit{heights}\)</span> array in <span class="math inline">\(O(n)\)</span> time, so processing all <span class="math inline">\(m\)</span> rows takes <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Within each row, we use a monotonic stack to find the left and right boundaries of each column. Since every element enters and leaves the stack at most once, the stack operations for one row take <span class="math inline">\(O(n)\)</span> time. Repeating this across all <span class="math inline">\(m\)</span> rows gives a total of <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Combining both parts, the overall time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/description" target="_blank" rel="noopener noreferrer">Count Submatrices With Equal Frequency of X and Y</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D character matrix <code>grid</code>, where <code>grid[i][j]</code> is either <code>&#39;X&#39;</code>, <code>&#39;Y&#39;</code>, or <code>&#39;.&#39;</code>, return the number of <span data-keyword="submatrix">submatrices</span> that contain:</p>

<ul>
	<li><code>grid[0][0]</code></li>
	<li>an <strong>equal</strong> frequency of <code>&#39;X&#39;</code> and <code>&#39;Y&#39;</code>.</li>
	<li><strong>at least</strong> one <code>&#39;X&#39;</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;X&quot;,&quot;Y&quot;,&quot;.&quot;],[&quot;Y&quot;,&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/06/07/examplems.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 175px; height: 350px;" /></strong></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;Y&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No submatrix has an equal frequency of <code>&#39;X&#39;</code> and <code>&#39;Y&#39;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>No submatrix has at least one <code>&#39;X&#39;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 1000</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;X&#39;</code>, <code>&#39;Y&#39;</code>, or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/description" target="_blank" rel="noopener noreferrer">Count Submatrices with Top-Left Element and Sum Less Than k</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer matrix <code>grid</code> and an integer <code>k</code>.</p>

<p>Return <em>the <strong>number</strong> of <span data-keyword="submatrix">submatrices</span> that contain the top-left element of the</em> <code>grid</code>, <em>and have a sum less than or equal to </em><code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/01/example1.png" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> grid = [[7,6,3],[6,6,1]], k = 18
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/01/example21.png" style="padding: 10px; background: #fff; border-radius: .5rem;" />
<pre>
<strong>Input:</strong> grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length </code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 1000 </code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-unguarded-cells-in-the-grid/description" target="_blank" rel="noopener noreferrer">Count Unguarded Cells in the Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>m</code> and <code>n</code> representing a <strong>0-indexed</strong> <code>m x n</code> grid. You are also given two 2D integer arrays <code>guards</code> and <code>walls</code> where <code>guards[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> and <code>walls[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> represent the positions of the <code>i<sup>th</sup></code> guard and <code>j<sup>th</sup></code> wall respectively.</p>

<p>A guard can see <b>every</b> cell in the four cardinal directions (north, east, south, or west) starting from their position unless <strong>obstructed</strong> by a wall or another guard. A cell is <strong>guarded</strong> if there is <strong>at least</strong> one guard that can see it.</p>

<p>Return<em> the number of unoccupied cells that are <strong>not</strong> <strong>guarded</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png" style="width: 300px; height: 204px;" />
<pre>
<strong>Input:</strong> m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The guarded and unguarded cells are shown in red and green respectively in the above diagram.
There are a total of 7 unguarded cells, so we return 7.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png" style="width: 200px; height: 201px;" />
<pre>
<strong>Input:</strong> m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The unguarded cells are shown in green in the above diagram.
There are a total of 4 unguarded cells, so we return 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= guards.length, walls.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>2 &lt;= guards.length + walls.length &lt;= m * n</code></li>
	<li><code>guards[i].length == walls[j].length == 2</code></li>
	<li><code>0 &lt;= row<sub>i</sub>, row<sub>j</sub> &lt; m</code></li>
	<li><code>0 &lt;= col<sub>i</sub>, col<sub>j</sub> &lt; n</code></li>
	<li>All the positions in <code>guards</code> and <code>walls</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-iterative-simulation">Approach 1: Iterative Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We want to determine which unoccupied cells are unguarded given a grid populated by guards, walls, and empty cells.</p>
<p>The vision of each guard is limited:</p>
<ul>
<li>They can see every cell in the four cardinal directions from their position: north, east, south, and west. In other words, they cannot see diagonally.</li>
<li>They cannot see past walls.</li>
</ul>
<p>Since we are given the locations of the guards and walls in the grid, the simplest approach will be to simulate each guard's range of vision. We can iterate through each direction from the guard's position until we either reach the grid's boundary, encounter another guard, or a wall, which blocks the guard's line of sight.</p>
<p>The key things to keep in mind are:</p>
<ul>
<li>Guards and walls occupy cells that cannot be guarded, so these should be distinctly marked.</li>
<li>For each guard, visibility should be checked in all four directions until an obstruction or the gridâ€™s edge is reached.</li>
<li>Once all guarded cells are marked, any unmarked cells represent unguarded areas, which can then be counted to find the solution.</li>
</ul>
<p>The following is a simulation of the approach, resulting in a final answer of 7 unguarded cells.</p>
<p>!?!../Documents/2257/2257_count_unguard.json:755,470!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize constants:</p>
<ul>
<li><code>UNGUARDED</code> (0): Represents an unguarded cell.</li>
<li><code>GUARDED</code> (1): Represents a cell that is guarded.</li>
<li><code>GUARD</code> (2): Represents a cell with a guard.</li>
<li><code>WALL</code> (3): Represents a wall cell.</li>
</ul>
</li>
<li>
<p>Define the function <code>markguarded</code> to mark cells as guarded:</p>
<ul>
<li>Traverse upwards from the given <code>(row, col)</code> position:
<ul>
<li>If the cell is a wall or already has a guard, stop marking.</li>
<li>Otherwise, mark the cell as <code>GUARDED</code>.</li>
</ul>
</li>
<li>Traverse downwards, leftwards, and rightwards in a similar manner to mark all reachable cells as <code>GUARDED</code> from the given position.</li>
</ul>
</li>
<li>
<p>Define the function <code>countUnguarded</code> to count unguarded cells:</p>
<ul>
<li>Initialize a grid of size <code>m x n</code>, where each cell is initially set to <code>UNGUARDED</code>.</li>
<li>Mark the positions of guards in the grid as <code>GUARD</code>.</li>
<li>Mark the positions of walls in the grid as <code>WALL</code>.</li>
<li>For each guard, call <code>markguarded</code> to mark all cells that are guarded by that guard.</li>
</ul>
</li>
<li>
<p>After marking all guarded cells, iterate through the grid and count the number of cells that are still <code>UNGUARDED</code>.</p>
</li>
<li>
<p>Return the count of unguarded cells.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/A8EV58Xz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows, <span class="math inline">\(n\)</span> the number of columns, <span class="math inline">\(g\)</span> be the number of guards in the <code>guards</code> list, and <span class="math inline">\(w\)</span> be the number of walls in the <code>walls</code> list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Initializing the grid of size <span class="math inline">\(m \times n\)</span> takes <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Marking guards and walls in the grid requires iterating over the <code>guards</code> and <code>walls</code> arrays, which takes <span class="math inline">\(O(g + w)\)</span>. However, since <span class="math inline">\(g, w \leq m \cdot n\)</span>, this step is bounded by <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>For each guard, the <code>markguarded</code> function traverses in four directions (up, down, left, right) but stops as soon as a wall, another guard, or the grid boundary is encountered. Each cell can be visited at most four times (once from each direction). Hence, marking all guarded cells is proportional to the total number of cells, taking <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Finally, counting the unguarded cells involves iterating over the entire grid, which also takes <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Combining all steps, the overall time complexity is: <span class="math inline">\(O(m \cdot n) + O(m \cdot n) + O(m \cdot n) = O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The grid occupies <span class="math inline">\(O(m \cdot n)\)</span> space. No additional space is used for recursion or other data structures, as the <code>markUnguarded</code> function uses iterative loops for marking cells.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-recursive-way">Approach 2: Recursive Way</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We begin by marking the positions of the guards and walls in the grid, just like in the first approach. Then, for each guard, we trigger recursion in all four directions. Each recursive call will explore one direction as far as possible, marking all the reachable cells as &quot;guarded.&quot; The exploration stops when it encounters a wall or another guard, and we repeat this process with other guards.</p>
<p>There is not much difference between Approach 1 and Approach 2 on a fundamental level, apart from their implementation, so this is meant to showcase a different implementation.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize constants:</p>
<ul>
<li><code>UNGUARDED</code> (0): Represents an unguarded cell.</li>
<li><code>GUARDED</code> (1): Represents a cell that is guarded.</li>
<li><code>GUARD</code> (2): Represents a cell with a guard.</li>
<li><code>WALL</code> (3): Represents a wall cell.</li>
</ul>
</li>
<li>
<p>Define <code>recurse(row, col, grid, direction)</code> function to perform recursive Search:</p>
<ul>
<li>If <code>row</code> or <code>col</code> is out of bounds, or if the cell is a guard or a wall, return.</li>
<li>Mark the current cell as <code>GUARDED</code>.</li>
<li>Recursively call <code>recurse</code> for neighboring cells based on the given direction ('U', 'D', 'L', or 'R').</li>
</ul>
</li>
<li>
<p>Define <code>countUnguarded(m, n, guards, walls)</code> to count the unguarded cells:</p>
<ul>
<li>
<p>Initialize a <code>grid</code> of size <code>m x n</code> with all cells set to <code>UNGUARDED</code>.</p>
</li>
<li>
<p>Mark the guards' positions in the <code>grid</code> by setting the respective cells to <code>GUARD</code>.</p>
</li>
<li>
<p>Mark the walls' positions in the <code>grid</code> by setting the respective cells to <code>WALL</code>.</p>
</li>
<li>
<p>For each guard:</p>
<ul>
<li>Call <code>recurse</code> to mark the cells as <code>GUARDED</code> by traversing in all four directions (Up, Down, Left, Right).</li>
</ul>
</li>
<li>
<p>After marking all guarded cells, count the number of cells that are still <code>UNGUARDED</code> in the grid.</p>
</li>
</ul>
</li>
<li>
<p>Return the count of unguarded cells.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3MhfHJ6b/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows, <span class="math inline">\(n\)</span> the number of columns, <span class="math inline">\(g\)</span> be the number of guards in the <code>guards</code> list, and <span class="math inline">\(w\)</span> be the number of walls in the <code>walls</code> list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Initializing the grid of size <span class="math inline">\(m \times n\)</span> takes <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Marking guards and walls in the grid involves iterating over the <code>guards</code> and <code>walls</code> arrays, which takes <span class="math inline">\(O(g + w)\)</span>. Since <span class="math inline">\(g, w \leq m \cdot n\)</span>, this step is bounded by <span class="math inline">\(O(m \cdot n)\)</span> in the worst case.</p>
<p>When marking guarded cells, each cell in the grid can be visited at most four times (once for each possible direction: up, down, left, right) across all guards. This means that the total traversal across all guards is proportional to the number of cells in the grid, making the marking process <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Counting the unguarded cells at the end involves iterating through all cells in the grid, which takes <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Combining all these steps, the overall time complexity simplifies to <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The primary space usage is the grid, which requires <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The DFS recursion has a space complexity up to <span class="math inline">\(O((m + n))\)</span> due to the recursive stack in the worst case where it could traverse a straight line of unguarded cells. However, this is less significant than <span class="math inline">\(O(m \cdot n)\)</span> in terms of space complexity.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-visibility-axis">Approach 3: Visibility Axis</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To approach this differently, we can spread visibility from each guard across the grid, row by row and column by column. At first, all cells are considered unguarded. As we go through each row and column, we update the grid to show which areas each guard can see. The important thing is that when a guard marks a cell as &quot;guarded,&quot; itâ€™s only marked once. If another guard later sees the same cell, we donâ€™t mark it again since it has already been marked. This helps avoid doing the same work twice.</p>
<p>The process happens in two main steps: first, we check rows, and then we check columns. In each step, we only update visibility in the direction weâ€™re focusing on. Once a guard marks a cell as &quot;guarded,&quot; it wonâ€™t be marked again.</p>
<p>For example, if Guard A can see cell (2, 3), we mark it as &quot;guarded.&quot; Later, if Guard B can also see cell (2, 3), we donâ€™t mark it again because Guard A already did. This method makes the process more efficient by preventing unnecessary marking.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize constants:</p>
<ul>
<li><code>UNGUARDED</code> (0): Represents an unguarded cell.</li>
<li><code>GUARDED</code> (1): Represents a cell that is guarded.</li>
<li><code>GUARD</code> (2): Represents a cell with a guard.</li>
<li><code>WALL</code> (3): Represents a wall cell.</li>
</ul>
</li>
<li>
<p>Initialize a 2D grid <code>grid</code> of size <code>m x n</code> with all cells set to <code>UNGUARDED</code>.</p>
</li>
<li>
<p>Mark the positions of guards in the grid:</p>
<ul>
<li>For each guard in <code>guards</code>, set <code>grid[guard[0]][guard[1]] = GUARD</code>.</li>
</ul>
</li>
<li>
<p>Mark the positions of walls in the grid:</p>
<ul>
<li>For each wall in <code>walls</code>, set <code>grid[wall[0]][wall[1]] = WALL</code>.</li>
</ul>
</li>
<li>
<p>Define a helper function <code>updateCellVisibility</code> to handle updating visibility of cells:</p>
<ul>
<li>If a cell contains a guard (<code>GUARD</code>), return <code>true</code>.</li>
<li>If a cell contains a wall (<code>WALL</code>), return <code>false</code>.</li>
<li>Otherwise, if the line of sight is active, mark the cell as <code>GUARDED</code>.</li>
</ul>
</li>
<li>
<p>Perform horizontal passes over the grid:</p>
<ul>
<li>For each row:
<ul>
<li>Traverse from left to right, updating visibility based on the guard's position.</li>
<li>Traverse from right to left, updating visibility again for the row.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform vertical passes over the grid:</p>
<ul>
<li>For each column:
<ul>
<li>Traverse from top to bottom, updating visibility based on the guard's position.</li>
<li>Traverse from bottom to top, updating visibility again for the column.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterate through the entire grid and count cells that are still marked as <code>UNGUARDED</code>.</p>
</li>
<li>
<p>Return the count of unguarded cells.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<blockquote>
<p>Java does not allow nested function definitions directly inside another function. To fix this, the helper function updateCellVisibility was moved outside of the countUnguarded method.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/hTpsxHyi/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows, <span class="math inline">\(n\)</span> the number of columns, <span class="math inline">\(g\)</span> be the number of guards in the <code>guards</code> list, and <span class="math inline">\(w\)</span> be the number of walls in the <code>walls</code> list.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The first loop marks the positions of the guards, which takes <span class="math inline">\(O(g)\)</span> times. However, since we're iterating through the grid's dimensions, the overall complexity for this part remains <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>The second loop marks the positions of the walls, similarly taking <span class="math inline">\(O(w)\)</span> time, but again the overall time complexity remains <span class="math inline">\(O(m \times n)\)</span> for iterating through the grid.</p>
<p>The third set of loops processes the horizontal and vertical passes over the grid, where each pass involves iterating over all cells in the grid, resulting in <span class="math inline">\(O(m \times n)\)</span> for each direction (horizontal and vertical). Since we have two directions, the total complexity for this part is <span class="math inline">\(O(2 \times m \times n) = O(m \times n)\)</span>.</p>
<p>Finally, the grid is scanned again to count the unguarded cells, which takes <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The primary space used by the algorithm is the <code>grid</code>, which has dimensions <span class="math inline">\(m \times n\)</span>. This grid stores the state for each cell (unguarded, guarded, guard, or wall). Hence, the space complexity is dominated by the space needed for the grid, which is <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>Additionally, the <code>updateCellVisibility</code> function uses constant space, and there are no other significant data structures contributing to space usage. Thus, the space complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-zeros-in-a-sorted-matrix/1" target="_blank" rel="noopener noreferrer">Count zeros in a sorted matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>N X N&nbsp;</strong>binary Square Matrix where each row and column of the matrix is sorted in ascending order. Find the total number of <strong>zeros</strong> present in the matrix.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 3
A = {{0, 0, 0},
&nbsp;    {0, 0, 1},
&nbsp;    {0, 1, 1}}<strong>
Output: </strong>6
<strong>Explanation: 
</strong>The first, second and third row contains 3, 2 and 1
zeroes respectively.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>N = 2
A = {{1, 1},
&nbsp;    {1, 1}}
<strong>Output: </strong>0
<strong>Explanation:
</strong>There are no zeroes in any of the rows.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>countZeros()&nbsp;</strong>which takes a <strong>2D matrix</strong> as input and returns the number occurring only once.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(N ).<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>

<p><span style="font-size:18px"><strong>Constraints</strong><br />
0 &lt; &nbsp; <strong>N</strong>&nbsp; &lt;= 10<sup>3</sup><br />
0 &lt;= <strong>A[i]</strong> &lt;= 1</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/coverage-of-all-zeros-in-a-binary-matrix4024/1" target="_blank" rel="noopener noreferrer">Coverage of all Zeros in a Binary Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; background-color: #ffffff;">Given a binary <strong>matrix </strong>contains <strong>0s</strong> and <strong>1s </strong>only, we need to find the sum of <strong>coverage</strong> of all zeros of the matrix where coverage for a particular 0 is defined as a total number of ones around a zero in immediate left, right, up and bottom directions.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><br /><span style="font-size: 14pt;">matrix = [[0, 1, 0],<br />          [0, 1, 1],</span><br /><span style="font-size: 14pt;">          [0, 0, 0]]<br /></span><span style="font-size: 14pt; font-family: Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; font-variant-alternates: normal; font-variant-position: normal; vertical-align: baseline; white-space-collapse: preserve;"><strong>Output</strong>: 6<br /></span><span style="font-size: 14pt; font-family: Arial, sans-serif; font-variant-numeric: normal; font-variant-east-asian: normal; font-variant-alternates: normal; font-variant-position: normal; vertical-align: baseline; white-space-collapse: preserve;"><strong>Explanation:</strong> There are a total of 6 coverage are there</span></pre>
<p><span id="docs-internal-guid-1235b0a7-7fff-bf71-d97f-b742714a175e"></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>matrix = [[0, 1]]
<strong>Output: </strong>1<br /></span><span style="font-size: 14pt;"><strong>Explanation: </strong>There are only 1 coverage.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n&nbsp;</span><span style="font-size: 15px;">*&nbsp;<span style="font-size: 18px;">m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span></span></p>
<p><span style="font-size: 15px;"><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= matrix.size, matrix[0].size &lt;= 100</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/create-a-spiral-matrix-of-nm-size-from-given-array/1" target="_blank" rel="noopener noreferrer">Create a spiral matrix of N*M size from given array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;"><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">You are given two positive integers </span><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">n </strong><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">and</span><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">&nbsp;<strong>m</strong></span><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">, and an integer array <strong>arr</strong>[] containing total (<strong>n*m)</strong> elements. R</span></span><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; font-size: 14pt;">eturn a 2D matrix of dimensions <strong>n x m</strong> by filling it in a clockwise spiral order using the elements from the given array.</span><br /></span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 4, m = 4, arr[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
<strong>Output:</strong> [[1, 2, 3, 4],<br />        [12, 13, 14, 5],<br />        [11, 16, 15, 6],<br />        [10, 9, 8, 7]]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> n = 3, m = 4, arr[] =[1, 8, 6, 3, 8, 6, 1, 6, 3, 2, 5, 3]
<strong>Output:</strong> [[1, 8, 6, 3],<br />        [2, 5, 3, 8],<br />        [3, 6, 1, 6]]<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> n = 2, m = 2, arr[] =[1, 8, 6, 3]
<strong>Output:</strong> [[1, 8],<br />        [3, 6]]</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 10<sup>3</sup><br />arr.size() = n x m<br />1 &le; arr[i] &le; 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cut-off-trees-for-golf-event/description" target="_blank" rel="noopener noreferrer">Cut Off Trees for Golf Event</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an <code>m x n</code> matrix. In this matrix:</p>

<ul>
	<li><code>0</code> means the cell cannot be walked through.</li>
	<li><code>1</code> represents an empty cell that can be walked through.</li>
	<li>A number greater than <code>1</code> represents a tree in a cell that can be walked through, and this number is the tree&#39;s height.</li>
</ul>

<p>In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.</p>

<p>You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes <code>1</code> (an empty cell).</p>

<p>Starting from the point <code>(0, 0)</code>, return <em>the minimum steps you need to walk to cut off all the trees</em>. If you cannot cut off all the trees, return <code>-1</code>.</p>

<p><strong>Note:</strong> The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> forest = [[1,2,3],[0,0,4],[7,6,5]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> forest = [[1,2,3],[0,0,0],[7,6,5]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The trees in the bottom row cannot be accessed as the middle row is blocked.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> forest = [[2,3,4],[0,0,5],[8,7,6]]
<strong>Output:</strong> 6
<b>Explanation:</b> You can follow the same path as Example 1 to cut off all the trees.
Note that you can cut off the first tree at (0, 0) before making any steps.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == forest.length</code></li>
	<li><code>n == forest[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>0 &lt;= forest[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>Heights of all trees are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-framework">Approach Framework</h3>
<p><strong>Explanation</strong></p>
<p>Starting from <code>(0, 0)</code>, for each tree in height order, we will calculate the distance from where we are to the next tree (and move there), adding that distance to the answer.</p>
<p>We frame the problem as providing some distance function <code>dist(forest, sr, sc, tr, tc)</code> that calculates the path distance from source <code>(sr, sc)</code> to target <code>(tr, tc)</code> through obstacles <code>dist[i][j] == 0</code>. (This distance function will return <code>-1</code> if the path is impossible.)</p>
<p>What follows is code and complexity analysis that is common to all three approaches. After, the algorithms presented in our approaches will focus on only providing our <code>dist</code> function.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">cutOffTree</span>(<span style="color:#999">self</span>, forest):
</span></span><span style="display:flex;"><span>        trees <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">sorted</span>((v, r, c) <span style="color:#000;font-weight:bold">for</span> r, row <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(forest)
</span></span><span style="display:flex;"><span>                       <span style="color:#000;font-weight:bold">for</span> c, v <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">enumerate</span>(row) <span style="color:#000;font-weight:bold">if</span> v <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>        sr <span style="color:#000;font-weight:bold">=</span> sc <span style="color:#000;font-weight:bold">=</span> ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> _, tr, tc <span style="color:#000;font-weight:bold">in</span> trees:
</span></span><span style="display:flex;"><span>            d <span style="color:#000;font-weight:bold">=</span> dist(forest, sr, sc, tr, tc)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> d <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">0</span>: <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> d
</span></span><span style="display:flex;"><span>            sr, sc <span style="color:#000;font-weight:bold">=</span> tr, tc
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> dr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">{-</span>1<span style="color:#000;font-weight:bold">,</span> 1<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> dc <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">{</span>0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">,</span> 1<span style="color:#000;font-weight:bold">};</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">cutOffTree</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> trees <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ArrayList<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> r <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> r <span style="color:#000;font-weight:bold">&lt;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>r<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> c <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> c <span style="color:#000;font-weight:bold">&lt;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#000;font-weight:bold">++</span>c<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> v <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>v <span style="color:#000;font-weight:bold">&gt;</span> 1<span style="color:#000;font-weight:bold">)</span> trees<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>v<span style="color:#000;font-weight:bold">,</span> r<span style="color:#000;font-weight:bold">,</span> c<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Collections<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">sort</span><span style="color:#000;font-weight:bold">(</span>trees<span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">,</span> b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-&gt;</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compare</span><span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> b<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> sr <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> sc <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> tree<span style="color:#000;font-weight:bold">:</span> trees<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> d <span style="color:#000;font-weight:bold">=</span> dist<span style="color:#000;font-weight:bold">(</span>forest<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">,</span> tree<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> tree<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">]);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>d <span style="color:#000;font-weight:bold">&lt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> d<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            sr <span style="color:#000;font-weight:bold">=</span> tree<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">];</span> sc <span style="color:#000;font-weight:bold">=</span> tree<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<p>All three algorithms have similar worst-case complexities, but in practice, each successive algorithm presented performs faster on random data.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((RC)^2)\)</span> where there are <span class="math inline">\(R\)</span> rows and <span class="math inline">\(C\)</span> columns in the given <code>forest</code>. We walk to <span class="math inline">\(R*C\)</span> trees, and each walk could spend <span class="math inline">\(O(R*C)\)</span> time searching for the tree.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(R*C)\)</span>, the maximum size of the data structures used.</p>
</li>
</ul>
<hr />
<h3 id="approach-1-bfs-accepted">Approach #1: BFS [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We perform a breadth-first-search, processing nodes (grid positions) in a queue. <code>seen</code> keeps track of nodes that have already been added to the queue at some point - those nodes will be already processed or are in the queue awaiting processing.</p>
<p>For each node next to be processed, we look at its neighbors. If they are in the forest (grid), they haven't been enqueued, and they aren't an obstacle, we will enqueue that neighbor.</p>
<p>We also keep a side count of the distance traveled for each node. If the node we are processing is our destination 'target' <code>(tr, tc)</code>, we'll return the answer.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">bfs</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    queue <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>deque([(sr, sc, <span style="color:#099">0</span>)])
</span></span><span style="display:flex;"><span>    seen <span style="color:#000;font-weight:bold">=</span> {(sr, sc)}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> queue:
</span></span><span style="display:flex;"><span>        r, c, d <span style="color:#000;font-weight:bold">=</span> queue<span style="color:#000;font-weight:bold">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> d
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> nr, nc <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c), (r, c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>), (r, c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span>
</span></span><span style="display:flex;"><span>                    (nr, nc) <span style="color:#000;font-weight:bold">not</span> <span style="color:#000;font-weight:bold">in</span> seen <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]):
</span></span><span style="display:flex;"><span>                seen<span style="color:#000;font-weight:bold">.</span>add((nr, nc))
</span></span><span style="display:flex;"><span>                queue<span style="color:#000;font-weight:bold">.</span>append((nr, nc, d<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">bfs</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Queue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> queue <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> LinkedList<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">boolean</span><span style="color:#000;font-weight:bold">[][]</span> seen <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">boolean</span><span style="color:#000;font-weight:bold">[</span>R<span style="color:#000;font-weight:bold">][</span>C<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    seen<span style="color:#000;font-weight:bold">[</span>sr<span style="color:#000;font-weight:bold">][</span>sc<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">poll</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> r <span style="color:#000;font-weight:bold">&amp;&amp;</span> r <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> c <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">!</span>seen<span style="color:#000;font-weight:bold">[</span>r<span style="color:#000;font-weight:bold">][</span>c<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>c<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                seen<span style="color:#000;font-weight:bold">[</span>r<span style="color:#000;font-weight:bold">][</span>c<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                queue<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>r<span style="color:#000;font-weight:bold">,</span> c<span style="color:#000;font-weight:bold">,</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">]+</span>1<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><hr />
<h3 id="approach-2-a-search-accepted">Approach #2: A* Search [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>The A* star algorithm is another path-finding algorithm.  For every node at position <code>(r, c)</code>, we have some estimated cost <code>node.f = node.g + node.h</code>, where <code>node.g</code> is the actual distance from <code>(sr, sc)</code> to <code>(r, c)</code>, and <code>node.h</code> is our <em>heuristic</em> (guess) of the distance from <code>(r, c)</code> to <code>(tr, tc)</code>.  In this case, our guess will be the taxicab distance, <code>node.h = abs(r-tr) + abs(c-tc)</code>.</p>
<p>We keep a priority queue to decide what node to search in (<em>expand</em>) next. We can prove that if we find the target node, we must have traveled the lowest possible distance <code>node.g</code>. By considering the last time when two backward paths are the same, without loss of generality we could suppose the penultimate square of the two paths are different, and then in this case <code>node.f = node.g + 1</code>, showing the path with less actual distance travelled is expanded first as desired.</p>
<p>It might be useful for solvers familiar with <em>Dijkstra's Algorithm</em> to know that Dijkstra's algorithm is a special case of <em>A* Search</em> with <code>node.h = 0</code> always.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">astar</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    heap <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#099">0</span>, <span style="color:#099">0</span>, sr, sc)]
</span></span><span style="display:flex;"><span>    cost <span style="color:#000;font-weight:bold">=</span> {(sr, sc): <span style="color:#099">0</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> heap:
</span></span><span style="display:flex;"><span>        f, g, r, c <span style="color:#000;font-weight:bold">=</span> heapq<span style="color:#000;font-weight:bold">.</span>heappop(heap)
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc: <span style="color:#000;font-weight:bold">return</span> g
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> nr, nc <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>,c), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>,c), (r,c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>), (r,c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]:
</span></span><span style="display:flex;"><span>                ncost <span style="color:#000;font-weight:bold">=</span> g <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(nr <span style="color:#000;font-weight:bold">-</span> tr) <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(nc <span style="color:#000;font-weight:bold">-</span> tc)
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> ncost <span style="color:#000;font-weight:bold">&lt;</span> cost<span style="color:#000;font-weight:bold">.</span>get((nr, nc), <span style="color:#099">9999</span>):
</span></span><span style="display:flex;"><span>                    cost[nr, nc] <span style="color:#000;font-weight:bold">=</span> ncost
</span></span><span style="display:flex;"><span>                    heapq<span style="color:#000;font-weight:bold">.</span>heappush(heap, (ncost, g<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, nr, nc))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">cutOffTree</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    PriorityQueue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> heap <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> PriorityQueue<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">,</span> b<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">-&gt;</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">compare</span><span style="color:#000;font-weight:bold">(</span>a<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> b<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]));</span>
</span></span><span style="display:flex;"><span>    heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offer</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>0<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    HashMap<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">,</span> Integer<span style="color:#000;font-weight:bold">&gt;</span> cost <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashMap<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">put</span><span style="color:#000;font-weight:bold">(</span>sr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> sc<span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">poll</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> g <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">],</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>3<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">return</span> g<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#458;font-weight:bold">int</span> nr <span style="color:#000;font-weight:bold">=</span> r <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">],</span> nc <span style="color:#000;font-weight:bold">=</span> c <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&amp;&amp;</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&amp;&amp;</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> ncost <span style="color:#000;font-weight:bold">=</span> g <span style="color:#000;font-weight:bold">+</span> 1 <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>ncost <span style="color:#000;font-weight:bold">&lt;</span> cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getOrDefault</span><span style="color:#000;font-weight:bold">(</span>nr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> nc<span style="color:#000;font-weight:bold">,</span> 9999<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    cost<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">put</span><span style="color:#000;font-weight:bold">(</span>nr <span style="color:#000;font-weight:bold">*</span> C <span style="color:#000;font-weight:bold">+</span> nc<span style="color:#000;font-weight:bold">,</span> ncost<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                    heap<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offer</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>ncost<span style="color:#000;font-weight:bold">,</span> g<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><hr />
<h3 id="approach-3-hadlocks-algorithm-accepted">Approach #3: Hadlock's Algorithm [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Without any obstacles, the distance from <code>source = (sr, sc)</code> to <code>target = (tr, tc)</code> is simply <code>taxi(source, target) = abs(sr-tr) + abs(sc-tc)</code>. This represents a sort of minimum distance that must be traveled. Whenever we walk &quot;away&quot; from the target, we increase this minimum by 2, as we stepped 1 move, plus the taxicab distance from our new location has increased by one.</p>
<p>Let's call such a move that walks away from the target a <em>detour</em>. It can be proven that the distance from source to target is simply <code>taxi(source, target) + 2 * detours</code>, where <code>detours</code> is the smallest number of detours in any path from <code>source</code> to <code>target</code>.</p>
<p><strong>Algorithm</strong></p>
<p>With respect to a <code>source</code> and <code>target</code>, call the <em>detour number</em> of a square to be the lowest number of detours possible in any path from <code>source</code> to that square.  (Here, detours are defined with respect to <code>target</code> - the number of away steps from that target.)</p>
<p>We will perform a priority-first search in order of detour number. If the target is found, it was found with the lowest detour number and therefore the lowest corresponding distance.  This motivates using <code>processed</code>, keeping track of when nodes are expanded, not visited - nodes could potentially be visited twice.</p>
<p>As each neighboring node can only have the same detour number or a detour number one higher, we will only consider at most 2 priority classes at a time. Thus, we can use a deque (double-ended queue) to perform this implementation.  We will place nodes with the same detour number to be expanded first, and nodes with a detour number one higher to be expanded after all nodes with the current number are done.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">hadlocks</span>(forest, sr, sc, tr, tc):
</span></span><span style="display:flex;"><span>    R, C <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(forest), <span style="color:#0086b3">len</span>(forest[<span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>    processed <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">set</span>()
</span></span><span style="display:flex;"><span>    deque <span style="color:#000;font-weight:bold">=</span> collections<span style="color:#000;font-weight:bold">.</span>deque([(<span style="color:#099">0</span>, sr, sc)])
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> deque:
</span></span><span style="display:flex;"><span>        detours, r, c <span style="color:#000;font-weight:bold">=</span> deque<span style="color:#000;font-weight:bold">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (r, c) <span style="color:#000;font-weight:bold">not</span> <span style="color:#000;font-weight:bold">in</span> processed:
</span></span><span style="display:flex;"><span>            processed<span style="color:#000;font-weight:bold">.</span>add((r, c))
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">and</span> c <span style="color:#000;font-weight:bold">==</span> tc:
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">abs</span>(sr<span style="color:#000;font-weight:bold">-</span>tr) <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">abs</span>(sc<span style="color:#000;font-weight:bold">-</span>tc) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>detours
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> nr, nc, closer <span style="color:#000;font-weight:bold">in</span> ((r<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c, r <span style="color:#000;font-weight:bold">&gt;</span> tr), (r<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c, r <span style="color:#000;font-weight:bold">&lt;</span> tr),
</span></span><span style="display:flex;"><span>                                   (r, c<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, c <span style="color:#000;font-weight:bold">&gt;</span> tc), (r, c<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, c <span style="color:#000;font-weight:bold">&lt;</span> tc)):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">and</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">and</span> forest[nr][nc]:
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> closer:
</span></span><span style="display:flex;"><span>                        deque<span style="color:#000;font-weight:bold">.</span>appendleft((detours, nr, nc))
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                        deque<span style="color:#000;font-weight:bold">.</span>append((detours<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>, nr, nc))
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">hadlocks</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>List<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;&gt;</span> forest<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> sc<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tr<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> R <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">(),</span> C <span style="color:#000;font-weight:bold">=</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">size</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Set<span style="color:#000;font-weight:bold">&lt;</span>Integer<span style="color:#000;font-weight:bold">&gt;</span> processed <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> HashSet<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    Deque<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]&gt;</span> deque <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> ArrayDeque<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>    deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerFirst</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>0<span style="color:#000;font-weight:bold">,</span> sr<span style="color:#000;font-weight:bold">,</span> sc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(!</span>deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">isEmpty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> cur <span style="color:#000;font-weight:bold">=</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">pollFirst</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> detours <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">],</span> r <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>1<span style="color:#000;font-weight:bold">],</span> c <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(!</span>processed<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">contains</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">*</span>C <span style="color:#000;font-weight:bold">+</span> c<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            processed<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">add</span><span style="color:#000;font-weight:bold">(</span>r<span style="color:#000;font-weight:bold">*</span>C <span style="color:#000;font-weight:bold">+</span> c<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>r <span style="color:#000;font-weight:bold">==</span> tr <span style="color:#000;font-weight:bold">&amp;&amp;</span> c <span style="color:#000;font-weight:bold">==</span> tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>sr<span style="color:#000;font-weight:bold">-</span>tr<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">abs</span><span style="color:#000;font-weight:bold">(</span>sc<span style="color:#000;font-weight:bold">-</span>tc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">+</span> 2 <span style="color:#000;font-weight:bold">*</span> detours<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> di <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> di <span style="color:#000;font-weight:bold">&lt;</span> 4<span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">++</span>di<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> nr <span style="color:#000;font-weight:bold">=</span> r <span style="color:#000;font-weight:bold">+</span> dr<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">int</span> nc <span style="color:#000;font-weight:bold">=</span> c <span style="color:#000;font-weight:bold">+</span> dc<span style="color:#000;font-weight:bold">[</span>di<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>                <span style="color:#458;font-weight:bold">boolean</span> closer<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>di <span style="color:#000;font-weight:bold">&lt;=</span> 1<span style="color:#000;font-weight:bold">)</span> closer <span style="color:#000;font-weight:bold">=</span> di <span style="color:#000;font-weight:bold">==</span> 0 <span style="color:#000;font-weight:bold">?</span> r <span style="color:#000;font-weight:bold">&gt;</span> tr <span style="color:#000;font-weight:bold">:</span> r <span style="color:#000;font-weight:bold">&lt;</span> tr<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">else</span> closer <span style="color:#000;font-weight:bold">=</span> di <span style="color:#000;font-weight:bold">==</span> 2 <span style="color:#000;font-weight:bold">?</span> c <span style="color:#000;font-weight:bold">&gt;</span> tc <span style="color:#000;font-weight:bold">:</span> c <span style="color:#000;font-weight:bold">&lt;</span> tc<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>0 <span style="color:#000;font-weight:bold">&lt;=</span> nr <span style="color:#000;font-weight:bold">&amp;&amp;</span> nr <span style="color:#000;font-weight:bold">&lt;</span> R <span style="color:#000;font-weight:bold">&amp;&amp;</span> 0 <span style="color:#000;font-weight:bold">&lt;=</span> nc <span style="color:#000;font-weight:bold">&amp;&amp;</span> nc <span style="color:#000;font-weight:bold">&lt;</span> C <span style="color:#000;font-weight:bold">&amp;&amp;</span> forest<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nr<span style="color:#000;font-weight:bold">).</span><span style="color:#008080">get</span><span style="color:#000;font-weight:bold">(</span>nc<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">&gt;</span> 0<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>closer<span style="color:#000;font-weight:bold">)</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerFirst</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>detours<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#000;font-weight:bold">else</span> deque<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">offerLast</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]{</span>detours<span style="color:#000;font-weight:bold">+</span>1<span style="color:#000;font-weight:bold">,</span> nr<span style="color:#000;font-weight:bold">,</span> nc<span style="color:#000;font-weight:bold">});</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div>
				</div>
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cyclically-rotating-a-grid/description" target="_blank" rel="noopener noreferrer">Cyclically Rotating a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>â€‹â€‹â€‹, where <code>m</code> and <code>n</code> are both <strong>even</strong> integers, and an integer <code>k</code>.</p>

<p>The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png" style="width: 231px; height: 258px;" /></p>

<p>A cyclic rotation of the matrix is done by cyclically rotating <strong>each layer</strong> in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the <strong>counter-clockwise</strong> direction. An example rotation is shown below:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg" style="width: 500px; height: 268px;" />
<p>Return <em>the matrix after applying </em><code>k</code> <em>cyclic rotations to it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/rod2.png" style="width: 421px; height: 191px;" />
<pre>
<strong>Input:</strong> grid = [[40,10],[30,20]], k = 1
<strong>Output:</strong> [[10,20],[40,30]]
<strong>Explanation:</strong> The figures above represent the grid at every state.
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/ringofgrid5.png" style="width: 231px; height: 262px;" /></strong> <strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/ringofgrid6.png" style="width: 231px; height: 262px;" /></strong> <strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/10/ringofgrid7.png" style="width: 231px; height: 262px;" /></strong>

<pre>
<strong>Input:</strong> grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
<strong>Output:</strong> [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
<strong>Explanation:</strong> The figures above represent the grid at every state.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 50</code></li>
	<li>Both <code>m</code> and <code>n</code> are <strong>even</strong> integers.</li>
	<li><code>1 &lt;= grid[i][j] &lt;=<sup> </sup>5000</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-greatest-value-in-each-row/description" target="_blank" rel="noopener noreferrer">Delete Greatest Value in Each Row</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of positive integers.</p>

<p>Perform the following operation until <code>grid</code> becomes empty:</p>

<ul>
	<li>Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.</li>
	<li>Add the maximum of deleted elements to the answer.</li>
</ul>

<p><strong>Note</strong> that the number of columns decreases by one after each operation.</p>

<p>Return <em>the answer after performing the operations described above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg" style="width: 600px; height: 135px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,4],[3,3,1]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg" style="width: 83px; height: 83px;" />
<pre>
<strong>Input:</strong> grid = [[10]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-neighbor-sum-service/description" target="_blank" rel="noopener noreferrer">Design Neighbor Sum Service</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>n x n</code> 2D array <code>grid</code> containing <strong>distinct</strong> elements in the range <code>[0, n<sup>2</sup> - 1]</code>.</p>

<p>Implement the <code>NeighborSum</code> class:</p>

<ul>
	<li><code>NeighborSum(int [][]grid)</code> initializes the object.</li>
	<li><code>int adjacentSum(int value)</code> returns the <strong>sum</strong> of elements which are adjacent neighbors of <code>value</code>, that is either to the top, left, right, or bottom of <code>value</code> in <code>grid</code>.</li>
	<li><code>int diagonalSum(int value)</code> returns the <strong>sum</strong> of elements which are diagonal neighbors of <code>value</code>, that is either to the top-left, top-right, bottom-left, or bottom-right of <code>value</code> in <code>grid</code>.</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/24/design.png" style="width: 400px; height: 248px;" /></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong></p>

<p>[&quot;NeighborSum&quot;, &quot;adjacentSum&quot;, &quot;adjacentSum&quot;, &quot;diagonalSum&quot;, &quot;diagonalSum&quot;]</p>

<p>[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]</p>

<p><strong>Output:</strong> [null, 6, 16, 16, 4]</p>

<p><strong>Explanation:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2024/06/24/designexample0.png" style="width: 250px; height: 249px;" /></strong></p>

<ul>
	<li>The adjacent neighbors of 1 are 0, 2, and 4.</li>
	<li>The adjacent neighbors of 4 are 1, 3, 5, and 7.</li>
	<li>The diagonal neighbors of 4 are 0, 2, 6, and 8.</li>
	<li>The diagonal neighbor of 8 is 4.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong></p>

<p>[&quot;NeighborSum&quot;, &quot;adjacentSum&quot;, &quot;diagonalSum&quot;]</p>

<p>[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]</p>

<p><strong>Output:</strong> [null, 23, 45]</p>

<p><strong>Explanation:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2024/06/24/designexample2.png" style="width: 300px; height: 300px;" /></strong></p>

<ul>
	<li>The adjacent neighbors of 15 are 0, 10, 7, and 6.</li>
	<li>The diagonal neighbors of 9 are 4, 12, 14, and 15.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n == grid.length == grid[0].length &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= n<sup>2</sup> - 1</code></li>
	<li>All <code>grid[i][j]</code> are distinct.</li>
	<li><code>value</code> in <code>adjacentSum</code> and <code>diagonalSum</code> will be in the range <code>[0, n<sup>2</sup> - 1]</code>.</li>
	<li>At most <code>2 * n<sup>2</sup></code> calls will be made to <code>adjacentSum</code> and <code>diagonalSum</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/design-spreadsheet/description" target="_blank" rel="noopener noreferrer">Design Spreadsheet</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A spreadsheet is a grid with 26 columns (labeled from <code>&#39;A&#39;</code> to <code>&#39;Z&#39;</code>) and a given number of <code>rows</code>. Each cell in the spreadsheet can hold an integer value between 0 and 10<sup>5</sup>.</p>

<p>Implement the <code>Spreadsheet</code> class:</p>

<ul>
	<li><code>Spreadsheet(int rows)</code> Initializes a spreadsheet with 26 columns (labeled <code>&#39;A&#39;</code> to <code>&#39;Z&#39;</code>) and the specified number of rows. All cells are initially set to 0.</li>
	<li><code>void setCell(String cell, int value)</code> Sets the value of the specified <code>cell</code>. The cell reference is provided in the format <code>&quot;AX&quot;</code> (e.g., <code>&quot;A1&quot;</code>, <code>&quot;B10&quot;</code>), where the letter represents the column (from <code>&#39;A&#39;</code> to <code>&#39;Z&#39;</code>) and the number represents a <strong>1-indexed</strong> row.</li>
	<li><code>void resetCell(String cell)</code> Resets the specified cell to 0.</li>
	<li><code>int getValue(String formula)</code> Evaluates a formula of the form <code>&quot;=X+Y&quot;</code>, where <code>X</code> and <code>Y</code> are <strong>either</strong> cell references or non-negative integers, and returns the computed sum.</li>
</ul>

<p><strong>Note:</strong> If <code>getValue</code> references a cell that has not been explicitly set using <code>setCell</code>, its value is considered 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;Spreadsheet&quot;, &quot;getValue&quot;, &quot;setCell&quot;, &quot;getValue&quot;, &quot;setCell&quot;, &quot;getValue&quot;, &quot;resetCell&quot;, &quot;getValue&quot;]<br />
[[3], [&quot;=5+7&quot;], [&quot;A1&quot;, 10], [&quot;=A1+6&quot;], [&quot;B2&quot;, 15], [&quot;=A1+B2&quot;], [&quot;A1&quot;], [&quot;=A1+B2&quot;]]</span></p>

<p><strong>Output:</strong><br />
<span class="example-io">[null, 12, null, 16, null, 25, null, 15] </span></p>

<p><strong>Explanation</strong></p>
Spreadsheet spreadsheet = new Spreadsheet(3); // Initializes a spreadsheet with 3 rows and 26 columns<br data-end="321" data-start="318" />
spreadsheet.getValue(&quot;=5+7&quot;); // returns 12 (5+7)<br data-end="373" data-start="370" />
spreadsheet.setCell(&quot;A1&quot;, 10); // sets A1 to 10<br data-end="423" data-start="420" />
spreadsheet.getValue(&quot;=A1+6&quot;); // returns 16 (10+6)<br data-end="477" data-start="474" />
spreadsheet.setCell(&quot;B2&quot;, 15); // sets B2 to 15<br data-end="527" data-start="524" />
spreadsheet.getValue(&quot;=A1+B2&quot;); // returns 25 (10+15)<br data-end="583" data-start="580" />
spreadsheet.resetCell(&quot;A1&quot;); // resets A1 to 0<br data-end="634" data-start="631" />
spreadsheet.getValue(&quot;=A1+B2&quot;); // returns 15 (0+15)</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows &lt;= 10<sup>3</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>
	<li>The formula is always in the format <code>&quot;=X+Y&quot;</code>, where <code>X</code> and <code>Y</code> are either valid cell references or <strong>non-negative</strong> integers with values less than or equal to <code>10<sup>5</sup></code>.</li>
	<li>Each cell reference consists of a capital letter from <code>&#39;A&#39;</code> to <code>&#39;Z&#39;</code> followed by a row number between <code>1</code> and <code>rows</code>.</li>
	<li>At most <code>10<sup>4</sup></code> calls will be made in <strong>total</strong> to <code>setCell</code>, <code>resetCell</code>, and <code>getValue</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/detect-cycles-in-2d-grid/description" target="_blank" rel="noopener noreferrer">Detect Cycles in 2D Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D array of characters <code>grid</code> of size <code>m x n</code>, you need to find if there exists any cycle consisting of the <strong>same value</strong> in <code>grid</code>.</p>

<p>A cycle is a path of <strong>length 4 or more</strong> in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the <strong>same value</strong> of the current cell.</p>

<p>Also, you cannot move to the cell that you visited in your last move. For example, the cycle <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code> is invalid because from <code>(1, 2)</code> we visited <code>(1, 1)</code> which was the last visited cell.</p>

<p>Return <code>true</code> if any cycle of the same value exists in <code>grid</code>, otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/1.png" style="width: 231px; height: 152px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There are two valid cycles shown in different colors in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/11.png" style="width: 225px; height: 163px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/22.png" style="width: 236px; height: 154px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]
<strong>Output:</strong> true
<strong>Explanation: </strong>There is only one valid cycle highlighted in the image below:
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/2.png" style="width: 229px; height: 157px;" />
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/07/15/3.png" style="width: 183px; height: 120px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/determinant-of-a-matrix-1587115620/1" target="_blank" rel="noopener noreferrer">Determinant of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square matrix of size <strong>n*n</strong>. The task is to find the <a href="https://en.wikipedia.org/wiki/Determinant"><strong>determinant</strong></a> of this matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
n = 4
matrix[][] = {{1, 0, 2, -1},
&nbsp;             {3, 0, 0, 5},
&nbsp;             {2, 1, 4, -3},
&nbsp;             {1, 0, 5, 0}}
<strong>Output</strong>: 30
<strong>Explanation</strong>:
Determinant of the given matrix is 30.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
n = 3
matrix[][] = {{1, 2, 3},
&nbsp;             {4, 5, 6},
&nbsp;             {7, 10, 9}}
<strong>Output</strong>: 12
<strong>Explanation</strong>:
Determinant of the given matrix is 12.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Complete the function <strong>determinantOfMatrix()&nbsp;</strong>that takes<strong> </strong>matrix<strong> </strong>and its size <strong>n</strong> as input parameters<strong> </strong>and returns the determinant of the matrix.<br /></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N<sup>4</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(N<sup>2</sup>)</span><br /><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<br />-10&nbsp;&lt;= mat[i][j] &lt;= 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/description" target="_blank" rel="noopener noreferrer">Determine Whether Matrix Can Be Obtained By Rotation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two <code>n x n</code> binary matrices <code>mat</code> and <code>target</code>, return <code>true</code><em> if it is possible to make </em><code>mat</code><em> equal to </em><code>target</code><em> by <strong>rotating</strong> </em><code>mat</code><em> in <strong>90-degree increments</strong>, or </em><code>false</code><em> otherwise.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/20/grid3.png" style="width: 301px; height: 121px;" />
<pre>
<strong>Input:</strong> mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
<strong>Output:</strong> true
<strong>Explanation: </strong>We can rotate mat 90 degrees clockwise to make mat equal target.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/20/grid4.png" style="width: 301px; height: 121px;" />
<pre>
<strong>Input:</strong> mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to make mat equal to target by rotating mat.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/26/grid4.png" style="width: 661px; height: 184px;" />
<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
<strong>Output:</strong> true
<strong>Explanation: </strong>We can rotate mat 90 degrees clockwise two times to make mat equal target.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == mat.length == target.length</code></li>
	<li><code>n == mat[i].length == target[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>mat[i][j]</code> and <code>target[i][j]</code> are either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/diagonal-sum0158/1" target="_blank" rel="noopener noreferrer">Diagonal sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a square matrix of size <strong>n</strong><strong>&times;n</strong>. Your task is to calculate the sum of its diagonals.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>matrix = {{1, 1, 1}, 
{1, 1, 1}, {1, 1, 1}}
<strong>Output: </strong>6</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>matrix = {{1, 2}, {3, 4}}
<strong>Output: </strong>10</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anyhting.&nbsp;Your task is to complete the function&nbsp;<strong>DiagonalSum()</strong>&nbsp;which takes the matrix as input parameter and returns the sum of its diagonals.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n)<br />
<strong>Expected Space Complexity:&nbsp;</strong>O(1)<br />
<br />
<strong>Constraints:</strong><br />
1 &lt;= n &lt;= 100<br />
1 &lt;= matrix elements &lt;= 10000</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/diagonal-traverse/description" target="_blank" rel="noopener noreferrer">Diagonal Traverse</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" style="width: 334px; height: 334px;" />
<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [1,2,4,7,5,3,6,8,9]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,2],[3,4]]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<h3 id="approach-1-diagonal-iteration-and-reversal">Approach 1: Diagonal Iteration and Reversal</h3>
<p><strong>Intuition</strong></p>
<p>A common strategy for solving a lot of programming problem is to first solve a stripped down, simpler version of them and then think what needs to be changed to achieve the original goal. Our first approach to this problem is also based on this very idea. So, instead of thinking about the zig-zag pattern of printing for the diagonals, let's say the problem statement simply asked us to print out the contents of the matrix, one diagonal after the other starting from the first element. Let's see what this problem would look like.</p>
<center>
<img src="../Figures/498/img1.png" width="600"/>
</center>
<p>The first row and the last column in this problem would serve as the starting point for the corresponding diagonal. Given an element inside a diagonal, say <span class="math inline">\([i, j]\)</span>, we can either go up the diagonal by going one row up and one column ahead i.e. <span class="math inline">\([i - 1, j + 1]\)</span> or, we can go down the diagonal by going one row down and one column to the left i.e. <span class="math inline">\([i + 1, j - 1]\)</span>. <em>Note</em> that this applies to diagonals that go from <code>right to left</code> only. The math would change for the ones that go from left to right.</p>
<p>This is a simple problem to solve, right? The only difference between this one and the original problem is that some of the diagonals are not printed in the right order. That's all we need to fix to get the right solution!</p>
<blockquote>
<p>We simply need to reverse the odd numbered diagonals before we add the elements to the final result array. So, for e.g. the third diagonal starting from the left would be [3, 7, 11] and before we add these elements to the final result array, we simply reverse them i.e. [11, 7, 3].</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize a <code>result</code> array that we will eventually return.</p>
</li>
<li>
<p>We would have an outer loop that will go over each of the diagonals one by one. As mentioned before, the elements in the first row and the last column would actually be the heads of their corresponding diagonals.</p>
</li>
<li>
<p>We then have an inner while loop that iterates over all the elements in the diagonal. We can calculate the number of elements in the corresponding diagonal by doing some math but we can simply iterate until one of the indices goes out of bounds.</p>
</li>
<li>
<p>For each diagonal we will need a new list or dynamic array like data structure since we don't know what size to allocate. Again, we can do some math and calculate the size of that particular diagonal and allocate memory; but it's not necessary for this explanation.</p>
</li>
<li>
<p>For odd numbered diagonals, we simply need to add the elements in our intermediary array, in reverse order to the final result array.</p>
 <center>
 <img src="../Figures/498/img2.png" width="500"/>
 </center>
</li>
</ol>
<p><a href="https://leetcode.com/playground/8NzZyMbU/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: <span class="math inline">\(O(N \cdot M)\)</span> considering the array has <span class="math inline">\(N\)</span> rows and <span class="math inline">\(M\)</span> columns. An important thing to remember is that for all the odd numbered diagonals, we will be processing the elements twice since we have to reverse the elements before adding to the result array. Additionally, to save space, we have to <code>clear</code> the intermediate array before we process a new diagonal. That operation also takes <span class="math inline">\(O(K)\)</span> where <span class="math inline">\(K\)</span> is the size of that array. So, we will be processing all the elements of the array at least twice. But, as far as the asymptotic complexity is concerned, it remains the same.</li>
<li>Space Complexity: <span class="math inline">\(O(min(N, M))\)</span> since the extra space is occupied by the intermediate arrays we use for storing diagonal elements and the maximum it can occupy is the equal to the minimum of <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span>. Remember, the diagonal can only extend till one of its indices goes out of scope.<br />
<br><br />
<br></li>
</ul>
<hr />
<h3 id="approach-2-simulation">Approach 2: Simulation</h3>
<p><strong>Intuition</strong></p>
<p>This approach simply and plainly does what the problem statement asks us to do. It's pure simulation. However, in order to implement this simulation, we need to understand the walking patterns inside the array. Basically, in the previous approach, figuring out the <code>head</code> of the diagonal was pretty easy. In this case, it won't be that easy. We need to figure out two things for each diagonal:</p>
<ol>
<li>The direction in which we want to process it's elements and</li>
<li>The head or the starting point for the diagonal <code>depending upon its direction</code>.</li>
</ol>
<p>Let's see these two things annotated on a sample matrix.</p>
<center>
<img src="../Figures/498/img3.png" width="600"/>
</center>
<p>Now that we know what two things we need to figure out, let's get to the part where we actually do it! The direction is pretty straightforward. We can simply use a boolean variable and keep alternating it to figure out the direction for a diagonal. That part is sorted. The slightly tricky part is figuring out the head of the next diagonal.</p>
<p>The good part is, we already know the <code>end</code> of the previous diagonal. We can use that information to figure out the head of the next diagonal.</p>
<p><strong>Next head when going UP</strong><br><br />
Let's look at the two scenarios that we may come across when we are at the tail end of a downwards diagonal and we want to find the head of the next diagonal.</p>
<center>
<img src="../Figures/498/img4.png" width="600"/>
</center>
<p>So, the general rule that we will be following when we want to find the head for an upwards going diagonal is that:</p>
<blockquote>
<p>The head would be the node directly below the tail of the previous diagonal. Unless the tail lies in the last row of the matrix in which case the head would be the node right next to the tail.</p>
</blockquote>
<p><strong>Next head when going DOWN</strong> <br><br />
Let's look at the two scenarios that we may come across when we are at the tail end of an upwards diagonal and we want to find the head of the next diagonal.</p>
<center>
<img src="../Figures/498/img5.png" width="600"/>
</center>
<p>So, the general rule that we will be following when we want to find the head for a downwards going diagonal is that:</p>
<blockquote>
<p>The head would be the node to the right of the tail of the previous diagonal. Unless the tail lies in the last column of the matrix in which case the head would be the node directly below the tail.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize a boolean variable called <code>direction</code> which will tell us whether the current diagonal is an upwards or downwards going. Based on the current direction and the tail, we will determine the head of the next diagonal. Initially the direction would be <code>1</code> which would indicate <code>up</code>. We will keep alternating this value from one iteration to the next.</p>
</li>
<li>
<p>Assuming we know the head of a diagonal, say <span class="math inline">\(matrix[i][j]\)</span>, we will use the direction to progress along the diagonal and process its elements.</p>
<ul>
<li>For an upwards going diagonal, the next element in the diagonal would be <span class="math inline">\(matrix[i - 1][j + 1]\)</span></li>
<li>For a downwards going diagonal, the next element would be <span class="math inline">\(matrix[i + 1][j - 1]\)</span>.</li>
</ul>
</li>
<li>
<p>We keep processing the elements of the current diagonal until we go out of the boundaries of the matrix.</p>
</li>
<li>
<p>Now, given that we know the tail of the diagonal (the last node before we went out of bounds), let's see how we can find the next head. Note that in the following pseudocode, the <code>direction</code> is for the current diagonal and we are trying to find the head of the next diagonal. So, if the direction is <code>up</code>, it means the next diagonal would be going down and vice-versa.</p>
 <pre>
tail = [i, j]
if direction == up, then {
   if [i, j + 1] is within bounds, then {
       next_head = [i, j + 1]
   } else { 
       next_head = [i + 1, j]
   }
} else {
   if [i + 1, j] is within bounds, then {
       next_head = [i + 1, j]
   } else { 
       next_head = [i, j + 1]
   }
}</pre>
</li>
<li>
<p>We keep processing the elements of a diagonal and once the current diagonal ends, we use the current direction and the tail element to find the next head and we switch over to processing the next diagonal. Also remember to flip the direction bit.</p>
</li>
</ol>
<p><a href="https://leetcode.com/playground/4fXSDJuN/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: <span class="math inline">\(O(N \cdot M)\)</span> since we process each element of the matrix exactly once.</li>
<li>Space Complexity: <span class="math inline">\(O(1)\)</span> since we don't make use of any additional data structure. Note that the space occupied by the output array doesn't count towards the space complexity since that is a requirement of the problem itself. Space complexity comprises any <code>additional</code> space that we may have used to get to build the final array. For the previous solution, it was the intermediate arrays. In this solution, we don't have any additional space apart from a couple of variables.<br />
<br><br />
<br></li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/description" target="_blank" rel="noopener noreferrer">Difference Between Ones and Zeros in Row and Column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A <strong>0-indexed</strong> <code>m x n</code> difference matrix <code>diff</code> is created with the following procedure:</p>

<ul>
	<li>Let the number of ones in the <code>i<sup>th</sup></code> row be <code>onesRow<sub>i</sub></code>.</li>
	<li>Let the number of ones in the <code>j<sup>th</sup></code> column be <code>onesCol<sub>j</sub></code>.</li>
	<li>Let the number of zeros in the <code>i<sup>th</sup></code> row be <code>zerosRow<sub>i</sub></code>.</li>
	<li>Let the number of zeros in the <code>j<sup>th</sup></code> column be <code>zerosCol<sub>j</sub></code>.</li>
	<li><code>diff[i][j] = onesRow<sub>i</sub> + onesCol<sub>j</sub> - zerosRow<sub>i</sub> - zerosCol<sub>j</sub></code></li>
</ul>

<p>Return <em>the difference matrix </em><code>diff</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png" style="width: 400px; height: 208px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,0,1],[0,0,1]]
<strong>Output:</strong> [[0,0,4],[0,0,4],[-2,-2,2]]
<strong>Explanation:</strong>
- diff[0][0] = <code>onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[0][1] = <code>onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[0][2] = <code>onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 
- diff[1][0] = <code>onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[1][1] = <code>onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 
- diff[1][2] = <code>onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 
- diff[2][0] = <code>onesRow<sub>2</sub> + onesCol<sub>0</sub> - zerosRow<sub>2</sub> - zerosCol<sub>0</sub></code> = 1 + 1 - 2 - 2 = -2
- diff[2][1] = <code>onesRow<sub>2</sub> + onesCol<sub>1</sub> - zerosRow<sub>2</sub> - zerosCol<sub>1</sub></code> = 1 + 1 - 2 - 2 = -2
- diff[2][2] = <code>onesRow<sub>2</sub> + onesCol<sub>2</sub> - zerosRow<sub>2</sub> - zerosCol<sub>2</sub></code> = 1 + 3 - 2 - 0 = 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png" style="width: 358px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]
<strong>Output:</strong> [[5,5,5],[5,5,5]]
<strong>Explanation:</strong>
- diff[0][0] = onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-array-counter">Approach: Array Counter</h3>
<p><strong>Intuition</strong></p>
<p>To build the matrix <code>diff</code>, we need to have the count of ones and zeroes in each row and column of the given matrix <code>grid</code>. One way is that for each cell <code>(i, j)</code> in the matrix <code>grid</code>, we can iterate over the <code>ith</code> row and <code>jth</code> column to find the number of ones and zeroes, and set the value <code>diff[i][j]</code> as <span class="math inline">\(onesRow_{i}\)</span> + <span class="math inline">\(onesCol_{j}\)</span> - <span class="math inline">\(zerosRow_{i}\)</span> - <span class="math inline">\(zerosCol_{j}\)</span>. However, this approach is inefficient, as for each of the <span class="math inline">\(M \cdot N\)</span> cells, we will have to iterate over a row and a column of <span class="math inline">\(M + N\)</span> cells to count the number of zeroes and ones, resulting in a complexity of <span class="math inline">\(O(M  \cdot N  \cdot (M + N))\)</span>.</p>
<p>Note that in the above approach, we are iterating over the cells repeatedly. However, when we iterate over the <code>ith</code> row to find the number of ones/zeros of that row, we're also simultaneously finding (and recording, if we can) all the columns of the cell located in the row. For example, when we traverse the first row, we are not only recording the count of ones and zeros in the first row but also the count of ones/zeros in all the cells located in the first row. When we traverse the second row, we also record the count of ones/zeros in all the cells located in the second row. So, when we finish traversing all the rows, we simultaneously obtain the count of ones/zeros for each column. Therefore, we could avoid repeated iteration by precomputing the number of ones/zeroes in each row and column.</p>
<p>We will keep two arrays <code>onesRow</code> of size <code>M</code> to store the count of ones in each row and <code>onesCol</code> of size <code>N</code> to store the ones in each column. We will then iterate over each cell in the matrix <code>grid</code> and for each cell, we add the value <code>grid[i][j]</code> to <code>onesRow[i]</code> and <code>onesCol[j]</code>. This is because matrices are binary, and adding <code>grid[i][j]</code> essentially increases the number of ones. Specifically, if <code>grid[i][j] = 1</code>, adding <code>grid[i][j]</code> means increasing the number of ones. If <code>grid[i][j] = 0</code>, we can still add <code>grid[i][j]</code>, since it means adding 0 so we are not increasing the number of ones.</p>
<p>Note that we don't need to build another two arrays to store the counts of zeroes, this is because the length of each row and column is fixed, and we can get the number of zeroes by subtracting the number of ones from the length of a row/column.<br />
<img src="../Figures/2482/2482A.png" alt="fig" /></p>
<p>So the value expression for <code>diff[i]</code> will be:</p>
<pre><code> diff[i][j] = onesRow[i] + onesCol[j] - (N - onesRow[i]) - (M - onesCol[j])
            = 2 * onesRow[i] + 2 * onesCol[j] - N - M
</code></pre>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize two arrays <code>onesRow</code> and <code>onesCol</code> of size <code>M</code> and <code>N</code> with zeroes.</li>
<li>Iterate over the cells in the matrix <code>grid</code> and add the value <code>grid[i][j]</code> to <code>onesRow[i]</code> and <code>onesCol[j]</code>.</li>
<li>Initialize an empty matrix matrix <code>diff</code> with size <code>M * N</code>.</li>
<li>Iterate over the matrix <code>grid</code> and assign <code>diff[i][j]</code> as <code>2 * onesRow[i] + 2 * onesCol[j] - N - M</code>.</li>
<li>Return <code>diff</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/44swEiQC/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the <code>grid</code>, and <span class="math inline">\(N\)</span> is the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M * N)\)</span></p>
<p>Each cell in the matrix is traversed twice, once to find the ones count and store them in <code>onesRow</code> and <code>onesCol</code>. Then again to find the values in the matrix <code>diff</code>. Hence the total time complexity is equal to <span class="math inline">\(O(M * N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M + N)\)</span></p>
<p>The only space we required apart from the matrix <code>diff</code> which is used to store the answer and is not considered as part of space complexity are the two arrays <code>onesRow</code> and <code>onesCol</code> to store the count of ones in the rows and columns. Therefore, the total space complexity is equal to <span class="math inline">\(O(M + N)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/description" target="_blank" rel="noopener noreferrer">Difference of Number of Distinct Values on Diagonals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D <code>grid</code> of size <code>m x n</code>, you should find the matrix <code>answer</code> of size <code>m x n</code>.</p>

<p>The cell <code>answer[r][c]</code> is calculated by looking at the diagonal values of the cell <code>grid[r][c]</code>:</p>

<ul>
	<li>Let <code>leftAbove[r][c]</code> be the number of <strong>distinct</strong> values on the diagonal to the left and above the cell <code>grid[r][c]</code> not including the cell <code>grid[r][c]</code> itself.</li>
	<li>Let <code>rightBelow[r][c]</code> be the number of <strong>distinct</strong> values on the diagonal to the right and below the cell <code>grid[r][c]</code>, not including the cell <code>grid[r][c]</code> itself.</li>
	<li>Then <code>answer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|</code>.</li>
</ul>

<p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.</p>

<ul>
	<li>For example, in the below diagram the diagonal is highlighted using the cell with indices <code>(2, 3)</code> colored gray:

	<ul>
		<li>Red-colored cells are left and above the cell.</li>
		<li>Blue-colored cells are right and below the cell.</li>
	</ul>
	</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/26/diagonal.png" style="width: 200px; height: 160px;" /></p>

<p>Return the matrix <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,3],[3,1,5],[3,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">Output: [[1,1,0],[1,0,1],[0,1,1]]</span></p>

<p><strong>Explanation:</strong></p>

<p>To calculate the <code>answer</code> cells:</p>

<table>
	<thead>
		<tr>
			<th>answer</th>
			<th>left-above elements</th>
			<th>leftAbove</th>
			<th>right-below elements</th>
			<th>rightBelow</th>
			<th>|leftAbove - rightBelow|</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>[0][0]</td>
			<td>[]</td>
			<td>0</td>
			<td>[grid[1][1], grid[2][2]]</td>
			<td>|{1, 1}| = 1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[0][1]</td>
			<td>[]</td>
			<td>0</td>
			<td>[grid[1][2]]</td>
			<td>|{5}| = 1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[0][2]</td>
			<td>[]</td>
			<td>0</td>
			<td>[]</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>[1][0]</td>
			<td>[]</td>
			<td>0</td>
			<td>[grid[2][1]]</td>
			<td>|{2}| = 1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[1][1]</td>
			<td>[grid[0][0]]</td>
			<td>|{1}| = 1</td>
			<td>[grid[2][2]]</td>
			<td>|{1}| = 1</td>
			<td>0</td>
		</tr>
		<tr>
			<td>[1][2]</td>
			<td>[grid[0][1]]</td>
			<td>|{2}| = 1</td>
			<td>[]</td>
			<td>0</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[2][0]</td>
			<td>[]</td>
			<td>0</td>
			<td>[]</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>[2][1]</td>
			<td>[grid[1][0]]</td>
			<td>|{3}| = 1</td>
			<td>[]</td>
			<td>0</td>
			<td>1</td>
		</tr>
		<tr>
			<td>[2][2]</td>
			<td>[grid[0][0], grid[1][1]]</td>
			<td>|{1, 1}| = 1</td>
			<td>[]</td>
			<td>0</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">Output: [[0]]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n, grid[i][j] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/description" target="_blank" rel="noopener noreferrer">Disconnect Path in a Binary Matrix by at Most One Flip</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> <strong>binary</strong> matrix <code>grid</code>. You can move from a cell <code>(row, col)</code> to any of the cells <code>(row + 1, col)</code> or <code>(row, col + 1)</code> that has the value <code>1</code>.&nbsp;The matrix is <strong>disconnected</strong> if there is no path from <code>(0, 0)</code> to <code>(m - 1, n - 1)</code>.</p>

<p>You can flip the value of <strong>at most one</strong> (possibly none) cell. You <strong>cannot flip</strong> the cells <code>(0, 0)</code> and <code>(m - 1, n - 1)</code>.</p>

<p>Return <code>true</code> <em>if it is possible to make the matrix disconnect or </em><code>false</code><em> otherwise</em>.</p>

<p><strong>Note</strong> that flipping a cell changes its value from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png" style="width: 441px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,0],[1,1,1]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/distance-of-nearest-cell-having-1-1587115620/1" target="_blank" rel="noopener noreferrer">Distance of nearest cell having 1</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary grid of <strong>n*m</strong>. Find the distance of the nearest 1 in the grid&nbsp;for each cell.<br />The distance is calculated as&nbsp;<strong>|i<sub>1</sub>&nbsp; - i<sub>2</sub>| + |j<sub>1</sub>&nbsp;- j<sub>2</sub>|</strong>, where i<sub>1</sub>, j<sub>1</sub>&nbsp;are the row number and column number of the current cell, and i<sub>2</sub>, j<sub>2</sub>&nbsp;are the row number and column number of the nearest cell having value 1.</span>&nbsp;<span style="font-size: 18px;">There should be atleast one 1 in the grid.</span></p>
<p><span style="font-size: 18px;"><strong>Examples</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[0,1,1,0], [1,1,0,0], [0,0,1,1]]
<strong>Output: <br /></strong>[[1,0,0,1], [0,0,1,1], [1,1,0,0]]
<strong>Explanation: <br /></strong>The grid is-
0 1 1 0&nbsp;
1 1 0 0&nbsp;
0 0 1 1&nbsp;
- 0's at (0,0), (0,3), (1,2), (1,3), (2,0) and (2,1) are at a distance of 1 from 1's at (0,1), (0,2), (0,2), (2,3), (1,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid0_1745302650.jpg" width="183" height="162" /> </pre>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = [[1,0,1], [1,1,0], [1,0,0]]
<strong>Output: <br /></strong>[[0,1,0], [0,0,1], [0,1,2]]
<strong>Explanation:</strong></span><span style="font-size: 18px;">&nbsp;<br />The grid is-
1 0 1
1 1 0
1 0 0
- 0's at (0,1), (1,2), (2,1) and (2,2) are at a  distance of 1, 1, 1 and 2 from 1's at (0,0), (0,2), (2,0) and (1,1) respectively.
</span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701275/Web/Other/blobid1_1745302675.jpg" width="196" height="173" /> </pre>
<p><span style="font-size: 18px;"><strong>Yout Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>nearest()&nbsp;</strong>which takes the grid as an input parameter and returns a matrix of the same dimensions where the value at index (i, j) in the resultant matrix signifies the <strong>minimum distance</strong> of 1 in the matrix from grid[i][j].</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/dungeon-game/description" target="_blank" rel="noopener noreferrer">Dungeon Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p>

<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p>

<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&#39;s health (represented by positive integers).</p>

<p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p>

<p>Return <em>the knight&#39;s minimum initial health so that he can rescue the princess</em>.</p>

<p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> dungeon = [[0]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == dungeon.length</code></li>
	<li><code>n == dungeon[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-row-and-column-pairs/description" target="_blank" rel="noopener noreferrer">Equal Row and Column Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> <code>n x n</code> integer matrix <code>grid</code>, <em>return the number of pairs </em><code>(r<sub>i</sub>, c<sub>j</sub>)</code><em> such that row </em><code>r<sub>i</sub></code><em> and column </em><code>c<sub>j</sub></code><em> are equal</em>.</p>

<p>A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg" style="width: 150px; height: 153px;" />
<pre>
<strong>Input:</strong> grid = [[3,2,1],[1,7,6],[2,7,7]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg" style="width: 200px; height: 209px;" />
<pre>
<strong>Input:</strong> grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-sum-grid-partition-i/description" target="_blank" rel="noopener noreferrer">Equal Sum Grid Partition I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> of positive integers. Your task is to determine if it is possible to make <strong>either one horizontal or one vertical cut</strong> on the grid such that:</p>

<ul>
	<li>Each of the two resulting sections formed by the cut is <strong>non-empty</strong>.</li>
	<li>The sum of the elements in both sections is <strong>equal</strong>.</li>
</ul>

<p>Return <code>true</code> if such a partition exists; otherwise return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.png" style="width: 200px;" /><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.jpeg" style="width: 200px; height: 200px;" /></p>

<p>A horizontal cut between row 0 and row 1 results in two non-empty sections, each with a sum of 5. Thus, the answer is <code>true</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,3],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>No horizontal or vertical cut results in two non-empty sections with equal sums. Thus, the answer is <code>false</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= n == grid[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/equal-sum-grid-partition-ii/description" target="_blank" rel="noopener noreferrer">Equal Sum Grid Partition II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> of positive integers. Your task is to determine if it is possible to make <strong>either one horizontal or one vertical cut</strong> on the grid such that:</p>

<ul>
	<li>Each of the two resulting sections formed by the cut is <strong>non-empty</strong>.</li>
	<li>The sum of elements in both sections is <b>equal</b>, or can be made equal by discounting <strong>at most</strong> one single cell in total (from either section).</li>
	<li>If a cell is discounted, the rest of the section must <strong>remain connected</strong>.</li>
</ul>

<p>Return <code>true</code> if such a partition exists; otherwise, return <code>false</code>.</p>

<p><strong>Note:</strong> A section is <strong>connected</strong> if every cell in it can be reached from any other cell by moving up, down, left, or right through other cells in the section.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,4],[2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/30/lc.jpeg" style="height: 180px; width: 180px;" /></p>

<ul>
	<li>A horizontal cut after the first row gives sums <code>1 + 4 = 5</code> and <code>2 + 3 = 5</code>, which are equal. Thus, the answer is <code>true</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/04/01/chatgpt-image-apr-1-2025-at-05_28_12-pm.png" style="height: 180px; width: 180px;" /></p>

<ul>
	<li>A vertical cut after the first column gives sums <code>1 + 3 = 4</code> and <code>2 + 4 = 6</code>.</li>
	<li>By discounting 2 from the right section (<code>6 - 2 = 4</code>), both sections have equal sums and remain connected. Thus, the answer is <code>true</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,4],[2,3,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2025/04/01/chatgpt-image-apr-2-2025-at-02_50_29-am.png" style="height: 180px; width: 180px;" /></strong></p>

<ul>
	<li>A horizontal cut after the first row gives <code>1 + 2 + 4 = 7</code> and <code>2 + 3 + 5 = 10</code>.</li>
	<li>By discounting 3 from the bottom section (<code>10 - 3 = 7</code>), both sections have equal sums, but they do not remain connected as it splits the bottom section into two parts (<code>[2]</code> and <code>[5]</code>). Thus, the answer is <code>false</code>.</li>
</ul>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[4,1,8],[3,2,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>No valid cut exists, so the answer is <code>false</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= n == grid[i].length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/escape-the-spreading-fire/description" target="_blank" rel="noopener noreferrer">Escape the Spreading Fire</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> which represents a field. Each cell has one of three values:</p>

<ul>
	<li><code>0</code> represents grass,</li>
	<li><code>1</code> represents fire,</li>
	<li><code>2</code> represents a wall that you and fire cannot pass through.</li>
</ul>

<p>You are situated in the top-left cell, <code>(0, 0)</code>, and you want to travel to the safehouse at the bottom-right cell, <code>(m - 1, n - 1)</code>. Every minute, you may move to an <strong>adjacent</strong> grass cell. <strong>After</strong> your move, every fire cell will spread to all <strong>adjacent</strong> cells that are not walls.</p>

<p>Return <em>the <strong>maximum</strong> number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse</em>. If this is impossible, return <code>-1</code>. If you can <strong>always</strong> reach the safehouse regardless of the minutes stayed, return <code>10<sup>9</sup></code>.</p>

<p>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.</p>

<p>A cell is <strong>adjacent</strong> to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" style="width: 650px; height: 404px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" style="width: 515px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" style="width: 174px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[2,2,0],[1,2,0]]
<strong>Output:</strong> 1000000000
<strong>Explanation:</strong> The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 10<sup>9</sup> is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 300</code></li>
	<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/exit-point-in-a-matrix0905/1" target="_blank" rel="noopener noreferrer">Exit Point in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>matrix</strong> of size <strong>n x m</strong> with <strong>0&rsquo;s</strong> and <strong>1&rsquo;s</strong>, you enter the matrix at cell <strong>(0,0)</strong> in <strong>left to right</strong> direction. Whenever you encounter a <strong>0</strong> you retain it in the <strong>same</strong> <strong>direction</strong>, else if you encounter a <strong>1</strong> you have to <strong>change</strong> the direction<strong> </strong>to the <strong>right </strong>of the current direction and <strong>change that 1</strong> value to <strong>0</strong>, you have to find out from which index you will <strong>leave </strong>the matrix<strong> </strong>at the end.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>n = 3, m = 3<strong><br /></strong>matrix = {{0, 1, 0},
          {0, 1, 1}, <br />          {0, 0, 0}}
<strong>Output: <br /></strong>{1, 0}
<strong>Explanation: <br /></strong>Enter the matrix at (0, 0) <br />-&gt; then move towards (0, 1) -&gt;  1 is encountered <br />-&gt; turn right towards (1, 1)  -&gt; again 1 is encountered <br />-&gt; turn right again towards (1, 0) <br />-&gt; now, the boundary of matrix will be crossed -&gt;hence, exit point reached at 1, 0..</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>n = 1, m = 2<strong><br /></strong>matrix = {{0, 0}}
<strong>Output: <br /></strong>{0, 1}<br /><strong>Explanation: <br /></strong>Enter the matrix at cell (0, 0).
Since the cell contains a 0, we continue moving in the same direction.
We reach cell (0, 1), which also contains a 0. So, we continue moving in the same direction, we exit the matrix from cell (0, 1).<br /></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>FindExitPoint()&nbsp;</strong>which takes the <strong>matrix</strong> as an input parameter and returns a <strong>list</strong> containing the <strong>exit point.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n * m) where n = number of rows and m = number of columns.<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n, m &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/expectation-2-4eb0b2e0/" target="_blank" rel="noopener noreferrer">Expectation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bitmanipulation</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Y was<em>Â looking for a single sign of hope</em>Â and then he saw a grid with two rows andÂ <span class="mathjax-latex">\(n\)</span>Â columns. as aÂ <em>typical prison punishment</em>Â Y is going to paint the grid.</p>

<p>Y thinks two cells are <strong>connected</strong> if they share a side and both are painted in theÂ <strong>same color</strong>.</p>

<p>He also thinks there is a <strong>path</strong> between two cellsÂ <span class="mathjax-latex">\(A\)</span>Â andÂ <span class="mathjax-latex">\(B\)</span> if there is a sequence of cellsÂ which starts with <span class="mathjax-latex">\(A\)</span> and ends with <span class="mathjax-latex">\(B\)</span>Â and any twoÂ consecutive cells in the sequence are <strong>connected</strong>.</p>

<p>Y calls a subset of grid's cells a <strong>connected component</strong>, if there is a path between any pair of subset's cells.</p>

<p>And at last, Y calls a connected componentÂ <span class="mathjax-latex">\(C\)</span> a <strong>maximal</strong>Â <strong>connected component</strong>, if there isn't any other connected component that includes <span class="mathjax-latex">\(C\)</span>.</p>

<p>If Y paints a cell in black or white with the same probability (bothÂ <span class="mathjax-latex">\(\frac{1}{2}\)</span>Â ), what is the expected number of maximal connected components modularÂ <span class="mathjax-latex">\(10^9+7\)</span> in the colored grid?</p>

<p>If the expected value isÂ <span class="mathjax-latex">\(\frac{P}{Q}\)</span>, printÂ <span class="mathjax-latex">\(P \times Q^{-1} \mod 10^9+7\)</span>.</p>

<p><strong>Input</strong></p>

<p>First and the only input line contains onlyÂ <span class="mathjax-latex">\(n\)</span>, number of grid's columns.</p>

<p><span class="mathjax-latex">\(1 \leq n \leq 10^{18}\)</span></p>

<p><strong>Output</strong></p>

<p>The only line of output contains an integer, expected number of maximal connected componentsÂ modularÂ <span class="mathjax-latex">\(10^9+7\)</span>.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>As shown the expectation number of maximal connected components are:<br>
<span class="mathjax-latex">\(\frac{1 + 2 + 2 + 2 + 2 + 2 + 4 + 2 + 2 + 4 + 2 + 2 + 2 + 2 + 2 + 1}{4} = \frac{34}{4}\)</span>.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/fill-a-special-grid/description" target="_blank" rel="noopener noreferrer">Fill a Special Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a non-negative integer <code><font face="monospace">n</font></code> representing a <code>2<sup>n</sup> x 2<sup>n</sup></code> grid. You must fill the grid with integers from 0 to <code>2<sup>2n</sup> - 1</code> to make it <strong>special</strong>. A grid is <strong>special</strong> if it satisfies <strong>all</strong> the following conditions:</p>

<ul>
	<li>All numbers in the top-right quadrant are smaller than those in the bottom-right quadrant.</li>
	<li>All numbers in the bottom-right quadrant are smaller than those in the bottom-left quadrant.</li>
	<li>All numbers in the bottom-left quadrant are smaller than those in the top-left quadrant.</li>
	<li>Each of its quadrants is also a special grid.</li>
</ul>

<p>Return the <strong>special</strong> <code>2<sup>n</sup> x 2<sup>n</sup></code> grid.</p>

<p><strong>Note</strong>: Any 1x1 grid is special.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">[[0]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The only number that can be placed is 0, and there is only one possible position in the grid.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[[3,0],[2,1]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The numbers in each quadrant are:</p>

<ul>
	<li>Top-right: 0</li>
	<li>Bottom-right: 1</li>
	<li>Bottom-left: 2</li>
	<li>Top-left: 3</li>
</ul>

<p>Since <code>0 &lt; 1 &lt; 2 &lt; 3</code>, this satisfies the given constraints.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[15,12,3,0],[14,13,2,1],[11,8,7,4],[10,9,6,5]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/05/4123example3p1drawio.png" style="width: 161px; height: 161px;" /></p>

<p>The numbers in each quadrant are:</p>

<ul>
	<li>Top-right: 3, 0, 2, 1</li>
	<li>Bottom-right: 7, 4, 6, 5</li>
	<li>Bottom-left: 11, 8, 10, 9</li>
	<li>Top-left: 15, 12, 14, 13</li>
	<li><code>max(3, 0, 2, 1) &lt; min(7, 4, 6, 5)</code></li>
	<li><code>max(7, 4, 6, 5) &lt; min(11, 8, 10, 9)</code></li>
	<li><code>max(11, 8, 10, 9) &lt; min(15, 12, 14, 13)</code></li>
</ul>

<p>This satisfies the first three requirements. Additionally, each quadrant is also a special grid. Thus, this is a special grid.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= n &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-good-subset-of-the-matrix/description" target="_blank" rel="noopener noreferrer">Find a Good Subset of the Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>Let us call a <strong>non-empty</strong> subset of rows <strong>good</strong> if the sum of each column of the subset is at most half of the length of the subset.</p>

<p>More formally, if the length of the chosen subset of rows is <code>k</code>, then the sum of each column should be at most <code>floor(k / 2)</code>.</p>

<p>Return <em>an integer array that contains row indices of a good subset sorted in <strong>ascending</strong> order.</em></p>

<p>If there are multiple good subsets, you can return any of them. If there are no good subsets, return an empty array.</p>

<p>A <strong>subset</strong> of rows of the matrix <code>grid</code> is any matrix that can be obtained by deleting some (possibly none or all) rows from <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> We can choose the 0<sup>th</sup> and 1<sup>st</sup> rows to create a good subset of rows.
The length of the chosen subset is 2.
- The sum of the 0<sup>th</sup>&nbsp;column is 0 + 0 = 0, which is at most half of the length of the subset.
- The sum of the 1<sup>st</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.
- The sum of the 2<sup>nd</sup>&nbsp;column is 1 + 0 = 1, which is at most half of the length of the subset.
- The sum of the 3<sup>rd</sup>&nbsp;column is 0 + 1 = 1, which is at most half of the length of the subset.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0]]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can choose the 0<sup>th</sup> row to create a good subset of rows.
The length of the chosen subset is 1.
- The sum of the 0<sup>th</sup>&nbsp;column is 0, which is at most half of the length of the subset.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,1,1]]
<strong>Output:</strong> []
<strong>Explanation:</strong> It is impossible to choose any subset of rows to create a good subset.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= n &lt;= 5</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-groups-of-farmland/description" target="_blank" rel="noopener noreferrer">Find All Groups of Farmland</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> binary matrix <code>land</code> where a <code>0</code> represents a hectare of forested land and a <code>1</code> represents a hectare of farmland.</p>

<p>To keep the land organized, there are designated rectangular areas of hectares that consist <strong>entirely</strong> of farmland. These rectangular areas are called <strong>groups</strong>. No two groups are adjacent, meaning farmland in one group is <strong>not</strong> four-directionally adjacent to another farmland in a different group.</p>

<p><code>land</code> can be represented by a coordinate system where the top left corner of <code>land</code> is <code>(0, 0)</code> and the bottom right corner of <code>land</code> is <code>(m-1, n-1)</code>. Find the coordinates of the top left and bottom right corner of each <strong>group</strong> of farmland. A <strong>group</strong> of farmland with a top left corner at <code>(r<sub>1</sub>, c<sub>1</sub>)</code> and a bottom right corner at <code>(r<sub>2</sub>, c<sub>2</sub>)</code> is represented by the 4-length array <code>[r<sub>1</sub>, c<sub>1</sub>, r<sub>2</sub>, c<sub>2</sub>].</code></p>

<p>Return <em>a 2D array containing the 4-length arrays described above for each <strong>group</strong> of farmland in </em><code>land</code><em>. If there are no groups of farmland, return an empty array. You may return the answer in <strong>any order</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> land = [[1,0,0],[0,1,1],[0,1,1]]
<strong>Output:</strong> [[0,0,0,0],[1,1,2,2]]
<strong>Explanation:</strong>
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> land = [[1,1],[1,1]]
<strong>Output:</strong> [[0,0,1,1]]
<strong>Explanation:</strong>
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png" style="width: 100px; height: 100px;" />
<pre>
<strong>Input:</strong> land = [[0]]
<strong>Output:</strong> []
<strong>Explanation:</strong>
There are no groups of farmland.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == land.length</code></li>
	<li><code>n == land[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>land</code> consists of only <code>0</code>&#39;s and <code>1</code>&#39;s.</li>
	<li>Groups of farmland are <strong>rectangular</strong> in shape.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary matrix of <code>0s</code> and <code>1s</code> of size <code>M x N</code>. The value <code>0</code> represents the forest land and <code>1</code> represents the farmland. We need to return a list with the top left and bottom right coordinates of each farmland in the matrix. All farmlands are rectangular. We can leverage this fact to make our search for farmland more efficient. From a given farmland cell, we can determine which of the eight neighboring cells is farmland by checking just four neighbors (left, right, up, and down). We don't need to check the diagonal neighbors because we can infer whether they are farmland. For example, if the cells on the right and below a farmland cell are also farmland, then the diagonal cell, as shown below, will have to be a farmland cell for this farmland to be rectangular.</p>
<p><img src="../Figures/1992/1992B.png" alt="fig" /></p>
<p>Therefore, this problem is similar to this <a href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a> problem, except the components (islands of farmland) here will always be rectangular. We will use this property in our third greedy approach. The first two approaches, DFS &amp; BFS, are similar to the one applied in <a href="https://leetcode.com/problems/number-of-islands/solution/">Number of Islands soluton</a>.</p>
<p><img src="../Figures/1992/1992A.png" alt="fig" /></p>
<blockquote>
<p>Note: In the following two approaches below, we used a separate array to keep track of visited cells; this could be done using the original input matrix. However, in an interview setting, altering the inputs is not recommended. We have applied this input-altering strategy in our last approach to demonstrate how it can be done.</p>
</blockquote>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find all the cells in each farmland. We will apply a depth-first search from each of the cells with the value <code>1</code> that has not yet been visited. In the depth-first search process, we will traverse each of the four connected neighbors with the value <code>1</code> and apply DFS. This way, we can traverse over all the cells in each farmland.</p>
<p>We need a way to find the top left and bottom right cell coordinates of each farmland. Since the order of cell traversal in DFS is not fixed, there is no way to find when the last cell will be visited. To solve this, we can keep the maximum <code>x</code> and <code>y</code> coordinates we have seen so far. This way the maximum <code>x</code> and <code>y</code> coordinates will refer to the bottom right coordinates, and the coordinate of the cell with which we started the DFS will be the top left coordinate.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Iterate over each cell in the matrix <code>land</code>, and for each cell <code>(row1, col1)</code>, do the following:</p>
<ul>
<li>If the cell is a farmland cell, i.e. <code>land[row1][col1] = 1</code>, and hasn't been visited yet (<code>visited[row1][col1] = 0</code>), start DFS from <code>(row1, col1)</code>. Also, keep two variables <code>row2</code> and <code>col2</code> as the coordinates of the bottom right corner initialized with <code>0</code> each.</li>
<li>In the DFS, mark the current coordinates as visited and update the values of <code>row2</code> and <code>col2</code> to the maximum compared with the current coordinates.</li>
<li>Traverse over the four neighbors and apply DFS if the neighbor is within the matrix boundary, a farmland cell, and hasn't been visited yet.</li>
<li>When the DFS is complete, store the top left coordinate as <code>(row1, col1)</code> and the bottom right as <code>(row2, col2)</code> in the list <code>ans</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Nmdf4uzS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because we used the <code>visited</code> array to prevent re-processing cells. All other helper functions like <code>isWithinFarm</code> are <span class="math inline">\(O(1)\)</span>. Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The array <code>visited</code> is of size <span class="math inline">\(M \cdot N\)</span>; also, there will be stack space consumed by DFS that will be equal to the maximum number of active stack calls, which will be equal to <span class="math inline">\(M * N\)</span> if all cells are <code>1</code> in the matrix. Apart from this, there is also array <code>ans</code>, but the space used to store the result isn't considered part of space complexity. Hence, the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similarly to the previous approach, we will traverse over each farmland and store the top left and bottom right corner coordinates in our answer. We will use the breadth-first search here to iterate over each cell. Iterating over the matrix, we will enqueue the first cell and mark it visited in the array <code>visited</code>. In the BFS, we will pop the cell from the queue, iterate over the four neighbors, and add them to the queue if the farmland cells have not been visited yet.</p>
<p>In BFS, the cells are visited in fixed order using a queue, and hence, we can identify the last visited cell in this group of farmland. Therefore, we don't need to keep the maximum coordinates we have seen. We can store the last cell we visit from the current group of farmland in the BFS, which would be the coordinates of the current farmland in the bottom right corner.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Iterate over each cell in the matrix <code>land</code> and for each cell <code>(row1, col1)</code> do the following:</p>
<ul>
<li>If the cell is a farmland cell, i.e <code>land[row1][col1] = 1</code> and isn't visited yet (<code>visited[row1][col1] = 0</code>), enqueue it to the queue start BFS from <code>(row1, col1)</code>.</li>
<li>Traverse over the four neighbors and add them to the queue for BFS if the neighbor is within the matrix boundary and is a farmland cell and hasn't visited yet. Also, mark these coordinates as visited.</li>
<li>When the BFS completes return the last coordinate that was popped from the queue and store the top left coordinate as <code>(row1, col1)</code> and the bottom right as the last visited node in the list <code>ans</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QpeHLgK4/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because of the <code>visited</code> array. All other helper functions like <code>isWithinFarm</code> are <span class="math inline">\(O(1)\)</span>. Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The array <code>visited</code> is of size <span class="math inline">\(M \cdot N\)</span>, also there will be space consumed by the queue that can be equal to <span class="math inline">\(M * N\)</span> if all cells are <code>1</code> in the matrix. Apart from this, there is also array <code>ans</code>, but the space used to store the result isn't considered as part of the space complexity. Hence, the total space complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We can solve this problem with a greedy approach because all farmlands will be rectangular. DFS and BFS approaches are able to find irregularly shaped farmland. Since farmlands are rectangular, we can just start from the first farmland cell, the top left corner, and iterate over the cells in the current row until we find a cell with the value <code>0</code>. The y-coordinate of this cell will be the <code>y</code> coordinate of the bottom right corner. We can then iterate over the cells with this <code>y</code> coordinate and increase the <code>x</code> coordinate until we find the cell with value <code>0</code>, this will be the bottom right corner of the current farmland.</p>
<p>We will also need to keep track of which cells have already been visited. We could use a separate array <code>visited</code> as we did in the last two approaches, but we will use the input matrix here to demonstrate another strategy. We mark all cells with values <code>1</code> to <code>0</code> in the farmland so that we don't visit them again and consider them as separate farmland. Please note that in an interview setting changing the input is generally discouraged.</p>
<p>This way, we will start from the first cell with the value <code>1</code> and then find the bottom right corner coordinate using the above strategy, then store the resulting coordinates in the list <code>ans</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize dimensions <code>M</code> and <code>N</code> to represent the number of rows and columns in the <code>land</code> grid.</p>
</li>
<li>
<p>Create a <code>res</code> array to store the top-left and bottom-right coordinates of each farmland plot.</p>
</li>
<li>
<p>Iterate through each cell in the grid using nested loops:</p>
<ul>
<li>For every cell <code>(row1, col1)</code>, check if it is part of farmland (<code>land[row1][col1] == 1</code>).</li>
<li>If farmland is found, initialize <code>x</code> to <code>row1</code> and <code>y</code> to <code>col1</code>.</li>
</ul>
</li>
<li>
<p>Expand the farmland boundaries:</p>
<ul>
<li>Increment <code>x</code> until you find the last row where <code>land[x][col1] == 1</code>.</li>
<li>For each row in this range, increment <code>y</code> until you find the last column where <code>land[x][y] == 1</code>.</li>
<li>Mark all cells in the identified rectangle as <code>0</code> to avoid revisiting them.</li>
</ul>
</li>
<li>
<p>Record the top-left <code>(row1, col1)</code> and bottom-right <code>(x - 1, y - 1)</code> coordinates of the current farmland plot in <code>res</code>.</p>
</li>
<li>
<p>Return the <code>res</code> array containing the coordinates of all identified farmland plots.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/ADduxYQV/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows in the matrix and <span class="math inline">\(N\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will iterate over each cell in the matrix at most once because we mark the visited cells in the <code>land</code>  array.  Hence, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only space required is <code>ans</code> but the space used to store the result isn't considered as part of space complexity. Hence, the total space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-all-possible-paths-from-top-to-bottom/1" target="_blank" rel="noopener noreferrer">Find all possible paths from top to bottom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a N x M grid. Find All possible paths from top left to bottom right.F<em>rom each cell you can either move only to right or down</em>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span><span style="font-size:18px">1 2 3</span>
<span style="font-size:18px">       4 5 6</span>
<span style="font-size:18px"><strong>Output: </strong></span><span style="font-size:18px">1 4 5 6</span>
<span style="font-size:18px">        1 2 5 6 </span>
<span style="font-size:18px">        1 2 3 6</span>
<span style="font-size:18px"><strong>Explanation: </strong>We can see that there are 3 </span>
<span style="font-size:18px">paths from the cell (0,0) to (1,2).</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong></span><span style="font-size:18px">1 2</span>
<span style="font-size:18px">       3 4</span>
<span style="font-size:18px"><strong>Output: </strong></span><span style="font-size:18px">1 2 4</span>
<span style="font-size:18px">        1 3 4</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>findAllPossiblePaths()&nbsp;</strong>which takes&nbsp;two integers n,m and grid[][]&nbsp;&nbsp;as input parameters and returns all possible paths from the top left cell to bottom right cell&nbsp;in a 2d array.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(2^N*M)<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n,m &lt;= 10<sup>&nbsp;</sup><br />
1 &lt;= grid[i][j] &lt;= n*m<br />
n * m &lt;&nbsp;20</span><br />
&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-peak-element-ii/description" target="_blank" rel="noopener noreferrer">Find a Peak Element II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>peak</strong> element in a 2D grid is an element that is <strong>strictly greater</strong> than all of its <strong>adjacent </strong>neighbors to the left, right, top, and bottom.</p>

<p>Given a <strong>0-indexed</strong> <code>m x n</code> matrix <code>mat</code> where <strong>no two adjacent cells are equal</strong>, find <strong>any</strong> peak element <code>mat[i][j]</code> and return <em>the length 2 array </em><code>[i,j]</code>.</p>

<p>You may assume that the entire matrix is surrounded by an <strong>outer perimeter</strong> with the value <code>-1</code> in each cell.</p>

<p>You must write an algorithm that runs in <code>O(m log(n))</code> or <code>O(n log(m))</code> time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/1.png" style="width: 206px; height: 209px;" /></p>

<pre>
<strong>Input:</strong> mat = [[1,4],[3,2]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong>&nbsp;Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/07/3.png" style="width: 254px; height: 257px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]
<strong>Output:</strong> [1,1]
<strong>Explanation:</strong>&nbsp;Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
	<li>No two adjacent cells are equal.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-a-safe-walk-through-a-grid/description" target="_blank" rel="noopener noreferrer">Find a Safe Walk Through a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> and an integer <code>health</code>.</p>

<p>You start on the upper-left corner <code>(0, 0)</code> and would like to get to the lower-right corner <code>(m - 1, n - 1)</code>.</p>

<p>You can move up, down, left, or right from one cell to another adjacent cell as long as your health <em>remains</em> <strong>positive</strong>.</p>

<p>Cells <code>(i, j)</code> with <code>grid[i][j] = 1</code> are considered <strong>unsafe</strong> and reduce your health by 1.</p>

<p>Return <code>true</code> if you can reach the final cell with a health value of 1 or more, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png" style="width: 301px; height: 121px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>A minimum of 4 health points is needed to reach the final cell safely.</p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png" style="width: 361px; height: 161px;" /></div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The final cell can be reached safely by walking along the gray cells below.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png" style="width: 181px; height: 121px;" /></p>

<p>Any path that does not go through the cell <code>(1, 1)</code> is unsafe since your health will drop to 0 when reaching the final cell.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code><font face="monospace">2 &lt;= m * n</font></code></li>
	<li><code>1 &lt;= health &lt;= m + n</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-champion-i/description" target="_blank" rel="noopener noreferrer">Find Champion I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> teams numbered from <code>0</code> to <code>n - 1</code> in a tournament.</p>

<p>Given a <strong>0-indexed</strong> 2D boolean matrix <code>grid</code> of size <code>n * n</code>. For all <code>i, j</code> that <code>0 &lt;= i, j &lt;= n - 1</code> and <code>i != j</code> team <code>i</code> is <strong>stronger</strong> than team <code>j</code> if <code>grid[i][j] == 1</code>, otherwise, team <code>j</code> is <strong>stronger</strong> than team <code>i</code>.</p>

<p>Team <code>a</code> will be the <strong>champion</strong> of the tournament if there is no team <code>b</code> that is stronger than team <code>a</code>.</p>

<p>Return <em>the team that will be the champion of the tournament.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1],[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There are two teams in this tournament.
grid[0][1] == 1 means that team 0 is stronger than team 1. So team 0 will be the champion.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1],[1,0,1],[0,0,0]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There are three teams in this tournament.
grid[1][0] == 1 means that team 1 is stronger than team 0.
grid[1][2] == 1 means that team 1 is stronger than team 2.
So team 1 will be the champion.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>For all <code>i grid[i][i]</code> is <code>0.</code></li>
	<li>For all <code>i, j</code> that <code>i != j</code>, <code>grid[i][j] != grid[j][i]</code>.</li>
	<li>The input is generated such that if team <code>a</code> is stronger than team <code>b</code> and team <code>b</code> is stronger than team <code>c</code>, then team <code>a</code> is stronger than team <code>c</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-difference-between-sum-of-diagonals1554/1" target="_blank" rel="noopener noreferrer">Find difference between sum of diagonals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a matrix Grid[][]&nbsp;of size NxN. Calculate the absolute difference between the sums of its diagonals.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3
Grid=[[1,2,3],[4,5,6],[7,8,9]]
<strong>Output: </strong>
0
<strong>Explanation:</strong>
Sum of primary diagonal = 1+5+9 = 15.
Sum of secondary diagonal = 3+5+7 = 15.
Difference = |15 - 15| = 0.</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3
Grid=[[1,1,1],[1,1,1],[1,1,1]]
<strong>Output:</strong>
0
<strong>Explanation:</strong>
Sum of primary diagonal = 1+1+1=3.
Sum of secondary diagonal = 1+1+1=3.
Difference = |3-3| = 0.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything.Your task is to complete the function <strong>diagonalSumDifference()</strong> which takes an integer N and a 2D array Grid as input parameters and returns the absolutes difference between the sums of its diagonals.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N)<br />
<strong>Expected Auxillary Space:</strong>O(1)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N&lt;=1000<br />
-1000&lt;=Grid[i][j]&lt;=1000, for 0&lt;=i,j</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-duplicate-rows-in-a-binary-matrix/1" target="_blank" rel="noopener noreferrer">Find duplicate rows in a binary matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>boolean</strong> matrix of size <strong>RxC</strong> where each cell contains either 0 or 1, find the row numbers&nbsp;</span><span style="font-size: 18px;">(0-based)</span><span style="font-size: 18px;">&nbsp;of row which already exists or are repeated.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
R = 2, C = 2
matrix[][] = {{1, 0},
            {1, 0}}
<strong>Output: </strong>
1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong>
Row 1 is duplicate of Row 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
R = 4, C = 3
matrix[][] = {{ 1, 0, 0},
            { 1, 0, 0},
            { 0, 0, 0},
            { 0, 0, 0}}</span>
<span style="font-size: 18px;"><strong>Output: </strong>
</span><span style="font-size: 18px;">1 3</span> 
<span style="font-size: 18px;"><strong>Explanation:</strong>
Row 1 and Row 3 are duplicates of Row 0 and 2 respectively. </span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You dont need to read input or print anything. Complete the function <strong>repeatedRows()</strong> that takes the matrix as input parameter and returns a list of row numbers which are duplicate rows.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(R * C)<br /><strong>Expected Auxiliary Space:</strong> O(R * C) </span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; R, C &le; 10<sup>3</sup></span><br /><span style="font-size: 18px;">0 &le; matrix[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-nth-element-of-spiral-matrix/1" target="_blank" rel="noopener noreferrer">Find kth element of spiral matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix with <strong>n</strong> rows and <strong>m </strong>columns. Your task is to find the <strong>kth</strong> element which is obtained while traversing the matrix spirally. You need to complete the method<strong> findK</strong>&nbsp;which takes four arguments the first argument is the matrix <strong>A </strong>and the next two arguments will be <strong>n </strong>and <strong>m </strong>denoting the size of the matrix A and then the forth argument is an integer <strong>k</strong>. The function will return the kth element obtained while traversing the matrix spirally.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1</strong></span><span style="font-size: 18px;"><strong>:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>n = 4, m = 4, k = 10
A[][] = {{1  2  3  4},
&nbsp;        {5  6  7  8},
&nbsp;        {9  10 11 12},<br />         {13 14 15 16}}
<strong>Output:
</strong>13<strong>
Explanation:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/700274/Web/Other/blobid0_1687070632.png" alt="" />
The spiral order of matrix will look like 1-&gt;2-&gt;3-&gt;4-&gt;8-&gt;12-&gt;16-&gt;15-&gt;14-&gt;13-&gt;9-&gt;5-&gt;6-&gt;7-&gt;11-&gt;10. So the 10th element in this order is 13. </span></pre>
<p><span style="font-size: 18px;"><strong>Example 2</strong></span><span style="font-size: 18px;"><strong>:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>n = 3, m = 3, k = 4
A[][] = {{1 2 3},
&nbsp;        {4 5 6},
&nbsp;        {7 8 9}}
<strong>Output:
</strong>6<strong>
Explanation:</strong>
The spiral order of matrix will look like 1-&gt;2-&gt;3-&gt;6-&gt;9-&gt;8-&gt;7-&gt;4-&gt;5. So the 4th element in this order is 6.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You only need to implement the given function&nbsp;<strong>findK()</strong>. Do not read input, instead use the arguments given in the function. Return the K'th element obtained by traversing matrix spirally.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n*m)<br /><strong>Expected Auxiliary Space:</strong> O(n*m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=n,m&lt;=10<sup>3</sup><br />1&lt;=k&lt;=n*m<br />-10<sup>9</sup> &lt;= A[i][j] &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-kth-largest-xor-coordinate-value/description" target="_blank" rel="noopener noreferrer">Find Kth Largest XOR Coordinate Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">quickselect</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D <code>matrix</code> of size <code>m x n</code>, consisting of non-negative integers. You are also given an integer <code>k</code>.</p>

<p>The <strong>value</strong> of coordinate <code>(a, b)</code> of the matrix is the XOR of all <code>matrix[i][j]</code> where <code>0 &lt;= i &lt;= a &lt; m</code> and <code>0 &lt;= j &lt;= b &lt; n</code> <strong>(0-indexed)</strong>.</p>

<p>Find the <code>k<sup>th</sup></code> largest value <strong>(1-indexed)</strong> of all the coordinates of <code>matrix</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 1
<strong>Output:</strong> 7
<strong>Explanation:</strong> The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 2
<strong>Output:</strong> 5
<strong>Explanation:</strong> The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[5,2],[1,6]], k = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds <strong>after</strong> which the room opens and can be moved to. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between adjacent rooms takes <em>exactly</em> one second.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0],[0,0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 3 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in one second.</li>
	<li>At time <code>t == 2</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 50</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 50</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a two-dimensional array of size <span class="math inline">\(n \times m\)</span>, and the task is to find the shortest time required to move from position <span class="math inline">\((0, 0)\)</span> to position <span class="math inline">\((n - 1, m - 1)\)</span>. While moving, one can go to any of the four adjacent positions (up, down, left, right), and each position has an associated earliest move time, meaning one can only move to that position after that time.</p>
<p>Therefore, the two-dimensional array can be regarded as an undirected graph of size <span class="math inline">\(n \times m\)</span>, where the position <span class="math inline">\((i, j)\)</span> has undirected edges connecting it to <span class="math inline">\((i - 1, j)\)</span>, <span class="math inline">\((i + 1, j)\)</span>, <span class="math inline">\((i, j - 1)\)</span>, and <span class="math inline">\((i, j + 1)\)</span>. We are required to find the shortest path from <span class="math inline">\((0, 0)\)</span> to <span class="math inline">\((n - 1, m - 1)\)</span>.</p>
<p>There are many algorithms for finding the shortest path, and here we choose Dijkstra's algorithm. You can refer to the editorial of <a href="https://leetcode.com/problems/network-delay-time/editorial/">743. Network Delay Time</a> to understand the basic process of Dijkstra's algorithm.</p>
<p>Unlike the standard Dijkstra algorithm, in this problem we define <span class="math inline">\(d[i][j]\)</span> to represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. The time to move from <span class="math inline">\((i, j)\)</span> to an adjacent coordinate <span class="math inline">\((u, v)\)</span> is given by <span class="math inline">\(\max(d[i][j], \textit{moveTime}[u][v]) + 1\)</span>. The rest of the process is consistent with Dijkstra's algorithm.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3gwDjz6F/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, so the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/description" target="_blank" rel="noopener noreferrer">Find Minimum Time to Reach Last Room II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a dungeon with <code>n x m</code> rooms arranged as a grid.</p>

<p>You are given a 2D array <code>moveTime</code> of size <code>n x m</code>, where <code>moveTime[i][j]</code> represents the <strong>minimum</strong> time in seconds when you can <strong>start moving</strong> to that room. You start from the room <code>(0, 0)</code> at time <code>t = 0</code> and can move to an <strong>adjacent</strong> room. Moving between <strong>adjacent</strong> rooms takes one second for one move and two seconds for the next, <strong>alternating</strong> between the two.</p>

<p>Return the <strong>minimum</strong> time to reach the room <code>(n - 1, m - 1)</code>.</p>

<p>Two rooms are <strong>adjacent</strong> if they share a common wall, either <em>horizontally</em> or <em>vertically</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,4],[4,4]]</span></p>

<p><strong>Output:</strong> 7</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 7 seconds.</p>

<ul>
	<li>At time <code>t == 4</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 5</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,0,0,0],[0,0,0,0]]</span></p>

<p><strong>Output:</strong> 6</p>

<p><strong>Explanation:</strong></p>

<p>The minimum time required is 6 seconds.</p>

<ul>
	<li>At time <code>t == 0</code>, move from room <code>(0, 0)</code> to room <code>(1, 0)</code> in one second.</li>
	<li>At time <code>t == 1</code>, move from room <code>(1, 0)</code> to room <code>(1, 1)</code> in two seconds.</li>
	<li>At time <code>t == 3</code>, move from room <code>(1, 1)</code> to room <code>(1, 2)</code> in one second.</li>
	<li>At time <code>t == 4</code>, move from room <code>(1, 2)</code> to room <code>(1, 3)</code> in two seconds.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">moveTime = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> 4</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == moveTime.length &lt;= 750</code></li>
	<li><code>2 &lt;= m == moveTime[i].length &lt;= 750</code></li>
	<li><code>0 &lt;= moveTime[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-shortest-path--dijkstra">Approach: Shortest Path + Dijkstra</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem is an extended version of <a href="https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description/">3341. Find Minimum Time to Reach Last Room I</a>. The key difference is that the time required for each move alternate: the first move takes 1 second, the second move takes 2 seconds, the third move takes 1 second, and so on.</p>
<p>Since the movement occurs on a two-dimensional grid, each move changes the coordinates <span class="math inline">\((i, j)\)</span> by exactly 1 in one of the four directions. As a result, the parity of <span class="math inline">\((i + j)\)</span> changes with every move. This allows us to determine the move's parity directly based on the current coordinates.</p>
<p>Let <span class="math inline">\(d[i][j]\)</span> represent the shortest time required to reach <span class="math inline">\((i, j)\)</span> from <span class="math inline">\((0, 0)\)</span>. Then, the time to move from <span class="math inline">\((i, j)\)</span> to an adjacent cell <span class="math inline">\((u, v)\)</span> is given by:</p>
<p><span class="math display">\[\max(d[i][j], \textit{moveTime}[u][v]) + (i + j) \bmod 2 + 1.
\]</span></p>
<p>Additionally, since reaching <span class="math inline">\((n - 1, m - 1)\)</span> is guaranteed, we can optimize the algorithm by checking within the main loop whether the current point is <span class="math inline">\((n - 1, m - 1)\)</span>. If it is, we can exit early to avoid unnecessary computations for other cells.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ar24ZbDa/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in <span class="math inline">\(\textit{moveTime}\)</span>, respectively.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(nm \log(nm))\)</span>.</li>
</ul>
<p>There are <span class="math inline">\(nm\)</span> points and <span class="math inline">\(O(nm)\)</span> edges. We implement Dijkstra's algorithm using a min-heap, performing at most <span class="math inline">\(O(nm)\)</span> insertions and deletions. Since each heap operation takes <span class="math inline">\(O(\log(nm))\)</span> time, the overall time complexity is <span class="math inline">\(O(nm \log(nm))\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(nm)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-missing-and-repeated-values/description" target="_blank" rel="noopener noreferrer">Find Missing and Repeated Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer matrix <code><font face="monospace">grid</font></code> of size <code>n * n</code> with values in the range <code>[1, n<sup>2</sup>]</code>. Each integer appears <strong>exactly once</strong> except <code>a</code> which appears <strong>twice</strong> and <code>b</code> which is <strong>missing</strong>. The task is to find the repeating and missing numbers <code>a</code> and <code>b</code>.</p>

<p>Return <em>a <strong>0-indexed </strong>integer array </em><code>ans</code><em> of size </em><code>2</code><em> where </em><code>ans[0]</code><em> equals to </em><code>a</code><em> and </em><code>ans[1]</code><em> equals to </em><code>b</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,3],[2,2]]
<strong>Output:</strong> [2,4]
<strong>Explanation:</strong> Number 2 is repeated and number 4 is missing so the answer is [2,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[9,1,7],[8,9,2],[3,4,6]]
<strong>Output:</strong> [9,5]
<strong>Explanation:</strong> Number 9 is repeated and number 5 is missing so the answer is [9,5].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == grid.length == grid[i].length &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= n * n</code></li>
	<li>For all <code>x</code> that <code>1 &lt;= x &lt;= n * n</code> there is exactly one <code>x</code> that is not equal to any of the grid members.</li>
	<li>For all <code>x</code> that <code>1 &lt;= x &lt;= n * n</code> there is exactly one <code>x</code> that is equal to exactly two of the grid members.</li>
	<li>For all <code>x</code> that <code>1 &lt;= x &lt;= n * n</code> except two of them there is exactly one pair of <code>i, j</code> that <code>0 &lt;= i, j &lt;= n - 1</code> and <code>grid[i][j] == x</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-hash-map">Approach 1: Hash Map</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a grid containing integers ranging from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span> with the following rules:</p>
<ol>
<li>One number is repeated twice.</li>
<li>One number from the range is missing in the input.</li>
<li>All other numbers occur exactly once.</li>
</ol>
<p>Our task is to find both the repeated number and the missing number in the grid. The most straightforward way to do this is to count how many times each number appears. The number that appears twice is the repeated number, while the number that does not appear at all is the missing one. But how can we efficiently count occurrences without excessive searching?</p>
<p>A hash map is a perfect tool for this task because it allows us to store and retrieve counts efficiently. Since each number can be associated with its count, we can map each integer to its frequency using a hash map. Fetching and updating values in a hash map happens in constant time on average, which makes it well-suited for this problem.</p>
<p>To implement this, we start by creating a hash map called <code>freq</code> to store the frequency of each number in the grid. We then iterate through the grid, updating the count for each number as we encounter it. Once we finish scanning the grid, we have a complete record of how many times each number appears.</p>
<p>Next, we loop through all numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span> and check their frequencies in <code>freq</code>. If a number has a count of <code>2</code>, it is the repeated number. If a number does not exist in the map, it is the missing number. Once we identify both, we return them as our final answer.</p>
<p>The slideshow below demonstrates the algorithm in action:</p>
<p>!?!../Documents/2965/slideshow.json:604,1082!?!</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>n</code> to store the length of the <code>grid</code>.</li>
<li><code>missing</code> and <code>repeat</code> to <code>-1</code>.</li>
</ul>
</li>
<li>Initialize a frequency map <code>freq</code> to track the count of each number in the <code>grid</code>.</li>
<li>For each <code>row</code> in the <code>grid</code>:
<ul>
<li>For each number in the <code>row</code>:
<ul>
<li>Add the number to <code>freq</code> or increment its count if already present.</li>
</ul>
</li>
</ul>
</li>
<li>For each <code>num</code> from <code>1</code> to <code>n * n</code> (inclusive):
<ul>
<li>If <code>num</code> is not present in the frequency map:
<ul>
<li>Set <code>missing</code> to <code>num</code>.</li>
</ul>
</li>
<li>If <code>num</code> appears twice in the frequency map:
<ul>
<li>Set <code>repeat</code> to <code>num</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return an array containing the repeated and missing numbers.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/WEb2C5Zo/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the side length of the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm makes two main passes. First, we iterate through each cell in our <span class="math inline">\(n \times n\)</span> grid to build the frequency map, which takes <span class="math inline">\(O(n^2)\)</span> operations. Then, we iterate through numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span> to find our missing and repeated values, which takes <span class="math inline">\(O(n^2)\)</span> operations. Since both passes are sequential and take <span class="math inline">\(O(n^2)\)</span> time, our overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a hash map to store the frequency of each number. The map will store all unique numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span> except the missing number, making the space complexity <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-math">Approach 2: Math</h3>
<h4 id="intuition-1">Intuition</h4>
<p>At first glance, this problem might seem to require tracking frequencies, but there's a more elegant mathematical approach. In a perfect sequence from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span>, every number appears exactly once. However, in our given sequence, one number appears twice, and another number is missing. Letâ€™s define the repeated number as <span class="math inline">\(x\)</span> and the missing number as <span class="math inline">\(y\)</span>.</p>
<p>Instead of explicitly counting occurrences, we can leverage basic mathematical properties of numbers. The sum of all numbers in a proper sequence from <span class="math inline">\(1\)</span> to <span class="math inline">\(n^2\)</span> can be computed using the formula:</p>
<p><span class="math display">\[\begin{aligned}
    \text{perfectSum} = \frac{n^2 \cdot (n^2 + 1)}{2}
\end{aligned}
\]</span></p>
<p>Similarly, the sum of the squares of these numbers follows this formula:</p>
<p><span class="math display">\[\begin{aligned}
    \text{perfectSqrSum} = \frac{n^2 \cdot (n^2 + 1) \cdot (2n^2 + 1)}{6}
\end{aligned}
\]</span></p>
<p>Now, if we compute the sum of numbers in our given grid (<span class="math inline">\(\text{sum}\)</span>) and compare it with <span class="math inline">\(\text{perfectSum}\)</span>, we can express their relationship as:</p>
<p><span class="math display">\[\begin{aligned}
    \text{sum} = \text{perfectSum} + x - y
\end{aligned}
\]</span></p>
<p>This tells us that the difference between the actual sum and the perfect sum gives us:</p>
<p><span class="math display">\[\begin{aligned}
    \text{sumDiff} = x - y
\end{aligned}
\]</span></p>
<p>Similarly, if we compute the sum of squares from our grid (<span class="math inline">\(\text{sqrSum}\)</span>) and compare it with <span class="math inline">\(\text{perfectSqrSum}\)</span>, we get:</p>
<p><span class="math display">\[\begin{aligned}
    \text{sqrDiff} = x^2 - y^2
\end{aligned}
\]</span></p>
<p>Now, we recall a fundamental algebraic identity:</p>
<p><span class="math display">\[\begin{aligned}
x^2 - y^2 = (x + y) \cdot (x - y)
\end{aligned}
\]</span></p>
<p>Since we already know <span class="math inline">\(x - y\)</span> from <span class="math inline">\(\text{sumDiff}\)</span>, we can substitute it into the equation:</p>
<p><span class="math display">\[\begin{aligned}
    \text{sqrDiff} = (x + y) \cdot \text{sumDiff}
\end{aligned}
\]</span></p>
<p>Rearranging this equation, we can solve for <span class="math inline">\(x + y\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
x + y = \frac{\text{sqrDiff}}{\text{sumDiff}}
\end{aligned}
\]</span></p>
<p>Now, we have two simple equations:</p>
<p><span class="math display">\[\begin{aligned}
x - y = \text{sumDiff}
\end{aligned}
\]</span></p>
<p><span class="math display">\[\begin{aligned}
x + y = \frac{\text{sqrDiff}}{\text{sumDiff}}
\end{aligned}
\]</span></p>
<p>Solving for <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
x = \frac{\text{sqrDiff}/\text{sumDiff} + \text{sumDiff}}{2}
\end{aligned}
\]</span></p>
<p><span class="math display">\[\begin{aligned}
y = \frac{\text{sqrDiff}/\text{sumDiff} - \text{sumDiff}}{2}
\end{aligned}
\]</span></p>
<p>This mathematical derivation translates directly into our code. We first calculate the actual sums from our grid and then compute the perfect sums using the formulas. The differences between these give us <span class="math inline">\(\text{sumDiff}\)</span> and <span class="math inline">\(\text{squareDifference}\)</span>, which we can plug into our final formulas to get the repeating and missing numbers.</p>
<blockquote>
<p>Note: One important implementation detail is the use of long instead of int for our calculations. This is crucial because when we're dealing with squares of numbers, we can easily exceed the integer range.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>sum</code> and <code>sqrSum</code> to <code>0</code> to store the actual sums from the <code>grid</code>.</li>
<li><code>n</code> to store the length of the <code>grid</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>total</code> to <code>n * n</code> to store the total number of elements.</li>
<li>For each <code>row</code> in the <code>grid</code>:
<ul>
<li>For each <code>col</code> in the <code>grid</code>:
<ul>
<li>Add the current element to <code>sum</code>.</li>
<li>Add the square of the current element to <code>sqrSum</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Calculate the <code>sumDiff</code> by subtracting the expected sum <code>(total * (total + 1) / 2)</code> from the actual <code>sum</code>.</li>
<li>Calculate the <code>sqrDiff</code> by subtracting the expected square sum <code>(total * (total + 1) * (2 * total + 1) / 6)</code> from the actual <code>sqrSum</code>.</li>
<li>Calculate <code>repeat</code> using the formula <code>(sqrDiff / sumDiff + sumDiff) / 2</code>.</li>
<li>Calculate <code>missing</code> using the formula <code>(sqrDiff / sumDiff - sumDiff) / 2</code>.</li>
<li>Return an array containing <code>repeat</code> and <code>missing</code> numbers.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4AW4BmW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the side length of the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm iterates through each cell in the <span class="math inline">\(n \times n\)</span> grid exactly once using two nested loops. All other operations (calculating sums, differences, and the final values) are constant time operations. Therefore, the total time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses a constant amount of extra space to store variables (<code>sum</code>, <code>sqrSum</code>, <code>n</code>, <code>total</code>, <code>sumDiff</code>, <code>sqrDiff</code>) regardless of the input size. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-number-of-closed-islands/1" target="_blank" rel="noopener noreferrer">Find number of closed islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <a href="https://www.geeksforgeeks.org/program-to-check-if-a-matrix-is-binary-matrix-or-not/">binary matrix</a> <strong>mat[][]</strong> of dimensions <strong>NxM</strong> such that 1 denotes land and <strong>0</strong> denotes water. Find the number of closed islands in the given matrix.<br />An island is a 4-directional(up,right,down and left) connected part of 1's.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> A closed island is a group of <strong>1s</strong> surrounded by only <strong>0s</strong> on all the boundaries <strong>(except diagonals)</strong>. In simple words, a closed island is an island whose none of the <strong>1s</strong> lie on the edges of the matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 5, M = 8
mat[][] =</span> <span style="font-size: 18px;">{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 0, 1},&nbsp;
           {0, 1, 0, 1, 0, 0, 0, 1},&nbsp;
           {0, 1, 1, 1, 1, 0, 1, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output:</strong>
2
<strong>Explanation</strong>:
</span><span style="font-size: 18px;">mat[][] =&nbsp;{{0, 0, 0, 0, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, 0, 1},&nbsp;
           {0, <strong>1</strong>, 0, <strong>1</strong>, 0, 0, 0, 1},&nbsp;
           {0, <strong>1, 1, 1, 1, </strong>0, <strong>1</strong>, 0},&nbsp;
           {1, 0, 0, 0, 0, 1, 0, 1}}&nbsp;
There are 2 closed islands. The islands in dark are closed because they are completely surrounded by 0s (water). There are two more islands in the last column of the matrix, but they are not completely surrounded by 0s. Hence they are not closed islands. </span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">N = 3, M = 3
mat[][] = {{1, 0, 0},
           {0, 1, 0},
           {0, 0, 1}}</span>
<span style="font-size: 18px;"><strong>Output: <br /></strong></span><span style="font-size: 18px;">1<strong><br />Explanation:<br /></strong>mat[][] = {{1, 0, 0},<br />          {0, <strong>1</strong>, 0},<br />          {0, 0, 1}}<br />There is just a one closed island.</span></pre>
<p><span style="font-size: 18px;"><strong>Your task:</strong></span><br /><span style="font-size: 18px;">You dont need to read input or print anything. Your task is to complete the function <strong>closedIslands()</strong>&nbsp;which takes two integers N and M, and a 2D binary matrix mat as input parameters and returns the number of closed islands.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(N*M)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; N,M &le; 500<br /><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-perimeter-of-shapes/1" target="_blank" rel="noopener noreferrer">Find perimeter of shapes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">geometric</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:20px">Given a matrix mat[][] of n&nbsp;rows and m&nbsp;columns, consisting of 0&rsquo;s and 1&rsquo;s. The task is to complete the function <strong>findPerimeter</strong> which returns an integer denoting the&nbsp;perimeter of sub-figures consisting of only 1&rsquo;s in the matrix.<br />
<br />
For example<br />
Perimeter of single 1 is 4 as it can be covered from all 4 side. Perimeter of double 11 is 6.</span></p>

<pre>
<span style="font-size:20px"><u>       </u>             <u>   </u> <u>    </u>
|  1  |           |  1    1  |
<u>       </u>             <u>   </u> <u>    </u></span></pre>

<p><br />
<span style="font-size:20px"><strong>Input:</strong><br />
The first line of input contains an integer T denoting the no of test cases. Then T test cases follow. The first line of each test case contains two space separated n and m denoting the size of the matrix mat[][] . Then in the next line&nbsp;are n*m&nbsp;space separated values of the matrix.<br />
<br />
<strong>Output:</strong><br />
For each test case in a new line print the perimeter of sub-figure consisting only 1&rsquo;s in the matrix.<br />
<br />
<strong>Constraints:</strong><br />
1&lt;=T&lt;=100<br />
1&lt;=n, m&lt;=20<br />
<br />
<strong>Example(To be used for expected output):<br />
Input:</strong><br />
2<br />
1 2<br />
1 1&nbsp;<br />
3 3<br />
1 0 0 1 0 0 1 0 0<br />
<br />
<strong>Output:</strong><br />
6<br />
8</span><br />
<br />
<span style="font-size:16px"><strong>Note:</strong>The <strong>Input/Ouput</strong> format and <strong>Example</strong> given are used for system&#39;s internal purpose, and should be used by a user for <strong>Expected Output</strong> only. As it is a function problem, hence a user should not read any input from stdin/console. The task is to complete the function specified, and not to write the full code.</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-rectangle-with-corners-as-1--141631/1" target="_blank" rel="noopener noreferrer">Find rectangle with corners as 1</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an&nbsp;<strong><code data-start="97" data-end="104">n x m</code></strong>&nbsp;binary matrix&nbsp;<strong><code data-start="119" data-end="124">mat[][]</code></strong>&nbsp;containing only 0s and 1s, determine if there exists a rectangle within the matrix such that all four corners of the rectangle are 1. If such a rectangle exists, return&nbsp;<strong><code data-start="294" data-end="300" data-is-only-node="">true</code></strong>; otherwise, return&nbsp;<strong><code data-start="320" data-end="327">false</code></strong>.</span></p>
<p><strong><span style="font-size: 18px;">Example:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] =<br />[[1, 0, 0, 1, 0],
[0, 0, <span style="color: #ff0000;">1,</span> 0, <span style="color: #ff0000;">1]</span>,
[0, 0, 0, 1, 0], 
[1, 0, <span style="color: #ff0000;">1,</span> 0, <span style="color: #ff0000;">1]</span>] </span>
<span style="font-size: 18px;"><strong>Output</strong>: true
<strong>Explanation: </strong>Valid corners are at index (1,2), (1,4), (3,2), (3,4) </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] =<br />[[0, 0, 0],
[0, 0, 0],
[0, 0, 0]]
<strong>Output: </strong>false<br /><strong>Explanation: </strong>There are no valid corners.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n, m &lt;= 200<br />0 &lt;= mat[i] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-grid-of-region-average/description" target="_blank" rel="noopener noreferrer">Find the Grid of Region Average</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>m x n</code> grid <code>image</code> which represents a grayscale image, where <code>image[i][j]</code> represents a pixel with intensity in the range <code>[0..255]</code>. You are also given a <strong>non-negative</strong> integer <code>threshold</code>.</p>

<p>Two pixels are <strong>adjacent</strong> if they share an edge.</p>

<p>A <strong>region</strong> is a <code>3 x 3</code> subgrid where the <strong>absolute difference</strong> in intensity between any two <strong>adjacent</strong> pixels is <strong>less than or equal to</strong> <code>threshold</code>.</p>

<p>All pixels in a region belong to that region, note that a pixel can belong to <strong>multiple</strong> regions.</p>

<p>You need to calculate a <code>m x n</code> grid <code>result</code>, where <code>result[i][j]</code> is the <strong>average</strong> intensity of the regions to which <code>image[i][j]</code> belongs, <strong>rounded down</strong> to the nearest integer. If <code>image[i][j]</code> belongs to multiple regions, <code>result[i][j]</code> is the <strong>average </strong>of the<strong> rounded-down average </strong>intensities of these regions, <strong>rounded down</strong> to the nearest integer. If <code>image[i][j]</code> does<strong> not</strong> belong to any region, <code>result[i][j]</code> is <strong>equal to</strong> <code>image[i][j]</code>.</p>

<p>Return the grid <code>result</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[[9,9,9,9],[9,9,9,9],[9,9,9,9]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/12/21/example0corrected.png" style="width: 832px; height: 275px;" /></p>

<p>There are two regions as illustrated above. The average intensity of the first region is 9, while the average intensity of the second region is 9.67 which is rounded down to 9. The average intensity of both of the regions is (9 + 9) / 2 = 9. As all the pixels belong to either region 1, region 2, or both of them, the intensity of every pixel in the result is 9.</p>

<p>Please note that the rounded-down values are used when calculating the average of multiple regions, hence the calculation is done using 9 as the average intensity of region 2, not 9.67.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2023/12/21/example1corrected.png" /></p>

<p>There are two regions as illustrated above. The average intensity of the first region is 25, while the average intensity of the second region is 30. The average intensity of both of the regions is (25 + 30) / 2 = 27.5 which is rounded down to 27.</p>

<p>All the pixels in row 0 of the image belong to region 1, hence all the pixels in row 0 in the result are 25. Similarly, all the pixels in row 3 in the result are 30. The pixels in rows 1 and 2 of the image belong to region 1 and region 2, hence their assigned value is 27 in the result.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[[5,6,7],[8,9,10],[11,12,13]]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is only one <code>3 x 3</code> subgrid, while it does not have the condition on difference of adjacent pixels, for example, the difference between <code>image[0][0]</code> and <code>image[1][0]</code> is <code>|5 - 8| = 3 &gt; threshold = 1</code>. None of them belong to any valid regions, so the <code>result</code> should be the same as <code>image</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n, m &lt;= 500</code></li>
	<li><code>0 &lt;= image[i][j] &lt;= 255</code></li>
	<li><code>0 &lt;= threshold &lt;= 255</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/description" target="_blank" rel="noopener noreferrer">Find the Kth Smallest Sum of a Matrix With Sorted Rows</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>mat</code> that has its rows sorted in non-decreasing order and an integer <code>k</code>.</p>

<p>You are allowed to choose <strong>exactly one element</strong> from each row to form an array.</p>

<p>Return <em>the </em><code>k<sup>th</sup></code><em> smallest array sum among all possible arrays</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,3,11],[2,4,6]], k = 5
<strong>Output:</strong> 7
<strong>Explanation:</strong> Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,3,11],[2,4,6]], k = 9
<strong>Output:</strong> 17
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
<strong>Output:</strong> 9
<strong>Explanation:</strong> Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat.length[i]</code></li>
	<li><code>1 &lt;= m, n &lt;= 40</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
	<li><code>1 &lt;= k &lt;= min(200, n<sup>m</sup>)</code></li>
	<li><code>mat[i]</code> is a non-decreasing array.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-maximum-number-of-fruits-collected/description" target="_blank" rel="noopener noreferrer">Find the Maximum Number of Fruits Collected</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a game dungeon comprised of&nbsp;<code>n x n</code> rooms arranged in a grid.</p>

<p>You are given a 2D array <code>fruits</code> of size <code>n x n</code>, where <code>fruits[i][j]</code> represents the number of fruits in the room <code>(i, j)</code>. Three children will play in the game dungeon, with <strong>initial</strong> positions at the corner rooms <code>(0, 0)</code>, <code>(0, n - 1)</code>, and <code>(n - 1, 0)</code>.</p>

<p>The children will make <strong>exactly</strong> <code>n - 1</code> moves according to the following rules to reach the room <code>(n - 1, n - 1)</code>:</p>

<ul>
	<li>The child starting from <code>(0, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j + 1)</code>, <code>(i + 1, j)</code>, and <code>(i, j + 1)</code> if the target room exists.</li>
	<li>The child starting from <code>(0, n - 1)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, and <code>(i + 1, j + 1)</code> if the target room exists.</li>
	<li>The child starting from <code>(n - 1, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i - 1, j + 1)</code>, <code>(i, j + 1)</code>, and <code>(i + 1, j + 1)</code> if the target room exists.</li>
</ul>

<p>When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.</p>

<p>Return the <strong>maximum</strong> number of fruits the children can collect from the dungeon.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]</span></p>

<p><strong>Output:</strong> <span class="example-io">100</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/08/07/clideo_editor_d0b446db9ba448e1a3fcdd0eecdb58d0-ezgifcom-crop.gif" style="width: 250px; height: 210px;" /></p>

<p>In this example:</p>

<ul>
	<li>The 1<sup>st</sup> child (green) moves on the path <code>(0,0) -&gt; (1,1) -&gt; (2,2) -&gt; (3, 3)</code>.</li>
	<li>The 2<sup>nd</sup> child (red) moves on the path <code>(0,3) -&gt; (1,2) -&gt; (2,3) -&gt; (3, 3)</code>.</li>
	<li>The 3<sup>rd</sup> child (blue) moves on the path <code>(3,0) -&gt; (3,1) -&gt; (3,2) -&gt; (3, 3)</code>.</li>
</ul>

<p>In total they collect <code>1 + 6 + 11 + 16 + 4 + 8 + 12 + 13 + 14 + 15 = 100</code> fruits.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">fruits = [[1,1],[1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>In this example:</p>

<ul>
	<li>The 1<sup>st</sup> child moves on the path <code>(0,0) -&gt; (1,1)</code>.</li>
	<li>The 2<sup>nd</sup> child moves on the path <code>(0,1) -&gt; (1,1)</code>.</li>
	<li>The 3<sup>rd</sup> child moves on the path <code>(1,0) -&gt; (1,1)</code>.</li>
</ul>

<p>In total they collect <code>1 + 1 + 1 + 1 = 4</code> fruits.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == fruits.length == fruits[i].length &lt;= 1000</code></li>
	<li><code>0 &lt;= fruits[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-dynamic-programming">Approach: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Firstly, since the child starting from <span class="math inline">\((0,0)\)</span> can only move <span class="math inline">\(n-1\)</span> times, he can only walk along the main diagonal. Therefore, we only need to calculate the maximum total number of fruits collected by the remaining two children.</p>
<p>For the child starting from the upper-right corner <span class="math inline">\((0, n-1)\)</span>, it's easy to see that he can only move above the main diagonal and cannot cross it; otherwise, he wonâ€™t be able to reach the lower-right corner in exactly <span class="math inline">\(n-1\)</span> moves. The same constraint applies to the other child starting from the lower-left corner <span class="math inline">\((n-1, 0)\)</span>.</p>
<p>Since the three children are not allowed to enter the same room, we only need to consider one of these two diagonal-symmetric cases. We can use dynamic programming to compute the maximum fruits collected along one valid path. Then, by flipping the matrix along the main diagonal, we can reuse the same logic to compute the other path. This transforms the problem into:</p>
<ul>
<li>Starting from the top-right corner <span class="math inline">\((0, n-1)\)</span>, without passing through the main diagonal, find the maximum number of fruits that can be collected by the time the child reaches room <span class="math inline">\((n-2, n-1)\)</span>.</li>
</ul>
<p>This can be solved using dynamic programming. Let <span class="math inline">\(\textit{dp}[i][j]\)</span> represent the maximum number of fruits that can be collected when reaching room <span class="math inline">\((i, j)\)</span>. For <span class="math inline">\(1 \leq i < n-1\)</span> and <span class="math inline">\(1 < j < n\)</span>, we define the recurrence as</p>
<p><span class="math display">\[\textit{dp}[i][j] = \max(\textit{dp}[i-1][j-1],\ \textit{dp}[i-1][j],\ \textit{dp}[i-1][j+1]) + \textit{fruits}[i][j].
\]</span></p>
<p>Since the destination is <span class="math inline">\((n-2, n-1)\)</span>, and every step moves the child downward (increasing <span class="math inline">\(i\)</span>), the column index <span class="math inline">\(j\)</span> is always greater than <span class="math inline">\(i\)</span>. So we can initialize <span class="math inline">\(j\)</span> to start from <span class="math inline">\(\max(n-1-i,\ i+1)\)</span> at each row.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/QAGUp2fg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the 2D grid <span class="math inline">\(\textit{fruits}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The dynamic programming required to calculate the contribution of the upper triangular area takes <span class="math inline">\(O(n^2)\)</span> time.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We use a rolling array to optimize the space complexity from <span class="math inline">\(O(n^2)\)</span> to <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i/description" target="_blank" rel="noopener noreferrer">Find the Minimum Area to Cover All Ones I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D <strong>binary</strong> array <code>grid</code>. Find a rectangle with horizontal and vertical sides with the<strong> smallest</strong> area, such that all the 1&#39;s in <code>grid</code> lie inside this rectangle.</p>

<p>Return the <strong>minimum</strong> possible area of the rectangle.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1,0],[1,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/08/examplerect0.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 279px; height: 198px;" /></p>

<p>The smallest rectangle has a height of 2 and a width of 3, so it has an area of <code>2 * 3 = 6</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0],[0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/08/examplerect1.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 204px; height: 201px;" /></p>

<p>The smallest rectangle has both height and width 1, so its area is <code>1 * 1 = 1</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 1000</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
	<li>The input is generated such that there is at least one 1 in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-one-time-traversal">Approach: One-time Traversal</h3>
<h4 id="intuition">Intuition</h4>
<p>During traversal, we need to find the upper, lower, left, and right boundaries where <span class="math inline">\(1\)</span> appears. Once the boundaries are identified, we calculate the minimum area they enclose.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kSgEeDrC/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <span class="math inline">\(\textit{grid}\)</span>, and <span class="math inline">\(m\)</span> be the number of columns in <span class="math inline">\(\textit{grid}[0]\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>We traverse the entire matrix once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>Only a few additional variables are needed.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-ii/description" target="_blank" rel="noopener noreferrer">Find the Minimum Area to Cover All Ones II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D <strong>binary</strong> array <code>grid</code>. You need to find 3 <strong>non-overlapping</strong> rectangles having <strong>non-zero</strong> areas with horizontal and vertical sides such that all the 1&#39;s in <code>grid</code> lie inside these rectangles.</p>

<p>Return the <strong>minimum</strong> possible sum of the area of these rectangles.</p>

<p><strong>Note</strong> that the rectangles are allowed to touch.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,1],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/14/example0rect21.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 280px; height: 198px;" /></p>

<ul>
	<li>The 1&#39;s at <code>(0, 0)</code> and <code>(1, 0)</code> are covered by a rectangle of area 2.</li>
	<li>The 1&#39;s at <code>(0, 2)</code> and <code>(1, 2)</code> are covered by a rectangle of area 2.</li>
	<li>The 1 at <code>(1, 1)</code> is covered by a rectangle of area 1.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,1,0],[0,1,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/05/14/example1rect2.png" style="padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 356px; height: 198px;" /></p>

<ul>
	<li>The 1&#39;s at <code>(0, 0)</code> and <code>(0, 2)</code> are covered by a rectangle of area 3.</li>
	<li>The 1 at <code>(1, 1)</code> is covered by a rectangle of area 1.</li>
	<li>The 1 at <code>(1, 3)</code> is covered by a rectangle of area 1.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either 0 or 1.</li>
	<li>The input is generated such that there are at least three 1&#39;s in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-enumerate">Approach: Enumerate</h3>
<h4 id="intuition">Intuition</h4>
<p>We can divide the <span class="math inline">\(\textit{grid}\)</span> into three non-overlapping sections and treat each section as a separate instance of the problem <a href="https://leetcode.com/problems/find-the-minimum-area-to-cover-all-ones-i/description/">ã€Œ3195. Find the Minimum Area to Cover All Ones Iã€</a>.</p>
<p><img src="https://assets.leetcode.com/users/images/84e7eb6e-8dd6-4a54-af67-1166c194e506_1755522896.2855275.png" alt="img" /></p>
<p>As shown in the figure above, there are <span class="math inline">\(6\)</span> possible cases. For cases <span class="math inline">\((1), (2), (4),\)</span> and <span class="math inline">\((5)\)</span>, we can enumerate the intersections of the three parts. For cases <span class="math inline">\((3)\)</span> and <span class="math inline">\((6)\)</span>, we can enumerate the rows and columns being cut. The time complexity in these scenarios is <span class="math inline">\(O(nm)\)</span>, <span class="math inline">\(O(n^2)\)</span>, or <span class="math inline">\(O(m^2)\)</span>.</p>
<p>Since <span class="math inline">\((1), (2), (3)\)</span> rotated counterclockwise by <span class="math inline">\(90\)</span> degrees correspond to <span class="math inline">\((4), (5), (6)\)</span>, we only need to consider the original array and the two arrays rotated <span class="math inline">\(90\)</span> degrees, enumerating the first three cases separately.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/L4VdGZ3c/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <span class="math inline">\(\textit{grid}\)</span> and <span class="math inline">\(m\)</span> be the number of columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m^2)\)</span>.</p>
<p>We divide the grid into three parts for processing. The time complexity of each part is <span class="math inline">\(O(n \cdot m)\)</span>, <span class="math inline">\(O(n^2)\)</span>, or <span class="math inline">\(O(m^2)\)</span>. When combined, the overall complexity becomes <span class="math inline">\(O(n^2 \cdot m^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>We need to store the three divided parts.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-peak-element-in-a-2d-matrix/1" target="_blank" rel="noopener noreferrer">Find the Peak Element in a 2D Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p class="MsoNormal"><span style="font-size: 18.6667px;">Given a 2D matrix <strong>mat[][]</strong>, identify any <strong>peak element</strong> within the matrix.</span></p>
<p class="MsoNormal"><span style="font-size: 18.6667px;">An element is considered a <strong>peak </strong>if it is <strong>greater than or equal</strong> to its <strong>four immediate neighbors:</strong> top, bottom, left, and right. For corner and edge elements, any missing neighbors are treated as having a value of <strong>negative infinity</strong>.</span></p>
<p class="MsoNormal"><span style="font-size: 18.6667px;"><strong>Note:</strong> A peak element is not necessarily the global maximum, it only needs to satisfy the condition relative to its adjacent elements. Multiple peak elements may exist, return any one of them.<br />Note that the driver code will print true if you return the correct position of peak element, else it will print false.</span></p>
<p class="MsoNormal"><span style="font-size: 14pt;"><strong>Examples:<br /></strong></span></p>
<pre class="MsoNormal"><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">mat[][] = </span>[[10, 20, 15],           
                [21, 30, 14],
                 [7, 16, 32]]<strong style="font-size: 14pt;"><br />Output: </strong>true<strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">One of the peak element is 30 at index (1, 1), which is greater than or equal to all its valid neighbors: Left = 21, Right = 14, Top = 20, Bottom = 16. So, it satisfies the peak condition. Alternatively, (2, 2) with value 32 also qualifies as a peak.</span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong>mat[][] <strong>= </strong>[[17, 7],
                [11, 10]]<strong style="font-size: 14pt;"><br />Output: </strong>true<strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">17 is the only peak element at index (0, 0). Its neighbors are: Right= 7, Bottom = 11. Since 17 is greater than or equal to both (and top/left are out of bounds), it qualifies as a peak element.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraint:<br /></span></strong><span style="font-size: 18.6667px;">1 &le; n &times; m &le; 10<sup>6</sup><br /></span><span style="font-size: 18.6667px;">-10<sup>6</sup>&nbsp;&le; mat[i][j] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-safest-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Find the Safest Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>n x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A cell containing a thief if <code>grid[r][c] = 1</code></li>
	<li>An empty cell if <code>grid[r][c] = 0</code></li>
</ul>

<p>You are initially positioned at cell <code>(0, 0)</code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.</p>

<p>The <strong>safeness factor</strong> of a path on the grid is defined as the <strong>minimum</strong> manhattan distance from any cell in the path to any thief in the grid.</p>

<p>Return <em>the <strong>maximum safeness factor</strong> of all paths leading to cell </em><code>(n - 1, n - 1)</code><em>.</em></p>

<p>An <strong>adjacent</strong> cell of cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> and <code>(r - 1, c)</code> if it exists.</p>

<p>The <strong>Manhattan distance</strong> between two cells <code>(a, b)</code> and <code>(x, y)</code> is equal to <code>|a - x| + |b - y|</code>, where <code>|val|</code> denotes the absolute value of val.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example1.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example2.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[0,0,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/07/02/example3.png" style="width: 362px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>
	<li><code>grid[i].length == n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There is at least one thief in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> representing a city layout where some cells contain thieves and others are empty, and we need to find the maximum safeness factor of all paths from the top-left corner to the bottom-right corner. The safeness factor of a path is defined as the minimum Manhattan distance from any cell in the path to any thief in the <code>grid</code>.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Manhattan distance between two cells is the sum of the absolute differences of their row and column indices.</li>
<li>All the cells in the <code>grid</code> contain either 0 or 1, representing empty cells and cells containing thieves respectively.</li>
<li>You start from the top-left corner <code>(0, 0)</code> and can move to adjacent cells in any of the four directions.</li>
<li>The maximum level of safety one can achieve while traversing from the starting point to the destination is by ensuring the least proximity to any cell containing a thief.</li>
</ol>
<h3 id="approach-1-breadth-first-search--binary-search">Approach 1: Breadth-First Search + Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Since we need to find the safeness factor of a path from the source to the destination, the initial intuition to solve this problem is that we should first find the safeness factors of the cells in the path. The path can span across the entire <code>grid</code>, so we need to find the safeness factors for all the cells in the <code>grid</code>.</p>
<p>One approach to find the safeness factors of the cells would be to iterate over each cell in the <code>grid</code> and find its distance from all the thieves in the <code>grid</code>. We can then pick the smallest distance as the safeness factor for that cell.</p>
<p>However, this brute force approach would have a time complexity of <span class="math inline">\(O(n^4)\)</span>, which would not satisfy the constraints of the problem. Therefore, a more optimized approach is needed.</p>
<p>To optimize the solution, we can leverage the properties of a multi-source breadth-first Search (BFS). Instead of finding the distance of each cell from all the thieves, we can do the opposite: find the distance of all the thieves from each cell.</p>
<blockquote>
<p>Note: A multi-source breadth-first search is a BFS where multiple starting nodes are explored simultaneously. This is an efficient method to find the shortest distances from any of the starting nodes to all reachable nodes in the graph. You can refer to this excellent <strong><a href="https://leetcode.com/problems/rotting-oranges/">problem</a></strong> to gain some practice on multi-source BFS.</p>
</blockquote>
<p>The intuition for this can be,</p>
<ul>
<li>We start by adding all the thief coordinates to a queue as the initial points of exploration.</li>
<li>We then explore the neighboring cells (up, down, left, and right) from all the thieves in one iteration, like ripples spreading outwards from each thief.</li>
<li>As we visit each cell, we mark it with the minimum distance from the nearest thief. This is because the first time a cell is visited, it means that the current thief is the closest one to that cell.</li>
<li>We continue the BFS traversal until all the cells in the <code>grid</code> are marked with their corresponding safeness values.</li>
</ul>
<p>The following slideshow demonstrates how the BFS gradually populates the <code>grid</code> with its minimum distances from a thief.</p>
<p>!?!../Documents/2812/bfs_slideshow.json:412,291!?!</p>
<p>Now that we have the safeness factor of each cell, we need to find the maximum safeness factor for which a path exists from the source cell to the destination cell. This implies that for all safeness values greater than it, no path exists, and at least one path exists for all values less than it. We can visualize these safeness factors as a monotonic sequence on a number line. The values that satisfy the constraints of the problem will be a contiguous series. These will be followed by a series of values that do not satisfy the constraints. We will name this breakpoint the inflection point.</p>
<p>The following slideshow visualizes how we iteratively converge to the location of the inflection point using binary search.</p>
<p>!?!../Documents/2812/bs_slideshow.json:482,160!?!</p>
<p>During the binary search, to determine if a safeness value meets the problem constraints, we employ another breadth-first search (BFS) traversal on the <code>grid</code>. The traversal attempts to find a path where every cell in the path satisfies this minimum safeness value. If such a path is found, it indicates that the given safeness value is a valid solution to the problem.</p>
<p>Thus, to find the maximum safeness factor, we can use binary search to efficiently locate the inflection point in this monotonic sequence. The last &quot;True&quot; value at the inflection point will be the maximum safeness factor for which a path exists.</p>
<p>In summary, the final solution involves two key steps:</p>
<ol>
<li>Perform a breadth-first search to compute the safeness factor for each cell, leveraging the fact that the first time a cell is visited, it represents the minimum distance from the nearest thief.</li>
<li>Apply binary search to find the maximum safeness factor for which a path exists from the source to the destination cell.</li>
</ol>
<p>This approach is more efficient than the initial brute-force solution, as it avoids the need to calculate the distance of each cell from all the thieves. Instead, it focuses on finding the distance of each cell from all the thieves, which can be done more optimally manner using BFS.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
<li>Define <code>isValidSafeness</code> method to check if a path exists with a minimum safeness value.</li>
</ul>
<h5 id="isvalidcell-method"><code>isValidCell</code> Method</h5>
<ol>
<li>Take the <code>grid</code>, row <code>i</code>, and column <code>j</code> as input.</li>
<li>Get the size of the <code>grid</code>, denoted by <code>n</code>.</li>
<li>Check if the cell at (<code>i</code>, <code>j</code>) is within the <code>grid</code> boundaries.</li>
<li>Return <code>true</code> if the cell is valid, <code>false</code> otherwise.</li>
</ol>
<h5 id="isvalidsafeness-method"><code>isValidSafeness</code> Method</h5>
<ol>
<li>
<p>Take the <code>grid</code> and the minimum safeness value as input.</p>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
<li><code>visited</code> as a 2-D array to mark visited cells.</li>
</ul>
</li>
<li>
<p>Check if the source and destination cells satisfy the minimum safeness.</p>
</li>
<li>
<p>Perform a breadth-first search (BFS) to find a valid path:</p>
<ul>
<li>Initialize a queue <code>q</code> to contain the coordinates.</li>
<li>Add the source cell (<code>0</code>, <code>0</code>) to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells in all directions:
<ul>
<li>If the neighboring cell is valid, unvisited and has a safeness value greater than or equal to the minimum safeness value:
<ul>
<li>Mark the cell as visited and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If a valid path is found, return <code>true</code>.</li>
</ul>
</li>
<li>
<p>Return <code>false</code> if no valid path is found.</p>
</li>
</ol>
<h5 id="signature-function-maximumsafenessfactor">Signature function <code>maximumSafenessFactor</code></h5>
<ol>
<li>
<p>Initialize a queue <code>q</code> to store the positions of thieves.</p>
</li>
<li>
<p>Mark thieves as <code>0</code> and empty cells as <code>-1</code>, and push thieves to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform a binary search for the maximum safeness factor:</p>
<ul>
<li>Initialize <code>start</code> and <code>end</code> variables.</li>
<li>Initialize <code>res</code> to store the maximum safeness value.</li>
<li>Loop through the <code>grid</code> to find the maximum safeness factor and assign it to <code>end</code>.</li>
<li>While <code>start</code> is less than or equal to <code>end</code>:
<ul>
<li>Calculate <code>mid</code>.</li>
<li>Check if a valid safeness exists for <code>mid</code> using <code>isValidSafeness</code> method.</li>
<li>Update <code>res</code> if valid safeness is found.</li>
<li>Update <code>start</code> or <code>end</code> based on the result of <code>isValidSafeness</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum safeness factor <code>res</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3UY5NMSg/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The time complexity for the initial BFS is <span class="math inline">\(O(n^2)\)</span>, as each cell in the <span class="math inline">\(n \cdot n\)</span> <code>grid</code> is visited once during the traversal.</p>
<p>The binary search occurs in the range [0, maximum safeness factor possible], where the maximum safeness factor possible is <span class="math inline">\(2 \cdot n\)</span>. The time complexity of the binary search is <span class="math inline">\(O(\log (2 \cdot n))\)</span>, which is equivalent to <span class="math inline">\(O(\log n)\)</span>.</p>
<p>For each iteration of the binary search, a breadth-first Search is conducted to verify validity, which has a time complexity of <span class="math inline">\(O(n^2)\)</span>. Thus, the total time complexity of the binary search portion is <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log n)\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The data structure used in the algorithm is a queue, which takes linear space. Since the total number of cells in the <code>grid</code> is <span class="math inline">\(n^2\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<h3 id="approach-2-bfs--greedy">Approach 2: BFS + Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used a binary search strategy to find the maximum safeness factor for which a path exists from the source to the destination. While this was an efficient solution, the intuition behind this approach is to directly find the optimal path from the source to the destination by leveraging Dijkstra's algorithm.</p>
<p>Similar to the previous approach, we first need to populate the <code>grid</code> with the safeness values for each cell. The algorithm to achieve this is the same as before, using the breadth-first Search (BFS) technique to compute the distance of each cell from the nearest thief.</p>
<p>The key idea here is to use Dijkstra's single source shortest path algorithm to find the optimal path from the source cell <code>[0, 0]</code> to the destination cell <code>[n-1, n-1]</code>. However, since each cell in the <code>grid</code> already contains its safeness factor, we need to modify Dijkstra's algorithm to find the path with the maximum safeness factor. In our modified Dijkstra's algorithm, we can greedily prioritize cells with a higher safeness factor to append to our path. The safeness factor of the path would be the minimum of the safeness values encountered in that path so far. Once we reach the destination cell, the safeness factor of the path would represent the required maximum safeness factor.</p>
<p>The modified Dijkstra's algorithm works as follows:</p>
<ul>
<li>We start with the source cell <code>[0, 0]</code> in a priority queue, where the priority is based on the highest safeness factor encountered in the path so far.</li>
<li>For efficiency, cells we've explored are marked as -1 in the <code>grid</code> itself.</li>
<li>If the current cell is the destination <code>[n-1, n-1]</code>, the traversal is over, and we return the maximum safeness factor encountered so far.</li>
<li>If the current cell is not the destination, we explore the valid adjacent cells. A cell is considered valid if it is within the <code>grid</code> boundaries and not visited yet (not -1).</li>
<li>For each valid neighbor, we calculate the potential safeness factor considering the current path's safeness and the new cell's distance to thieves. The minimum of these two values becomes the new safeness for the path with the addition of the neighbor.</li>
<li>We add the valid neighbors to the priority queue, prioritizing them based on their safeness factor.</li>
<li>We continue the exploration until we reach the destination cell.</li>
</ul>
<p>The key advantage of this approach is that it directly finds the optimal path from the source to the destination instead of relying on a binary search to find the maximum safeness factor. By using Dijkstra's algorithm, we can ensure that we find the path with the maximum safeness factor, without the need to perform a separate binary search.</p>
<p>Additionally, this approach may be more intuitive for some users, as it closely resembles the problem of finding the shortest path with the maximum weight (safeness factor) on a weighted graph.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>dir</code> to store directions for moving to neighboring cells: right, left, down, up.</li>
<li>Define the <code>isValidCell</code> method to check if a given cell is valid within the <code>grid</code>.</li>
</ul>
<ol>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>n</code> as the size of the <code>grid</code>.</li>
<li><code>q</code> as a queue of coordinates to perform the breadth-first search (BFS).</li>
</ul>
</li>
<li>
<p>Mark thieves as 0 and empty cells as -1 in the <code>grid</code>. Push thieves' coordinates to the queue.</p>
</li>
<li>
<p>Perform BFS to calculate the safeness factor for each cell:</p>
<ul>
<li>While the queue is not empty:
<ul>
<li>Retrieve the front element <code>curr</code> from the queue.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and unvisited (safeness factor = -1):
<ul>
<li>Update its safeness factor and push it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Initialize a priority queue <code>pq</code> to prioritize cells with a higher safeness factor. Push the starting cell to <code>pq</code>.</p>
</li>
<li>
<p>Perform BFS to find the path with the maximum safeness factor:</p>
<ul>
<li>While the priority queue <code>pq</code> is not empty:
<ul>
<li>Retrieve the top element <code>curr</code> from <code>pq</code>.</li>
<li>If the destination is reached, return the safeness factor of the path.</li>
<li>Explore neighboring cells:
<ul>
<li>If the neighboring cell is valid and not marked as visited:
<ul>
<li>Update the safeness factor for the path and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no path is found, return -1.</p>
</li>
</ol>
<blockquote>
<p>Note: In the C++ implementation, the elements in the priority queue are stored as <code>[safeness, row, col]</code> to leverage C++'s default comparison capabilities.</p>
</blockquote>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/UHkVoNQF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \cdot n\)</span> be the size of the matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2 \cdot \log (n))\)</span></p>
<p>Similar to Approach 1, the time complexity of the initial BFS is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>To find the optimal path, we use Dijkstra's single source shortest path algorithm, which has a time complexity of <span class="math inline">\(O(n^2 \cdot \log (n))\)</span> when implemented in a <code>grid</code> of size <span class="math inline">\(n \cdot n\)</span>.</p>
<p>The total time complexity is the sum of the time complexities of the two parts: <span class="math inline">\(O(n^2) + O(n^2 \cdot \log (n))\)</span>. This can be simplified to <span class="math inline">\(O(n^2 \cdot \log (n))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The two data structures used in this approach are the queue and the priority queue, both of which have a linear space complexity. Since the maximum number of elements that can be present in the queues is <span class="math inline">\(n \cdot n\)</span>, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-string-in-grid0111/1" target="_blank" rel="noopener noreferrer">Find the string in grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D grid&nbsp;of <strong>n</strong>*<strong>m</strong> of characters and a <strong>word</strong>, find all occurrences of given word in grid. A word can be matched in <strong>all 8 directions</strong> at any point. Word is said to be found in a direction if all characters match in this direction (not in zig-zag form). The 8 directions are, <strong>horizontally left</strong>, <strong>horizontally right</strong>, <strong>vertically up</strong>, <strong>vertically down</strong>, and <strong>4 diagonal directions</strong>.<br /><br /><strong>Note:</strong> The returning list should be <strong>lexicographically smallest</strong>. If the word can be found in multiple directions starting from the same coordinates, the list should contain the coordinates only once.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = {{a,b,c},{d,r,f},{g,h,i}},
word = "abc"
<strong>Output: <br /></strong>{{0,0}}
<strong>Explanation: <br /></strong>From (0,0) we can find "abc" in horizontally right direction.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>grid = {{a,b,a,b},{a,b,e,b},{e,b,e,b}}
word = "abe"
<strong>Output: <br /></strong>{{0,0},{0,2},{1,0}}
<strong>Explanation: <br /></strong>From (0,0) we can find "abe" in right-down diagonal. <br />From (0,2) we can find "abe" in left-down diagonal. <br />From (1,0) we can find "abe" in horizontally right direction.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything, Your task is to complete the function&nbsp;<strong>searchWord()&nbsp;</strong>which takes grid and word as input parameters and returns a list containing the positions from where the word originates&nbsp;in any direction. If there is no such position then returns an&nbsp;empty&nbsp;list.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m*k) where k is constant<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= m &lt;= 50<br />1 &lt;= |word| &lt;= 15</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-string-with-lcp/description" target="_blank" rel="noopener noreferrer">Find the String with LCP</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>We define the <code>lcp</code> matrix of any <strong>0-indexed</strong> string <code>word</code> of <code>n</code> lowercase English letters as an <code>n x n</code> grid such that:</p>

<ul>
	<li><code>lcp[i][j]</code> is equal to the length of the <strong>longest common prefix</strong> between the substrings <code>word[i,n-1]</code> and <code>word[j,n-1]</code>.</li>
</ul>

<p>Given an&nbsp;<code>n x n</code> matrix <code>lcp</code>, return the alphabetically smallest string <code>word</code> that corresponds to <code>lcp</code>. If there is no such string, return an empty string.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>. For example, <code>&quot;aabd&quot;</code> is lexicographically smaller than <code>&quot;aaca&quot;</code> because the first position they differ is at the third letter, and <code>&#39;b&#39;</code> comes before <code>&#39;c&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]
<strong>Output:</strong> &quot;abab&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is &quot;abab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]
<strong>Output:</strong> &quot;aaaa&quot;
<strong>Explanation:</strong> lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is &quot;aaaa&quot;. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>
	<li><code><font face="monospace">0 &lt;= lcp[i][j] &lt;= n</font></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-width-of-columns-of-a-grid/description" target="_blank" rel="noopener noreferrer">Find the Width of Columns of a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. The width of a column is the maximum <strong>length </strong>of its integers.</p>

<ul>
	<li>For example, if <code>grid = [[-10], [3], [12]]</code>, the width of the only column is <code>3</code> since <code>-10</code> is of length <code>3</code>.</li>
</ul>

<p>Return <em>an integer array</em> <code>ans</code> <em>of size</em> <code>n</code> <em>where</em> <code>ans[i]</code> <em>is the width of the</em> <code>i<sup>th</sup></code> <em>column</em>.</p>

<p>The <strong>length</strong> of an integer <code>x</code> with <code>len</code> digits is equal to <code>len</code> if <code>x</code> is non-negative, and <code>len + 1</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[22],[333]]
<strong>Output:</strong> [3]
<strong>Explanation:</strong> In the 0<sup>th</sup> column, 333 is of length 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[-15,1,3],[15,7,12],[5,6,-2]]
<strong>Output:</strong> [3,1,2]
<strong>Explanation:</strong> 
In the 0<sup>th</sup> column, only -15 is of length 3.
In the 1<sup>st</sup> column, all integers are of length 1. 
In the 2<sup>nd</sup> column, both 12 and -2 are of length 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100 </code></li>
	<li><code>-10<sup>9</sup> &lt;= grid[r][c] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/description" target="_blank" rel="noopener noreferrer">Find Valid Matrix Given Row and Column Sums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two arrays <code>rowSum</code> and <code>colSum</code> of non-negative integers where <code>rowSum[i]</code> is the sum of the elements in the <code>i<sup>th</sup></code> row and <code>colSum[j]</code> is the sum of the elements of the <code>j<sup>th</sup></code> column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.</p>

<p>Find any matrix of <strong>non-negative</strong> integers of size <code>rowSum.length x colSum.length</code> that satisfies the <code>rowSum</code> and <code>colSum</code> requirements.</p>

<p>Return <em>a 2D array representing <strong>any</strong> matrix that fulfills the requirements</em>. It&#39;s guaranteed that <strong>at least one </strong>matrix that fulfills the requirements exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rowSum = [3,8], colSum = [4,7]
<strong>Output:</strong> [[3,0],
         [1,7]]
<strong>Explanation:</strong> 
0<sup>th</sup> row: 3 + 0 = 3 == rowSum[0]
1<sup>st</sup> row: 1 + 7 = 8 == rowSum[1]
0<sup>th</sup> column: 3 + 1 = 4 == colSum[0]
1<sup>st</sup> column: 0 + 7 = 7 == colSum[1]
The row and column sums match, and all matrix elements are non-negative.
Another possible matrix is: [[1,2],
                             [3,5]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rowSum = [5,7,10], colSum = [8,6,8]
<strong>Output:</strong> [[0,5,0],
         [6,1,0],
         [2,0,8]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li>
	<li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 10<sup>8</sup></code></li>
	<li><code>sum(rowSum) == sum(colSum)</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-greedy">Approach 1: Greedy</h3>
<h4 id="intuition">Intuition</h4>
<p>Imagine there is a non-negative integer matrix <code>origMatrix</code> with dimensions <span class="math inline">\(N \times M\)</span>. We have performed a sum operation on each row and column of the matrix, storing the results in two lists: <code>rowSum</code> and <code>colSum</code>. The list <code>rowSum</code> of size <span class="math inline">\(N\)</span> contains the sum of each row of the original matrix, while the list <code>colSum</code> of size <span class="math inline">\(M\)</span> contains the sum of each column. Given these two lists, <code>rowSum</code> and <code>colSum</code>, we need to reconstruct the original matrix <code>origMatrix</code>. The inputs are guaranteed to be valid, meaning at least one solution exists, and any valid matrix can be returned in the case of multiple solutions.</p>
<p>Let's think about the value we can assign to a particular cell at row <code>r</code> and column <code>c</code>. We need to assign such a value that the total sum in the row doesn't exceed <code>rowSum[r]</code> and total sum in the column doesn't exceed <code>colSum[c]</code>. This is because we can only have non-negative integers in the matrix and hence we cannot exceed the total sum. We can greedily choose the maximum number we can assign to a cell and what should it be? The maximum value we can assign considering only the rows will be <code>rowSum[r] - sum of all cells we have filled in row r so far</code>, similarly the maximum value we can assign considering only the columns will be <code>colSum[c] - sum of all cells we have filled in the column c so far</code>. As just discussed we cannot exceed the total sum in any of the two constraints (row and column) we will choose the minimum of these two values to assign to the cell at <code>(r, c)</code>.</p>
<p>To achieve this, we iterate over the elements of the matrix, maintaining the cumulative sums of the rows and columns processed so far. Let <code>currRowSum[i]</code> represent the sum of the elements in the <span class="math inline">\(i\)</span>-th row up to the current element, and <code>currColSum[j]</code> represent the sum of the elements in the <span class="math inline">\(j\)</span>-th column up to the current element. For the cell <code>(i, j)</code>, the value can be determined as:</p>
<p><span class="math display">\[
This ensures that the sum of the $i$-th row does not exceed `rowSum[i]` and the sum of the $j$-th column does not exceed `colSum[j]`. After determining $K$, we update `currRowSum[i]` and `currColSum[j]` by adding $K$.

We initialize `currRowSum` and `currColSum` to zero and proceed from the top left to the bottom right of the matrix, filling in the values and storing them in `origMatrix`.

#### Algorithm

1. Initialize the number of rows and number of columns as $N$ and $M$ respectively.
2. Initialize two lists `currRowSum` and `currColSum` of size $N$ and $M$ respectively with values as zero.
3. Initialize the answer matrix `origMatrix` of size $N * M$ with all values as zero.
4. Iterate over all cells in the matrix and for each cell `(i, j)`, do the following:

    - Store the value in `origMatrix[i][j]` as `min(rowSum[i] - currRowSum[i], colSum[j] - currColSum[j])`.
    - Add the above value to `currRowSum[i]` and `currColSum[j]`.
5. Return `origMatrix`.

#### Implementation

[code](https://leetcode.com/playground/DxJT7rDW/shared)

#### Complexity Analysis

Here,$N$ is the number size of the list `rowSum` and $M$ is the size of the list `colSum`.

* Time complexity: $O(N \times M)$.

    Initializing the answer matrix `origMatrix` takes $O(N \times M)$ time. Also, we iterate over each of the $N \times M$ cells to find the values. Hence, the total time complexity is equal to $O(N \times M)$.

* Space complexity: $O(N + M)$.

    The space required to store the answer is not considered part of the space complexity. Therefore, the space required for this approach is the two lists to store the current sum of rows and columns. Hence, the total space complexity is equal to $O(N + M)$.

---

### Approach 2: Space Optimized Greedy

#### Intuition

> Note: In an interview setting, an approach that involves changing the input is generally not recommended. This and the next approach will change the input matrix and are added for the sake of completion. While suggesting these approaches in an interview the downside of the changing input must be called out.

In the previous approach, we used two lists, `currRowSum` and `currColSum`, to keep track of the cumulative sums of elements for each row and column. However, we can eliminate the need for these lists by directly updating the given `rowSum` and `colSum` lists.

Instead of maintaining the cumulative sums, we will now keep track of the remaining sums. For each cell `(i, j)`, we assign a value equal to `min(rowSum[i], colSum[j])`. After assigning this value to `origMatrix[i][j]`, we subtract it from both `rowSum[i]` and `colSum[j]`.

By updating `rowSum[i]` and `colSum[j]` in this manner, they will always represent the maximum possible value that can be assigned to the current cell `(i, j)`. This approach eliminates the need for additional space to store cumulative sums and simplifies the implementation.

#### Algorithm

1. Initialize the number of rows and number of columns as $N$ and $M$ respectively.
2. Initialize the answer matrix `origMatrix` of size $N * M$ with all values as zero.
3. Iterate over all cells in the matrix and for each cell `(i, j)`, do the following:

    - Store the value in `origMatrix[i][j]` as `min(rowSum[i], colSum[j])`.
    - Subtract the above value from `rowSum[i]` and `colSum[j]`.
4. Return `origMatrix`.

#### Implementation

[code](https://leetcode.com/playground/kDRiBT75/shared)

#### Complexity Analysis

Here, $N$ is the number size of the list `rowSum` and $M$ is the size of the list `colSum`.

* Time complexity: $O(N * M)$.

    Initializing the answer matrix `origMatrix` takes $O(N \times M)$ time. Also, we iterate over each of the $N \times M$ cells to find the values. Hence, the total time complexity is equal to $O(N \times M)$.

* Space complexity: $O(1)$.

    The space required to store the answer is not considered part of the space complexity. We don't require any extra space other than the matrix to store the answer. Hence, the total space complexity is constant.

---

### Approach 3: Time + Space Optimized Greedy

#### Intuition

If we observe the previous approach closely, we are assigning the minimum of `(rowSum[i], colSum[j])` to the cell `(i, j)` and then subtracting this minimum value from both `rowSum[i]` and `colSum[j]`. This implies that at each iteration, one of `rowSum[i]` or `colSum[j]` will become zero, i.e., whichever is the minimum will become zero. 

When `rowSum[i]` becomes zero, all future operations involving `i` as the row index will have `min(rowSum[i], colSum[j])` equal to zero. Similarly, when `colSum[j]` becomes zero, all future operations involving `j` as the column index will also have `min(rowSum[i], colSum[j])` equal to zero.

This means that we need only one operation for a pair of row and column `(i, j)`. When iterating over the cells, for each pair `(i, j)`, we will either make `rowSum[i]` or `colSum[j]` zero, allowing us to skip subsequent operations for that row or column respectively.

We will implement this with a while loop that runs while the row index `i` and column index `j` are within their respective sizes. In each iteration, we find the value to assign to the current cell as `min(rowSum[i], colSum[j])`, and subtract this from both `rowSum[i]` and `colSum[j]`. If `rowSum[i]` becomes zero, we increment `i`; otherwise, we increment `j`. Finally, we return the matrix `origMatrix`.

![fig](../Figures/1605/1605A.png)

#### Algorithm

1. Initialize the number of rows and number of columns as $N$ and $M$ respectively.
2. Initialize the answer matrix `origMatrix` of size $N * M$ with all values as zero.
3. Initialize the row index `i` and column index `j` to `0`.
4. Iterate over all cells`(i, j)` while both `i` and `j` are within the boundary, do the following:

    - Store the value in `origMatrix[i][j]` as `min(rowSum[i], colSum[j])`.
    - Subtract the above value from `rowSum[i]` and `colSum[j]`.
    - If `rowSum[i]` becomes `0`, increment `i` otherwise increment the variable `j`.
5. Return `origMatrix`.

#### Implementation

[code](https://leetcode.com/playground/3ge9HUJR/shared)

#### Complexity Analysis


Here, $N$ is the number size of the list `rowSum` and $M$ is the size of the list `colSum`.

* Time complexity: $O(N \times M)$.

    Initializing the answer matrix `origMatrix` takes $O(N \times M)$ time. To store the values in the answer matrix we performed $O(N + M)$ operations as we skipped either the row or column at each iteration. Hence, the total time complexity is equal to $O(N \times M)$.

* Space complexity: $O(1)$.

    The space required to store the answer is not considered part of the space complexity. We don't require any extra space other than the matrix to store the answer. Hence, the total space complexity is constant.

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-whether-path-exist5238/1" target="_blank" rel="noopener noreferrer">Find whether path exist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a grid of size <strong>n</strong>*<strong>n</strong>&nbsp;filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination.&nbsp;You can traverse up, down, right and left.<br />The description of cells is as follows:</span></p>
<ul>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>1</strong>&nbsp;means Source.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>2</strong>&nbsp;means Destination.</span></li>
<li><span style="font-size: 18px;">A value of cell&nbsp;<strong>3</strong>&nbsp;means Blank cell.</span></li>
<li><span style="font-size: 18px;">A value of cell <strong>0&nbsp;</strong>means Wall (blocked cell which we cannot traverse).</span></li>
</ul>
<p><span style="font-size: 18px;"><strong>Note</strong>: There are only a single source and a single destination.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{3,0,3,0,0},{3,0,0,0,3},{3,3,3,3,3},{0,2,3,0,0},{3,0,0,1,3}}
<strong>Output: </strong>0
<strong>Explanation: </strong>The grid is-
3 0 3 0 0&nbsp;
3 0 0 0 3&nbsp;
3 3 3 3 3&nbsp;
0 2 3 0 0&nbsp;
3 0 0 1 3&nbsp;
There is no path to reach at (3,1) i,e at destination from (4,3) i,e source.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>grid = {{1,3},{3,2}}
<strong>Output: </strong>1
<strong>Explanation: </strong>The grid is-
<span style="color: #000000;">1 3
3 2
</span>There is a path from (0,0) i,e source to (1,1) i,e destination.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(n<sup>2</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/description" target="_blank" rel="noopener noreferrer">Find Winner on a Tic Tac Toe Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><strong>Tic-tac-toe</strong> is played by two players <code>A</code> and <code>B</code> on a <code>3 x 3</code> grid. The rules of Tic-Tac-Toe are:</p>

<ul>
	<li>Players take turns placing characters into empty squares <code>&#39; &#39;</code>.</li>
	<li>The first player <code>A</code> always places <code>&#39;X&#39;</code> characters, while the second player <code>B</code> always places <code>&#39;O&#39;</code> characters.</li>
	<li><code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> characters are always placed into empty squares, never on filled ones.</li>
	<li>The game ends when there are <strong>three</strong> of the same (non-empty) character filling any row, column, or diagonal.</li>
	<li>The game also ends if all squares are non-empty.</li>
	<li>No more moves can be played if the game is over.</li>
</ul>

<p>Given a 2D integer array <code>moves</code> where <code>moves[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> move will be played on <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code>. return <em>the winner of the game if it exists</em> (<code>A</code> or <code>B</code>). In case the game ends in a draw return <code>&quot;Draw&quot;</code>. If there are still movements to play return <code>&quot;Pending&quot;</code>.</p>

<p>You can assume that <code>moves</code> is valid (i.e., it follows the rules of <strong>Tic-Tac-Toe</strong>), the grid is initially empty, and <code>A</code> will play first.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/22/xo1-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
<strong>Output:</strong> &quot;A&quot;
<strong>Explanation:</strong> A wins, they always play first.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/22/xo2-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
<strong>Output:</strong> &quot;B&quot;
<strong>Explanation:</strong> B wins.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/22/xo3-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
<strong>Output:</strong> &quot;Draw&quot;
<strong>Explanation:</strong> The game ends in a draw since there are no moves to make.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= moves.length &lt;= 9</code></li>
	<li><code>moves[i].length == 2</code></li>
	<li><code>0 &lt;= row<sub>i</sub>, col<sub>i</sub> &lt;= 2</code></li>
	<li>There are no repeated elements on <code>moves</code>.</li>
	<li><code>moves</code> follow the rules of tic tac toe.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/first-completely-painted-row-or-column/description" target="_blank" rel="noopener noreferrer">First Completely Painted Row or Column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>arr</code>, and an <code>m x n</code> integer <strong>matrix</strong> <code>mat</code>. <code>arr</code> and <code>mat</code> both contain <strong>all</strong> the integers in the range <code>[1, m * n]</code>.</p>

<p>Go through each index <code>i</code> in <code>arr</code> starting from index <code>0</code> and paint the cell in <code>mat</code> containing the integer <code>arr[i]</code>.</p>

<p>Return <em>the smallest index</em> <code>i</code> <em>at which either a row or a column will be completely painted in</em> <code>mat</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="image explanation for example 1" /><img alt="image explanation for example 1" src="https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg" style="width: 321px; height: 81px;" />
<pre>
<strong>Input:</strong> arr = [1,3,4,2], mat = [[1,4],[2,3]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="image explanation for example 2" src="https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg" style="width: 601px; height: 121px;" />
<pre>
<strong>Input:</strong> arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The second column becomes fully painted at arr[3].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n = mat[i].length</code></li>
	<li><code>arr.length == m * n</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>
	<li>All the integers of <code>arr</code> are <strong>unique</strong>.</li>
	<li>All the integers of <code>mat</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two inputs: an array <code>arr</code> and a matrix <code>mat</code>. The array <code>arr</code> is a list of numbers, and the matrix <code>mat</code> is a grid where each cell contains one of these numbers. Both <code>arr</code> and <code>mat</code> contain all integers from 1 to <span class="math inline">\(m \cdot n\)</span>, where <span class="math inline">\(m\)</span> is the number of rows in the matrix and <span class="math inline">\(n\)</span> is the number of its columns.</p>
<p>Our goal is to simulate a process where we &quot;paint&quot; the cells of the matrix in the order defined by <code>arr</code>. Starting from the first number in <code>arr</code>, we find the corresponding cell in <code>mat</code> and mark it as painted. As we progress through <code>arr</code>, more cells in <code>mat</code> will become painted.</p>
<p>We need to find the smallest index <code>i</code> in <code>arr</code> such that, after painting the cell corresponding to <span class="math inline">\(arr[i]\)</span>, either:</p>
<ol>
<li>An entire row in the matrix becomes completely painted (all cells in the row are marked).</li>
<li>An entire column in the matrix becomes completely painted (all cells in the column are marked).</li>
</ol>
<blockquote>
<p>Note: Each number in <code>arr</code> corresponds to a unique cell in <code>mat</code>. This means no number is repeated, and every cell in the matrix will eventually be painted.</p>
</blockquote>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute-Force</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute force way to solve this problem will be to start processing each element of <code>arr</code> one by one, paint the corresponding cell in <code>mat</code> and then iterate over its row and column to check whether at least one of them is completely painted.</p>
<p>To achieve this, we need a way to efficiently retrieve the position of each number in the matrix. For this purpose, we create a map called <code>numToPos</code>, where each key represents a number from <code>mat</code>, and its corresponding value is the position (row and column) of that number in <code>mat</code>. This map allows us to quickly look up the position of any number during processing.</p>
<p>After constructing the map, we start iterating through each number in <code>arr</code>. For each number, we check where it appears in <code>mat</code> by looking it up in the map. Once we find the numberâ€™s position, we mark it as &quot;seen&quot; by setting its value in <code>mat</code> to a negative number. This marking indicates that the cell is painted.</p>
<p>After marking the cell, the next step is to check whether the current row or column is completely filled. To do this:</p>
<ul>
<li>We scan the entire row where the marked cell is located. If every element in that row is now negative, we know the entire row is painted.</li>
<li>Similarly, we check the entire column for the same condition. If all elements in that column are negative, we know the column is fully painted.</li>
</ul>
<p>If either the row or the column of the marked cell is completely painted, we immediately return the current index in <code>arr</code> since this is the first index, the processing of which resulted in fully painted row or column.</p>
<p>Since <code>mat</code> and <code>arr</code> always contain the same numbers, every cell in <code>mat</code> will eventually be painted. Therefore, we donâ€™t need to account for a scenario where we reach the end of the array without completing a row or column. If such a scenario were possible, we might theoretically return an invalid value (e.g.,<code> -1</code>), but this is not allowed under the given constraints.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to the number of rows and columns in the matrix <code>mat</code>, respectively.</p>
</li>
<li>
<p>Create a <code>numToPos</code> map to store the position (row, column) of each number in the matrix.</p>
</li>
<li>
<p>Populate <code>numToPos</code> by iterating over the matrix <code>mat</code>:</p>
<ul>
<li>For each element <code>value</code> in the matrix, store its position <code>(row, col)</code> in <code>numToPos</code>.</li>
</ul>
</li>
<li>
<p>Iterate over each element <code>num</code> in the array <code>arr</code>:</p>
<ul>
<li>
<p>Retrieve the position <code>(row, col)</code> of <code>num</code> from <code>numToPos</code>.</p>
</li>
<li>
<p>Mark the element in <code>mat[row][col]</code> as seen by negating its value (<code>mat[row][col] = -mat[row][col]</code>).</p>
</li>
<li>
<p>Check if the entire row or column has been marked (i.e., if all values in the row/column are negative):</p>
<ul>
<li>Call <code>checkRow(row, mat)</code> to check if the row is fully marked.</li>
<li>Call <code>checkColumn(col, mat)</code> to check if the column is fully marked.</li>
<li>If either check is <code>true</code>, return the current index <code>i</code> in <code>arr</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>-1</code> (This line is a safeguard and will never be reached because of the problem constraints).</p>
</li>
<li>
<p>The helper functions <code>checkRow(row, mat)</code> and <code>checkColumn(col, mat)</code>:</p>
<ul>
<li>Both functions iterate through the row or column, respectively, to check if all values are negative.</li>
<li>Return <code>true</code> if the entire row or column is fully marked, otherwise <code>false</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: This solution gets a TLE because of high time complexity</p>
</blockquote>
<p><a href="https://leetcode.com/playground/7CbXtgK9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k = m \cdot n\)</span> be the size of <code>arr</code> (since <span class="math inline">\(arr.length == m \cdot n\)</span>), <span class="math inline">\(m\)</span> the number of rows in <code>mat</code>, and <span class="math inline">\(n\)</span> the number of columns in <code>mat</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot (m + n) + m \cdot n)\)</span></p>
<p>We first build a map to store the positions of each element in the matrix, which takes <span class="math inline">\(O(m \cdot n)\)</span> time. Then, we iterate through the array <code>arr</code> and for each element, we check if the corresponding row or column is completely painted. This checking step takes <span class="math inline">\(O(m + n)\)</span> for each element in <code>arr</code>, leading to a total time complexity of <span class="math inline">\(O(k \cdot (m + n) + m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We use a map to store the positions of each element in the matrix, which requires <span class="math inline">\(O(m \cdot n)\)</span> space. Other variables use constant space, so the total space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-brute-force-optimized-with-counting">Approach 2: Brute Force Optimized with Counting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The brute force approach works by iterating over a row and a column after each number is marked, to check whether they have become fully painted.  However, we noticed that this is inefficient and leads to Time Limit Exceeded (TLE) error.</p>
<p>In this approach, instead of checking the entire row or column after each step, we maintain counters for the number of painted cells in of them. This way, we avoid iterating through the entire row and column every time, making the &quot;fully-colored check&quot; a constant-time operation.</p>
<p>Just like in the brute force approach, we first map every number in <code>mat</code> to its position (row and column) using a hashmap <code>numToPos</code>. This allows us to efficiently find where each number from <code>arr</code> appears in <code>mat</code>.</p>
<p>Additionally, we maintain two arrays <code>rowCount</code> and <code>colCount</code> to track how many numbers have been marked in each row and column, respectively. Initially, all values in these arrays are set to <code>0</code>.</p>
<p>Each time a number is marked, we increment the count for its corresponding row and column. This allows us to efficiently track the progress of the marking without re-scanning the whole row or column.</p>
<p>After marking a number, we only need to check if the entire row or column has been filled:</p>
<ul>
<li>If the count of marked numbers in the row (<code>rowCount[row]</code>) is equal to the number of columns, it means the row is fully marked.</li>
<li>Similarly, if the count of marked numbers in the column (<code>colCount[col]</code>) is equal to the number of rows, the column is fully marked.</li>
</ul>
<p>Again, since the problem guarantees that a row or column will eventually be fully marked, we don't need to worry about handling edge cases where no completion happens. The return value of <code>-1</code> is just a safeguard, but it will never be reached given the problem constraints.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to the number of rows and columns in the matrix <code>mat</code>.</p>
</li>
<li>
<p>Create two arrays, <code>rowCount</code> and <code>colCount</code>, to keep track of the number of times each row and column have been &quot;painted&quot;. Initialize all their elements to <code>0</code>.</p>
</li>
<li>
<p>Create a map <code>numToPos</code> to store the position of each number in the matrix.</p>
</li>
<li>
<p>Iterate through the matrix <code>mat</code> to populate <code>numToPos</code> with the position (row, col) of each value in <code>mat</code>.</p>
</li>
<li>
<p>Iterate through the array <code>arr</code>:</p>
<ul>
<li>For each number <code>num</code> in <code>arr</code>, retrieve its position <code>(row, col)</code> from <code>numToPos</code>.</li>
<li>Increment the count of the corresponding row and column in <code>rowCount</code> and <code>colCount</code>.</li>
<li>If the count for the row reaches <code>numCols</code> or the count for the column reaches <code>numRows</code>, return the current index <code>i</code> (indicating the number that completes a row or column).</li>
</ul>
</li>
<li>
<p>Return <code>-1</code> (This line is a safeguard and will never be reached because of the problem constraints).</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gCcgLWPh/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k = m \cdot n\)</span> be the size of <code>arr</code> (since <span class="math inline">\(arr.length == m \cdot n\)</span>), <span class="math inline">\(m\)</span> the number of rows in <code>mat</code>, and <span class="math inline">\(n\)</span> the number of columns in <code>mat</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k) \equiv O(m \cdot n)\)</span></p>
<p>We first build a map to store the positions of each element in the matrix, which takes <span class="math inline">\(O(k)\)</span> time. Then, we iterate through the array <code>arr</code> (of size <span class="math inline">\(m \cdot n\)</span>) and for each element, we update the counts for the corresponding row and column. This step also takes <span class="math inline">\(O(k)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(k) \equiv O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We use a map to store the positions of each element in the matrix, which requires <span class="math inline">\(O(k)\)</span> space. Additionally, we use two arrays (<code>rowCount</code> and <code>colCount</code>) of sizes <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> respectively, contributing <span class="math inline">\(O(m + n)\)</span> space. Thus, the total space complexity is <span class="math inline">\(O(k + m + n) \equiv O((m \cdot n) + m + n) \approx O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-reverse-mapping">Approach 3: Reverse Mapping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In Approach 2, we were checking the count of &quot;painted&quot; elements for each row and column after every marking operation. Now, instead of that, we track the greatest index at which an element of each row and column occurs in <code>arr</code>. This will reduce space usage and eliminate the need for redundant checks, as we wonâ€™t need the <code>rowCount</code> and <code>colCount</code> arrays anymore.</p>
<p>Similarly to the previous approaches, we begin by mapping each number to its position (index)  in <code>arr</code>, using a hashmap, <code>numToIndex</code>.</p>
<p>Instead of counting marked numbers, we consider a different question: When will a row or column be fully painted? Intuitively, this happens when all the numbers in that row or column have been processed. Building on this idea, we observe that it suffices to track the latest index in <code>arr</code> where each number in a row or column appears. If we know the greatest index for any element in a row or column, that row or column will be fully painted once that index is reached.</p>
<p>For example, consider a row of <code>mat</code>, which contains the numbers 3, 5, and 8. If their indices in <code>arr</code> are 1, 3, and 2 respectively, the row will be fully painted when index 3 (the largest index for any number in that row) in arr is reached.</p>
<p>After determining the greatest index for each row and column, we identify the row or column with the smallest maximum index, as this represents the first to be fully painted.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2661/reverse_mapping.json:880,790!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a <code>numToIndex</code> unordered map to store the index of each element from <code>arr</code>.</p>
</li>
<li>
<p>Populate <code>numToIndex</code> by iterating over the <code>arr</code> and recording the index of each element.</p>
</li>
<li>
<p>Initialize <code>lastElementIndex</code> to <code>INT_MAX</code> and <code>result</code> to <code>INT_MIN</code> to track the earliest complete row or column.</p>
</li>
<li>
<p>Initialize <code>numRows</code> and <code>numCols</code> to the number of rows and columns in the matrix <code>mat</code>, respectively.</p>
</li>
<li>
<p>Check for the earliest row to be completely painted:</p>
<ul>
<li>Iterate through each row in the matrix <code>mat</code>:
<ul>
<li>Initialize <code>result</code> to <code>INT_MIN</code> for each row.</li>
<li>Iterate through each column in the current row:
<ul>
<li>For each element in the row, find its index in <code>numToIndex</code> and update <code>result</code> with the maximum of its current value and index of the current element in <code>arr</code>.</li>
</ul>
</li>
<li>Update <code>lastElementIndex</code> with the minimum of <code>lastElementIndex</code> and the row's <code>result</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check for the earliest column to be completely painted:</p>
<ul>
<li>Iterate through each column in the matrix <code>mat</code>:
<ul>
<li>Initialize <code>result</code> to <code>INT_MIN</code> for each column.</li>
<li>Iterate through each row in the current column:
<ul>
<li>For each element in the column, find its index in <code>numToIndex</code> and update <code>result</code> with the maximum index value.</li>
</ul>
</li>
<li>Update <code>lastElementIndex</code> with the minimum of <code>lastElementIndex</code> and the column's <code>result</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>lastElementIndex</code>, which represents the earliest index where a row or column has been completely painted.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/VohmeeNQ/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k = m \cdot n\)</span> be the size of <code>arr</code> (since <span class="math inline">\(arr.length == m \cdot n\)</span>), <span class="math inline">\(m\)</span> the number of rows in <code>mat</code>, and <span class="math inline">\(n\)</span> the number of columns in <code>mat</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We first build a map to store the index of each element in <code>arr</code>, which takes <span class="math inline">\(O(k)\)</span> time. Then, we check for the earliest row and column to be completely painted, which takes <span class="math inline">\(O(m \cdot n)\)</span> time. Since <span class="math inline">\(k = m \cdot n\)</span>, the total time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k) \equiv O(m\cdot n)\)</span></p>
<p>We use a map to store the index of each element in <code>arr</code>, which requires <span class="math inline">\(O(k)\)</span> space. Other variables use constant space, so the total space complexity is <span class="math inline">\(O(k) \equiv O(m\cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/description" target="_blank" rel="noopener noreferrer">Flip Columns For Maximum Number of Equal Rows</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>matrix</code>.</p>

<p>You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from <code>0</code> to <code>1</code> or vice versa).</p>

<p>Return <em>the maximum number of rows that have all values equal after some number of flips</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[0,1],[1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> After flipping no values, 1 row has all values equal.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[0,1],[1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> After flipping values in the first column, both rows have equal values.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[0,0,0],[0,0,1],[1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> After flipping values in the first two columns, the last two rows have equal values.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>matrix[i][j]</code> is either&nbsp;<code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>Our task is to make as many rows as possible in the matrix consist of identical values (either all 0s or all 1s) using only one type of move: flipping entire columns.</p>
<p>On closer inspection, you will see there are only two possible scenarios to look out for:</p>
<p>For the first, let's consider a 3 x 3 grid:</p>
<pre><code>+---+---+---+
| 0 | 1 | 0 |
+---+---+---+
| 0 | 1 | 0 |
+---+---+---+
| 1 | 1 | 0 |
+---+---+---+
</code></pre>
<p>We can see from this grid that flipping columns to make the first row uniform will make the second row uniform, as well. However, the third row remains non-uniform since it does not match the first row.</p>
<p>Now, let's look at our second scenario:</p>
<pre><code>+---+---+---+---+
| 0 | 1 | 0 | 0 |
+---+---+---+---+
| 1 | 0 | 1 | 1 |
+---+---+---+---+
| 0 | 1 | 0 | 0 |
+---+---+---+---+
| 0 | 1 | 1 | 0 |
+---+---+---+---+
</code></pre>
<p>The first two rows are perfect opposites. Flipping the second column to make the first row uniform will have the positive side effect of making the values in the second row uniform, as well. Additionally, as in the first scenario, the third row will now become uniform. However, the fourth row remains non-uniform since it is neither identical nor exactly opposite.</p>
<p>This means that our answer boils down to this: the rows that can be made uniform (all values in the row are the same) after flipping will be the combined total of rows that are identical and rows that are exactly opposite.</p>
<p>We'll loop over each row in the given matrix to determine which approach is best. For each row, we count the number of other rows in the matrix that are exactly the same and that are exactly opposite. The highest count across all rows will be our answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a variable:
<ul>
<li><code>numCols</code> to store the number of columns in the matrix by accessing the length of the first row.</li>
<li><code>maxIdenticalRows</code> to track the maximum count of identical rows found so far.</li>
</ul>
</li>
<li>Iterate through each row <code>currentRow</code> of the matrix:
<ul>
<li>Initialize:
<ul>
<li>an array <code>flippedRow</code> of size <code>numCols</code> to store the flipped version of the current row.</li>
<li>a counter <code>identicalRowCount</code> to track rows matching either the current pattern or its flipped version.</li>
</ul>
</li>
<li>Create the flipped version by iterating through each column:
<ul>
<li>Set each element of <code>flippedRow</code> to the complement (1 - value) of the corresponding element in <code>currentRow</code>.</li>
</ul>
</li>
<li>Iterate through each row of the matrix again as <code>compareRow</code>:
<ul>
<li>Compare <code>compareRow</code> with both <code>currentRow</code> and <code>flippedRow</code>.</li>
<li>If <code>compareRow</code> matches either pattern, increment <code>identicalRowCount</code>.</li>
</ul>
</li>
<li>Update <code>maxIdenticalRows</code> to the larger value between itself and <code>identicalRowCount</code>.</li>
</ul>
</li>
<li>Return <code>maxIdenticalRows</code> as the final result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hPcGzMKT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m)\)</span></p>
<p>The outer loop iterates through each row of the matrix. For each row, the algorithm creates its flipped version (<span class="math inline">\(m\)</span> operations) and then compares it with every other row in the matrix (<span class="math inline">\(n\)</span> comparisons, each requiring <span class="math inline">\(m\)</span> operations for array comparison).</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n \cdot n \cdot m) = O(n^2 \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The only additional space used is for storing the <code>flippedRow</code> array, which has a length equal to <span class="math inline">\(m\)</span>.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-hash-map">Approach 2: Hash Map</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Notice that a row and its complement actually form the same pattern, just with opposite digits. To illustrate this, let's take the 2 x 2 grid again:</p>
<pre><code>+---+---+
| 0 | 1 |
+---+---+
| 1 | 0 |
+---+---+
</code></pre>
<p>To represent the pattern in a more abstract way, let's use 'T' for the first digit in each row and 'F' for its opposite. In the first row, 'T' stands for 0, while in the second row, 'T' stands for 1. Essentially, we are replacing every number in a row with a symbol signifying whether the number is equal to the first number in the grid. If we rewrite our grid using these symbols, it becomes a bit easier to see the underlying structure.</p>
<pre><code>+---+---+
| T | F |   // T = 0
+---+---+
| T | F |   // T = 1
+---+---+
</code></pre>
<p>This means that if we replace each row with a unique pattern that represents it, then identical and even complementary rows will share the same pattern. The below illustration visualizes this concept:</p>
<p><img src="../Figures//1072/TFpic.png" alt="" /></p>
<p>So, our task simplifies to just finding the pattern that shows up the most often. To do this, weâ€™ll go through each row in the matrix, converting it into its pattern string. Then, weâ€™ll use a map called <code>patternFrequency</code> to keep track of how many times each pattern appears. Once weâ€™ve done that, weâ€™ll just look through all the values in the map, find the highest frequency, and return that as our answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a map <code>patternFrequency</code> to store patterns and their frequencies.</li>
<li>Iterate through each row <code>currentRow</code> of the matrix:
<ul>
<li>Initialize a string <code>patternBuilder</code> to construct the pattern.</li>
<li>For each element in the row:
<ul>
<li>Compare it with the first element of the row.</li>
<li>Append 'T' to the pattern if the current element matches the first element.</li>
<li>Append 'F' to the pattern if the current element differs from the first element.</li>
</ul>
</li>
<li>Convert the constructed pattern to a string <code>rowPattern</code>.</li>
<li>Update the frequency of <code>rowPattern</code> in the map.</li>
</ul>
</li>
<li>Initialize a variable <code>maxFrequency</code> to track the highest frequency found.</li>
<li>Iterate through all frequencies in the map:
<ul>
<li>Update <code>maxFrequency</code> to the larger value between itself and current frequency.</li>
</ul>
</li>
<li>Return <code>maxFrequency</code> as the final result.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Zvf6p6xz/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The outer loop iterates through each of the <span class="math inline">\(n\)</span> rows in the matrix. For each row, we create a pattern by examining each element of the row, which takes <span class="math inline">\(m\)</span> operations.</p>
<p>The final loop through the map is bounded by <span class="math inline">\(n\)</span> as there cannot be more unique patterns than rows.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n \cdot m + n)\)</span> = <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The <code>patternFrequency</code> map stores the patterns as keys and their frequencies as values. The length of each pattern is <span class="math inline">\(m\)</span> and there can be at most <span class="math inline">\(n\)</span> unique patterns (equal to the number of rows).</p>
<p>Thus, the space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flipping-an-image/description" target="_blank" rel="noopener noreferrer">Flipping an Image</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> binary matrix <code>image</code>, flip the image <strong>horizontally</strong>, then invert it, and return <em>the resulting image</em>.</p>

<p>To flip an image horizontally means that each row of the image is reversed.</p>

<ul>
	<li>For example, flipping <code>[1,1,0]</code> horizontally results in <code>[0,1,1]</code>.</li>
</ul>

<p>To invert an image means that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>.</p>

<ul>
	<li>For example, inverting <code>[0,1,1]</code> results in <code>[1,0,0]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> image = [[1,1,0],[1,0,1],[0,0,0]]
<strong>Output:</strong> [[1,0,0],[0,1,0],[1,1,1]]
<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
<strong>Output:</strong> [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == image.length</code></li>
	<li><code>n == image[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>images[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can do this in place.  In each row, the <code>i</code>th value from the left is equal to the inverse of the <code>i</code>th value from the right.</p>
<p>We use <code>(C+1) / 2</code> (with floor division) to iterate over all indexes <code>i</code> in the first half of the row, including the center.</p>
<p><a href="https://leetcode.com/playground/8fjB4LMj/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <code>N</code> is the total number of elements in <code>A</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span> in <em>additional</em> space complexity.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flip-square-submatrix-vertically/description" target="_blank" rel="noopener noreferrer">Flip Square Submatrix Vertically</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, and three integers <code>x</code>, <code>y</code>, and <code>k</code>.</p>

<p>The integers <code>x</code> and <code>y</code> represent the row and column indices of the <strong>top-left</strong> corner of a <strong>square</strong> submatrix and the integer <code>k</code> represents the size (side length) of the square submatrix.</p>

<p>Your task is to flip the submatrix by reversing the order of its rows vertically.</p>

<p>Return the updated matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/07/20/gridexmdrawio.png" style="width: 300px; height: 116px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = </span>[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]<span class="example-io">, x = 1, y = 0, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The diagram above shows the grid before and after the transformation.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/07/20/gridexm2drawio.png" style="width: 350px; height: 68px;" />â€‹â€‹â€‹â€‹â€‹â€‹â€‹
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,4,2,3],[2,3,4,2]], x = 0, y = 2, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[3,4,4,2],[2,3,2,3]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The diagram above shows the grid before and after the transformation.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
	<li><code>0 &lt;= x &lt; m</code></li>
	<li><code>0 &lt;= y &lt; n</code></li>
	<li><code>1 &lt;= k &lt;= min(m - x, n - y)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flood-fill/description" target="_blank" rel="noopener noreferrer">Flood Fill</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an image represented by an <code>m x n</code> grid of integers <code>image</code>, where <code>image[i][j]</code> represents the pixel value of the image. You are also given three integers <code>sr</code>, <code>sc</code>, and <code>color</code>. Your task is to perform a <strong>flood fill</strong> on the image starting from the pixel <code>image[sr][sc]</code>.</p>

<p>To perform a <strong>flood fill</strong>:</p>

<ol>
	<li>Begin with the starting pixel and change its color to <code>color</code>.</li>
	<li>Perform the same process for each pixel that is <strong>directly adjacent</strong> (pixels that share a side with the original pixel, either horizontally or vertically) and shares the <strong>same color</strong> as the starting pixel.</li>
	<li>Keep <strong>repeating</strong> this process by checking neighboring pixels of the <em>updated</em> pixels&nbsp;and modifying their color if it matches the original color of the starting pixel.</li>
	<li>The process <strong>stops</strong> when there are <strong>no more</strong> adjacent pixels of the original color to update.</li>
</ol>

<p>Return the <strong>modified</strong> image after performing the flood fill.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[2,2,2],[2,2,0],[2,0,1]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg" style="width: 613px; height: 253px;" /></p>

<p>From the center of the image with position <code>(sr, sc) = (1, 1)</code> (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.</p>

<p>Note the bottom corner is <strong>not</strong> colored 2, because it is not horizontally or vertically connected to the starting pixel.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0</span></p>

<p><strong>Output:</strong> <span class="example-io">[[0,0,0],[0,0,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == image.length</code></li>
	<li><code>n == image[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>0 &lt;= image[i][j], color &lt; 2<sup>16</sup></code></li>
	<li><code>0 &lt;= sr &lt; m</code></li>
	<li><code>0 &lt;= sc &lt; n</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>We perform the algorithm explained in the problem description: paint the starting pixels, plus adjacent pixels of the same color, and so on.</p>
<p><strong>Algorithm</strong></p>
<p>Say <code>color</code> is the color of the starting pixel. Let's flood fill the starting pixel: we change the color of that pixel to the new color, then check the 4 neighboring pixels to make sure they are valid pixels of the same <code>color</code>, and of the valid ones, we flood fill those, and so on.</p>
<p>We can use a function <code>dfs</code> to perform a flood fill on a target pixel.</p>
<p><a href="https://leetcode.com/playground/StwTP8bA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of pixels in the image. We might process every pixel.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of the implicit call stack when calling <code>dfs</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/flood-fill-algorithm1856/1" target="_blank" rel="noopener noreferrer">Flood fill Algorithm</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a 2D grid <strong>image[][] </strong>of size n*m, where each <strong>image[i][j]</strong> represents the color of a pixel in the image. Also provided a coordinate<strong>(sr, sc) </strong>representing the <strong>starting pixel</strong> (row and column) and a <strong>new color</strong> value <strong>newColor</strong>.</span></p>
<p><span style="font-size: 14pt;">Your task is to perform a <strong>flood fill</strong> starting from the pixel <strong>(sr, sc)</strong>, changing its color to <strong>newColor</strong> and the color of all the connected pixels that have the same <strong>original color</strong>. Two pixels are considered connected if they are adjacent <strong>horizontally or vertically</strong> (not diagonally) and have the <strong>same original color</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong style="font-size: 18.6667px;">Input: </strong><span style="font-size: 18.6667px;">image[][] = [[1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1]], sr = 1, sc = 2, newColor = 2<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705720/Web/Other/blobid0_1744378665.jpg" width="258" height="228" /><br /><strong>Output:</strong> [[2, 2, 2, 0], [0, 2, 2, 2], [1, 0, 2, 2]]<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705720/Web/Other/blobid1_1744378699.jpg" width="253" height="224" /><br /><strong>Explanation:</strong> Starting from pixel (1, 2) with value 1, flood fill updates all connected pixels (up, down, left, right) with value 1 to 2, resulting in [[2, 2, 2, 0], [0, 2, 2, 2], [1, 0, 2, 2]].</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>image[][] = [[1, 1, 1], [1, 1, 0], [1, 0, 1]], sr = 1, sc = 1, newColor = 2
<strong>Output: </strong>[[2, 2, 2], [2, 2, 0], [2, 0, 1]]
<strong>Explanation: </strong>From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>image[][] = [[0, 1, 0], [0, 1, 0]], sr = 0, sc = 1, newColor = 0
<strong>Output: </strong>[[0, 0, 0], [0, 0, 0]]
<strong>Explanation: </strong>Starting from pixel (0, 1) with value 1, flood fill changes all 4-directionally connected pixels with value 1 to 0, resulting in [[0, 0, 0], [0, 0, 0]]</span><span style="font-size: 14pt;"><br /></span></pre>
<div><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n &le; m &le; 500<br />0 &le; image[i][j] &le; 10</span></div>
<div><span style="font-size: 14pt;">0 &le; newColor &le; 10</span></div>
<div><span style="font-size: 14pt;">0 &le; sr &le; (n-1)</span></div>
<div><span style="font-size: 14pt;">0 &le; sc &le; (m-1)</span></div></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/form-coils-in-a-matrix4726/1" target="_blank" rel="noopener noreferrer">Form coils in a matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a positive integer <strong>n</strong> that represents dimensions of a 4n x 4n matrix with values from 1 to 4*n*4*n filled from left to right and top to bottom. Your task is to form two coils from matrix and print the coils.</span></p>

<p><span style="font-size:18px">Follow the given examples for better understanding.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>n = </strong>1</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">10 6 2 3 4 8 12 16
7 11 15 14 13 9 5 1</span> 
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The matrix is </span>
<span style="font-size:18px">1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16</span>
<span style="font-size:18px">So, the two coils are as given in the Ouput.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>n = </strong>2</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">36 28 20 21 22 30 38 46
54 53 52 51 50 42 34 26
18 10 2 3 4 5 6 7 8
16 24 32 40 48 56 64

29 37 45 44 43 35 27 19
11 12 13 14 15 23 31 39
47 55 63 62 61 60 59 58
57 49 41 33 25 17 9 1 </span> 
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px"><img alt="" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/MatrixCoil.jpg" style="height:266px; width:400px" />
</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>formCoils()</strong> which takes an Integer n as input and returns a vector of two vectors representing coil1 and coil2.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(n<sup>2</sup>)<br />
<strong>Expected Auxiliary Space:</strong> O(n<sup>2</sup>)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">1 &lt;= n &lt;= 20</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/game-of-life/description" target="_blank" rel="noopener noreferrer">Game of Life</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>According to <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>

<p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <b>live</b> (represented by a <code>1</code>) or <b>dead</b> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>

<ol>
	<li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li>
	<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
	<li>Any live cell with more than three live neighbors dies, as if by over-population.</li>
	<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>

<p><span>The next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the <code>m x n</code> grid <code>board</code>. In this process, births and deaths occur <strong>simultaneously</strong>.</span></p>

<p><span>Given the current state of the <code>board</code>, <strong>update</strong> the <code>board</code> to reflect its next state.</span></p>

<p><strong>Note</strong> that you do not need to return anything.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" style="width: 562px; height: 322px;" />
<pre>
<strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
<strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" style="width: 402px; height: 162px;" />
<pre>
<strong>Input:</strong> board = [[1,1],[1,0]]
<strong>Output:</strong> [[1,1],[1,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 25</code></li>
	<li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</li>
	<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geeks-island--170646/1" target="_blank" rel="noopener noreferrer">Geeks Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">dfs</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geeks Island is represented by an&nbsp;<strong>N * M</strong>&nbsp;matrix&nbsp;<strong>mat</strong>. The island is touched by the Indian Ocean from the top and left edges and the Arabian Sea from the right and bottom edges. Each element of the matrix represents the height of the cell.</span></p>

<p><span style="font-size:18px">Due to the rainy season, the island receives a lot of rainfall, and the water can flow in four directions(up, down, left, or right) from one cell to another one with&nbsp;<strong>height equal or lower</strong>.</span></p>

<p><span style="font-size:18px">You need to find the number of cells from where water can flow to both the Indian Ocean and the Arabian Sea.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px">N = 5, M = 5</span>
<span style="font-size:18px">mat[][] =    {{1, 3, 3, 2, 4},
               </span><span style="font-size:18px">{4, 5, 6, 4, 4},</span>
               <span style="font-size:18px">{2, 4, 5, 3, 1},</span>
               <span style="font-size:18px">{6, 7, 1, 4, 5},</span>
               <span style="font-size:18px">{6, 1, 1, 3, 4}}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">8</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">Indian    ~   ~   ~   ~   ~
Ocean  ~  1   3   3   2  (4) *
        ~  4   5  (6) (4) (4) *
        ~  2   4  (5)  3   1  *
        ~ (6) (7)  1   4   5  *
        ~ (6)  1   1   3   4  *           
&nbsp;          *   *   *   *   * Arabian Sea</span>
<span style="font-size:18px">Water can flow to both ocean and sea from the cells
denoted by parantheses().For example at index(1,2), the height of that island is 6. If a water drop falls on that island, water can flow to up direction(as 3&lt;=6) and reach to Indian Ocean. ALso, water can flow to right direction(as 6&gt;=4&gt;=4) and reach to Arabian Sea.</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<strong><span style="font-size:18px">Input:</span></strong>
<span style="font-size:18px">N = 2, M = 3</span>
<span style="font-size:18px">mat[][] =    {{1, 1, 1},</span>
               <span style="font-size:18px">{1, 1, 1}}</span>
<strong><span style="font-size:18px">Output:</span></strong>
<span style="font-size:18px">6 </span>
<strong><span style="font-size:18px">Explanation:</span></strong>
<span style="font-size:18px">Water can flow from all cells to both Indian Ocean and Arabian Sea as the height of all islands are same.</span></pre>

<p><strong><span style="font-size:18px">Your Task:</span></strong></p>

<p><span style="font-size:18px">Your task is to complete the function <strong>water_flow()&nbsp;</strong>which takes an integer array <strong>mat</strong>, integer <strong>N</strong> and integer <strong>M</strong>&nbsp;as the input parameter and returns an integer, denoting the number of cells from which water can to both ocean and sea.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity</strong> : O(</span><span style="font-size:18px">N*M</span><span style="font-size:18px">)<br />
<strong>Expected Auxiliary Space</strong> : O(N*M)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span></p>

<ul>
	<li><span style="font-size:18px">1 &lt;= N, M &lt;= 10<sup>3</sup></span></li>
	<li><span style="font-size:18px">1 &lt;= mat[i][j] &lt;= 10<sup>6</sup></span></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/geeks-village-and-wells--170647/1" target="_blank" rel="noopener noreferrer">Geek&#39;s Village and Wells</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Geek&#39;s village is represented by a 2-D matrix of characters of size n*m, where</span></p>

<p><span style="font-size:18px">H - Represents a house<br />
W - Represents a well<br />
. - Represents an open ground<br />
N - Prohibited area(Not allowed to enter this area)</span></p>

<p><span style="font-size:18px">Every house in the village needs to take water from a well, as the family members are so busy with their work, so every family wants to take the water from a well in minimum time, which is possible only if they have to cover as less distance as possible. Your task is to determine the minimum distance that a person in the house should travel to take out the water and carry it back to the house.</span></p>

<p><span style="font-size:18px">A person is allowed to move only in four directions left, right, up, and down. That means if he/she is the cell (i,j), then the possible cells he/she can reach in one move are (i,j-1),(i,j+1),(i-1,j),(i+1,j), and the person is not allowed to move out of the grid.</span></p>

<p><span style="font-size:18px"><strong>Note:</strong> For all the cells containing &#39;N&#39;, &#39;W&#39; and &#39;.&#39; our answer should be 0, and for all the houses where there is no possibility of taking water our answer should be -1.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 3
m = 3
c[][]: H H H
       H W H
&nbsp;      H H H</span>
<span style="font-size:18px"><strong>Output:</strong>
4 2 4 
2 0 2 
4 2 4</span>
<span style="font-size:18px"><strong>Explanation:</strong>
There is only one well hence all the houses present
in the corner of matrix will have to travel a minimum
distance of 4, 2 is for house to well and other two is
for well to house. And rest of the houses have to travel
a minimum distance of 2 (House -&gt; Well -&gt; House).</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
n = 5
m = 5
c[][]: H N H H H
&nbsp;      N N H H W
&nbsp;      W H H H H
&nbsp;      H H H H H
&nbsp;      H H H H H</span>
<span style="font-size:18px"><strong>Output:</strong>
-1 0 6 4 2 
0 0 4 2 0 
0 2 4 4 2 
2 4 6 6 4 
4 6 8 8 6</span>
<span style="font-size:18px"><strong>Explanation:</strong>
There is no way any person from the house in
cell (0,0) can take the water from any well, and
for rest of the houses there is same type of
strategy we have to follow as followed in example 1. </span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function geekAndWells() which takes n and m, dimensions of the grid, and a 2-D grid of size n*m and returns a 2-D array containing the minimum distance for all the houses as explained above.</span></p>

<p><strong><span style="font-size:18px">Expected Time Complexity: O(n*m)<br />
Expected Space Complexity: O(n*m)</span></strong></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n &lt;= 10^3<br />
1 &lt;= m &lt;= 10^3</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/generalised-fibonacci-numbers1820/1" target="_blank" rel="noopener noreferrer">Generalised Fibonacci numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">matrix</span> <span class="topic-badge">modulararithmetic</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Consider the generalized Fibonacci number <strong>g</strong>, which is dependent on <strong>a</strong>, <strong>b</strong> and <strong>c</strong> as follows :-<br /><strong>g</strong>(1) = 1, <strong>g</strong>(2) = 1. For any other number&nbsp;<strong>n, </strong><strong>g</strong>(n) = <strong>a*g</strong>(n-1) + <strong>b*g</strong>(n-2) + <strong>c</strong>.</span></p>
<p><span style="font-size: 18px;">For a given value of <strong>m</strong>, determine <strong>g(n)%m</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>a = </strong>3<br /><strong>b = </strong>3<br /><strong>c = </strong>3<br /><strong>n = </strong>3<br /><strong>m = </strong>5</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">4</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">g(1) = 1 and g(2) = 1 <br /></span><span style="font-size: 18px;">g(3) = 3*g(2) + 3*g(1) + 3 = 3*1 + 3*1 + 3 = 9<br /></span><span style="font-size: 18px;">We need to return answer modulo 5, so 9%5 = 4, is the answer.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>a = </strong>2<br /><strong>b = </strong>2<br /><strong>c = </strong>2<br /><strong>n = </strong>4<br /><strong>m = </strong>100</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">16</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">g(1) = 1 and g(2) = 1<br /></span><span style="font-size: 18px;">g(3) = 2*g(2) + 2*g(1) + 2 = 2*1 + 2*1 + 2 = 6<br />g(4) = 2*g(3) + 2*g(2) + 2  = 2*6 + 2*1 + 2 = 16<br />We need to return answer modulo 100, so 16%100 = 16, is the answer.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>genFibNum()</strong> which takes 5 Integers <strong>a, b, c, n</strong>, and <strong>m</strong> as input and returns <strong>g(n)%m.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O( log(n) ).<br /><strong>Expected Auxiliary Space:</strong> O(1).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= a, b, c, n, m &lt;= 10<sup>9</sup>+7</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/generate-a-matrix-with-each-row-and-column-of-given-sum/1" target="_blank" rel="noopener noreferrer">Generate a matrix with each row and column of given sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">Given two integer arrays&nbsp;<strong>rowSum[]&nbsp;</strong>of size<strong>&nbsp;n</strong>&nbsp;and&nbsp;<strong>colSum[]&nbsp;</strong>of size<strong>&nbsp;m</strong>, the task is to construct a 2D matrix of size&nbsp;<strong>n x m</strong>&nbsp;such that the sum of matrix elements in&nbsp;<strong>i</strong>th row is&nbsp;<strong>rowSum[i]</strong>&nbsp;and the sum of matrix elements in&nbsp;<strong>j</strong>th column is&nbsp;<strong>colSum[j]</strong>.<br />Note:<strong>&nbsp;</strong></span><span style="font-size: 18.6667px;">Since multiple answers are possible, return any one of them.&nbsp;<br />Arrays are generated such that answer is always<strong> possible</strong>.<br /></span><span style="font-size: 18.6667px;">The driver code will print true if output matrix is correct, otherwise it will print false.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>rowSum[] = [5, 7, 10], colSum[] = [8, 6, 8]
<strong>Output:</strong> true
<strong>Explanation:</strong> For the matrix [[0, 5, 0], [6, 1, 0], [2, 0, 8]], we have r</span><span style="font-size: 18.6667px;">ow 1 with sum equal to 5 and column 1 has sum equal to 8.Row 2 has sum equal to 7 and column 2 has sum equal to 6.Row 3 has sum equal to 10 and column 3 has sum equal to 8.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>rowSum[] = [1, 0], colSum[] = [1]<br /><strong>Output:</strong> true
<strong>Explanation:</strong> For the matrix [[1], [0]], we have r</span><span style="font-size: 18.6667px;">ow 1 with sum equal to 1 and column 1 has sum equal to 1.Row 2 with sum equal to 0.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= n, m &lt;= 10<sup>3</sup><br />1 &lt;= rowSum[i] &lt;= 10<sup>3</sup><br />1 &lt;= colSum[i] &lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/description" target="_blank" rel="noopener noreferrer">Get Biggest Three Rhombus Sums in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>â€‹â€‹â€‹.</p>

<p>A <strong>rhombus sum</strong> is the sum of the elements that form <strong>the</strong> <strong>border</strong> of a regular rhombus shape in <code>grid</code>â€‹â€‹â€‹. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each <strong>rhombus sum</strong>:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png" style="width: 385px; height: 385px;" />
<p>Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.</p>

<p>Return <em>the biggest three <strong>distinct rhombus sums</strong> in the </em><code>grid</code><em> in <strong>descending order</strong></em><em>. If there are less than three distinct values, return all of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png" style="width: 360px; height: 361px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
<strong>Output:</strong> [228,216,211]
<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 20 + 3 + 200 + 5 = 228
- Red: 200 + 2 + 10 + 4 = 216
- Green: 5 + 200 + 4 + 2 = 211
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png" style="width: 217px; height: 217px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [20,9,8]
<strong>Explanation:</strong> The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 4 + 2 + 6 + 8 = 20
- Red: 9 (area 0 rhombus in the bottom right corner)
- Green: 8 (area 0 rhombus in the bottom middle)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[7,7,7]]
<strong>Output:</strong> [7]
<strong>Explanation:</strong> All three possible rhombus sums are the same, so return [7].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/grid-game/description" target="_blank" rel="noopener noreferrer">Grid Game</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D array <code>grid</code> of size <code>2 x n</code>, where <code>grid[r][c]</code> represents the number of points at position <code>(r, c)</code> on the matrix. Two robots are playing a game on this matrix.</p>

<p>Both robots initially start at <code>(0, 0)</code> and want to reach <code>(1, n-1)</code>. Each robot may only move to the <strong>right</strong> (<code>(r, c)</code> to <code>(r, c + 1)</code>) or <strong>down </strong>(<code>(r, c)</code> to <code>(r + 1, c)</code>).</p>

<p>At the start of the game, the <strong>first</strong> robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting all the points from the cells on its path. For all cells <code>(r, c)</code> traversed on the path, <code>grid[r][c]</code> is set to <code>0</code>. Then, the <strong>second</strong> robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting the points on its path. Note that their paths may intersect with one another.</p>

<p>The <strong>first</strong> robot wants to <strong>minimize</strong> the number of points collected by the <strong>second</strong> robot. In contrast, the <strong>second </strong>robot wants to <strong>maximize</strong> the number of points it collects. If both robots play <strong>optimally</strong>, return <em>the <b>number of points</b> collected by the <strong>second</strong> robot.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a1.png" style="width: 388px; height: 103px;" />
<pre>
<strong>Input:</strong> grid = [[2,5,4],[1,5,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a2.png" style="width: 384px; height: 105px;" />
<pre>
<strong>Input:</strong> grid = [[3,3,1],[8,5,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a3.png" style="width: 493px; height: 103px;" />
<pre>
<strong>Input:</strong> grid = [[1,3,1,15],[1,3,3,1]]
<strong>Output:</strong> 7
<strong>Explanation: </strong>The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == 2</code></li>
	<li><code>n == grid[r].length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[r][c] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a matrix <code>grid</code> containing 2 rows and <code>n</code> columns. Each cell contains a value representing the number of points for that cell in the <code>grid</code>. Two robots are playing a game where they are initially positioned at <code>(0, 0)</code> and aim to reach <code>(1, n - 1)</code>.</p>
<p>Each robot can only move right or down in the grid. The task is to compute the points collected by the second robot, given the strategies of both robots.</p>
<p>The challenge is that the first robot moves first, and its goal is to reduce the points available for the second robot. The second robot then takes the best path to collect as many points as possible.</p>
<hr />
<h3 id="approach-prefix-and-suffix-sum">Approach: Prefix and Suffix Sum</h3>
<h4 id="intuition">Intuition</h4>
<p>A key observation from the overview is that the number of opportunities the second robot has to move to the bottom row corresponds to the number of columns in the grid. When the first robot collects all the points on its way, it leaves a pattern of <code>0</code>-valued cells behind. The pattern looks like this: there will be some <code>0</code>-valued consecutive cells (possibly none) in the first row, two <code>0</code>-valued cells in the same column where it moves to the bottom row, and the remaining cells in the bottom row are also <code>0</code>-valued. This creates a &quot;cut&quot; through the grid where the first robot has moved, leaving the rest of the grid available for the second robot.</p>
<p><img src="../Figures/2017/Turn_image.png" alt="example" /></p>
<p>Now, consider the choices left for the second robot:</p>
<ul>
<li>
<p>The second robot must now choose how to move, given that parts of the grid are now blocked by the first robot's path. If the second robot moves to the second row at a point further down than where the first robot turned, it will need to collect points from the first row from that point onward. Since the bottom row is already collected, the optimal strategy for the second robot will be to collect points from the remaining cells of the top row before it reaches its target.</p>
</li>
<li>
<p>Alternatively, the second robot could move to the second row at the first column and collect all the points in the second row until it reaches the point where the first robot made its turn.</p>
</li>
</ul>
<p>Refer to the image provided for better understanding:</p>
<p><img src="../Figures/2017/image2.png" alt="example" /></p>
<p>To summarize, we have only two possibilities for the second robot, assuming the first robot moves to the next row at index <code>turnIndex</code>:</p>
<ul>
<li>Option 1: Collect all points in the first row after the point where the first robot moved down.</li>
<li>Option 2: Collect all points in the second row before the point where the first robot moved down.</li>
</ul>
<p>To optimize the second robot's decision-making, we maintain two running sums:</p>
<ul>
<li><code>firstRowSum</code>: The sum of points in the first row, initially set to the sum of all the points in the first row.</li>
<li><code>secondRowSum</code>: The sum of points in the second row, initially set to the sum of all the points in the second row.</li>
</ul>
<p>As we iterate through all possible values for the first robotâ€™s turn (<code>turnIndex</code>), we adjust these sums to reflect the points the second robot can collect based on its own movement strategy. Specifically:</p>
<ol>
<li>For each <code>turnIndex</code>, calculate the sum of points the second robot would collect if it follows <em>Option 1</em> (from the first row after the <code>turnIndex</code>).</li>
<li>Alternatively, calculate the sum if it follows <em>Option 2</em> (from the second row before the <code>turnIndex</code>).</li>
</ol>
<p>Finally, we compute the smallest value among the largest outcomes of these two strategies (because the goal is to reduce the highest possible points the second robot can collect).</p>
<blockquote>
<p>Notice that the problem is not the same as finding the highest number of points the first robot can collect. For example, if <code>grid = [[2, 4, 6], [8, 9, 10]]</code>, the first robot could take the path <code>2 -&gt; 8 -&gt; 9 -&gt; 10</code> to maximize its points, leaving <code>4</code> and <code>6</code> for the second robot. But the better strategy is for the first robot to turn down at index <code>1</code>, leaving either <code>6</code> or <code>8</code> for the second robot, which would then get <code>max(6, 8) = 8</code> points instead of <code>10</code>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize <code>firstRowSum</code> with the sum of all elements in the first row of <code>grid</code>. Initialize <code>secondRowSum</code> as <code>0</code>.</p>
</li>
<li>
<p>Set <code>minimumSum</code> to a very large value (<code>LONG_LONG_MAX</code>).</p>
</li>
<li>
<p>Iterate through the indices of the first row:</p>
<ul>
<li>Subtract the current element of the first row from <code>firstRowSum</code>.</li>
<li>Calculate the maximum value between <code>firstRowSum</code> and <code>secondRowSum</code>; This would be the highest number of points the second robot can get if the first robot turns down at the current index.</li>
<li>Update <code>minimumSum</code> with the smaller value between <code>minimumSum</code> and the calculated maximum.</li>
<li>Add the current element of the second row to <code>secondRowSum</code>.</li>
</ul>
</li>
<li>
<p>Return <code>minimumSum</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4JkwKvH/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through each column of the <code>grid</code> exactly once. For each column, it updates the sums of the first and second rows and computes the minimum of the maximum values. These operations take constant time for each column. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, including variables for <code>firstRowSum</code>, <code>secondRowSum</code>, and <code>minimumSum</code>. No additional data structures proportional to the size of the input are used. Thus, the overall space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/grid-path-2/1" target="_blank" rel="noopener noreferrer">Grid Path 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a grid of n * m having 0 and 1 respectively, 0 denotes space, and 1 denotes obstacle. Geek is located at the top-left corner (i.e. grid[0][0]) and wants to reach the bottom right corner of the grid. A geek can move either<strong> down</strong> or <strong>right</strong> at any point in time. return the total number of ways in which Geek can reach the bottom right corner. answer may be large take the modulo by 1e9+7.</span></p>
<pre><span style="font-size: 18px;"><strong>Example:</strong>
<strong>Input:
</strong>n = 3, m = 3
grid= [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong>
2
<strong>Explanation:</strong>
There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach
the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right -&gt; Right</span>

<strong><span style="font-size: 18px;">Example 2:
Input:
</span></strong><span style="font-size: 18px;">n = 2, m = 2
grid = [[0,1],[0,0]]
<strong>Output:</strong>
1</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't have to read input or print anything. Your task is to complete the function <strong>totalWays()&nbsp;</strong>which takes the integer n and m and m * n grid.</span></p>
<p><span style="font-size: 18px;"><strong>Constraint:</strong><br />1 &lt;= m,n &lt;= 100<br />grid[i][j] is 0 or 1.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(m * n)<br /><strong>Expected Space Complexity:</strong> O(n)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/grid-teleportation-traversal/description" target="_blank" rel="noopener noreferrer">Grid Teleportation Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D character grid <code>matrix</code> of size <code>m x n</code>, represented as an array of strings, where <code>matrix[i][j]</code> represents the cell at the intersection of the <code>i<sup>th</sup></code> row and <code>j<sup>th</sup></code> column. Each cell is one of the following:</p>

<ul>
	<li><code>&#39;.&#39;</code> representing an empty cell.</li>
	<li><code>&#39;#&#39;</code> representing an obstacle.</li>
	<li>An uppercase letter (<code>&#39;A&#39;</code>-<code>&#39;Z&#39;</code>) representing a teleportation portal.</li>
</ul>

<p>You start at the top-left cell <code>(0, 0)</code>, and your goal is to reach the bottom-right cell <code>(m - 1, n - 1)</code>. You can move from the current cell to any adjacent cell (up, down, left, right) as long as the destination cell is within the grid bounds and is not an obstacle<strong>.</strong></p>

<p>If you step on a cell containing a portal letter and you haven&#39;t used that portal letter before, you may instantly teleport to any other cell in the grid with the same letter. This teleportation does not count as a move, but each portal letter can be used<strong> at most </strong>once during your journey.</p>

<p>Return the <strong>minimum</strong> number of moves required to reach the bottom-right cell. If it is not possible to reach the destination, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [&quot;A..&quot;,&quot;.A.&quot;,&quot;...&quot;]</span></p>

<p><strong>Output:</strong> 2</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/example04140.png" style="width: 151px; height: 151px;" /></p>

<ul>
	<li>Before the first move, teleport from <code>(0, 0)</code> to <code>(1, 1)</code>.</li>
	<li>In the first move, move from <code>(1, 1)</code> to <code>(1, 2)</code>.</li>
	<li>In the second move, move from <code>(1, 2)</code> to <code>(2, 2)</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [&quot;.#...&quot;,&quot;.#.#.&quot;,&quot;.#.#.&quot;,&quot;...#.&quot;]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/ezgifcom-animated-gif-maker.gif" style="width: 251px; height: 201px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == matrix.length &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= n == matrix[i].length &lt;= 10<sup>3</sup></code></li>
	<li><code>matrix[i][j]</code> is either <code>&#39;#&#39;</code>, <code>&#39;.&#39;</code>, or an uppercase English letter.</li>
	<li><code>matrix[0][0]</code> is not an obstacle.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/help-a-thief5938/1" target="_blank" rel="noopener noreferrer">Help a Thief!!!</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You have to help a thief to steal as many as GoldCoins as possible from a GoldMine. There he saw <strong>N</strong> Gold Boxes an each Gold Boxes consists of <strong>A<sub>i</sub></strong> Plates each plates consists of <strong>B<sub>i</sub></strong> Gold Coins. Your task is to print the maximum gold coins theif can steal if he can take a maximum of T plates.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>T = </strong>3, <strong>N = </strong>3</span><strong> </strong>
<span style="font-size:18px"><strong>A[] = </strong>{1, 2, 3}
<strong>B[] = </strong>{3, 2, 1}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">7</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The thief will take 1 plate of coins
from the first box and 2 plate of coins
from the second plate. 3 + 2*2 = 7.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>T = </strong>0, <strong>N = </strong>3</span><strong> </strong>
<span style="font-size:18px"><strong>A[] = </strong>{1, 3, 2}</span>
<span style="font-size:18px"><strong>B[] = </strong>{2, 3, 1}</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">0</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The thief can&#39;t take any plates.
So he can&#39;t steal any coins.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>maxCoins()</strong> which takes 2 Integers T, and N and two arrays A and B of size N as input and returns the maximum number of gold coins the thief can steal if he can take a maximum of T plates.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N*logN)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">0 &lt;= T,N &lt;= 10<sup>4</sup><br />
1 &lt;= A[i] &lt;= 10<sup>4</sup></span><br />
<span style="font-size:18px">1 &lt;= B[i] &lt;= 10<sup>4</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/identical-matrices1042/1" target="_blank" rel="noopener noreferrer">Identical Matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given two square matrices Grid1 and Grid2 with the same dimensions(NxN).Check whether they are identical or not.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=2
Grid1=[[1,2],[3,4]]
Grid2=[[1,2],[3,4]]
<strong>Output:</strong>
1
<strong>Explanation:</strong>
Both the matrices are identical,
so the answer is 1.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=2
Grid1=[[1,2][3,4]]
Grid2=[[1,2][3,2]]
<strong>Output:</strong>
0
<strong>Explanation:</strong>
Both the matrices are not identical,
So, answer is 0.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything.Your task is to complete the function <strong>areMatricesIdentical()</strong> which takes the integer N and two 2D arrays Grid1 and Grid2 as input parameters and returns 1 if the matrices are identical.Otherwise,it returns 0.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N<sup>2</sup>)<br />
<strong>Expected Auxillary Space:</strong>O(1)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N&lt;=1000<br />
-1000&lt;=Grid1[i][j],Grid2[i][j]&lt;=1000,for 0&lt;=i,j</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/image-overlap/description" target="_blank" rel="noopener noreferrer">Image Overlap</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two images, <code>img1</code> and <code>img2</code>, represented as binary, square matrices of size <code>n x n</code>. A binary matrix has only <code>0</code>s and <code>1</code>s as values.</p>

<p>We <strong>translate</strong> one image however we choose by sliding all the <code>1</code> bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the <strong>overlap</strong> by counting the number of positions that have a <code>1</code> in <strong>both</strong> images.</p>

<p>Note also that a translation does <strong>not</strong> include any kind of rotation. Any <code>1</code> bits that are translated outside of the matrix borders are erased.</p>

<p>Return <em>the largest possible overlap</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg" style="width: 450px; height: 231px;" />
<pre>
<strong>Input:</strong> img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We translate img1 to right by 1 unit and down by 1 unit.
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg" style="width: 450px; height: 105px;" />
The number of positions that have a 1 in both images is 3 (shown in red).
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg" style="width: 450px; height: 231px;" />
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> img1 = [[1]], img2 = [[1]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> img1 = [[0]], img2 = [[0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == img1.length == img1[i].length</code></li>
	<li><code>n == img2.length == img2[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>img1[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>img2[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/image-smoother/description" target="_blank" rel="noopener noreferrer">Image Smoother</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <strong>image smoother</strong> is a filter of the size <code>3 x 3</code> that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg" style="width: 493px; height: 493px;" />
<p>Given an <code>m x n</code> integer matrix <code>img</code> representing the grayscale of an image, return <em>the image after applying the smoother on each cell of it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg" style="width: 613px; height: 253px;" />
<pre>
<strong>Input:</strong> img = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> [[0,0,0],[0,0,0],[0,0,0]]
<strong>Explanation:</strong>
For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg" style="width: 613px; height: 253px;" />
<pre>
<strong>Input:</strong> img = [[100,200,100],[200,50,200],[100,200,100]]
<strong>Output:</strong> [[137,141,137],[141,138,141],[137,141,137]]
<strong>Explanation:</strong>
For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == img.length</code></li>
	<li><code>n == img[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= img[i][j] &lt;= 255</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>In this problem, we are given an <code>m x n</code> integer matrix <code>img</code>.</p>
<p>We need to return a matrix of dimension <code>m x n</code> where each cell is obtained by applying <strong>smoother</strong> on the corresponding cell of the <code>img</code> matrix.</p>
<p>Now, <strong>smoother</strong>, as given in the problem statement, can be thought of as an operator that takes as an input a cell. It then returns the <em>average</em> of the values of the &quot;cell and its <em>neighbors</em>&quot;.</p>
<ul>
<li>
<p><em>average</em>: the average of a list of integers is the sum of the integers divided by the number of integers in the list. The average can be a floating point number, and in that case, the smoother should round down the result to the nearest integer.</p>
</li>
<li>
<p><em>neighbors</em>: a cell is called a neighbor of another cell if they share a common edge or a common corner.</p>
</li>
</ul>
<p>Now, based on the different numbers of neighbors, let's see how we can apply the <strong>smoother</strong> operator on a cell.</p>
<ul>
<li>
<p>A cell can have at most 8 neighbors. 4 of these share a common edge, and the remaining 4 share a common corner.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide1.PNG" alt="8_neighbors" /></p>
<p>To apply smoother on the central cell, colored in yellow, we need to find the average of the values of the cell and its 8 neighbors. It is worth noting that for computing the average, we need to consider the value of the cell itself as well.</p>
<ul>
<li>
<p>The sum of the values of the cell and its 8 neighbors is <code>24 + 4 + 56 + 8 + 78 + 2 + 23 + 8 + 69</code>, which adds up to <code>272</code>.</p>
</li>
<li>
<p>The number of cells we are using to compute the average is <code>9</code>.</p>
</li>
<li>
<p>Hence, the average is <code>272 / 9</code>, which is <code>30.22</code>, rounded down to <code>30</code>.</p>
</li>
</ul>
</li>
<li>
<p>If there is only one cell in the matrix, then it has no neighbors.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide2_1.PNG" alt="no_neighbors" /></p>
<p>To apply smoother on this cell, we need to find the average of the values of the cell and its (non-existent) neighbors.</p>
<ul>
<li>
<p>The sum of the values of the cell and its 0 neighbors is the value present in the cell itself, which is <code>68</code>.</p>
</li>
<li>
<p>The number of cells we are using to compute the average is <code>1</code> only since there were no neighbors.</p>
</li>
<li>
<p>Hence, the average is <code>68 / 1</code>, which is the same as the value of the cell itself, which is <code>68</code>.</p>
</li>
</ul>
</li>
<li>
<p>If there is more than one cell in the matrix, then each cell has at least one neighbor.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide2_2.PNG" alt="1neighbors" /></p>
</li>
<li>
<p>If the matrix has more than one row, and more than one column, then each cell has at least 3 neighbors.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide3.PNG" alt="3neighbors" /></p>
<p>To apply smoother on the corner cell, colored in yellow, we need to find the average of the values of the cell and its 3 neighbors.</p>
<ul>
<li>
<p>The sum of the values of the cell and its 3 neighbors is <code>42 + 59 + 23 + 75</code>, which adds up to <code>199</code>.</p>
</li>
<li>
<p>The number of cells we are using to compute the average is <code>4</code>.</p>
</li>
<li>
<p>Hence, the average is <code>199 / 4</code>, which is <code>49.75</code>, rounded down to <code>49</code>.</p>
</li>
</ul>
</li>
</ul>
<p>Thus, using this way, we need to apply the <strong>smoother</strong> operator on each cell of the <code>img</code>, and return the resultant matrix.</p>
<details> <summary> <b> Why it is called a smoother? </b> Click to find out! </summary>
<p>
<blockquote>
<p>Grayscale images are nothing but a matrix (two-dimensional array) of integers. Each integer represents a pixel, the smallest unit of a digital image. The value of the integer represents the intensity of the pixel. The higher the value, the more intense the pixel is. The intensity of the pixel ranges from <code>0</code> to <code>255</code>. The value <code>0</code> represents black, and the value <code>255</code> represents white. The values in between represent different shades of gray.</p>
<p>Here is a grayscale image of size <code>400 px x 400 px</code>.</p>
<p><img src="../Figures/661/661_code_images/gray_image.png" alt="gray_image" /></p>
<p>One pixel represents one cell, hence the dimension of the corresponding matrix will be <code>400 x 400</code>. Here is what a part of the matrix looks like.</p>
<p><img src="../Figures/661/661_code_images/matrix_gray_image.png" alt="gray_image_matrix" /></p>
<p>On applying the <strong>smoother</strong> operator on each cell of the matrix, the same part of the matrix will look like this.</p>
<p><img src="../Figures/661/661_code_images/matrix_smooth_image1.png" alt="gray_image_matrix_smoother" /></p>
<p>Let's convert the smoothened matrix back to the grayscale image, and compare it with the original image.</p>
<p><img src="../Figures/661/661_code_images/compare1.png" alt="comparison" /></p>
<p>Readers can observe that the image after applying the <strong>smoother</strong> operator is blurr than the original image with sharp and fine details chopped off. If we again and again apply the <strong>smoother</strong> operator on the image, the image will become more and more blurred. Here are a few rounds of repeated application of the <strong>smoother</strong> operator on the image.</p>
<p><img src="../Figures/661/661_code_images/compare2.png" alt="repeated_application" /></p>
</blockquote>
<blockquote>
<p>As <strong>trivia</strong>, it is worth knowing that a grayscale image is a two-dimensional array of integers, but a colored image is a three-dimensional array of integers. It has three dimensions because each pixel has three components: red, green, and blue. The value of each component ranges from <code>0</code> to <code>255</code>. The value <code>0</code> represents the absence of the component, and the value <code>255</code> represents the presence of the component in its full intensity. The values in between represent different shades of the component. The three components together represent the color of the pixel.</p>
</blockquote>
</p>
</details>
<br/>
<p>Let's see how we can solve this problem with different approaches.</p>
<hr />
<h3 id="approach-1-create-a-new-smoothened-image">Approach 1: Create a New Smoothened Image</h3>
<h4 id="intuition">Intuition</h4>
<p>We know that for applying the <strong>smoother</strong> operator, we need to consider the neighbors in the original <code>img</code> matrix, not the neighbors in the resultant matrix. Hence, we cannot overwrite the values of the <code>img</code> matrix with the result of the <strong>smoother</strong> operator.</p>
<p>The following example illustrates this point.</p>
<blockquote>
<p>Let our <code>img</code> be <code>[[100, 0, 10], [0, 0, 25], [10, 10, 10]]</code>. The output should be <code>[[25, 22, 8], [20, 18, 9], [5, 9, 11]]</code></p>
<p><img src="../Figures/661/661_slide_images_used/Slide4.PNG" alt="img-out" /></p>
<p>Assume that we have applied the smooth operator on the first cell, and overwritten the value of the cell with the result. The <code>img</code> now will become <code>[[25, 0, 10], [0, 0, 25], [10, 10, 10]]</code>.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide5_1.PNG" alt="overwrite" /></p>
<p>Now if we use this matrix to apply the smooth operator on the second cell of the first row, we will get the value <code>10</code> instead of the expected value <code>22</code>.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide5_2.PNG" alt="wrong" /></p>
</blockquote>
<p>For this reason, we will not overwrite the values of the <code>img</code> matrix with the result of the <strong>smoother</strong> operator. This, thus calls for an extra space to store the result of the <strong>smoother</strong> operator for each cell of the <code>img</code> matrix.</p>
<p>The dimension of the input <code>img</code> matrix is <code>m x n</code>. Thus, let's create smoothened image in a new matrix <code>smooth_img</code> of dimension <code>m x n</code>.</p>
<p>Now to compute individual cells of the <code>smooth_img</code>, we need to read the corresponding cell and its (valid) neighbors from the <code>img</code> matrix.</p>
<p>Thus, to compute the <code>smooth_img[i][j]</code>, we may need to read the following cells from the <code>img</code> matrix.</p>
<ul>
<li><code>img[i][j]</code>, the cell itself.</li>
<li><code>img[i - 1][j - 1]</code>, the cell that shares the top-left corner with this cell.</li>
<li><code>img[i - 1][j]</code>, the cell that shares the top edge with this cell.</li>
<li><code>img[i - 1][j + 1]</code>, the cell that shares the top-right corner with this cell.</li>
<li><code>img[i][j - 1]</code>, the cell that shares the left edge with this cell.</li>
<li><code>img[i][j + 1]</code>, the cell that shares the right edge with this cell.</li>
<li><code>img[i + 1][j - 1]</code>, the cell that shares the bottom-left corner with this cell.</li>
<li><code>img[i + 1][j]</code>, the cell that shares the bottom edge with this cell.</li>
<li><code>img[i + 1][j + 1]</code>, the cell that shares the bottom-right corner with this cell.</li>
</ul>
<p>However, not all of these cells are necessarily valid.</p>
<blockquote>
<p>If <code>i = 0</code>, then <code>img[i - 1][j - 1]</code>, <code>img[i - 1][j]</code>, and <code>img[i - 1][j + 1]</code> are invalid, because they are above the top most row of the <code>img</code> matrix.</p>
</blockquote>
<p>A cell will be valid only if it is within the bounds of the <code>img</code> matrix.</p>
<ul>
<li>The row index of the cell should be greater than or equal to <code>0</code>, and less than <code>m</code>.</li>
<li>The column index of the cell should be greater than or equal to <code>0</code>, and less than <code>n</code>.</li>
</ul>
<p>Thus, in general, a neighbor with row index <code>x</code>, and column index <code>y</code> will be valid if <code>0 &lt;= x &lt; m</code>, and <code>0 &lt;= y &lt; n</code>. Both of these conditions should be true.</p>
<p>Now we need to compute the average of the values of the valid neighbors of the cell, and the value of the cell itself. For this, we need the sum of these values and the count of these values.</p>
<p>Hence, to compute <code>smooth_img[i][j]</code></p>
<ul>
<li>Use two variables, <code>sum</code> and <code>count</code>, to store the sum and count of the values of the valid neighbors of the cell, and the value of the cell itself.</li>
<li>Iterate over all plausible nine indices, if the indices form a valid neighbor, then add the value of the cell at that index to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</li>
<li>Compute the average by <code>sum / count</code>, and store the rounded down value in <code>smooth_img[i][j]</code>.</li>
</ul>
<p>Readers are encouraged to implement this algorithm on their own.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Save the dimensions of the image. Store the number of rows in <code>m</code>, and the number of columns in <code>n</code>, as convention used in the problem statement as well.</p>
</li>
<li>
<p>Create a new image of the same dimension as the input image. Let's call this new image <code>smooth_img</code>. Initialize all the cells of the <code>smooth_img</code> with <code>0</code>.</p>
</li>
<li>
<p>Iterate over the cells of the image. Let's call the current cell <code>img[i][j]</code>.</p>
<ul>
<li>
<p>Initialize two integer variables <code>sum</code> and <code>count</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over all plausible nine indices <code>(x, y)</code>. The <code>(x, y)</code> are</p>
<ul>
<li>
<p><code>(i - 1, j - 1)</code></p>
</li>
<li>
<p><code>(i - 1, j)</code></p>
</li>
<li>
<p><code>(i - 1, j + 1)</code></p>
</li>
<li>
<p><code>(i, j - 1)</code></p>
</li>
<li>
<p><code>(i, j)</code></p>
</li>
<li>
<p><code>(i, j + 1)</code></p>
</li>
<li>
<p><code>(i + 1, j - 1)</code></p>
</li>
<li>
<p><code>(i + 1, j)</code></p>
</li>
<li>
<p><code>(i + 1, j + 1)</code></p>
</li>
</ul>
<p>If index <code>(x, y)</code> is valid, then add the value of <code>img[x][y]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>In <code>smooth_img[i][j]</code>, store the rounded down value of <code>sum / count</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return the <code>smooth_img</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/9UY4TRnT/shared">code</a></p>
<p><strong>Implementation Note:</strong> For iterating the nine neighbors, we have used constant time nested for loops, which list the nine neighbors.</p>
<p>The other approach to achieving this is using the <code>DIRECTION</code> array, which lists the change in the neighbor's position. A typical <code>DIRECTION</code> array will look like this</p>
<pre><code class="language-DIRECTION">[
    (-1, -1), (-1, 0), (-1, 1),
    (0, -1), (0, 0), (0, 1),
    (1, -1), (1, 0), (1, 1)
]
</code></pre>
<p>Readers are encouraged to implement this approach as well to widen their implementation skills.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows in the <code>img</code> matrix, and <span class="math inline">\(n\)</span> be the number of columns in the <code>img</code> matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We are computing the value of each cell of the <code>smooth_img</code> matrix. There are <span class="math inline">\(m \cdot n\)</span> cells in the <code>smooth_img</code> matrix.</p>
<p>For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell.</p>
<p>Hence, the time complexity of the algorithm is <span class="math inline">\(O(m \cdot n \cdot 9)\)</span>, which is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We are creating a new matrix of dimension <span class="math inline">\(m \cdot n\)</span> to store the result. Hence, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-space-optimized-smoothened-image">Approach 2: Space-Optimized Smoothened Image</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we created a new matrix of dimension <code>m x n</code> to store the result. Moreover, we have seen that we can't overwrite the values of the <code>img</code> matrix with the result of the <strong>smoother</strong> operator. If we modify <code>img[i][j]</code> in place, we won't be able to use the original <code>img[i][j]</code> in subsequent calculations because the value at this position has already been overwritten.</p>
<p>Let's take a closer look at why we can't overwrite these values.</p>
<p>We were moving row-by-row, and in each row, we were moving column-by-column. Assume we are overwriting the cells <em>(with somehow correct smoothened value)</em> as we move on.</p>
<p>Let's call the current cell <code>img[i][j]</code>. To compute <code>smooth_img[i][j]</code>, we need to read the value of <code>img[i][j]</code>, and its neighbors.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide6.PNG" alt="neighbors" /></p>
<p>However, because of our order of traversal, out of these 8 neighbors, the top 3 neighbors (which are in the row <code>img[i - 1]</code>), and the left neighbor (which is in cell <code>img[i][j - 1]</code>) have already been overwritten. Hence, we don't have access to the original values of these neighbors.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide7.PNG" alt="no_access" /></p>
<p>In summary, for calculating <code>smooth_img[i]</code></p>
<ul>
<li>We need to save the original values of two rows <code>img[i]</code> and <code>img[i - 1]</code>.</li>
<li>Rows before <code>img[i - 1]</code>, such as <code>img[i - 2]</code> or <code>img[i - 3]</code>, are no longer needed and need not be saved.</li>
<li>The next row <code>img[i + 1]</code> has not been overwritten yet, and hence, we can use it as is it.</li>
</ul>
<p>To achieve this, we can proceed by saving all original values of two rows in two temporary arrays. The previous row is saved as <code>prev</code> and the current row is saved as <code>curr</code>.</p>
<p>Now, for computing <code>img[i][j]</code></p>
<ul>
<li>All three neighbors of the previous row will be saved in the <code>prev</code> array. The stored values in <code>img[i - 1]</code> will be the smoothed value as we are supposed to overwrite as we proceed.</li>
<li>The original value of <code>img[i][j - 1]</code> will be saved in <code>curr</code> array. The presently stored value of <code>img[i][j - 1]</code> is the smoothed value of <code>img[i][j - 1]</code>, and not the original value.</li>
<li>The original value of <code>img[i][j]</code> is in <code>img</code> itself, because it has not been overwritten yet.</li>
<li>The original value of <code>img[i][j + 1]</code> is in <code>img</code> itself, because it has not been overwritten yet.</li>
<li>All three neighbors of the next row will be saved in <code>img</code> itself.</li>
</ul>
<p>Hence, by using this approach, we can overwrite the values of the <code>img</code> matrix. The <code>curr</code> can be filled on the fly before overwriting, and will be given the name of <code>prev</code> after the iteration is over.</p>
<p>Readers are encouraged to implement this approach where we need not construct a new matrix to store the result. However, there are a few more optimizations that can be done.</p>
<p>Let's brainstorm further to use only one array <code>temp</code> instead of two arrays. The idea is that if we are on <code>img[i][j]</code></p>
<ul>
<li>The indices <code>temp[j]</code>, <code>temp[j + 1]</code>, <code>temp[j + 2]</code> ... represent the value of the <code>prev</code> array, or in other terms, original values of <code>img[i - 1]</code></li>
<li>The indices ... <code>temp[j - 3]</code>, <code>temp[j - 2]</code>, <code>temp[j - 1]</code> represent the value of the <code>curr</code> array, or in other terms, original values of <code>img[i]</code></li>
</ul>
<p>This construction overwrites <em>previous row values</em> in <code>temp</code> with <em>current row values</em> as we traverse along the row. However, it has one major flaw. Let's enlist to see what it is by focusing on cell <code>img[i][j]</code>.</p>
<ul>
<li>The neighbors in next row <code>img[i + 1]</code> are in <code>img</code> only.</li>
<li>The next neighbor in same row <code>img[i][j + 1]</code> is in <code>img</code> only.</li>
<li>The current value of <code>img[i][j]</code> is also not overwritten yet.</li>
<li>The previous neighbor in same row <code>img[i][j - 1]</code> is in <code>temp</code>.</li>
<li>The two of neighbors in previous row <code>img[i - 1]</code> are in <code>temp</code>. Precisely original value of <code>img[i - 1][j]</code> is in <code>temp[j]</code>, and original value of <code>img[i - 1][j + 1]</code> is in <code>temp[j + 1]</code>.</li>
</ul>
<p>The only missing piece is the original value of <code>img[i - 1][j - 1]</code>. The value there now is smoothed value of <code>img[i - 1][j - 1]</code>, and <code>temp[j - 1]</code> stores <code>curr[j - 1]</code>, and not <code>prev[j - 1]</code>.</p>
<p>What if before writing original <code>img[i][j - 1]</code> into <code>temp[j - 1]</code> <em>(which before writing stores <code>img[i - 1][j - 1]</code>)</em>, we store its original value in an integer variable <code>prev_val</code>? Turns out this will work, and the missing piece will be filled.</p>
<p>We have reduced the space used from <span class="math inline">\(m \cdot n\)</span> to <span class="math inline">\(2n\)</span>, then to <span class="math inline">\(n\)</span>.</p>
<details>
<summary>Any further optimization? Click to find out!</summary>
<p>
<p>What if we have <span class="math inline">\(n \gg m\)</span>? In this case, we would prefer to store one column <em>(which will have elements from <span class="math inline">\(m\)</span> rows)</em> in an array, and not one row <em>(which will have elements from <span class="math inline">\(n\)</span> columns)</em> in an array. This will reduce the space used from <span class="math inline">\(n\)</span> to <span class="math inline">\(m\)</span>, or precisely to <span class="math inline">\(\min(m,n)\)</span>.</p>
<p>There are two ways of achieving this.</p>
<ol>
<li>
<p><a href="https://leetcode.com/problems/transpose-matrix/description/">Transpose the matrix</a>, and then use row-order traversal. After obtaining the result, transpose the matrix again to get the original matrix.</p>
<p>However,</p>
<ul>
<li>
<p>Transposing a non-square matrix in <span class="math inline">\(O(m \cdot n)\)</span> time takes <span class="math inline">\(O(m \cdot n)\)</span> space. We aimed to reduce from <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(\min(m,n))\)</span>. This indeed has increased space utilization.</p>
</li>
<li>
<p>The <a href="https://en.wikipedia.org/wiki/In-place_matrix_transposition">in-place transpose</a> will increase the time complexity from <span class="math inline">\(O(m \cdot n)\)</span> to <span class="math inline">\(O(m \cdot n \cdot \log(mn))\)</span>. This is because the in-place transpose is done by swapping the elements of the matrix. The swapping is done in a cycle. The number of cycles is <span class="math inline">\(O(m \cdot n)\)</span>. The length of each cycle is <span class="math inline">\(O(\log(m  n))\)</span>. Hence, the time complexity of the in-place transpose is <span class="math inline">\(O(m \cdot n \cdot \log(m  n))\)</span>.</p>
</li>
</ul>
<p>Hence, transposing the matrix is not a good idea. Let's see what's the other way.</p>
</li>
<li>
<p>Use column-order traversal instead of row-order traversal. The <code>temp</code> will store values of one column and not one row. The <code>prev_val</code> will store the original value of the cell in the same column but in the previous row.</p>
<p>However, two-dimension arrays in most of the programming languages are <strong><a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major</a></strong>, and not <strong>column-major</strong>. <em>The consecutive elements of a row are contiguous in memory</em>. Reading memory in contiguous locations is faster than jumping around among locations. Hence, column order traversal will be slower than row order traversal. However, asymptotically both will have the same time complexity.</p>
</li>
</ol>
<p>Thus all two ways of reducing space complexity from <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(\min(m,n))\)</span> have their downsides. Hence, we will stick with the space complexity of <span class="math inline">\(O(n)\)</span>.</p>
</p>
</details>
<br/>
<p><span class="math inline">\(\downarrow_{\text{Portion after realizing that sticking with space complexity of } O(n) \text{ is better, at least in this approach}}\)</span></p>
<p>With all the details being discussed minutely, let's see how we can implement this approach.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Save the dimensions of the image. Store the number of rows in <code>m</code>, and the number of columns in <code>n</code>, as convention used in the problem statement as well.</p>
</li>
<li>
<p>Create an array of size <code>n</code>. Let's call this array <code>temp</code>.</p>
</li>
<li>
<p>Declare an integer variable <code>prev_val</code>, and initialize it with <code>0</code>.</p>
</li>
<li>
<p>Iterate over the cells of the image. Let's call the current cell <code>img[i][j]</code>.</p>
<ul>
<li>
<p>Initialize two integer variables <code>sum</code> and <code>count</code> to <code>0</code>.</p>
</li>
<li>
<p>If there exists the next row, that is, <code>i + 1 &lt; m</code>, then we have to consider all the bottom neighbors.</p>
<ul>
<li>
<p>If there exists the left-bottom neighbor, that is, <code>j - 1 &gt;= 0</code>, then add the value of <code>img[i + 1][j - 1]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>Add the value of <code>img[i + 1][j]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>If there exists the right-bottom neighbor, that is, <code>j + 1 &lt; n</code>, then add the value of <code>img[i + 1][j + 1]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
</ul>
</li>
<li>
<p>If there exists the next neighbor, that is, <code>j + 1 &lt; n</code>, then add the value of <code>img[i][j + 1]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>Add the value of <code>img[i][j]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>If there exists the previous neighbor, that is, <code>j - 1 &gt;= 0</code>, then add the value of <code>temp[j - 1]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>. The <code>temp</code> till index <code>j - 1</code> stores the original values of the current row <code>img[i]</code> only.</p>
</li>
<li>
<p>If there exists the previous row, that is, <code>i - 1 &gt;= 0</code>, then we have to consider all the top neighbors.</p>
<ul>
<li>
<p>If there exists the left-top neighbor, that is, <code>j - 1 &gt;= 0</code>, then add the value of <code>prev_val</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>. The <code>prev_val</code> stores original value of <code>img[i - 1][j - 1]</code>.</p>
</li>
<li>
<p>Add the value of <code>temp[j]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>. The <code>temp</code> at index <code>j</code> stores the original value of <code>img[i - 1][j]</code>.</p>
</li>
<li>
<p>If there exists the right-top neighbor, that is, <code>j + 1 &lt; n</code>, then add the value of <code>temp[j + 1]</code> to <code>sum</code>, and increment <code>count</code> by <code>1</code>. The <code>temp</code> at index <code>j + 1</code> stores original value of <code>img[i - 1][j + 1]</code>.</p>
</li>
</ul>
</li>
<li>
<p>Now comes the overwriting part.</p>
</li>
<li>
<p>If there exists the previous row, that is, <code>i - 1 &gt;= 0</code>, then the value at <code>temp[j]</code> will serve the purpose of the top-left corner sharing neighbor of the next location in iteration, that is, of <code>img[i][j + 1]</code>. Hence, store <code>temp[j]</code> in <code>prev_val</code>.</p>
</li>
<li>
<p>Store the value of <code>img[i][j]</code> in <code>temp[j]</code>. This will maintain the loop invariant of the definition of <code>temp</code>.</p>
</li>
<li>
<p>Overwrite the value of <code>img[i][j]</code> with the rounded down value of <code>sum / count</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return the <code>img</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/9b5KtAMB/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows in the <code>img</code> matrix, and <span class="math inline">\(n\)</span> be the number of columns in the <code>img</code> matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We are traversing every cell of the <code>img</code> matrix. There are <span class="math inline">\(m \cdot n\)</span> cells in the <code>img</code> matrix.</p>
<p>In every traversal, we are doing constant time work of computing the smoothed value, overwriting, and updating the <code>temp</code> array.</p>
<p>Hence, the time complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The array <code>temp</code> is of size <span class="math inline">\(n\)</span>. The remaining variables are of constant size. Hence, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-constant-space-smoothened-image">Approach 3: Constant Space Smoothened Image</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Based on the previous algorithms, we know that if we modify <code>img[i][j]</code> in place, we won't be able to use the original <code>img[i][j]</code> in subsequent calculations because the value at this position has already been overwritten. Can we somehow store both the pre-modified and post-modified <code>img[i][j]</code> values in the same cell? Ideally speaking, it's possible.</p>
<p>Considering the data structure of <code>img</code>, we cannot store two separate numbers in one cell. However, we can represent two independent numbers using a single number.</p>
<p>Assume we have two independent numbers, <span class="math inline">\(p\)</span> and <span class="math inline">\(r\)</span>. Let's define another number <span class="math inline">\(Y\)</span> as<br />
<span class="math inline">\(Y = p \cdot X + r\)</span><br />
where <span class="math inline">\(X\)</span> is a constant.</p>
<ul>
<li>To extract <span class="math inline">\(p\)</span> from <span class="math inline">\(Y\)</span>, we can do <span class="math inline">\(Y / X\)</span>.</li>
<li>To extract <span class="math inline">\(r\)</span> from <span class="math inline">\(Y\)</span>, we can do <span class="math inline">\(Y \% X\)</span>.</li>
</ul>
<p>Hence, the encoded <span class="math inline">\(Y\)</span> indeed stores two integers of our interest, <span class="math inline">\(p\)</span> and <span class="math inline">\(r\)</span>.</p>
<p>Let's focus more on <span class="math inline">\(X\)</span>. What should be the value of <span class="math inline">\(X\)</span>? It turns out it depends on <span class="math inline">\(r\)</span>. The <span class="math inline">\(r\)</span> is the remainder when we divide <span class="math inline">\(Y\)</span> by <span class="math inline">\(X\)</span>. Hence, <span class="math inline">\(r\)</span> can take values from <span class="math inline">\(0\)</span> to <span class="math inline">\(X - 1\)</span>.</p>
<blockquote>
<p>If we divide an integer by <span class="math inline">\(X\)</span>, the remainder will be in the range <span class="math inline">\(0\)</span> to <span class="math inline">\(X - 1\)</span>. For example, when divided by <span class="math inline">\(8\)</span>, the remainder will be in the range <span class="math inline">\(0\)</span> to <span class="math inline">\(7\)</span>.</p>
</blockquote>
<p>Thus our <span class="math inline">\(r\)</span> varies from <span class="math inline">\(0\)</span> to <span class="math inline">\(X - 1\)</span>.</p>
<p>Now, let's look at the constraints given in the problem statement.</p>
<blockquote>
<p><code>0 &lt;= img[i][j] &lt;= 255</code></p>
</blockquote>
<p>Thus, every cell of the <code>img</code> matrix can take values from <code>0</code> to <code>255</code>. Thus, we can have correspondence between <span class="math inline">\(r\)</span> and <code>img[i][j]</code>. To limit the remainder <span class="math inline">\(r\)</span> to <code>255</code>, we can choose <span class="math inline">\(X\)</span> to be <code>256</code>.</p>
<p>Let's now find out the value of <span class="math inline">\(p\)</span>. In a single integer, we wish to store the original value of <code>img[i][j]</code>, and the smoothed value of <code>img[i][j]</code>.</p>
<ul>
<li>The task of storing original value of <code>img[i][j]</code> is done by <span class="math inline">\(r\)</span>.</li>
<li>We can allot <span class="math inline">\(p\)</span> to store the smoothed value of <code>img[i][j]</code>.</li>
</ul>
<p>Hence, the summarized correspondence is</p>
<ul>
<li><span class="math inline">\(Y\)</span> represents two integers encoded in one integer. The two integers are the original value of <code>img[i][j]</code>, and smoothed value of <code>img[i][j]</code>.</li>
<li><span class="math inline">\(X\)</span> is <code>256</code>, the carefully chosen constant.</li>
<li><span class="math inline">\(r\)</span> is the remainder when we divide <span class="math inline">\(Y\)</span> by <span class="math inline">\(X\)</span>. The remainder <span class="math inline">\(r\)</span> is the original value of <code>img[i][j]</code>.</li>
<li><span class="math inline">\(p\)</span> is the quotient when we divide <span class="math inline">\(Y\)</span> by <span class="math inline">\(X\)</span>. The quotient <span class="math inline">\(p\)</span> is the smoothed value of <code>img[i][j]</code>.</li>
</ul>
<p>Hence, our algorithm will be</p>
<ul>
<li>For every cell, assume it stores <span class="math inline">\(Y\)</span> (and not <span class="math inline">\(r\)</span>)</li>
<li>Extract <span class="math inline">\(r\)</span>, the original value of <code>img[i][j]</code>, from <span class="math inline">\(Y\)</span> using <span class="math inline">\(Y \% 256\)</span></li>
<li>Compute smoothened value using neighbors of <code>img[i][j]</code>. For computing a smoothened value, we need the original value of neighbors as well, which will be extracted using the same logic. The smoothened value will be stored in <span class="math inline">\(p\)</span>.</li>
<li>Encode the smoothened value in <span class="math inline">\(Y\)</span> itself by updating it as <span class="math inline">\(Y = p \cdot 256 + r\)</span>.</li>
<li>Once every <span class="math inline">\(Y\)</span> of the matrix is encoded with smoothened value, from it extract smoothened value <span class="math inline">\(p\)</span> by doing <span class="math inline">\(Y / 256\)</span>.</li>
</ul>
<p>Hence, the algorithm sounds simple. However, there is a word of caution. Multiplying integers may cause overflow if multiplication exceeds the range of integers. For this, let's find the minimum and maximum value our encoded <span class="math inline">\(Y\)</span> can take.</p>
<p><span class="math inline">\(\boxed{Y = p \cdot 256 + r}\)</span></p>
<ul>
<li>
<p><span class="math inline">\(p\)</span> is the smoothened value which is an average of at most nine values ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(255\)</span>. Hence, the average <span class="math inline">\(p\)</span> will also lie between <span class="math inline">\(0\)</span> to <span class="math inline">\(255\)</span>.</p>
</li>
<li>
<p><span class="math inline">\(r\)</span> also lies between <span class="math inline">\(0\)</span> to <span class="math inline">\(255\)</span>.</p>
</li>
<li>
<p>The minimum value of <span class="math inline">\(Y\)</span> is <span class="math inline">\(0 \cdot 256 + 0 = 0\)</span>.</p>
</li>
<li>
<p>The maximum value of <span class="math inline">\(Y\)</span> is <span class="math inline">\(255 \cdot 256 + 255 = 65535\)</span> represented as <span class="math inline">\(2^{16} - 1\)</span>, which is reasonably less than the maximum value of an integer, which is <span class="math inline">\(2^{31} - 1\)</span>.</p>
</li>
</ul>
<p>Hence, we need not to worry about overflow in this particular problem.</p>
<p>With all the details being discussed minutely, let's see how we can implement this approach.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Save the dimensions of the image. Store the number of rows in <code>m</code>, and the number of columns in <code>n</code>, as convention used in the problem statement as well.</p>
</li>
<li>
<p>Iterate over the cells of the image. Let's call the current cell <code>img[i][j]</code>.</p>
<ul>
<li>
<p>Initialize two integer variables <code>sum</code> and <code>count</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over all plausible nine indices <code>(x, y)</code>. The <code>(x, y)</code> are</p>
<ul>
<li>
<p><code>(i - 1, j - 1)</code></p>
</li>
<li>
<p><code>(i - 1, j)</code></p>
</li>
<li>
<p><code>(i - 1, j + 1)</code></p>
</li>
<li>
<p><code>(i, j - 1)</code></p>
</li>
<li>
<p><code>(i, j)</code></p>
</li>
<li>
<p><code>(i, j + 1)</code></p>
</li>
<li>
<p><code>(i + 1, j - 1)</code></p>
</li>
<li>
<p><code>(i + 1, j)</code></p>
</li>
<li>
<p><code>(i + 1, j + 1)</code></p>
</li>
</ul>
<p>If the indices form a valid neighbor, then extract the original value of <code>img[x][y]</code> using <code>img[x][y] % 256</code>, and add it to <code>sum</code>. Increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>Encode the smoothed value in <code>img[i][j]</code> as <code>img[i][j] += (sum / count) * 256 </code>.</p>
</li>
</ul>
</li>
<li>
<p>Traverse again over the cells of the image. Let's call the current cell <code>img[i][j]</code>. Extract the smoothed value from <code>img[i][j]</code> using <code>img[i][j] / 256</code>, and store it in <code>img[i][j]</code>.</p>
</li>
<li>
<p>Return the <code>img</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/82csSf8n/shared">code</a></p>
<p><strong>Point to Ponder:</strong> With the number <code>256</code>, we are doing three operations</p>
<ul>
<li>Taking modulo</li>
<li>Multiplying</li>
<li>Dividing</li>
</ul>
<p>Now, <code>256</code> is special in the sense that it is a power of two. Is there a faster way to do these three operations? Readers are encouraged to think about it.</p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows in the <code>img</code> matrix, and <span class="math inline">\(n\)</span> be the number of columns in the <code>img</code> matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We are traversing every cell of the <code>img</code> matrix. There are <span class="math inline">\(m \cdot n\)</span> cells in the <code>img</code> matrix.</p>
<p>For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell. At each index, we are doing constant time arithmetic operations.</p>
<p>Again, we are traversing over all the cells of the <code>img</code> matrix to extract the smoothed value from the encoded value.</p>
<p>Hence, the time complexity of the algorithm is <span class="math inline">\(O((m \cdot n \cdot 9) + (m \cdot n))\)</span>, which is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are not using any extra space. Smoothened Values are encoded and extracted in the existing integer value of <code>img</code>. Hence, the space complexity of the algorithm is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-bit-manipulation">Approach 4: Bit Manipulation</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let's again analyze the constraints given in the problem statement.</p>
<blockquote>
<p><code>0 &lt;= img[i][j] &lt;= 255</code></p>
</blockquote>
<p>An integer, in most of the programming languages, is represented using 32 bits. The <code>255</code> is <code>11111111</code> in binary. All numbers from <code>0</code> to <code>255</code> require at most 8 bits to represent them.</p>
<p>Hence, out of these 32 bits, only the least significant 8 bits are used to represent the value of <code>img[i][j]</code>. We, to avoid any inconsistency, won't alter the most significant bit, as it is often used to represent the sign of the integer. Hence, the 23 bits are free to use.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide8.PNG" alt="unused" /></p>
<p>This suggests the idea that in these 23 unused bits, we can store the smoothed value of <code>img[i][j]</code>. This we can achieve by using bit-manipulation. In bit manipulation, we use the bit-wise operators.</p>
<details> <summary> <b> For quick review of bit-wise operators, click here </b> </summary>
<p>
<ul>
<li>
<p><strong>NOT:</strong> Bitwise NOT is a unary operator that flips the bits of the integer. If the current bit is <span class="math inline">\(0\)</span>, it will change it to <span class="math inline">\(1\)</span> and vice versa. The symbol of the bitwise NOT operator is tilde (<code>~</code>).</p>
<pre><code>N = 5 = 101 (in binary)
~N = ~(101) = 010 = 2 (in decimal)
</code></pre>
</li>
<li>
<p><strong>AND:</strong> If both bits in the compared position of the operand are <span class="math inline">\(1\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(1\)</span>, otherwise <span class="math inline">\(0\)</span>. The symbol of the bitwise AND operator is ampersand (<code>&amp;</code>).</p>
<pre><code>A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A &amp; B = 101 &amp; 001 = 001 = 1 (in decimal)
</code></pre>
</li>
<li>
<p><strong>OR:</strong> If both bits in the compared position of the operand are <span class="math inline">\(0\)</span>, the bit in the resulting bit pattern is <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>. The symbol of the bitwise OR operator is pipe (<code>|</code>).</p>
<pre><code>A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A | B = 101 | 001 = 101 = 5 (in decimal)
</code></pre>
</li>
<li>
<p><strong>XOR:</strong> In bitwise XOR if both bits are the same, the result will be <span class="math inline">\(0\)</span>, otherwise <span class="math inline">\(1\)</span>. The symbol of the bitwise XOR operator is caret (<code>^</code>).</p>
<pre><code>A = 5 = 101 (in binary) 
B = 1 = 001 (in binary) 
A ^ B = 101 ^ 001 = 100 = 4 (in decimal)
</code></pre>
</li>
<li>
<p><strong>Left Shift:</strong> The Left shift operator is a binary operator that shifts bits to the left by a certain number of positions and appends <code>0</code> at the right side. One left shift is equivalent to multiplying the bit pattern with <span class="math inline">\(2\)</span>. The symbol of the left shift operator is <code>&lt;&lt;</code>.</p>
<p><code>x &lt;&lt; y</code> means left shift <code>x</code> by <code>y</code> bits, which is equivalent to multiplying <code>x</code> with <span class="math inline">\(2^y\)</span>.</p>
<pre><code>A = 1 = 001 (in binary) 
A &lt;&lt; 1 = 001 &lt;&lt; 1 = 010 = 2 (in decimal)
A &lt;&lt; 2 = 001 &lt;&lt; 2 = 100 = 4 (in decimal)

B = 5 = 00101 (in binary)
B &lt;&lt; 1 = 00101 &lt;&lt; 1 = 01010 = 10 (in decimal)
B &lt;&lt; 2 = 00101 &lt;&lt; 2 = 10100 = 20 (in decimal)
</code></pre>
</li>
<li>
<p><strong>Right Shift:</strong> The Right shift operator is a binary operator that shifts bits to the right by a certain number of positions and appends <code>0</code> at the left side. One right shift is equivalent to dividing the bit pattern with <span class="math inline">\(2\)</span>. The symbol of the right shift operator is <code>&gt;&gt;</code>.</p>
<p><code>x &gt;&gt; y</code> means right shift <code>x</code> by <code>y</code> bits, which is equivalent to dividing <code>x</code> with <span class="math inline">\(2^y\)</span>.</p>
<pre><code>A = 4 = 100 (in binary) 
A &gt;&gt; 1 = 100 &gt;&gt; 1 = 010 = 2 (in decimal)
A &gt;&gt; 2 = 100 &gt;&gt; 2 = 001 = 1 (in decimal)
A &gt;&gt; 3 = 100 &gt;&gt; 3 = 000 = 0 (in decimal)

B = 5 = 00101 (in binary)
B &gt;&gt; 1 = 00101 &gt;&gt; 1 = 00010 = 2 (in decimal)
</code></pre>
</li>
</ul>
</p>
</details>
<br/>
<p><span class="math inline">\(\downarrow_{\text{Portion After Review}}\)</span></p>
<p>Now the smoothed value is an average of nine values ranging from <code>0</code> to <code>255</code>. Hence, the average will also lie between <code>0</code> to <code>255</code>. Thus, the smoothed value will also require at most 8 bits to represent it. This we can store together as follows.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide9.PNG" alt="two_store" /></p>
<p><strong>How do we store smoothened corresponding values?</strong> Let's see.</p>
<p>Initially, the smoothened corresponding value was a separate integer, as shown in the figure below.<br />
<img src="../Figures/661/661_slide_images_used/Slide10.PNG" alt="separate" /></p>
<p>We can left shift (using the <code>&lt;&lt;</code> operator ) the integer so that the orientation now looks like as follows.<br />
<img src="../Figures/661/661_slide_images_used/Slide11.PNG" alt="left_shift" /></p>
<p>Now there is a property of bitwise OR (<code>|</code>) operator. <code>x | 0 = x</code>. In the context of the diagram, doing bitwise OR of both these separate integers</p>
<ul>
<li>The most significant 16 bits will remain 0 because both integers have 0 in those bits.</li>
<li>The least significant 8 bits will store the values of <code>img[i][j]</code></li>
<li>The remaining 8 bits will store the values of the smoothened corresponding value.</li>
</ul>
<p><img src="../Figures/661/661_slide_images_used/Slide12.PNG" alt="or" /></p>
<p><strong>How can we extract the original value of <code>img[i][j]</code> from this mixed integer?</strong></p>
<p>In other words,</p>
<ul>
<li>
<p>We wish to set all except the least significant 8 bits to 0.</p>
<p>The bitwise AND (<code>&amp;</code>) operator has property of <code>x &amp; 0 = 0</code>. Thus to set the first 24 bits to <code>0</code>, we can do bitwise AND with an integer that has the first 24 bits as <code>0</code></p>
</li>
<li>
<p>We wish to retain the least significant 8 bits as it is.</p>
<p>The bitwise AND (<code>&amp;</code>) operator has property of <code>x &amp; 1 = x</code>. Thus to retain the last 8 bits as it is, we can do bitwise AND with an integer that has the last 8 bits as <code>1</code>.</p>
</li>
</ul>
<p>Thus, the integer with which we can do bitwise AND (<code>&amp;</code>) to extract the original value of <code>img[i][j]</code> is <code>00000000000000000000000011111111</code>, which is <code>255</code> in decimal, and <code>11111111</code> in binary.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide13.PNG" alt="and" /></p>
<p><strong>How can we extract the smoothened value from this mixed integer, after we are done with computing all the smoothened values?</strong></p>
<p>As done above, we perhaps can do bitwise AND (<code>&amp;</code>) with <code>00000000000000001111111100000000</code>, which is <code>65280</code> in decimal, and <code>1111111100000000</code> in binary. This will retain the smoothened value bits as it is, turning off all other bits.</p>
<p>After that, to get the smoothened value, we can right shift (using the<code>&gt;&gt;</code> operator ) the integer by 8 bits (To encode, we did a left shift by 8 bits). This will bring the smoothened value to the least significant 8 bits.</p>
<p>However, readers can appreciate that only the right shift is sufficient to extract the smoothened value.</p>
<p><img src="../Figures/661/661_slide_images_used/Slide14.PNG" alt="right_shift" /></p>
<p>Hence, our algorithm will be</p>
<ul>
<li>For every cell, assume it stores the mixed-integer.</li>
<li>Extract the original value of <code>img[i][j]</code> using bitwise AND (<code>&amp;</code>) with <code>255</code>.</li>
<li>Compute smoothened value using neighbors of <code>img[i][j]</code>. For computing the smoothened value, we need the original value of neighbors as well, which will be extracted using the same logic.</li>
<li>Left shift (<code>&lt;&lt;</code>) the smoothened value by 8 bits, and encode it in the mixed integer using bitwise OR (<code>|</code>) operator.</li>
<li>Once every mixed integer of the matrix is encoded with the smoothened value, extract the smoothened value using the right shift (<code>&gt;&gt;</code>) operator.</li>
</ul>
<blockquote>
<p>The bit manipulation works because we have only 8 bits per pixel (abbreviated as &quot;bpp&quot;). The &quot;bpp&quot; is the number of bits used to represent the color of a single pixel in a bitmapped image or video frame buffer. Hence, we can use the remaining bits to store the smoothened value.</p>
</blockquote>
<p>Readers can appreciate the one-to-one correspondence in this approach and <a href="#approach-3-constant-space-smoothened-image">previous approach</a></p>
<ul>
<li>
<p>Bitwise AND (<code>&amp;</code>) with <code>255</code> <span class="math inline">\(\equiv\)</span> modulo by <code>256</code></p>
</li>
<li>
<p>Left shift (<code>&lt;&lt;</code>) by 8 bits <span class="math inline">\(\equiv\)</span> multiply by <code>256</code></p>
</li>
<li>
<p>Bitwise OR (<code>|</code>) of smoothened value with <code>img[i][j]</code> provided least significant 8 bits of the left-shifted smoothened value are <code>0</code> <span class="math inline">\(\equiv\)</span> add <code>img[i][j]</code></p>
</li>
<li>
<p>Right shift (<code>&gt;&gt;</code>) by 8 bits <span class="math inline">\(\equiv\)</span> divide by <code>256</code></p>
</li>
</ul>
<p>This was hinted at <strong><a href="#implementation-2">Point to Ponder</a></strong> in previous approach.</p>
<p>The bit-wise operators are faster than arithmetic operators. Hence, this approach is faster than the <a href="#approach-3-constant-space-smoothened-image">previous approach</a>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Save the dimensions of the image. Store the number of rows in <code>m</code>, and the number of columns in <code>n</code>, as convention used in the problem statement as well.</p>
</li>
<li>
<p>Iterate over the cells of the image. Let's call the current cell <code>img[i][j]</code>.</p>
<ul>
<li>
<p>Initialize two integer variables <code>sum</code> and <code>count</code> to <code>0</code>.</p>
</li>
<li>
<p>Iterate over all plausible nine indices <code>(x, y)</code>. The <code>(x, y)</code> are</p>
<ul>
<li>
<p><code>(i - 1, j - 1)</code></p>
</li>
<li>
<p><code>(i - 1, j)</code></p>
</li>
<li>
<p><code>(i - 1, j + 1)</code></p>
</li>
<li>
<p><code>(i, j - 1)</code></p>
</li>
<li>
<p><code>(i, j)</code></p>
</li>
<li>
<p><code>(i, j + 1)</code></p>
</li>
<li>
<p><code>(i + 1, j - 1)</code></p>
</li>
<li>
<p><code>(i + 1, j)</code></p>
</li>
<li>
<p><code>(i + 1, j + 1)</code></p>
</li>
</ul>
<p>If the indices form a valid neighbor, then extract the original value of <code>img[x][y]</code> using <code>img[x][y] &amp; 255</code>, and add it to <code>sum</code>. Increment <code>count</code> by <code>1</code>.</p>
</li>
<li>
<p>Encode the smoothed value in <code>img[i][j]</code> as <code>img[i][j] |= (sum / count) &lt;&lt; 8 </code>.</p>
</li>
</ul>
</li>
<li>
<p>Traverse again over the cells of the image. Let's call the current cell <code>img[i][j]</code>. Extract the smoothed value from <code>img[i][j]</code> using <code>img[i][j] &gt;&gt; 8</code>, and store it in <code>img[i][j]</code></p>
</li>
<li>
<p>Return the <code>img</code>.</p>
</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/HdLbENr2/shared">code</a></p>
<p><strong>Implementation Notes:</strong> Different programming languages have different notations of bitwise operators. For example, for the bitwise NOT operator, we have the following notations:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic">C++</a> uses <code>~</code></li>
<li><a href="https://go.dev/ref/spec">Go</a> uses unary <code>^</code> operator</li>
<li><a href="https://hexdocs.pm/elixir/1.13.0/Bitwise.html">Elixir</a> uses <code>~~~</code>, or <code>bnot</code></li>
<li><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Rust</a> uses <code>!</code></li>
<li>In <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/inv.html">Kotlin</a>, we can use <code>inv()</code> function</li>
</ul>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows in the <code>img</code> matrix, and <span class="math inline">\(n\)</span> be the number of columns in the <code>img</code> matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We are traversing every cell of the <code>img</code> matrix. There are <span class="math inline">\(m \cdot n\)</span> cells in the <code>img</code> matrix.</p>
<p>For each cell, we are iterating over all plausible nine indices. There are at most nine indices for each cell. At each index, we are doing constant time bitwise operations.</p>
<blockquote>
<p>We are taking bitwise AND (<code>&amp;</code>) of <code>sum</code> and <code>255</code>. Now there can be at most <span class="math inline">\(32\)</span> (or any other constant number) bits in an integer. Hence, the <code>&amp;</code> operator will be done at most <span class="math inline">\(32\)</span> times. Thus, the time complexity of the bitwise AND (<code>&amp;</code>) operator is <span class="math inline">\(O(32)\)</span>, which is <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<blockquote>
<p>We are left shifting (<code>&lt;&lt;</code>) an integer (<code>sum / count</code>) by <code>8</code> bits.</p>
<p>Left shifting <span class="math inline">\(1\)</span> bit in a signed integer is done by</p>
<ul>
<li>
<p>Assigning to every non-signed bit the value of the bit to its right side</p>
</li>
<li>
<p>The LSB doesn't have any bit to its right side, so it is assigned <code>0</code></p>
</li>
</ul>
<p>Hence, there will be at most <span class="math inline">\(31\)</span> such assignments in one left shift, since in a signed integer, the MSB is used to represent the sign of the integer, and it is retained as it is in the left shift.</p>
<p>Hence, number of assignments in one left shift is <span class="math inline">\(31\)</span>, and in <span class="math inline">\(8\)</span> left shifts, it is <span class="math inline">\(31 \cdot 8 = 248\)</span>. Thus, the time complexity of the left shift (<code>&lt;&lt;</code>) operator is <span class="math inline">\(O(248)\)</span>, which is <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<blockquote>
<p>We are also doing bitwise OR (<code>|</code>) of two integers <code>img[i][j]</code> and <code>(sum / count) &lt;&lt; 8</code>. Now there can be at most <span class="math inline">\(32\)</span> (or any other constant number) bits in an integer. Hence, the <code>|</code> operator will be done at most <span class="math inline">\(32\)</span> times. Thus, the time complexity of the bitwise OR (<code>|</code>) operator is <span class="math inline">\(O(32)\)</span>, which is <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<p>Again, we are traversing over all the cells of the <code>img</code> matrix to extract the smoothed value from the encoded value using the bitwise operator.</p>
<blockquote>
<p>We are right shifting (<code>&gt;&gt;</code>) an integer (<code>img[i][j]</code>) by <code>8</code> bits.</p>
<p>Right shifting <span class="math inline">\(1\)</span> bit in a signed integer is done by</p>
<ul>
<li>
<p>Assigning to every non-signed bit the value of the bit to its left side, except for the <em>second most significant bit</em></p>
</li>
<li>
<p>The <em>second most significant bit</em> has to its left side the <em>most significant bit</em>, which is used to represent the sign of the integer. Hence, the <em>second most significant bit</em> is assigned the value of <code>0</code></p>
</li>
</ul>
<p>Hence, there will be at most <span class="math inline">\(31\)</span> such assignments in one right shift, since in a signed integer, the MSB is used to represent the sign of the integer, and it is retained as it is in the right shift.</p>
<p>Hence, number of assignments in one right shift is <span class="math inline">\(31\)</span>, and in <span class="math inline">\(8\)</span> right shifts, it is <span class="math inline">\(31 \cdot 8 = 248\)</span>. Thus, the time complexity of the right shift (<code>&gt;&gt;</code>) operator is <span class="math inline">\(O(248)\)</span>, which is <span class="math inline">\(O(1)\)</span>.</p>
</blockquote>
<p>Hence, the time complexity of the algorithm is <span class="math inline">\(O((m \cdot n \cdot 9) + (m \cdot n))\)</span>, which is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We are not using any extra space. Smoothened values are encoded and extracted in the existing integer value of <code>img</code>. Hence, the space complexity of the algorithm is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/increment-submatrices-by-one/description" target="_blank" rel="noopener noreferrer">Increment Submatrices by One</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code>, indicating that we initially have an <code>n x n</code>&nbsp;<strong>0-indexed</strong> integer matrix <code>mat</code> filled with zeroes.</p>

<p>You are also given a 2D integer array <code>query</code>. For each <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code>, you should do the following operation:</p>

<ul>
	<li>Add <code>1</code> to <strong>every element</strong> in the submatrix with the <strong>top left</strong> corner <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> and the <strong>bottom right</strong> corner <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code>. That is, add <code>1</code> to <code>mat[x][y]</code> for all <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> and <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code>.</li>
</ul>

<p>Return<em> the matrix</em> <code>mat</code><em> after performing every query.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example11.png" style="width: 531px; height: 121px;" />
<pre>
<strong>Input:</strong> n = 3, queries = [[1,1,2,2],[0,0,1,1]]
<strong>Output:</strong> [[1,1,0],[1,2,1],[0,1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example22.png" style="width: 261px; height: 82px;" />
<pre>
<strong>Input:</strong> n = 2, queries = [[0,0,1,1]]
<strong>Output:</strong> [[1,1],[1,1]]
<strong>Explanation:</strong> The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>
	<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reversing-the-rows-of-a-matrix-1587115621/1" target="_blank" rel="noopener noreferrer">Interchanging the rows of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix of dimensions n1 x m1. Interchange its rows&nbsp;in-place such that the first&nbsp;row&nbsp;will become the last&nbsp;row&nbsp;and so on.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
n1 = 4, m1 = 4
matrix[][] = {{1, 2, 3, 4},
&nbsp;            {5, 6, 7, 8},
    &nbsp;        {9, 10, 11, 12},
    &nbsp;        {13, 14, 15,16}}
<strong>Output</strong>: 
13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4
<strong>Explanation</strong>:
Matrix after exchanging rows:
13 14 15 16
 9 10 11 12
 5  6  7  8
 1  2  3  4
<strong>Note</strong>: Output is printed row-wise linearly. 
</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:
n1 = 5, m1 = 3
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
matrix[][] = {{1, 2, 3},
&nbsp;            {4, 5, 6},
    &nbsp;        {7, 8, 9},
    &nbsp;        {10, 11, 12},
&nbsp;            {13, 14, 15}}
<strong>Output</strong>: 
13 14 15 10 11 12 7 8 9 4 5 6 1 2 3
<strong>Explanation</strong>:
After interchanging rows:
13 14 15
10 11 12
 7  8  9
 4  5  6
 1  2  3

</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You dont need to read input or print anything.&nbsp;Complete the function<strong> interchangeRows()&nbsp;</strong>that takes matrix<strong> </strong>as input parameter&nbsp;and modifies<strong> </strong>the matrix in-place such that the first row becomes the last row and so on.<br /><br /><strong>Expected Time Complexity:</strong> O(n1 * m1)<br /><strong>Expected Auxiliary Space:</strong> O(1)<br /><br /><strong>Constraints:</strong><br />1 &lt;= n<sub>1</sub>, m<sub>1</sub> &lt;= 100<br />1 &lt;= matrix[i][j]&nbsp;&lt;= 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/island-perimeter/description" target="_blank" rel="noopener noreferrer">Island Perimeter</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given <code>row x col</code> <code>grid</code> representing a map where <code>grid[i][j] = 1</code> represents&nbsp;land and <code>grid[i][j] = 0</code> represents water.</p>

<p>Grid cells are connected <strong>horizontally/vertically</strong> (not diagonally). The <code>grid</code> is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>

<p>The island doesn&#39;t have &quot;lakes&quot;, meaning the water inside isn&#39;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/12/island.png" style="width: 221px; height: 213px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The perimeter is the 16 yellow stripes in the image above.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0]]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>row == grid.length</code></li>
	<li><code>col == grid[i].length</code></li>
	<li><code>1 &lt;= row, col &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li>There is exactly one island in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/is-sudoku-valid4820/1" target="_blank" rel="noopener noreferrer">Is Sudoku Valid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an&nbsp;incomplete Sudoku&nbsp;configuration in terms of a 9x9 &nbsp;2-D square matrix(<strong>mat[][]</strong>)&nbsp;the task to check if the current configuration is valid or not where a 0 represents an empty block.<br /><strong>Note:</strong> Current valid configuration does not ensure validity of the final solved sudoku.&nbsp;<br /></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat[][] = [
[3, 0, 6, 5, 0, 8, 4, 0, 0]
[5, 2, 0, 0, 0, 0, 0, 0, 0]
[0, 8, 7, 0, 0, 0, 0, 3, 1]
[0, 0, 3, 0, 1, 0, 0, 8, 0]
[9, 0, 0, 8, 6, 3, 0, 0, 5]
[0, 5, 0, 0, 9, 0, 6, 0, 0]
[1, 3, 0, 0, 0, 0, 2, 5, 0]
[0, 0, 0, 0, 0, 0, 0, 7, 4]
[0, 0, 5, 2, 0, 6, 3, 0, 0]
]
<strong>Output:</strong> true
<strong>Explaination:</strong> It is possible to have aproper sudoku.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat[][] = [
[3, 0, 3, 5, 0, 8, 4, 0, 0]
[5, 2, 0, 0, 0, 0, 0, 0, 0]
[0, 8, 7, 0, 0, 0, 0, 3, 1]
[0, 0, 3, 0, 1, 0, 0, 8, 0]
[9, 0, 0, 8, 6, 3, 0, 0, 5]
[0, 5, 0, 0, 9, 0, 6, 0, 0]
[1, 3, 0, 0, 0, 0, 2, 5, 0]
[0, 0, 0, 0, 0, 0, 0, 7, 4]
[0, 0, 5, 2, 0, 6, 3, 0, 0]
]
<strong>Output:</strong> false
<strong>Explaination:</strong> It is not possible to have aproper sudoku.<br /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat[][] = [
[2, 0, 2, 5, 0, 8, 4, 0, 0]
[5, 2, 0, 0, 0, 0, 0, 0, 0]
[0, 8, 7, 0, 0, 0, 0, 3, 1]
[0, 0, 3, 0, 1, 0, 0, 8, 0]
[9, 0, 0, 8, 6, 3, 0, 0, 5]
[0, 5, 0, 0, 9, 0, 6, 0, 0]
[1, 3, 0, 0, 0, 0, 2, 5, 0]
[0, 0, 0, 0, 0, 0, 0, 7, 4]
[0, 0, 5, 2, 0, 6, 3, 0, 0]
]
<strong>Output:</strong> false
<strong>Explaination:</strong> It is not possible to have aproper sudoku.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />0 &le; mat[i][j] &le; 9</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-highest-ranked-items-within-a-price-range/description" target="_blank" rel="noopener noreferrer">K Highest Ranked Items Within a Price Range</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> that represents a map of the items in a shop. The integers in the grid represent the following:</p>

<ul>
	<li><code>0</code> represents a wall that you cannot pass through.</li>
	<li><code>1</code> represents an empty cell that you can freely move to and from.</li>
	<li>All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.</li>
</ul>

<p>It takes <code>1</code> step to travel between adjacent grid cells.</p>

<p>You are also given integer arrays <code>pricing</code> and <code>start</code> where <code>pricing = [low, high]</code> and <code>start = [row, col]</code> indicates that you start at the position <code>(row, col)</code> and are interested only in items with a price in the range of <code>[low, high]</code> (<strong>inclusive</strong>). You are further given an integer <code>k</code>.</p>

<p>You are interested in the <strong>positions</strong> of the <code>k</code> <strong>highest-ranked</strong> items whose prices are <strong>within</strong> the given price range. The rank is determined by the <strong>first</strong> of these criteria that is different:</p>

<ol>
	<li>Distance, defined as the length of the shortest path from the <code>start</code> (<strong>shorter</strong> distance has a higher rank).</li>
	<li>Price (<strong>lower</strong> price has a higher rank, but it must be <strong>in the price range</strong>).</li>
	<li>The row number (<strong>smaller</strong> row number has a higher rank).</li>
	<li>The column number (<strong>smaller</strong> column number has a higher rank).</li>
</ol>

<p>Return <em>the </em><code>k</code><em> highest-ranked items within the price range <strong>sorted</strong> by their rank (highest to lowest)</em>. If there are fewer than <code>k</code> reachable items within the price range, return <em><strong>all</strong> of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png" style="width: 200px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
<strong>Output:</strong> [[0,1],[1,1],[2,1]]
<strong>Explanation:</strong> You start at (0,0).
With a price range of [2,5], we can take items from (0,1), (1,1), (2,1) and (2,2).
The ranks of these items are:
- (0,1) with distance 1
- (1,1) with distance 2
- (2,1) with distance 3
- (2,2) with distance 4
Thus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png" style="width: 200px; height: 151px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
<strong>Output:</strong> [[2,1],[1,2]]
<strong>Explanation:</strong> You start at (2,3).
With a price range of [2,3], we can take items from (0,1), (1,1), (1,2) and (2,1).
The ranks of these items are:
- (2,1) with distance 2, price 2
- (1,2) with distance 2, price 3
- (1,1) with distance 3
- (0,1) with distance 4
Thus, the 2 highest ranked items in the price range are (2,1) and (1,2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/30/example3.png" style="width: 149px; height: 150px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
<strong>Output:</strong> [[2,1],[2,0]]
<strong>Explanation:</strong> You start at (0,0).
With a price range of [2,3], we can take items from (2,0) and (2,1). 
The ranks of these items are: 
- (2,1) with distance 5
- (2,0) with distance 6
Thus, the 2 highest ranked items in the price range are (2,1) and (2,0). 
Note that k = 3 but there are only 2 reachable items within the price range.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>pricing.length == 2</code></li>
	<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>
	<li><code>start.length == 2</code></li>
	<li><code>0 &lt;= row &lt;= m - 1</code></li>
	<li><code>0 &lt;= col &lt;= n - 1</code></li>
	<li><code>grid[row][col] &gt; 0</code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/knight-in-geekland--170647/1" target="_blank" rel="noopener noreferrer">Knight in Geekland</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bfs</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Knight is at <strong>(start_x,start_y)</strong> in Geekland which is represented by an <strong>NxM</strong> 2D matrix.<br />Each cell in the matrix contains some points. In the ith step, the knight can collect all the points from all the cells that can be visited in exactly i steps without revisiting any cell.<br />Also, the knight has some magical powers that enable him to fetch coins from the future i.e. If the knight can collect y coins in the xth step he can fetch all the coins that he will collect in the (x + y)th step and if the knight can collect z coins in the (x + y)th step he can fetch all the coins that he will collect in the (x + y + z)th step and so on without increasing the step count i.e. knight will stay on xth step and will get all the coins of the future steps mentioned above((x + y)th step coins + (x + y+z)th steps + ...).</span></p>
<p><span style="font-size: 18px;"><strong>For example</strong>, If in 1st step knight can collect 1 point, then knight will also collect all the points which are at (1+1)th step i.e. 2 steps, and if knight can collect 3 points in (1+1)th step then knight will also collect all the points at (1+1+3)th step and so on. Hence being only at the first step knight can collect overall 1+3 = 4 points if there are no points available at (1+1+3)th step.</span></p>
<p><span style="font-size: 18px;">Find the minimum number of steps required to collect the maximum points.<br /><strong>Note:</strong> The <a href="https://en.wikipedia.org/wiki/Knight_(chess)#:~:text=Compared%20to%20other%20chess%20pieces,pieces%20to%20reach%20its%20destination.">knight moves</a> exactly the same as the knight on a chess board. Please follow 0 indexing.</span></p>
<p><span style="font-size: 18px;">Example 1:</span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n = 9
m = 10
start_x = 4, start_y = 5
arr =
0 0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0
0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0 <span style="color: #ff0000;"><strong>1</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> 0 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #000000;"><strong><span style="background-color: #ffff00;">0</span></strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> 0
0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0 <span style="color: #ff0000;"><strong>0</strong></span> <span style="color: #00ff00;"><strong>2</strong></span> <span style="color: #ff0000;"><strong>0</strong></span> 0 0 <span style="color: #00ff00;"><strong>2</strong></span>
0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0
0 0 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 <span style="color: #00ff00;"><strong>2</strong></span> 0 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> minimum knight have to take 1 steps to gain maximum points.
Initially, the knight has 0 coins, he will take 1 step to collect 1 point (sum of cells denoted in red color).
Now in the second step, he can collect points from all the cells colored green i.e. 64 points.
But with his magical power, at the 1st step, he can fetch points from the (1 + 1)th step. Therefore he can collect 1 + 64 coins at step 1 only. Hence answer is 1.</span>
</pre>
<p><span style="font-size: 18px;">Example 2:</span></p>
<pre><span style="font-size: 18px;">Input:
n = 3 
m = 3
start_x = 2, start_y = 1
arr =
7 6 8
9 1 4
6 2 8
Output:0
Explanation:
Initially, the knight has 2 points, or more formally we can say that at the 0th step knight has 2 points.
In the first step, he can collect points from cells (0, 0) and (0, 2) i.e. 15 points.
In the second step, he can collect points from cells (1, 0) and (1, 2) i.e. 13 coins.
In the third step, he can collect points from cells (2, 0) and (2, 2) i.e. 14 points.
In the fourth step, he can collect points from the cell (0, 1) i.e. 6 points.
So in each step, he can collect coins like -You can see in the below image  Knight can collect 15 coins in the 0th step only
<img style="height: 430px; width: 500px;" src="https://media.geeksforgeeks.org/img-practice/rect46213-1668840290.png" alt="" /></span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function knightInGeekland() which takes 2-d array <strong>arr[][],</strong>&nbsp;starting coordinates of knight <strong>start_x, and start_y&nbsp;</strong>as input, and return an integer value as min steps to gain max points.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N*M)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />&nbsp;&nbsp;&nbsp;1 &lt;= len(arr), len(arr[0])&nbsp;&lt;&nbsp;10<sup>3</sup><br />&nbsp; &nbsp;0&nbsp;&lt;= values in arr &lt;=100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kronecker-product0918/1" target="_blank" rel="noopener noreferrer">Kronecker Product</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>n*m</strong>&nbsp;matrix <strong>A</strong> and a <strong>p*q</strong>&nbsp;matrix <strong>B</strong>, their <strong>Kronecker product</strong> C = A tensor B, also called their matrix direct product, is an <strong>(np)*(mq)</strong>&nbsp;matrix.<br />
A tensor B<br />
=<br />
|a<sub>11</sub>B &nbsp; &nbsp;a<sub>12</sub>B|&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
|a<sub>21</sub>B &nbsp; &nbsp;a<sub>22</sub>B|<br />
=&nbsp; &nbsp;<br />
|a<sub>11</sub>b<sub>11 &nbsp;&nbsp;</sub> a<sub>11</sub>b<sub>12 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>11 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>12</sub>|<br />
|a<sub>11</sub>b<sub>21 &nbsp;&nbsp;</sub> a<sub>11</sub>b<sub>22 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>21 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>22</sub>|<br />
|a<sub>11</sub>b<sub>31 &nbsp;&nbsp;</sub> a<sub>11</sub>b<sub>32 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>31 &nbsp;&nbsp;</sub> a<sub>12</sub>b<sub>32</sub>|<br />
|a<sub>21</sub>b<sub>11 &nbsp;&nbsp;</sub> a<sub>21</sub>b<sub>12 &nbsp;&nbsp;</sub> a<sub>22</sub>b<sub>11 &nbsp;&nbsp;</sub> a<sub>22</sub>b<sub>12</sub>|<br />
|a<sub>21</sub>b<sub>21 &nbsp;&nbsp;</sub> a<sub>21</sub>b<sub>22 &nbsp;&nbsp;</sub> a<sub>22</sub>b<sub>21 &nbsp;&nbsp;</sub> a<sub>22</sub>b<sub>22</sub>|<br />
|a<sub>21</sub>b<sub>31 &nbsp;&nbsp;</sub> a<sub>21</sub>b<sub>32 &nbsp;&nbsp;</sub> a<sub>22</sub>b<sub>31 &nbsp; </sub>&nbsp;a<sub>22</sub>b<sub>32</sub>|</span></p>

<p>&nbsp;</p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
n = 2, m = 2 
p = 2, q = 2
A = {{1, 2}, 
&nbsp;    {3, 4}}
B = {{0, 5}, 
&nbsp;    {6, 7}}
<strong>Output:</strong> {{0, 5, 0, 10}, 
&nbsp;        {6, 7, 12, 14}, 
&nbsp;        {0, 15, 0, 20}, 
&nbsp;        {18, 21, 24, 28}}
<strong>Explaination:</strong> If the multiplication process 
is followed then this will be the answer.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>kroneckerProduct()</strong> which takes n, m, p, q and A and B as input parameters and returns the resultant matrix.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(n*m*p*q)<br />
<strong>Expected Auxiliary Space:</strong> O(n*m*p*q)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n, m, p, q &le; 20<br />
1 &le; A[i][j], B[i][j] &le; 100&nbsp;</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/kth-element-in-matrix/1" target="_blank" rel="noopener noreferrer">Kth smallest element in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binarysearch</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">heap</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;">Given a matrix&nbsp;<strong>mat[][]</strong>&nbsp;of size <strong>n*n</strong>, where each row and column is sorted in&nbsp;<strong>non-decreasing</strong>&nbsp;order. Find the&nbsp;<strong>kth</strong>&nbsp;smallest element in the matrix.</span></span></p>
<div><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Examples:</strong></span></span></div>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>mat[][] = [[16, 28, 60, 64], k = 3<br />                [22, 41, 63, 91],<br />                [27, 50, 87, 93],<br />                [36, 78, 87, 94]]
<strong>Output: </strong>27
<strong>Explanation: </strong>27 is the 3<sup>rd</sup> smallest element.</span></span></pre>
<pre><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Input: </strong>mat[][] = [[10, 20, 30, 40], k = 7<br />                [15, 25, 35, 45],<br />                [24, 29, 37, 48],<br />                [32, 33, 39, 50]] 
<strong>Output: </strong>30
<strong>Explanation: </strong>30 is the 7<sup>th</sup> smallest element.</span></span></pre>
<p><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;"><strong>Constraints:</strong><br />1 &le; n &le; 500<br />1 &le; mat[i][j] &le; 10<sup>4</sup></span></span><br /><span style="font-size: 18px;"><span style="font-family: arial,helvetica,sans-serif;">1 &le; k &le; n*n</span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description" target="_blank" rel="noopener noreferrer">Kth Smallest Element in a Sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest element in the matrix</em>.</p>

<p>Note that it is the <code>k<sup>th</sup></code> smallest element <strong>in the sorted order</strong>, not the <code>k<sup>th</sup></code> <strong>distinct</strong> element.</p>

<p>You must find a solution with a memory complexity better than <code>O(n<sup>2</sup>)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
<strong>Output:</strong> 13
<strong>Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<u><strong>13</strong></u>,15], and the 8<sup>th</sup> smallest number is 13
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[-5]], k = 1
<strong>Output:</strong> -5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li>
	<li><code>1 &lt;= k &lt;= n<sup>2</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li>
	<li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href="http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf" target="_blank">this paper</a> fun.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-1-bordered-square/description" target="_blank" rel="noopener noreferrer">Largest 1-Bordered Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D <code>grid</code> of <code>0</code>s and <code>1</code>s, return the number of elements in&nbsp;the largest <strong>square</strong>&nbsp;subgrid that has all <code>1</code>s on its <strong>border</strong>, or <code>0</code> if such a subgrid&nbsp;doesn&#39;t exist in the <code>grid</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> 9
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,0,0]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length &lt;= 100</code></li>
	<li><code>1 &lt;= grid[0].length &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-local-values-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Largest Local Values in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>grid</code>.</p>

<p>Generate an integer matrix <code>maxLocal</code> of size <code>(n - 2) x (n - 2)</code> such that:</p>

<ul>
	<li><code>maxLocal[i][j]</code> is equal to the <strong>largest</strong> value of the <code>3 x 3</code> matrix in <code>grid</code> centered around row <code>i + 1</code> and column <code>j + 1</code>.</li>
</ul>

<p>In other words, we want to find the largest value in every contiguous <code>3 x 3</code> matrix in <code>grid</code>.</p>

<p>Return <em>the generated matrix</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/21/ex1.png" style="width: 371px; height: 210px;" />
<pre>
<strong>Input:</strong> grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
<strong>Output:</strong> [[9,9],[8,6]]
<strong>Explanation:</strong> The diagram above shows the original matrix and the generated matrix.
Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png" style="width: 436px; height: 240px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
<strong>Output:</strong> [[2,2,2],[2,2,2],[2,2,2]]
<strong>Explanation:</strong> Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>3 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given an integer matrix <code>grid</code> of size <span class="math inline">\(N \cdot N\)</span>. For each element <code>(i, j)</code> in the <code>grid</code>, we need to find the maximum value in the <span class="math inline">\(3 \cdot 3\)</span> matrix with the top left cell as <code>(i, j)</code>. The local maximums should be returned in a new matrix. Note that we need to add the value to the new matrix only for <code>(i, j)</code> values with a valid <span class="math inline">\(3 \cdot 3\)</span> matrix. Therefore, the size of the new matrix is always <span class="math inline">\((N - 2) \cdot (N - 2)\)</span>, and the last two rows and columns in the original matrix grid are left out.</p>
<p>We will follow the process given in the problem description to generate the new matrix. <span class="math inline">\(3 \cdot 3\)</span> matrices cannot be created from the last two rows and last two columns as of <code>grid</code>, so we will iterate over the rows from <code>0</code> to <code>N - 2</code> and columns from <code>0</code> to <code>N - 2</code> in the <code>grid</code>. For each cell, we will iterate over the <span class="math inline">\(3 \cdot 3\)</span> matrix and find the local maximum value. This value will be stored in the new matrix <code>maxLocal</code>.</p>
<p>The below figure demonstrates each step of the <code>maxLocal</code> grid creation. At each step, we iterate over the <span class="math inline">\(3 \cdot 3\)</span> matrix and add the maximum value to the <code>maxLocal</code> grid.</p>
<p><img src="../Figures/2373/2373A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an empty matrix <code>maxLocal</code> of size <span class="math inline">\((N - 2) \cdot (N - 2)\)</span>, this will store the maximum values of all possible <code>3 x 3</code> matrices.</li>
<li>Define the <code>findMax</code> function, which takes the <code>grid</code> and the coordinates <code>(x, y)</code> as parameters. This function finds the maximum value in the <code>3 x 3</code> section of the grid, where <code>(x, y)</code> is the top-left corner.
<ul>
<li>Iterate over the <code>3 x 3</code> matrix starting with <code>(x, y)</code> as top-left cell.</li>
<li>Find and return the maximum value as <code>maxElement</code>.</li>
</ul>
</li>
<li>Iterate over the <code>grid</code> rows <code>0</code> to <code>N - 2</code> and columns <code>0</code> to <code>N - 2</code>, and for each cell <code>(i, j)</code>:
<ul>
<li>Use <code>findMax(grid, i, j)</code> to find the maximum local element and store it in the matrix <code>maxLocal</code> at position <code>(i, j)</code>.</li>
</ul>
</li>
<li>Return <code>maxLocal</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hz258aNG/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of rows and columns in the matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot N)\)</span></p>
<p>We iterate over the matrix <code>grid</code> rows <code>0</code> to <code>N - 2</code> and columns <code>0</code> to <code>N - 2</code> using nested loops. In the inner loop, we call the <code>findMax</code> function, so it is called <span class="math inline">\((N - 2 )^2\)</span> times. The <code>findMax</code> function iterates over the <span class="math inline">\(3 \cdot 3\)</span> matrix to find the maximum value. Hence, the total number of operations will be <span class="math inline">\(9 \cdot (N -2)^2\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(N ^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N \cdot N)\)</span></p>
<p>We need to create a new matrix <code>maxLocal</code> of size <span class="math inline">\((N -2)^2\)</span>; hence, the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-magic-square/description" target="_blank" rel="noopener noreferrer">Largest Magic Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <code>k x k</code> <strong>magic square</strong> is a <code>k x k</code> grid filled with integers such that every row sum, every column sum, and both diagonal sums are <strong>all equal</strong>. The integers in the magic square <strong>do not have to be distinct</strong>. Every <code>1 x 1</code> grid is trivially a <strong>magic square</strong>.</p>

<p>Given an <code>m x n</code> integer <code>grid</code>, return <em>the <strong>size</strong> (i.e., the side length </em><code>k</code><em>) of the <strong>largest magic square</strong> that can be found within this grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg" style="width: 413px; height: 335px;" />
<pre>
<strong>Input:</strong> grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The largest magic square has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg" style="width: 333px; height: 255px;" />
<pre>
<strong>Input:</strong> grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-the-largest-rectangle-of-1s-with-swapping-of-columns-allowed0243/1" target="_blank" rel="noopener noreferrer">Largest rectangle of 1s with swapping of columns allowed</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a matrix <strong>mat</strong>&nbsp;of size <strong>R*C</strong> with 0 and 1s, find the largest rectangle of all 1s in the matrix. The rectangle can be formed by swapping any pair of columns of given matrix.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
R = 3, C = 5
mat[][] = {{0, 1, 0, 1, 0},
           {0, 1, 0, 1, 1},
           {1, 1, 0, 1, 0}};
<strong>Output:</strong> 6
<strong>Explanation: </strong>The largest rectangle&#39;s area
is 6. The rectangle can be formed by
swapping column  2 with 3. The matrix
after swapping will be
     0 0 1 1 0
     0 0 1 1 1
     1 0 1 1 0
</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>R = 4, C = 5
mat[][] = {{0, 1, 0, 1, 0},
           {0, 1, 1, 1, 1},
           {1, 1, 1, 0, 1},
           {1, 1, 1, 1, 1}};
<strong>Output:</strong> 9
</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>maxArea()</strong>&nbsp;which takes the 2D array of&nbsp;booleans&nbsp;<strong>mat,</strong>&nbsp;<strong>r&nbsp;</strong>and<strong>&nbsp;c</strong><strong>&nbsp;</strong>as parameters and returns an integer denoting the answer.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(R*(R + C))<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(R*C)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;= R,C &lt;=10<sup>3</sup><br />
0 &lt;= mat[i][j] &lt;= 1</span></p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-rectangular-sub-matrix-whose-sum-is-0/1" target="_blank" rel="noopener noreferrer">Largest rectangular sub-matrix whose sum is 0</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">hash</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a matrix <strong>mat[][]</strong>. Find the size of the largest sub-matrix whose <strong>sum</strong> is equal to <strong>zero</strong>. The size of a matrix is the product of rows and columns. A sub-matrix is a matrix obtained from the given matrix by deletion of several (possibly, zero or all) rows/columns from the beginning and several (possibly, zero or all) rows/columns from the end.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"><span style="font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif;"><strong>Input: </strong>mat[][] = [[9, 7, 16, 5], [1, -6, -7, 3], [1, 8, 7, 9], [7, -2, 0, 10]] <strong>
Output: </strong>6<strong>
Explanation: <br /></strong></span></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/710026/Web/Other/blobid0_1736762643.png" alt="" width="488" height="432" /></span></pre>
<pre style="font-weight: 400;"><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] =  [[1, 2, 3], [-3, -2, -1], [1, 7, 5]]
<strong>Output:</strong>  6
<strong>Explanation:<br /></strong><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/710026/Web/Other/blobid1_1736762643.png" alt="" width="478" height="426" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> mat[][] = [[1, -1], [-1, 1]]
<strong>Output:</strong> 4<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation:</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> The largest sub-matrix with sum 0 is </span>[[1, -1], [-1, 1]].</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints</strong>:<br />1 &lt;= mat.size(), mat[0].size() &lt;= 100<br />-1000 &lt;= mat[][] &lt;= 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-square-with-sum-at-most-k/1" target="_blank" rel="noopener noreferrer">Largest Square with Sum at Most K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">mathematical</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a matrix <strong>mat[][]</strong> of size <strong>n*m</strong>&nbsp;and an integer <strong>k</strong>. Find the <strong>maximum </strong>length of a square submatrix having the <strong>sum </strong>of elements less than or equal to <strong>k</strong>. Return <strong>0</strong> if no such square exits.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><span style="font-size: 14pt;"><strong>Input: </strong></span><span style="font-size: 18.6667px;">k = 6,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 14pt;">mat[][]<strong> =</strong> </span><span style="font-size: 18.6667px;">[[1, 1, 1, 1],
          [1, 0, 0, 0],
          [1, 0, 0, 0],
          [1, 0, 0, 0]]<br /></span><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">3</span><strong style="font-size: 14pt;"><br />Explanation: </strong><span style="font-size: 14pt;">S</span></span><span style="font-size: 18.6667px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">quare submatrix from (0, 0) to (2, 2) with sum 5 is one of the valid answer.</span></pre>
<pre><span style="font-size: 14pt;"><span style="font-size: 14pt;"><strong>Input: </strong></span><span style="font-size: 18.6667px;">k = 1,<br /></span><span style="font-size: 14pt;">mat[][] = </span><span style="font-size: 18.6667px;">[[2, 2, 2],
          [2, 2, 2],
          [2, 2, 2],
          [2, 2, 2]]</span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">0</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span><span style="font-size: 18.6667px;">There is no valid answer.</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &le; n &times; m &le; 10</span><span style="font-size: 14pt;"><sup>6</sup><br />-10<sup>5</sup> &le; mat[i][j] &le; 10<sup>5</sup><br />0 &le; k &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-submatrix-with-rearrangements/description" target="_blank" rel="noopener noreferrer">Largest Submatrix With Rearrangements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a binary matrix <code>matrix</code> of size <code>m x n</code>, and you are allowed to rearrange the <strong>columns</strong> of the <code>matrix</code> in any order.</p>

<p>Return <em>the area of the largest submatrix within </em><code>matrix</code><em> where <strong>every</strong> element of the submatrix is </em><code>1</code><em> after reordering the columns optimally.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png" style="width: 500px; height: 240px;" />
<pre>
<strong>Input:</strong> matrix = [[0,0,1],[1,1,1],[1,0,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40852-pm.png" style="width: 500px; height: 62px;" />
<pre>
<strong>Input:</strong> matrix = [[1,0,1,0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 3.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,1,0],[1,0,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>matrix[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sort-by-height-on-each-baseline-row">Approach 1: Sort By Height On Each Baseline Row</h3>
<p><strong>Intuition</strong></p>
<p>A submatrix is just a rectangle - what is the area of a rectangle? It's <code>B * H</code>, where <code>B</code> is the base (width) and <code>H</code> is the height of the rectangle. As we are looking for the largest submatrix, we would prefer larger values for <code>B</code> and <code>H</code>.</p>
<p>While we can freely rearrange columns, we cannot do anything to change the order of the rows. Let's start by considering what effect rearranging columns has.</p>
<p><img src="../Figures/1727/1.png" alt="example" /><br />
<br></p>
<p>Using the example from the problem description, we see that by rearranging some columns, we can &quot;connect&quot; two 1s in the bottom row, thus increasing the base of the submatrix. Note that rearranging the columns has no effect on height.</p>
<p>If we were allowed to rearrange the rows, then that would affect the height because some 1s could &quot;connect&quot; vertically. Because we can freely rearrange columns, we have good control of the base, but no control on the height. As such, a good first step would be to determine how much height each column contributes on its own.</p>
<p>Let's modify <code>matrix</code> so that each <code>matrix[row][col]</code> represents the following value: &quot;how many consecutive 1s are there if we start from <code>matrix[row][col]</code> and move upward?&quot;</p>
<p><img src="../Figures/1727/2.png" alt="example" /><br />
<br></p>
<p>In the above image, consider the bottom right square <code>(2, 2)</code>. The value of this square is <code>3</code> because there are <code>3</code> consecutive ones in this column up to this point. The bottom middle square <code>(2, 1)</code> has a value of <code>0</code> because <code>matrix[2][1] = 0</code>, so any streak &quot;resets&quot;.</p>
<p>What is the point of this modification? Now, we can consider how much height each column can contribute at a given row. Take a look at the bottom row <code>[2, 0, 3]</code>. What happens if we sort it descending?</p>
<p><img src="../Figures/1727/3.png" alt="example" /><br />
<br></p>
<p>This sorted row <code>[3, 2, 0]</code> is saying:</p>
<ul>
<li>At column <code>0</code>, we have seen three consecutive ones.</li>
<li>At column <code>1</code>, we have seen two consecutive ones.</li>
<li>At column <code>2</code>, we have seen zero consecutive ones.</li>
</ul>
<p>Visually, this sorted row represents the following image:</p>
<p><img src="../Figures/1727/4.png" alt="example" /><br />
<br></p>
<p>Now, let's iterate over this sorted row and consider the largest submatrix we can make.</p>
<ul>
<li>At column <code>0</code>, we have a height of <code>3</code>. What is our base? We only have one column, so the base is <code>1</code>. Thus, we have an area of <code>3</code>.</li>
<li>At column <code>1</code>, we have a height of <code>2</code>. What is our base? Every column must have a height of at least <code>2</code> for us to have a valid submatrix. Because we sorted descending, every column to the left must have a height of <strong>at least</strong> <code>2</code>. Thus, we have a base of <code>2</code>, and an area of <code>2 * 2 = 4</code>.</li>
<li>At column <code>2</code>, we have a height of <code>0</code> and a base of <code>3</code>. The area is <code>0</code>.</li>
</ul>
<p>Now, hopefully, the idea is clear: at each column <code>col</code>, we know every column to its left has a height greater than or equal to the current height. Thus, we can treat the number of columns <code>col + 1</code> as the base to form a submatrix with the current height.</p>
<p>We iterate over the input <code>matrix</code> and keep track of how many consecutive ones each column has seen. To do this, for a given <code>row, col</code>, we first check if <code>matrix[row][col] != 0</code>. If so, we add the value of <code>matrix[row - 1][col]</code> to it. If <code>matrix[row][col] = 0</code>, we do nothing, which effectively resets the streak for the current column since the next iteration at <code>matrix[row + 1][col]</code> will reference <code>matrix[row][col]</code>, which is <code>0</code>. If we have a streak, then <code>matrix[row][col]</code> will continually increase by <code>1</code> for each row.</p>
<p>Once we have finished updating a row, we sort it descending and iterate over it to find the largest submatrix we can make if we treat the current row as the bottom of the submatrix. For a sorted <code>currRow</code>, we treat <code>currRow[i]</code> as the height and <code>i + 1</code> as the base. The reason we are allowed to sort each row is because sorting each row is equivalent to rearranging the columns, which we are allowed to do freely.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>m = matrix.length</code>, <code>n = matrix[0].length</code>, and the answer <code>ans = 0</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> to <code>m</code>:
<ul>
<li>Iterate <code>col</code> from <code>0</code> to <code>n</code>:
<ul>
<li>If <code>matrix[row][col] != 0</code> and <code>row &gt; 0</code>:
<ul>
<li>Add <code>matrix[row - 1][col]</code> to <code>matrix[row][col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Create a copy of <code>matrix[row]</code> as <code>currRow</code>, then sort <code>currRow</code> in descending order.</li>
<li>Iterate <code>i</code> over the indiecs of <code>currRow</code>:
<ul>
<li>Update <code>ans</code> with <code>currRow[i] * (i + 1)</code> if it is larger.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note that in Java, we can't conveniently sort <code>int[]</code> in descending order, so we sort it in ascending order and consider the base to the right of each column instead. For each column <code>i</code>, every column to its right has a height greater than or equal to the current height. Thus, we can treat the number of columns <code>n - i</code> as the base to form a submatrix with the current height.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/UzD8g98c/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(m\)</span> as the number of rows in <code>matrix</code> and <span class="math inline">\(n\)</span> as the number of columns in <code>matrix</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot \log{}n)\)</span></p>
<p>We iterate over <span class="math inline">\(m\)</span> rows. For each row, we update the values which costs <span class="math inline">\(O(n)\)</span>. Then, we sort the row, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>. Finally, we iterate over the row to calculate submatrix areas, which costs <span class="math inline">\(O(n)\)</span>.</p>
<p>Overall, each of the <span class="math inline">\(m\)</span> iterations costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Although we are only allocating <code>currRow</code> which has a size of <span class="math inline">\(O(n)\)</span>, we are modifying <code>matrix</code>. It is generally considered a bad practice to modify the input and when you do, you should count it as part of the space complexity.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-without-modifying-input">Approach 2: Without Modifying Input</h3>
<p><strong>Intuition</strong></p>
<p>Generally, it is not considered a good practice to modify the input, especially if the input is something passed by reference like an array. Also, many people will argue that when you modify the input, you must include it as part of the space complexity.</p>
<p>You may notice in the previous approach, as we iterate on a <code>row</code> and modify <code>matrix[row]</code>, we only depend on values from the previous row <code>matrix[row - 1]</code>. As such, instead of modifying the array, we will allocate a few arrays of size <span class="math inline">\(n\)</span> to avoid modifying the input.</p>
<ul>
<li><code>currRow</code>. This is analogous to <code>matrix[row]</code> from the previous approach. Therefore, <code>currRow[col] = matrix[row][col]</code> from the previous approach.</li>
<li><code>prevRow</code>. This is analogous to <code>matrix[row - 1]</code> from the previous approach. We will initialize it will all <code>0</code>.</li>
<li><code>sortedRow</code>. This is analogous to <code>currRow</code> from the previous approach. It is simply the copy of the current row that we will sort.</li>
</ul>
<p>At the start of each outer for-loop iteration, we will set <code>currRow</code> as a copy of <code>matrix[row]</code>. Then, we iterate over each column <code>col</code> and add <code>prevRow[col]</code> to <code>currRow[col]</code> if <code>currRow[col] != 0</code>, similar to the previous approach.</p>
<p>Once we have calculated <code>currRow</code>, we create the sorted copy <code>sortedRow</code> and iterate over it, calculating the answer in the same manner as the previous approach. Finally, before moving to the next row, we update <code>prevRow = currRow</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>m = matrix.length</code>, <code>n = matrix[0].length</code>, <code>prevRow</code> as an array of length <code>n</code> with values of <code>0</code>, and the answer <code>ans = 0</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> to <code>m</code>:
<ul>
<li>Set <code>currRow</code> as a copy of <code>matrix[row]</code>.</li>
<li>Iterate <code>col</code> from <code>0</code> to <code>n</code>:
<ul>
<li>If <code>currRow[col] != 0</code>:
<ul>
<li>Add <code>prevRow[col]</code> to <code>currRow[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Create a copy of <code>currRow</code> as <code>sortedRow</code>, then sort <code>sortedRow</code> in descending order.</li>
<li>Iterate <code>i</code> over the indiecs of <code>sortedRow</code>:
<ul>
<li>Update <code>ans</code> with <code>sortedRow[i] * (i + 1)</code> if it is larger.</li>
</ul>
</li>
<li>Update <code>prevRow = currRow</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>Note that in Java, we can't conveniently sort <code>int[]</code> in descending order, so we sort it in ascending order and consider the base to the right of each column instead. For each column <code>i</code>, every column to its right has a height greater than or equal to the current height. Thus, we can treat the number of columns <code>n - i</code> as the base to form a submatrix with the current height.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/brZgwKTX/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(m\)</span> as the number of rows in <code>matrix</code> and <span class="math inline">\(n\)</span> as the number of columns in <code>matrix</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot \log{}n)\)</span></p>
<p>We iterate over <span class="math inline">\(m\)</span> rows. For each row, we update the values which costs <span class="math inline">\(O(n)\)</span>. Then, we sort the row, which costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>. Finally, we iterate over the row to calculate submatrix areas, which costs <span class="math inline">\(O(n)\)</span>. There is also some <span class="math inline">\(O(n)\)</span> copying work.</p>
<p>Overall, each of the <span class="math inline">\(m\)</span> iterations costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We are using three arrays, all of size <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-no-sort">Approach 3: No Sort</h3>
<p><strong>Intuition</strong></p>
<p>In fact, we don't actually need to sort each row to implement the idea from the first two approaches!</p>
<p>Here, we will use the exact same idea: track the height that each column can contribute, then iterate over these heights in descending order to calculate the maximum area. The only question is, how do we iterate over the heights in descending order without sorting?</p>
<p>Let's think about a hypothetical list <code>heights</code>. In this list, we will store pairs of values: <code>(height, col)</code>. For each row, each pair represents: the column <code>col</code> has seen <code>height</code> consecutive ones. This hypothetical list will be sorted descending by the <code>height</code> values.</p>
<p>Let's say we also have a list <code>prevHeights</code>, which functions identically to <code>heights</code>, except it represents the previous row. Note that this relationship is the same as the one from the previous approach between <code>prevRow</code> and <code>currRow</code>.</p>
<p>For a given <code>row</code>, how do we compute <code>heights</code> out of <code>prevHeights</code>? First, we should only consider adding a column <code>col</code> to <code>heights</code> if <code>matrix[row][col] = 1</code>. Because if <code>matrix[row][col] = 0</code>, it means the current streak length is 0, and this column will contribute 0 to the area. Therefore, we don't need to add it to <code>heights</code> for traversal.</p>
<p>If <code>matrix[row][col] = 1</code>, there are two scenarios:</p>
<ol>
<li>We are currently on a consecutive streak for <code>col</code>. In this case, some pair with <code>col</code> must already exist in <code>prevHeights</code>.</li>
<li>We are starting a new streak for <code>col</code>, that is, <code>matrix[row - 1][col]</code> was <code>0</code>. We can simply add <code>(1, col)</code> to <code>heights</code>.</li>
</ol>
<p>Here's what we'll do: we iterate over each <code>(height, col)</code> pair in <code>prevHeights</code>. If <code>matrix[row][col] = 1</code>, then we have the first scenario and can extend the streak. We add <code>(height + 1, col)</code> to <code>heights</code>. Because we assume <code>prevHeights</code> is sorted descending already, we iterate over each <code>(height, col)</code> pair in sorted order as well. When we add a pair <code>(height + 1, col)</code> to <code>heights</code>, because the increment is <strong>fixed at <code>1</code></strong>, <code>heights</code> must also be sorted.</p>
<p>Next, we iterate over each <code>col</code> and check if <code>matrix[row][col] = 1</code>. If it is, <strong>AND</strong> <code>col</code> is not already in <code>heights</code>, then we should start a new streak by adding <code>(1, col)</code> to <code>heights</code>. How can we tell if <code>col</code> is already in <code>heights</code>? For each <code>row</code>, we can maintain a boolean array <code>seen</code>, where <code>seen[col]</code> indicates we have already added <code>col</code> to <code>heights</code>. We can set <code>seen[col] = true</code> for each <code>col</code> that gets added to <code>heights</code> in the previous step (iterating over <code>prevHeights</code>). Because we are iterating over each <code>col</code> <strong>after</strong> iterating over the elements of <code>prevHeights</code>, we will not lose the sorted order of <code>heights</code>, since <code>1</code> is the minimum height possible that can be in <code>heights</code>.</p>
<p>Thus, <code>heights</code> will remain sorted as long as our assumption that <code>prevHeights</code> was sorted is true. Initially on our first iteration, <code>prevHeights</code> is an empty list. As an empty list is technically sorted, the assumption is true, and at every iteration <code>heights</code> will be sorted!</p>
<p>Finally, we can perform the same process to calculate the answer: iterate over <code>heights</code> with an index variable <code>i</code> and treat <code>i + 1</code> as the base.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>m = matrix.length</code>, <code>n = matrix[0].length</code>, <code>prevHeights</code> as an empty list, and the answer <code>ans = 0</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> to <code>m</code>:
<ul>
<li>Initialize <code>heights</code> as an empty list.</li>
<li>Initialize <code>seen</code> as a boolean array of length <code>n</code> with values <code>false</code>.</li>
<li>Iterate over each <code>(height, col)</code> in <code>prevHeights</code>:
<ul>
<li>If <code>matrix[row][col] == 1</code>:
<ul>
<li>Add <code>(height + 1, col)</code> to <code>heights</code>.</li>
<li>Set <code>seen[col] = true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate <code>col</code> from <code>0</code> to <code>n</code>:
<ul>
<li>If <code>seen[col] = false</code> and <code>matrix[row][col] == 1</code>:
<ul>
<li>Add <code>(1, col)</code> to <code>heights</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate <code>i</code> over the indices of <code>heights</code>:
<ul>
<li>Update <code>ans</code> with <code>heights[i][0] * (i + 1)</code> if it is larger.</li>
</ul>
</li>
<li>Update <code>prevHeights = heights</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/etzSLBxi/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(m\)</span> as the number of rows in <code>matrix</code> and <span class="math inline">\(n\)</span> as the number of columns in <code>matrix</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We iterate over <span class="math inline">\(m\)</span> rows. For each row, we iterate over <code>prevHeights</code> which cannot have a length greater than <span class="math inline">\(n\)</span>. We also iterate over <span class="math inline">\(n\)</span> columns and <code>heights</code>, which similarly cannot have a length greater than <span class="math inline">\(n\)</span>.</p>
<p>Thus, each of the <span class="math inline">\(m\)</span> iterations costs <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>prevHeights</code> and <code>heights</code>, neither of which could possibly exceed a size of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/largest-subsquare-surrounded-by-x0558/1" target="_blank" rel="noopener noreferrer">Largest subsquare surrounded by X</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square matrix<strong> mat[][]</strong>, where each cell can be either '<strong>X</strong>' or '<strong>O</strong>', you need to find the size of the <strong>largest square subgrid</strong> that is completely surrounded by '<strong>X</strong>'. More formally you need to find the largest square within the grid where all its <strong>border cells are 'X'</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[X,X],[X,X]]
<strong>Output: </strong>2
<strong>Explanation: </strong>The largest square submatrix surrounded by X is the whole input matrix.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[X,X,X,O],[X,O,X,X],[X,X,X,O],[X,O,X,X]]
<strong>Output: </strong>3
<strong>Explanation:</strong>
Here,the input represents following 
matrix of size 4 x 4
<strong>X</strong> <strong>X</strong> <strong>X</strong> O
<strong>X</strong> O <strong>X</strong> X
<strong>X</strong> <strong>X</strong> <strong>X</strong> O
X O X X
The square submatrix starting at (0,0) and ending at (2,2) is the largest submatrix surrounded by X. Therefore, size of that matrix would be 3.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= mat.size() &lt;= 1000<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/last-cell-in-a-matrix/1" target="_blank" rel="noopener noreferrer">Last cell in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix&nbsp;of dimensions&nbsp;&nbsp;with <strong>R</strong>&nbsp;rows and <strong>C</strong>&nbsp;columns. Start from&nbsp;<strong>cell(0, 0)</strong>, moving in the&nbsp;<strong>right</strong> direction. Perform the following operations:&nbsp;</span></p>
<ul>
<li><span style="font-size: 18px;">If the value of&nbsp;<strong>matrix[i][j]</strong>&nbsp;is&nbsp;<strong>0</strong>, then traverse in the same direction and check the next value.</span></li>
<li><span style="font-size: 18px;">If the value of&nbsp;<strong>matrix[i][j]</strong>&nbsp;is&nbsp;<strong>1</strong>, then update&nbsp;<strong>matrix[i][j]</strong>&nbsp;to&nbsp;<strong>0</strong>&nbsp;and change the current direction clockwise. ie -&nbsp;<strong>up</strong>,&nbsp;<strong>right</strong>,&nbsp;<strong>down</strong>, or&nbsp;<strong>left</strong>&nbsp;directions change to&nbsp;<strong>right</strong>,&nbsp;<strong>down</strong>,&nbsp;<strong>left</strong>, and&nbsp;<strong>up</strong>&nbsp;respectively.</span></li>
</ul>
<p><span style="font-size: 18px;">Find the index of the cell where you will be forced to exit the matrix while performing the given traversal.&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
matrix[][] = {{0,1},
              {1,0}}
R=2
C=2</span>

<span style="font-size: 18px;"><strong>Output:</strong> (1,1)
<strong>Explanation:</strong>
<img style="height: 178px; width: 300px;" src="https://media.geeksforgeeks.org/img-practice/endpoint1-1622886995.jpg" alt="" />
<img style="height: 178px; width: 500px;" src="https://media.geeksforgeeks.org/img-practice/endpoint2-1622887085.jpg" alt="" />
<img style="height: 250px; width: 500px;" src="https://media.geeksforgeeks.org/img-practice/endpoint3-1622887174.jpg" alt="" /></span>

</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
matrix[][] = {{0, 1, 1, 1, 0},</span>
                   <span style="font-size: 18px;">{1, 0, 1, 0, 1},
              {1, 1, 1, 0, 0}}
R=3
C=5</span>

<span style="font-size: 18px;"><strong>Output:</strong> (2,0)
<strong>Explanation: </strong>We will leave the grid after visiting the index (2,0).</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Complete the function <strong>endPoints()</strong>&nbsp;which take a 2D matrix<strong>[][] </strong>, an integer <strong>R</strong> and an integer <strong>C </strong>as input parameters and returns the index of the last cell before exiting the matrix.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(R*C)<br /><strong>Expected Space Complexity:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= R,C&lt;=1000<br />0&lt;= matrix[i][j] &lt;=1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/last-day-where-you-can-still-cross/description" target="_blank" rel="noopener noreferrer">Last Day Where You Can Still Cross</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>1-based</strong> binary matrix where <code>0</code> represents land and <code>1</code> represents water. You are given integers <code>row</code> and <code>col</code> representing the number of rows and columns in the matrix, respectively.</p>

<p>Initially on day <code>0</code>, the <strong>entire</strong> matrix is <strong>land</strong>. However, each day a new cell becomes flooded with <strong>water</strong>. You are given a <strong>1-based</strong> 2D array <code>cells</code>, where <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> represents that on the <code>i<sup>th</sup></code> day, the cell on the <code>r<sub>i</sub><sup>th</sup></code> row and <code>c<sub>i</sub><sup>th</sup></code> column (<strong>1-based</strong> coordinates) will be covered with <strong>water</strong> (i.e., changed to <code>1</code>).</p>

<p>You want to find the <strong>last</strong> day that it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells. You can start from <strong>any</strong> cell in the top row and end at <strong>any</strong> cell in the bottom row. You can only travel in the<strong> four</strong> cardinal directions (left, right, up, and down).</p>

<p>Return <em>the <strong>last</strong> day where it is possible to walk from the <strong>top</strong> to the <strong>bottom</strong> by only walking on land cells</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;" />
<pre>
<strong>Input:</strong> row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;" />
<pre>
<strong>Input:</strong> row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>cells.length == row * col</code></li>
	<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>
	<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>
	<li>All the values of <code>cells</code> are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/description" target="_blank" rel="noopener noreferrer">Length of Longest V-Shaped Diagonal Segment</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer matrix <code>grid</code> of size <code>n x m</code>, where each element is either <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<p>A <strong>V-shaped diagonal segment</strong> is defined as:</p>

<ul>
	<li>The segment starts with <code>1</code>.</li>
	<li>The subsequent elements follow this infinite sequence: <code>2, 0, 2, 0, ...</code>.</li>
	<li>The segment:
	<ul>
		<li>Starts <strong>along</strong> a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).</li>
		<li>Continues the<strong> sequence</strong> in the same diagonal direction.</li>
		<li>Makes<strong> at most one clockwise 90-degree</strong><strong> turn</strong> to another diagonal direction while <strong>maintaining</strong> the sequence.</li>
	</ul>
	</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/11/length_of_longest3.jpg" style="width: 481px; height: 202px;" /></p>

<p>Return the <strong>length</strong> of the <strong>longest</strong> <strong>V-shaped diagonal segment</strong>. If no valid segment <em>exists</em>, return 0.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_1-2.jpg" style="width: 201px; height: 192px;" /></p>

<p>The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: <code>(0,2) &rarr; (1,3) &rarr; (2,4)</code>, takes a <strong>90-degree clockwise turn</strong> at <code>(2,4)</code>, and continues as <code>(3,3) &rarr; (4,2)</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_2.jpg" style="width: 201px; height: 201px;" /></strong></p>

<p>The longest V-shaped diagonal segment has a length of 4 and follows these coordinates: <code>(2,3) &rarr; (3,2)</code>, takes a <strong>90-degree clockwise turn</strong> at <code>(3,2)</code>, and continues as <code>(2,1) &rarr; (1,0)</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/12/09/matrix_3.jpg" style="width: 201px; height: 201px;" /></strong></p>

<p>The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: <code>(0,0) &rarr; (1,1) &rarr; (2,2) &rarr; (3,3) &rarr; (4,4)</code>.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>The longest V-shaped diagonal segment has a length of 1 and follows these coordinates: <code>(0,0)</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>m == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code> or <code>2</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-memoization-search">Approach: Memoization Search</h3>
<h4 id="intuition">Intuition</h4>
<p>According to the problem statement, the definition of a V-shaped diagonal segment is as follows:</p>
<ul>
<li>The starting element of the V-shaped diagonal segment must be <span class="math inline">\(1\)</span>, and the subsequent elements must alternate according to the sequence <span class="math inline">\([2,0,2,0,\cdots]\)</span>. In other words, the <strong>access sequence</strong> of elements must be <span class="math inline">\([1,2,0,2,0,\cdots]\)</span>.</li>
<li>Starting from one diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right), and continuing along that same diagonal, it is allowed to make at most one clockwise <span class="math inline">\(90^\circ\)</span> turn into another diagonal direction while still maintaining the sequence pattern.</li>
</ul>
<p>There are a total of <span class="math inline">\(4\)</span> diagonal directions: from the upper left to the lower right, from the upper right to the lower left, from the lower right to the upper left, and from the lower left to the upper right. The corresponding coordinate offsets are <span class="math inline">\((1,1), (1,-1), (-1,-1), (-1,1)\)</span>. We use subscripts <span class="math inline">\(0\)</span> to <span class="math inline">\(3\)</span> to represent these directions. If the current direction is <span class="math inline">\(d\)</span> and it is rotated counterclockwise by <span class="math inline">\(90^\circ\)</span>, then the new diagonal direction is <span class="math inline">\((d+1)\bmod 4\)</span>. Careful analysis shows that once the starting position and the initial diagonal direction of a V-shaped diagonal segment are determined, the maximum possible segment length depends on the longest valid continuation from the following position. At this point, dynamic programming can be applied to compute the maximum length of a V-shaped diagonal segment starting from each point.</p>
<p>For convenience, we use a top-down memoization search. Let <span class="math inline">\(\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target})\)</span> represent the maximum length of a V-shaped diagonal segment starting from position <span class="math inline">\((x,y)\)</span>, where the current diagonal direction is <span class="math inline">\(\textit{direction}\)</span>, the expected element value is <span class="math inline">\(\textit{target}\)</span>, and the current rotation state is <span class="math inline">\(\textit{turn}\)</span>. We maintain <span class="math inline">\(\textit{memo}\)</span> to record the maximum values of all substates, and initialize all states to <span class="math inline">\(-1\)</span> for ease of calculation. Since adjacent elements must follow the V-shaped sequence pattern, we also need to verify whether the current elementâ€™s value is valid given the previous one. This is an important detail in the search.</p>
<p>The calculation process of <span class="math inline">\(\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target})\)</span> is as follows:</p>
<ul>
<li>
<p>From the previous position <span class="math inline">\((x,y)\)</span>, the next position <span class="math inline">\((nx,ny)\)</span> is computed using the offset corresponding to <span class="math inline">\(\textit{direction}\)</span>. We then check whether <span class="math inline">\((nx,ny)\)</span> is within bounds and whether <span class="math inline">\(\textit{grid}[nx][ny]\)</span> equals <span class="math inline">\(\textit{target}\)</span>. If it goes out of bounds or does not match the target, the path is invalid and we return <span class="math inline">\(0\)</span>.</p>
</li>
<li>
<p>If the path continues without rotation, the next call is <span class="math inline">\(\text{dfs}(nx,ny,\textit{direction},\textit{turn},2-\textit{target})\)</span>. If the path rotates, the next call is <span class="math inline">\(\text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn},2-\textit{target})\)</span>. The maximum length starting from <span class="math inline">\((nx,ny)\)</span> is the maximum of these two cases, plus <span class="math inline">\(1\)</span>. Thus, the recurrence is:</p>
<p><span class="math display">\[\text{dfs}(x,y,\textit{direction},\textit{turn},\textit{target}) = \max\big(\text{dfs}(nx,ny,\textit{direction},\textit{turn},2-\textit{target}), \text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn},2-\textit{target})\big) + 1
\]</span></p>
</li>
</ul>
<p>Since the target value of each element can be derived directly from its position relative to the previous element, we do not need to store the target in the memoization state. This simplifies the recurrence to:</p>
<p><span class="math display">\[\text{dfs}(x,y,\textit{direction},\textit{turn}) = \max\big(\text{dfs}(nx,ny,\textit{direction},\textit{turn}), \text{dfs}(nx,ny,(\textit{direction}+1)\bmod 4,\textit{turn})\big) + 1
\]</span></p>
<p>Finally, since the starting element of any valid V-shaped diagonal segment must be <span class="math inline">\(1\)</span>, we iterate through the grid, launch DFS from every position where the element equals <span class="math inline">\(1\)</span>, and compute the maximum length among all V-shaped diagonal segments.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Q9einiX9/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m,n\)</span> be the number of rows and columns of the given matrix <span class="math inline">\(\textit{grid}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>There are <span class="math inline">\(O(m \cdot n)\)</span> substates in the memoization search, and each state takes <span class="math inline">\(O(1)\)</span> time to compute.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(mn)\)</span>.</p>
<p>Both the memoization table and the recursion stack require <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/lets-play0201/1" target="_blank" rel="noopener noreferrer">Let&#39;s Play!!!</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Let&#39;s play a game!! Given a matrix mat[][] with n&nbsp;x m&nbsp;elements. Your task is to check that matrix is Super Similar or not. To perform this task you have to follow these Rules: Firstly all even index rows to be Rotated left and odd index rows to right, And Rotation is done X times(Index starting from zero). Secondly, After all the Rotations check if the initial and the final Matrix are same Return 1 else 0.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> n = 2, m = 2
mat = {{1, 2}, 
&nbsp;      {5, 6}}
x = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Matrix after rotation:
mat = {{ 2, 1}
&nbsp;      { 6, 5}}
After one rotation mat is 
not same as the previous one.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> n = 2, m = 4
mat = {{1, 2, 1, 2}, 
&nbsp;      {2, 1, 2, 1}}
x = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> After two rotation mat is 
same as the previous one.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You do not need to read input or print anything. Your task is to complete the function <strong>isSuperSimilar()</strong> which takes n, m, x and the matrix as input parameter and returns 1&nbsp;if the initial and the final Matrix are same&nbsp;else returns 0.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(n*m)<br />
<strong>Expected Auxiliary Space:</strong> O(n*m)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n, m &le; 30<br />
1&nbsp;&le; mat[i][j] &le; 100&nbsp;<br />
1 &le; x&nbsp;&le; 20</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/c-letters-collection4552/1" target="_blank" rel="noopener noreferrer">Letters Collection</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">cpp</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">The Postmaster wants&nbsp;to write a program to answer the queries regarding letter collection in a city. A city is represented as a matrix <strong>mat</strong> of size<strong> n*m.</strong> Each cell represents a house and contains letters which are denoted by a number in the&nbsp;cell. The program should answer&nbsp;<strong>q </strong>queries which are of following types:<br /><strong>1 i j&nbsp;</strong>: To sum all the letters which are at a 1-hop distance from the cell (i,j) in any direction<br /><strong>2 i j :&nbsp;</strong>To sum all the letters which are at a 2-hop distance from the cell (i,j) in any direction&nbsp;<br />The queries are given in a 2D matrix&nbsp;<strong>queries[][]</strong>.<br />In one hop distance p</span><span style="font-size: 18px;">ostmaster</span><span style="font-size: 18px;"> can go to any of [</span><span style="font-size: 18px;">(i-1,j-1), (i-1,j), (i-1,j+1), </span><span style="font-size: 18px;">(i,j-1), (i,j+1), (i+1,j-1), (i+1,j), (i+1,j+1)] from (i,j).&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
n = 4, m = 5
mat = {{1, 2, 3, 4, 10}, 
&nbsp;      {5, 6, 7, 8, 10}, 
&nbsp;      {9, 1, 3, 4, 10}, 
&nbsp;      {1, 2, 3, 4, 10}}
q = 2
queries = {{1 0 1}, 
&nbsp;          {2 0 1}}
<strong>Output:</strong> <br />22 29
<strong>Explaination:</strong> 
For the first query sum is 1+5+6+7+3 = 22. 
For the second query sum is 9+1+3+4+8+4 = 29.<br /></span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
n = 6, m = 6
mat = {{ 1,  2,  3,  4,  5,  6}, 
&nbsp;      { 7,  8,  9, 10, 11, 12}, 
&nbsp;      {13, 14, 15, 16, 17, 18}, 
&nbsp;      {19, 20, 21, 22, 23, 24},<br />       {25, 26, 27, 28, 29, 30},<br />       {31, 32, 33, 34, 35, 36}}
q = 1
queries = {{2 3 2}}
<strong>Output:</strong> <br />336
<strong>Explaination:</strong> 
The first query sum is 7+8+9+10+11+17+23+29+35+34+33+32+31+25+19+13 = 336.</span> </pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You do not need to&nbsp;read input or print anything. Your task is to complete the function <strong>matrixSum()</strong> which takes <strong>n</strong>, <strong>m</strong>, <strong>mat</strong>, <strong>q </strong>and <strong>queries </strong>as input parameters and returns a list of integers where the ith value is the answers for ith query.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(q)<br /><strong>Expected Auxiliary Space:</strong> O(q)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 10<sup>3</sup><br />0&nbsp;</span><span style="font-size: 18px;">&le;</span><span style="font-size: 18px;"> mat[i][j]&nbsp;</span><span style="font-size: 18px;">&le; 10<sup>7</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">1 &le; q &le; 10<sup>5</sup><br />1 </span><span style="font-size: 18px;">&le; q[i][0] </span><span style="font-size: 18px;">&le; 2<br /></span><span style="font-size: 18px;">0 </span><span style="font-size: 18px;">&le; q[i][1] &lt; n</span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">0 </span><span style="font-size: 18px;">&le; q[i][2] &lt; m</span><span style="font-size: 18px;"><br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-path-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Longest Increasing Path in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>

<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/longest-possible-route-in-a-matrix-with-hurdles/1" target="_blank" rel="noopener noreferrer">Longest Possible Route in a Matrix with Hurdles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an N&nbsp;x M&nbsp;matrix, with a few hurdles(denoted by 0) arbitrarily placed, calculate the length of the longest possible route possible from source<strong>(xs,ys)</strong> to a destination<strong>(xd,yd)</strong> within the matrix. We are allowed to move to only adjacent cells which are not hurdles. The route cannot contain any diagonal moves and a location once visited in a particular path cannot be visited again.If it is impossible to reach the destination from the source return <strong>-1</strong>.</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">{xs,ys} = {0,0}</span>
<span style="font-size: 18px;">{xd,yd} = {1,7}</span>
<span style="font-size: 18px;">matrix = 1 1 1 1 1 1 1 1 1 1</span>
<span style="font-size: 18px;">         1 1 0 1 1 0 1 1 0 1</span>
<span style="font-size: 18px;">         1 1 1 1 1 1 1 1 1 1</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">24</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<strong><span style="font-size: 18px;"><img style="height: 175px; width: 500px;" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/matrix_highlight.png" alt="" /></span></strong></pre>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong>
<span style="font-size: 18px;">{xs,ys} = {0,3}</span>
<span style="font-size: 18px;">{xd,yd} = {2,2}</span>
<span style="font-size: 18px;">matrix =<strong><span style="font-size: 18px;"> </span></strong>1 0 0 1 0</span>
<span style="font-size: 18px;">         0 0 0 1 0</span>
<span style="font-size: 18px;">         0 1 1 0 0</span>
<strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">-1</span>
<strong><span style="font-size: 18px;">Explanation:</span></strong>
<span style="font-size: 18px;">We can see that it is impossible to</span>
<span style="font-size: 18px;">reach the cell (2,2) from (0,3).</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>longestPath()&nbsp;</strong>which takes matrix ,source and destination as&nbsp;input parameters and returns an integer denoting the longest path.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(2^(N*M))<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(N*M)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 10</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lucky-numbers-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Lucky Numbers in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix of <strong>distinct </strong>numbers, return <em>all <strong>lucky numbers</strong> in the matrix in <strong>any </strong>order</em>.</p>

<p>A <strong>lucky number</strong> is an element of the matrix such that it is the minimum element in its row and maximum in its column.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[3,7,8],[9,11,13],[15,16,17]]
<strong>Output:</strong> [15]
<strong>Explanation:</strong> 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
<strong>Output:</strong> [12]
<strong>Explanation:</strong> 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[7,8],[1,2]]
<strong>Output:</strong> [7]
<strong>Explanation:</strong> 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 50</code></li>
	<li><code>1 &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code>.</li>
	<li>All elements in the matrix are distinct.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-simulation">Approach 1: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a matrix of size <span class="math inline">\(M X N\)</span> with distinct integers. We need to return the list of lucky numbers in the matrix. An integer in the matrix is lucky if it is the maximum integer in its column and it is the minimum value in its row.</p>
<p>In this approach, we will simulate the process by iterating over each integer in the matrix, checking if it is the maximum in its row and the minimum in its column. If it meets both criteria, we will add it to the list of lucky numbers, <code>luckyNumbers</code>.</p>
<p>The naive approach to check the criteria for each integer involves iterating over each integer in the current row and column to verify the minimum and maximum criteria, requiring <span class="math inline">\(M + N\)</span> operations per integer. A more efficient method is to precompute the minimum of each row and the maximum of each column before processing the matrix. This allows us to check the criteria for each integer in constant time. We iterate over each row to store the minimum in <code>rowMin</code> and each column to store the maximum in <code>colMax</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Iterate over each row and store the minimum of the <code>ith</code> row at the <code>ith</code> position in the list <code>rowMin</code>.</li>
<li>Iterate over each column and store the maximum of the <code>ith</code> column at the <code>ith</code> position in the list <code>colMax</code>.</li>
<li>Iterate over each integer in the matrix and for each integer at <code>(i, j)</code>, check if the integer is equal to <code>rowMin[i]</code> and <code>colMax[j]</code>. If yes, add it to the list <code>luckyNumbers</code>.</li>
<li>Return <code>luckyNumbers</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/nrmzAWyP/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of rows in the matrix and <span class="math inline">\(M\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N * M)\)</span>.</p>
<p>To store the maximum of each row, we require <span class="math inline">\(N * M\)</span> operations and the same for strong the maximum of each column. In the end, to find the lucky numbers we again iterate over each integer. Hence, the total time complexity is equal to <span class="math inline">\(O(N * M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + M)\)</span>.</p>
<p>We require two lists, <code>rowMin</code> and <code>colMax</code> of size <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span> respectively. Hence the total space complexity is equal to <span class="math inline">\(O(N + M)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy">Approach 2: Greedy</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we didn't observe a key observation that there can be at most one lucky number in the matrix. Let's first try to prove that there cannot be more than one lucky number in the matrix by contradiction.</p>
<p>Suppose we have an integer <code>X</code> in the row <code>r1</code> and column <code>c1</code> as shown below, the integer <code>X</code> is the minimum in its row and maximum in its column and hence is a lucky number. Let's say there's another integer <code>Y</code> in the column <code>r2</code> and column <code>c2</code> let's assume that <code>Y</code> is also a lucky number. The below figure shows the expressions we have based on these assumptions that lead us to a contradictory expression.</p>
<p><img src="../Figures/1380/1380A.png" alt="fig" /></p>
<p>Hence, we can conclude that there can be at most one lucky number. If it exists, it can be found as follows: the lucky number is the minimum element in its row and the maximum element in its column. Therefore, we first find the minimum element of each row and then determine the maximum of these minimums as <code>rowMinMax</code>. Similarly, we find the maximum of each column and then determine the minimum of these maximums as <code>colMaxMin</code>. If <code>rowMinMax</code> equals <code>colMaxMin</code>, then this value is the lucky number; otherwise, we return an empty list.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Iterate over each row and find the minimum as <code>rMin</code>, then find the maximum of these minimum elements in each row as <code>rMinMax</code>.</li>
<li>Iterate over each column and find the maximum as <code>rMax</code>, then find the minimum of these maximum elements in each column as <code>cMaxMin</code>.</li>
<li>If the values <code>rMinMax</code> and <code>cMaxMin</code> are equal then return <code>rMinMax</code> or <code>cMaxMin</code>.</li>
<li>Otherwise, return an empty list.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/WvMuSd9Z/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of rows in the matrix and <span class="math inline">\(M\)</span> is the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N * M)\)</span>.</p>
<p>To find the value <code>rMinMax</code> and <code>cMaxMin</code> we are iterating over each integer in the matrix. Hence, the total time complexity is equal to <span class="math inline">\(O(N * M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>No extra space is required apart from the few variables. Hence the total space complexity is constant.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/magic-square/1" target="_blank" rel="noopener noreferrer">Magic Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;<strong>n*n&nbsp;</strong>matrix&nbsp;<strong>mat[][]&nbsp;</strong>,check whether the matrix is a&nbsp;<strong>magic square&nbsp;</strong>or not.</span></p>
<blockquote>
<p><span style="font-size: 14pt;">A Magic Square is a n x n matrix of distinct elements from 1 to n<sup>2</sup>&nbsp;where the sum of any row, column, or diagonal is always equal to the same number.</span></p>
</blockquote>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">mat = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]<br /><strong>Output: </strong>"Magic Square"<br /><strong>Explanation: </strong>R1-&gt;2+7+6=15, R2-&gt;9+5+1=15, R3-&gt;4+3+8=15<br />             C1-&gt;2+9+4=15, C2-&gt;7+5+3=15, C3-&gt;6+1+8=15<br />             D1-&gt;2+5+8=15, D2=6+5+4=15</span></pre>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><span style="font-size: 14pt;"> mat = [[1, 2], [3, 4]]<br /><strong>Output: </strong>"Not a Magic Square"<br /><strong>Explanation: </strong>Sum of all rows and columns are not same.</span></pre>
<pre><strong><span style="font-size: 14pt;">Input:</span></strong><span style="font-size: 14pt;"> mat = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]<br /><strong>Output: </strong>"Not a Magic Square"<br /><strong>Explanation: </strong>All sums are same but all elements from 1 to n<sup>2</sup> are not present.<br /></span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &nbsp;&lt;= &nbsp;mat.length &nbsp;&lt;= 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/magic-squares-in-grid/description" target="_blank" rel="noopener noreferrer">Magic Squares In Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <code>3 x 3</code> <strong>magic square</strong> is a <code>3 x 3</code> grid filled with distinct numbers <strong>from </strong>1<strong> to </strong>9 such that each row, column, and both diagonals all have the same sum.</p>

<p>Given a <code>row x col</code> <code>grid</code> of integers, how many <code>3 x 3</code> magic square subgrids are there?</p>

<p>Note: while a magic square can only contain numbers from 1 to 9, <code>grid</code> may contain numbers up to 15.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]
<strong>Output:</strong> 1
<strong>Explanation: </strong>
The following subgrid is a 3 x 3 magic square:
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg" style="width: 242px; height: 242px;" />
while this one is not:
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg" style="width: 242px; height: 242px;" />
In total, there is only one magic square inside the given grid.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[8]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>row == grid.length</code></li>
	<li><code>col == grid[i].length</code></li>
	<li><code>1 &lt;= row, col &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Let's start by clarifying some common points of confusion over this problem description. Note that:</p>
<ol>
<li>The given grid may contain integers above <code>9</code>, but a magic grid may only contain integers <code>1</code> to <code>9</code>.</li>
<li>The given grid may contain duplicate values, but every value in a magic grid must be distinct. In other words, no duplicate values are allowed.</li>
</ol>
<p>With the given <code>grid</code>, you want to find the number of subarrays in <code>grid</code> that are magic squares. A <code>3 x 3</code> magic square is defined as a <code>3 x 3</code> array containing distinct integers from <code>1</code> to <code>9</code> whose rows, columns, and diagonals all have the same sum.</p>
<hr />
<h3 id="approach-1-manual-scan">Approach 1: Manual Scan</h3>
<h3 id="intuition">Intuition</h3>
<p>One brute-force approach is to consider each <code>3 x 3</code> subarray of the <code>grid</code> and manually check if each subarray satisfies the definition of a <code>3 x 3</code> magic square.</p>
<p>We iterate through the entire grid, examining each possible <code>3 x 3</code> subarray. For each subarray, we'll check each element to make sure that it is within the allowed range and that it isn't a duplicate. Then, we verify that the sums of all three rows, three columns, and the two diagonals are equal. If all these conditions are met, then the subarray is a magic square.</p>
<h3 id="algorithm">Algorithm</h3>
<ol>
<li>Initialize <code>ans</code> to <code>0</code>, representing the total count of magic squares.</li>
<li>Define a helper function <code>isMagicSquare(grid, row, col)</code> that determines if the subarray of <code>grid</code> starting at index <code>(row, col)</code> is a magic square:
<ul>
<li>For each element <code>num</code> of the subarray:
<ul>
<li>If it falls outside the allowed range (<code>num &gt; 9</code> or <code>num &lt; 1</code>), return <code>false</code></li>
<li>If we have seen <code>num</code> in the previous iteration, that means the values aren't distinct, so return <code>false</code></li>
</ul>
</li>
<li>Initialize <code>diagonal1</code> and <code>diagonal2</code> as the sums for the 2 diagonals.</li>
<li>If <code>diagonal1 != diagonal2</code>, return <code>false</code></li>
<li>Initialize <code>row1</code>, <code>row2</code>, and <code>row3</code> as the sums for the 3 rows.</li>
<li>If any of the row sums don't equal <code>diagonal1</code>, then there are different sums for the rows and columns, so return <code>false</code></li>
<li>Initialize <code>col1</code>, <code>col2</code>, and <code>col3</code> as the sums for the 3 columns.</li>
<li>Similarly, if any of the column sums don't equal <code>diagonal1</code>, return <code>false</code></li>
</ul>
</li>
<li>For each index <code>(row, col)</code> of <code>grid</code>:
<ul>
<li>If <code>isSquareMagic(grid, row col)</code> is <code>true</code>, then increment <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p><a href="https://leetcode.com/playground/hMjeqDaZ/shared">code</a></p>
<h3 id="time-complexity">Time Complexity</h3>
<p>Let <code>M</code> and <code>N</code> be the number of rows and columns of <code>grid</code>, respectively.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The number of <code>3 x 3</code> subarrays to check for <code>grid</code> is linearly proportional to the size of <code>grid</code>, which is <span class="math inline">\(M \cdot N\)</span>. For each <code>3 x 3</code> subarray of <code>grid</code>, we iterate through all its values to check that they are distinct and within range, which takes constant time. We also perform the sum calculations that involve additional array indexing into a <code>grid</code>, which also takes constant time. Thus, the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p><code>isMagicSquare</code> uses an array to keep track of which values the current subarray of <code>grid</code> contains. However, this array has a constant size of <span class="math inline">\(10\)</span>, so the space complexity is <span class="math inline">\(O(1)\)</span></p>
</li>
</ul>
<h3 id="approach-2-check-unique-properties-of-magic-square">Approach 2: Check Unique Properties of Magic Square</h3>
<h3 id="intuition-1">Intuition</h3>
<p>In Approach 1, we determined whether each subarray of <code>grid</code> is a magic square by explicitly checking each criterion of the magic square definition given in the problem statement.</p>
<p>We can dive deeper into the definition of a <code>3 x 3</code> magic square to find additional properties that can help us simplify the logic for determining if a subarray is a magic square:</p>
<p><strong>Constant Sum</strong></p>
<p>By definition, every row has the same sum <span class="math inline">\(S\)</span>. Furthermore, the definition states that a magic grid <strong>can</strong> only contain values <code>1</code> to <code>9</code> and each value must be distinct. Since every <code>3 x 3</code> magic grid will contain exactly <code>9</code> squares, we can see that every magic grid <strong>will</strong> have exactly one of each allowed value. Thus, we can see that the total sum of an entire <code>3 x 3</code> magic square is <span class="math inline">\(1 + 2 + 3 + ... + 9 = 45\)</span>.</p>
<p>Because each magic square consists of <span class="math inline">\(3\)</span> rows, we can say that <span class="math inline">\(3S = 45\)</span> and thus <span class="math inline">\(S = 15\)</span>. This means that every row sum, and in turn every column sum and diagonal sum, equals <span class="math inline">\(15\)</span>.</p>
<p><strong>Limited Number of Arrangements</strong></p>
<p>If every row, column, and diagonal has to sum up to <span class="math inline">\(15\)</span> and can only contain distinct values from <span class="math inline">\(1\)</span> to <span class="math inline">\(9\)</span>, then there are only a limited number of arrangements to form a magic square. Listed below are all possible combinations of 3-part sums that add up to <span class="math inline">\(15\)</span>, where each value is between <span class="math inline">\(1\)</span> and <span class="math inline">\(9\)</span>:</p>
<p><span class="math inline">\(1 + 5 + 9\)</span></p>
<p><span class="math inline">\(1 + 6 + 8\)</span></p>
<p><span class="math inline">\(2 + 4 + 9\)</span></p>
<p><span class="math inline">\(2 + 5 + 8\)</span></p>
<p><span class="math inline">\(2 + 6 + 7\)</span></p>
<p><span class="math inline">\(3 + 4 + 8\)</span></p>
<p><span class="math inline">\(3 + 5 + 7\)</span></p>
<p><span class="math inline">\(4 + 5 + 6\)</span></p>
<p>We can see that there are 8 different ways, which map directly to the 8 3-part sums in the magic square (3 rows + 3 columns + 2 diagonals = 8 total sums). We can explore further constraints on arranging the possible magic squares.</p>
<p><strong>Constraint 1 - Middle element</strong></p>
<p>5 appears in exactly 4 of these sums. The only element that would appear in 4 sums is the middle element of the magic square. Specifically, the middle element appears in the sums for the middle row, the middle column, and both diagonals. Thus, we know that for a subarray to be a magic square, its middle element has to be 5.</p>
<p><img src="../Figures/840/5_as_middle_element.png" alt="Middle element 5 appearing in 4 sums" /></p>
<p><strong>Constraint 2 - Even numbers</strong></p>
<p>Moreover, the even numbers (2, 4, 6, and 8) each appear in exactly 3 of the sums. Only the corner elements of the grid can appear in exactly 3 sums. Specifically, they appear in the sum for one row, one column, and one diagonal. Thus, we know the corner elements have to be even numbers.</p>
<p><img src="../Figures/840/even_numbers.png" alt="Even numbers in the corners" /></p>
<p><strong>Constraint 3 - Odd numbers</strong></p>
<p>Finally, the only numbers remaining are the odd numbers (1, 3, 7, and 9). They each appear in exactly 2 of the sums. The remaining elements on the edges of the grid also appear in exactly 2 sums: the sums for one row and one column. Thus, we know the remaining edge elements have to be odd numbers.</p>
<p><img src="../Figures/840/odd_numbers.png" alt="Odd numbers in the remaining edges" /></p>
<p>Using these constraints, we can more easily generate all the possible arrangements for a <code>3 x 3</code> magic square:</p>
<p><img src="../Figures/840/all_possible_squares.png" alt="All possible magic squares" /></p>
<p>We observe that for all possible arrangements, the elements around the border (the even/odd numbers from constraints 2/3 above) all follow the ordered sequence</p>
<p><span class="math inline">\(2, 9, 4, 3, 8, 1, 6, 7\)</span></p>
<p>either moving clockwise or counter-clockwise around the border, starting at a corner element.</p>
<p>Thus, we know that a subarray is a magic square if and only if it satisfies the 2 following properties:</p>
<ol>
<li>The middle element is 5</li>
<li>The bordering elements follow the <span class="math inline">\(2, 9, 4, 3, 8, 1, 6, 7\)</span> sequence, starting at some corner element and going either clockwise or counter-clockwise.</li>
</ol>
<h3 id="algorithm-1">Algorithm</h3>
<ol>
<li>Initialize <code>ans</code> to <code>0</code>, representing the total count of magic squares.</li>
<li>Define a helper function <code>isMagicSquare(grid, row, col)</code> that determines if the subarray of <code>grid</code> starting at index <code>(row, col)</code> is a magic square:
<ul>
<li>Initialize the magic sequence <code>sequence</code> to <code>2943816729438167</code>.</li>
<li>Also initialize the reversed sequence <code>reversedSequence</code> to <code>7618349276183492</code> to account for the opposite direction.</li>
<li>Initialize a string <code>S</code>.</li>
<li>Starting from the first element <code>grid[row][col]</code>, append all bordering elements in clockwise order to <code>S</code>.</li>
<li>If <code>S</code> is contained in either <code>sequence</code> or <code>reversedSequence</code>, the first element is even, and the middle element is <span class="math inline">\(5\)</span>, then the subarray is a magic square so return <code>true</code></li>
<li>Otherwise, return <code>false</code></li>
</ul>
</li>
<li>For each index <code>(row, col)</code> of <code>grid</code>:
<ul>
<li>If <code>isMagicSquare(grid, row col)</code> is <code>true</code>, then increment <code>ans</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p><a href="https://leetcode.com/playground/Jk295rHG/shared">code</a></p>
<h3 id="time-complexity-1">Time Complexity</h3>
<p>Let <code>M</code> and <code>N</code> be the number of rows and columns of <code>grid</code>, respectively.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>Similar to Approach 1, the pattern checking in <code>isMagicSquare</code> is done in constant time. This function is called <span class="math inline">\(O(M \cdot N)\)</span> times, so the total time complexity is <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The only auxiliary data structure used is a string storing our bordering pattern, which is a constant size. Thus, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-a-square-with-the-same-color/description" target="_blank" rel="noopener noreferrer">Make a Square with the Same Color</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> of size <code>3 x 3</code> consisting only of characters <code>&#39;B&#39;</code> and <code>&#39;W&#39;</code>. Character <code>&#39;W&#39;</code> represents the white color<!-- notionvc: 06a49cc0-a296-4bd2-9bfe-c8818edeb53a -->, and character <code>&#39;B&#39;</code> represents the black color<!-- notionvc: 06a49cc0-a296-4bd2-9bfe-c8818edeb53a -->.</p>

<p>Your task is to change the color of <strong>at most one</strong> cell<!-- notionvc: c04cb478-8dd5-49b1-80bb-727c6b1e0232 --> so that the matrix has a <code>2 x 2</code> square where all cells are of the same color.<!-- notionvc: adf957e1-fa0f-40e5-9a2e-933b95e276a7 --></p>

<p>Return <code>true</code> if it is possible to create a <code>2 x 2</code> square of the same color, otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<style type="text/css">.grid-container {
  display: grid;
  grid-template-columns: 30px 30px 30px;
  padding: 10px;
}
.grid-item {
  background-color: black;
  border: 1px solid gray;
  height: 30px;
  font-size: 30px;
  text-align: center;
}
.grid-item-white {
  background-color: white;
}
</style>
<style class="darkreader darkreader--sync" media="screen" type="text/css">
</style>
<p><strong class="example">Example 1:</strong></p>

<div class="grid-container">
<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>It can be done by changing the color of the <code>grid[0][2]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="grid-container">
<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;],[&quot;W&quot;,&quot;B&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>It cannot be done by changing at most one cell.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="grid-container">
<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>

<div class="grid-item grid-item-white">&nbsp;</div>
</div>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;W&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>The <code>grid</code> already contains a <code>2 x 2</code> square of the same color.<!-- notionvc: 9a8b2d3d-1e73-457a-abe0-c16af51ad5c2 --></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == 3</code></li>
	<li><code>grid[i].length == 3</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;W&#39;</code> or <code>&#39;B&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/make-matrix-beautiful-1587115620/1" target="_blank" rel="noopener noreferrer">Make Matrix Beautiful</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="78" data-end="361"><span style="font-size: 14pt;">A <strong data-start="105" data-end="125">beautiful matrix</strong> is defined as a square matrix in which the <strong>sum </strong>of elements in every row and every column is equal. Given a square matrix <strong>mat[][]</strong>, your task is to determine the <strong data-start="288" data-end="320">minimum number of operations</strong> required to make the matrix beautiful.<br /></span><span style="font-size: 14pt;">In one operation, you are allowed to increment the value of <strong data-start="423" data-end="447">any single cell </strong>by<strong data-start="423" data-end="447"> 1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[1, 2], <br />                [3, 4]]
<strong>Output</strong>: 4
<strong>Explanation</strong>:<br />Increment value of cell(0, 0) by 3, <br />Increment value of cell(0, 1) by 1. <br />Matrix after the operations: [[4, 3], <br />                            [3, 4]]<br />Here, sum of each row and column is 7.<br />Hence total 4 operation are required.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[1, 2, 3],<br />                [4, 2, 3],<br />                [3, 2, 1]]
<strong>Output</strong>: 6
<strong>Explanation</strong>: <br />Increment value of cell(0, 0) by 1, <br />Increment value of cell(0, 1) by 2, <br />I</span><span style="font-size: 14pt;">ncrement value of cell(2, 1) by 1, <br />Increment value of cell(2, 2) by 2. <br />Matrix after the operations: [[2, 4, 3], <br />                            [4, 2, 3],<br />                            [3, 3, 3]] <br />Here, sum of each row and column is 9.<br />Hence total 6 operation are required.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 900<br />0 &le; mat[i][j] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/make-zeroes4042/1" target="_blank" rel="noopener noreferrer">Make Zeroes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix&nbsp;of&nbsp; size n x&nbsp;m. Your task is to make Zeroes, that means in whole matrix when you find a zero,&nbsp;convert its upper, lower, left, and right value to zero and make that element the sum of the upper, lower, left and right value. Do the following tasks according to the initial matrix.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>matrix = {{1, 2, 3, 4},
                 {5, 6, 0, 7}, 
&nbsp;                {8, 9, 4, 6},
                 {8, 4, 5, 2}}
<strong>Output:</strong>&nbsp;{{1, 2, 0, 4}, 
&nbsp;        {5, 0, 20, 0},
         {8, 9, 0, 6}, 
&nbsp;        {8, 4, 5, 2}}
<strong>Explanation:</strong>&nbsp;As matrix[1][2] = 0, we will
perform the operation here. Then matrix[1][2]
= matrix[0][2] + matrix[2][2] + matrix[1][1] 
+ matrix[1][3] and matrix[0][2] = matrix[2][2] 
= matrix[1][1] = matrix[1][3] = 0.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>matrix = {{1, 2}, 
&nbsp;                {3, 4}}
<strong>output: </strong>{{1, 2}, 
&nbsp;        {3, 4}}</span>
</pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>MakeZeros()</strong>&nbsp;which takes the matrix as input parameter and does the given task according to initial matrix. You don't need to return anything. The driver code prints the modified matrix itself in the output.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n * m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n * m)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 100<br />0 &le; matrix[i][j] &le; 100, where 0 &le; i &le; n and 0 &le; j &le; m</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/making-a-large-island/description" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary matrix <code>grid</code>. You are allowed to change <strong>at most one</strong> <code>0</code> to be <code>1</code>.</p>

<p>Return <em>the size of the largest <strong>island</strong> in</em> <code>grid</code> <em>after applying this operation</em>.</p>

<p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>s.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Change one 0 to 1 and connect two 1s, then we get an island with area = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,0]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>Change the 0 to 1 and make the island bigger, only one island with area = 4.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1],[1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Can&#39;t change any 0 to 1, only one island with area = 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-using-dfs">Approach 1: Using DFS</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a binary matrix where each cell is either <code>0</code> (representing water) or <code>1</code> (representing land) and the ability to flip at most one <code>0</code> to <code>1</code>. Our task is to find the largest island in the matrix, or in other words, the largest group of <code>1</code>s connected with each other either up, down, left, or right (4-directionally) after the flip operation.</p>
<p>At first, we might think of flipping each <code>0</code> to <code>1</code> and then calculating the size of the largest island in the modified matrix. However, this brute-force approach is inefficient, especially for larger grids, as it involves multiple recalculations for each flip, which would lead to Time Limit Exceeded (TLE) error.</p>
<p>Instead of recalculating island sizes for every flip, we can take advantage of the fact that flipping a single <code>0</code> only affects the islands adjacent to it. Specifically, flipping a <code>0</code> merges neighboring islands into one larger island. This insight allows us to efficiently compute the largest island after flipping by precomputing the sizes of all islands first.</p>
<p>Check out the diagram below, where we can see that we can merge two islands into one by flipping a zero in between.</p>
<p><img src="../Figures/827/make_large_island.png" alt="make_large_island" /></p>
<p>We start by traversing the grid and identifying all the islands using Depth-First Search (DFS). During this traversal, we give each island a unique identifier (like a color). At the same time, we also calculate and store the size of each island in a map, where the key is the islandâ€™s unique identifier and the value is its size. This precomputation allows us to avoid recalculating island sizes later.</p>
<blockquote>
<p>For a more comprehensive understanding of depth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">DFS Explore Card</a>.</p>
</blockquote>
<p>After labeling the islands and knowing their sizes, we then look at each <code>0</code> in the grid. Flipping a <code>0</code> to <code>1</code> might connect neighboring islands, creating a larger island. For each <code>0</code>, we examine the islands around it and collect their unique identifiers using a set (to avoid counting the same island more than once). We then sum up the sizes of these islands to calculate the size of the new island that would be formed if this <code>0</code> were flipped to <code>1</code>.</p>
<p>As we evaluate each potential flip, we compare the size of the island that would be formed with the largest island weâ€™ve seen so far. This ensures that we find the largest possible island we can form by flipping a single <code>0</code>. We will handle special edge cases (e.g., the grid is full with <code>1</code>s or <code>0</code>s) separately.</p>
<p>This strategy is efficient because the grid is only traversed twice:</p>
<ol>
<li>To label the islands and compute their sizes.</li>
<li>To evaluate the potential island size for each <code>0</code> flip.</li>
</ol>
<h4 id="algorithm">Algorithm</h4>
<h5 id="exploreisland-helper-function"><code>exploreIsland</code> helper function:</h5>
<ul>
<li>
<p>Define the <code>exploreIsland</code> function which recursively explores an island with the given id <code>islandId</code> starting from the given cell <code>(currentRow, currentColumn)</code>.</p>
</li>
<li>
<p>Check if the current cell is out of bounds, is not part of an island or is already visited (i.e., its value is not <code>1</code>):</p>
<ul>
<li>If so, return <code>0</code>, indicating no land is found at this cell.</li>
</ul>
</li>
<li>
<p>Mark the current cell with the given <code>islandId</code> to indicate it has been visited.</p>
</li>
<li>
<p>Recursively explore the four neighboring cells (up, down, left, right) and accumulate the area of the island:</p>
<ul>
<li>Call <code>exploreIsland</code> for the cell below <code>(currentRow + 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell above <code>(currentRow - 1, currentColumn)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the right <code>(currentRow, currentColumn + 1)</code>.</li>
<li>Call <code>exploreIsland</code> for the cell to the left <code>(currentRow, currentColumn - 1)</code>.</li>
</ul>
</li>
<li>
<p>Return the total area of the island (i.e., 1 + the sum of all reachable land cells from the current position).</p>
</li>
</ul>
<h5 id="largestisland-main-function"><code>largestIsland</code> main function:</h5>
<ul>
<li>
<p>Initialize <code>islandSizes</code> to store sizes of islands, and <code>islandId</code> starting at <code>2</code> (to mark islands).</p>
</li>
<li>
<p>Traverse through the grid to mark all islands and calculate their sizes:</p>
<ul>
<li>For each cell in the grid, if the cell contains a land (value <code>1</code>), call <code>exploreIsland()</code> to mark the island and calculate its size.</li>
<li>For each island, store the size in <code>islandSizes</code> using the <code>islandId</code> as the key and increment <code>islandId</code> for the next island.</li>
</ul>
</li>
<li>
<p>Check if there are no islands (empty grid), in which case return 1 (since flipping one <code>0</code> would form a new island).</p>
</li>
<li>
<p>If only one island exists in the entire grid, check if the size of that island is equal to the total grid size:</p>
<ul>
<li>If true, return the size of the island.</li>
<li>Otherwise, return the size of the island + 1 (as we can expand the island by flipping one <code>0</code>).</li>
</ul>
</li>
<li>
<p>Initialize <code>maxIslandSize</code> to 1, which will store the size of the largest island.</p>
</li>
<li>
<p>Traverse through the grid again to try converting each <code>0</code> to a <code>1</code> and calculate the resulting island size:</p>
<ul>
<li>For each <code>0</code>, check its neighboring cells (up, down, left, right) to find which islands are connected to it.</li>
<li>Use a unordered set to store unique neighboring island IDs.</li>
<li>Sum the sizes of all unique neighboring islands and add 1 (to account for the flipped <code>0</code> turning into a <code>1</code>).</li>
<li>Update <code>maxIslandSize</code> with the maximum island size found.</li>
</ul>
</li>
<li>
<p>Return <code>maxIslandSize</code>, the size of the largest island after trying to expand all possible <code>0</code>s.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fqsaoAuS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid to identify and mark islands using a Depth-First Search (DFS) approach. During this process, each cell is visited at most once, ensuring that the DFS traversal contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells, which is a constant-time operation. The use of an unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Thus, the overall time complexity is dominated by the grid traversal and DFS, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the recursion stack used during the DFS traversal and the storage required for the unordered map that keeps track of island sizes. In the worst case, the recursion depth of the DFS can be <span class="math inline">\(O(n \times m)\)</span> if the entire grid forms a single large island. The unordered map stores the sizes of all islands, and in the worst case, the number of islands can be proportional to the number of cells, contributing <span class="math inline">\(O(n \times m)\)</span> to the space complexity.</p>
<p>Furthermore, the unordered set used to store neighboring islands for each <code>0</code> cell has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factors are the recursion stack and the unordered map, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-disjoint-set-union-dsu">Approach 2: Using Disjoint Set Union (DSU)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Another way to solve this problem is by using a data structure called <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Disjoint Set Union (DSU)</a>, also known as Union-Find.</p>
<p>In DSU, the main goal is to keep track of groups (or sets) of elements where each set has a representative. The key operations in DSU are:</p>
<ol>
<li><strong>Find</strong>: This operation helps to find the representative (or &quot;leader&quot;) of the set to which an element belongs. If two elements are in the same set, they will have the same representative.</li>
<li><strong>Union</strong>: This operation merges two sets together. If two elements belong to different sets, they are combined into a single set, and the representative of one set becomes the representative of the merged set.</li>
</ol>
<p>The idea behind DSU is that we represent each island as a set, and then we merge islands when we encounter an adjacent land cell. This helps us keep track of which cells belong to which island and how big each island is.</p>
<p>First, we initialize a DSU structure where each land cell is its own representative (each cell is its own island), meaning that  <code>parent[node] = node</code> for every land cell node. We also initialize the <code>islandSize</code> array, where each island starts with a size of 1 (since each island is just one land cell initially). This is represented as <code>islandSize[node] = 1</code>.</p>
<p>As we traverse the grid, whenever we encounter a land cell (<code>1</code>), we check its adjacent cells (up, down, left, right). If an adjacent cell is also land, we union their corresponding sets. This means we merge the two islands (sets) into one larger island. The merging process ensures that the larger island becomes the representative of the merged set, keeping the data structure efficient.</p>
<p>During the merging step, we also update the size of the new island (set) by adding the size of the two merged islands. This is done by maintaining the <code>islandSize</code> array, where <code>islandSize[node]</code> is updated after each union operation.</p>
<p>After the initial union of all adjacent land cells, we then evaluate the potential effect of flipping a <code>0</code> (water) cell to <code>1</code> (land). When flipping a <code>0</code> to <code>1</code>, it will create a new island that merges with its adjacent islands (if any). To calculate the size of the new island formed by flipping a <code>0</code>, we simply look at the neighboring islands (sets) and calculate the size of the combined island. We do this by finding the representatives of the neighboring sets using find operations and summing their sizes.</p>
<p>As we evaluate each potential flip, we keep track of the largest island size encountered. If the grid is already filled with <code>1</code>s or <code>0</code>s, we handle these edge cases accordingly, but the main idea remains to maximize the island size formed by flipping a single <code>0</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<h5 id="define-the-disjointset-class">Define the <code>DisjointSet</code> class:</h5>
<ul>
<li>
<p>Initialize <code>parent</code> and <code>islandSize</code> arrays:</p>
<ul>
<li><code>parent</code> stores the parent of each node.</li>
<li><code>islandSize</code> stores the size of the connected island for each root.</li>
</ul>
</li>
<li>
<p>Initialize the <code>DisjointSet</code> constructor with <code>n</code> elements:</p>
<ul>
<li>For each node from <code>l</code> to <code>n-1</code>:
<ul>
<li>Set <code>parent[node] = node</code>, meaning each node is initially its own parent.</li>
<li>Set <code>islandSize[node] = 1</code>, indicating each island starts with size 1.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Implement <code>findRoot</code> function with path compression:</p>
<ul>
<li>If the current node is its own parent, return the node as the root.</li>
<li>Otherwise, recursively find the root of the parent and apply path compression by updating the parent of the node.</li>
</ul>
</li>
<li>
<p>Implement <code>unionNodes(nodeA, nodeB)</code> function to union two sets based on size:</p>
<ul>
<li>Find the roots of both <code>nodeA</code> and <code>nodeB</code> using the <code>findRoot</code> function.</li>
<li>If both nodes are already in the same set (i.e., have the same root), do nothing.</li>
<li>Otherwise, union the sets by size:
<ul>
<li>Attach the smaller island to the larger one:
<ul>
<li>If the island of <code>nodeA</code> is smaller, set <code>parent[rootA] = rootB</code> and update the size of <code>rootB</code>â€™s island.</li>
<li>If the island of <code>nodeB</code> is smaller, set <code>parent[rootB] = rootA</code> and update the size of <code>rootA</code>â€™s island.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="in-the-given-solution-class">In the given <code>Solution</code> class:</h5>
<ul>
<li>
<p>Initialize <code>rows</code> and <code>columns</code> to store the grid's dimensions.</p>
</li>
<li>
<p>Initialize a Disjoint Set Union (DSU) for the entire grid with <code>rows * columns</code> size.</p>
</li>
<li>
<p>Define direction arrays (<code>rowDirections</code>, <code>columnDirections</code>) for traversing up, down, left, and right.</p>
</li>
</ul>
<p>Step 1: Union adjacent <code>1</code>s in the grid:</p>
<ul>
<li>Iterate through each cell in the grid:
<ul>
<li>If the current cell contains <code>1</code>, calculate the flattened 1D index for the current cell, as <code>(columns * currentRow) + currentColumn</code>.</li>
<li>For each of the four possible directions (up, down, left, right), check if the neighbor is within bounds and also contains <code>1</code>.</li>
<li>If the neighbor is valid, flatten the 2D index and use the DSU to union the current cell and the neighbor.</li>
</ul>
</li>
</ul>
<p>Step 2: Calculate the maximum possible island size:</p>
<ul>
<li>Initialize <code>maxIslandSize</code> to store the largest island size and <code>hasZero</code> as a flag to check if there are any zeros in the grid.</li>
<li>Initialize a <code>uniqueRoots</code> set to store the unique roots of neighboring <code>1</code>s for each <code>0</code> in the grid.</li>
<li>Iterate through the grid to find all zeros (<code>0</code> cells):
<ul>
<li>For each <code>0</code>, initialize the <code>currentIslandSize</code> to <code>1</code> (since we are flipping the <code>0</code>).</li>
<li>For each direction (up, down, left, right), check if the neighboring cell contains <code>1</code> and if so, add the root of the neighboring island to <code>uniqueRoots</code>.</li>
<li>Sum the sizes of the unique neighboring islands using their roots.</li>
<li>Update <code>maxIslandSize</code> with the largest island size found.</li>
</ul>
</li>
</ul>
<p>Step 3: Return the result:</p>
<ul>
<li>If there are no zeros in the grid, return the size of the entire grid (i.e., <code>rows * columns</code>).</li>
<li>Otherwise, return <code>maxIslandSize</code>, the largest island size after flipping a zero.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/fFCPs4tS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the grid, <span class="math inline">\(m\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm consists of two main phases. In the first phase, we iterate over every cell in the grid and we use a Disjoint Set Union (DSU) data structure to union adjacent <code>1</code>s. For each cell, we check its four neighboring cells, which is a constant-time operation. The DSU operations, including <code>findRoot</code> and <code>unionNodes</code>, are nearly constant time due to path compression and union by size optimizations. Thus, the first phase contributes <span class="math inline">\(O(n \times m)\)</span> to the time complexity.</p>
<p>In the second phase, we iterate over every cell again to explore the possibility of converting each <code>0</code> to <code>1</code> and calculating the potential island size. For each <code>0</code>, we check its four neighboring cells and use the DSU to find the roots of neighboring islands. The unordered set ensures that neighboring islands are counted uniquely, and the total work done in this phase is also <span class="math inline">\(O(n \times m)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the grid traversal and DSU operations, resulting in <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The space complexity is primarily determined by the DSU data structure, which stores the parent and size of each cell. Both the <code>parent</code> and <code>islandSize</code> arrays require <span class="math inline">\(O(n \times m)\)</span> space. Additionally, the unordered set used to store unique roots for neighboring islands has a maximum size of 4, as there are only four possible neighboring cells. This does not significantly impact the overall space complexity.</p>
<p>Therefore, the dominant factor is the DSU data structure, resulting in an overall space complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/making-a-large-island/1" target="_blank" rel="noopener noreferrer">Making A Large Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">bfs</span> <span class="topic-badge">dfs</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an<strong> n x n </strong>binary matrix<strong> grid[][]</strong>. You are allowed to change at most one<strong> 0</strong> to <strong>1</strong>.&nbsp;</span><span style="font-size: 18.6667px;">A group of <strong>connected 1s</strong> forms an island. Two 1s are connected if they share one of their sides with each other.</span></p>
<p><span style="font-size: 14pt;">Return the size of the <strong>largest island</strong> in the grid after applying this operation.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,0],[0,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">3</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change any one 0 to 1 and connect two 1s, then we get an island with area = 3.</span></span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,0]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Change the only 0 to 1 and make the island bigger, then we get an island with area = 4.</span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">grid[] = [[1,1],[1,1]]</span><br /><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">4</span><br /><strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 18.6667px;">Can't change any 0 to 1, only one island possible with area = 4.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraints:</span></strong></p>
<p><span style="font-size: 18.6667px;">1 &lt;= n &lt;= 500<br />0 &lt;= grid[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/map-of-highest-peak/description" target="_blank" rel="noopener noreferrer">Map of Highest Peak</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer matrix <code>isWater</code> of size <code>m x n</code> that represents a map of <strong>land</strong> and <strong>water</strong> cells.</p>

<ul>
	<li>If <code>isWater[i][j] == 0</code>, cell <code>(i, j)</code> is a <strong>land</strong> cell.</li>
	<li>If <code>isWater[i][j] == 1</code>, cell <code>(i, j)</code> is a <strong>water</strong> cell.</li>
</ul>

<p>You must assign each cell a height in a way that follows these rules:</p>

<ul>
	<li>The height of each cell must be non-negative.</li>
	<li>If the cell is a <strong>water</strong> cell, its height must be <code>0</code>.</li>
	<li>Any two adjacent cells must have an absolute height difference of <strong>at most</strong> <code>1</code>. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</li>
</ul>

<p>Find an assignment of heights such that the maximum height in the matrix is <strong>maximized</strong>.</p>

<p>Return <em>an integer matrix </em><code>height</code><em> of size </em><code>m x n</code><em> where </em><code>height[i][j]</code><em> is cell </em><code>(i, j)</code><em>&#39;s height. If there are multiple solutions, return <strong>any</strong> of them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png" style="width: 220px; height: 219px;" /></strong></p>

<pre>
<strong>Input:</strong> isWater = [[0,1],[0,0]]
<strong>Output:</strong> [[1,0],[2,1]]
<strong>Explanation:</strong> The image shows the assigned heights of each cell.
The blue cell is the water cell, and the green cells are the land cells.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png" style="width: 300px; height: 296px;" /></strong></p>

<pre>
<strong>Input:</strong> isWater = [[0,0,1],[1,0,0],[0,0,0]]
<strong>Output:</strong> [[1,1,0],[0,1,1],[1,2,2]]
<strong>Explanation:</strong> A height of 2 is the maximum possible height of any assignment.
Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == isWater.length</code></li>
	<li><code>n == isWater[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>isWater[i][j]</code> is <code>0</code> or <code>1</code>.</li>
	<li>There is at least <strong>one</strong> water cell.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as 542: <a href="https://leetcode.com/problems/01-matrix/description/" target="_blank">https://leetcode.com/problems/01-matrix/</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D matrix <code>isWater</code> of dimensions <code>m x n</code>, which represents a map consisting of land and water cells. Specifically:</p>
<ul>
<li>If <code>isWater[i][j] = 0</code>, the cell <code>(i, j)</code> represents land.</li>
<li>If <code>isWater[i][j] = 1</code>, the cell <code>(i, j)</code> represents water.</li>
</ul>
<p>The goal is to assign a height to each cell such that the highest peak on the map (i.e., the greatest height of any cell) is as high as possible. This assignment must follow these rules:</p>
<ol>
<li>The height of each cell must be non-negative.</li>
<li>The height of all water cells is fixed at 0. These cells have fixed heights and cannot be changed.</li>
<li>The height difference between two adjacent cells (cells that share a side) must not be greater than one. For example, if the height of cell <code>(2, 3)</code> is <code>4</code>, then the heights of its adjacent cellsâ€”<code>(1, 3)</code>, <code>(3, 3)</code>, <code>(2, 4)</code>, and <code>(2, 2)</code>â€”must be either <code>3</code>, <code>4</code> or <code>5</code>.</li>
</ol>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>Letâ€™s first break the problem down into a simpler, one-dimensional version.</p>
<p>Imagine a row of cells with only one water cell. Intuitively, as we move away from the water cell, the heights of the land cells should gradually increase. The height of each land cell can naturally be determined by its distance from the water cell.</p>
<p><img src="../Figures/1765/1765_approach1a.png" alt="One-dimensional version of the problem with a single water cell" /></p>
<p>Now, letâ€™s add a second water cell to the row. The idea stays the same, but now each land cellâ€™s height is determined by its smallest distance to any water cell. This ensures a smooth increase in height as we move away from both water cells.</p>
<p><img src="../Figures/1765/1765_approach1b.png" alt="One-dimensional version of the problem with two water cells" /></p>
<p>When we extend this logic to two dimensions, the concept is identical. For every cell in the grid, we calculate its smallest distance to any water cell and assign that value as its height.</p>
<ul>
<li>Heights increase smoothly from water cells, ensuring the highest peak is at the farthest distance from all water cells.<br />
This can be visualized as a &quot;ripple effect&quot; where water cells propagate their distances outward, assigning heights to nearby land cells.</li>
</ul>
<p><img src="../Figures/1765/1765_approach1c.png" alt="Two-dimensional version" /></p>
<p>This approach works intuitively for two reasons:</p>
<ul>
<li>It follows the rule that the height difference between two adjacent cells is at most one. This is because the minimum distance to water for any two neighboring cells cannot differ by more than one.</li>
<li>Itâ€™s optimal because it ensures that the height of the cells increases consistently as we move farther from water cells, maximizing the highest peak on the map.</li>
</ul>
<p>To find the shortest distance from any cell to a water cell, we use Breadth-First Search (BFS) starting from all water cells. When a land cell is reached for the first time, its shortest distance to a water cell is set.</p>
<blockquote>
<p>For a more comprehensive understanding of breadth-first search, check out the <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS Explore Card ðŸ”—</a>. This resource provides an in-depth look at BFS, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define two arrays of size <code>4</code>: <code>dx = [0, 0, 1, -1]</code> and <code>dy = [1, -1, 0, 0]</code>. Each pair <code>(dx[d], dy[d])</code> represents one of the four possible directions to an adjacent cell.</li>
<li>Initialize a 2D matrix, named <code>cellHeights</code>, of the same dimension as <code>isWater</code>. Set all of its cells to an invalid value, i.e. <code>-1</code>.</li>
<li>Initialize an empty queue of pairs, <code>cellQueue</code>.</li>
<li>Iterate over the <code>isWater</code> matrix:
<ul>
<li>Push every water cell into the <code>cellQueue</code>.</li>
<li>Set the height of each water cell to be <code>0</code>.</li>
</ul>
</li>
<li>Initialize <code>heightOfNextLayer</code> to <code>1</code> - that is the height of the neighbors of the cells currently in queue.</li>
<li>While the <code>cellQueue</code> is not empty:
<ul>
<li>Set <code>layerSize</code> to the size of the queue.</li>
<li>For each cell in the current layer, i.e. for <code>i</code> from <code>0</code> to <code>layerSize - 1</code>:
<ul>
<li>Pop the top cell <code>currentCell</code> out of the queue.</li>
<li>For each direction, i.e. for <code>d</code> from <code>0</code> to <code>3</code>:
<ul>
<li>Find the neighbor of the current cell to that direction, <code>neighborCell = (currentCell.x + dx[d], currentCell.y + dy[d])</code>.</li>
<li>If <code>neighbor</code> is a valid cell (i.e. it is not out of the bounds of the matrix) and it is not already visited (i.e. <code>cellHeights[neighbor.x][neighbor.y] == -1</code>):
<ul>
<li>Set <code>cellHeights[neighbor.x][neighbor.y]</code> to <code>heightOfNextLayer</code>.</li>
<li>Push <code>neighbor</code> into the <code>cellQueue</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>heightOfNextLayer</code> by <code>1</code>.</li>
</ul>
</li>
<li>Return <code>cellHeights</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/AbkNMEXz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>isWater</code> matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We perform a single multi-source BFS traversal over the cells of the matrix. The time complexity of BFS is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> is the number of vertices (cells in the grid, <span class="math inline">\(m \times n\)</span>) and <span class="math inline">\(E\)</span> is the number of edges (connections between neighboring cells).</p>
<p>In a grid, each cell has at most 4 neighbors, resulting in at most <span class="math inline">\(4 \cdot m \times n\)</span> edges. Since <span class="math inline">\(E\)</span> is proportional to <span class="math inline">\(V\)</span> in a grid, the total time complexity simplifies to <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We use a 2D matrix <code>cellHeights</code> of size <span class="math inline">\(m \times n\)</span> to store the calculated heights. Additionally, the BFS queue can hold up to <span class="math inline">\(m \times n\)</span> cells in the worst case. Therefore, the overall space complexity is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we build on the idea that the height of each cell should be the smallest distance to any water cell. From there, we observe that once we know the smallest distances of a cellâ€™s neighboring cells, calculating the distance for the current cell becomes straightforward â€” itâ€™s just the smallest of the neighborsâ€™ distances plus one. The core idea is to use dynamic programming to compute these distances efficiently.</p>
<p>Dynamic programming works well here because:</p>
<ol>
<li>Each cell's height can be derived from the heights of its neighboring cells.</li>
<li>By iterating over the grid in a specific order, we can ensure that all necessary states are computed before being used.</li>
</ol>
<p>However, the challenge is figuring out the correct order to compute these states. In DP terms, we need to ensure all necessary states are computed before using them.</p>
<p>Letâ€™s simplify by imagining we can only move down or right. In that case, the top-left corner has no choices â€” itâ€™s either a water cell or not reachable. Similarly, for the first row and column, we only have options from neighboring cells directly below or to the right.</p>
<p>Using this, we can fill the DP table row by row and column by column, in common order.</p>
<p>Finally, we perform a second pass, moving upward or left, to correct any distances that were overestimated during the first pass, which only considered partial directions (top and left).</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>rows</code> to the number of rows and <code>columns</code> to the number of columns of the <code>isWater</code> matrix.</li>
<li>Initialize a 2D matrix, named <code>cellHeights</code>, of the same dimension as <code>isWater</code>. Set all of its cells to a large value, i.e. <code>INF</code>.</li>
<li>Iterate over the <code>cellHeights</code> matrix and set the height of all water cells to <code>0</code>.</li>
<li>Loop with <code>row</code> from <code>0</code> to <code>rows - 1</code>:
<ul>
<li>Loop with <code>col</code> from <code>0</code> to <code>columns - 1</code>:
<ul>
<li>Initialize <code>minNeighborDistance</code> to <code>INF</code>.</li>
<li>Find the neighbor above the current cell, i.e. <code>neighborRow = row - 1, neighborCol = col</code>.</li>
<li>If the neighbor is valid, i.e. if it is not out of the bounds of the grid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Find the neighbor to the left of the current cell, i.e. <code>neighborRow = row, neighborCol = col - 1</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Set the height of the current cell to the minimum of its current value <code>minNeighborDistance + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Perform the second pass over <code>cellHeights</code> moving in the opposite directions:</li>
<li>Loop with <code>row</code> from <code>rows - 1</code> to <code>0</code>:
<ul>
<li>Loop with <code>col</code> from <code>columns - 1</code> to <code>0</code>:
<ul>
<li>Initialize <code>minNeighborDistance</code> to <code>INF</code>.</li>
<li>Find the neighbor below the current cell, i.e. <code>neighborRow = row + 1, neighborCol = col</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Find the neighbor to the right of the current cell, i.e. <code>neighborRow = row, neighborCol = col + 1</code>.</li>
<li>If the neighbor is valid:
<ul>
<li>Set <code>minNeighborDistance</code> to the minimum of itself and <code>cellHeights[neighborRow][neighborCol]</code>.</li>
</ul>
</li>
<li>Set the height of the current cell to the minimum of its current value <code>minNeighborDistance + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>cellHeights</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/oYC2r7oo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>isWater</code> matrix.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We iterate over the cells of the matrix 3 times and perform constant-time operations, including comparisons and assignments, on each iteration. Therefore, the time complexity of the algorithm is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \times n)\)</span><br />
We use a 2D matrix <code>cellHeights</code> of size <span class="math inline">\(m \times n\)</span> to store the calculated heights resulting in a space complexity of <span class="math inline">\(O(m \times n)\)</span>. Unlike the previous approach that used a queue as an additional data structure, this method only relies on the input grid and the resulting matrix, keeping the space complexity factor lower.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matrix-block-sum/description" target="_blank" rel="noopener noreferrer">Matrix Block Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>k</code>, return <em>a matrix</em> <code>answer</code> <em>where each</em> <code>answer[i][j]</code> <em>is the sum of all elements</em> <code>mat[r][c]</code> <em>for</em>:</p>

<ul>
	<li><code>i - k &lt;= r &lt;= i + k,</code></li>
	<li><code>j - k &lt;= c &lt;= j + k</code>, and</li>
	<li><code>(r, c)</code> is a valid position in the matrix.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
<strong>Output:</strong> [[12,21,16],[27,45,33],[24,39,28]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
<strong>Output:</strong> [[45,45,45],[45,45,45],[45,45,45]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;mat.length</code></li>
	<li><code>n ==&nbsp;mat[i].length</code></li>
	<li><code>1 &lt;= m, n, k &lt;= 100</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/boundary-traversal-of-matrix-1587115620/1" target="_blank" rel="noopener noreferrer">Matrix Boundary Traversal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a matrix <strong>mat[][] </strong>. Return the boundary traversal on the matrix in a clockwise manner starting from the first row of the matrix. </span><br /><br /><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],[13, 14, 15,16]]
<strong>Output</strong>: [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5]
<strong>Explanation</strong>: The boundary traversal is: [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5]
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>:mat[][] = [[12, 11, 10, 9],[8, 7, 6, 5],[4, 3, 2, 1]]
<strong>Output</strong>: [12, 11, 10, 9, 5, 1, 2, 3, 4, 8]<br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">: The boundary traversal is: </span>[12, 11, 10, 9, 5, 1, 2, 3, 4, 8]</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>:mat[][] = [[12, 11],[4, 3]] <br /></span><strong style="font-size: 14pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Output</strong><span style="font-size: 14pt; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">: [12, 11, 3, 4]<br /></span><span style="font-size: 14pt;"><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">: The boundary traversal is: </span>[12, 11, 3, 4]<br /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size()&le; 1000<br /></span><span style="font-size: 18px;">1 &le; mat[0].size() &le; 1000<br />0 &le; mat[i][j] &le; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matrix-cells-in-distance-order/description" target="_blank" rel="noopener noreferrer">Matrix Cells in Distance Order</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">geometry</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given four integers <code>row</code>, <code>cols</code>, <code>rCenter</code>, and <code>cCenter</code>. There is a <code>rows x cols</code> matrix and you are on the cell with the coordinates <code>(rCenter, cCenter)</code>.</p>

<p>Return <em>the coordinates of all cells in the matrix, sorted by their <strong>distance</strong> from </em><code>(rCenter, cCenter)</code><em> from the smallest distance to the largest distance</em>. You may return the answer in <strong>any order</strong> that satisfies this condition.</p>

<p>The <strong>distance</strong> between two cells <code>(r<sub>1</sub>, c<sub>1</sub>)</code> and <code>(r<sub>2</sub>, c<sub>2</sub>)</code> is <code>|r<sub>1</sub> - r<sub>2</sub>| + |c<sub>1</sub> - c<sub>2</sub>|</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> rows = 1, cols = 2, rCenter = 0, cCenter = 0
<strong>Output:</strong> [[0,0],[0,1]]
<strong>Explanation:</strong> The distances from (0, 0) to other cells are: [0,1]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> rows = 2, cols = 2, rCenter = 0, cCenter = 1
<strong>Output:</strong> [[0,1],[0,0],[1,1],[1,0]]
<strong>Explanation:</strong> The distances from (0, 1) to other cells are: [0,1,1,2]
The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> rows = 2, cols = 3, rCenter = 1, cCenter = 2
<strong>Output:</strong> [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
<strong>Explanation:</strong> The distances from (1, 2) to other cells are: [0,1,1,2,2,3]
There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows, cols &lt;= 100</code></li>
	<li><code>0 &lt;= rCenter &lt; rows</code></li>
	<li><code>0 &lt;= cCenter &lt; cols</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/matrix-chain-multiplication0303/1" target="_blank" rel="noopener noreferrer">Matrix Chain Multiplication</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an&nbsp;</span><span style="font-size: 18px;">array&nbsp;</span><strong style="font-size: 18px;">arr[] </strong><span style="font-size: 18px;">which represents</span><strong style="font-size: 18px;"> the&nbsp;</strong><span style="font-size: 18px;">dimensions of</span><span style="font-size: 18px;"> a sequence of matrices&nbsp;</span><span style="font-size: 18px;">where the&nbsp;</span><strong style="font-size: 18px;">i<sup>th</sup></strong><span style="font-size: 18px;">&nbsp;matrix has the dimensions&nbsp;</span><strong style="font-size: 18px;">(arr[i-1] x arr[i])</strong><span style="font-size: 18px;"> for i&gt;=1</span><span style="font-size: 18px;">, find the most efficient way to multiply these matrices together. The efficient way is the one that involves the least number of multiplications.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 1, 3, 4]
<strong>Output:</strong> 20
<strong>Explanation:</strong> There are 3 matrices of dimensions 2 &times; 1, 1 &times; 3, and 3 &times; 4, Let this 3 input matrices be M1, M2, and M3. There are two ways to multiply: ((M1 x M2) x M3) and (M1 x (M2 x M3)), note that the result of (M1 x M2) is a 2 x 3 matrix and result of (M2 x M3) is a 1 x 4 matrix. <br /></span><span style="font-size: 18px;">((M1 x M2) x M3)  requires (2 x 1 x 3) + (2 x 3 x 4) = 30 
(M1 x (M2 x M3))  requires (1 x 3 x 4) + (2 x 1 x 4) = 20. <br /></span><span style="font-size: 18px;">The minimum of these two is 20.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [1, 2, 3, 4, 3]
<strong>Output:</strong> 30
<strong>Explanation:</strong> There are 4 matrices of dimensions 1 &times; 2, 2 &times; 3, 3 &times; 4, 4 &times; 3. Let this 4 input matrices be M1, M2, M3 and M4. The minimum number of multiplications are obtained by ((M1 x M2) x M3) x M4). The minimum number is (1 x 2 x 3) + (1 x 3 x 4) + (1 x 4 x 3) = 30.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> arr[] = [3, 4]
<strong>Output:</strong> 0<br /><strong>Explanation:</strong> As there is only one matrix so, there is no cost of multiplication.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong>&nbsp;<br />2 &le; arr.size() &le; 100<br />1 &le; arr[i] &le; 200</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matrix-diagonal-sum/description" target="_blank" rel="noopener noreferrer">Matrix Diagonal Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a&nbsp;square&nbsp;matrix&nbsp;<code>mat</code>, return the sum of the matrix diagonals.</p>

<p>Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png" style="width: 336px; height: 174px;" />
<pre>
<strong>Input:</strong> mat = [[<strong>1</strong>,2,<strong>3</strong>],
&nbsp;             [4,<strong>5</strong>,6],
&nbsp;             [<strong>7</strong>,8,<strong>9</strong>]]
<strong>Output:</strong> 25
<strong>Explanation: </strong>Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[<strong>1</strong>,1,1,<strong>1</strong>],
&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],
&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],
&nbsp;             [<strong>1</strong>,1,1,<strong>1</strong>]]
<strong>Output:</strong> 8
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[<strong>5</strong>]]
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == mat.length == mat[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a square matrix <code>mat</code>. Our task is to return the sum of the elements on the primary and secondary diagonals without counting any element twice (if it occurs on both the diagonals).</p>
<hr />
<h3 id="approach-iterating-over-diagonal-elements">Approach: Iterating over Diagonal Elements</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that elements along the primary diagonals have the same row and column number. So, all elements of the form <code>mat[i][i]</code> with <code>i</code> ranging from <code>i = 0</code> to <code>i = n - 1</code>, where <code>n</code> is the number of rows (or columns) in <code>mat</code>, form the primary diagonal.</p>
<p>Let's form the secondary diagnal starting with the last row and first column, i.e., <code>mat[n - 1][0]</code>. <code>mat[n - 2][1]</code> is the next element over the secondary diagonal, one row up and one column ahead. The following element, <code>mat[n - 3][2]</code>, is again one row up and one column ahead of the previous element. The final element is <code>mat[0][n - 1]</code>. We can notice that the sum of the row and column numbers is constant (<code>n - 1</code>) because the column increases by one but the row decreases by one. As a result, all elements of the form <code>mat[n - 1 - i][i]</code> with <code>i</code> ranging from <code>i = 0</code> to <code>i = n - 1</code> constitute the secondary diagonal.</p>
<p>When we compare a square matrix with an odd number of rows to a square matrix with an even number of rows, we notice that there is a common element <code>mat[n / 2][n / 2]</code> at the intersection of the primary and secondary diagonals in the case of the matrix with odd rows:</p>
<p><img src="../Figures/1572/1572-1.png" alt="img" /></p>
<p>We add the elements on the primary and secondary diagonals and deduct the common element if number of rows in <code>mat</code> is odd.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer <code>n</code> that stores the number of rows (or columns) in <code>mat</code>.</li>
<li>Create an answer variable <code>ans</code> which will store the sum of elements on the primary and secondary diagonals. Initialize it to <code>0</code>.</li>
<li>Iterate from <code>i = 0</code> to <code>i = n - 1</code>:
<ul>
<li>Add elements on the primary diagonal to <code>ans</code>. We perform <code>ans += mat[i][i]</code>.</li>
<li>Add elements on the secondary diagonal to <code>ans</code>. We perform <code>ans += mat[n - 1 - i][i]</code>.</li>
</ul>
</li>
<li>If the number of rows in <code>mat</code> is odd, we have a common element between the primary and secondary diagonals. We decrement it from <code>ans</code>. We perform <code>ans -= mat[n / 2][n / 2]</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fxtTzMuX/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of rows (or columns) in <code>mat</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>We iterate over primary and secondary diagonals which requires <span class="math inline">\(O(n)\)</span> time each.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>Except using fews like integer <code>n</code> and <code>ans</code>, which take constant space, we do not consume any other space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/matrix-exponentiation2711/1" target="_blank" rel="noopener noreferrer">Matrix Exponentiation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">modulararithmetic</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an equation of the form f(n) = f(n-1) + f(n-2) where f(0) = 1, f(1) = 1&nbsp;, the task is to find the n<sup>th</sup>&nbsp;term of this sequence.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 3
<strong>Output: </strong>3
<strong>Explanation: </strong>f(3) = f(2) + f(1) = 3
</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2
<strong>Output: </strong>2
<strong>Explanation: </strong>f(2) = f(1) + f(0) = 2</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Yout Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>FindNthTerm()&nbsp;</strong>which takes n as input parameter and returns n<sup>th</sup>&nbsp;term mod 10^9+7&nbsp;.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(log(n))<br /><strong>Expected Space Complexity:&nbsp;</strong>O(K) where K is constant.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/matrix-game-10229/1" target="_blank" rel="noopener noreferrer">Matrix Game - 1</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given <strong>N</strong> and&nbsp;a <strong>N*N matrix</strong> containing 0&rsquo;s and 1&rsquo;s. Group all the row numbers (starting index 0) which are having 1&rsquo;s at same position.</span></p>

<p><strong>Example 1:</strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=4
matrix= [0010</span>
            <span style="font-size:18px">0100</span>
            <span style="font-size:18px">0010</span>
            <span style="font-size:18px">0000]
<strong>Output:</strong>
0 1</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">In the above test case, 1st and 3rd row have
the 1&#39;s at same column,i.e., 2(starting index 
from 0) so group first and third row. And print 
the index of first row, i.e., 0 (starting index 
from 0).</span>
<span style="font-size:18px">For second row, as it is the only row with same 
indexing of 1&#39;s so print it&#39;s index , i.e., 1.</span>
<span style="font-size:18px">For forth row, 1 is not present in this row so 
didn&#39;t print anything.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=1
matrix = [0]
<strong>Output:</strong>
-1
<strong>Explanation:</strong>
There is no row containing 1.</span></pre>

<p>&nbsp;</p>

<div><strong><span style="font-size:18px">Your task:</span></strong></div>

<div><span style="font-size:18px">You don&#39;t need to read input or print anything. Your task is to complete the function</span><strong><span style="font-size:18px"> groupRows(), </span></strong><span style="font-size:18px">which takes &nbsp;the <strong>matrix</strong>&nbsp;and an integer <strong>N</strong> as input parameters and returns a list of row numbers after grouping. If there is no row containing 1, return&nbsp;<strong>-1</strong>.</span></div>

<div>&nbsp;</div>

<div><span style="font-size:18px"><strong>Expected Time Complexity: </strong>O(n*n)</span></div>

<div><span style="font-size:18px"><strong>Expected Auxiliary Space: </strong>O(n*n)</span></div>

<div>&nbsp;</div>

<div><strong><span style="font-size:18px">Constraints:</span></strong></div>

<div><span style="font-size:18px">1&lt;=N&lt;=20</span></div>

<div>&nbsp;</div>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/matrix-operations/1" target="_blank" rel="noopener noreferrer">Matrix Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a binary matrix&nbsp;of dimensions <strong>M&nbsp;* N.&nbsp;</strong>One can perform the given operation in&nbsp;the matrix.</span></p>

<ul>
	<li><span style="font-size:18px">If the value of&nbsp;<strong>matrix[i][j]</strong>&nbsp;is&nbsp;<strong>0</strong>, then traverse in the same direction and check the next value.</span></li>
	<li><span style="font-size:18px">If the value of&nbsp;<strong>matrix[i][j]</strong>&nbsp;is&nbsp;<strong>1</strong>, then update&nbsp;<strong>matrix[i][j]</strong>&nbsp;to&nbsp;<strong>0</strong>&nbsp;and change the current direction from&nbsp;<strong>up</strong>,&nbsp;<strong>right</strong>,&nbsp;<strong>down</strong>, or&nbsp;<strong>left</strong>&nbsp;to the directions&nbsp;<strong>right</strong>,&nbsp;<strong>down</strong>,&nbsp;<strong>left</strong>, and&nbsp;<strong>up</strong>&nbsp;respectively.</span></li>
</ul>

<p><span style="font-size:18px">Initially you start from <strong>cell(0, 0)</strong>, moving in <strong>right</strong> direction.</span></p>

<p><span style="font-size:18px">The task is to find the first cell&nbsp;of the matrix </span>&nbsp;<span style="font-size:18px">which&nbsp;</span><span style="font-size:18px">leads to outside the matrix from</span><span style="font-size:18px">&nbsp;the traversal of the given matrix&nbsp;from the cell&nbsp;<strong>(0, 0)</strong> by performing the operations.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
matrix[][] = {{0,1},
              {1,0}}</span>

<span style="font-size:18px"><strong>Output:</strong> (1,1)
<strong>Explanation:</strong>
<img alt="" src="https://media.geeksforgeeks.org/img-practice/endpoint1-1622886995.jpg" style="height:178px; width:300px" />
<img alt="" src="https://media.geeksforgeeks.org/img-practice/endpoint2-1622887085.jpg" style="height:178px; width:500px" />
<img alt="" src="https://media.geeksforgeeks.org/img-practice/endpoint3-1622887174.jpg" style="height:250px; width:500px" /></span>

</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
matrix[][] = {{0, 1, 1, 1, 0},</span>
                   <span style="font-size:18px">{1, 0, 1, 0, 1},
              {1, 1, 1, 0, 0}}</span>

<span style="font-size:18px"><strong>Output:</strong> (2,0)</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>endPoints()</strong>&nbsp;that take the matrix as input parameter and output the last cell before the pointer gets outside of the matrix.</span></p>

<p><span style="font-size:18px"><strong>Constrains:</strong><br />
1&lt;= M, N&nbsp;&lt;=1000<br />
0&lt;= matrix[i][j] &lt;=1</span></p>

<p>&nbsp;</p>

<p>&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/matrix-similarity-after-cyclic-shifts/description" target="_blank" rel="noopener noreferrer">Matrix Similarity After Cyclic Shifts</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>mat</code> and an integer <code>k</code>. The matrix rows are 0-indexed.</p>

<p>The following proccess happens <code>k</code> times:</p>

<ul>
	<li><strong>Even-indexed</strong> rows (0, 2, 4, ...) are cyclically shifted to the left.</li>
</ul>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/lshift.jpg" style="width: 283px; height: 90px;" /></p>

<ul>
	<li><strong>Odd-indexed</strong> rows (1, 3, 5, ...) are cyclically shifted to the right.</li>
</ul>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/rshift-stlone.jpg" style="width: 283px; height: 90px;" /></p>

<p>Return <code>true</code> if the final modified matrix after <code>k</code> steps is identical to the original matrix, and <code>false</code> otherwise.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mat = [[1,2,3],[4,5,6],[7,8,9]], k = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>In each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).</p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/t1-2.jpg" style="width: 857px; height: 150px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/t1-3.jpg" style="width: 632px; height: 150px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">mat = [[2,2],[2,2]], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p>As all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= mat.length &lt;= 25</code></li>
	<li><code>1 &lt;= mat[i].length &lt;= 25</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 25</code></li>
	<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-area-of-island/description" target="_blank" rel="noopener noreferrer">Max Area of Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>&#39;s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>

<p>Return <em>the maximum <strong>area</strong> of an island in </em><code>grid</code>. If there is no island, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" style="width: 500px; height: 310px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-depth-first-search-recursive-accepted">Approach #1: Depth-First Search (Recursive) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We want to know the area of each connected shape in the grid, then take the maximum of these.</p>
<p>If we are on a land square and explore every square connected to it 4-directionally (and recursively squares connected to those squares, and so on), then the total number of squares explored will be the area of that connected shape.</p>
<p>To ensure we don't count squares in a shape more than once, let's use <code>seen</code> to keep track of squares we haven't visited before. It will also prevent us from counting the same shape more than once.</p>
<p><a href="https://leetcode.com/playground/CQGNqDhr/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns.  We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by the call stack during our recursion.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-iterative-accepted">Approach #2: Depth-First Search (Iterative) [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can try the same approach using a stack-based, (or &quot;iterative&quot;) depth-first search.</p>
<p>Here, <code>seen</code> will represent squares that have either been visited or are added to our list of squares to visit (<code>stack</code>). For every starting land square that hasn't been visited, we will explore 4-directionally around it, adding land squares that haven't been added to <code>seen</code> to our <code>stack</code>.</p>
<p>On the side, we'll keep a count <code>shape</code> of the total number of squares seen during the exploration of this shape. We'll want the running max of these counts.</p>
<p><a href="https://leetcode.com/playground/khZHhSir/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(R*C)\)</span>, where <span class="math inline">\(R\)</span> is the number of rows in the given <code>grid</code>, and <span class="math inline">\(C\)</span> is the number of columns. We visit every square once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(R*C)\)</span>, the space used by <code>seen</code> to keep track of visited squares and the space used by <code>stack</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximal-rectangle/description" target="_blank" rel="noopener noreferrer">Maximal Rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" style="width: 402px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;0&quot;]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == matrix.length</code></li>
	<li><code>cols == matrix[i].length</code></li>
	<li><code>1 &lt;= row, cols &lt;= 200</code></li>
	<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximal-square/description" target="_blank" rel="noopener noreferrer">Maximal Square</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, <em>find the largest square containing only</em> <code>1</code>&#39;s <em>and return its area</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" style="width: 400px; height: 319px;" />
<pre>
<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" style="width: 165px; height: 165px;" />
<pre>
<strong>Input:</strong> matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[&quot;0&quot;]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-amount-of-money-robot-can-earn/description" target="_blank" rel="noopener noreferrer">Maximum Amount of Money Robot Can Earn</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> grid. A robot starts at the top-left corner of the grid <code>(0, 0)</code> and wants to reach the bottom-right corner <code>(m - 1, n - 1)</code>. The robot can move either right or down at any point in time.</p>

<p>The grid contains a value <code>coins[i][j]</code> in each cell:</p>

<ul>
	<li>If <code>coins[i][j] &gt;= 0</code>, the robot gains that many coins.</li>
	<li>If <code>coins[i][j] &lt; 0</code>, the robot encounters a robber, and the robber steals the <strong>absolute</strong> value of <code>coins[i][j]</code> coins.</li>
</ul>

<p>The robot has a special ability to <strong>neutralize robbers</strong> in at most <strong>2 cells</strong> on its path, preventing them from stealing coins in those cells.</p>

<p><strong>Note:</strong> The robot&#39;s total coins can be negative.</p>

<p>Return the <strong>maximum</strong> profit the robot can gain on the route.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[0,1,-1],[1,-2,3],[2,-3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p>An optimal path for maximum coins is:</p>

<ol>
	<li>Start at <code>(0, 0)</code> with <code>0</code> coins (total coins = <code>0</code>).</li>
	<li>Move to <code>(0, 1)</code>, gaining <code>1</code> coin (total coins = <code>0 + 1 = 1</code>).</li>
	<li>Move to <code>(1, 1)</code>, where there&#39;s a robber stealing <code>2</code> coins. The robot uses one neutralization here, avoiding the robbery (total coins = <code>1</code>).</li>
	<li>Move to <code>(1, 2)</code>, gaining <code>3</code> coins (total coins = <code>1 + 3 = 4</code>).</li>
	<li>Move to <code>(2, 2)</code>, gaining <code>4</code> coins (total coins = <code>4 + 4 = 8</code>).</li>
</ol>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">coins = [[10,10,10],[10,10,10]]</span></p>

<p><strong>Output:</strong> <span class="example-io">40</span></p>

<p><strong>Explanation:</strong></p>

<p>An optimal path for maximum coins is:</p>

<ol>
	<li>Start at <code>(0, 0)</code> with <code>10</code> coins (total coins = <code>10</code>).</li>
	<li>Move to <code>(0, 1)</code>, gaining <code>10</code> coins (total coins = <code>10 + 10 = 20</code>).</li>
	<li>Move to <code>(0, 2)</code>, gaining another <code>10</code> coins (total coins = <code>20 + 10 = 30</code>).</li>
	<li>Move to <code>(1, 2)</code>, gaining the final <code>10</code> coins (total coins = <code>30 + 10 = 40</code>).</li>
</ol>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == coins.length</code></li>
	<li><code>n == coins[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>-1000 &lt;= coins[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-difference-score-in-a-grid/description" target="_blank" rel="noopener noreferrer">Maximum Difference Score in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>grid</code> consisting of <strong>positive</strong> integers. You can move from a cell in the matrix to <strong>any</strong> other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value <code>c1</code> to a cell with the value <code>c2</code> is <code>c2 - c1</code>.<!-- notionvc: 8819ca04-8606-4ecf-815b-fb77bc63b851 --></p>

<p>You can start at <strong>any</strong> cell, and you have to make <strong>at least</strong> one move.</p>

<p>Return the <strong>maximum</strong> total score you can achieve.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/03/14/grid1.png" style="width: 240px; height: 240px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong> We start at the cell <code>(0, 1)</code>, and we perform the following moves:<br />
- Move from the cell <code>(0, 1)</code> to <code>(2, 1)</code> with a score of <code>7 - 5 = 2</code>.<br />
- Move from the cell <code>(2, 1)</code> to <code>(2, 2)</code> with a score of <code>14 - 7 = 7</code>.<br />
The total score is <code>2 + 7 = 9</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/04/08/moregridsdrawio-1.png" style="width: 180px; height: 116px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[4,3,2],[3,2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong> We start at the cell <code>(0, 0)</code>, and we perform one move: <code>(0, 0)</code> to <code>(0, 1)</code>. The score is <code>3 - 4 = -1</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-matrix-sum/description" target="_blank" rel="noopener noreferrer">Maximum Matrix Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer <code>matrix</code>. You can do the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Choose any two <strong>adjacent</strong> elements of <code>matrix</code> and <strong>multiply</strong> each of them by <code>-1</code>.</li>
</ul>

<p>Two elements are considered <strong>adjacent</strong> if and only if they share a <strong>border</strong>.</p>

<p>Your goal is to <strong>maximize</strong> the summation of the matrix&#39;s elements. Return <em>the <strong>maximum</strong> sum of the matrix&#39;s elements using the operation mentioned above.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png" style="width: 401px; height: 81px;" />
<pre>
<strong>Input:</strong> matrix = [[1,-1],[-1,1]]
<strong>Output:</strong> 4
<b>Explanation:</b> We can follow the following steps to reach sum equals 4:
- Multiply the 2 elements in the first row by -1.
- Multiply the 2 elements in the first column by -1.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png" style="width: 321px; height: 121px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
<strong>Output:</strong> 16
<b>Explanation:</b> We can follow the following step to reach sum equals 16:
- Multiply the 2 last elements in the second row by -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 250</code></li>
	<li><code>-10<sup>5</sup> &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-journey-from-minus-to-plus">Approach: Journey From Minus to Plus</h3>
<h4 id="intuition">Intuition</h4>
<p>To maximize the matrix sum, letâ€™s first imagine the ideal situation: if every element in the matrix were positive, we would have the highest possible sum. Since we can flip pairs of adjacent elements by multiplying them by -1, we could, in theory, make all values positive if we wanted. So, we start by calculating the sum of the absolute values of all elements, as this would be the ideal maximum sum if all elements were positive.</p>
<p>Next, we need to think about when flipping doesnâ€™t work perfectly. Specifically, if thereâ€™s an odd number of negative elements, it wonâ€™t be possible to make everything positive because one negative will always remain. This observation leads us to a simple rule: if thereâ€™s an even count of negative numbers, we can flip them all to positive values. But if the count is odd, one number has to stay negative, which means the sum canâ€™t be quite as high as in the ideal case.</p>
<p>To minimize the impact of this remaining negative, we want it to be the smallest number in the matrix. So, while calculating the absolute sum, we also track the smallest absolute value. This way, if we end up with an odd count of negatives, we can subtract twice this smallest value from the total. This subtraction accounts for the one unavoidable negative element and keeps the final sum as high as possible.</p>
<details>
  <summary>Why subtract twice the smallest absolute value? (Click Here!)</summary>
  <p>For an odd count of negative numbers, flipping a negative number to positive adds that number's absolute value to the total sum. For example, if we had flipped -1 to +1, it would increase the sum by +1. However, since we can't flip this number (due to the odd count of negatives), we need to "remove" this potential gain. This is why we subtract twice the smallest absolute value: once to account for the gain we didnâ€™t get and again because we didnâ€™t flip it.</p>
</details>
</br>
<p>!?!../Documents/1975/1975_maximum_matrix_sum.json:760,680!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>totalSum</code> to 0, <code>minAbsVal</code> to <code>INT_MAX</code>, and <code>negativeCount</code> to 0 to store the sum of absolute values, track the smallest absolute value, and count the number of negative elements, respectively.</p>
</li>
<li>
<p>For each row in <code>matrix</code>:</p>
<ul>
<li>For each <code>val</code> in the row:
<ul>
<li>Add the absolute value of <code>val</code> to <code>totalSum</code> to accumulate the absolute sum.</li>
<li>If <code>val</code> is negative, increment <code>negativeCount</code>.</li>
<li>Update <code>minAbsVal</code> to the smaller of <code>minAbsVal</code> and <code>abs(val)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After traversing the matrix, check if <code>negativeCount</code> is odd:</p>
<ul>
<li>If it is, subtract <code>2 * minAbsVal</code> from <code>totalSum</code> to adjust for the odd number of negatives, ensuring the maximum possible matrix sum.</li>
</ul>
</li>
<li>
<p>Return <code>totalSum</code>, which now represents the maximum achievable matrix sum after adjustments.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HniUHgCZ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> be the number of rows and <code>m</code> be the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \times m)\)</span></p>
<p>The algorithm iterates through each element in the matrix, performing constant-time operations per element, resulting in an overall time complexity of <span class="math inline">\(O(n \times m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of space, independent of the size of the matrix, resulting in a space complexity of <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-non-negative-product-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Maximum Non Negative Product in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code>. Initially, you are located at the top-left corner <code>(0, 0)</code>, and in each step, you can only <strong>move right or down</strong> in the matrix.</p>

<p>Among all possible paths starting from the top-left corner <code>(0, 0)</code> and ending in the bottom-right corner <code>(m - 1, n - 1)</code>, find the path with the <strong>maximum non-negative product</strong>. The product of a path is the product of all integers in the grid cells visited along the path.</p>

<p>Return the <em>maximum non-negative product <strong>modulo</strong> </em><code>10<sup>9</sup> + 7</code>. <em>If the maximum product is <strong>negative</strong>, return </em><code>-1</code>.</p>

<p>Notice that the modulo is performed after getting the maximum product.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/product1.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/product2.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,-2,1],[1,-2,1],[3,-4,1]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/product3.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[1,3],[0,-4]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Maximum non-negative product is shown (1 * 0 * -4 = 0).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 15</code></li>
	<li><code>-4 &lt;= grid[i][j] &lt;= 4</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-no-of-1s-row3027/1" target="_blank" rel="noopener noreferrer">Maximum no of 1&#39;s row</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a boolean 2D array, where each row is sorted. Find the row with the maximum number of 1s.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N = 3, M = 4
Mat[] = {{0 1 1 1},
         {0 0 1 1},
&nbsp;        {0 0 1 1}}
<strong>Output:</strong> 0
<strong>Explanation</strong>: Row 0 has 3 ones whereas
rows 1 and 2 have just 2 ones.
</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: 
N = 2, M = 2
Mat[] = {{0 1},
&nbsp;        {1 1}}
<strong>Output:</strong> 1
<strong>Explanation</strong>: Row 1 has 2 ones whereas
row 0 has just a single one. </span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function&nbsp;<strong>maxOnes ()&nbsp;</strong>which takes a 2D array Mat[][] and its dimensions N&nbsp;and M&nbsp;as inputs and returns the row index with the maximum number of 1s (0-based index). If there are multiple rows with the maximum number of ones, then return the row with the smaller index.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(NLogM).<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N, M &lt;= 40<br />
0 &lt;= M[ ][ ] &lt;= 1</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-number-of-coins--170647/1" target="_blank" rel="noopener noreferrer">Maximum Number of coins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">We have been given N balloons, each with a number of coins associated with it. On bursting a balloon i, the number of coins gained is equal to A[i-1]*A[i]*A[i+1].<br />
Also, balloons i-1 and i+1 now become adjacent. Find the maximum possible profit earned after bursting all the balloons. Assume an extra 1 at each boundary.</span></p>

<p><strong><span style="font-size:18px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input</strong><strong>:</strong> 
N=2
a[]={5, 10}
<strong>Output:</strong> 
60
<strong>Explanation:</strong> First Burst 5, Coins = 1*5*10
              Then burst 10, Coins+= 1*10*1
              Total = 60</span></pre>

<p><strong><span style="font-size:18px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px">N=4
a[] = {3,1,5,8}
<strong>Output:
</strong>167
<strong>Explanation:</strong>
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>maxCoins()</strong>&nbsp;which takes the array arr[], its size N, and returns the maximum number of coins that can be collected.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N^3)<br />
<strong>Expected Space Complexity:</strong> O(N^2)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= N &lt;= 400</span><br />
<span style="font-size:18px">0 &lt;= a[i] &lt;= 100</span><br />
&nbsp;</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-fish-in-a-grid/description" target="_blank" rel="noopener noreferrer">Maximum Number of Fish in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>

<ul>
	<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>
	<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>
</ul>

<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>

<ul>
	<li>Catch all the fish at cell <code>(r, c)</code>, or</li>
	<li>Move to any adjacent <strong>water</strong> cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>

<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example.png" style="width: 241px; height: 161px;" />
<pre>
<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/29/example2.png" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a <code>grid</code> of size <code>m x n</code>, where each cell <code>(r, c)</code> can either be land or water. The grid is represented by an integer matrix where:</p>
<ul>
<li>A land cell is denoted by <code>0</code>.</li>
<li>A water cell contains a number of fish, indicated by a value greater than <code>0</code>.</li>
</ul>
<p>We need to find the largest number of fish that a fisher can collect by starting at an optimal water cell and moving to connected water cells. The fisher can collect fish from any water cell they start from, and then they can move to any adjacent water cell to continue collecting more fish. The fisher can repeat this operation as many times as needed, moving between connected water cells to collect fish.</p>
<p>This problem is closely related to the &quot;<a href="https://leetcode.com/problems/max-area-of-island/description/">Max Area of Island</a>&quot; problem, which also deals with connected regions in a grid. However, the key difference here is that in this problem, the value in each water cell is not simply <code>1</code>, but rather the number of fish in that cell, which adds an extra layer of complexity.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can think of the grid as a map of a graph, where each water cell is a node connected to other water cells around it, either up, down, left, or right. The water cells are grouped together, forming distinct regions that are separated by land cells. The goal is to find the largest group of connected water cells, which represents the region with the most fish.</p>
<p>To solve this, we can use a <a href="https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/">Depth-First Search (DFS)</a>. DFS works by exploring every connected node (in this case, the water cells) starting from a given cell. When we find a water cell, we start a DFS from that cell. The DFS will look at all neighboring water cells (in all four directions), marking them as visited to ensure we donâ€™t count them again.</p>
<p>As we traverse each connected water region, we also keep a running total of the number of fish in that region. This means that for every new DFS call, we add up all the fish in that group of connected cells.</p>
<p>After exploring all the water cells in one region, we move on to the next unvisited water cell and repeat the process. While doing this, we always track the greatest number of fish encountered in any of the regions. By the time we finish going through the whole grid, we will have found the region with the most fish and that will be our result.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>Initialize <code>m</code> and <code>n</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li>Create a 2D vector <code>visited</code> of size <code>m x n</code> to track visited cells, initialized to <code>false</code>.</li>
<li>Initialize <code>result</code> to <code>0</code>, which will store the maximum fish count from any connected component.</li>
<li>Iterate through each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell is a water cell (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int r, int c)</code></p>
<ol>
<li>If the current cell <code>(r, c)</code>, is out of bounds, is a land cell (<code>grid[r][c] == 0</code>), or, has already been visited (<code>visited[r][c] == true</code>), return <code>0</code>.</li>
<li>Mark the current cell <code>(r, c)</code> as visited by setting <code>visited[r][c] = true</code>.</li>
<li>Recursively calculate the total fish count from all connected water cells:
<ul>
<li>Call <code>countFishes</code> for the cells to the right, left, bottom, and top.</li>
</ul>
</li>
<li>Return the sum of fish in the current cell (<code>grid[r][c]</code>) and the fish counts from all valid neighboring cells.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/VHJhrpCk/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m x n</code> cells. For each cell, it performs a depth-first search (DFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m x n</code> to track visited cells. Additionally, the depth-first search (DFS) can recurse to explore all connected cells, contributing to the space complexity. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Similar to Depth-First Search (DFS), we can also use a <a href="https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/">Breadth-First Search (BFS)</a> to explore the grid and find the connected water regions. BFS works by exploring all neighboring cells at the present depth level before moving on to cells at the next level. This means that BFS explores level by level, starting from a water cell and expanding outward to its neighboring water cells.</p>
<p>We start by iterating through the grid and whenever we encounter a water cell that hasn't been visited yet, we initiate a BFS. From that cell, we explore its four neighboring cells (up, down, left, right), checking if they are also water cells and marking them as visited. This continues until all water cells in the current region have been explored.</p>
<p>While performing the BFS, we accumulate the number of fish in the connected region by adding up the values of all the visited water cells. This ensures that we get the total number of fish in that region.</p>
<p>After exploring all neighboring water cells in the current region, we move on to the next unvisited water cell and repeat the BFS process. Throughout the BFS traversal, we keep track of the largest fish count encountered. By the end of the grid traversal, we will have identified the connected water region with the most fish and return that as our result.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the number of rows and columns in <code>grid</code>.</li>
<li><code>result</code> to store the maximum fish count found in any connected component. Initialized to <code>0</code>.</li>
<li><code>visited</code> as a 2D matrix of size <code>numRows x numCols</code> to track visited cells, initialized to <code>false</code>.</li>
</ul>
</li>
<li>
<p>Iterate through the Grid:</p>
<ul>
<li>For each cell <code>(i, j)</code> in the grid:
<ul>
<li>If the cell contains water (<code>grid[i][j] &gt; 0</code>) and has not been visited, call <code>countFishes(grid, visited, i, j)</code> to calculate the total fish in the connected component starting from <code>(i, j)</code>.</li>
<li>Update <code>result</code> to the maximum of <code>result</code> and the fish count returned by <code>countFishes</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Result:</p>
<ul>
<li>After iterating through all cells, return the <code>result</code>.</li>
</ul>
</li>
</ol>
<p>Helper Function: <code>countFishes(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int row, int col)</code></p>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>numRows</code> and <code>numCols</code> to represent the dimensions of the grid.</li>
<li><code>fishCount</code> to accumulate the number of fish in the connected component, initialized to <code>0</code>.</li>
<li><code>q</code> as a queue for BFS traversal starting from the initial cell <code>(row, col)</code>.</li>
</ul>
</li>
<li>
<p>BFS Traversal:</p>
<ul>
<li>Push the initial cell <code>(row, col)</code> onto the queue and mark it as visited.</li>
<li>While the queue is not empty:
<ul>
<li>Dequeue the front element to get current coordinates <code>(row, col)</code>.</li>
<li>Add the fish count from the current cell to <code>fishCount</code>.</li>
<li>Explore all four directions (up, down, left, right) for connected water cells:
<ul>
<li>If the neighboring cell is within bounds, contains water, and hasn't been visited, add it to the queue and mark it as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return Fish Count:</p>
<ul>
<li>After exploring all possible connected cells, return <code>fishCount</code>.</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/afuZyzJQ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, where the <code>grid</code> is completely filled with water cells, the algorithm iterates through all <code>m \cdot n</code> cells. For each cell, it performs a Breadth-first search (BFS) to calculate the total fish in the connected region. Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The algorithm uses a <code>visited</code> matrix of size <code>m \cdot n</code> to track visited cells. Hence, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-union-find-algorithm">Approach 3: Union Find Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving problems based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union-find data structure or merge-find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. More specifically, it allows us to perform two main operations:</p>
<ol>
<li><strong>Find</strong>: This operation helps us determine which set a particular element belongs to. In our case, it will help us check if two water cells are part of the same connected region.</li>
<li><strong>Union</strong>: This operation merges two sets into one. It allows us to combine two connected water cells into the same region.</li>
</ol>
<p>For this problem, we can think of each water cell as an individual set, and the goal is to merge them into larger sets based on their connectivity. As we perform the &quot;Union&quot; operation, we also need to keep track of the total number of fish in each connected component (group of connected water cells).</p>
<p>If you are new to Union-Find, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">LeetCode Explore Card</a>. We will not talk about implementation details in this article, but only about the interface to the data structure.</p>
<p>Our task, as with the previous approaches, is to count the maximum sum of fishes among all the connected components formed in the graph with water cells acting as nodes and an edge between directly connected cells.</p>
<p>First, we treat each water cell as its own separate component, initializing a structure to store the number of fish in each component. Initially, each water cell holds its own fish count.</p>
<p>We then iterate over all the cells in the grid. For each water cell, we check its four neighbors (up, down, left, right). If a neighboring cell is also water, we perform a &quot;Union&quot; operation to merge their components, effectively connecting the two cells. As we do this, we update the fish count for the newly merged component by adding the fish counts from both cells.</p>
<p>After merging the cells, we keep track of the maximum fish count encountered in any connected component. This can be done by maintaining a separate array (let's call it <code>fishes</code>) where each entry corresponds to the total fish count of a particular connected component.</p>
<p>At the end of this process, the largest value in the <code>totalFish</code> array will give us the largest sum of fish in any connected component.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main Function: <code>findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid)</code></p>
<ul>
<li>
<p>Initialize Variables:</p>
<ul>
<li>Determine the number of rows (<code>rows</code>) and columns (<code>cols</code>) in the grid.</li>
<li>Compute the total number of cells (<code>totalCells</code>) which is <code>rows * cols</code>.</li>
</ul>
</li>
<li>
<p>Union-Find Initialization:</p>
<ul>
<li>Create arrays <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>:
<ul>
<li><code>parent</code> keeps track of the root for each cell.</li>
<li><code>componentSize</code> tracks the size of the component (number of cells) each root represents.</li>
<li><code>totalFish</code> tracks the total fish count in the connected component represented by each root.</li>
</ul>
</li>
<li>Use <code>iota(parent.begin(), parent.end(), 0)</code> to initialize <code>parent</code> such that each cell is its own parent initially.</li>
</ul>
</li>
<li>
<p>Setting Initial Fish Count:</p>
<ul>
<li>Traverse the grid and populate the <code>totalFish</code> array with the fish count of each cell.</li>
</ul>
</li>
<li>
<p>Union Operation:</p>
<ul>
<li>Use direction vectors <code>dRow</code> and <code>dCol</code> to explore neighboring cells (right, left, down, up).</li>
<li>For each water cell (<code>grid[row][col] &gt; 0</code>), union its connected neighbors using the <code>unionComponents</code> function.</li>
</ul>
</li>
<li>
<p>After processing all cells and merging components, iterate through the <code>totalFish</code> array to find the maximum fish count among all components that have a unique root.</p>
</li>
<li>
<p>Return the maximum fish count found.</p>
</li>
</ul>
<p>Helper Function: <code>unionComponents(vector&lt;int&gt;&amp; parent, vector&lt;int&gt;&amp; componentSize, vector&lt;int&gt;&amp; totalFish, int x, int y)</code></p>
<ul>
<li>
<p>Find the root of <code>x</code>: Use <code>findParent</code> to get the root of component containing <code>x</code>.</p>
</li>
<li>
<p>Find the root of <code>y</code>: Use <code>findParent</code> to get the root of component containing <code>y</code>.</p>
</li>
<li>
<p>Union by size: If the roots are different, attach the smaller tree under the root of the larger tree, ensuring optimization.</p>
</li>
<li>
<p>Update Component Size and Fish Count: After merging, update the size of the new component and the total fish count accordingly.</p>
</li>
</ul>
<p>Helper Function: <code>findParent(vector&lt;int&gt;&amp; parent, int x)</code></p>
<ul>
<li>If <code>parent[x]</code> equals <code>x</code>, then <code>x</code> is its own root. Otherwise, recursively find the parent of <code>parent[x]</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/goJL6dcH/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span></p>
<p>The outer loop iterates over all cells in the grid, which takes <span class="math inline">\(O(n \cdot m)\)</span> time.</p>
<p>For each cell, the algorithm checks its four neighbors (right, left, down, up), which is a constant <span class="math inline">\(O(4)\)</span> operation.</p>
<p>The <code>findParent</code> and <code>unionComponents</code> operations are performed using the Union-Find data structure with path compression and union by size. These operations have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function, which is very small and can be considered almost constant.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((n \cdot m) \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses three auxiliary arrays: <code>parent</code>, <code>componentSize</code>, and <code>totalFish</code>, each of size <span class="math inline">\(n \cdot m\)</span>.</p>
<p>The space required for these arrays is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Additionally, the recursion stack for the <code>findParent</code> function is bounded by the height of the Union-Find tree, which is <span class="math inline">\(O(\alpha(n \cdot m))\)</span> due to path compression. However, this is negligible compared to the space used by the arrays.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-moves-in-a-grid/description" target="_blank" rel="noopener noreferrer">Maximum Number of Moves in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> matrix <code>grid</code> consisting of <strong>positive</strong> integers.</p>

<p>You can start at <strong>any</strong> cell in the first column of the matrix, and traverse the grid in the following way:</p>

<ul>
	<li>From a cell <code>(row, col)</code>, you can move to any of the cells: <code>(row - 1, col + 1)</code>, <code>(row, col + 1)</code> and <code>(row + 1, col + 1)</code> such that the value of the cell you move to, should be <strong>strictly</strong> bigger than the value of the current cell.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of <strong>moves</strong> that you can perform.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" style="width: 201px; height: 201px;" />
<pre>
<strong>Input:</strong> grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can start at the cell (0, 0) and make the following moves:
- (0, 0) -&gt; (0, 1).
- (0, 1) -&gt; (1, 2).
- (1, 2) -&gt; (2, 3).
It can be shown that it is the maximum number of moves that can be made.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<img alt="" src="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png" />
<strong>Input:</strong> grid = [[3,2,4],[2,1,9],[1,1,7]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Starting from any cell in the first column we cannot perform any moves.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have an <code>M x N</code> matrix called <code>grid</code>, filled with positive integers. The challenge is to start from any cell in the first column and find out how many moves we can make to the right while following specific rules.</p>
<p>From any cell <code>(i, j)</code> in the first column, we can move to the next column in one of three ways:</p>
<ol>
<li>Directly right to the cell <code>(i, j + 1)</code>.</li>
<li>Diagonally up-right to the cell <code>(i - 1, j + 1)</code>.</li>
<li>Diagonally down-right to the cell <code>(i + 1, j + 1)</code>.</li>
</ol>
<p>However, there's an important condition: we can only make a move if the value in the destination cell is greater than the value in the current cell.</p>
<p>Our goal is to determine the maximum number of moves we can make, starting from any cell in the first column.</p>
<p><img src="../Figures/2684/2684A.png" alt="fig" /></p>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's consider the scenario with a single starting point from the first column. To solve the problem, the most intuitive approach is to explore the possible cells (those with a greater value) from the current cell and continue moving until there are no further options. The maximum number of moves made during this process would be our answer. In this case, we would track the cells we have visited to ensure that each cell is not visited more than once.</p>
<p>However, tracking visited cells raises a question: is it possible to reach the same cell from different starting points with different numbers of moves? If so, we would need to revisit a cell for each starting point to find the maximum move count. We can prove that this is not possible. The number of moves required to reach a particular cell from different starting points would always be the same. This is because, in each move, the column index strictly increases (as we move from a cell in column <code>j</code> to a cell in column <code>j + 1</code>). Therefore, reaching cell <code>(i, j)</code> from any starting cell in the first column (say <code>(x, 0)</code>) requires exactly <code>j</code> moves, and it's not possible to reach it in more or fewer moves.</p>
<p>To extend this approach for starting from any cell in the first column, we can use a traversal method known as Breadth-First Search (BFS). A variation of BFS that starts with multiple initial sources is called Multi-Source BFS. In this case, the approach remains similar to the single-source scenario, except that all cells in the first column are used as starting points in the BFS queue. We then explore the possible next cells that have not been visited yet and have a value greater than the current cell. We keep track of the number of moves made so far, and each time we process a cell from the queue, we update the maximum moves recorded. At the end, this value represents the maximum possible moves.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize Variables:
<ul>
<li>Get the dimensions of the grid: <code>M</code> (number of rows) and <code>N</code> (number of columns).</li>
<li>Create a queue <code>q</code> for BFS traversal.</li>
<li>Create a 2D list <code>vis</code> of size <code>M x N</code> initialized to False to keep track of visited cells.</li>
<li>Define possible directions for movement to adjacent rows in the next column as <code>dirs = [-1, 0, 1]</code>.</li>
</ul>
</li>
<li>Enqueue Starting Cells:
<ul>
<li>For each row in the first column (<code>col = 0</code>):
<ul>
<li>Mark the cell as visited.</li>
<li>Enqueue the cell along with the initial move count <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Perform BFS Traversal:
<ul>
<li>Initialize <code>maxMoves</code> to <code>0</code> to store the maximum number of moves made.</li>
<li>While the queue is not empty:
<ul>
<li>Get the size of the current queue (<code>sz</code>) representing the number of cells to process at this level.</li>
<li>For each cell in the current level:
<ul>
<li>Dequeue the cell and extract its row, column, and move count.</li>
<li>Update <code>maxMoves</code> as the maximum between <code>maxMoves</code> and the current move count.</li>
<li>Explore Possible Moves:
<ul>
<li>For each direction (<code>dir</code>) in <code>dirs</code>:
<ul>
<li>Calculate the new row as <code>newRow = row + dir</code> and the new column as <code>newCol = col + 1</code>.</li>
<li>Check if the new cell is within bounds, not yet visited, and its value is greater than the current cell's value.</li>
<li>If valid, mark the new cell as visited, and enqueue it with the incremented move count (<code>count + 1</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>After processing all cells, return <code>maxMoves</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/25bnsXdR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows and <span class="math inline">\(N\)</span> is the number of columns in the given matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will always be visiting a cell only once due to the visited array. We started from the cells in the first column and might end up in visiting all the cells in the matrix. Hence the time complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We need the visited array as the size of the given matrix <code>grid</code> to keep track of each cell. Also, the queue used in the BFS will have the <span class="math inline">\(M\)</span> number of entries at max, i.e. one for each row. Hence, the total space complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-top-down-dynamic-programming">Approach 2: Top-Down Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach uses a similar idea but with a different strategy. As discussed earlier, one method is to explore the possible cells from the current cell and continue until no further options remain. This works well when there is a single starting cell.</p>
<p>However, in the given problem, there are multiple starting cells, and repeating the process for each one independently might be inefficient. This is because we could end up traversing the same cells multiple times from different starting points. The key insight for using dynamic programming here is that the number of moves possible from a cell is fixed, regardless of how we reach that cell. In other words, once we have calculated the number of moves for a cell, we can reuse that value whenever we encounter that cell again, rather than recalculating it.</p>
<p>To solve the problem, we'll perform a recursive process to explore the possible cells for each starting point in the first column and determine the maximum number of moves we can make. After calculating the moves for each starting cell, we will return the highest value as the maximum possible moves. During this process, we'll use memoization to store the number of moves for each cell, allowing us to return the result directly if we revisit that cell, thus avoiding redundant recursion</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Define possible directions for movement to adjacent rows in the next column as <code>dirs = [-1, 0, 1]</code>.</li>
<li>Define DFS Function:
<ul>
<li>The DFS function takes <code>row</code>, <code>col</code>, <code>grid</code>, and <code>dp</code> array as parameters.</li>
<li>Get the dimensions <code>M</code> (number of rows) and <code>N</code> (number of columns).</li>
<li>Check Memoized Result: If <code>dp[row][col]</code> is not <code>-1</code>, return its value, as the maximum moves for this cell have already been computed.</li>
<li>Initialize <code>max_moves</code> to <code>0</code> to track the maximum moves possible from this cell.
<ul>
<li>Explore All Directions:</li>
<li>For each direction in dirs:
<ul>
<li>Compute the next cell position as <code>new_row = row + dir</code> and <code>new_col = col + 1</code>.</li>
<li>Check Validity: Ensure that the new position is within grid bounds and the next cell value is greater than the current cell's value.</li>
<li>If valid, recursively call DFS on the new position and update <code>max_moves</code> as max(<code>max_moves</code>, <code>1 + DFS(new_row, new_col, grid, dp)</code>).</li>
</ul>
</li>
</ul>
</li>
<li>Store the computed <code>max_moves</code> for <code>dp[row][col]</code> and return it.</li>
</ul>
</li>
<li>Call the above function for all the cells in the first column and find the maximum returned value as <code>maxMoves</code>.</li>
<li>Return <code>maxMoves</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VPnLRcnW/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows and <span class="math inline">\(N\)</span> is the number of columns in the given matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will always be the calculating the moves for each cell only once due to the <code>dp</code> array. We might end up finding all the states in the <code>dp</code> that are <span class="math inline">\(M \cdot N\)</span> and hence the time complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The size of array <code>dp</code> is same as the size of the given matrix <code>grid</code> to keep the answer of each cell. There will also be some stack space required to keep all the active stack calls which can be at max equal to number of columns as there can be one active stack call for each move. Hence, the total space complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-bottom-up-dynamic-programming">Approach 3: Bottom-up Dynamic Programming</h3>
<h4 id="intuition-2">Intuition</h4>
<p>This approach is similar to the previous one, but instead of using recursion, we calculate the state values iteratively in a <code>dp</code> array. This helps save space that would otherwise be used for the recursion stack. The process of filling the values in this approach is essentially the reverse of the previous method.</p>
<p>For each cell in the grid, the <code>dp</code> array stores the number of moves required to reach that cell when starting from any cell in the first column. We begin with the base case: the cells in the first column are initialized with a value of <code>1</code>. Although logically, the number of moves should be <code>0</code> since we can't move to a cell starting from itself, we assign a value of <code>1</code> to these cells as an indicator that they are reachable. Cells with a value of <code>0</code> in <code>dp</code> will represent those that cannot be reached from any starting point in the first column. We can adjust the extra <code>1</code> by subtracting it from the result before returning the final answer.</p>
<p>To calculate the values for the remaining cells, we iterate through the columns from <code>1</code> to <code>N - 1</code>, and within each column, we iterate over the rows from <code>0</code> to <code>M - 1</code>. This order is necessary because determining the value for cell <code>(i, j)</code> depends on the values of the cells in the previous column, namely <code>(i - 1, j - 1)</code>, <code>(i, j - 1)</code>, and <code>(i + 1, j - 1)</code>. Thus, when processing column <code>j</code>, we must already have the values for all rows in column <code>j - 1</code>.</p>
<p>For each cell <code>(i, j)</code>, we check the three potential cells from the previous column. If any of these cells have a value less than the current cell and their dp value is not zero (indicating that the cell is reachable), we update <code>dp[i][j]</code> to be the maximum of its current value and one plus the value of the reachable cell:</p>
<blockquote>
<p><span class="math inline">\( \text {dp[i][j] = max(dp[i][j],  dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i + 1][j - 1] + 1)}\)</span></p>
</blockquote>
<p>This formula is used provided that the value of the previous cell is greater than the current cell and has a positive dp value. The maximum number of moves we can make from any cell in the first column will be the highest value in the <code>dp</code> array after subtracting the extra <code>1</code> that we initially added.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize variables:
<ul>
<li>Get the grid dimensions <code>M</code> (rows) and <code>N</code> (columns).</li>
<li>Create a 2D dp array of size <code>M x N</code> initialized to <code>0</code> to store the maximum moves from each cell.</li>
</ul>
</li>
<li>Set Initial reachable cells:
<ul>
<li>For each cell in the first column (<code>col = 0</code>), set <code>dp[i][0] = 1</code> for all rows <code>i</code>. This indicates that these cells are reachable as starting points.</li>
</ul>
</li>
<li>Iterate over each cell in column major order, for each cell <code>(i, j)</code>
<ul>
<li>Check the possible cells in the previous column:
<ul>
<li>If the current cell <code>grid[i][j]</code> is greater than the cell directly to its left <code>grid[i][j - 1]</code> and <code>dp[i][j - 1] &gt; 0</code> (reachable):
<ul>
<li>Update dp[i][j] with the maximum of its current value and dp[i][j - 1] + 1.</li>
</ul>
</li>
<li>If <code>i - 1</code> (upper diagonal) is valid, and <code>grid[i][j]</code> is greater than <code>grid[i - 1][j - 1]</code> and <code>dp[i - 1][j - 1] &gt; 0</code>:
<ul>
<li>Update <code>dp[i][j]</code> with the maximum of its current value and <code>dp[i - 1][j - 1] + 1</code>.</li>
</ul>
</li>
<li>If <code>i + 1</code> (lower diagonal) is valid, and <code>grid[i][j]</code> is greater than <code>grid[i + 1][j - 1]</code> and <code>dp[i + 1][j - 1] &gt; 0</code>:
<ul>
<li>Update <code>dp[i][j]</code> with the maximum of its current value and <code>dp[i + 1][j - 1] + 1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Find the maximum value of all <code>dp[i][j] - 1</code> as <code>maxMoves</code></li>
<li>Return <code>maxMoves</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/2wpPakvv/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows and <span class="math inline">\(N\)</span> is the number of columns in the given matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will be finding the values for each cell in the array <code>dp</code> with size as <span class="math inline">\(M \cdot N\)</span> and hence the time complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>The size of array <code>dp</code> is same as the size of the given matrix <code>grid</code> to keep the answer of each cell. Hence, the total space complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-space-optimized-bottom-up-dynamic-programming">Approach 4: Space-Optimized Bottom-up Dynamic Programming</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In our previous solution, we used a <code>dp</code> array with a size of <code>M x N</code> to keep track of the number of moves possible for each cell in a grid. But if we dig a bit deeper, weâ€™ll notice that for any cell <code>(i, j)</code>, the answer only depends on values from the previous column, <code>j - 1</code>, because any moves to <code>(i, j)</code> come from there.</p>
<p>This observation simplifies things a lot! Instead of storing results for every single cell in the grid, we can just keep track of two columns at a time: the previous column (for reference) and the current column (for updating values). As we move to the next column, we simply update our &quot;previous column&quot; values to reflect the new current column results. This way, weâ€™re only using two arrays, one for each column we need, instead of the whole <code>M x N</code> grid. This small adjustment saves a lot of memory, giving us a big boost in efficiency.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize Variables:
<ul>
<li>Get the grid dimensions <code>M</code> (rows) and <code>N</code> (columns).</li>
<li>Create a dp array of size <code>M x 2</code> initialized to <code>0</code> to store the maximum moves.
<ul>
<li>dp[i][0] tracks moves for the current column.</li>
<li>dp[i][1] tracks moves for the next column.</li>
</ul>
</li>
</ul>
</li>
<li>Set initial reachable cells:
<ul>
<li>For each cell in the first column (<code>col = 0</code>), set <code>dp[i][0] = 1</code> for all rows <code>i</code>, indicating that these cells are reachable starting points.</li>
</ul>
</li>
<li>Iterate over each cell in column major order, for each cell <code>(i, j)</code>
<ul>
<li>Check Possible Moves:
<ul>
<li>If <code>grid[i][j]</code> is greater than <code>grid[i][j - 1]</code> and <code>dp[i][0] &gt; 0</code> (reachable):
<ul>
<li>Update <code>dp[i][1]</code> as <code>max(dp[i][1], dp[i][0] + 1)</code>.</li>
</ul>
</li>
<li>If <code>i - 1</code> (upper diagonal) is valid and <code>grid[i][j]</code> is greater than <code>grid[i - 1][j - 1]</code> and <code>dp[i - 1][0] &gt; 0</code>:
<ul>
<li>Update <code>dp[i][1]</code> as <code>max(dp[i][1], dp[i - 1][0] + 1)</code>.</li>
</ul>
</li>
<li>If <code>i + 1</code> (lower diagonal) is valid and grid[i][j] is greater than <code>grid[i + 1][j - 1]</code> and <code>dp[i + 1][0] &gt; 0</code>:
<ul>
<li>Update <code>dp[i][1]</code> as <code>max(dp[i][1], dp[i + 1][0] + 1)</code>.</li>
</ul>
</li>
<li>Update <code>maxMoves</code> with <code>max(maxMoves, dp[i][1] - 1)</code> to track the maximum number of moves so far.</li>
</ul>
</li>
</ul>
</li>
<li>After processing each column <code>j</code>, shift values from <code>dp[i][1]</code> to <code>dp[i][0]</code> for the next iteration, and reset <code>dp[i][1]</code> to <code>0</code> for all rows <code>i</code>.</li>
<li>Return <code>maxMoves</code>.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/4r8yVBnB/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> is the number of rows and <span class="math inline">\(N\)</span> is the number of columns in the given matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M \cdot N)\)</span></p>
<p>We will be finding the values for each cell in the array <code>dp</code> with size as <span class="math inline">\(M \cdot N\)</span> and hence the time complexity is equal to <span class="math inline">\(O(M \cdot N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M)\)</span></p>
<p>The size of array <code>dp</code> is <span class="math inline">\(2 * M\)</span>. Hence, the total space complexity is equal to <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-points-from-grid-queries/description" target="_blank" rel="noopener noreferrer">Maximum Number of Points From Grid Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two-pointers</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>

<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>

<ul>
	<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>
	<li>Otherwise, you do not get any points, and you end this process.</li>
</ul>

<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>

<p>Return <em>the resulting array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/image1.png" style="width: 571px; height: 152px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
<strong>Output:</strong> [5,8,1]
<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" />
<pre>
<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> matrix <code>grid</code> and an array of queries, <code>queries</code>. For each query, we attempt to collect as many points as possible while following specific movement rules that dictate how far we can traverse the grid.</p>
<p>For each <code>queries[i]</code>, we begin at the top-left corner of the grid. We are allowed to move in four directions: up, down, left, and right. The primary condition governing movement is the comparison between <code>queries[i]</code> and the value of the current cell:</p>
<ol>
<li>
<p>If <code>queries[i]</code> is strictly greater than the value of the current cell, then:</p>
<ul>
<li>If this is the first time visiting the cell, we earn one point.</li>
<li>We can then move to any of the adjacent cells (if they exist).</li>
</ul>
</li>
<li>
<p>If <code>queries[i]</code> is less than or equal to the value of the current cell, then:</p>
<ul>
<li>We cannot proceed further from this cell.</li>
<li>The process for this query terminates immediately.</li>
</ul>
</li>
</ol>
<p>The final result for <code>queries[i]</code> is the number of unique cells we were able to collect points from.</p>
<blockquote>
<p>Note: Each query starts independently, meaning that the traversal for one query does not affect the traversal for another.</p>
</blockquote>
<p>Another difficult but extremely practical way to phrase this problem is to imagine you're at a buffet, where you can only eat dishes that are under a certain calorie count. Each dish represents a number in the grid, and your queries are your calorie limits. You want to know how many dishes you can indulge in without exceeding your limit. The algorithm helps you quickly determine how many dishes fit your criteria, allowing you to make the most of your buffet experience! Sometimes, the representation of data is more important than the data itself.</p>
<p>To solve this problem, we need a solid understanding of BFS, priority queues, and disjoint union. While we will explain the application of these concepts, we will not go in-depth into their theoretical aspects and their basic structure.</p>
<p>For a deeper understanding of the theory or to learn how the general conceptual implementation works, please check out the following explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS and Priority Queue</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union Find</a></li>
<li><a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a></li>
</ul>
<hr />
<h3 id="approach-1-brute-force-tle">Approach 1: Brute Force (TLE)</h3>
<h4 id="intuition">Intuition</h4>
<p>For each query value, we need to determine how many cells in the grid have a value strictly less than the query while ensuring we only move to adjacent cells. This naturally forms a graph traversal problem where each cell is treated as a node connected to its adjacent cells. Since we are interested in finding all reachable nodes that satisfy a condition, Breadth-First Search (BFS) is a suitable choice. BFS explores all nodes at the current level before moving to the next, ensuring we do not miss any reachable cells that meet the criteria.</p>
<p>For each query, we begin at the <code>(0,0)</code> cell and initialize a queue for BFS traversal. We also maintain a <code>visited</code> boolean matrix to ensure we do not revisit cells. The traversal continues as long as there are unprocessed cells in the queue. At each step, we check if the current cellâ€™s value is greater than or equal to the query value. If it is, we cannot proceed further from this cell. Otherwise, we count the cell as visited, increment our result, and attempt to move to its four adjacent cells (up, down, left, and right). Any adjacent cell that has not been visited and has a value strictly less than the query is added to the queue.</p>
<p>Since each query is independent, we repeat this process for each of them. The final result for each query is the total number of unique cells that we were able to visit while following the movement constraints.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Iterate over each query:</p>
<ul>
<li>
<p>Extract <code>queryValue</code> from <code>queries</code>.</p>
</li>
<li>
<p>Initialize a BFS queue starting from <code>(0,0)</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track visited cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Initialize <code>points</code> to count valid cells.</p>
</li>
<li>
<p>Perform BFS:</p>
<ul>
<li>Get the current queue size to process all elements at this level.</li>
<li>Iterate over the queue:
<ul>
<li>Extract <code>currentRow</code> and <code>currentCol</code> from the front.</li>
<li>If <code>grid[currentRow][currentCol] &gt;= queryValue</code>, skip processing.</li>
<li>Otherwise, increment <code>points</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds, not visited, and value is <code>&lt; queryValue</code>, mark <code>(newRow, newCol)</code> as visited and add it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Store <code>points</code> in <code>result</code> at the corresponding query index.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jtezm3QA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot m)\)</span></p>
<p>The outer loop runs <span class="math inline">\(k\)</span> times, once for each query. In each iteration, a BFS is performed on the grid. In the worst case, the BFS will visit every cell in the grid, which is <span class="math inline">\(n \cdot m\)</span> cells. Therefore, the time complexity for each query is <span class="math inline">\(O(n \cdot m)\)</span>, and for all queries, it becomes <span class="math inline">\(O(k \cdot n \cdot m)\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor, which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by the <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>. This matrix is used to keep track of visited cells during the BFS traversal.</p>
<p>The BFS queue can also hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case (e.g., when all cells are part of the BFS traversal). Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-queries--min-heap-expansion">Approach 2: Sorting Queries + Min-Heap Expansion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we restart the search from the top-left corner for every query, treating each query as an independent problem. This results in a significant amount of redundant work because many queries share overlapping information. If a smaller query has already determined that certain cells are accessible, then a larger query should be able to reuse that information instead of starting from scratch. This suggests that instead of treating each query separately, we can process them in an order that allows us to build on previously discovered results, avoiding unnecessary recomputation.</p>
<p>A natural way to achieve this is to <strong>sort the queries in increasing order</strong> while keeping track of their original indices. By doing this, we ensure that when we process a query, all smaller queries have already been resolved. This allows us to maintain a growing region of accessible cells rather than restarting the search for each query.</p>
<p>To efficiently manage this expanding region, we use a <strong>min-heap (priority queue)</strong>. The heap allows us to always expand from the lowest-value cell first, ensuring that we process cells in the correct order. We begin by inserting the top-left cell <code>(grid[0][0], (0,0))</code> into the heap.</p>
<p>As long as the smallest cell in the heap has a value less than the current query, we remove it from the heap, mark it as visited, and attempt to expand outward by pushing all its unvisited neighbors into the heap. Since the heap maintains the smallest-value cell at the top, this ensures that we always expand the lowest-value region before moving to higher values. If the smallest cell's value is greater than or equal to the current query's value, we store the current count of reachable cells in the answer array and continue expanding with the next query's value as the new threshold.</p>
<p>By the time we process a query, all the cells that could have been visited with smaller query values have already been handled. This allows us to directly store the number of reachable cells without restarting the traversal. Instead of performing redundant BFS searches for each query, we maintain a continuous expansion process, ensuring that each cell is processed only once.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Create a <code>sortedQueries</code> array to store queries along with their original indices.</p>
</li>
<li>
<p>Sort <code>sortedQueries</code> by query values in ascending order.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) to expand cells in increasing order of <code>grid</code> values.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track processed cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Push <code>{grid[0][0], {0, 0}}</code> into <code>minHeap</code> to start expansion.</p>
</li>
<li>
<p>Initialize <code>totalPoints</code> to count valid cells.</p>
</li>
<li>
<p>Iterate over sorted queries:</p>
<ul>
<li>Extract <code>queryValue</code> and <code>queryIndex</code>.</li>
<li>Expand cells while <code>minHeap</code> contains values <code>&lt; queryValue</code>:
<ul>
<li>Pop the smallest <code>cellValue</code> and its position.</li>
<li>Increment <code>totalPoints</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds and not visited, push <code>{grid[newRow][newCol], {newRow, newCol}}</code> into <code>minHeap</code> and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>totalPoints</code> in <code>result</code> at the corresponding query index.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3F8Ff5Ud/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span></p>
<p>The algorithm first sorts the <code>k</code> queries, which takes <span class="math inline">\(O(k \log k)\)</span> time. Then, for each query, it processes cells using a min-heap. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed and pushed into the heap. Each heap operation (push or pop) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, processing all cells takes <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m + k)\)</span></p>
<p>The space complexity is dominated by:</p>
<ol>
<li>The <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The min-heap, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case.</li>
<li>The <code>sortedQueries</code> vector, which stores <code>k</code> pairs of values and indices.</li>
</ol>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m + k)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-priority-queue-with-binary-search">Approach 3: Using Priority Queue with Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we processed queries sequentially and used a min-heap to expand the reachable region in increasing order, allowing us to efficiently determine the number of points collected for each query. In this approach, we will separate the precomputation step from the answer calculation to improve algorithmic clarity.</p>
<p>To implement this, we can preprocess the grid <strong>once</strong> and store the results in a structured way so that queries can be answered in constant or logarithmic time. The key insight is that every cell in the grid has a <strong>minimum value threshold</strong> that must be met in order for it to be reached. If we can determine the smallest query value required to reach each number of points, we can use <strong>binary search</strong> to efficiently answer all queries.</p>
<p>So we will begin by treating this as a shortest-path problem where we want to determine the minimum &quot;effort&quot; required to reach each cell. We can use <strong>Dijkstraâ€™s algorithm</strong> with a min-heap to explore the grid in order of increasing cost. Each cell <code>(i, j)</code> is processed in order of its minimum required value, and we update its neighbors with the maximum value seen along the way. This ensures that we always determine the optimal way to reach a cell.</p>
<p>Thus, our approach will be divided into three key steps:</p>
<ol>
<li>Reformulating the Problem as a Shortest-Path Search</li>
<li>Running Dijkstraâ€™s Algorithm</li>
<li>Answering Queries Using Binary Search</li>
</ol>
<h5 id="step-1-reformulating-the-problem-as-a-shortest-path-search"><strong>Step 1: Reformulating the Problem as a Shortest-Path Search</strong></h5>
<p>Instead of handling each query separately, we treat the grid as a <strong>weighted graph</strong> where each cell <code>(i, j)</code> has a weight equal to <code>grid[i][j]</code>. The goal is to expand outwards from <code>(0,0)</code>, adding cells in increasing order of their values. We need to determine <strong>the minimum effort required to reach each cell</strong>, which means that a Dijkstra-like algorithm is appropriate.</p>
<p>We use a min-heap (priority queue) to always expand the cell with the lowest current value. Each time we expand to a new cell, we record the maximum value encountered along that path. This ensures that we always determine the optimal way to reach a cell before processing its neighbors.</p>
<p>To keep track of how many points can be collected for any given query threshold, we maintain an array <code>thresholdForMaxPoints</code>, where <code>thresholdForMaxPoints[k]</code> stores the <strong>smallest query value</strong> required to collect <code>k</code> points.</p>
<h5 id="step-2-running-dijkstras-algorithm"><strong>Step 2: Running Dijkstraâ€™s Algorithm</strong></h5>
<p>We begin by initializing a min-heap with the starting cell <code>(0,0)</code>, assigning it a value equal to <code>grid[0][0]</code>. This heap will allow us to always expand towards the next reachable cell with the smallest value, ensuring that we process cells in the correct order.</p>
<p>As we expand outward, we repeatedly extract the smallest value from the heap, which represents the next cell to be processed. From there, we attempt to move to the neighboring cells, as long as they are not already visitedâ€” this guarantees that we always find the optimal path to reach it.</p>
<p>For each newly reached cell <code>(i, j)</code>, we compute the minimum threshold required to access it. This is determined by taking the maximum value encountered along the path leading to that cell. In other words, we track the largest value that must be surpassed in order to reach <code>(i, j)</code>.</p>
<p>As we continue expanding, we maintain an array <code>thresholdForMaxPoints</code>, where each entry records the smallest query value required to collect a given number of points. Each time we reach a new cell, we store its threshold in this array, associating it with the number of cells we have accessed so far.</p>
<p>By the end of this process, <code>thresholdForMaxPoints[k]</code> holds the <strong>minimum query value</strong> needed to collect exactly <code>k</code> points.</p>
<h5 id="step-3-answering-queries-using-binary-search"><strong>Step 3: Answering Queries Using Binary Search</strong></h5>
<p>Once we have preprocessed the grid, answering a query reduces to a simple binary search on <code>thresholdForMaxPoints</code>. Since we stored thresholds in increasing order, binary search allows us to determine in <strong>logarithmic time</strong> how many points can be collected for a given query.</p>
<p>For a query <code>threshold</code>, we search for the <strong>largest index <code>k</code></strong> such that <code>thresholdForMaxPoints[k] &lt; threshold</code>. The answer to the query is simply <code>k</code>, the number of points that can be collected.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2503/approach3.json:630,940!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define <code>DIRECTIONS</code> to facilitate movement in four directions.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Get <code>rowCount</code> and <code>colCount</code> from <code>grid</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Create <code>thresholdForMaxPoints</code>, where index <code>i</code> stores the minimum query value required to reach <code>i</code> cells.</p>
</li>
<li>
<p>Create <code>minValueToReach</code>, where <code>minValueToReach[i][j]</code> holds the maximum value encountered to reach <code>(i, j)</code>, initialized to <code>MAX_VALUE</code>.</p>
</li>
<li>
<p>Run Dijkstraâ€™s algorithm:</p>
<ul>
<li>Use <code>minHeap</code> (min-priority queue) to explore cells in increasing order of encountered values.</li>
<li>Start from <code>(0,0)</code>, setting <code>minValueToReach[0][0] = grid[0][0]</code> and pushing it into <code>minHeap</code>.</li>
<li>While <code>minHeap</code> is not empty:
<ul>
<li>Extract the cell with the smallest encountered value.</li>
<li>Store the encountered value in <code>thresholdForMaxPoints[++visitedCells]</code>.</li>
<li>Explore four possible directions:
<ul>
<li>If the adjacent cell <code>(newRow, newCol)</code> is within bounds and unvisited:
<ul>
<li>Update its <code>minValueToReach</code> as the maximum of the value to reach the current cell and  <code>grid[newRow][newCol]</code>.</li>
<li>Push it into <code>minHeap</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Process queries using binary search:</p>
<ul>
<li>For each <code>queries[i]</code>, find the rightmost <code>mid</code> where <code>thresholdForMaxPoints[mid] &lt; threshold</code>.</li>
<li>Initialize <code>left = 0</code>, <code>right = totalCells</code>.</li>
<li>Perform binary search:
<ul>
<li>Compute <code>mid = (left + right + 1) / 2</code>.</li>
<li>If <code>thresholdForMaxPoints[mid] &lt; threshold</code>, move <code>left = mid</code>.</li>
<li>Otherwise, adjust <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Store <code>left</code> in <code>result[i]</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YbXEgeXX/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span></p>
<p>The algorithm uses a min-heap to perform a modified Dijkstra's traversal. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed, and each heap operation (insertion or extraction) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>For each of the <code>k</code> queries, a binary search is performed on the <code>thresholdForMaxPoints</code> array, which has a size of <span class="math inline">\((n \cdot m) + 1\)</span>. Each binary search operation takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(k \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by:</p>
<ul>
<li>The <code>minHeap</code>, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells.</li>
<li>The <code>minValueToReach</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The <code>thresholdForMaxPoints</code> array, which is of size <span class="math inline">\((n \cdot m) + 1\)</span>.</li>
</ul>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of handling queries one by one, we can take a different approach where we process all grid cells first and answer queries afterward. This allows us to efficiently determine the number of reachable points for each query without having to traverse the grid multiple times.</p>
<p>To better understand this approach, let's reiterate our previous observation in a slightly different way. Think about what each query is asking. A query provides a threshold value and asks how many cells in the grid can be reached from the top-left corner <code>(0,0)</code>, while ensuring that all visited cells have values strictly less than this threshold. Instead of iterating over the grid every time a query is given, we can reverse the problem: first process the grid in increasing order of cell values, then efficiently answer all queries using this precomputed information.</p>
<p>To do this, we first extract all the grid cells and sort them in ascending order based on their values. By processing these cells in this order, we can simulate how the reachable area grows as the threshold increases. We maintain a <strong>disjoint set union (Union-Find) data structure</strong> to dynamically merge connected components as we encounter new cells with increasing values.</p>
<p>As we iterate through the sorted grid cells, we add each cell to our Union-Find structure. Whenever we add a cell, we also check its four adjacent neighbors (up, down, left, and right). If a neighbor has already been processed, we merge the current cell with its neighboring cell in the Union-Find structure. This ensures that, at any given moment, all connected components represent regions of the grid where all cells have values strictly less than the current threshold.</p>
<p>At the same time, we also sort the queries in ascending order based on their values. As we process each query, we continue adding cells to our Union-Find structure until the current cell values reach or exceed the query threshold. Once we finish adding all the relevant cells for a query, we determine how many of these cells are reachable from <code>(0,0)</code>. Since the Union-Find structure keeps track of the size of connected components, we can efficiently find the number of reachable cells by checking the size of the component that contains <code>(0,0)</code>.</p>
<p>If the query value is greater than <code>grid[0][0]</code>, then the number of reachable cells is simply the size of the connected component containing <code>(0,0)</code>. Otherwise, no additional cells are reachable, and the answer for this query is <code>0</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>Cell(row, col, value)</code> to represent grid cells and <code>Query(index, value)</code> to store queries with their original indices.</p>
</li>
<li>
<p>Initialize <code>ROW_DIRECTIONS</code> and <code>COL_DIRECTIONS</code> for moving in four directions.</p>
</li>
<li>
<p>Extract <code>rowCount</code> and <code>colCount</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Sort queries:</p>
<ul>
<li>Store each query as a <code>Query</code> object in <code>sortedQueries</code>.</li>
<li>Sort <code>sortedQueries</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Sort grid cells:</p>
<ul>
<li>Store each cell as a <code>Cell</code> object in <code>sortedCells</code>.</li>
<li>Sort <code>sortedCells</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Initialize <code>UnionFind</code> data structure for dynamic connectivity.</p>
</li>
<li>
<p>Process queries:</p>
<ul>
<li>Iterate over <code>sortedQueries</code>, maintaining an index <code>cellIndex</code> to track which cells have been processed.</li>
<li>While <code>sortedCells[cellIndex].value &lt; query.value</code>, mark the cell as processed and merge it with already processed adjacent cells using <code>UnionFind.union()</code>.</li>
<li>Compute the size of the connected component containing <code>(0,0)</code>, storing the result for <code>query.index</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h5 id="unionfind-class"><strong><code>UnionFind</code> Class:</strong></h5>
<ul>
<li>
<p>Define <code>UnionFind</code> class for disjoint set operations.</p>
</li>
<li>
<p>Declare <code>parent</code> array to track the representative of each set.</p>
</li>
<li>
<p>Declare <code>size</code> array to store the size of each set.</p>
</li>
<li>
<p>Constructor (<code>UnionFind(int n)</code>):</p>
<ul>
<li>Initialize <code>parent</code> with <code>-1</code>, indicating each element is its own set.</li>
<li>Initialize <code>size</code> to <code>1</code>, as each set initially has one element.</li>
</ul>
</li>
<li>
<p><code>find(int node)</code>: Implements path compression to optimize lookup.</p>
<ul>
<li>If <code>parent[node]</code> is <code>-1</code>, it is the root and returned.</li>
<li>Otherwise, recursively find the root and apply path compression (<code>parent[node] = find(parent[node])</code>).</li>
</ul>
</li>
<li>
<p><code>union(int nodeA, int nodeB)</code>:</p>
<ul>
<li>Find roots of <code>nodeA</code> and <code>nodeB</code>.</li>
<li>If both nodes share the same root, they are already in the same set, return <code>false</code>.</li>
<li>Otherwise, perform union by size:
<ul>
<li>Attach the smaller tree to the larger tree.</li>
<li>Update <code>size</code> accordingly.</li>
</ul>
</li>
<li>Return <code>true</code> to indicate a successful union.</li>
</ul>
</li>
<li>
<p><code>getSize(int node)</code>:</p>
<ul>
<li>Find the root of <code>node</code> and return the size of its set.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/8CUbzoZh/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span></p>
<p>The time complexity arises from several steps. First, sorting the <code>queries</code> array takes <span class="math inline">\(O(k \log k)\)</span>. Second, sorting the <code>sortedCells</code> array takes <span class="math inline">\(O((n \cdot m) \log (n \cdot m))\)</span>. Finally, processing each query involves iterating through the cells and performing union-find operations.</p>
<p>The union-find operations, with path compression and union by size, have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function (practically constant).</p>
<p>Since we process up to <code>totalCells</code> cells for each query, the total time for all queries is <span class="math inline">\(O(k \cdot \alpha(n \cdot m))\)</span>. Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((n \cdot m) + k)\)</span></p>
<p>The space complexity is dominated by the <code>sortedQueries</code> array, which takes <span class="math inline">\(O(k)\)</span> space, the <code>sortedCells</code> array, which takes <span class="math inline">\(O(n \cdot m)\)</span> space, and the <code>UnionFind</code> data structure, which uses <span class="math inline">\(O(n \cdot m)\)</span> space for the <code>parent</code> and <code>size</code> arrays. Therefore, the overall space complexity is <span class="math inline">\(O((n \cdot m) + k)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-points-with-cost/description" target="_blank" rel="noopener noreferrer">Maximum Number of Points with Cost</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>points</code> (<strong>0-indexed</strong>). Starting with <code>0</code> points, you want to <strong>maximize</strong> the number of points you can get from the matrix.</p>

<p>To gain points, you must pick one cell in <strong>each row</strong>. Picking the cell at coordinates <code>(r, c)</code> will <strong>add</strong> <code>points[r][c]</code> to your score.</p>

<p>However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows <code>r</code> and <code>r + 1</code> (where <code>0 &lt;= r &lt; m - 1</code>), picking cells at coordinates <code>(r, c<sub>1</sub>)</code> and <code>(r + 1, c<sub>2</sub>)</code> will <strong>subtract</strong> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> from your score.</p>

<p>Return <em>the <strong>maximum</strong> number of points you can achieve</em>.</p>

<p><code>abs(x)</code> is defined as:</p>

<ul>
	<li><code>x</code> for <code>x &gt;= 0</code>.</li>
	<li><code>-x</code> for <code>x &lt; 0</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong><strong> </strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> points = [[1,2,3],[1,5,1],[3,1,1]]
<strong>Output:</strong> 9
<strong>Explanation:</strong>
The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).
You add 3 + 5 + 3 = 11 to your score.
However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.
Your final score is 11 - 2 = 9.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png" style="width: 200px; height: 299px;" />
<pre>
<strong>Input:</strong> points = [[1,5],[2,3],[4,2]]
<strong>Output:</strong> 11
<strong>Explanation:</strong>
The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).
You add 5 + 3 + 4 = 12 to your score.
However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.
Your final score is 12 - 1 = 11.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == points.length</code></li>
	<li><code>n == points[r].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= points[r][c] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our goal with this problem is to determine the maximum number of points we can get by picking one cell from each row of a given matrix.  The possible score for each row consist of two components:</p>
<ol>
<li>The point value of the selected cell.</li>
<li>A penalty equal to the horizontal distance between the current cell and the selected cell in the previous row.</li>
</ol>
<p>The problem constraints hint that an efficient solution is needed. Specifically, since the problem is constrained by <span class="math inline">\(m \times n \leq 10 ^ 5\)</span>, we should aim for an <span class="math inline">\(O(m \times n)\)</span> solution.</p>
<p>In a brute-force approach, the idea would be to explore every possible combination of selecting one element from each row. Starting with the first row, we'd pick an element, then move to the next row and try every possible element there, repeating this process until we've chosen an element from each row. For each of these combinations, we would calculate the sum of the selected elements while also accounting for the cost incurred when switching columns between consecutive rows.</p>
<p>This approach involves using nested loops to compare every possible cell in each row, resulting in an exponential number of possibilities. As the number of rows and columns increases, the number of potential paths grows rapidly, making this method computationally infeasible for large grids. Instead, we need to optimize how we transition from one row to the next while keeping track of the maximum points we can accumulate.</p>
<p>Before attempting this problem, it may be helpful to solve related problems like &quot;<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">121. Best Time to Buy and Sell Stock</a>&quot; and &quot;<a href="https://leetcode.com/problems/best-sightseeing-pair/description/">1014. Best Sightseeing Pair</a>.&quot; These problems involve similar concepts of optimizing a series of decisions or transitions, which is a key aspect of solving the matrix points problem efficiently. Understanding the strategies used in those problems will build a foundation for approaching this one.</p>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Our goal is to create a solution that efficiently finds the maximum points possible while moving from the top row to the bottom row of the matrix. To do this, we initialize an array called <code>previousRow</code> with the values of the first row of the matrix. We can then operate off this array to build another array, <code>currentRow</code>. Each element in <code>currentRow</code> will represent the number of points we can gain by picking that cell, taking into account both the point value of the cell and the penalty for choosing it.</p>
<p>A straightforward approach to build <code>currentRow</code> would be to iterate over all cells in <code>previousRow</code> and apply the penalty for the horizontal distance:</p>
<pre><code>// For the Xth and (X+1)th rows of the points matrix
currentRow[i] = max(previousRow[j] - abs(j - i) for j in range(n)) + points[X+1][i]
</code></pre>
<p>Since this approach directly checks every cell in <code>previousRow</code> for each cell in <code>currentRow</code>, it involves repeated and redundant calculations and has a time complexity of <span class="math inline">\(O(n^2)\)</span> for each row, where <span class="math inline">\(n\)</span> is the number of columns. Given that we need to repeat this process for every row, this solution would not meet the problem's constraints, especially for large matrices.</p>
<p>Instead of recalculating the possible scores from every cell in <code>previousRow</code> for each cell in <code>currentRow</code>, we can use two auxiliary arrays, <code>leftMax</code> and <code>rightMax</code>, to store the maximum possible contributions from the left and right, respectively. This allows us to simply compare these two precomputed values to determine the best score for each cell in <code>currentRow</code>.</p>
<p>To construct <code>leftMax</code>:</p>
<ol>
<li>Set <code>leftMax[0]</code> equal to <code>previousRow[0]</code>, as there are no values to its left.</li>
<li>For each subsequent index <code>i</code>, compute <code>leftMax[i]</code> as the maximum of <code>previousRow[i]</code> and <code>leftMax[i-1] - 1</code>. The subtraction accounts for the penalty incurred when moving horizontally to the next cell.</li>
</ol>
<p>Have a look at this slideshow to better understand how each cell in <code>leftMax</code> is populated:</p>
<p>!?!../Documents/1937/slideshow.json:1482,762!?!</p>
<p>Similarly, construct <code>rightMax</code> by iterating from right to left.</p>
<p>With <code>leftMax</code> and <code>rightMax</code> prepared, we can compute the maximum points for each cell in <code>currentRow</code> using:</p>
<pre><code>currentRow[i] = max(leftMax[i], rightMax[i]) + points[X+1][i]
</code></pre>
<p>This allows us to efficiently calculate the maximum points for each row in <span class="math inline">\(O(n)\)</span> time, making the overall time complexity <span class="math inline">\(O(m \times n)\)</span>, where <span class="math inline">\(m\)</span> is the number of rows.</p>
<p>We apply this optimized process iteratively from the first row to the last row of the matrix. After processing all rows, the array <code>previousRow</code> will contain the maximum possible points for each cell in the last row. The final answer is the maximum value found in this array, which represents the highest score achievable while moving from the top to the bottom of the matrix.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in the input matrix <code>points</code>.</li>
<li>Create an array <code>previousRow</code>. Initialize it with values of the first row of the input matrix.</li>
<li>Iterate from the <code>0</code>th to <code>rows-2</code>th row. For each <code>row</code>:
<ul>
<li>Initialize arrays:
<ul>
<li><code>leftMax</code>: for maximum points achievable from left to right.</li>
<li><code>rightMax</code>: for maximum points achievable from right to left.</li>
<li><code>currentRow</code>: for the maximum points achievable for each cell in the current row.</li>
</ul>
</li>
<li>Set the first element of <code>leftMax</code> to the first element of <code>previousRow</code>.</li>
<li>Loop <code>col</code> from <code>1</code> to the end of <code>cols</code>:
<ul>
<li>Set <code>leftMax[col]</code> to the maximum of <code>leftMax[col - 1] - 1</code> and <code>previousRow[col]</code>.</li>
</ul>
</li>
<li>Set the last element of <code>rightMax</code> to the last element of <code>previousRow</code>.</li>
<li>Loop <code>col</code> from <code>cols - 2</code> to <code>0</code>:
<ul>
<li>Set <code>rightMax[col]</code> to the maximum of <code>rightMax[col + 1] - 1</code> and <code>previousRow[col]</code>.</li>
</ul>
</li>
<li>Loop <code>col</code> from <code>0</code> to the end of <code>cols</code>:
<ul>
<li>Calculate the maximum points for each cell in the current row:
<ol>
<li>Take the value from <code>points</code> for the next row (<code>points[row + 1][col]</code>).</li>
<li>Add the maximum of <code>leftMax[col]</code> and <code>rightMax[col]</code> to it.</li>
</ol>
</li>
<li>Set the calculated value to <code>currentRow[col]</code>.</li>
</ul>
</li>
<li>Update <code>previousRow</code> to be <code>currentRow</code>.</li>
</ul>
</li>
<li>Initialize a variable <code>maxPoints</code> to store the overall maximum points.</li>
<li>Loop through all values of <code>previousRow</code> and set <code>maxPoints</code> to the maximum.</li>
<li>Return <code>maxPoints</code> as our answer.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Pkt9v2VS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the height and width of <code>points</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The outer loop runs <span class="math inline">\(m-1\)</span> times. Inside it, two inner loops run <span class="math inline">\(n-1\)</span> times and another one runs <span class="math inline">\(n\)</span> times. Thus, the overall time complexity is <span class="math inline">\(O((m-1) \cdot (n-1 + n-1 + n))\)</span>, which simplifies to <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use four additional arrays, each of which takes <span class="math inline">\(n\)</span> space. All other variables take constant space.</p>
<p>Thus, the space complexity is <span class="math inline">\(O(4 \cdot n) = O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dynamic-programming-optimized">Approach 2: Dynamic Programming (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we used auxiliary arrays to keep track of the maximum points achievable from the left and right directions. This time, we streamline the process by using the <code>previousRow</code> array itself as temporary storage for the left-side maximums and then update it with the right-side maximums in a single pass.</p>
<p>Thus, we will require two passes to do this.</p>
<ol>
<li>First Pass: Left-to-Right Sweep<br />
We begin by iterating through the row from left to right. As we move, we store the maximum points achievable from the left in the <code>previousRow</code> array. This step essentially builds the equivalent of the <code>leftMax</code> array directly within <code>previousRow</code>.</li>
</ol>
<ul>
<li>At the start, <code>runningMax</code> is initialized to <code>0</code>. At the beginning of each iteration, <code>runningMax</code> will hold the maximum value that can be achieved from the left till <code>i-1</code>.</li>
<li>For each cell <code>i</code>, we update <code>runningMax</code> to the maximum of <code>previousRow[i]</code> and <code>runningMax - 1</code>, where the subtraction accounts for the horizontal distance penalty.</li>
</ul>
<p>This process ensures that <code>previousRow[i]</code> contains the maximum points that can be accumulated when moving from the left to the <code>i</code>th cell.</p>
<ol>
<li>Second Pass: Right-to-Left Sweep<br />
Next, we perform a second loop, this time iterating from right to left. This pass starts from the right and combines the results from the left-to-right pass with the maximum values from the right.</li>
</ol>
<ul>
<li>We reset <code>runningMax</code> to <code>0</code> before starting this pass. Similar to the left-to-right pass, we update <code>runningMax</code> for each column.</li>
<li>We take the maximum of the current <code>previousRow[col]</code> (which now contains the best value from the left) and the new <code>runningMax</code> (best value from the right).</li>
<li>We add <code>row[col]</code> to this maximum, incorporating the points from the current cell in the current row.</li>
</ul>
<p>After processing all rows, the array <code>previousRow</code> (which now holds the updated values) will contain the maximum points that can be accumulated for each cell in the last row of the matrix. The maximum value in this array is our final answer, representing the highest possible score from the top to the bottom of the matrix.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Set <code>cols</code> as the number of columns in <code>points</code>.</li>
<li>Create an array <code>previousRow</code> of size <code>cols</code>.</li>
<li>Iterate through each <code>row</code> in the <code>points</code> matrix:
<ul>
<li>Initialize a variable <code>runningMax</code> to <code>0</code>.</li>
<li>Iterate <code>col</code> from <code>0</code> to <code>cols-1</code>:
<ul>
<li>Update <code>runningMax</code> to the maximum of <code>runningMax - 1</code> and <code>previousRow[col]</code>.</li>
<li>Set <code>previousRow[col]</code> equal to <code>runningMax</code>.</li>
</ul>
</li>
<li>Now, iterate <code>col</code> in the reverse order:
<ul>
<li>Update <code>runningMax</code> to the maximum of <code>runningMax - 1</code> and <code>previousRow[col]</code>.</li>
<li>Update <code>previousRow[col]</code> by taking the maximum of its current value and <code>runningMax</code>, then add the current cell's value.</li>
</ul>
</li>
</ul>
</li>
<li>Loop through all values of <code>previousRow</code> and set <code>maxPoints</code> to the maximum.</li>
<li>Return <code>maxPoints</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/myUZqkTc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the height and width of <code>points</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The main loop iterates through each row of <code>points</code>. Inside this loop, the algorithm uses two nested loops, each iterating <span class="math inline">\(n\)</span> times. Overall, this takes <span class="math inline">\(O(m \cdot n)\)</span> time.</p>
<p>The final loop to find the maximum points also iterates <span class="math inline">\(n\)</span> times.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(m \cdot n) + O(n) = O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses an array <code>previousRow</code> of length <span class="math inline">\(n\)</span>. Thus, the space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/path-in-matrix3805/1" target="_blank" rel="noopener noreferrer">Maximum path sum in matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a matrix <code><strong>mat[][]</strong></code> of size <code><strong>n </strong>x&nbsp;<strong>m</strong></code> where each element is a positive integer. Starting from any cell in the first row, you are allowed to move to the next row, but with specific movement constraints. From any cell <code>(r, c)</code> in the current row, you can move to any of the three possible positions :</span></p>
<ol>
<li><span style="font-size: 14pt;"><code>(r+1, c-1)</code> &mdash; move diagonally to the left.</span></li>
<li><span style="font-size: 14pt;"><code>(r+1, c)</code> &mdash; move directly down.</span></li>
<li><span style="font-size: 14pt;"><code>(r+1, c+1)</code> &mdash; move diagonally to the right.</span></li>
</ol>
<p><span style="font-size: 14pt;">Find the maximum sum of any path starting from any column in the first row and ending at any column in the last row, following the above movement constraints.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> mat[][] = [[3, 6, 1], [2, 3, 4], [5, 5, 1]]
<strong>Output:</strong> 15
<strong>Explaination:</strong> The best path is (0, 1) -&gt; (1, 2) -&gt; (2, 1). It gives the maximum sum as 15.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> mat[][] = [[2, 1, 1], [1, 2, 2]]
<strong>Output:</strong> 4
<strong>Explaination:</strong> The best path is (0, 0) -&gt; (1, 1). It gives the maximum sum as 4.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> mat[][] = [[25]]
<strong>Output:</strong> 25
<strong>Explaination:</strong> (0, 0) is the only cell in mat[][], so maximum path sum will be 25.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 500<br />1 &le; mat[i].size() &le; 500<br />1 &le; mat[i][j] &le; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-points-tourist-can-earn/description" target="_blank" rel="noopener noreferrer">Maximum Points Tourist Can Earn</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers, <code>n</code> and <code>k</code>, along with two 2D integer arrays, <code>stayScore</code> and <code>travelScore</code>.</p>

<p>A tourist is visiting a country with <code>n</code> cities, where each city is <strong>directly</strong> connected to every other city. The tourist&#39;s journey consists of <strong>exactly</strong> <code>k</code> <strong>0-indexed</strong> days, and they can choose <strong>any</strong> city as their starting point.</p>

<p>Each day, the tourist has two choices:</p>

<ul>
	<li><strong>Stay in the current city</strong>: If the tourist stays in their current city <code>curr</code> during day <code>i</code>, they will earn <code>stayScore[i][curr]</code> points.</li>
	<li><strong>Move to another city</strong>: If the tourist moves from their current city <code>curr</code> to city <code>dest</code>, they will earn <code>travelScore[curr][dest]</code> points.</li>
</ul>

<p>Return the <strong>maximum</strong> possible points the tourist can earn.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, k = 1, stayScore = [[2,3]], travelScore = [[0,2],[1,0]]</span></p>

<p><strong>Output:</strong> 3</p>

<p><strong>Explanation:</strong></p>

<p>The tourist earns the maximum number of points by starting in city 1 and staying in that city.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, k = 2, stayScore = [[3,4,2],[2,1,2]], travelScore = [[0,2,1],[2,0,4],[3,2,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p>The tourist earns the maximum number of points by starting in city 1, staying in that city on day 0, and traveling to city 2 on day 1.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>1 &lt;= k &lt;= 200</code></li>
	<li><code>n == travelScore.length == travelScore[i].length == stayScore[i].length</code></li>
	<li><code>k == stayScore.length</code></li>
	<li><code>1 &lt;= stayScore[i][j] &lt;= 100</code></li>
	<li><code>0 &lt;= travelScore[i][j] &lt;= 100</code></li>
	<li><code>travelScore[i][i] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-rows-covered-by-columns/description" target="_blank" rel="noopener noreferrer">Maximum Rows Covered by Columns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>matrix</code> and an integer <code>numSelect</code>.</p>

<p>Your goal is to select exactly <code>numSelect</code> <strong>distinct </strong>columns from <code>matrix</code> such that you cover as many rows as possible.</p>

<p>A row is considered <strong>covered</strong> if all the <code>1</code>&#39;s in that row are also part of a column that you have selected. If a row does not have any <code>1</code>s, it is also considered covered.</p>

<p>More formally, let us consider <code>selected = {c<sub>1</sub>, c<sub>2</sub>, ...., c<sub>numSelect</sub>}</code> as the set of columns selected by you. A row <code>i</code> is <strong>covered</strong> by <code>selected</code> if:</p>

<ul>
	<li>For each cell where <code>matrix[i][j] == 1</code>, the column <code>j</code> is in <code>selected</code>.</li>
	<li>Or, no cell in row <code>i</code> has a value of <code>1</code>.</li>
</ul>

<p>Return the <strong>maximum</strong> number of rows that can be <strong>covered</strong> by a set of <code>numSelect</code> columns.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png" style="width: 240px; height: 400px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>One possible way to cover 3 rows is shown in the diagram above.<br />
We choose s = {0, 2}.<br />
- Row 0 is covered because it has no occurrences of 1.<br />
- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.<br />
- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.<br />
- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.<br />
Thus, we can cover three rows.<br />
Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png" style="height: 250px; width: 84px;" /></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">matrix = [[1],[0]], numSelect = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting the only column will result in both rows being covered since the entire matrix is selected.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>matrix[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= numSelect&nbsp;&lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-from-grid-operations/description" target="_blank" rel="noopener noreferrer">Maximum Score From Grid Operations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> of size <code>n x n</code>. Initially, all cells of the grid are colored white. In one operation, you can select any cell of indices <code>(i, j)</code>, and color black all the cells of the <code>j<sup>th</sup></code> column starting from the top row down to the <code>i<sup>th</sup></code> row.</p>

<p>The grid score is the sum of all <code>grid[i][j]</code> such that cell <code>(i, j)</code> is white and it has a horizontally adjacent black cell.</p>

<p>Return the <strong>maximum</strong> score that can be achieved after some number of operations.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,0,0,0,0],[0,0,3,0,0],[0,1,0,0,0],[5,0,0,3,0],[0,0,0,0,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">11</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/05/11/one.png" style="width: 300px; height: 200px;" />
<p>In the first operation, we color all cells in column 1 down to row 3, and in the second operation, we color all cells in column 4 down to the last row. The score of the resulting grid is <code>grid[3][0] + grid[1][2] + grid[3][3]</code> which is equal to 11.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[10,9,0,0,15],[7,1,0,8,0],[5,20,0,11,0],[0,0,0,1,2],[8,12,1,10,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">94</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/05/11/two-1.png" style="width: 300px; height: 200px;" />
<p>We perform operations on 1, 2, and 3 down to rows 1, 4, and 0, respectively. The score of the resulting grid is <code>grid[0][0] + grid[1][0] + grid[2][1] + grid[4][1] + grid[1][3] + grid[2][3] + grid[3][3] + grid[4][3] + grid[0][4]</code> which is equal to 94.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;=&nbsp;n == grid.length &lt;= 100</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/description" target="_blank" rel="noopener noreferrer">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>threshold</code>, return <em>the maximum side-length of a square with a sum less than or equal to </em><code>threshold</code><em> or return </em><code>0</code><em> if there is no such square</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/05/e1.png" style="width: 335px; height: 186px;" />
<pre>
<strong>Input:</strong> mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The maximum side length of square with sum less than 4 is 2 as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>0 &lt;= mat[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= threshold &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-spending-after-buying-items/description" target="_blank" rel="noopener noreferrer">Maximum Spending After Buying Items</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m * n</code> integer matrix <code>values</code>, representing the values of <code>m * n</code> different items in <code>m</code> different shops. Each shop has <code>n</code> items where the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> shop has a value of <code>values[i][j]</code>. Additionally, the items in the <code>i<sup>th</sup></code> shop are sorted in non-increasing order of value. That is, <code>values[i][j] &gt;= values[i][j + 1]</code> for all <code>0 &lt;= j &lt; n - 1</code>.</p>

<p>On each day, you would like to buy a single item from one of the shops. Specifically, On the <code>d<sup>th</sup></code> day you can:</p>

<ul>
	<li>Pick any shop <code>i</code>.</li>
	<li>Buy the rightmost available item <code>j</code> for the price of <code>values[i][j] * d</code>. That is, find the greatest index <code>j</code> such that item <code>j</code> was never bought before, and buy it for the price of <code>values[i][j] * d</code>.</li>
</ul>

<p><strong>Note</strong> that all items are pairwise different. For example, if you have bought item <code>0</code> from shop <code>1</code>, you can still buy item <code>0</code> from any other shop.</p>

<p>Return <em>the <strong>maximum amount of money that can be spent</strong> on buying all </em> <code>m * n</code> <em>products</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> values = [[8,5,2],[6,4,1],[9,7,3]]
<strong>Output:</strong> 285
<strong>Explanation:</strong> On the first day, we buy product 2 from shop 1 for a price of values[1][2] * 1 = 1.
On the second day, we buy product 2 from shop 0 for a price of values[0][2] * 2 = 4.
On the third day, we buy product 2 from shop 2 for a price of values[2][2] * 3 = 9.
On the fourth day, we buy product 1 from shop 1 for a price of values[1][1] * 4 = 16.
On the fifth day, we buy product 1 from shop 0 for a price of values[0][1] * 5 = 25.
On the sixth day, we buy product 0 from shop 1 for a price of values[1][0] * 6 = 36.
On the seventh day, we buy product 1 from shop 2 for a price of values[2][1] * 7 = 49.
On the eighth day, we buy product 0 from shop 0 for a price of values[0][0] * 8 = 64.
On the ninth day, we buy product 0 from shop 2 for a price of values[2][0] * 9 = 81.
Hence, our total spending is equal to 285.
It can be shown that 285 is the maximum amount of money that can be spent buying all m * n products. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> values = [[10,8,6,4,2],[9,7,5,3,2]]
<strong>Output:</strong> 386
<strong>Explanation:</strong> On the first day, we buy product 4 from shop 0 for a price of values[0][4] * 1 = 2.
On the second day, we buy product 4 from shop 1 for a price of values[1][4] * 2 = 4.
On the third day, we buy product 3 from shop 1 for a price of values[1][3] * 3 = 9.
On the fourth day, we buy product 3 from shop 0 for a price of values[0][3] * 4 = 16.
On the fifth day, we buy product 2 from shop 1 for a price of values[1][2] * 5 = 25.
On the sixth day, we buy product 2 from shop 0 for a price of values[0][2] * 6 = 36.
On the seventh day, we buy product 1 from shop 1 for a price of values[1][1] * 7 = 49.
On the eighth day, we buy product 1 from shop 0 for a price of values[0][1] * 8 = 64
On the ninth day, we buy product 0 from shop 1 for a price of values[1][0] * 9 = 81.
On the tenth day, we buy product 0 from shop 0 for a price of values[0][0] * 10 = 100.
Hence, our total spending is equal to 386.
It can be shown that 386 is the maximum amount of money that can be spent buying all m * n products.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == values.length &lt;= 10</code></li>
	<li><code>1 &lt;= n == values[i].length &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= values[i][j] &lt;= 10<sup>6</sup></code></li>
	<li><code>values[i]</code> are sorted in non-increasing order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Maximum Strictly Increasing Cells in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>1-indexed</strong>&nbsp;<code>m x n</code> integer matrix <code>mat</code>, you can select any cell in the matrix as your <strong>starting cell</strong>.</p>

<p>From the starting cell, you can move to any other cell <strong>in the</strong> <strong>same row or column</strong>, but only if the value of the destination cell is <strong>strictly greater</strong> than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p>

<p>Your task is to find the <strong>maximum number of cells</strong> that you can visit in the matrix by starting from some cell.</p>

<p>Return <em>an integer denoting the maximum number of cells that can be visited.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png" style="width: 200px; height: 176px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[1,1],[1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Since the cells must be strictly increasing, we can only visit one cell in this example. 
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><strong class="example"><img alt="" src="https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png" style="width: 350px; height: 250px;" /></strong></p>

<pre>
<strong>Input:</strong> mat = [[3,1,6],[-9,5,7]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. 
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length&nbsp;</code></li>
	<li><code>n == mat[i].length&nbsp;</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-students-taking-exam/description" target="_blank" rel="noopener noreferrer">Maximum Students Taking Exam</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>seats</code>&nbsp;&nbsp;that represent seats distributions&nbsp;in a classroom.&nbsp;If a seat&nbsp;is&nbsp;broken, it is denoted by <code>&#39;#&#39;</code> character otherwise it is denoted by a <code>&#39;.&#39;</code> character.</p>

<p>Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting&nbsp;directly in front or behind him. Return the <strong>maximum </strong>number of students that can take the exam together&nbsp;without any cheating being possible.</p>

<p>Students must be placed in seats in good condition.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img height="200" src="https://assets.leetcode.com/uploads/2020/01/29/image.png" width="339" />
<pre>
<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Teacher can place 4 students in available seats so they don&#39;t cheat on the exam. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> seats = [[&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;#&quot;,&quot;#&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;],
&nbsp;               [&quot;#&quot;,&quot;#&quot;],
&nbsp;               [&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Place all students in available seats. 

</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],
&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> 10
<strong>Explanation:</strong> Place students in available seats in column 1, 3 and 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>seats</code>&nbsp;contains only characters&nbsp;<code>&#39;.&#39;<font face="sans-serif, Arial, Verdana, Trebuchet MS">&nbsp;and</font></code><code>&#39;#&#39;.</code></li>
	<li><code>m ==&nbsp;seats.length</code></li>
	<li><code>n ==&nbsp;seats[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 8</code></li>
	<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-of-an-hourglass/description" target="_blank" rel="noopener noreferrer">Maximum Sum of an Hourglass</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>.</p>

<p>We define an <strong>hourglass</strong> as a part of the matrix with the following form:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/img.jpg" style="width: 243px; height: 243px;" />
<p>Return <em>the <strong>maximum</strong> sum of the elements of an hourglass</em>.</p>

<p><strong>Note</strong> that an hourglass cannot be rotated and must be entirely contained within the matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/1.jpg" style="width: 323px; height: 323px;" />
<pre>
<strong>Input:</strong> grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]
<strong>Output:</strong> 30
<strong>Explanation:</strong> The cells shown above represent the hourglass with the maximum sum: 6 + 2 + 1 + 2 + 9 + 2 + 8 = 30.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/08/21/2.jpg" style="width: 243px; height: 243px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> 35
<strong>Explanation:</strong> There is only one hourglass in the matrix, with the sum: 1 + 2 + 3 + 5 + 7 + 8 + 9 = 35.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>3 &lt;= m, n &lt;= 150</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-sum-of-hour-glass3842/1" target="_blank" rel="noopener noreferrer">Maximum sum of hour glass</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two integers <strong>n</strong>, <strong>m</strong> and a 2D matrix <strong>mat</strong> of dimensions <strong>nxm</strong>, the task is to find the <strong>maximum sum</strong> of an <strong>hourglass</strong>.<br />An <strong>hourglass</strong> is defined as a part of the matrix with the following form:</span></p>
<p><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/705187/Web/Other/blobid1_1710860182.png" width="209" height="213" /></span></p>
<p><span style="font-size: 18px;">Return <strong>-1</strong> if any hourglass is <strong>not found</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n = 3, m = 3
mat = [[1, 2, 3],<br />       [4, 5, 6],<br />       [7, 8, 9]]
<strong>Output:</strong>
35
<strong>Explanation:</strong>
There is only one hour glass which is
1 2 3
  5
7 8 9   and its sum is 35.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n = 2, m = 3
mat = [[1, 2, 3],<br />       [4, 5, 6]]
<strong>Output:</strong>
-1
<strong>Explanation:</strong>
There are no hour glasses in this matrix.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>findMaxSum()</strong> which takes the two integers <strong>n</strong>, <strong>m</strong>, and the 2D matrix <strong>mat</strong> as input parameters and returns the maximum sum of an hourglass in the matrix. If there are no hourglasses, it returns -1.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n*m)<br /><strong>Expected Auxillary Space: </strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= n &lt;= 150<strong><br /></strong></span><span style="font-size: 18px;">3 &lt;= m &lt;= 150<br />0 &lt;= mat[i][j] &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-sum-rectangle2948/1" target="_blank" rel="noopener noreferrer">Maximum sum Rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">kadane</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2D matrix <strong>mat[][]</strong> with dimensions n&times;m. Find the maximum possible <strong>sum</strong> of any <strong>submatrix </strong>within the given matrix.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]
<strong>Output: </strong>29
<strong>Explanation: </strong>The matrix is as follows and the green rectangle denotes the maximum sum rectangle which is equal to 29.
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/899247/Web/Other/blobid0_1751695089.jpg" width="364" height="225" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[-1, -2], [-3, -4]]
<strong>Output: </strong>-1
<strong>Explanation: </strong>Taking only the first cell is the optimal choice.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 300<br />-1000 &le; mat[i][j] &le; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-sum-with-at-most-k-elements/description" target="_blank" rel="noopener noreferrer">Maximum Sum With at Most K Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-pm-slice="1 3 []">You are given a 2D integer matrix <code>grid</code> of size <code>n x m</code>, an integer array <code>limits</code> of length <code>n</code>, and an integer <code>k</code>. The task is to find the <strong>maximum sum</strong> of <strong>at most</strong> <code>k</code> elements from the matrix <code>grid</code> such that:</p>

<ul data-spread="false">
	<li>
	<p>The number of elements taken from the <code>i<sup>th</sup></code> row of <code>grid</code> does not exceed <code>limits[i]</code>.</p>
	</li>
</ul>

<p data-pm-slice="1 1 []">Return the <strong>maximum sum</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2],[3,4]], limits = [1,2], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">7</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>From the second row, we can take at most 2 elements. The elements taken are 4 and 3.</li>
	<li>The maximum possible sum of at most 2 selected elements is <code>4 + 3 = 7</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[5,3,7],[8,2,6]], limits = [2,2], k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">21</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>From the first row, we can take at most 2 elements. The element taken is 7.</li>
	<li>From the second row, we can take at most 2 elements. The elements taken are 8 and 6.</li>
	<li>The maximum possible sum of at most 3 selected elements is <code>7 + 8 + 6 = 21</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == limits.length</code></li>
	<li><code>m == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 500</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= limits[i] &lt;= m</code></li>
	<li><code>0 &lt;= k &lt;= min(n * m, sum(limits))</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/description" target="_blank" rel="noopener noreferrer">Maximum Trailing Zeros in a Cornered Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>grid</code> of size <code>m x n</code>, where each cell contains a positive integer.</p>

<p>A <strong>cornered path</strong> is defined as a set of adjacent cells with <strong>at most</strong> one turn. More specifically, the path should exclusively move either <strong>horizontally</strong> or <strong>vertically</strong> up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the <strong>alternate</strong> direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.</p>

<p>The <strong>product</strong> of a path is defined as the product of all the values in the path.</p>

<p>Return <em>the <strong>maximum</strong> number of <strong>trailing zeros</strong> in the product of a cornered path found in </em><code>grid</code>.</p>

<p>Note:</p>

<ul>
	<li><strong>Horizontal</strong> movement means moving in either the left or right direction.</li>
	<li><strong>Vertical</strong> movement means moving in either the up or down direction.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg" style="width: 577px; height: 190px;" />
<pre>
<strong>Input:</strong> grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The grid on the left shows a valid cornered path.
It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.
It can be shown that this is the maximum trailing zeros in the product of a cornered path.

The grid in the middle is not a cornered path as it has more than one turn.
The grid on the right is not a cornered path as it requires a return to a previously visited cell.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg" style="width: 150px; height: 157px;" />
<pre>
<strong>Input:</strong> grid = [[4,3,2],[7,6,1],[8,8,8]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The grid is shown in the figure above.
There are no cornered paths in the grid that result in a product with a trailing zero.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-i/description" target="_blank" rel="noopener noreferrer">Maximum Value Sum by Placing Three Rooks I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> 2D array <code>board</code> representing a chessboard, where <code>board[i][j]</code> represents the <strong>value</strong> of the cell <code>(i, j)</code>.</p>

<p>Rooks in the <strong>same</strong> row or column <strong>attack</strong> each other. You need to place <em>three</em> rooks on the chessboard such that the rooks <strong>do not</strong> <strong>attack</strong> each other.</p>

<p>Return the <strong>maximum</strong> sum of the cell <strong>values</strong> on which the rooks are placed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = </span>[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]</p>

<p><strong>Output:</strong> 4</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/08/rooks2.png" style="width: 294px; height: 450px;" /></p>

<p>We can place the rooks in the cells <code>(0, 2)</code>, <code>(1, 3)</code>, and <code>(2, 1)</code> for a sum of <code>1 + 1 + 2 = 4</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[1,2,3],[4,5,6],[7,8,9]]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p>We can place the rooks in the cells <code>(0, 0)</code>, <code>(1, 1)</code>, and <code>(2, 2)</code> for a sum of <code>1 + 5 + 9 = 15</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[1,1,1],[1,1,1],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>We can place the rooks in the cells <code>(0, 2)</code>, <code>(1, 1)</code>, and <code>(2, 0)</code> for a sum of <code>1 + 1 + 1 = 3</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= m == board.length &lt;= 100</code></li>
	<li><code>3 &lt;= n == board[i].length &lt;= 100</code></li>
	<li><code>-10<sup>9</sup> &lt;= board[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-ii/description" target="_blank" rel="noopener noreferrer">Maximum Value Sum by Placing Three Rooks II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> 2D array <code>board</code> representing a chessboard, where <code>board[i][j]</code> represents the <strong>value</strong> of the cell <code>(i, j)</code>.</p>

<p>Rooks in the <strong>same</strong> row or column <strong>attack</strong> each other. You need to place <em>three</em> rooks on the chessboard such that the rooks <strong>do not</strong> <strong>attack</strong> each other.</p>

<p>Return the <strong>maximum</strong> sum of the cell <strong>values</strong> on which the rooks are placed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = </span>[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]</p>

<p><strong>Output:</strong> 4</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/08/rooks2.png" style="width: 294px; height: 450px;" /></p>

<p>We can place the rooks in the cells <code>(0, 2)</code>, <code>(1, 3)</code>, and <code>(2, 1)</code> for a sum of <code>1 + 1 + 2 = 4</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[1,2,3],[4,5,6],[7,8,9]]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p>We can place the rooks in the cells <code>(0, 0)</code>, <code>(1, 1)</code>, and <code>(2, 2)</code> for a sum of <code>1 + 5 + 9 = 15</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[1,1,1],[1,1,1],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>We can place the rooks in the cells <code>(0, 2)</code>, <code>(1, 1)</code>, and <code>(2, 0)</code> for a sum of <code>1 + 1 + 1 = 3</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= m == board.length &lt;= 500</code></li>
	<li><code>3 &lt;= n == board[i].length &lt;= 500</code></li>
	<li><code>-10<sup>9</sup> &lt;= board[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-increase-to-keep-city-skyline/description" target="_blank" rel="noopener noreferrer">Max Increase to Keep City Skyline</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a city composed of <code>n x n</code> blocks, where each block contains a single building shaped like a vertical square prism. You are given a <strong>0-indexed</strong> <code>n x n</code> integer matrix <code>grid</code> where <code>grid[r][c]</code> represents the <strong>height</strong> of the building located in the block at row <code>r</code> and column <code>c</code>.</p>

<p>A city&#39;s <strong>skyline</strong> is the&nbsp;outer contour formed by all the building when viewing the side of the city from a distance. The <strong>skyline</strong> from each cardinal direction north, east, south, and west may be different.</p>

<p>We are allowed to increase the height of <strong>any number of buildings by any amount</strong> (the amount can be different per building). The height of a <code>0</code>-height building can also be increased. However, increasing the height of a building should <strong>not</strong> affect the city&#39;s <strong>skyline</strong> from any cardinal direction.</p>

<p>Return <em>the <strong>maximum total sum</strong> that the height of the buildings can be increased by <strong>without</strong> changing the city&#39;s <strong>skyline</strong> from any cardinal direction</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png" style="width: 700px; height: 603px;" />
<pre>
<strong>Input:</strong> grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
<strong>Output:</strong> 35
<strong>Explanation:</strong> The building heights are shown in the center of the above image.
The skylines when viewed from each cardinal direction are drawn in red.
The grid after increasing the height of buildings without affecting skylines is:
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0],[0,0,0],[0,0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Increasing the height of any building will result in the skyline changing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[r].length</code></li>
	<li><code>2 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-row-and-column-maximums-accepted">Approach #1: Row and Column Maximums [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>The skyline looking from the top is <code>col_maxes = [max(column_0), max(column_1), ...]</code>.  Similarly, the skyline from the left is <code>row_maxes [max(row_0), max(row_1), ...]</code></p>
<p>In particular, each building <code>grid[r][c]</code> could become height <code>min(max(row_r), max(col_c))</code>, and this is the largest such height.  If it were larger, say <code>grid[r][c] &gt; max(row_r)</code>, then the part of the skyline <code>row_maxes = [..., max(row_r), ...]</code> would change.</p>
<p>These increases are also independent (none of them change the skyline), so we can perform them independently.</p>
<p><a href="https://leetcode.com/playground/TY4kLmTB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the number of rows (and columns) of the grid.  We iterate through every cell of the grid.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the space used by <code>row_maxes</code> and <code>col_maxes</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/max-rectangle/1" target="_blank" rel="noopener noreferrer">Max  rectangle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">stack</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix <strong>mat[][] </strong>of size <strong>n * m</strong>. Find the maximum area of a rectangle formed only of <strong>1s</strong> in the given matrix. </span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">mat[][] = [[0, 1, 1, 0],
                [1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, 1, 0, 0]]
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">8</span><strong style="font-size: 18px;">
Explanation: </strong><span style="font-size: 18px;">The largest rectangle with only 1&rsquo;s is from (1, 0) to (2, 3) which is
[1, 1, 1, 1]
[1, 1, 1, 1]
and area is 4 *2 = 8</span></span><span style="font-size: 18px;">.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat[][] = [[0, 1, 1],
                [1, 1, 1],
                [0, 1, 1]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The largest rectangle with only 1&rsquo;s is from (0, 1) to (2, 2) which is
[1, 1]
[1, 1]
[1, 1]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= mat.size(), mat[0].size()&lt;=1000<br />0&lt;=mat[][]&lt;=1<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description" target="_blank" rel="noopener noreferrer">Max Sum of Rectangle No Larger Than K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">ordered-set</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> matrix <code>matrix</code> and an integer <code>k</code>, return <em>the max sum of a rectangle in the matrix such that its sum is no larger than</em> <code>k</code>.</p>

<p>It is <strong>guaranteed</strong> that there will be a rectangle with a sum no larger than <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" style="width: 255px; height: 176px;" />
<pre>
<strong>Input:</strong> matrix = [[1,0,1],[0,-2,3]], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[2,2,-1]], k = 3
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> What if the number of rows is much larger than the number of columns?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/median-in-a-row-wise-sorted-matrix1527/1" target="_blank" rel="noopener noreferrer">Median in a row-wise sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>row-wise sorted</strong> matrix&nbsp;</span><strong style="font-size: 18.6667px;">mat[][]</strong><span style="font-size: 14pt;"> of size n*m, where the number of rows and columns is always </span><strong style="font-size: 14pt;">odd</strong><span style="font-size: 14pt;">.&nbsp;Return the <strong>median</strong> of the matrix.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 3, 5], <br />                [2, 6, 9], <br />                [3, 6, 9]]
<strong>Output:</strong>&nbsp;5
<strong>Explanation</strong>: Sorting matrix elements gives us [1, 2, 3, 3, 5, 6, 6, 9, 9]. Hence, 5 is median.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[2, 4, 9],
                [3, 6, 7],
                [4, 7, 10]]
<strong>Output: </strong>6
<strong>Explanation</strong>: Sorting matrix elements gives us [2, 3, 4, 4, 6, 7, 7, 9, 10]. Hence, 6 is median.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat = [[3], [4], [8]]
<strong>Output: </strong>4
<strong>Explanation</strong>: Sorting matrix elements gives us [3, 4, 8]. Hence, 4 is median.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le; 400<br />1 &le; mat[i][j] &le; 2000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minesweeper/description" target="_blank" rel="noopener noreferrer">Minesweeper</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Let&#39;s play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" target="_blank">Wikipedia</a>, <a href="http://minesweeperonline.com" target="_blank">online game</a>)!</p>

<p>You are given an <code>m x n</code> char matrix <code>board</code> representing the game board where:</p>

<ul>
	<li><code>&#39;M&#39;</code> represents an unrevealed mine,</li>
	<li><code>&#39;E&#39;</code> represents an unrevealed empty square,</li>
	<li><code>&#39;B&#39;</code> represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),</li>
	<li>digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) represents how many mines are adjacent to this revealed square, and</li>
	<li><code>&#39;X&#39;</code> represents a revealed mine.</li>
</ul>

<p>You are also given an integer array <code>click</code> where <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> represents the next click position among all the unrevealed squares (<code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>).</p>

<p>Return <em>the board after revealing this position according to the following rules</em>:</p>

<ol>
	<li>If a mine <code>&#39;M&#39;</code> is revealed, then the game is over. You should change it to <code>&#39;X&#39;</code>.</li>
	<li>If an empty square <code>&#39;E&#39;</code> with no adjacent mines is revealed, then change it to a revealed blank <code>&#39;B&#39;</code> and all of its adjacent unrevealed squares should be revealed recursively.</li>
	<li>If an empty square <code>&#39;E&#39;</code> with at least one adjacent mine is revealed, then change it to a digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) representing the number of adjacent mines.</li>
	<li>Return the board when no more squares will be revealed.</li>
</ol>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg" style="width: 500px; max-width: 400px; height: 269px;" />
<pre>
<strong>Input:</strong> board = [[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;M&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;]], click = [3,0]
<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg" style="width: 489px; max-width: 400px; height: 269px;" />
<pre>
<strong>Input:</strong> board = [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]], click = [1,2]
<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;X&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>board[i][j]</code> is either <code>&#39;M&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;B&#39;</code>, or a digit from <code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>.</li>
	<li><code>click.length == 2</code></li>
	<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>
	<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>
	<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> is either <code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/description" target="_blank" rel="noopener noreferrer">Minimize the Difference Between Target and Chosen Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>mat</code> and an integer <code>target</code>.</p>

<p>Choose one integer from <strong>each row</strong> in the matrix such that the <strong>absolute difference</strong> between <code>target</code> and the <strong>sum</strong> of the chosen elements is <strong>minimized</strong>.</p>

<p>Return <em>the <strong>minimum absolute difference</strong></em>.</p>

<p>The <strong>absolute difference</strong> between two numbers <code>a</code> and <code>b</code> is the absolute value of <code>a - b</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/matrix1.png" style="width: 181px; height: 181px;" />
<pre>
<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
<strong>Output:</strong> 0
<strong>Explanation:</strong> One possible choice is to:
- Choose 1 from the first row.
- Choose 5 from the second row.
- Choose 7 from the third row.
The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png" style="width: 61px; height: 181px;" />
<pre>
<strong>Input:</strong> mat = [[1],[2],[3]], target = 100
<strong>Output:</strong> 94
<strong>Explanation:</strong> The best possible choice is to:
- Choose 1 from the first row.
- Choose 2 from the second row.
- Choose 3 from the third row.
The sum of the chosen elements is 6, and the absolute difference is 94.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png" style="width: 301px; height: 61px;" />
<pre>
<strong>Input:</strong> mat = [[1,2,9,8,7]], target = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> The best choice is to choose 7 from the first row.
The absolute difference is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 70</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>
	<li><code>1 &lt;= target &lt;= 800</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-absolute-difference-in-sliding-submatrix/description" target="_blank" rel="noopener noreferrer">Minimum Absolute Difference in Sliding Submatrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an integer <code>k</code>.</p>

<p>For every contiguous <code>k x k</code> <strong>submatrix</strong> of <code>grid</code>, compute the <strong>minimum absolute</strong> difference between any two <strong>distinct</strong> values within that <strong>submatrix</strong>.</p>

<p>Return a 2D array <code>ans</code> of size <code>(m - k + 1) x (n - k + 1)</code>, where <code>ans[i][j]</code> is the minimum absolute difference in the submatrix whose top-left corner is <code>(i, j)</code> in <code>grid</code>.</p>

<p><strong>Note</strong>: If all elements in the submatrix have the same value, the answer will be 0.</p>
A submatrix <code>(x1, y1, x2, y2)</code> is a matrix that is formed by choosing all cells <code>matrix[x][y]</code> where <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,8],[3,-2]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[2]]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>There is only one possible <code>k x k</code> submatrix: <code><span class="example-io">[[1, 8], [3, -2]]</span></code><span class="example-io">.</span></li>
	<li>Distinct values in the submatrix are<span class="example-io"> <code>[1, 8, 3, -2]</code>.</span></li>
	<li>The minimum absolute difference in the submatrix is <code>|1 - 3| = 2</code>. Thus, the answer is <code>[[2]]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,-1]], k = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">[[0,0]]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>Both <code>k x k</code> submatrix has only one distinct element.</li>
	<li>Thus, the answer is <code>[[0, 0]]</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,-2,3],[2,3,5]], k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[1,2]]</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>There are two possible <code>k &times; k</code> submatrix:

	<ul>
		<li>Starting at <code>(0, 0)</code>: <code>[[1, -2], [2, 3]]</code>.

		<ul>
			<li>Distinct values in the submatrix are <code>[1, -2, 2, 3]</code>.</li>
			<li>The minimum absolute difference in the submatrix is <code>|1 - 2| = 1</code>.</li>
		</ul>
		</li>
		<li>Starting at <code>(0, 1)</code>: <code>[[-2, 3], [3, 5]]</code>.
		<ul>
			<li>Distinct values in the submatrix are <code>[-2, 3, 5]</code>.</li>
			<li>The minimum absolute difference in the submatrix is <code>|3 - 5| = 2</code>.</li>
		</ul>
		</li>
	</ul>
	</li>
	<li>Thus, the answer is <code>[[1, 2]]</code>.</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == grid.length &lt;= 30</code></li>
	<li><code>1 &lt;= n == grid[i].length &lt;= 30</code></li>
	<li><code>-10<sup>5</sup> &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= min(m, n)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-path-with-alternating-directions-ii/description" target="_blank" rel="noopener noreferrer">Minimum Cost Path with Alternating Directions II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>m</code> and <code>n</code> representing the number of rows and columns of a grid, respectively.</p>

<p>The cost to enter cell <code>(i, j)</code> is defined as <code>(i + 1) * (j + 1)</code>.</p>

<p>You are also given a 2D integer array <code>waitCost</code> where <code>waitCost[i][j]</code> defines the cost to <strong>wait</strong> on that cell.</p>

<p>The path will always begin by entering cell <code>(0, 0)</code> on move 1 and paying the entrance cost.</p>

<p>At each step, you follow an alternating pattern:</p>

<ul>
	<li>On <strong>odd-numbered</strong> seconds, you must move <strong>right</strong> or <strong>down</strong> to an <strong>adjacent</strong> cell, paying its entry cost.</li>
	<li>On <strong>even-numbered</strong> seconds, you must <strong>wait</strong> in place for <strong>exactly</strong> one second and pay <code>waitCost[i][j]</code> during that second.</li>
</ul>

<p>Return the <strong>minimum</strong> total cost required to reach <code>(m - 1, n - 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 1, n = 2, waitCost = [[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal path is:</p>

<ul>
	<li>Start at cell <code>(0, 0)</code> at second 1 with entry cost <code>(0 + 1) * (0 + 1) = 1</code>.</li>
	<li><strong>Second 1</strong>: Move right to cell <code>(0, 1)</code> with entry cost <code>(0 + 1) * (1 + 1) = 2</code>.</li>
</ul>

<p>Thus, the total cost is <code>1 + 2 = 3</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 2, n = 2, waitCost = [[3,5],[2,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal path is:</p>

<ul>
	<li>Start at cell <code>(0, 0)</code> at second 1 with entry cost <code>(0 + 1) * (0 + 1) = 1</code>.</li>
	<li><strong>Second 1</strong>: Move down to cell <code>(1, 0)</code> with entry cost <code>(1 + 1) * (0 + 1) = 2</code>.</li>
	<li><strong>Second 2</strong>: Wait at cell <code>(1, 0)</code>, paying <code>waitCost[1][0] = 2</code>.</li>
	<li><strong>Second 3</strong>: Move right to cell <code>(1, 1)</code> with entry cost <code>(1 + 1) * (1 + 1) = 4</code>.</li>
</ul>

<p>Thus, the total cost is <code>1 + 2 + 2 + 4 = 9</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">m = 2, n = 3, waitCost = [[6,1,4],[3,2,5]]</span></p>

<p><strong>Output:</strong> <span class="example-io">16</span></p>

<p><strong>Explanation:</strong></p>

<p>The optimal path is:</p>

<ul>
	<li>Start at cell <code>(0, 0)</code> at second 1 with entry cost <code>(0 + 1) * (0 + 1) = 1</code>.</li>
	<li><strong>Second 1</strong>: Move right to cell <code>(0, 1)</code> with entry cost <code>(0 + 1) * (1 + 1) = 2</code>.</li>
	<li><strong>Second 2</strong>: Wait at cell <code>(0, 1)</code>, paying <code>waitCost[0][1] = 1</code>.</li>
	<li><strong>Second 3</strong>: Move down to cell <code>(1, 1)</code> with entry cost <code>(1 + 1) * (1 + 1) = 4</code>.</li>
	<li><strong>Second 4</strong>: Wait at cell <code>(1, 1)</code>, paying <code>waitCost[1][1] = 2</code>.</li>
	<li><strong>Second 5</strong>: Move right to cell <code>(1, 2)</code> with entry cost <code>(1 + 1) * (2 + 1) = 6</code>.</li>
</ul>

<p>Thus, the total cost is <code>1 + 2 + 1 + 4 + 2 + 6 = 16</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>waitCost.length == m</code></li>
	<li><code>waitCost[0].length == n</code></li>
	<li><code>0 &lt;= waitCost[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Connect Two Groups of Points</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two groups of points where the first group has <code>size<sub>1</sub></code> points, the second group has <code>size<sub>2</sub></code> points, and <code>size<sub>1</sub> &gt;= size<sub>2</sub></code>.</p>

<p>The <code>cost</code> of the connection between any two points are given in an <code>size<sub>1</sub> x size<sub>2</sub></code> matrix where <code>cost[i][j]</code> is the cost of connecting point <code>i</code> of the first group and point <code>j</code> of the second group. The groups are connected if <strong>each point in both groups is connected to one or more points in the opposite group</strong>. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.</p>

<p>Return <em>the minimum cost it takes to connect the two groups</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg" style="width: 322px; height: 243px;" />
<pre>
<strong>Input:</strong> cost = [[15, 96], [36, 2]]
<strong>Output:</strong> 17
<strong>Explanation</strong>: The optimal way of connecting the groups is:
1--A
2--B
This results in a total cost of 17.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg" style="width: 322px; height: 403px;" />
<pre>
<strong>Input:</strong> cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
<strong>Output:</strong> 4
<strong>Explanation</strong>: The optimal way of connecting the groups is:
1--A
2--B
2--C
3--A
This results in a total cost of 4.
Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
<strong>Output:</strong> 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>size<sub>1</sub> == cost.length</code></li>
	<li><code>size<sub>2</sub> == cost[i].length</code></li>
	<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>
	<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>
	<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Cost to Make at Least One Valid Path in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>

<ul>
	<li><code>1</code> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>
	<li><code>2</code> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>
	<li><code>3</code> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>
	<li><code>4</code> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li>
</ul>

<p>Notice that there could be some signs on the cells of the grid that point outside the grid.</p>

<p>You will initially start at the upper left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path does not have to be the shortest.</p>

<p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>

<p>Return <em>the minimum cost to make the grid have at least one valid path</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" style="width: 400px; height: 390px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3)
The total cost = 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" style="width: 350px; height: 341px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You can follow the path from (0, 0) to (2, 2).
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" style="width: 200px; height: 192px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[4,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 4</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-dynamic-programming">Approach 1: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Letâ€™s consider a single cell (<code>row</code>, <code>col</code>) in the middle of the grid. To reach this cell, we can come from one of its four neighbors: above (<code>row - 1</code>, <code>col</code>), left (<code>row</code>, <code>col - 1</code>), below (<code>row + 1</code>, <code>col</code>), or right (<code>row</code>, <code>col + 1</code>). The cost to reach this cell depends on two factors: the cost of reaching one of its neighbors and the cost of moving from that neighbor to (<code>row</code>, <code>col</code>). This leads us to the conclusion that if we can compute the minimum cost to reach its neighbors, we can determine the minimum cost to reach the current cell as well.</p>
<p>This dependency on neighboring cells suggests a dynamic programming approach. Initially, it might seem logical to move right and down from the top-left corner towards the bottom-right corner, filling the grid as we go. However, this problem is more complex because paths arenâ€™t restricted to just right or down movements. In fact, a more cost-effective path might involve going left or up, depending on the direction changes needed.</p>
<p>To solve this, we create a grid <code>minChanges</code> to store the minimum cost to reach each cell. Initially, we set all cells to infinity except for the starting cell <code>(0, 0)</code>, which starts at 0 because thereâ€™s no cost to begin there.</p>
<p>To find the minimum cost path, we use a two-pass system that repeats until we can't find any better paths:</p>
<ol>
<li>
<p><strong>Forward Pass</strong>: Starting from the top-left corner, we move towards the bottom-right corner. For each cell, we check the cost of reaching it from its neighbors above or to the left. If the neighborâ€™s direction naturally points to the current cell, thereâ€™s no additional cost; otherwise, it costs 1 to change direction. Using this information, we update the minimum cost for the current cell.</p>
</li>
<li>
<p><strong>Backward Pass</strong>: Starting from the bottom-right corner, we move back towards the top-left corner. This pass considers neighbors below or to the right. Itâ€™s particularly useful for uncovering paths where a roundabout route (moving up or left) results in a lower cost than a direct one.</p>
</li>
</ol>
<p>After each pass, we check if any cellâ€™s minimum cost has changed. If not, it means weâ€™ve found the optimal solution. Since the cost of a cell can only decrease with each iteration and cannot drop below 0, this process is guaranteed to converge.</p>
<p>Finally, the value in the bottom-right cell of the <code>minChanges</code> grid represents the minimum cost to create a valid path from the top-left to the bottom-right corner.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input <code>grid</code>.</li>
<li>Create a 2-D array <code>minChanges</code> with dimensions <code>numRows * numCols</code> to track the minimum changes needed to reach each cell.</li>
<li>Initialize all cells in the <code>minChanges</code> array to the maximum possible integer value.</li>
<li>Set the value of <code>minChanges[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter an infinite loop that will continue until convergence is reached.
<ul>
<li>Create a 2-D array <code>prevState</code> to store the previous state of <code>minChanges</code> for comparison.</li>
<li>Copy the current state of <code>minChanges</code> into <code>prevState</code>.</li>
<li>Begin the forward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from above and left</li>
<li>Update the <code>minChanges</code> value based on:
<ul>
<li>Whether the neighbor naturally points to the current cell (cost is 0).</li>
<li>Or needs to be changed to point to the current cell (cost is 1).</li>
</ul>
</li>
</ul>
</li>
<li>Begin the backward pass through the grid:
<ul>
<li>For each cell, examine its neighbors from below and right</li>
<li>Apply the same cost calculation logic as in the forward pass.</li>
</ul>
</li>
<li>Compare prevState with the current <code>minChanges</code> array:
<ul>
<li>If they are identical, break the loop as convergence is reached.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minChanges[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cUHwszao/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O((n \cdot m)^2)\)</span></p>
<p>The algorithm has an outer loop that continues until convergence, where <span class="math inline">\(k\)</span> is the number of iterations needed. In each iteration, we perform a forward pass and a backward pass through the entire grid, each taking <span class="math inline">\(O(n \cdot m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot k)\)</span>.</p>
<p>The value of <span class="math inline">\(k\)</span> depends on the grid configuration and in the worst case could be proportional to <span class="math inline">\(n \cdot m\)</span>, making the worst-case time complexity <span class="math inline">\(O((n \cdot m)^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses two 2D arrays - <code>minChanges</code> and <code>prevState</code>, each of size <span class="math inline">\(n \times m\)</span>. No additional space scaling with input size is needed. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-dijkstras-algorithm">Approach 2: Dijkstra's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We start by thinking of the grid as a network of connected points (a graph). Each cell represents a point (node), and the cells are connected to their neighbors. These connections (edges) have specific costs:</p>
<ol>
<li>Cost is 0 if the sign in one cell points directly to its neighbor.</li>
<li>Cost is 1 in all other cases where we need to change the sign.</li>
</ol>
<p>This gives us a problem where we need to find the cheapest path through a directed graph, which is exactly what Dijkstra's algorithm is designed to handle.</p>
<p>With Dijkstraâ€™s algorithm, we use a priority queue to explore cells based on their current cost, ensuring that we always process the lowest-cost paths first. We also maintain a grid, <code>minCost</code>, where each cell tracks the cheapest way to reach that cell from the start. The queue holds cells we are currently exploring, each entry containing three pieces of information: the total cost so far, and the row and column indices of the cell. The queue is organized such that cells with the lower cost are processed first, which helps us prioritize more promising paths over more expensive ones.</p>
<p>For each cell we explore, we evaluate all its four neighboring cells. To do this, we calculate the cost to reach the neighbor by adding the current cost to the cost of moving to the neighbor (either 0 or 1, depending on the sign). If this new cost is lower than the current recorded cost in <code>minCost</code>, weâ€™ve found a better path to the neighbor, so we update the cost in <code>minCost</code> and add the neighbor to the queue for further exploration.</p>
<p>This process continues until all cells have been explored, and the queue is empty. At this point, the <code>minCost</code> grid holds the minimum cost required to reach each cell from the starting cell (top-left corner). Finally, the solution to the problem is simply the value stored in <code>minCost</code> at the bottom-right corner of the grid.</p>
<blockquote>
<p>For a more comprehensive understanding of Dijkstra's Algorithm, check out the <a href="https://leetcode.com/explore/featured/card/graph/622/single-source-shortest-path-algorithm/3862/">Dijkstra's Algorithm Explore Card ðŸ”—</a>. This resource provides an in-depth look at Dijkstra's Algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a 2-D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</p>
</li>
<li>
<p>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</p>
</li>
<li>
<p>Create a minimum priority queue <code>pq</code> ordered by cost, where each element is a triplet [cost, row, col].</p>
</li>
<li>
<p>Add the starting position <code>[0, 0, 0]</code> to the priority queue with initial cost <code>0</code>.</p>
</li>
<li>
<p>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</p>
</li>
<li>
<p>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</p>
</li>
<li>
<p>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</p>
</li>
<li>
<p>Enter a loop that continues while the priority queue is not empty:</p>
<ul>
<li>Extract the current cell with minimum cost from the priority queue.</li>
<li>If a better path to this cell has been found, skip processing this cell.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Check if the new position is within the grid boundaries.</li>
<li>Calculate the new cost:
<ul>
<li>Add <code>0</code> if the current cell naturally points in this direction.</li>
<li>Add <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new cost is less than the previously known cost for the new position:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>Add the new position to the priority queue with its cost.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8rasikDe/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span></p>
<p>The algorithm uses Dijkstra's algorithm with a priority queue. In the worst case, we might need to visit each cell multiple times until we find the optimal path, but no more than <span class="math inline">\(4\)</span> times per cell (once for each direction). For each cell, we perform a priority queue operation which takes <span class="math inline">\(O(\log(n \cdot m))\)</span> time, where <span class="math inline">\(n \cdot m\)</span> is the maximum size of the queue. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot m \cdot \log(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a priority queue that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-0-1-breadth-first-search">Approach 3: 0-1 Breadth-First Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Dijkstra's algorithm works well for finding the shortest path, but our problem has a unique feature: the path costs are either 0 or 1. This is key because any path with only 0-cost edges, no matter how long, will always be better than one that uses even a single 1-cost edge. Therefore, it makes sense to prioritize exploring 0-cost edges first. Only after all 0-cost edges have been explored, should we move on to the 1-cost edges. This insight leads us to a modification of the Breadth-First Search (BFS) algorithm, known as 0-1 BFS.</p>
<p>In 0-1 BFS, we adjust the traditional BFS by using a deque (double-ended queue) instead of a regular queue. The deque allows us to prioritize 0-cost edges more efficiently. Each element of the deque will store the row and column indices of a cell, and we will maintain a <code>minCost</code> grid to track the minimum cost to reach each cell.</p>
<p>As we visit each cell, we evaluate its four neighboring cells. If moving to a neighbor doesnâ€™t require a sign change (i.e., the move is a 0-cost move), we add that neighbor to the front of the deque because we want to explore it immediately. On the other hand, if a sign change is required (making it a 1-cost move), we add the neighbor to the back of the deque, ensuring it gets explored later, after all the 0-cost moves.</p>
<p>For each neighbor we explore, we calculate the cost to reach it and compare it to the current value in the <code>minCost</code> grid. If the calculated cost is lower, we update <code>minCost</code> with the new, cheaper value.</p>
<p>Once the BFS traversal completes and all cells have been processed, the minimum cost to reach the bottom-right corner will be stored in <code>minCost</code>. We return this value as the solution to the problem.</p>
<p>The below slideshow demonstrates the algorithm in action:</p>
<p>!?!../Documents/1368/slideshow.json:1080,1080!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>dirs</code> with four direction vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize variables <code>numRows</code> and <code>numCols</code> to store the number of rows and columns in the input grid.</li>
<li>Create a 2D array <code>minCost</code> with dimensions <code>numRows * numCols</code> to track the minimum cost to reach each cell.</li>
<li>Initialize all cells in the <code>minCost</code> array to the maximum possible integer value.</li>
<li>Create a double-ended queue <code>deque</code> for 0-1 BFS implementation.</li>
<li>Add the starting position <code>[0, 0]</code> to the front of the <code>deque</code>.</li>
<li>Set the value of <code>minCost[0][0]</code> to <code>0</code> since it's the starting position.</li>
<li>Enter a loop that continues while the <code>deque</code> is not empty:
<ul>
<li>Extract the current cell from the front of the <code>deque</code>.</li>
<li>For each of the four possible directions:
<ul>
<li>Calculate the new position by adding direction vectors.</li>
<li>Calculate the <code>cost</code>:
<ul>
<li>Set <code>cost</code> to <code>0</code> if the current cell naturally points in this direction.</li>
<li>Set <code>cost</code> to <code>1</code> if we need to change the direction.</li>
</ul>
</li>
<li>If the new position is valid and the new path is cheaper:
<ul>
<li>Update the <code>minCost</code> for the new position.</li>
<li>If the <code>cost</code> is 1:
<ul>
<li>Add the new position to the back of the <code>deque</code>.</li>
</ul>
</li>
<li>If the <code>cost</code> is 0:
<ul>
<li>Add the new position to the front of the <code>deque</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minCost[numRows-1][numCols-1]</code>, which represents the minimum cost to reach the target cell.</li>
</ul>
<p>Helper method <code>isValid(row, col, numRows, numCols)</code>:</p>
<ul>
<li>Check if the given position is:
<ul>
<li>Within the grid's row boundaries.</li>
<li>Within the grid's column boundaries.</li>
</ul>
</li>
<li>Return <code>true</code> if all conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/NWGViPMb/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses 0-1 BFS approach where each cell is visited at most once for each edge weight (0 or 1). Since we process zero-weight edges before one-weight edges (by adding to the front of the deque), each cell gets its final shortest distance when it's first processed. No cell is processed more than once with the same cost. Therefore, the time complexity is linear with respect to the number of cells, giving us <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a deque that in the worst case might contain all cells of the grid, taking <span class="math inline">\(O(n \cdot m)\)</span> space. We also maintain the <code>minCost</code> array of size <span class="math inline">\(n \times m\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-depth-first-search--breadth-first-search">Approach 4: Depth-First Search + Breadth-First Search</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Let us extend the idea of exploring all 0-weight edges. Since some paths cost 0 to traverse, we could technically explore a sizable portion of the grid without incurring any cost at all. Now, if we are allowed a cost of 1, we could expand from the parts of the grid already explored and cover an even larger area. Like this, if we gradually increase the cost that we allow for exploration, there will be a cost value where the entire grid (along with the target cell), will be explored.</p>
<p>The primary difference between this approach and all the other ones is that previously we started with exploring the grid and populated the cost along the way. But here, we fix the cost and figure out how much we can explore adhering to it.</p>
<p>We'll use a combination of Breadth-First Search (BFS) and Depth-First Search (DFS) to implement our idea. Imagine our exploration as having levels; cells reachable with cost 0 being one level, cells with cost 1 as another, and so on. We'll use DFS to explore all cells at a given level (cost) and we'll use BFS to guide the exploration level by level until all the cells have been explored.</p>
<p>Let's break down how this works:</p>
<p>Starting at (0,0), we use DFS to follow the arrows without any modifications. If a cell points right and we follow it right, that's free! We keep following these zero-cost paths until we can't go further. Think of this as drawing a continuous line through cells, following arrows until we have to lift our pencil.</p>
<p>Every time we reach a cell through DFS, we also add it to a queue. These cells will serve as the starting points for the next level of exploration.</p>
<p>After we've explored all zero-cost paths, we switch to BFS. We take a cell from the queue, and make a modification to the direction, thereby increasing the cost by 1. With the new direction of the current cell, new cells in the grid are now reachable, and we explore all cells using DFS like before. As we explore the grid using DFS, we maintain a grid <code>minCost</code> which stores the cost at which we first visited that cell.</p>
<p>We continue this process of modification for all direction values for each cell at the current level. After the current level is explored, we increase the cost by 1 again and start modifying the direction of cells in the queue to explore further.</p>
<p>As usual, when all the cells in the grid have been explored, we'll return the bottom-right corner of the <code>minCost</code> array as our answer.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize a directions array <code>dirs</code> with four vectors representing right, left, down, and up movements.</li>
</ul>
<p>Main method <code>minCost</code>:</p>
<ul>
<li>Initialize the variables for <code>numRows</code>, <code>numCols</code>, and the initial <code>cost</code> (set to 0).</li>
<li>Create a 2D array <code>minCost</code> to track the minimum cost to reach each cell.</li>
<li>Fill the <code>minCost</code> array with maximum integer values to mark cells as unvisited.</li>
<li>Create a <code>queue</code> to store cells that need cost increments for the BFS part.</li>
<li>Call <code>dfs</code> from the origin <code>(0,0)</code> with the initial cost of 0.</li>
<li>In the BFS part, while the <code>queue</code> is not empty:
<ul>
<li>Increment the <code>cost</code> by 1.</li>
<li>Store the current level size.</li>
<li>Process all cells at the current level:
<ul>
<li>Poll a cell from the <code>queue</code>.</li>
<li>For each of the four directions:
<ul>
<li>Call <code>dfs</code> from the new position with the current <code>cost</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Finally, return the minimum cost to reach the bottom-right cell of the grid (<code>minCost[numRows - 1][numCols - 1]</code>).</li>
</ul>
<p>Helper method <code>dfs(grid, row, col, minCost, cost, queue)</code>:</p>
<ul>
<li>Check if the current cell is valid and unvisited using the <code>isUnvisited</code> function.</li>
<li>If not valid or already visited, return.</li>
<li>Set the current cell's cost in the <code>minCost</code> array.</li>
<li>Add the current cell to the <code>queue</code>.</li>
<li>Calculate the next direction based on the <code>grid</code> value (subtracting 1 for 0-based indexing).</li>
<li>Recursively call <code>dfs</code> in the direction pointed by the arrow without increasing the cost.</li>
</ul>
<p>Helper method <code>isUnvisited(minCost, row, col)</code>:</p>
<ul>
<li>Check if the row and column are within the grid bounds.</li>
<li>Check if the cell has not been visited (still has maximum value).</li>
<li>Return <code>true</code> only if both conditions are met, <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ti9zFAP6/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and <span class="math inline">\(m\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses a hybrid DFS-BFS approach. In the DFS part, each cell is visited at most once when following zero-cost paths (following arrows). In the BFS part, each cell might be added to the queue once for exploration in different directions, but again, each cell is processed at most once since we only visit unvisited cells. Since each cell can only be visited once in both phases, and for each cell, we perform constant time operations, the total time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The algorithm uses multiple data structures that each can grow up to <span class="math inline">\(O(n \cdot m)\)</span>: the <code>minCost</code> array to track visited cells, the <code>queue</code> for BFS that in the worst case might contain all cells, and the recursive call stack for DFS that in worst case might go through all cells in a snake-like pattern. Thus, the total space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-falling-path-sum/description" target="_blank" rel="noopener noreferrer">Minimum Falling Path Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> array of integers <code>matrix</code>, return <em>the <strong>minimum sum</strong> of any <strong>falling path</strong> through</em> <code>matrix</code>.</p>

<p>A <strong>falling path</strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <code>(row, col)</code> will be <code>(row + 1, col - 1)</code>, <code>(row + 1, col)</code>, or <code>(row + 1, col + 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg" style="width: 499px; height: 500px;" />
<pre>
<strong>Input:</strong> matrix = [[2,1,3],[6,5,4],[7,8,9]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> There are two falling paths with a minimum sum as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg" style="width: 164px; height: 365px;" />
<pre>
<strong>Input:</strong> matrix = [[-19,57],[-40,-5]]
<strong>Output:</strong> -59
<strong>Explanation:</strong> The falling path with a minimum sum is shown.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-falling-path-sum-ii/description" target="_blank" rel="noopener noreferrer">Minimum Falling Path Sum II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> integer matrix <code>grid</code>, return <em>the minimum sum of a <strong>falling path with non-zero shifts</strong></em>.</p>

<p>A <strong>falling path with non-zero shifts</strong> is a choice of exactly one element from each row of <code>grid</code> such that no two elements chosen in adjacent rows are in the same column.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> 
The possible falling paths are:
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
The falling path with the smallest sum is&nbsp;[1,5,7], so the answer is&nbsp;13.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[7]]
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an <code>n x n</code> integer matrix <code>grid</code>, we have to find the minimum sum of a <strong>falling path with non-zero shifts</strong>.</p>
<blockquote>
<p>A <strong>falling path with non-zero shifts</strong> is a choice of exactly one element from each row of the <code>grid</code> such that no two elements chosen in adjacent rows are in the same column.</p>
</blockquote>
<p>When choosing elements for the <strong>falling path with non-zero shifts</strong>, we must meet the following conditions:</p>
<ul>
<li>Choose one element from each row</li>
<li>No two elements chosen in adjacent rows should be in the same column</li>
</ul>
<p>In other words, if <code>grid[row][col]</code> is chosen, then <code>grid[row + 1][col]</code> and <code>grid[row - 1][col]</code> cannot be chosen.</p>
<p>The editorial systematically solves the problem by developing an approach and refining it.</p>
<hr />
<h3 id="approach-1-top-down-dynamic-programming">Approach 1: Top-Down Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>Let's try solving the problem in a brute-force manner. It is a straightforward way to solve problems.</p>
<blockquote>
<p>Though the brute force approach is considered to be the most naÃ¯ve approach, it is a good starting point to understand the problem.</p>
<p>Brute force is exhaustive, and often not efficient. However, it gives a deeper understanding of the basis of the problem, which can further help to shape a better-optimized solution.</p>
</blockquote>
<p>We can try all possible combinations of elements from each row and find the minimum sum.</p>
<p>Let's select the element from every row, starting from the first row.</p>
<ul>
<li>
<p>We can select any element from the first row. There are <code>n</code> such possibilities. We don't know which element will lead to the minimum sum. Hence, we try all of them.</p>
<blockquote>
<p><strong>Word of Caution:</strong> The very assumption that we should start with the minimum element in the first row is wrong.</p>
<p><img src="../Figures/1289/1289_slide_images_used/Slide2_1.PNG" alt="image" /></p>
<p>If we choose <code>50</code> in the first row, then in the second row we only have the possibility of selecting <code>100</code>. Thus, we will end up with <code>151</code>.<br />
However, selecting <code>100</code> in the first row will permit us to choose <code>1</code> in the second row. Thus, we will end up with <code>102</code>, which is the optimal minimum sum.</p>
</blockquote>
</li>
<li>
<p>After selecting an element from the first row, we have to select an element from the second row. We can select any element from the second row, except the element in the same column as the element selected from the first row. There are <code>n - 1</code> such possibilities. We don't know which element will lead to the minimum sum. Hence, we try all of them.</p>
</li>
<li>
<p>After selecting an element from the second row, we have to select an element from the third row. We can select any element from the third row, except the element in the same column as the element selected from the second row. There are <code>n - 1</code> such possibilities. We don't know which element will lead to the minimum sum. Hence, we try all of them.</p>
</li>
<li>
<p>We will do this until we reach the last row. After selecting an element from the last row, we will have a path. The minimum sum of all these paths will be the answer.</p>
</li>
</ul>
<p>To formulate this, let's define a function <code>optimal(row, col)</code> which returns the minimum sum of a falling path with non-zero shifts, starting from row <code>row</code> and column <code>col</code>.</p>
<ul>
<li>
<p>If <code>row == n - 1</code>, then it means that we have reached the last row. Thus, the only path from this point is the value of the cell itself. Thus, we return <code>grid[row][col]</code>.</p>
</li>
<li>
<p>Otherwise, we have to select <code>grid[row][col]</code>. Now from this point, we have <code>n - 1</code> choices for selecting an element from the next row.</p>
<p>We will choose from the next row the cell which leads to the minimum sum.</p>
<p>Which function returns the minimum sum of a falling path with non-zero shifts, starting from a given row and column?<br />
Our very own <code>optimal</code> function.</p>
<blockquote>
<p>The paradigm of solving a problem using a function that solves the same problem is called <strong>recursion</strong>.</p>
<p>For solving <code>optimal</code> in a particular row <code>row</code>, we are calling <code>optimal</code> in the next row <code>row + 1</code>. Thus, <code>optimal</code> is calling itself. This is called <strong>recursion</strong>.</p>
<p>We are sure that <code>optimal</code> will terminate because there exists a row whose next row is not present.</p>
</blockquote>
<p>Thus, <code>optimal(row, col)</code> will return <code>grid[row][col] + min(optimal(row + 1, next_row_col))</code> where <code>0 &lt;= next_row_col &lt; n</code> and <code>next_row_col != col</code>.</p>
</li>
</ul>
<p>Thus, using these observations, we can formulate the recursive solution. We are trying all the possible combinations by performing a depth-first search on the <code>grid</code>.</p>
<blockquote>
<p>The <strong>depth-first search</strong> is a systematic way of exploring all the possible combinations of a problem. It is called <strong>depth-first</strong> because we are exploring the depth of the problem first, and then moving to the next branch.</p>
<p>It is an exhaustive search process wherein we will traverse all the cells in a path. On reaching the end of the path, we must undo our last step in the current path and try a different possible next step to extend the path.</p>
</blockquote>
<p>It's worth noting that we need to call <code>optimal</code> from every element of the first row because any element can be the starting point of the falling path. We will return the minimum sum of all these calls.</p>
<pre><code class="language-Algorithm">1. Save the size of the square `grid` in a variable `n`.

2. Define a recursive function `optimal`. It takes the row number `row` 
   and column number `col` as input of the cell from which we have to
   start the falling path. It returns the minimum sum of a falling path 
   with non-zero shifts, starting from cell `grid[row][col]`.

    Apart from `row` and `col`, make sure to pass the necessary 
    parameters that need to be accessed in the function.

    a. If `row == n - 1`, then there is no row left to select. 
       Thus, we return `grid[row][col]`.

    b. Otherwise, initialize a variable `next_minimum` with `INT_MAX`. 
       This variable will store the minimum sum of a falling path with 
       non-zero shifts, starting from the next row. 

    c. From this cell, we have `n - 1` possibilities of selecting an 
       element from the next row. 

       Thus traverse linearly in the `row + 1` using the variable 
       `next_row_col`. If `next_row_col != col`, then we can select 
       `grid[row + 1][next_row_col]`. 
        
        We need to select `next_row_col` for which `next_minimum` is the 
        minimum. Thus, `next_minimum` will be 
        `min(optimal(row + 1, next_row_col))` where 
        `0 &lt;= next_row_col &lt; n` and `next_row_col != col`.
    
    d. From this cell, the minimum sum of a falling path with non-zero 
       shifts is `grid[row][col] + next_minimum`. Return this value.

3. We can select any element from the first row. We will select the 
   element which leads to the minimum sum. Thus, initialize a variable 
   `answer` with `INT_MAX`.

    Traverse linearly in the first row using variable `col`. For every 
    cell, call `optimal(0, col)`. Variable `answer` will be 
    `min(optimal(0, col))` where `0 &lt;= col &lt; n`.

4. Return `answer`.
</code></pre>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">minFallingPathSum</span>(<span style="color:#999">self</span>, grid: List[List[<span style="color:#0086b3">int</span>]]) <span style="color:#000;font-weight:bold">-&gt;</span> <span style="color:#0086b3">int</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># Save the size of the square grid</span>
</span></span><span style="display:flex;"><span>        n <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(grid)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># The optimal(row, col) function returns the minimum sum of a </span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># falling path with non-zero shifts, starting from grid[row][col]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">optimal</span>(row, col):
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic"># If the last row, then return the value of the cell itself</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> row <span style="color:#000;font-weight:bold">==</span> n <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">return</span> grid[row][col]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic"># Select grid[row][col], and move on to next row. For next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic"># row, choose the cell that leads to the minimum sum</span>
</span></span><span style="display:flex;"><span>            next_minimum <span style="color:#000;font-weight:bold">=</span> inf
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">for</span> next_row_col <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(n):
</span></span><span style="display:flex;"><span>                <span style="color:#000;font-weight:bold">if</span> next_row_col <span style="color:#000;font-weight:bold">!=</span> col:
</span></span><span style="display:flex;"><span>                    next_minimum <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">min</span>(next_minimum, optimal(row <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, next_row_col))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#998;font-style:italic"># Minimum cost from this cell</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> grid[row][col] <span style="color:#000;font-weight:bold">+</span> next_minimum
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># We can select any element from the first row. We will select</span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># the element which leads to minimum sum.</span>
</span></span><span style="display:flex;"><span>        answer <span style="color:#000;font-weight:bold">=</span> inf
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> col <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(n):
</span></span><span style="display:flex;"><span>            answer <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">min</span>(answer, optimal(<span style="color:#099">0</span>, col))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic"># Return the minimum sum</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> answer
</span></span></code></pre><pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">minFallingPathSum</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[][]</span> grid<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// We can select any element from the first row. We will select
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// the element which leads to minimum sum.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span> answer <span style="color:#000;font-weight:bold">=</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">MAX_VALUE</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> col <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> col <span style="color:#000;font-weight:bold">&lt;</span> grid<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> col<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            answer <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>answer<span style="color:#000;font-weight:bold">,</span> optimal<span style="color:#000;font-weight:bold">(</span>0<span style="color:#000;font-weight:bold">,</span> col<span style="color:#000;font-weight:bold">,</span> grid<span style="color:#000;font-weight:bold">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Return the minimum sum
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">return</span> answer<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// The optimal(row, col) function returns the minimum sum of a
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// falling path with non-zero shifts, starting from grid[row][col]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">optimal</span><span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> row<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span> col<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[][]</span> grid<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If the last row, then return the value of the cell itself
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>row <span style="color:#000;font-weight:bold">==</span> grid<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span> <span style="color:#000;font-weight:bold">-</span> 1<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> grid<span style="color:#000;font-weight:bold">[</span>row<span style="color:#000;font-weight:bold">][</span>col<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Select grid[row][col], and move on to next row. For next
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// row, choose the cell that leads to the minimum sum
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span> nextMinimum <span style="color:#000;font-weight:bold">=</span> Integer<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">MAX_VALUE</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> nextRowCol <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span> nextRowCol <span style="color:#000;font-weight:bold">&lt;</span> grid<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">;</span> nextRowCol<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>nextRowCol <span style="color:#000;font-weight:bold">!=</span> col<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                nextMinimum <span style="color:#000;font-weight:bold">=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>nextMinimum<span style="color:#000;font-weight:bold">,</span> optimal<span style="color:#000;font-weight:bold">(</span>row <span style="color:#000;font-weight:bold">+</span> 1<span style="color:#000;font-weight:bold">,</span> nextRowCol<span style="color:#000;font-weight:bold">,</span> grid<span style="color:#000;font-weight:bold">));</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Minimum cost from this cell
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">return</span> grid<span style="color:#000;font-weight:bold">[</span>row<span style="color:#000;font-weight:bold">][</span>col<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">+</span> nextMinimum<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> minFallingPathSum(vector<span style="color:#000;font-weight:bold">&lt;</span>vector<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// We can select any element from the first row. We will select
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// the element which leads to minimum sum.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span> answer <span style="color:#000;font-weight:bold">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> col <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; col <span style="color:#000;font-weight:bold">&lt;</span> grid.size(); col<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            answer <span style="color:#000;font-weight:bold">=</span> min(answer, optimal(<span style="color:#099">0</span>, col, grid));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Return the minimum sum
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">return</span> answer;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// The optimal(row, col) function returns the minimum sum of a
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// falling path with non-zero shifts, starting from grid[row][col]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">optimal</span>(<span style="color:#458;font-weight:bold">int</span> row, <span style="color:#458;font-weight:bold">int</span> col, vector<span style="color:#000;font-weight:bold">&lt;</span>vector<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// If the last row, then return the value of the cell itself
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> (row <span style="color:#000;font-weight:bold">==</span> grid.size() <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> grid[row][col];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Select grid[row][col], and move on to next row. For next
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// row, choose the cell that leads to the minimum sum
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#458;font-weight:bold">int</span> nextMinimum <span style="color:#000;font-weight:bold">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> nextRowCol <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; nextRowCol <span style="color:#000;font-weight:bold">&lt;</span> grid.size(); nextRowCol<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> (nextRowCol <span style="color:#000;font-weight:bold">!=</span> col) {
</span></span><span style="display:flex;"><span>                nextMinimum <span style="color:#000;font-weight:bold">=</span> min(nextMinimum, optimal(row <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, nextRowCol, grid));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// Minimum cost from this cell
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">return</span> grid[row][col] <span style="color:#000;font-weight:bold">+</span> nextMinimum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre><p>The algorithm is inefficient. It has exponential time complexity and is not feasible for large inputs.</p>
<details><summary>For detailed complexity analysis, click here!</summary>
<p>
<p>Let <span class="math inline">\(N\)</span> be the number of rows of the square <code>grid</code>. Every row has <span class="math inline">\(N\)</span> columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot (N - 1)^N)\)</span></p>
<p>In the main function, we are calling <code>optimal</code> from every element of the first row.</p>
<p>Now let's fix our focus on one such call to one cell.</p>
<ul>
<li>In <code>optimal</code>, we are recursively calling <code>optimal</code> for every column of the next row, except for one column.</li>
<li>Thus, there will be <span class="math inline">\(N - 1\)</span> such calls from a particular row.</li>
<li>There are <span class="math inline">\(N\)</span> such rows from which recursive calls are made.</li>
</ul>
<p>Thus, the time complexity from one cell of the first row is <span class="math inline">\(O((N - 1)^N)\)</span>.</p>
<p>There are <span class="math inline">\(N\)</span> such cells in the first row. Thus, time complexity will be <span class="math inline">\(O(N \cdot (N - 1)^N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<ul>
<li>
<p>The space complexity of a recursive function depends on the maximum number of recursive calls on the stack.</p>
<p>At any point in time, there will be at most <span class="math inline">\(N\)</span> recursive calls on the stack, as each recursive call is made from a different row. In each recursive call, we have constant space complexity independent of input size. Therefore, space complexity because of the recursive call stack will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>All other variables use constant space independent of input size.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N + 1)\)</span>, which is <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<p><span class="math inline">\(\downarrow_{\text{Section after Complexity Analysis}}\)</span></p>
</p>
</details>
<br/>
<p>For optimization, let's examine the recursion tree for <code>optimal(0, 0)</code>, when <code>n = 4</code>.</p>
<blockquote>
<p>A recursion tree is a tree where every node is a recursive call. The root node is the first call to the function. The leaf nodes are the base cases. The intermediate nodes are the recursive calls.</p>
</blockquote>
<p><img src="../Figures/1289/1289_slide_images_used/Slide1.PNG" alt="Recursion Tree" /></p>
<p>As visible in the recursion tree, there are many same-colored overlapping sub-problems. <strong>Is there any point in calculating the same sub-problem again and again?</strong> No, right?</p>
<p><strong>What if we store the result of each sub-problem and use it when required?</strong> This is the foundation of dynamic programming. We store the result of each sub-problem and use it when required.</p>
<blockquote>
<p>Dynamic programming is a programming paradigm in which we break a problem into sub-problems, store the result of each sub-problem, and use it when required. To dive deep into dynamic programming, readers can visit <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Dynamic Programming Explore Card</a>.</p>
</blockquote>
<p>Since there are two state variables <code>row</code> and <code>col</code>, we can use a two-dimensional array to store the result of each sub-problem.</p>
<blockquote>
<p>If there are <span class="math inline">\(T\)</span> state variables, then we need an array of at most <span class="math inline">\(T\)</span> dimensions to store the result of each sub-problem.</p>
</blockquote>
<p>We also need to decide how and using which data structure we will store the result of each sub-problem. We have the following options.</p>
<ul>
<li>
<p>Use a hash map <code>memo</code> to cache the result. The key of the hash map will be a pair of integer indices <code>(row, col)</code>, and the value will be the result of <code>optimal(row, col)</code>.</p>
</li>
<li>
<p>Use a two-dimensional array <code>memo</code> to cache the result. <code>memo[row][col]</code> will store the result of <code>optimal(row, col)</code>.</p>
</li>
</ul>
<p>In this approach, we will use the hash map <code>memo</code> to cache the result. Readers are encouraged to implement the solution using a two-dimensional array as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Save the size of the square <code>grid</code> in a variable <code>n</code>.</p>
</li>
<li>
<p>Initialize a hash map <code>memo</code> to cache the minimum sum of a falling path with non-zero shifts, starting from a particular cell. The key will be a pair of integer indices <code>(row, col)</code>, and a value as an integer.</p>
</li>
<li>
<p>Define a recursive function <code>optimal</code>. It takes as input the row number <code>row</code> and column number <code>col</code> of the cell from which we start the falling path. It returns the minimum sum of a falling path with non-zero shifts, starting from cell <code>grid[row][col]</code>.</p>
<p>In addition to <code>row</code> and <code>col</code>, make sure to pass any parameters to the function that need to be accessed in the function.</p>
<ul>
<li>
<p>If <code>row == n - 1</code>, then there is no row left to select. Thus, we return <code>grid[row][col]</code>.</p>
</li>
<li>
<p>If the result of this sub-problem is already cached, then return the cached result. In other words, if <code>(row, col)</code> is present in <code>memo</code>, then return <code>memo[(row, col)]</code>.</p>
</li>
<li>
<p>Otherwise, initialize a variable <code>next_minimum</code> with <code>INT_MAX</code>. This variable will store the minimum sum of a falling path with non-zero shifts, starting from the next row.</p>
</li>
<li>
<p>From this cell, we have <code>n - 1</code> possibilities of selecting an element from the next row.</p>
<p>Traverse linearly in the next row <code>row + 1</code> using variable <code>next_row_col</code>. If <code>next_row_col != col</code>, then we can select <code>grid[row + 1][next_row_col]</code>.</p>
<p>We need to select <code>next_row_col</code> for which <code>next_minimum</code> is the minimum. Thus, <code>next_minimum</code> will be <code>min(optimal(row + 1, next_row_col))</code> where <code>0 &lt;= next_row_col &lt; n</code> and <code>next_row_col != col</code>.</p>
</li>
<li>
<p>Thus, from this cell, the minimum sum of a falling path with non-zero shifts is <code>grid[row][col] + next_minimum</code>. Cache this value in <code>memo</code> with the key as <code>(row, col)</code> and return this value.</p>
</li>
</ul>
</li>
<li>
<p>We can select any element from the first row. We will select the element which leads to the minimum sum. Thus, initialize a variable <code>answer</code> with <code>INT_MAX</code>.</p>
<p>Traverse linearly in the first row using variable <code>col</code>. For every cell, call <code>optimal(0, col)</code>. Variable <code>answer</code> will be <code>min(optimal(0, col))</code> where <code>0 &lt;= col &lt; n</code>.</p>
</li>
<li>
<p>Return <code>answer</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/cp7XYnDb/shared">code</a></p>
<p><strong>Note:</strong> It <em>may</em> give Time Limit Exceeded/Memory Limit Exceeded because of</p>
<ul>
<li>large constant factor associated with the asymptotic complexity of the algorithm</li>
<li>large auxiliary stack space required for recursion</li>
<li>slow internal functions</li>
</ul>
<p>It's worth mentioning that if readers are using an array instead of a hash map, then they must make sure NOT to initialize the array with <code>-1</code> because <code>-1</code> could be an answer, and we will never be able to distinguish between the case when the state is not computed, and the case when the state is computed and the answer is <code>-1</code>.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of rows of the square <code>grid</code>. Every row has <span class="math inline">\(N\)</span> columns.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span></p>
<p>In the main function, we are calling <code>optimal</code> from every element of the first row. Let's analyze every element separately.</p>
<ul>
<li>
<p><strong>Calling <code>optimal(0, 0)</code></strong>. Readers can appreciate that due to the recursive nature of the function, all yellow-highlighted sub-problems will be called, and their results will be saved in <code>memo</code> after the first call.</p>
<p><img src="../Figures/1289/1289_slide_images_used/Slide2_2.PNG" alt="opt_0_0" /></p>
<p>This is because every cell calls <code>optimal</code> for every column of the next row, except for one in the same column.</p>
<p>Thus, <span class="math inline">\(1 + \bigg( (N -1) \cdot N \bigg) - 1\)</span> sub-problems will be called, which is <span class="math inline">\(O(N^2)\)</span>.</p>
<p>In each sub-problem call, we are traversing linearly in the next row. Thus, the time complexity of each sub-problem call is <span class="math inline">\(O(N)\)</span>.</p>
<p>Hence, the time complexity of <code>optimal(0, 0)</code> is <span class="math inline">\(O( N^2 \cdot N)\)</span>, which is <span class="math inline">\(O(N^3)\)</span>.</p>
</li>
<li>
<p><strong>Calling <code>optimal(0, 1)</code></strong>. It will directly call all the cells having red dots on them.</p>
<p><img src="../Figures/1289/1289_slide_images_used/Slide2_3.PNG" alt="opt_0_1" /></p>
<ul>
<li>
<p>The value of the yellow-highlighted cell will be fetched from <code>memo</code>. Thus, there will be no recursive call from that cell. There are <span class="math inline">\(N - 2\)</span> such cells, and they will have constant time complexity.</p>
</li>
<li>
<p>The value of the cell that is not yellow-highlighted will be calculated by calling <code>optimal</code> for <span class="math inline">\(N - 1\)</span> columns of the third row.</p>
<p>There is <span class="math inline">\(1\)</span> such cell, and it will have linear time complexity.</p>
</li>
</ul>
<p>Hence, time complexity of <code>optimal(0, 1)</code> is <span class="math inline">\(O((N - 2) \cdot 1 + 1 \cdot N)\)</span>, which is <span class="math inline">\(O(N)\)</span>.</p>
<p>After the end of this call, the optimal value of all yellow-highlighted cells will be cached in <code>memo</code>.</p>
<p><img src="../Figures/1289/1289_slide_images_used/Slide3_1.PNG" alt="after_opt_0_1" /></p>
</li>
<li>
<p>We have <span class="math inline">\(N - 2\)</span> cells remaining in first row. They will pick the minimum result of <span class="math inline">\(N - 1\)</span> valid cells from the second row.</p>
<p>Thus, for remaining cells, time complexity will be <span class="math inline">\(O((N - 2) \cdot (N - 1))\)</span>, which is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<p>Hence, the time complexity of the main function is <span class="math inline">\(O(N^3 + N + N^2)\)</span>, which is <span class="math inline">\(O(N^3)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<ul>
<li>
<p>The space complexity of a recursive function depends on the maximum number of recursive calls on the stack.</p>
<p>At any point in time, there will be at most <span class="math inline">\(N\)</span> recursive calls on the stack, as each recursive call is made from a different row. In each recursive call, we have constant space complexity independent of input size. Therefore, space complexity because of the recursive call stack will be <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>We are using a hash map <code>memo</code> to cache the result of each sub-problem. There are <span class="math inline">\(N^2\)</span> such sub-problems. Therefore, space complexity because of caching will be <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
<li>
<p>All other variables use constant space independent of input size.</p>
</li>
</ul>
<p>Hence, the overall space complexity will be <span class="math inline">\(O(N + N^2 + 1)\)</span>, which is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-bottom-up-dynamic-programming">Approach 2: Bottom-Up Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The <a href="#approach-1-top-down-dynamic-programming">top-down dynamic programming</a> approach is a recursive solution, which has overhead due to recursive calls and maintaining the call stack. We can eliminate this overhead by using an iterative approach. Thus, let's transform the recursive solution into an iterative solution.</p>
<p>For this let's write the mathematical recurrence for the problem.</p>
<p><span class="math inline">\(\text{optimal}(row, col)\)</span> represents the minimum sum of a falling path with non-zero shifts, starting from cell <code>grid[row][col]</code>. The equation for the recurrence (which is often called the Bellman equation) is</p>
<p><span class="math display">\[
Since there are two state variables $row$ and $col$, we will use a two-dimensional array to store the result of each sub-problem. Let's call this array `memo`. 

> The size of the `memo` array will depend on the range of the state variables. 
> - `row` can take values from `0` to `n - 1`.
> - `col` can take values from `0` to `n - 1`.
>
> Hence, the size of the `memo` array will be `n x n`, the same as the size of the `grid`.

Our goal is to fill the array in a bottom-up manner. This means that we will fill the array first for base case(s), and then for subsequent recursive cases.

In this problem, the base case is when `row = n - 1`. Hence, we will fill the array in a bottom-up manner starting from the last row and moving upwards. We traverse the array row-wise from the last row to the first row, and within each row, we traverse from left to right.

The answer will be the minimum value in the first row of the `memo` array.

> It's worth noting that it is bottom-up because we are **moving from the solved base case to the unsolved sub-problems**. 
>
> The order of traversal from bottom-row to up has **nothing to do** with the term bottom-up dynamic programming. Many problems require traversal in a diagonal manner. Thus, critically analyze the Bellman Equation to conclude the order of filling the array.

Readers are encouraged to implement the solution on their own.

#### Algorithm

1. Save the size of the square `grid` in a variable `n`.

2. Declare a two-dimensional array `memo` to cache the minimum sum of a falling path with non-zero shifts, starting from a particular cell. It will have size `n x n`.

3. Fill the base case. For every cell in last row, `memo[n - 1][col]` will be `grid[n - 1][col]`.

4. Fill the recursive cases. For every row from `n - 2` to `0`, and for every column from `0` to `n - 1`, do the following

    - Initialize a variable `next_minimum` with `INT_MAX`. This variable will store the minimum sum of a falling path with non-zero shifts, starting from the next row. 

    - From this cell, we have `n - 1` possibilities of selecting an element from the next row. 

        Thus traverse linearly in the next row `row + 1` using variable `next_row_col`. If `next_row_col != col`, then we can select `memo[row + 1][next_row_col]`. 
        
        We need to select `next_row_col` for which `next_minimum` is the minimum. Thus, `next_minimum` will be `min(memo[row + 1][next_row_col])` where `0 <= next_row_col < n` and `next_row_col != col`.
    
    - Thus, from this cell, the minimum sum of a falling path with non-zero shifts is `grid[row][col] + next_minimum`. Cache this value in `memo[row][col]`.

5. Find the minimum from the first row of `memo`. Return this value.

#### Implementation

[code](https://leetcode.com/playground/YrmE9La7/shared)

#### Complexity Analysis

Let $N$ be the number of rows of the square `grid`. Every row has $N$ columns.

* Time complexity: $O(N^3)$

    We are traversing in every cell of the `memo` array once.

    - For the last row, we do a constant time operation of assigning `grid[row][col]` to `memo[row][col]`. There are $N$ such cells, and each cell will take constant time. Thus, the time complexity will be $O(N)$.

    - For the remaining rows, we find a minimum from valid elements of the next row. There are $(N - 1) \cdot N$ such cells, and each cell will take linear time. Thus, the time complexity will be $O((N - 1) \cdot N \cdot N)$, which is $O(N^3)$.

    At the end, we find the minimum from the first row. It will take $O(N)$ time.

    Thus, overall time complexity will be $O(N + N^3 + N)$, which is $O(N^3)$.

* Space complexity: $O(N^2)$

    We used a two-dimensional array `memo` of size $N \times N$. Thus, space complexity will be $O(N^2)$. All other variables use constant space independent of input size. 
        
---

### Approach 3: Bottom-Up Dynamic Programming. Save Minimum and Second Minimum

#### Intuition

In [bottom-up dynamic programming](#approach-2-bottom-up-dynamic-programming), we visited every cell of the `memo` array.

However, computing `memo[row][col]` requires traversal in the `memo[row + 1]` array. The purpose of this traversal was to find the *minimum* from **valid elements** of the next row. 

Assume this *minimum* is represented by the red cell in the following figure.

![minimum](../Figures/1289/1289_slide_images_used/Slide3_2.PNG)

This red-cell *minimum* is **valid** for all green elements since it is not in the same column as the green elements. 

However, it is **invalid** for the blue element since it is in the same column as the red element. Thus, for the blue element, we need to find the *minimum* excluding the red cell, which will be the *second minimum* of the next row.

Thus, for computing any element in `memo`, what ultimately matters is the *minimum* and *second minimum* of the next row. Hence while traversing and filling `memo`, we can store the *minimum* and *second minimum* of the current row, which will help the previous row in computing `memo[row][col]`.

Here is the visualization of the algorithm for the input `[[99,1,60,4,3], [49, 1, 10, 42, 56], [87, 28, 78, 60, 5], [23, 12, 53, 69, 6], [3, 5, 15, 6, 7]]`

!?!../Documents/1289/1289_slideshow.json:960,540!?!   
<br/>

**In what condition we will be prompted to use *second minimum*?**   
When the column of *minimum* is the same as the column of the current element. Hence, instead of saving **values** of *minimum* and *second minimum*, we can save the **column** of *minimum* and *second minimum*. From **column**, we can fetch the **value**.

#### Algorithm

1. Save the size of the square `grid` in a variable `n`.

2. Declare a two-dimensional array `memo` to cache the minimum sum of a falling path with non-zero shifts, starting from a particular cell. It will have size `n x n`.

3. Declare two variables `next_min1_c` and `next_min2_c` to store the column of *minimum* and *second minimum* respectively. Initialize them with `None`.

4. Fill Base Case in `memo`, and in the same traversal, update the values of `next_min1_c` and `next_min2_c`.

    - For every cell in last row, `memo[n - 1][col]` will be `grid[n - 1][col]`.

    - If `next_min1_c` is `None` or `memo[n - 1][col]` is less than or equal to `memo[n - 1][next_min1_c]`, then
      
        - Update `next_min2_c` with `next_min1_c`
       
        - Update `next_min1_c` with `col`  

    - Otherwise, if `next_min2_c` is `None` or `memo[n - 1][col]` is less than or equal to `memo[n - 1][next_min2_c]`, then update `next_min2_c` with `col`.

    > The updates done in the above two points are the standard approach of finding the minimum and second minimum from an array. For more details, read [this editorial](https://leetcode.com/problems/buy-two-chocolates/editorial/#approach-5-one-pass)

    They are *minimum* and *second minimum* of the current row, and will act as *minimum* and *second minimum* of the next row for the previous row elements.

5. Fill the recursive cases. For every row from `n - 2` to `0`.

    - Declare two variables `min1_c` and `min2_c` to store the column of *minimum* and *second minimum*, respectively, for `memo[row]`. The `memo[row]` is not computed yet. Initialize them with `None`.

    - Traverse from column `0` to `n - 1` using variable `col`. For every column, do the following

        - If `col != next_min1_c`, then we can select minimum element from `memo[row + 1]` array. Thus, `memo[row][col]` will be `grid[row][col] + memo[row + 1][next_min1_c]`.

           Otherwise, `memo[row][col]` will be `grid[row][col] + memo[row + 1][next_min2_c]`. 

        - If `min1_c` is `None` or `memo[row][col]` is less than or equal to `memo[row][min1_c]`, then 
            - Update `min2_c` with `min1_c`
             
            - Update `min1_c` with `col`  

        - Otherwise, if `min2_c` is `None` or `memo[row][col]` is less than or equal to `memo[row][min2_c]`, then update `min2_c` with `col`.

        > The updates done in the above two points are the standard approach of finding the minimum and second minimum from an array. For more details, read [this editorial](https://leetcode.com/problems/buy-two-chocolates/editorial/#approach-5-one-pass)
    
    - Update `next_min1_c` and `next_min2_c` with `min1_c` and `min2_c` respectively. The current row is the next row for the previous row elements.

6. Return the minimum from the first row of `memo`. It will be the `memo[0][next_min1_c]`.` 

#### Implementation

[code](https://leetcode.com/playground/DSRCPgfn/shared)

#### Complexity Analysis

Let $N$ be the number of rows of the square `grid`. Every row has $N$ columns.

* Time complexity: $O(N^2)$

    We are traversing in every cell of the `memo` array once.

    For all the cells, we do two main operations
    - Computing `memo[row][col]`. In the base case, and even in recursive cases, the operation is constant time.
      
    - Ensuring loop invariant of `next_min1_c` and `next_min2_c`. 
    
    Both of these are constant time operations.

    Thus, $N^2$ cells take $O(1)$ time. Hence, the overall time complexity will be $O(N^2)$.

* Space complexity: $O(N^2)$ 

    We are using a two-dimensional array `memo` of size $N \cdot N$. Thus, space complexity will be $O(N^2)$. All other variables use constant space independent of input size.
        
---

### Approach 4: Space-Optimized Bottom-Up Dynamic Programming

#### Intuition

The rule of thumb is:

> If there are $T$ state variables, then we need an array of **at most** $T$ dimensions to store the result of each sub-problem.

The term **at most** is a good signal. We might be able to reduce the number of dimensions of the array by carefully analyzing the recurrence relation. 

$$\text{optimal}(row, col) = \begin{cases} \text{grid}[row][col] & \text{if } row = n - 1 \\ \text{grid}[row][col] + \min_{\substack{0 \leq next\_row\_col < n \\ next\_row\_col \neq col}} \text{optimal}(row + 1, next\_row\_col) & \text{otherwise} \end{cases}$$

We can observe the fact that the value of $\text{optimal}(row, \_)$ depends only on the values of $\text{optimal}(row + 1, \_)$.

In other words, instead of saving the entire `memo` array, we can save only the recently processed row of the `memo` array. This will reduce space complexity from $O(N^2)$ to $O(N)$. Readers are encouraged to implement this approach.

$\downarrow$

**However, do we even need to save one row of the `memo` array?**  
From [previous approach](#approach-3-bottom-up-dynamic-programming-save-minimum-and-second-minimum), we realize the fact that only **column** of *minimum* and *second minimum* of the next row is required.  
From these **columns**, we fetched the **values**. These columns ensured that we were not selecting the same column as the current element.

**What if we saved values as well?**   
This will help us develop an approach with no `memo` array. 

$\downarrow$

Hence, as we process the row, we will save four variables
- `next_min1_c` and `next_min2_c` to store the column of *minimum* and *second minimum*, respectively, of (non-existent) next row of the `memo` array.
- `next_min1` and `next_min2` to store the value of *minimum* and *second minimum*, respectively, of (non-existent) next row of the `memo` array.


#### Algorithm

1. Save the size of the square `grid` in a variable `n`.

2. Declare and Initialize four variables

   - `next_min1_c` to store the column of *minimum* of (non-existent) next row of the `memo` array. Initialize it with `None`. 

    - `next_min2_c` to store the column of *second minimum* of (non-existent) next row of the `memo` array. Initialize it with `None`.

    - `next_min1` to store the value of *minimum* of (non-existent) next row of the `memo` array. Initialize it with `None`.

    - `next_min2` to store the value of *second minimum* of (non-existent) next row of the `memo` array. Initialize it with `None`.

3. Traverse in the last row of `grid` using variable `col`. For every column, do the following

    - If `next_min1` is `None` or `grid[n - 1][col]` is less than or equal to `next_min1`, then

        - Update `next_min2` with `next_min1`
       
        - Update `next_min1` with `grid[n - 1][col]`  

        - Update `next_min2_c` with `next_min1_c`

        - Update `next_min1_c` with `col` 

    - Otherwise, if `next_min2` is `None` or `grid[n - 1][col]` is less than or equal to `next_min2`, then 

        - Update `next_min2` with `grid[n - 1][col]`

        - Update `next_min2_c` with `col`

    > The updates done are the standard approach of finding the minimum and second minimum from an array. For more details, read [this editorial](https://leetcode.com/problems/buy-two-chocolates/editorial/#approach-5-one-pass)
 
4. Traverse in the remaining rows of `grid` from `n - 2` to `0` using variable `row`. For every row, do the following

    - Declare and initialize four variables

        - `min1_c` to store the column of *minimum* of (non-existent) current row of the `memo` array. Initialize it with `None`.

        - `min2_c` to store the column of *second minimum* of the (non-existent) current row of the `memo` array. Initialize it with `None`.

        - `min1` to store the value of *minimum* of (non-existent) current row of the `memo` array. Initialize it with `None`.

        - `min2` to store the value of *second minimum* of the (non-existent) current row of the `memo` array. Initialize it with `None`.

    - Traverse in the current row of `grid` using variable `col`. For every column, do the following

        - If `col != next_min1_c`, then we can select the minimum element from the (non-existent) next row of the `memo` array. Thus, the optimal `value` from this cell will be `grid[row][col] + next_min1`.

           Otherwise, the optimal `value` from this cell will be `grid[row][col] + next_min2`.
        
        - If `min1` is `None` or `value` is less than or equal to `min1`, then 
            - Update `min2` with `min1`
              
            - Update `min1` with `value`  

            - Update `min2_c` with `min1_c`
             
            - Update `min1_c` with `col`

        - Otherwise, if `min2` is `None` or `value` is less than or equal to `min2`, then               
            - Update `min2` with `value`
             
            - Update `min2_c` with `col`  
    
    - Update `next_min1_c`, `next_min2_c`, `next_min1`, and `next_min2` with `min1_c`, `min2_c`, `min1`, and `min2` respectively. The current row is the next row for the previous row elements.

5. Return the minimum from the first row of the `grid`. It will be `next_min1`. 
 
#### Implementation

[code](https://leetcode.com/playground/DGJcpkkz/shared)

#### Complexity Analysis

Let $N$ be the number of rows of the square `grid`. Every row has $N$ columns.

* Time complexity: $O(N^2)$

    We are traversing in every cell of the `grid` array once.

    For all the cells, we are doing two main operations
    - Computing `value`. It will take constant time.
     
    - Ensuring loop invariant of `next_min1_c`, `next_min2_c`, `next_min1`, and `next_min2`.

    All these operations are constant time operations.

    Thus, $N^2$ cells take $O(1)$ time. Hence, the overall time complexity will be $O(N^2)$. 

* Space complexity: $O(1)$

    We are using only a handful of variables, which are independent of input size. Thus, space complexity will be $O(1)$.
        
---

**Follow-up**: What if we were asked to print the path as well? Readers are encouraged to take this as an exercise and comment with their solution below.

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-clean-the-classroom/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Clean the Classroom</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="324" data-start="147">You are given an <code>m x n</code> grid <code>classroom</code> where a student volunteer is tasked with cleaning up litter scattered around the room. Each cell in the grid is one of the following:</p>

<ul>
	<li><code>&#39;S&#39;</code>: Starting position of the student</li>
	<li><code>&#39;L&#39;</code>: Litter that must be collected (once collected, the cell becomes empty)</li>
	<li><code>&#39;R&#39;</code>: Reset area that restores the student&#39;s energy to full capacity, regardless of their current energy level (can be used multiple times)</li>
	<li><code>&#39;X&#39;</code>: Obstacle the student cannot pass through</li>
	<li><code>&#39;.&#39;</code>: Empty space</li>
</ul>

<p>You are also given an integer <code>energy</code>, representing the student&#39;s maximum energy capacity. The student starts with this energy from the starting position <code>&#39;S&#39;</code>.</p>

<p>Each move to an adjacent cell (up, down, left, or right) costs 1 unit of energy. If the energy reaches 0, the student can only continue if they are on a reset area <code>&#39;R&#39;</code>, which resets the energy to its <strong>maximum</strong> capacity <code>energy</code>.</p>

<p>Return the <strong>minimum</strong> number of moves required to collect all litter items, or <code>-1</code> if it&#39;s impossible.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;S.&quot;, &quot;XL&quot;], energy = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The student starts at cell <code data-end="262" data-start="254">(0, 0)</code> with 2 units of energy.</li>
	<li>Since cell <code>(1, 0)</code> contains an obstacle &#39;X&#39;, the student cannot move directly downward.</li>
	<li>A valid sequence of moves to collect all litter is as follows:
	<ul>
		<li>Move 1: From <code>(0, 0)</code> &rarr; <code>(0, 1)</code> with 1 unit of energy and 1 unit remaining.</li>
		<li>Move 2: From <code>(0, 1)</code> &rarr; <code>(1, 1)</code> to collect the litter <code>&#39;L&#39;</code>.</li>
	</ul>
	</li>
	<li>The student collects all the litter using 2 moves. Thus, the output is 2.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;LS&quot;, &quot;RL&quot;], energy = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>The student starts at cell <code data-end="262" data-start="254">(0, 1)</code> with 4 units of energy.</li>
	<li>A valid sequence of moves to collect all litter is as follows:
	<ul>
		<li>Move 1: From <code>(0, 1)</code> &rarr; <code>(0, 0)</code> to collect the first litter <code>&#39;L&#39;</code> with 1 unit of energy used and 3 units remaining.</li>
		<li>Move 2: From <code>(0, 0)</code> &rarr; <code>(1, 0)</code> to <code>&#39;R&#39;</code> to reset and restore energy back to 4.</li>
		<li>Move 3: From <code>(1, 0)</code> &rarr; <code>(1, 1)</code> to collect the second litter <code data-end="1068" data-start="1063">&#39;L&#39;</code>.</li>
	</ul>
	</li>
	<li>The student collects all the litter using 3 moves. Thus, the output is 3.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">classroom = [&quot;L.S&quot;, &quot;RXL&quot;], energy = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>No valid path collects all <code>&#39;L&#39;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m == classroom.length &lt;= 20</code></li>
	<li><code>1 &lt;= n == classroom[i].length &lt;= 20</code></li>
	<li><code>classroom[i][j]</code> is one of <code>&#39;S&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, <code>&#39;X&#39;</code>, or <code>&#39;.&#39;</code></li>
	<li><code>1 &lt;= energy &lt;= 50</code></li>
	<li>There is exactly <strong>one</strong> <code>&#39;S&#39;</code> in the grid.</li>
	<li>There are <strong>at most</strong> 10 <code>&#39;L&#39;</code> cells in the grid.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Move a Box to Their Target Location</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.</p>

<p>The game is represented by an <code>m x n</code> grid of characters <code>grid</code> where each element is a wall, floor, or box.</p>

<p>Your task is to move the box <code>&#39;B&#39;</code> to the target position <code>&#39;T&#39;</code> under the following rules:</p>

<ul>
	<li>The character <code>&#39;S&#39;</code> represents the player. The player can move up, down, left, right in <code>grid</code> if it is a floor (empty cell).</li>
	<li>The character <code>&#39;.&#39;</code> represents the floor which means a free cell to walk.</li>
	<li>The character<font face="monospace">&nbsp;</font><code>&#39;#&#39;</code><font face="monospace">&nbsp;</font>represents the wall which means an obstacle (impossible to walk there).</li>
	<li>There is only one box <code>&#39;B&#39;</code> and one target cell <code>&#39;T&#39;</code> in the <code>grid</code>.</li>
	<li>The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a <strong>push</strong>.</li>
	<li>The player cannot walk through the box.</li>
</ul>

<p>Return <em>the minimum number of <strong>pushes</strong> to move the box to the target</em>. If there is no way to reach the target, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/06/sample_1_1620.png" style="width: 500px; height: 335px;" />
<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We return only the number of times the box is pushed.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> -1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;],
               [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> push the box down, left, left, up and up.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>grid</code> contains only characters <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>, <code>&#39;S&#39;</code>, <code>&#39;T&#39;</code>, or <code>&#39;B&#39;</code>.</li>
	<li>There is only one character <code>&#39;S&#39;</code>, <code>&#39;B&#39;</code>, and <code>&#39;T&#39;</code> in the <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Reach Target with Rotations</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In an&nbsp;<code>n*n</code>&nbsp;grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at&nbsp;<code>(n-1, n-2)</code>&nbsp;and&nbsp;<code>(n-1, n-1)</code>.</p>

<p>In one move the snake can:</p>

<ul>
	<li>Move one cell to the right&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>
	<li>Move down one cell&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>
	<li>Rotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>.<br />
	<img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image-2.png" style="width: 300px; height: 134px;" /></li>
	<li>Rotate counterclockwise&nbsp;if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>.<br />
	<img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image-1.png" style="width: 300px; height: 121px;" /></li>
</ul>

<p>Return the minimum number of moves to reach the target.</p>

<p>If there is no way to reach the target, return&nbsp;<code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/24/image.png" style="width: 400px; height: 439px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
&nbsp;              [0,0,0,0,1,1],
&nbsp;              [0,0,1,0,1,0],
&nbsp;              [0,1,1,0,0,0],
&nbsp;              [0,1,1,0,0,0]]
<strong>Output:</strong> 11
<strong>Explanation:
</strong>One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1,1,1,1],
&nbsp;              [0,0,0,0,1,1],
&nbsp;              [1,1,0,0,0,1],
&nbsp;              [1,1,1,0,0,1],
&nbsp;              [1,1,1,0,0,1],
&nbsp;              [1,1,1,0,0,0]]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
	<li>It is guaranteed that the snake starts at empty cells.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-moves-to-spread-stones-over-grid/description" target="_blank" rel="noopener noreferrer">Minimum Moves to Spread Stones Over Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer matrix <code>grid</code> of size <code>3 * 3</code>, representing the number of stones in each cell. The grid contains exactly <code>9</code> stones, and there can be <strong>multiple</strong> stones in a single cell.</p>

<p>In one move, you can move a single stone from its current cell to any other cell if the two cells share a side.</p>

<p>Return <em>the <strong>minimum number of moves</strong> required to place one stone in each cell</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg" style="width: 401px; height: 281px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,0],[1,1,1],[1,2,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One possible sequence of moves to place one stone in each cell is: 
1- Move one stone from cell (2,1) to cell (2,2).
2- Move one stone from cell (2,2) to cell (1,2).
3- Move one stone from cell (1,2) to cell (0,2).
In total, it takes 3 moves to place one stone in each cell of the grid.
It can be shown that 3 is the minimum number of moves required to place one stone in each cell.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example2-2.svg" style="width: 401px; height: 281px;" />
<pre>
<strong>Input:</strong> grid = [[1,3,0],[1,0,0],[1,0,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible sequence of moves to place one stone in each cell is:
1- Move one stone from cell (0,1) to cell (0,2).
2- Move one stone from cell (0,1) to cell (1,1).
3- Move one stone from cell (2,2) to cell (1,2).
4- Move one stone from cell (2,2) to cell (2,1).
In total, it takes 4 moves to place one stone in each cell of the grid.
It can be shown that 4 is the minimum number of moves required to place one stone in each cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == grid[i].length == 3</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
	<li>Sum of <code>grid</code> is equal to <code>9</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-days-to-disconnect-island/description" target="_blank" rel="noopener noreferrer">Minimum Number of Days to Disconnect Island</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">strongly-connected-component</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary grid <code>grid</code> where <code>1</code> represents land and <code>0</code> represents water. An <strong>island</strong> is a maximal <strong>4-directionally</strong> (horizontal or vertical) connected group of <code>1</code>&#39;s.</p>

<p>The grid is said to be <strong>connected</strong> if we have <strong>exactly one island</strong>, otherwise is said <strong>disconnected</strong>.</p>

<p>In one day, we are allowed to change <strong>any </strong>single land cell <code>(1)</code> into a water cell <code>(0)</code>.</p>

<p>Return <em>the minimum number of days to disconnect the grid</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land1.jpg" style="width: 500px; height: 169px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]

<strong>Output:</strong> 2
<strong>Explanation:</strong> We need at least 2 days to get a disconnected grid.
Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land2.jpg" style="width: 404px; height: 85px;" />
<pre>
<strong>Input:</strong> grid = [[1,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Grid of full water is also disconnected ([[1,1]] -&gt; [[0,0]]), 0 islands.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary grid where each cell represents either land (1) or water (0). Each day, we can convert any single land cell to a water cell. Our task is to determine the minimum number of days required to modify the grid such that it either:</p>
<ul>
<li>Contains no islands, or</li>
<li>Contains more than one island.</li>
</ul>
<p>An island is a maximal group of horizontally or vertically connected land cells.</p>
<p>In this article, we will explore the applications of the Flood-Fill Algorithm, Tarjan's Algorithm, and Articulation Points, focusing on their practical uses rather than their fundamental principles. If you are unfamiliar with these algorithms, please refer to the foundational materials for a comprehensive understanding:</p>
<ol>
<li><a href="https://leetcode.com/problems/flood-fill/description/">Flood-Fill Algorithm</a></li>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/editorial/">Tarjan's Algorithm and Articulation Points</a></li>
</ol>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The binary grid can initially be in one of three states:</p>
<ol>
<li>No islands (all cells are water).</li>
<li>One island.</li>
<li>More than one island.</li>
</ol>
<p>We only need to modify the grid in the second case, aiming to reach either the first or third state with minimal changes.</p>
<p>A brute force approach would involve flipping each land cell one by one to achieve the desired conditions. However, this could generate up to <span class="math inline">\(2^{30}\)</span> states, which will not satisfy the problem constraints.</p>
<p>To reduce this complexity, we can identify a pattern. The most effective way to split an island into two parts is to find the thinnest cross-section and change those cells to water. In a binary grid, even for uniform shapes like squares or circles, the thinnest cross-section comprises at most 2 squares. Examples can be seen here:</p>
<p><img src="../Figures/1568/two_is_enough.png" alt="two flips are enough" /></p>
<p>First, we should determine if the grid already satisfies the conditions (zero or more than one island). If so, we can immediately return 0.</p>
<p>To check if we can meet the conditions in 1 step, we systematically flip each island cell to water and evaluate the resulting configuration. We iterate over each cell in the grid, temporarily changing it to water, and use a <code>countIslands</code> function to determine the number of islands in the modified grid. When we encounter a land cell, we use the <a href="https://en.wikipedia.org/wiki/Flood_fill">flood-fill algorithm</a> to count the entire island. The total number of flood-fill calls indicates the number of islands.</p>
<p>If removing one land cell does not achieve the goal, the only remaining option is to return 2.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define an array <code>DIRECTIONS</code> that contain the directions for moving right, left, down, and up.</li>
</ul>
<p>Main method <code>minDays</code>:</p>
<ul>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in <code>grid</code>.</li>
<li>Initialize a variable <code>initialIslandCount</code> and set it to the initial number of islands in the grid by calling the <code>countIslands</code> method.</li>
<li>Check if <code>initialIslandCount</code> is not equal to <code>1</code> (i.e. the island is already disconnected):
<ul>
<li>If <code>true</code>, return <code>0</code>.</li>
</ul>
</li>
<li>Iterate through each cell <code>(row, col)</code> of the grid:
<ul>
<li>If the cell is water, skip it.</li>
<li>Set <code>grid[row][col]</code> to <code>0</code>.</li>
<li>Find the <code>newIslandCount</code> by calling <code>countIslands</code>.</li>
<li>If <code>newIslandCount</code> is not equal to <code>1</code>, return <code>1</code>.</li>
<li>Set  <code>grid[row][col]</code> back to <code>1</code>.</li>
</ul>
</li>
<li>Return <code>2</code>.</li>
</ul>
<p>Helper method <code>countIslands</code>:</p>
<ul>
<li>Define a method <code>countIslands</code> with parameter: the <code>grid</code>.</li>
<li>Initialize:
<ul>
<li><code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>a boolean array <code>visited</code> to track visited cells.</li>
<li>a variable <code>islandCount</code> set to <code>0</code>.</li>
</ul>
</li>
<li>Iterate through each cell <code>(row, col)</code> of the <code>grid</code>:
<ul>
<li>If the cell has not been visited and its value is <code>1</code>:
<ul>
<li>Call <code>exploreIsland</code> on <code>(row, col)</code>.</li>
<li>Increment <code>islandCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>islandCount</code>.</li>
</ul>
<p>Helper method <code>exploreIsland</code>:</p>
<ul>
<li>Define a method <code>exploreIsland</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, and the <code>visited</code> array.</li>
<li>Set <code>visited[row][col]</code> to <code>true</code>.</li>
<li>For each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Set <code>newRow</code> to <code>row + direction[0]</code>.</li>
<li>Set <code>newCol</code> to <code>col + direction[1]</code>.</li>
<li>Check if the <code>(newRow, newCol)</code> is valid using <code>isValidLandCell</code>:
<ul>
<li>If <code>true</code>, call <code>exploreIsland</code> on <code>(newRow, newCol)</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidLandCell</code>:</p>
<ul>
<li>Define a method <code>isValidLandCell</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, and the <code>visited</code> array.</li>
<li>Return <code>true</code> if the cell is within the <code>grid</code> bounds, <code>grid[row][col]</code> is <code>1</code> and has not been visited yet.</li>
<li>Else, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TkjwpTDi/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)^2)\)</span></p>
<p>The main operation in this algorithm is the <code>countIslands</code> function, which is called multiple times. <code>countIslands</code> in turn calls the <code>exploreIslands</code> method, which performs a depth-first search on the grid. The DFS in the worst case can explore all the cells in the grid, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>The <code>countIslands</code> method may be called a maximum of <span class="math inline">\(1 + m \cdot n\)</span> times.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O((m \cdot n) \cdot (1 + m \cdot n))\)</span>, which simplifies to <span class="math inline">\(O((m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The main space usage comes from the <code>visited</code> array in the <code>countIslands</code> function, which has a size of <span class="math inline">\(m \times n\)</span>.</p>
<p>The recursive call stack in the DFS (<code>exploreIsland</code> function) can go as deep as <span class="math inline">\(m \cdot n\)</span> in the worst case.</p>
<p>Therefore, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tarjans-algorithm">Approach 2: Tarjan's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An articulation point is a cell that will split an island in two when it is changed from land to water. If a given grid has an articulation point, we can disconnect the island in one day. Tarjan's algorithm efficiently finds articulation points in a graph.</p>
<p>The algorithm uses three key pieces of information for each node (cell): discovery time, lowest reachable time, and parent. The discovery time is when a node is first visited during the DFS. The lowest reachable time is the minimum discovery time of any node that can be reached from the subtree rooted at the current node, including the current node itself. The parent is the node from which the current node was discovered during the DFS.</p>
<p>A node can be an articulation point in two cases:</p>
<ol>
<li>A non-root node is an articulation point if it has a child whose lowest reachable time is greater than or equal to the node's discovery time. This condition means that the child (and its subtree) cannot reach any ancestor of the current node without going through the current node, making it critical for connectivity.</li>
<li>The root node of the DFS tree is an articulation point if it has more than one child. Removing the root would disconnect these children from each other.</li>
</ol>
<p>If no articulation points are found, the grid cannot be disconnected by removing a single land cell. In that case, we return 2.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define a constant array <code>DIRECTIONS</code> that contains the directions for moving right, down, left, and up.</li>
</ul>
<p>Main method <code>minDays</code>:</p>
<ul>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>Initialize an <code>ArticulationPointInfo</code> object <code>apInfo</code> with <code>hasArticulationPoint</code> set to <code>false</code> and <code>time</code> set to <code>0</code>.</li>
<li>Initialize variables:
<ul>
<li><code>landCells</code> to count the number of land cells in the grid.</li>
<li><code>islandCount</code> to count the number of islands in the grid.</li>
</ul>
</li>
<li>Initialize arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> with default values of <code>-1</code>. These arrays store information about each cell during DFS traversal.</li>
<li>Loop through each cell <code>(i, j)</code> of the <code>grid</code>:
<ul>
<li>If the cell is land (<code>1</code>):
<ul>
<li>Increment the <code>landCells</code> count.</li>
<li>If the cell has not been visited (<code>discoveryTime[i][j]</code> = <code>-1</code>):
<ul>
<li>Call <code>findArticulationPoints</code> on <code>(i, j)</code> to find if articulation point exists.</li>
<li>Increment <code>islandCount</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If there is zero or more than one island, return <code>0</code></li>
<li>If there is only one land cell, return <code>1</code>.</li>
<li>If there is an articulation point, return <code>1</code>.</li>
<li>Otherwise, return <code>2</code>.</li>
</ul>
<p>Helper method <code>findArticulationPoints</code>:</p>
<ul>
<li>Define a method <code>findArticulationPoints</code> with parameters: <code>grid</code>, the <code>row</code> and <code>col</code> indices, <code>discoveryTime</code>, <code>lowestReachable</code>, <code>parentCell</code>, and <code>apInfo</code>.</li>
<li>Set <code>rows</code> and <code>cols</code> as the number of rows and columns in the <code>grid</code>.</li>
<li>Set <code>discoveryTime</code> of the current cell to <code>apInfo.time</code>.</li>
<li>Increment the <code>time</code> in <code>apInfo</code>.</li>
<li>Set the <code>lowestReachable</code> time of the current cell to its <code>discoveryTime</code>.</li>
<li>Initialize a variable <code>children</code> to count the number of child nodes in the DFS tree.</li>
<li>To explore adjacent cells, loop through each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Calculate <code>newRow</code> as <code>row + direction[0]</code>.</li>
<li>Calculate <code>newCol</code> as <code>col + direction[1]</code>.</li>
<li>If <code>(newRow, newCol)</code> is a valid cell:
<ul>
<li>If the <code>discoveryTime</code> of the new cell is <code>-1</code>:
<ul>
<li>Increment <code>children</code>.</li>
<li>Set the <code>parentCell</code> of the new cell to the current cell.</li>
<li>Recursively call <code>findArticulationPoints</code> for the new cell.</li>
<li>Update the <code>lowestReachable</code> time for the current cell to the minimum of <code>lowestReachable[row][col]</code> and <code>lowestReachable[newRow][newCol]</code>.</li>
<li>If <code>lowestReachable</code> of <code>(newRow, newCol)</code> is greater than or equal to <code>discoveryTime</code> of <code>(row, col)</code>, and <code>(row, col)</code> has a parent:
<ul>
<li>Set <code>hasArticulationPoint</code> of <code>apInfo</code> to <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Else if <code>(newRow, newCol)</code> is not the parent of <code>(row, col)</code>:
<ul>
<li>Set <code>lowestReachable</code> time of <code>(row, col)</code> to the minimum of <code>lowestReachable[row][col]</code> and <code>discoveryTime[newRow][newCol]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Check if <code>(row, col)</code> is the root of the DFS tree and has more than 1 <code>children</code>:
<ul>
<li>Set <code>hasArticulationPoint</code> of <code>apInfo</code> to <code>true</code>.</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidLandCell</code>:</p>
<ul>
<li>Define a method <code>isValidLandCell</code> with parameters: <code>grid</code>, and the <code>row</code> and <code>col</code> indices.</li>
<li>Return <code>true</code> if the given cell is within the bounds of the grid and is a land cell (<code>1</code>).</li>
<li>Else, return <code>false</code>.</li>
</ul>
<p>Helper class <code>ArticulationPointInfo</code>:</p>
<ul>
<li>Define a class <code>ArticulationPointInfo</code> with fields: <code>hasArticulationPoint</code> and <code>time</code>.</li>
<li>Override the default constructor to initialize <code>hasArticulationPoint</code> and <code>time</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/V5ydSy68/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Initializing the arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> takes <span class="math inline">\(O(m \cdot n)\)</span> time each.</p>
<p>The DFS traversal by the <code>findArticulationPoints</code> method visits each cell exactly once, taking <span class="math inline">\(O(m \cdot n)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The arrays <code>discoveryTime</code>, <code>lowestReachable</code>, and <code>parentCell</code> each take <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>The recursive call stack for the DFS traversal can go as deep as the number of land cells in the worst case. If all cells are land, the depth of the recursive call stack can be <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(m \cdot n) + O(m \cdot n) = O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> binary matrix <code>mat</code>. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing <code>1</code> to <code>0</code> and <code>0</code> to <code>1</code>). A pair of cells are called neighbors if they share one edge.</p>

<p>Return the <em>minimum number of steps</em> required to convert <code>mat</code> to a zero matrix or <code>-1</code> if you cannot.</p>

<p>A <strong>binary matrix</strong> is a matrix with all cells equal to <code>0</code> or <code>1</code> only.</p>

<p>A <strong>zero matrix</strong> is a matrix with all cells equal to <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/28/matrix.png" style="width: 409px; height: 86px;" />
<pre>
<strong>Input:</strong> mat = [[0,0],[0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Given matrix is a zero matrix. We do not need to change it.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[1,0,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> Given matrix cannot be a zero matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 3</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-smart-enumeration">Approach 1: Smart Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>The question asks us to transform a 0-1 matrix into all 0s using the minimum number of flips, and when an element is flipped, all of its 4 neighbors (if they exist) will be flipped too. The problem is also known as the <strong>Lights Out Puzzle</strong>.</p>
<p>You might already realize that for each element, we only need to flip it at most once since flipping the same element twice cancels the previous flip. Because the size of the matrix is not large (at most 3 x 3 according to the constraints), we can just try all combinations of the decisions on each element (whether to flip it or not).</p>
<p>However, there is a better way to do the enumeration. Suppose we make each decision from the top row to the bottom row. When we're making decisions for the <span class="math inline">\(i^{th}\)</span> row, all the rows above the <span class="math inline">\((i - 1)^{th}\)</span> row should be already be 0s, because flipping the elements in the <span class="math inline">\(i^{th}\)</span> row and below cannot change the elements above the <span class="math inline">\((i - 1)^{th}\)</span> row. This means when we're working on the <span class="math inline">\(i^{th}\)</span> row, if there are still 1s in the <span class="math inline">\((i - 1)^{th}\)</span> row, they can only be changed into 0 by flips on the current row. Furthermore, if there's a 0 in the <span class="math inline">\((i - 1)^{th}\)</span> row, we shouldn't flip its neighbors in the current row. <strong>In other words, when we're working on the <span class="math inline">\(i^{th}\)</span> row, the decisions are uniquely determined by the state of the <span class="math inline">\((i - 1)^{th}\)</span> row.</strong> The <span class="math inline">\(i^{th}\)</span> row's decisions needs to make the values in the <span class="math inline">\((i - 1)^{th}\)</span> row into all 0s.</p>
<p>Here is an example:</p>
<center>
<img src="../Figures/1284/1284_Minimum_Number_of_Flips_to_Convert_Binary_Matrix_to_Zero_Matrix_1.png" width="500"/>
</center>
<br>
<p>After applying the decisions for the <span class="math inline">\(i^{th}\)</span> row, it changes into:</p>
<center>
<img src="../Figures/1284/1284_Minimum_Number_of_Flips_to_Convert_Binary_Matrix_to_Zero_Matrix_2.png" width="500"/>
</center>
<br>
<p>So we only need to try all the decisions for the first row (index = 0), for each such decision, the decisions for all the following rows are already determined. For each set of first-row decisions, if after applying all the decisions the values in the last row are all 0s, then it's a feasible solution. We're required to find the minimum number of flips of all feasible solutions.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Assume the input matrix is called mat[][] and it has <span class="math inline">\(n\)</span> columns. The algorithm works as follows:</p>
<ol>
<li>Enumerate all the possible decisions for the first row.</li>
<li>Suppose List<Integer> <code>operations</code> is a decision for the first row. Each element is either 0 or 1, indicating whether the corresponding element in <code>mat[0]</code> is flipped or not. We also need to maintain two binary arrays of size <span class="math inline">\(n\)</span> for each row. <code>lastState[]</code> which has values of the previous row and <code>changed[]</code> which represents whether the values in the current row are flipped when working on the previous row.</li>
<li>Initialize <code>lastState</code> = <code>operations</code> (need to transform from List<Integer> to int[]). Initialize <code>changed</code> into all 0s since the <span class="math inline">\(0^{th}\)</span> row doesn't have a previous row.</li>
<li>For each row in mat, use the next step to calculate the <code>state</code> which is initialized to <code>changed</code>.</li>
<li>For each position <code>j</code> in the range [0, n - 1] of the current row, the determined decision is <code>lastState[j]</code>, so change the value of <code>state[j]</code> accordingly, i.e if <code>lastState[j]</code> is 1, flip <code>state[j]</code>, <code>state[j - 1]</code> and <code>state[j + 1]</code> if they exist. Also, increase the counter of flips by 1.</li>
<li>Because of the current row's decision, the values that are flipped in the next row is exactly <code>lastState</code> and the decision for the next row is exactly the <code>state</code> array. So set <code>changed</code> = <code>lastState</code> and <code>lastState</code> = <code>state</code>, then move onto the next row</li>
<li>Once we complete all rows, check whether <code>lastState</code> contains all 0s to determine whether it's a feasible solution.</li>
<li>Return the minimum number of flips for all the feasible solutions that are proposed by step 1.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fhDWa93U/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span> are the number of rows and columns of the input matrix.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(M \cdot N \cdot 2 ^ N)\)</span>.</li>
</ul>
<p>It takes <span class="math inline">\(O(2 ^ N)\)</span> time to list all the possible decisions for the first row (index = 0). And for each such decision, it takes <span class="math inline">\(O(M \cdot N)\)</span> to further apply the uniquely determined decision for each element in the matrix. So the total time complexity is <span class="math inline">\(O(M \cdot N \cdot 2 ^ N)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(N)\)</span>.<br />
We only save/reuse one Integer List of length <span class="math inline">\(N\)</span> to enumerate all possible decisions for the first row (index = 0). And only save 2 int arrays of length <span class="math inline">\(N\)</span> to further apply the uniquely determined decision for each element. So the space complexity is <span class="math inline">\(O(N)\)</span>.</li>
</ul>
<blockquote>
<p>It's possible to transpose the input matrix if M &lt; N to lower the time and space complexities.</p>
</blockquote>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Make Binary Grid Palindromic I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A row or column is considered <strong>palindromic</strong> if its values read the same forward and backward.</p>

<p>You can <strong>flip</strong> any number of cells in <code>grid</code> from <code>0</code> to <code>1</code>, or from <code>1</code> to <code>0</code>.</p>

<p>Return the <strong>minimum</strong> number of cells that need to be flipped to make <strong>either</strong> all rows <strong>palindromic</strong> or all columns <strong>palindromic</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0],[0,0,0],[0,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-20-10.png" style="width: 420px; height: 108px;" /></p>

<p>Flipping the highlighted cells makes all the rows palindromic.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = </span>[[0,1],[0,1],[0,0]]</p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-31-23.png" style="width: 300px; height: 100px;" /></p>

<p>Flipping the highlighted cell makes all the columns palindromic.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>All rows are already palindromic.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Make Binary Grid Palindromic II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A row or column is considered <strong>palindromic</strong> if its values read the same forward and backward.</p>

<p>You can <strong>flip</strong> any number of cells in <code>grid</code> from <code>0</code> to <code>1</code>, or from <code>1</code> to <code>0</code>.</p>

<p>Return the <strong>minimum</strong> number of cells that need to be flipped to make <strong>all</strong> rows and columns <strong>palindromic</strong>, and the total number of <code>1</code>&#39;s in <code>grid</code> <strong>divisible</strong> by <code>4</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0],[0,1,0],[0,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/01/image.png" style="width: 400px; height: 105px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1],[0,1],[0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/08/screenshot-from-2024-07-09-01-37-48.png" style="width: 300px; height: 104px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/01/screenshot-from-2024-08-01-23-05-26.png" style="width: 200px; height: 70px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-operations-to-satisfy-conditions/description" target="_blank" rel="noopener noreferrer">Minimum Number of Operations to Satisfy Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> of size <code>m x n</code>. In one <strong>operation</strong>, you can change the value of <strong>any</strong> cell to <strong>any</strong> non-negative number. You need to perform some <strong>operations</strong> such that each cell <code>grid[i][j]</code> is:</p>

<ul>
	<li>Equal to the cell below it, i.e. <code>grid[i][j] == grid[i + 1][j]</code> (if it exists).</li>
	<li>Different from the cell to its right, i.e. <code>grid[i][j] != grid[i][j + 1]</code> (if it exists).</li>
</ul>

<p>Return the <strong>minimum</strong> number of operations needed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,2],[1,0,2]]</span></p>

<p><strong>Output:</strong> 0</p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/15/examplechanged.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>

<p>All the cells in the matrix already satisfy the properties.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,1,1],[0,0,0]]</span></p>

<p><strong>Output:</strong> 3</p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/03/27/example21.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>

<p>The matrix becomes <code>[[1,0,1],[1,0,1]]</code> which satisfies the properties, by doing these 3 operations:</p>

<ul>
	<li>Change <code>grid[1][0]</code> to 1.</li>
	<li>Change <code>grid[0][1]</code> to 0.</li>
	<li>Change <code>grid[1][2]</code> to 1.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[2],[3]]</span></p>

<p><strong>Output:</strong> 2</p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/31/changed.png" style="width: 86px; height: 277px;padding: 10px; background: #fff; border-radius: .5rem;" /></p>

<p>There is a single column. We can change the value to 1 in each cell using 2 operations.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n, m &lt;= 1000</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Number of Visited Cells in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">monotonic-stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code>. Your initial position is at the <strong>top-left</strong> cell <code>(0, 0)</code>.</p>

<p>Starting from the cell <code>(i, j)</code>, you can move to one of the following cells:</p>

<ul>
	<li>Cells <code>(i, k)</code> with <code>j &lt; k &lt;= grid[i][j] + j</code> (rightward movement), or</li>
	<li>Cells <code>(k, j)</code> with <code>i &lt; k &lt;= grid[i][j] + i</code> (downward movement).</li>
</ul>

<p>Return <em>the minimum number of cells you need to visit to reach the <strong>bottom-right</strong> cell</em> <code>(m - 1, n - 1)</code>. If there is no valid path, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The image above shows one of the paths that visits exactly 4 cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" style="width: 271px; height: 171px;" />
<pre>
<strong>Input:</strong> grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
<strong>Output:</strong> 3
<strong>Explanation: </strong>The image above shows one of the paths that visits exactly 3 cells.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" style="width: 181px; height: 81px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,0],[1,0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> It can be proven that no path exists.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>
	<li><code>grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description" target="_blank" rel="noopener noreferrer">Minimum Obstacle Removal to Reach Corner</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>

<ul>
	<li><code>0</code> represents an <strong>empty</strong> cell,</li>
	<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>
</ul>

<p>You can move up, down, left, or right from and to an empty cell.</p>

<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2-D matrix <code>grid</code>, where each cell is either empty or contains an obstacle. We can remove any obstacle, and our goal is to find the minimum number of obstacles that need to be removed to create a path from the top-left corner to the bottom-right corner.</p>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We can frame this problem as a shortest-path problem with a start and end point, and from each cell, we can move in four directions (up, down, left, right). There are two scenarios for movement:</p>
<ol>
<li>Moving to an empty cell costs nothing (edge weight = 0).</li>
<li>Moving to a cell with an obstacle costs 1 as we must remove it (edge weight = 1).</li>
</ol>
<p>This turns our problem into a graph with edges weighted 0 or 1. The goal is to find the shortest path from the start to the destination using Dijkstra's algorithm.</p>
<p>Weâ€™ll implement Dijkstraâ€™s algorithm using a priority queue, where each element contains the cell's coordinates and the number of obstacles removed to reach it. The queue will be sorted by obstacle count in increasing order. For each element, we explore its four neighbors. If a neighbor contains an obstacle, we increment the obstacle count and add it to the queue for further exploration.</p>
<p>As we explore, weâ€™ll eventually reach the destination cell. Once we do, we return its obstacle count, which is guaranteed to be the minimum, as the queue prioritizes cells with the fewest obstacles.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize a 2D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Set dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.
<ul>
<li>Set all cells in <code>minObstacles</code> to infinity to represent unvisited cells.</li>
</ul>
</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to the value of <code>grid[0][0]</code>, since this is the initial position.</li>
<li>Create a priority queue <code>pq</code> that orders elements based on the number of obstacles encountered.
<ul>
<li>Each element in the queue is an array containing: [obstacles count, row, column]</li>
</ul>
</li>
<li>Add the starting position to the priority queue with its obstacle count.</li>
<li>Enter a loop that continues while <code>pq</code> is not empty:
<ul>
<li>Extract the cell with minimum obstacles from the queue.</li>
<li>If this cell is the target <code>(m-1, n-1)</code>, return the obstacle count.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid:
<ul>
<li>Calculate the new obstacle count by adding the grid value of the new position.</li>
<li>If the new obstacle count is less than the previously recorded count for that cell:</li>
<li>Update the <code>minObstacles</code> array with the new count.</li>
<li>Add the new position to <code>pq</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return -1 if the main loop completes without finding the target (this shouldn't happen).</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Z4CaAqmQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>The priority queue can contain up to <span class="math inline">\(O(m \cdot n)\)</span> elements (all the cells in the grid), making each operation cost <span class="math inline">\(O(\log(m \cdot n))\)</span> time. Thus, the time complexity is <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is dominated by two main components: the <code>minObstacles</code> array and the priority queue, both of which have a complexity of <span class="math inline">\(O(m \cdot n)\)</span>. The <code>directions</code> array and other variables take constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-0-1-breadth-first-search-bfs">Approach 2: 0-1 Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As stated earlier, moving through cells without obstacles has no cost. Therefore, we prioritize exploring neighboring empty cells first, only moving to cells with obstacles when no free cells are left.</p>
<p>We perform a BFS using a deque to manage the queue. When exploring neighboring cells, we add empty cells to the front of the deque for immediate exploration, and cells with obstacles to the back, delaying their exploration.</p>
<p>We maintain a result grid, <code>minObstacles</code>, initialized to infinity (indicating they are unvisited), to track the minimum obstacles encountered at each cell. We'll add the top left cell to the deque and begin our exploration. At each step, we'll pop the top cell in the deque and explore its neighbors. All empty neighbors go to the front of the deque, while others go to the bottom with their obstacle count increased by 1. Simultaneously, we'll update the <code>minObstacles</code> value for each neighboring position.</p>
<p>Once all cells are explored, the value at the bottom-right cell of <code>minObstacles</code> will give the minimum obstacles encountered on the shortest path.</p>
<p>Here's a brief visualization of how the <code>minObstacles</code> matrix is filled up step by step:</p>
<p>!?!../Documents/2290/slideshow.json:702,942!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 2-D array <code>directions</code> containing four pairs of coordinates representing possible movements: right (0,1), left (0,-1), down (1,0), and up (-1,0).</li>
</ul>
<p>Main method <code>minimumObstacles</code>:</p>
<ul>
<li>Store the dimensions of the grid in variables <code>m</code> (rows) and <code>n</code> (columns).</li>
<li>Initialize a 2-D array <code>minObstacles</code> of size <span class="math inline">\(m \times n\)</span> to track minimum obstacles needed to reach each cell.</li>
<li>Initialize all cells in <code>minObstacles</code> with infinity to represent unvisited cells.</li>
<li>Set the starting cell <code>minObstacles[0][0]</code> to 0, as we start from this position.</li>
<li>Create a double-ended queue <code>deque</code> to process cells.
<ul>
<li>Add the starting position to the queue.</li>
</ul>
</li>
<li>Loop while the deque is not empty:
<ul>
<li>Extract the first cell from the queue.</li>
<li>For each possible direction:
<ul>
<li>Calculate new position coordinates.</li>
<li>If the new position is valid and unvisited (<code>minObstacles</code> value is infinity):
<ul>
<li>If the new cell contains an obstacle (value 1):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count plus 1.</li>
<li>Add the new position to the back of the deque.</li>
</ul>
</li>
<li>If the new cell is empty (value 0):
<ul>
<li>Update <code>minObstacles</code> with the current obstacle count.</li>
<li>Add a new position to the front of the deque.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the value in <code>minObstacles[m-1][n-1]</code> representing minimum obstacles removed to reach target.</li>
</ul>
<p>Helper method <code>isValid(row, col)</code>:</p>
<ul>
<li>Return <code>true</code> if the <code>row</code> and <code>col</code> lie within the grid boundaries.</li>
<li>Return <code>false</code> otherwise.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/VbP4ycxv/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>Each of the <span class="math inline">\(m \cdot n\)</span> cells in the grid is visited exactly once because we only process unvisited cells. The deque operations are all <span class="math inline">\(O(1)\)</span>.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The <code>minObstacles</code> array and the deque both take <span class="math inline">\(O(m \cdot n)\)</span> space. All other variables take constant space.</p>
<p>Thus, the space complexity remains <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make a Uni-Value Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer <code>grid</code> of size <code>m x n</code> and an integer <code>x</code>. In one operation, you can <strong>add</strong> <code>x</code> to or <strong>subtract</strong> <code>x</code> from any element in the <code>grid</code>.</p>

<p>A <strong>uni-value grid</strong> is a grid where all the elements of it are equal.</p>

<p>Return <em>the <strong>minimum</strong> number of operations to make the grid <strong>uni-value</strong></em>. If it is not possible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[2,4],[6,8]], x = 2
<strong>Output:</strong> 4
<strong>Explanation:</strong> We can make every element equal to 4 by doing the following: 
- Add x to 2 once.
- Subtract x from 6 once.
- Subtract x from 8 twice.
A total of 4 operations were used.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[1,5],[2,3]], x = 1
<strong>Output:</strong> 5
<strong>Explanation:</strong> We can make every element equal to 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[3,4]], x = 2
<strong>Output:</strong> -1
<strong>Explanation:</strong> It is impossible to make every element equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= x, grid[i][j] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D integer array <code>grid</code>, a number <code>x</code>, and the ability to add or subtract <code>x</code> from any element in the grid any number of times. Our goal is to determine the smallest number of such operations needed to make all elements in the grid equal. If it is impossible to achieve this, we return <code>-1</code>.</p>
<p>We can see that if it is possible to make all elements equal, the optimal final value must be one of the original numbers in the grid, as any other value may require unnecessary extra steps.</p>
<p>For example, given <code>grid = [[2, 4], [6, 8]]</code> and <code>x = 2</code>, we can make all elements equal to <code>10</code> in <code>4 + 3 + 2 + 1 = 10</code> operations. However, this is not optimal because, along the way, we reached a state where all elements were equal to <code>8</code> in just <code>3 + 2 + 1 = 6</code> operations (not the best, but still better). From that point, increasing all numbers by <code>2</code> again is unnecessary.</p>
<hr />
<h3 id="approach-1-sorting-and-median">Approach 1: Sorting and Median</h3>
<h4 id="intuition">Intuition</h4>
<p>First, let's think about when it's possible to make all grid elements equal.</p>
<p>Consider any two numbers in the grid, <code>a</code> and <code>b</code>, and a number <code>x</code>. Suppose we want to make both <code>a</code> and <code>b</code> equal to some value <code>v. The only operation allowed is adding or subtracting </code>x<code>some number of times. This means we must be able to reach</code>v<code>from both</code>a<code>and</code>b<code>using</code>x`.</p>
<p>For this to be possible, the differences <code>v - a</code> and <code>v - b</code> must both be multiples of <code>x</code>, or equivalently:</p>
<p><span class="math inline">\((v - a) \% x = 0 \quad \text{and} \quad (v - b) \% x = 0\)</span></p>
<p>Rearranging this, we get:</p>
<p><span class="math inline">\(a \% x = b \% x = v \% x\)</span></p>
<p>This tells us that all numbers in the grid must have the same remainder when divided by <code>x</code>. Otherwise, it is impossible to transform them into a single value using only <code>x</code>-sized steps.</p>
<p>For example, if <code>grid = [[1, 8], [3, 5]]</code> and <code>x = 2</code>, we cannot make all elements equal to any odd value because <code>8</code> is even, and adding <code>2</code> any number of times will always result in an even number. Similarly, we cannot make all elements equal to any even value because <code>1</code>, <code>3</code>, and <code>5</code> are odd, and adding <code>2</code> will always keep them odd. Since we cannot make all numbers have the same parity, it is impossible to make the grid uni-value.</p>
<p>Thus, our first step is to check if all numbers in the grid have the same remainder when divided by <code>x</code>. If they don't, we immediately return <code>-1</code>. Otherwise, our goal is to find the smallest number of operations required.</p>
<p>To make things easier, note that the arrangement of numbers in the grid doesnâ€™t affect our task at all, since we can apply operations to any number, no matter its position. So, we can simplify the problem by flattening the grid into a one-dimensional array.</p>
<p>Now, which value should we aim to make all numbers equal to?</p>
<ul>
<li>If we pick a value too large, then the smaller numbers will need many additions of <code>x</code> to reach it.</li>
<li>If we pick a value too small, then the larger numbers will need many subtractions of <code>x</code>.</li>
</ul>
<p>A natural choice is the <strong>median</strong> of the numbers.</p>
<p>Why? The median is the balancing point that minimizes the total distance numbers need to move. By choosing the median, we ensure that half of the numbers shift up and the other half shift down, naturally minimizing the total number of operations.<br />
For example, consider <code>grid = [[2, 4], [6, 8]]</code> with <code>x = 2</code>:</p>
<ul>
<li>If we make all values <code>8</code>, we need <code>3 + 2 + 1 + 0 = 6</code> operations.</li>
<li>If we choose <code>4</code> (the median), the operations reduce to <code>1 + 0 + 1 + 2 = 4</code>.</li>
</ul>
<p>In fact, selecting the median of the numbers always results in the smallest number of operations.</p>
<blockquote>
<p>The <strong>median</strong> value of a set of numbers is the value at which half of the numbers in the set are below it, and the other half are above it.</p>
</blockquote>
<details>
<summary>Click here for a formal proof</summary>
<br>
<p>Let's assume that <span class="math inline">\(x = 1\)</span> for simplicity. Define <span class="math inline">\(f(i)\)</span> as the number of operations required to make all elements equal to <span class="math inline">\(a_i\)</span>, where <span class="math inline">\(a\)</span> is the flattened, sorted array containing all elements of the grid. Then:</p>
<p><span class="math display">\[f(i) = (a_i - a_0) + (a_i - a_1) + ... + (a_i - a_{i - 1}) + (a_{i + 1} - a_i) + ... + (a_{mn} - a_i)
\]</span></p>
<p>Similarly, for <span class="math inline">\(f(i - 1)\)</span>:</p>
<p><span class="math display">\[f(i - 1) = (a_{i - 1} - a_0) + (a_{i - 1} - a_1) + ... + (a_{i - 1} - a_{i - 2}) + (a_{i} - a_{i - 1}) + ... + (a_{mn} - a_{i - 1})
\]</span></p>
<p>Subtracting these expressions gives:</p>
<p><span class="math display">\[f(i) - f(i - 1) = i \cdot (a_i - a_{i - 1}) + (mn-i) \cdot (a_{i - 1} -a_i)=(2i - mn)(a_i - a_{i - 1})
\]</span></p>
<p>Since <span class="math inline">\(a_i > a_{i - 1}\)</span>, the sign of <span class="math inline">\(f(i) - f(i - 1)\)</span> depends on <span class="math inline">\(2i - mn\)</span>:</p>
<ul>
<li>If <span class="math inline">\(2 \cdot i < mn\)</span>, then <span class="math inline">\(f(i) < f(i-1)\)</span>, meaning that <span class="math inline">\(f\)</span> is decreasing.</li>
<li>If <span class="math inline">\(2 \cdot i > mn\)</span>, <span class="math inline">\(f(i) > f(i-1)\)</span>, meaning that <span class="math inline">\(f\)</span> is increasing.</li>
</ul>
<p>Thus, the minimum value occurs at <span class="math inline">\(f(\frac{mn}{2})\)</span> or <span class="math inline">\(f(\frac{mn - 1}{2})\)</span>.</p>
</details>
<br>
<p>To find the median, we first sort the array in non-decreasing order and then pick the middle value. Next, we iterate through the array again to calculate how many operations are needed for each number to reach the median, and then we sum these operations.</p>
<blockquote>
<p>In C++, we can avoid fully sorting the array by using the <code>nth_element</code> function. This operation runs in linear time and ensures that the desired element is placed at the index it would occupy in a fully sorted array. For the median, this means the element will be placed at the middle index.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an empty array, called <code>numsArray</code> to store all numbers.</li>
<li>a variable <code>result = 0</code> to store the total number of operations.</li>
</ul>
</li>
<li>Flatten the <code>grid</code> into <code>numsArray</code>, by iterating over its elements and pushing them into it.</li>
<li>Sort <code>numsArray</code> in non-decreasing order.</li>
<li>Initialize <code>length</code> to the size of <code>numsArray</code>.</li>
<li>Store the median of the array (<code>numsArray[length / 2]</code>) in <code>finalCommonNumber</code>.</li>
<li>For each <code>number</code> in <code>numsArray</code>:
<ul>
<li>If <code>number % x != finalCommonNumber % x</code>, return <code>-1</code>, as we found two elements in the array with different remainders when divided by <code>x</code>.</li>
<li>Otherwise, increment <code>result</code> by the number of operations needed for this element to become equal to <code>finalCommonNumber</code>, i.e. <code>abs(finalCommonNumber - number) / x</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/9k3csGTs/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(mn \times \log{mn})\)</span></p>
<p>First, we loop through the gridâ€™s elements to flatten it into a one-dimensional array, which takes <span class="math inline">\(O(mn)\)</span> time. Then, we sort the <code>numsArray</code> in <span class="math inline">\(O(mn \times \log{mn})\)</span>, since it contains <span class="math inline">\(m \cdot n\)</span> elements. Finally, we go through the array, performing constant-time operations (arithmetic and checks) in each step, which takes another <span class="math inline">\(O(mn)\)</span> time. Therefore, the overall time complexity is dominated by the sorting step and is equal to <span class="math inline">\(O(mn \times \log{mn})\)</span>.</p>
<blockquote>
<p>In C++, we replace sorting with the <code>nth_element</code> function, which runs in <span class="math inline">\(O(\frac{mn}{2}) = O(mn)\)</span> time. Therefore, the total time complexity for this implementation is equal to <span class="math inline">\(O(mn)\)</span>.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(mn)\)</span></p>
<p>We create an array to store all numbers in the grid, which requires <span class="math inline">\(O(mn)\)</span> space. Apart from that, we only use a fixed number of variables (<code>finalCommonValue</code>, <code>result</code>, etc.) that take up constant space.</p>
<p>Lastly, we must account for the space that is required for sorting (<span class="math inline">\(S\)</span>), which depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log mn)\)</span>.</li>
<li>In C++, the <code>nth_element()</code> function has a constant space complexity of <span class="math inline">\(O(1)\)</span>, as it performs the rearrangement in-place without requiring additional memory proportional to the size of the input.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(mn)\)</span>.</li>
</ul>
<p>As a result, the space complexity of the algorithm is determined by the size of the <code>numsArray</code> and is equal to <span class="math inline">\(O(mn)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-prefix-and-suffix-sums">Approach 2: Prefix and Suffix Sums</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we discuss an alternative to the greedy solution mentioned earlier. Instead of assuming that the median will always minimize the number of operations, we will check each element to see if it can be the final common value for the grid.</p>
<p>A simple way to do this is to iterate over the elements of the flattened array and consider each one as the potential final value for the grid. For each value, we would loop through the array again to calculate how many operations are needed to make each number equal to this value. Then, we would update the result with the total number of operations. However, this approach uses two nested loops, resulting in quadratic time complexity which is inefficient for the given constraints.</p>
<p>How can we optimize it then?</p>
<p>First, letâ€™s break down the number of operations needed to make all elements equal to <span class="math inline">\(a_i\)</span>. For simplicity, weâ€™ll assume the array is sorted. To calculate the operations required for the smaller elements, we get:</p>
<p><span class="math display">\[\frac{a_i - a_0}{x} + \frac{a_i - a_1}{x} + ... \frac{a_i - a_{i - 1}}{x}
\]</span></p>
<p>As mentioned earlier, if a solution exists, all elements have the same remainder when divided by <span class="math inline">\(x\)</span>, so each fraction is an integer. In that case, the sum can be simplified as:</p>
<p><span class="math display">\[\frac{i \cdot a_i - (a_0 + a_1 + ... + a_{i - 1})}{x}
\]</span></p>
<p>Notice that <span class="math inline">\(a_0 + a_1 + ... + a_{i - 1}\)</span> is a fixed value â€” the sum of the array up to index <span class="math inline">\(i\)</span>, also known as the prefix sum.<br />
Similarly, for the greater elements, the operations can be expressed as:</p>
<p><span class="math display">\[\frac{(a_{i + 1} + a_{i + 2} + ... + a_{\text{length} - 1}) - (\text{length} - i - 1) \cdot a_i}{x}
\]</span></p>
<p>This is related to the suffix sum from index <span class="math inline">\(i\)</span> onward.</p>
<p>With the prefix and suffix sums precomputed, we can quickly calculate the number of operations needed for each potential final value in constant time.</p>
<p>As in the previous approach, we begin by flattening the grid into a one-dimensional array and checking if all elements have the same remainder when divided by <code>x</code>. If they do, we calculate the prefix and suffix sum arrays and iterate over the array again to compute the number of operations for each potential common value, updating the result with the smallest number of operations.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an empty array, called <code>numsArray</code> to store all numbers.</li>
<li>a variable <code>result = INF</code> to store the smallest number of required operations.</li>
</ul>
</li>
<li>For each element <code>grid[row][col]</code>:
<ul>
<li>If <code>grid[row][col] % x != grid[0][0] % x</code>, return <code>-1</code>, since we found two elements with different remainders when divided by <code>x</code>.</li>
<li>Otherwise, push <code>grid[row][col]</code> into <code>numsArray</code>.</li>
</ul>
</li>
<li>Sort <code>numsArray</code> in non-decreasing order.</li>
<li>Initialize <code>length</code> to the size of <code>numsArray</code>.</li>
<li>Create two arrays, called <code>prefixSum</code> and <code>suffixSum</code>, of size <code>length</code> with all elements initially set to <code>0</code>.</li>
<li>Loop over <code>numsArray</code> with <code>index</code> from <code>1</code> to <code>length - 1</code>:
<ul>
<li>Calculate the prefix sum up to <code>index</code>, excluding <code>numsArray[index]</code>, as <code>prefixSum[index] = prefixSum[index - 1] + numsArray[index - 1]</code>.</li>
</ul>
</li>
<li>Loop over <code>numsArray</code> in reverse with <code>index</code> from <code>length - 2</code> to <code>0</code>:
<ul>
<li>Calculate the suffix sum from <code>index</code>, excluding <code>numsArray[index]</code>, as <code>suffixSum[index] = suffixSum[index + 1] + numsArray[index + 1]</code>.</li>
</ul>
</li>
<li>Loop over <code>numsArray</code> one more time to calculate the number of operations required for each potential final value:
<ul>
<li>Calculate <code>leftOperations</code> as <code>(numsArray[index] * index - prefixSum[index]) / x</code>.</li>
<li>Calculate <code>rightOperations</code> as <code>(suffixSum[index] - numsArray[index] * (length - index - 1)) / x</code>.</li>
<li>Update the result with the minimum of its current value and <code>leftOperations + rightOperations</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/RqtDUKLk/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(mn \times \log{mn})\)</span></p>
<p>As in the previous approach, we first flatten the grid into a one-dimensional array, which takes <span class="math inline">\(O(mn)\)</span> time. We then sort the array in <span class="math inline">\(O(mn \times \log{mn})\)</span> time. After that, we perform three separate loops, each running exactly <span class="math inline">\(mn\)</span> times and performing constant-time operations in each iteration. These loops calculate the prefix and suffix sum arrays and, ultimately, the smallest number of operations required. As a result, the overall time complexity is again dominated by the sorting step, making it <span class="math inline">\(O(mn \times \log{mn})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(mn)\)</span></p>
<p>We create three arrays, <code>numsArray</code>, <code>prefixSum</code>, and <code>suffixSum</code>, each of size <span class="math inline">\(mn\)</span>. Sorting <code>numsArray</code> may require additional space: <span class="math inline">\(O(\log {mn})\)</span> in C++ and Java (for in-place sorting algorithms like Quicksort) and <span class="math inline">\(O(mn)\)</span> in Python (for Timsort, which uses extra space for merges). However, the dominant factor in space complexity is the auxiliary arrays, leading to an overall space complexity of <span class="math inline">\(O(mn)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointers">Approach 3: Two Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we donâ€™t start by fixing the final common value of the grid. Instead, we take a gradual approach. We progressively make all elements equal by extending the prefix and suffix of the flattened array that already contain equal elements.</p>
<p>We initialize two pointers, <code>prefixIndex</code> and <code>suffixIndex</code>, which start at the first and last elements of the sorted, flattened array, respectively. Our goal is to move these pointers toward the middle until they meet.</p>
<p>To move <code>prefixIndex</code>, we need to ensure that all elements up to <code>prefixIndex + 1</code> are equal. The number of operations required to achieve this can be calculated inductively. Suppose the first <code>prefixIndex</code> elements are already equal. To make them equal to <code>a[prefixIndex + 1]</code>, we need <code>prefixIndex * (a[prefixIndex + 1] - a[prefixIndex]) / x</code> operations.</p>
<p>Similarly, we determine the number of operations needed to move <code>suffixIndex</code> closer to the middle by making all elements in the corresponding suffix equal. In each step, we extend either the prefix or the suffix, choosing the one with fewer elements at that point.</p>
<p>By following this process, we gradually make all elements equal to the median of the array, which matches our original strategy.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>an empty array, called <code>numsArray</code> to store all numbers.</li>
<li>a variable <code>result = 0</code> to count the smallest number of required operations.</li>
</ul>
</li>
<li>For each element <code>grid[row][col]</code>:
<ul>
<li>If <code>grid[row][col] % x != grid[0][0] % x</code>, return <code>-1</code>, since we found two elements with different remainders when divided by <code>x</code>.</li>
<li>Otherwise, push <code>grid[row][col]</code> into <code>numsArray</code>.</li>
</ul>
</li>
<li>Sort <code>numsArray</code> in non-decreasing order.</li>
<li>Initialize:
<ul>
<li><code>length</code> to the size of <code>numsArray</code>.</li>
<li><code>prefixIndex</code> to <code>0</code>.</li>
<li><code>suffixIndex</code> to <code>length - 1</code>.</li>
</ul>
</li>
<li>While <code>prefixIndex &lt; suffixIndex</code>, meaning that we have more elements to process:
<ul>
<li>If the prefix of equal elements is currently shorter than the suffix, i.e., <code>prefixIndex &lt; length - suffixIndex + 1</code>:
<ul>
<li>Calculate <code>prefixOperations</code> as <code>(prefixIndex + 1) * (numsArray[prefixIndex + 1] - numsArray[prefixIndex]) / x</code>.</li>
<li>Increment <code>result</code> by <code>prefixOperations</code>, i.e., the number of operations needed to make the first <code>prefixIndex + 1</code> elements equal.</li>
<li>Increment <code>prefixIndex</code> by <code>1</code>.</li>
</ul>
</li>
<li>Otherwise:
<ul>
<li>Calculate <code>suffixOperations</code> as <code>(length - suffixIndex) * (numsArray[suffixIndex] - numsArray[suffixIndex - 1]) / x</code>.</li>
<li>Increment <code>result</code> by <code>suffixOperations</code>, i.e., the number of operations required to make the last <code>length - suffixIndex</code> elements of the array equal.</li>
<li>Decrement <code>suffixIndex</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/PKKUmw66/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns in the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(mn \times \log{mn})\)</span></p>
<p>Like in the previous approaches, we first flatten the grid in <span class="math inline">\(O(mn)\)</span> time and sort it in <span class="math inline">\(O(mn \times \log{mn})\)</span> time. Then, we make a final pass over its elements using the two pointers, which requires another <span class="math inline">\(O(mn)\)</span> time. Therefore, the overall time complexity, dominated by the sorting step, is equal to <span class="math inline">\(O(mn \log {mn})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(mn)\)</span></p>
<p>The algorithm uses only the <code>numsArray</code> that contains exactly <span class="math inline">\(mn\)</span> elements along with a fixed number of variables (<code>result</code>, <code>prefixIndex</code>, <code>suffixIndex</code>, etc.). Sorting the array requires extra space <span class="math inline">\(S\)</span>, which depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log mn)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log mn)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(mn)\)</span>.</li>
</ul>
<p>Overall, the space complexity is bounded by the size of the <code>numsArray</code>, and therefore it remains equal to <span class="math inline">\(O(mn)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-219">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-make-columns-strictly-increasing/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Make Columns Strictly Increasing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers.</p>

<p>In one operation, you can increment the value of any <code>grid[i][j]</code> by 1.</p>

<p>Return the <strong>minimum</strong> number of operations needed to make all columns of <code>grid</code> <strong>strictly increasing</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,2],[1,3],[3,4],[0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>To make the <code>0<sup>th</sup></code> column strictly increasing, we can apply 3 operations on <code>grid[1][0]</code>, 2 operations on <code>grid[2][0]</code>, and 6 operations on <code>grid[3][0]</code>.</li>
	<li>To make the <code>1<sup>st</sup></code> column strictly increasing, we can apply 4 operations on <code>grid[3][1]</code>.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2024/11/10/firstexample.png" style="width: 200px; height: 347px;" /></div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,2,1],[2,1,0],[1,2,3]]</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<ul>
	<li>To make the <code>0<sup>th</sup></code> column strictly increasing, we can apply 2 operations on <code>grid[1][0]</code>, and 4 operations on <code>grid[2][0]</code>.</li>
	<li>To make the <code>1<sup>st</sup></code> column strictly increasing, we can apply 2 operations on <code>grid[1][1]</code>, and 2 operations on <code>grid[2][1]</code>.</li>
	<li>To make the <code>2<sup>nd</sup></code> column strictly increasing, we can apply 2 operations on <code>grid[1][2]</code>.</li>
</ul>
<img alt="" src="https://assets.leetcode.com/uploads/2024/11/10/secondexample.png" style="width: 300px; height: 257px;" /></div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt; 2500</code></li>
</ul>

<p>&nbsp;</p>
<div class="spoiler">
<div>
<pre>

&nbsp;</pre>
</div>
</div>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-220">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-operations-to-write-the-letter-y-on-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Operations to Write the Letter Y on a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>n x n</code> grid where <code>n</code> is odd, and <code>grid[r][c]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<p>We say that a cell belongs to the Letter <strong>Y</strong> if it belongs to one of the following:</p>

<ul>
	<li>The diagonal starting at the top-left cell and ending at the center cell of the grid.</li>
	<li>The diagonal starting at the top-right cell and ending at the center cell of the grid.</li>
	<li>The vertical line starting at the center cell and ending at the bottom border of the grid.</li>
</ul>

<p>The Letter <strong>Y</strong> is written on the grid if and only if:</p>

<ul>
	<li>All values at cells belonging to the Y are equal.</li>
	<li>All values at cells not belonging to the Y are equal.</li>
	<li>The values at cells belonging to the Y are different from the values at cells not belonging to the Y.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to</em> <code>0</code><em>,</em> <code>1</code><em>,</em> <em>or</em> <code>2</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/22/y2.png" style="width: 461px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,2],[1,1,0],[0,1,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 1 while those that do not belong to Y are equal to 0.
It can be shown that 3 is the minimum number of operations needed to write Y on the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2024/01/22/y3.png" style="width: 701px; height: 201px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]
<strong>Output:</strong> 12
<strong>Explanation:</strong> We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 0 while those that do not belong to Y are equal to 2. 
It can be shown that 12 is the minimum number of operations needed to write Y on the grid.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= n &lt;= 49 </code></li>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 2</code></li>
	<li><code>n</code> is odd.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-221">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-path-cost-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Path Cost in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> consisting of <strong>distinct</strong> integers from <code>0</code> to <code>m * n - 1</code>. You can move in this matrix from a cell to any other cell in the <strong>next</strong> row. That is, if you are in cell <code>(x, y)</code> such that <code>x &lt; m - 1</code>, you can move to any of the cells <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code>. <strong>Note</strong> that it is not possible to move from cells in the last row.</p>

<p>Each possible move has a cost given by a <strong>0-indexed</strong> 2D array <code>moveCost</code> of size <code>(m * n) x n</code>, where <code>moveCost[i][j]</code> is the cost of moving from a cell with value <code>i</code> to a cell in column <code>j</code> of the next row. The cost of moving from cells in the last row of <code>grid</code> can be ignored.</p>

<p>The cost of a path in <code>grid</code> is the <strong>sum</strong> of all values of cells visited plus the <strong>sum</strong> of costs of all the moves made. Return <em>the <strong>minimum</strong> cost of a path that starts from any cell in the <strong>first</strong> row and ends at any cell in the <strong>last</strong> row.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png" style="width: 301px; height: 281px;" />
<pre>
<strong>Input:</strong> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]
<strong>Output:</strong> 17
<strong>Explanation: </strong>The path with the minimum possible cost is the path 5 -&gt; 0 -&gt; 1.
- The sum of the values of cells visited is 5 + 0 + 1 = 6.
- The cost of moving from 5 to 0 is 3.
- The cost of moving from 0 to 1 is 8.
So the total cost of the path is 6 + 3 + 8 = 17.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The path with the minimum possible cost is the path 2 -&gt; 3.
- The sum of the values of cells visited is 2 + 3 = 5.
- The cost of moving from 2 to 3 is 1.
So the total cost of this path is 5 + 1 = 6.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 50</code></li>
	<li><code>grid</code> consists of distinct integers from <code>0</code> to <code>m * n - 1</code>.</li>
	<li><code>moveCost.length == m * n</code></li>
	<li><code>moveCost[i].length == n</code></li>
	<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-222">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-path-sum/description" target="_blank" rel="noopener noreferrer">Minimum Path Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>

<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]
<strong>Output:</strong> 12
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-223">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/description" target="_blank" rel="noopener noreferrer">Minimum Swaps to Arrange a Binary Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> binary <code>grid</code>, in one step you can choose two <strong>adjacent rows</strong> of the grid and swap them.</p>

<p>A grid is said to be <strong>valid</strong> if all the cells above the main diagonal are <strong>zeros</strong>.</p>

<p>Return <em>the minimum number of steps</em> needed to make the grid valid, or <strong>-1</strong> if the grid cannot be valid.</p>

<p>The main diagonal of a grid is the diagonal that starts at cell <code>(1, 1)</code> and ends at cell <code>(n, n)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/28/fw.jpg" style="width: 750px; height: 141px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1],[1,1,0],[1,0,0]]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/16/e2.jpg" style="width: 270px; height: 270px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> All rows are similar, swaps have no effect on the grid.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/16/e3.jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,1]]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code> <code>== grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-224">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description" target="_blank" rel="noopener noreferrer">Minimum Time to Visit a Cell In a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">graph</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">shortest-path</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> matrix <code>grid</code> consisting of <b>non-negative</b> integers where <code>grid[row][col]</code> represents the <strong>minimum</strong> time required to be able to visit the cell <code>(row, col)</code>, which means you can visit the cell <code>(row, col)</code> only when the time you visit it is greater than or equal to <code>grid[row][col]</code>.</p>

<p>You are standing in the <strong>top-left</strong> cell of the matrix in the <code>0<sup>th</sup></code> second, and you must move to <strong>any</strong> adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.</p>

<p>Return <em>the <strong>minimum</strong> time required in which you can visit the bottom-right cell of the matrix</em>. If you cannot visit the bottom-right cell, then return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png" /></p>

<pre>
<strong>Input:</strong> grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> One of the paths that we can take is the following:
- at t = 0, we are on the cell (0,0).
- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.
- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.
- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.
- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.
- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.
- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.
- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.
The final time is 7. It can be shown that it is the minimum time possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png" style="width: 151px; height: 151px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,2,4],[3,2,1],[1,0,4]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no path from the top left to the bottom-right cell.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>grid[0][0] == 0</code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-modified-dijkstras-algorithm">Approach: Modified Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a matrix <code>grid</code> where each cell contains the minimum time required for that cell to be accessible. In other words, if we begin at the top-left cell and each move takes 1 second, the value in each cell tells us the minimum time after which we can enter it.</p>
<p>The challenge arises when we find ourselves stuck in a cell, unable to move forward because all neighboring cells are inaccessible, with higher minimum times. In such situations, we must &quot;waste&quot; time to move forward. How do we do that? By wandering around! We can move back and forth between the current cell and any previously accessible cells until a neighboring cell becomes accessible.</p>
<p>The time we need to &quot;waste&quot; is determined by the difference between the current cellâ€™s time and the minimum time of an accessible neighboring cell. Itâ€™s important to note that each unit of time wasted takes 2 seconds since we travel to a previous cell and return to the current cell. Therefore, if the difference between the current time and the target cell's time is odd, we can step into the target cell exactly when it becomes accessible. Here's a slideshow demonstrating that:</p>
<p>!?!../Documents/2577/odd_slideshow.json:564,822!?!</p>
<p>On the other hand, if the difference is even, weâ€™ll arrive at the target cell 1 second after it has opened:</p>
<p>!?!../Documents/2577/even_slideshow.json:564,822!?!</p>
<p>Next, letâ€™s discuss the base case. If we are at the top-left corner and all neighboring cells have a minimum time greater than 1, we are stuck. There are no other accessible cells to waste time on, and thus, the solution is not possible. In this case, we return -1.</p>
<p>Otherwise, a solution exists. We can apply Dijkstraâ€™s shortest path algorithm with a priority queue, starting from the top-left cell. Each element in the queue holds the cellâ€™s coordinates and the time taken to reach it, ordered by time in ascending order. We also maintain a <code>visited</code> matrix to track the cells we have already processed. For each cell in the queue, we check its neighbors, compute the time required to enter each one, and add any accessible neighbors to the queue, adjusting for the waiting time. When we reach the bottom-right corner, we return the associated time as the final answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Check if both initial moves (right and down) in the grid require more than 1 second:</p>
<ul>
<li>If both <code>grid[0][1] &gt; 1</code> and <code>grid[1][0] &gt; 1</code>, return <code>-1</code> because itâ€™s impossible to proceed.</li>
</ul>
</li>
<li>
<p>Initialize variables:</p>
<ul>
<li><code>rows</code> and <code>cols</code> store the dimensions of the grid.</li>
<li><code>directions</code> array defines the possible moves: down, up, right, and left.</li>
<li><code>visited</code> array keeps track of visited cells.</li>
<li><code>pq</code> is a priority queue that stores <code>{time, row, col}</code> tuples, ordered by minimum time to reach each cell.</li>
</ul>
</li>
<li>
<p>Add the starting point (top-left cell) to the priority queue with its initial time (<code>grid[0][0]</code>).</p>
</li>
<li>
<p>While the priority queue is not empty:</p>
<ul>
<li>
<p>Poll the cell with the minimum time (<code>time, row, col</code>).</p>
</li>
<li>
<p>If the target cell (bottom-right) is reached, return the <code>time</code>.</p>
</li>
<li>
<p>Skip the current cell if it has already been visited.</p>
</li>
<li>
<p>Mark the current cell as visited.</p>
</li>
<li>
<p>For each of the four possible directions:</p>
<ul>
<li>Calculate the next cell coordinates (<code>nextRow, nextCol</code>).</li>
<li>If the cell is valid (within bounds and not visited), calculate the additional wait time for the next cell:
<ul>
<li>If the difference between the grid value and the current time is even, the additional wait time is <code>1</code>.</li>
<li>Otherwise, the wait time is <code>0</code>.</li>
</ul>
</li>
<li>Calculate the next possible time based on the grid value and the wait time, and add the new <code>{nextTime, nextRow, nextCol}</code> to the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the loop ends without reaching the target, return <code>-1</code> (no path found).</p>
</li>
<li>
<p>Helper function <code>isValid</code>:</p>
<ul>
<li>Check if a cell is within bounds and has not been visited.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/J2vnwBjv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns in the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \log(m \cdot n))\)</span></p>
<p>In the main loop, the priority queue operations (insertion and deletion) take <span class="math inline">\(O(\log k)\)</span> time where <span class="math inline">\(k\)</span> is the number of elements in the queue. Since each cell is added to the queue exactly once, the queue size is bounded by <span class="math inline">\(O(m \cdot n)\)</span>. Therefore, with <span class="math inline">\(O(m \cdot n)\)</span> cells and <span class="math inline">\(O(\log(m \cdot n))\)</span> time for each queue operation, the total time complexity is <span class="math inline">\(O(m \cdot n\log(m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>The space complexity is determined by two main components: the <code>visited</code> boolean matrix and the priority queue, both of which use <span class="math inline">\(O(m \cdot n)\)</span> space.</p>
<p>Thus, the space complexity of the algorithm is <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-225">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/missing-number-in-matrix5316/1" target="_blank" rel="noopener noreferrer">Missing number in matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a matrix of size <strong>n x n</strong>&nbsp;such that it has only <strong>one</strong> <strong>0</strong>, Find the <strong>positive&nbsp;number</strong>&nbsp;(greater than zero) to be placed in place of the 0&nbsp;such that sum of the numbers in every row, column and two diagonals become equal. If no such number exists, return -1.</p>
<p><strong>Note:</strong>&nbsp;Diagonals should be only of the form matrix[i][i]&nbsp;and matrix[i][n-i-1]. <strong>n</strong> is always greater than 1. The <strong>answer</strong> can be greater than&nbsp;<strong>10<sup>9</sup></strong>.<span style="font-size: 10.8333px;">&nbsp;</span><br />&nbsp;</p>
<p><strong>Example 1:</strong></p>
<pre><strong>Input: </strong>matrix = {{5, 5}, {5, 0}}
<strong>Output: </strong>5
<strong>Explanation: </strong>The matrix is
5 5
5 0
Therefore If we place 5 instead of 0, all
the element of matrix will become 5. 
Therefore row 5+5=10, column 5+5=10 and 
diagonal 5+5=10, all are equal.</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input: </strong>matrix = {{1, 2, 0}, {3, 1, 2}, 
{2, 3, 1}}
<strong>Output: </strong>-1
<strong>Explanation: </strong>It is not possible to insert 
an element in place of 0 so that the 
condition is satisfied.thus result is -1.&nbsp;

</pre>
<p><strong>Your Task:</strong><br />You don't need to read or print anyhting. Your task is to complete the function&nbsp;<strong>MissingNo()&nbsp;</strong>which takes the matrix as input parameter and returns the number which should be placed in place of 0 such that the condition gets satisfied. If not possible return -1.<br />&nbsp;</p>
<p><strong>Expected Time Complexity:&nbsp;</strong>O(n * n)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(2 * n)<br />&nbsp;</p>
<p><strong>Constraints:</strong><br />2 &lt;= n &lt;= 1000<br />1 &lt;= elements in the matrix &lt;= 10^9</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-226">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/modify-the-matrix/description" target="_blank" rel="noopener noreferrer">Modify the Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>matrix</code>, create a new <strong>0-indexed</strong> matrix called <code>answer</code>. Make <code>answer</code> equal to <code>matrix</code>, then replace each element with the value <code>-1</code> with the <strong>maximum</strong> element in its respective column.</p>

<p>Return <em>the matrix</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/24/matrix1.png" style="width: 491px; height: 161px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
<strong>Output:</strong> [[1,2,9],[4,8,6],[7,8,9]]
<strong>Explanation:</strong> The diagram above shows the elements that are changed (in blue).
- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.
- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/24/matrix2.png" style="width: 411px; height: 111px;" />
<pre>
<strong>Input:</strong> matrix = [[3,-1],[5,2]]
<strong>Output:</strong> [[3,2],[5,2]]
<strong>Explanation:</strong> The diagram above shows the elements that are changed (in blue).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 50</code></li>
	<li><code>-1 &lt;= matrix[i][j] &lt;= 100</code></li>
	<li>The input is generated such that each column contains at least one non-negative integer.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-227">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-frequent-prime/description" target="_blank" rel="noopener noreferrer">Most Frequent Prime</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <code>m x n</code> <strong>0-indexed </strong>2D<strong> </strong>matrix <code>mat</code>. From every cell, you can create numbers in the following way:</p>

<ul>
	<li>There could be at most <code>8</code> paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.</li>
	<li>Select a path from them and append digits in this path to the number being formed by traveling in this direction.</li>
	<li>Note that numbers are generated at every step, for example, if the digits along the path are <code>1, 9, 1</code>, then there will be three numbers generated along the way: <code>1, 19, 191</code>.</li>
</ul>

<p>Return <em>the most frequent <span data-keyword="prime-number">prime number</span> <strong>greater</strong> than </em><code>10</code><em> out of all the numbers created by traversing the matrix or </em><code>-1</code><em> if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the <b>largest</b> among them.</em></p>

<p><strong>Note:</strong> It is invalid to change the direction during the move.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2024/02/15/south" style="width: 641px; height: 291px;" /> </strong>

<pre>
<strong>
Input:</strong> mat = [[1,1],[9,9],[1,1]]
<strong>Output:</strong> 19
<strong>Explanation:</strong> 
From cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:
East: [11], South-East: [19], South: [19,191].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].
The most frequent prime number among all the created numbers is 19.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[7]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[9,7,8],[4,6,5],[2,8,6]]
<strong>Output:</strong> 97
<strong>Explanation:</strong> 
Numbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].
Numbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].
Numbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].
Numbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].
The most frequent prime number among all the created numbers is 97.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 6</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-228">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/multiply-2-matrices4144/1" target="_blank" rel="noopener noreferrer">Multiply 2 matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two square matrices <strong data-start="177" data-end="182">mat1[][]</strong> and <strong data-start="187" data-end="192">mat2[][]</strong>, each of size <strong>n &times; n</strong>. You have to <strong data-start="236" data-end="267">multiply </strong>these two matrices and return the resulting matrix.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat1[][] = [[1, 1, 1], mat2[][] = [[1, 1, 1],
                 [1, 1, 1],             [1, 1, 1],
                 [1, 1, 1]]             [1, 1, 1]]
<strong>Output: </strong>[[3, 3, 3],<br />        [3, 3, 3],<br />        [3, 3, 3]]<br /><strong>Explanation: </strong>After multiplying mat1 and mat2 we get the resulting matrix </span><span style="font-size: 14pt;">equal to</span> <span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">[[3, 3, 3], [3, 3, 3], [3, 3, 3]].</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">mat1[][] = [[1, 2], mat2[][] = [[4, 3],
                 [3, 4]]             [2, 1]]</span>
<strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">[[8, 5],<br />       [20, 13]]<br /></span></span><span style="font-size: 14pt;"><strong>Explanation: </strong>After multiplying mat1 and mat2 we get the resulting matrix equal to <span style="color: #000000;">[[8, 5], [20, 13]]</span></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 100<br />1 &le; mat1[i][j], mat2[i][j] &le; 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-229">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/multiply-matrices/1" target="_blank" rel="noopener noreferrer">Multiply Matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given two square Matrices A[][] and B[][]. Your task is to complete the function <strong>multiply</strong> which stores the multiplied matrices&nbsp;in a new matrix C[][].</span><br />
&nbsp;</p>

<p><strong><span style="font-size:20px">Example 1:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>
N = 2
A[][] = {{7, 8}, {2 , 9}}
B[][] = {{14, 5}, {5, 18}}</span>

<span style="font-size:18px"><strong>Output: </strong>
C[][] = {{138, 179}, {73, 172}}</span></pre>

<p>&nbsp;</p>

<p><strong><span style="font-size:20px">Example 2:</span></strong></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>
N = 2
A[][] = {{17, 4}, {17 , 16}}
B[][] = {{9, 2}, {7, 1}}</span>

<span style="font-size:18px"><strong>Output: </strong>
C[][] = {{181, 38}, {265, 50}}</span></pre>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;=T&lt;= 100<br />
1 &lt;= N &lt;= 20</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-230">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/multiply-the-matrices-1587115620/1" target="_blank" rel="noopener noreferrer">Multiply the matrices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two matrices mat1[][] and mat2[][] of size (4x4). Find whether the resultant res[][] matrix is equal to the multiplication of both the matrices.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat1[][]= [[1, 2, 3, 4], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],<br />       mat2[][]= </span><span style="font-size: 14pt;">[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],<br />       res[][]= [[1, 2, 3, 4], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]<br /></span><span style="font-size: 18px;"><strong>Output:</strong> true
<strong>Explanation: </strong>Matrices are of size 4x4 and 4x4 which results in 4x4 matrix with elements as:
res[][] = </span><span style="font-size: 14pt;">[[1, 2, 3, 4], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat1[][]= [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [1, 2, 3, 4]],<br />       mat2[][]= </span><span style="font-size: 14pt;">[[1, 0, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 0]],<br />       res[][]= [[0, 1, 4, 4], [12, 5, 14, 12], [20, 20, 21, 20], [1, 6, 8, 9]]<br /></span><span style="font-size: 18px;"><strong>Output:</strong> false
<strong>Explanation: </strong>Matrices are of size 4x4 and 4x4 which results in 4x4 matrix with elements as:
res[][] = </span><span style="font-size: 14pt;">[[4, 6, 6, 4], [12, 14, 14, 12], [20, 22, 22, 20], [4, 6, 6, 4]]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">0 &lt;= mat1[i], mat2[i] &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-231">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/nearest-exit-from-entrance-in-maze/description" target="_blank" rel="noopener noreferrer">Nearest Exit from Entrance in Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>maze</code> (<strong>0-indexed</strong>) with empty cells (represented as <code>&#39;.&#39;</code>) and walls (represented as <code>&#39;+&#39;</code>). You are also given the <code>entrance</code> of the maze, where <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> denotes the row and column of the cell you are initially standing at.</p>

<p>In one step, you can move one cell <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the <strong>nearest exit</strong> from the <code>entrance</code>. An <strong>exit</strong> is defined as an <strong>empty cell</strong> that is at the <strong>border</strong> of the <code>maze</code>. The <code>entrance</code> <strong>does not count</strong> as an exit.</p>

<p>Return <em>the <strong>number of steps</strong> in the shortest path from the </em><code>entrance</code><em> to the nearest exit, or </em><code>-1</code><em> if no such path exists</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg" style="width: 333px; height: 253px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;,&quot;.&quot;]], entrance = [1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;]], entrance = [1,0]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg" style="width: 173px; height: 93px;" />
<pre>
<strong>Input:</strong> maze = [[&quot;.&quot;,&quot;+&quot;]], entrance = [0,0]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no exits in this maze.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>maze.length == m</code></li>
	<li><code>maze[i].length == n</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>maze[i][j]</code> is either <code>&#39;.&#39;</code> or <code>&#39;+&#39;</code>.</li>
	<li><code>entrance.length == 2</code></li>
	<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>
	<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>
	<li><code>entrance</code> will always be an empty cell.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-232">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-closed-islands/description" target="_blank" rel="noopener noreferrer">Number of Closed Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D&nbsp;<code>grid</code> consists of <code>0s</code> (land)&nbsp;and <code>1s</code> (water).&nbsp; An <em>island</em> is a maximal 4-directionally connected group of <code><font face="monospace">0</font>s</code> and a <em>closed island</em>&nbsp;is an island <strong>totally</strong>&nbsp;(all left, top, right, bottom) surrounded by <code>1s.</code></p>

<p>Return the number of <em>closed islands</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png" style="width: 240px; height: 120px;" /></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Islands in gray are closed because they are completely surrounded by water (group of 1s).</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png" style="width: 160px; height: 80px;" /></p>

<pre>
<strong>Input:</strong> grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1,1],
&nbsp;              [1,0,0,0,0,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,1,0,1,0,1],
&nbsp;              [1,0,1,1,1,0,1],
&nbsp;              [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
<strong>Output:</strong> 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a 2D <code>grid</code>. Each cell of <code>grid</code> represents a land or water cell denoted by <code>0</code> and <code>1</code> respectively.</p>
<p>Our task is to return the number of closed islands where a closed island is an island totally (all left, top, right, bottom) surrounded by <code>1s</code>.</p>
<hr />
<h3 id="approach-1-breadth-first-search">Approach 1: Breadth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem states that an island is formed by connecting all of the '0s' in all four directions (left, top, right, and bottom), which leads us to model the problem as a graph.</p>
<p>We can treat the 2D grid as an undirected graph. A land cell in <code>grid</code> corresponds to a node in such a graph with an undirected edge between horizontally or vertically adjacent land cells.</p>
<p>Let's see what forms an island in such a graph. So, we begin at any node and proceed to its neighbors, i.e., all nodes one edge away. From the nodes 1 edge away, we move to their neighbors, i.e., all the nodes 2 edges away from the starting node, and so on. If we keep traversing until we can't anymore, all the nodes that are visited in this traversal together form an island.</p>
<p>While traversing the island, we look to see if any node in the graph corresponds to a cell at the <code>grid</code>'s boundary. The island does not form a closed island if any node on it is on the <code>grid</code>'s boundary. Otherwise, a closed island is formed if there is no node on the <code>grid</code>'s boundary.</p>
<p>We can use a graph traversal algorithm like breadth-first search (BFS) to traverse over the islands. BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l + 1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Leetcode Explore Card</a>.</p>
<p>We perform a BFS from every unvisited land cell, treating it as a node. While traversing the island, we check if any node in the island is present on the <code>grid</code>'s boundary. If we have such a node, the island is not a closed island. Otherwise, we have a closed island if we never visit a cell at the <code>grid</code>'s edge. As a result, we add one to our answer variable.</p>
<p>It is important to note that we will not stop the BFS traversal if we come across a node on the boundary. We will perform the complete BFS traversal to cover the entire island so that we can mark all the nodes of the island and not visit any of its nodes again.</p>
<p>Here's a visual step-by-step example:</p>
<p>!?!../Documents/1254/1254_number_of_closed_islands.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a BFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, <code>m</code>, <code>n</code>, <code>grid</code> and <code>visit</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which BFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>We initialize a queue <code>q</code> of pair of integers and push <code>(x, y)</code> into it. We also mark <code>(x, y)</code> as visited.</li>
<li>Create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>While the queue is not empty, we dequeue the first pair <code>(x, y)</code> from the queue and iterate over all its neighbors. If any neighboring cell is not in bounds of <code>grid</code>, it means the current <code>(x, y)</code> cell is present at the boundary of <code>grid</code>. We do not have a closed island, and we mark <code>isClosed = false</code>. For each neighboring cell, we check if it is a land cell or not. If it is a land cell and has not been visited yet, we mark it as visited and push <code>(r, c)</code> into the queue.</li>
<li>After the queue is empty, we return <code>isClosed</code>.</li>
<li>If <code>bfs</code> returns <code>true</code>, we increment <code>count</code> by 1 .</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kUdyBASY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform BFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>Each queue operation in the BFS algorithm takes <span class="math inline">\(O(1)\)</span> time, and a single node can be pushed once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The BFS queue takes <span class="math inline">\(O(m \cdot n)\)</span> space in the worst-case because each node is added once.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we have to traverse over <code>grid</code> modeled as a graph to find the closed islands, another method is to use a depth-first search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the number of rows and columns in the given <code>grid</code>.</li>
<li>Create an answer variable <code>count</code> to keep track of the number of closed islands in <code>grid</code>. We initialize it with <code>0</code>.</li>
<li>Create a 2D array called <code>visit</code> to keep track of visited cells.</li>
<li>Iterate over all the cells of <code>grid</code> and for every cell <code>(i, j)</code> check if it is a land cell or not. If it is a land cell and it has not been visited yet, begin a DFS traversal from <code>(i, j)</code> cell:
<ul>
<li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>x</code>, <code>y</code>, and <code>grid</code> as the parameters. The <code>x</code> and <code>y</code> parameters represent the row and column of the cell from which DFS should begin. We start with <code>(i ,j)</code> cell.</li>
<li>If the cell <code>(x, y)</code> is out of bounds, it means there was a land cell at the boundary of <code>grid</code> whose neighbor is <code>(x, y)</code>. So, we return <code>false</code> to indicate that this island is not closed.</li>
<li>Else if it is a water cell or an already visited cell, we return <code>true</code>.</li>
<li>Otherwise, we visit this cell and mark it as visited. We create a boolean variable <code>isClosed</code> that stores whether or not the current island is a closed island or not. We initialize it to <code>true</code> because we haven't found any nodes in the island that are on the <code>grid</code> boundary yet.</li>
<li>We then call <code>dfs</code> recursively from each of the neighbors of <code>(x, y)</code>.</li>
<li>If any of the directions leads to a cell in the island at the <code>grid</code> boundary, the island is not closed, and we mark <code>isClosed = false</code>. As discussed above, it is worth noting that in order to mark all the cells of the island, we called <code>dfs</code> individually over each of the four neighbors. We can't simply use <code>dfs(x - 1, y, m, n, grid, visit) &amp;&amp; dfs(x + 1, y, m, n, grid, visit) &amp;&amp; dfs(x, y - 1, m, n, grid, visit) &amp;&amp; dfs(x, y + 1, m, n, grid, visit)</code> because if the first <code>dfs</code> call returns <code>false</code>, the next three <code>dfs</code> calls will not be executed.</li>
<li>If <code>dfs</code> returns <code>true</code>, we increment <code>count</code> by 1.</li>
</ul>
</li>
<li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/HsudNnFS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are the number of rows and columns in the given grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>We iterate over all the cells and find unvisited land cells to perform DFS traversal from those. This takes <span class="math inline">\(O(m \cdot n)\)</span> time.</li>
<li>The <code>dfs</code> function visits each node once, leading to <span class="math inline">\(O(m \cdot n)\)</span> operations for <span class="math inline">\(m \cdot n\)</span> nodes. We iterate over all the neighbors of each node that is popped out of the queue. So for every node, we would iterate four times to iterate over the neighbors, resulting in <span class="math inline">\(O(4 \cdot m \cdot n) = O(m \cdot n)\)</span> operations total for all the nodes.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<ul>
<li>The <code>visit</code> array takes <span class="math inline">\(O(m \cdot n)\)</span> space.</li>
<li>The recursion stack used by <code>dfs</code> can have no more than <span class="math inline">\(O(m \cdot n)\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(m \cdot n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-233">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-enclaves/description" target="_blank" rel="noopener noreferrer">Number of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>, where <code>0</code> represents a sea cell and <code>1</code> represents a land cell.</p>

<p>A <strong>move</strong> consists of walking from one land cell to another adjacent (<strong>4-directionally</strong>) land cell or walking off the boundary of the <code>grid</code>.</p>

<p>Return <em>the number of land cells in</em> <code>grid</code> <em>for which we cannot walk off the boundary of the grid in any number of <strong>moves</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg" style="width: 333px; height: 333px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All 1s are either on the boundary or can reach the boundary.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-234">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-enclaves/1" target="_blank" rel="noopener noreferrer">Number Of Enclaves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given an <strong>n&nbsp;x m</strong>&nbsp;binary matrix <strong>grid</strong>, where <strong>0</strong> represents a sea cell and <strong>1</strong> represents a land cell.</span></p>
<p><span style="font-size: 18px;">A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.</span></p>
<p><span style="font-size: 18px;">Find the number of land cells in <strong>grid</strong> for which we cannot walk off the boundary of the grid in any number of moves.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 0},
            {1, 0, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 0
1 0 <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">grid[][] = {{0, 0, 0, 1},
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 1, 1, 0}}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">4</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">0 0 0 1
0 <strong>1</strong> <strong>1</strong> 0
0 <strong>1</strong> <strong>1</strong> 0
0 0 0 1
0 1 1 0</span>
<span style="font-size: 18px;">The highlighted cells represents the land cells.</span></pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to print or input anything. Complete the function <strong>numberOfEnclaves()&nbsp;</strong>which takes a 2D integer matrix <strong>grid&nbsp;</strong>as the input parameter and returns an integer, denoting the number of land cells.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Expected Space Complexity:</strong> O(n * m)</span></p>
<p><strong><span style="font-size: 18px;">Constraints:</span></strong></p>
<ul>
<li><span style="font-size: 18px;">1 &lt;= n, m &lt;= 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or 1</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-235">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-increasing-paths-in-a-grid/description" target="_blank" rel="noopener noreferrer">Number of Increasing Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>

<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" style="width: 181px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,1],[3,4]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].
- Paths with length 3: [1 -&gt; 3 -&gt; 4].
The total number of paths is 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -&gt; 2].
The total number of paths is 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-236">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-islands/description" target="_blank" rel="noopener noreferrer">Number of Islands</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>

<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 300</code></li>
	<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-237">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-laser-beams-in-a-bank/description" target="_blank" rel="noopener noreferrer">Number of Laser Beams in a Bank</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Anti-theft security devices are activated inside a bank. You are given a <strong>0-indexed</strong> binary string array <code>bank</code> representing the floor plan of the bank, which is an <code>m x n</code> 2D matrix. <code>bank[i]</code> represents the <code>i<sup>th</sup></code> row, consisting of <code>&#39;0&#39;</code>s and <code>&#39;1&#39;</code>s. <code>&#39;0&#39;</code> means the cell is empty, while<code>&#39;1&#39;</code> means the cell has a security device.</p>

<p>There is <strong>one</strong> laser beam between any <strong>two</strong> security devices <strong>if both</strong> conditions are met:</p>

<ul>
	<li>The two devices are located on two <strong>different rows</strong>: <code>r<sub>1</sub></code> and <code>r<sub>2</sub></code>, where <code>r<sub>1</sub> &lt; r<sub>2</sub></code>.</li>
	<li>For <strong>each</strong> row <code>i</code> where <code>r<sub>1</sub> &lt; i &lt; r<sub>2</sub></code>, there are <strong>no security devices</strong> in the <code>i<sup>th</sup></code> row.</li>
</ul>

<p>Laser beams are independent, i.e., one beam does not interfere nor join with another.</p>

<p>Return <em>the total number of laser beams in the bank</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg" style="width: 400px; height: 368px;" />
<pre>
<strong>Input:</strong> bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]
<strong>Output:</strong> 8
<strong>Explanation:</strong> Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0<sup>th</sup> row with any on the 3<sup>rd</sup> row.
This is because the 2<sup>nd</sup> row contains security devices, which breaks the second condition.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg" style="width: 244px; height: 325px;" />
<pre>
<strong>Input:</strong> bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There does not exist two devices located on two different rows.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == bank.length</code></li>
	<li><code>n == bank[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>bank[i][j]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-greedy">Approach: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>The laser beam will exist from one row (let's call it row <code>a</code>) to another (row <code>b</code>) if all rows in between have no security devices. In such cases, there will be a laser beam from each safety device in row <code>a</code> to every safety device in row <code>b</code>. Therefore, if the first row has <code>M</code> devices and the second one has <code>N</code> devices, then the total number of laser beams will be <code>M * N</code> between these two rows. Note that it doesn't matter how many rows in between have no safety devices as the beams will only exist between the rows having the devices.</p>
<p>In continuation to the above scenario, the second row with safety devices has <code>N</code> devices, and suppose the third row with safety devices has <code>K</code> devices. Then the number of laser beams between the second and this third row will be <code>N * K</code>, and there will be no other beams between the third row and other previous rows. One thing to observe from here is that we can ignore the rows without safety devices as they will be passed through by the beams that are created by rows having devices. Also, the beams will only be there between adjacent rows with devices and the number of beams will be the product of their device count.</p>
<p>We will keep the count of devices in each row and then multiply it by the number of devices in the previous row which has devices (if it exists). The count of devices in the previous row will be stored in a variable <code>prev</code> and will be updated with the number of devices in the current row (only if the devices count is non zero). The sum of all these products of devices count of every adjacent row with non-zero devices will be our answer.</p>
<p><img src="../Figures/2125/2125A.png" alt="fig" /></p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>prev</code> and <code>ans</code> to <code>0</code>.</li>
<li>Iterate over each string in <code>bank</code> and initialize the <code>count</code> to <code>0</code>. Iterate over each character in the string and increment the counter <code>count</code> if the character is a <code>1</code>.</li>
<li>After iterating over all characters of a string, if the <code>count</code> is not zero then add <code>prev * count</code> to <code>ans</code>. Also update the value of <code>prev</code> to <code>count</code> if <code>count != 0</code>.</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/2WR6ShVu/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(M\)</span> is the number of strings in the <code>bank</code> and <span class="math inline">\(N\)</span> is the average length of the strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(M * N)\)</span></p>
<p>We have to iterate over each character once to find the number of safety devices in each row and hence the time complexity is equal to <span class="math inline">\(O(M * N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only need three variables <code>prev</code>, <code>ans</code> and <code>count</code> and hence the space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-238">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-palindromic-paths-in-a-matrix0819/1" target="_blank" rel="noopener noreferrer">Number of Palindromic paths in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">palindrome</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a <strong>matrix</strong>&nbsp;containing lower alphabetical characters only of size <strong>n*m</strong>.&nbsp;We need to count the number of palindromic paths in the given matrix.<br />
A path is defined as a sequence of cells starting from top-left cell and ending at bottom-right cell. We are allowed to move to <strong>right</strong> and <strong>down</strong> only from current cell.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>matrix = {{a,a,a,b},{b,a,a,a},{a,b,b,a}}
<strong>Output: </strong>3
<strong>Explanation: </strong>Number of palindromic paths are 3 
from top-left to bottom-right.
aaaaaa (0, 0) -&gt; (0, 1) -&gt; (1, 1) -&gt; (1, 2) -&gt; 
(1, 3) -&gt; (2, 3)    
aaaaaa (0, 0) -&gt; (0, 1) -&gt; (0, 2) -&gt; (1, 2) -&gt; 
(1, 3) -&gt; (2, 3)    
abaaba (0, 0) -&gt; (1, 0) -&gt; (1, 1) -&gt; (1, 2) -&gt; 
(2, 2) -&gt; (2, 3)</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>matrix = {{a,b},{c,d}}
<strong>Output: </strong>0
<strong>Explanation: </strong>There is no palindromic paths.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anyhting. Your task is to complete the function&nbsp;<strong>countPalindromicPaths()&nbsp;</strong>which takes the matrix as input parameter and returns the total nuumber of palindromic paths modulo 10<sup>9</sup>&nbsp;+ 7.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>*m<sup>2</sup>)<br />
<strong>Space Complexity:&nbsp;</strong>O(n*m)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n, m &le; 100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-239">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-paths-in-a-matrix-with-k-coins2728/1" target="_blank" rel="noopener noreferrer">Number of paths in a matrix with k coins</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a <strong>n x n</strong>&nbsp;matrix such that&nbsp;each of its&nbsp;cells contains some&nbsp;coins. Count the number of ways to collect <strong>exactly k coins</strong> while moving from&nbsp;top left corner of the matrix&nbsp;to the&nbsp;bottom right. From a cell (<strong>i</strong>, <strong>j</strong>), you can only move to (<strong>i+1</strong>, <strong>j</strong>) or (<strong>i</strong>, <strong>j+1</strong>).</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>:
k = 12, n = 3
arr[] = [[1, 2, 3], 
&nbsp;      [4, 6, 5], 
&nbsp;      [3, 2, 1]]
<strong>Output:</strong>&nbsp;<br />2
<strong>Explanation</strong>: 
There are 2 possible paths with exactly 12 coins, (1 + 2 + 6 + 2 + 1) and (1 + 2 + 3 + 5 + 1).
</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
k = 16, n = 3
arr[] = [[1, 2, 3],&nbsp;
&nbsp;      [4, 6, 5],&nbsp;
&nbsp;      [9, 8, 7]]
<strong>Output: <br /></strong>0 
<strong>Explanation: </strong>
There are no possible paths that lead to sum=16
</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>numberOfPath()</strong> which takes integers <strong>n</strong>, <strong>k</strong> and a 2D matrix <strong>arr</strong>[][] as input parameters and returns an integer denoting the number of possible paths.</span><br /><br /><span style="font-size: 14pt;"><strong>Expected Time Complexity:</strong> O(n*n*k)<br /><strong>Expected Auxiliary Space:</strong> O(n*n*k)</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong></span><span style="font-size: 14pt;">1 &lt;= k &lt; 100<br />1 &lt;= n &lt; 100<br />0 &lt;= arr<sub>ij</sub> &lt;= 200</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-240">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-paths-with-max-score/description" target="_blank" rel="noopener noreferrer">Number of Paths with Max Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a square <code>board</code>&nbsp;of characters. You can move on the board starting at the bottom right square marked with the character&nbsp;<code>&#39;S&#39;</code>.</p>

<p>You need&nbsp;to reach the top left square marked with the character <code>&#39;E&#39;</code>. The rest of the squares are labeled either with a numeric character&nbsp;<code>1, 2, ..., 9</code> or with an obstacle <code>&#39;X&#39;</code>. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.</p>

<p>Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, <strong>taken modulo <code>10^9 + 7</code></strong>.</p>

<p>In case there is no path, return&nbsp;<code>[0, 0]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> board = ["E23","2X2","12S"]
<strong>Output:</strong> [7,1]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> board = ["E12","1X1","21S"]
<strong>Output:</strong> [4,2]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> board = ["E11","XXX","11S"]
<strong>Output:</strong> [0,0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-241">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-submatrices-that-sum-to-target/description" target="_blank" rel="noopener noreferrer">Number of Submatrices That Sum to Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>matrix</code>&nbsp;and a <code>target</code>, return the number of non-empty submatrices that sum to <font face="monospace">target</font>.</p>

<p>A submatrix <code>x1, y1, x2, y2</code> is the set of all cells <code>matrix[x][y]</code> with <code>x1 &lt;= x &lt;= x2</code> and <code>y1 &lt;= y &lt;= y2</code>.</p>

<p>Two submatrices <code>(x1, y1, x2, y2)</code> and <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> are different if they have some coordinate&nbsp;that is different: for example, if <code>x1 != x1&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
<strong>Output:</strong> 4
<strong>Explanation:</strong> The four 1x1 submatrices that only contain 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,-1],[-1,1]], target = 0
<strong>Output:</strong> 5
<strong>Explanation:</strong> The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[904]], target = 0
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
	<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
	<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
	<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-242">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/number-of-submatrix-have-sum-k/1" target="_blank" rel="noopener noreferrer">Number of submatrix have sum X</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a<strong><em data-start="46" data-end="53">&nbsp;</em></strong>matrix <strong><code data-start="61" data-end="70">mat[][]</code> </strong>of size&nbsp;</span><strong style="font-size: 18.6667px;">n &times; m </strong><span style="font-size: 14pt;">and an integer</span><strong style="font-size: 14pt;"> x</strong><span style="font-size: 14pt;">, find the number of square submatrices whose </span><strong style="font-size: 14pt;">sum </strong><span style="font-size: 14pt;">of elements is equal to <strong>x</strong></span><span style="font-size: 14pt;">.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[2, 4, 7, 8, 10], [3, 1, 1, 1, 1], [9, 11, 1, 2, 1], [12, -17, 1, 1, 1]], x = 10<strong><br />Output: </strong>3<strong><br /><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">Explanation</span>: </strong>The sub-squares whose sum of elements = 10, are colored in the matrix.<strong><br /></strong><img src="https://media.geeksforgeeks.org/wp-content/uploads/20250709104122447377/22.webp" width="403" height="342" /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[3, 3, 5, 3], [2, 2, 2, 6], [11, 2, 2, 4]], x = 1<strong><br />Output: </strong>0<strong><br />Explanation: </strong>There is no sub-squares whose sum of elements is 1.</span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &le; n, m &le; 100<br />-10<sup>3</sup> &le; mat[i] &le; 10<sup>3<br /></sup>-10<sup>9</sup> &le; x &le;&nbsp;</span><span style="font-size: 18.6667px;">10</span><sup>9</sup></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-243">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description" target="_blank" rel="noopener noreferrer">Number of Ways of Cutting a Pizza</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a rectangular pizza represented as a <code>rows x cols</code>&nbsp;matrix containing the following characters: <code>&#39;A&#39;</code> (an apple) and <code>&#39;.&#39;</code> (empty cell) and given the integer <code>k</code>. You have to cut the pizza into <code>k</code> pieces using <code>k-1</code> cuts.&nbsp;</p>

<p>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.</p>

<p><em>Return the number of ways of cutting the pizza such that each piece contains <strong>at least</strong> one apple.&nbsp;</em>Since the answer can be a huge number, return this modulo 10^9 + 7.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png" style="width: 500px; height: 378px;" /></strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 3 
<strong>Explanation:</strong> The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
	<li><code>rows ==&nbsp;pizza.length</code></li>
	<li><code>cols ==&nbsp;pizza[i].length</code></li>
	<li><code>1 &lt;= k &lt;= 10</code></li>
	<li><code>pizza</code> consists of characters <code>&#39;A&#39;</code>&nbsp;and <code>&#39;.&#39;</code> only.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-244">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pacific-atlantic-water-flow/description" target="_blank" rel="noopener noreferrer">Pacific Atlantic Water Flow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island&#39;s left and top edges, and the <strong>Atlantic Ocean</strong> touches the island&#39;s right and bottom edges.</p>

<p>The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.</p>

<p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell&#39;s height is <strong>less than or equal to</strong> the current cell&#39;s height. Water can flow from any cell adjacent to an ocean into the ocean.</p>

<p>Return <em>a <strong>2D list</strong> of grid coordinates </em><code>result</code><em> where </em><code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code><em> denotes that rain water can flow from cell </em><code>(r<sub>i</sub>, c<sub>i</sub>)</code><em> to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" style="width: 400px; height: 400px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
<strong>Output:</strong> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
<strong>Explanation:</strong> The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -&gt; Pacific Ocean 
&nbsp;      [0,4] -&gt; Atlantic Ocean
[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
&nbsp;      [1,3] -&gt; [1,4] -&gt; Atlantic Ocean
[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean 
&nbsp;      [1,4] -&gt; Atlantic Ocean
[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean 
&nbsp;      [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean
[3,0]: [3,0] -&gt; Pacific Ocean 
&nbsp;      [3,0] -&gt; [4,0] -&gt; Atlantic Ocean
[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean 
&nbsp;      [3,1] -&gt; [4,1] -&gt; Atlantic Ocean
[4,0]: [4,0] -&gt; Pacific Ocean 
       [4,0] -&gt; Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> heights = [[1]]
<strong>Output:</strong> [[0,0]]
<strong>Explanation:</strong> The water can flow from the only cell to the Pacific and Atlantic oceans.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == heights.length</code></li>
	<li><code>n == heights[r].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= heights[r][c] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-245">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description" target="_blank" rel="noopener noreferrer">Paths in Matrix Whose Sum Is Divisible by K</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> and an integer <code>k</code>. You are currently at position <code>(0, 0)</code> and you want to reach position <code>(m - 1, n - 1)</code> moving only <strong>down</strong> or <strong>right</strong>.</p>

<p>Return<em> the number of paths where the sum of the elements on the path is divisible by </em><code>k</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/08/13/image-20220813183124-1.png" style="width: 437px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two paths where the sum of the elements on the path is divisible by k.
The first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.
The second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/08/17/image-20220817112930-3.png" style="height: 85px; width: 132px;" />
<pre>
<strong>Input:</strong> grid = [[0,0]], k = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong> The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img src="https://assets.leetcode.com/uploads/2022/08/12/image-20220812224605-3.png" style="width: 257px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1
<strong>Output:</strong> 10
<strong>Explanation:</strong> Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-246">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/paths-to-reach-origin3850/1" target="_blank" rel="noopener noreferrer">Paths to reach origin</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are standing on a point&nbsp;<strong>(x, y)</strong> and you want to go to the origin<strong>&nbsp;(0, 0)</strong>&nbsp;by taking steps either&nbsp;<strong>left</strong> or <strong>down</strong> i.e. from each point you are allowed to move either in&nbsp;<strong>(x-1, y) or (x, y-1)</strong>. Find the number of <strong>paths </strong>from<strong> point </strong>to<strong> origin</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;">x = 3, y = 0 
<strong>Output:</strong> <br />1
<strong>Explanation</strong>: Path used was -  <strong>(3,0)  --&gt; ( 2,0) --&gt; (1,0) --&gt; (0,0)</strong>.We can see that there is no other path than this, so we return 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>x = 3, y = 6
<strong>Output:</strong> <br />84 <br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Explanation</strong><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">:<br /></span>There are total 84 possible paths.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Since this is a function problem. You don't need to take any input, as it is already accomplished by the driver code. You just need to complete the function <strong>ways</strong>() that takes integer<strong> x&nbsp;</strong>and <strong>y</strong>&nbsp;as parameters and returns the total&nbsp;number of <strong>paths </strong>from<strong> point(x,y) </strong>to the<strong> origin(0,0) % 1000000007.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(x*y).<br /><strong>Expected Auxiliary Space:</strong> O(x*y).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />0 &le; x, y &le; 500</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-247">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-maximum-gold/description" target="_blank" rel="noopener noreferrer">Path with Maximum Gold</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a gold mine <code>grid</code> of size <code>m x n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p>

<p>Return the maximum amount of gold you can collect under the conditions:</p>

<ul>
	<li>Every time you are located in a cell you will collect all the gold in that cell.</li>
	<li>From your position, you can walk one step to the left, right, up, or down.</li>
	<li>You can&#39;t visit the same cell more than once.</li>
	<li>Never visit a cell with <code>0</code> gold.</li>
	<li>You can start and stop collecting gold from <strong>any </strong>position in the grid that has some gold.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,6,0],[5,8,7],[0,9,0]]
<strong>Output:</strong> 24
<strong>Explanation:</strong>
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
<strong>Output:</strong> 28
<strong>Explanation:</strong>
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 15</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
	<li>There are at most <strong>25 </strong>cells containing gold.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-with-backtracking">Approach 1: Depth-First Search with Backtracking</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to collect the maximum amount of gold possible from a given <code>grid</code>.</p>
<p>It's possible to traverse the <code>grid</code> and find the cells containing gold using nested loops, but this won't provide us with the path with the maximum gold. Instead, we will use depth-first search (DFS) to search for the best path.</p>
<p>We can begin searching for gold in any cell of the <code>grid</code> that has gold, so we perform a depth-first search for gold starting at each cell.</p>
<p>Let's consider our search function. If the starting cell contains gold, we should continue searching for gold in the adjacent cells. However, if the starting cell does not contain gold, we should halt the search since this path cannot lead to a valid solution.</p>
<p>What if a cell in the middle of the search process doesn't contain gold? We could restart the entire search process, or we could backtrack to the last cell on this path that contained gold and resume the search from there.</p>
<p>This idea is called backtracking. If a certain choice cannot lead to a valid solution, we can implement backtracking to abandon the current choice to return to the last valid choice and explore other possibilities.</p>
<blockquote>
<p>If you are not familiar with backtracking, we recommend you read our <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">Backtracking Explore Card</a>.</p>
</blockquote>
<p>We will define a recursive function, <code>dfsBacktrack</code>, that returns the path with the maximum gold for a given starting cell.</p>
<p>Our base case occurs when the current cell contains no gold or when the given coordinates are outside the matrix boundary. In either case, we return zero.</p>
<p>Next, let's discuss the recursive case. First, we collect the gold at the current cell by saving its original value and setting the cell to <code>0</code>.</p>
<p>Then, we explore the possible paths from this cell by calling <code>dfsBacktrack</code> recursively for each of the four adjacent cells and updating the maximum gold if we find a better path.</p>
<p>For a given cell with coordinates <code>(row, col)</code> the four neighbors are:</p>
<ul>
<li>Right Neighbor: <code>(row + 0, col + 1)</code></li>
<li>Below Neighbor: <code>(row + 1, col + 0)</code></li>
<li>Left Neighbor: <code>(row + 0, col - 1)</code></li>
<li>Above Neighbor: <code>(row - 1, col + 0)</code></li>
</ul>
<p>We can observe that we change the first neighbor's column by the same amount as the next neighbor's row. By extracting this pattern, we can store it in an array <code>DIRECTIONS = {0, 1, 0, -1, 0}</code>. For each neighbor cell <code>i</code>, the row will change by <code>DIRECTIONS[i]</code>, and the column will change by <code>DIRECTIONS[i + 1]</code>.</p>
<p>After the recursive calls, we reset the current cell to its original value. This allows us to backtrack and explore other potential paths from this cell.</p>
<p>We return the sum of the maximum gold obtained and the current cell's gold value, representing the total gold collected on the path up to this point.</p>
<p>Then, from the <code>getMaximumGold</code> function, we use nested loops to traverse the possible starting cells. For each cell, we call the <code>dfsBacktrack</code> function and update the maximum gold value each time we find a better path.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a constant array <code>DIRECTIONS</code> to <code>{0, 1, 0, -1, 0}</code>.</li>
<li>Initialize the variable <code>rows</code> to the number of rows in the grid and <code>cols</code> to the number of columns.</li>
<li>Initialize a variable <code>maxGold</code> for storing the amount of gold collected on any path so far to <code>0</code>.</li>
<li>Define a function <code>dfsBacktrack</code> that finds the path with the maximum gold using DFS and backtracking. The function takes parameters <code>grid</code>, <code>rows</code>, <code>cols</code>, <code>row</code>, and <code>col</code>, representing the coordinates of the current cell within the <code>grid</code>.
<ul>
<li>Base Case: We cannot collect gold in the cell <code>(row, col)</code>. If <code>grid[row][col]</code> equals <code>0</code>, or if the cell is outside the <code>grid</code>, return zero. We check whether the cell is outside the grid using the condition <code>row &lt; 0 or col &lt; 0 or row == rows or col == cols</code>.</li>
<li>Initialize a local variable <code>maxGold</code> to <code>0</code>.</li>
<li>Mark the current cell as visited and save the value. Initialize a variable <code>originalVal</code> to <code>grid[row][col]</code>, and set <code>grid[row][col]</code> to <code>0</code>.</li>
<li>Search each of the four adjacent cells. Call <code>dfsBacktrack</code> for the cells to the left, right, above, and below the current cell. Update the maximum gold if a better path is found.</li>
<li>Reset the current cell back to its original value so that when we backtrack, we can explore other possible paths from this cell.</li>
<li>Return the sum of <code>maxGold</code> and <code>originalVal</code>, which represents the gold collected on this path so far.</li>
</ul>
</li>
<li>Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, find the maximum gold that can be collected starting at that cell using the <code>dfsBacktrack</code> function and update <code>maxGold</code> whenever a better path is found.</li>
<li>Return <code>maxGold</code>.</li>
</ol>
<p>The <code>dfsBacktrack</code> function is visualized below for the input <code>grid = [[1,5,0],[7,2,4]]</code> and the start cell <code>(0, 0)</code>:</p>
<p>!?!../Documents/1219/1219_slideshow.json:700,395!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EScajpgt/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <code>grid</code>, <span class="math inline">\(m\)</span> be the number of columns, and <span class="math inline">\(g\)</span> be the number of gold cells.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
<p>We search for the path with maximum gold from each starting cell that contains gold using the backtrack function, which recursively calls itself. From the starting cell, we explore paths in <span class="math inline">\(4\)</span> directions, but for each additional cell in the path, we explore paths in <span class="math inline">\(3\)</span> directions because we already collected gold from the direction we came from. That means the backtrack function can be called up to <span class="math inline">\(3^g\)</span> times for a given starting cell, and it takes <span class="math inline">\(O(g \cdot 3^g)\)</span> to search for the maximum gold from all the gold cells.</p>
<p>In the <code>getMaximumGold</code> function, we iterate through each cell in the matrix, checking whether each has gold. We've already accounted for the gold cells, so this takes <span class="math inline">\(O(m \cdot n - g)\)</span> for the cells that do not contain gold.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(g)\)</span></p>
<p>Since the length of a path through gold cells can be <span class="math inline">\(g\)</span>, the recursive call stack can grow up to size <span class="math inline">\(g\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-with-backtracking">Approach 2: Breadth-First Search with Backtracking</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When a problem can be solved with depth-first search, it can often also be solved with breadth-first search (BFS).</p>
<p>We will create a function, <code>bfsBacktrack</code>, that uses a breadth-first search to find the path with the maximum gold for a given starting cell.</p>
<p>We will use a queue to store the cells we need to search. Each entry in the queue contains the coordinates of the current cell, the gold found so far on the path, and a set storing the cells visited on this path so far.</p>
<p>When we pop the front cell from the queue, we store the amount of gold found on the path so far as <code>currGold</code>, and update the <code>maxGold</code> if the <code>currGold</code> is higher.</p>
<p>Then, if each of the four adjacent cells has gold, is inside the matrix, and has not yet been visited, we mark them as visited and add them to the queue with the updated gold collected. After adding the cell to the queue, we remove it from the visited set to explore other possible paths from this cell during backtracking.</p>
<p>To improve the efficiency of the solution, we calculate the total amount of gold in the matrix before searching. This way, if we discover a path that has the maximum possible total gold, we can halt the search process.</p>
<p>Similar to the above solution, we call <code>bfsBacktrack</code> for every starting cell in the matrix.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a constant array <code>DIRECTIONS</code> to <code>{0, 1, 0, -1, 0}</code>.</li>
<li>Initialize the variable <code>rows</code> to the number of rows in the grid and <code>cols</code> to the number of columns.</li>
<li>Calculate the total amount of gold in the <code>grid</code> using a running sum. Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, add the gold to <code>totalGold</code>.</li>
<li>Initialize a variable <code>maxGold</code> to store the amount of gold collected on the path with the maximum gold to <code>0</code>.</li>
<li>Define a function <code>bfsBacktrack</code> that searches for the path with the maximum gold using BFS and backtracking. The parameters are the <code>grid</code>, <code>rows</code>, <code>cols</code>, <code>row</code>, and <code>col</code>, representing the current cell coordinates in the <code>grid</code>.
<ul>
<li>Initialize a queue <code>queue</code> which stores the path and gold collected for a given cell.</li>
<li>Initialize a set <code>visited</code> for storing <code>(row, col)</code> pairs we have already visited.</li>
<li>Initialize a local variable <code>maxGold</code> to <code>0</code>.</li>
<li>Add the starting <code>(row, col)</code> pair to the visited set.</li>
<li>Add the starting cell's <code>row</code>, <code>col</code>, amount of gold, and visited set to the queue.</li>
<li>While the queue is not empty:
<ul>
<li>Pop the front entry from the queue. Save the row as <code>currRow</code>, the column as <code>currCol</code>, the visited set as <code>currVis</code>, and the gold as <code>currGold</code>.</li>
<li>Update <code>maxGold</code> to <code>currGold</code> if <code>currGold</code> is larger.</li>
<li>Search each of the four adjacent cells. For the cells to the left, right, above, and below of the current cell:
<ul>
<li>Set <code>nextRow</code> to the neighbor cell's row coordinates and <code>nextCol</code> to the neighbor's column coordinates.</li>
<li>Add the neighbor cell to the queue if it contains gold, is in the matrix, and has not been visited:
<ul>
<li>Mark this cell as visited in <code>currVis</code>.</li>
<li>Add this cell's gold to <code>currGold</code> and add the cell to the queue with a copy of the <code>currVis</code> set.</li>
<li>Remove this cell from <code>currVis</code> so that when we backtrack, we can explore other possible paths.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxGold</code>.</li>
</ul>
</li>
<li>Using nested <code>for</code> loops for each cell <code>(row, col)</code> in the <code>grid</code>, find the maximum gold that can be collected at that cell using the <code>bfsBacktrack</code> function and update <code>maxGold</code> when a better path is found. If a path with the <code>totalGold</code> is found, return the <code>totalGold</code>.</li>
<li>Return <code>maxGold</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/MG7g9pY8/shared">code</a></p>
<blockquote>
<p><strong>Note:</strong> The copy operations for <code>unordered_set</code> are inefficient and cause the C++ solution to result in &quot;time limit exceeded&quot;. Therefore, the C++ implementation uses a bitset for the <code>visited</code> and <code>currVis</code> sets. Each bit in the bitset represents a cell in the matrix, with <code>1</code> indicating the cell as visited and <code>0</code> as unvisited. Matrix coordinates are mapped to the bitset using the formula <code>nextRow * cols + nextCol</code>.</p>
</blockquote>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows in the <code>grid</code>, <span class="math inline">\(m\)</span> be the number of columns, and <span class="math inline">\(g\)</span> be the number of gold cells.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span></p>
<p>We search for the path with the maximum gold starting from each gold cell. We search in three directions for each cell along the path because we have already collected the gold on the current path. This means we push up to <span class="math inline">\(3^g\)</span> entries to the queue. We stop the BFS when the queue is empty, so this process takes <span class="math inline">\(O(g \cdot 3^g)\)</span>.</p>
<p>In the <code>getMaximumGold</code> function, we check whether each cell contains gold. The gold cells have already been accounted for, so this takes <span class="math inline">\(m \cdot n -g\)</span> for the cells with no gold.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O(m \cdot n - g + g \cdot 3^g)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(g \cdot 3^g)\)</span> (Java and Python3) or <span class="math inline">\(O(3^g + m \cdot n)\)</span> (C++)</p>
<p>Java and Python3: A visited set of size <span class="math inline">\(g\)</span> is created for each entry in the queue. The queue can grow to size <span class="math inline">\(3^g\)</span>, so the <code>currVis</code> sets can use up to <span class="math inline">\(O(g \cdot 3^g)\)</span> space.</p>
<p>C++: The queue may use up to <span class="math inline">\(3^g\)</span> space. We initialize the visited bitset to size <code>1024</code> since the constraints limit <code>m</code> and <code>n</code> to <code>100</code>, ensuring the bitset is large enough to store all <code>1000</code> possible coordinates. Therefore, the space complexity is <span class="math inline">\(O(3^g + m \cdot n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-248">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/path-with-minimum-effort/description" target="_blank" rel="noopener noreferrer">Path With Minimum Effort</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are a hiker preparing for an upcoming hike. You are given <code>heights</code>, a 2D array of size <code>rows x columns</code>, where <code>heights[row][col]</code> represents the height of cell <code>(row, col)</code>. You are situated in the top-left cell, <code>(0, 0)</code>, and you hope to travel to the bottom-right cell, <code>(rows-1, columns-1)</code> (i.e.,&nbsp;<strong>0-indexed</strong>). You can move <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>, and you wish to find a route that requires the minimum <strong>effort</strong>.</p>

<p>A route&#39;s <strong>effort</strong> is the <strong>maximum absolute difference</strong><strong> </strong>in heights between two consecutive cells of the route.</p>

<p>Return <em>the minimum <strong>effort</strong> required to travel from the top-left cell to the bottom-right cell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex1.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,2],[3,8,2],[5,3,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex2.png" style="width: 300px; height: 300px;" /></p>

<pre>
<strong>Input:</strong> heights = [[1,2,3],[3,8,4],[5,3,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/04/ex3.png" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> This route does not require any effort.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == heights.length</code></li>
	<li><code>columns == heights[i].length</code></li>
	<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
	<li><code>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-249">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/predict-the-column/1" target="_blank" rel="noopener noreferrer">Predict the Column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix(2D array) <strong>M </strong>of size <strong>N</strong>*<strong>N</strong> consisting of <strong>0s</strong> and <strong>1s</strong> only. The task is to find the <strong>column </strong>with maximum number of <strong>0s</strong>.&nbsp;</span><span style="font-size: 18px;">If more than one column exists, print the one which comes first. If the maximum number of <strong>0s is 0 then return -1.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Example:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 3
M[][] = {{0, 0, 0},
          {1, 0, 1},
          {0, 1, 1}}
<strong>Output:<br /></strong>0
<strong>Explanation:
</strong>0th column (<strong>0-based indexing</strong>) is having 2 zeros which is maximum among all columns and comes first.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />Your task is to complete the function <strong>columnWithMaxZero()</strong> which should return the <strong>column numbe</strong>r with the maximum number of zeros.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(N * N)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>3</sup><br />0 &lt;= A[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-250">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/prefix-sum-of-matrix-or-2d-array/1" target="_blank" rel="noopener noreferrer">Prefix Sum of Matrix (Or 2D Array)</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a integer matrix (or 2D array) <strong>a[][]</strong> of dimensions <strong>n *&nbsp;m</strong>. Also, given another 2-D array&nbsp;<strong>query[][]</strong> of dimensions <strong>q *&nbsp;4</strong>. </span></p>
<p><span style="font-size: 18px;">For each index 0 &lt; i &lt; query.length, find the sum of all the elements of the rectangular matrix whose top left corner is (query[i][0], query[i][1]) and bottom right corner is (query[i][2], query[i][3]).</span></p>
<p><span style="font-size: 18px;">Example -&nbsp;</span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
n = 3, m = 3, q = 2 
a[][] = [
          [ 1, 2, 3],
          [ 4, 5, 6],
          [ 7, 8, 9]
        ]</span>

<span style="font-size: 18px;">query[][] = [
               [0, 0, 2, 2]
               [1, 0, 2, 1]
            ]</span>

<span style="font-size: 18px;"><strong>Output:</strong>
45
24</span>

<strong><span style="font-size: 18px;">Explanation:</span></strong>

<span style="font-size: 18px;">The sum of all the elements in the matrix whose top left corner is (0, 0) and the bottom right corner is (2, 2) is 45.</span>

<span style="font-size: 18px;">The sum of all the elements in the matrix whose top left corner is (1, 0) and the bottom right corner is (2, 1) is 24.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong></span></p>
<p><span style="font-size: 18px;">You&nbsp;don't&nbsp;have to print anything, printing is done by the driver code itself. Your task is to complete the function submatrixSum()&nbsp;which takes the array <strong>a[][]</strong>,&nbsp;its dimensions&nbsp;<strong>n, m</strong>,&nbsp; the <strong>query[][]</strong> array, and its dimension <strong>q</strong> as the inputs and returns the vector/list of where the i<sup>th</sup>&nbsp;element denotes answer of i<sup>th</sup>&nbsp;query.</span></p>
<p><span style="font-size: 18px;">Expected Time Complexity: <strong>O(n<sup>2 </sup>+ q)</strong><br />Expected Space Complexity: <strong>O(n<sup>2</sup>)&nbsp;</strong></span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />0 &lt; n, m &lt; 10<sup>3</sup></span></p>
<p><span style="font-size: 18px;">0 &lt; n * m &lt; 10<sup>6</sup></span></p>
<p><span style="font-size: 18px;">0 &lt; q &lt; 10<sup>3</sup></span></p>
<p><span style="font-size: 18px;">0 &lt; a[i][j] &lt; 10<sup>9</sup></span></p>
<p><span style="font-size: 18px;">0 &lt; query[i][0], query[i][2] &lt; n</span></p>
<p><span style="font-size: 18px;">0 &lt; query[i][1], query[i][3] &lt; m</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-251">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/prime-in-diagonal/description" target="_blank" rel="noopener noreferrer">Prime In Diagonal</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 0-indexed two-dimensional integer array <code>nums</code>.</p>

<p>Return <em>the largest <strong>prime</strong> number that lies on at least one of the <b>diagonals</b> of </em><code>nums</code>. In case, no prime is present on any of the diagonals, return<em> 0.</em></p>

<p>Note that:</p>

<ul>
	<li>An integer is <strong>prime</strong> if it is greater than <code>1</code> and has no positive integer divisors other than <code>1</code> and itself.</li>
	<li>An integer <code>val</code> is on one of the <strong>diagonals</strong> of <code>nums</code> if there exists an integer <code>i</code> for which <code>nums[i][i] = val</code> or an <code>i</code> for which <code>nums[i][nums.length - i - 1] = val</code>.</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png" style="width: 181px; height: 121px;" /></p>

<p>In the above diagram, one diagonal is <strong>[1,5,9]</strong> and another diagonal is<strong> [3,5,7]</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,2,3],[5,6,7],[9,10,11]]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1,2,3],[5,17,7],[9,11,10]]
<strong>Output:</strong> 17
<strong>Explanation:</strong> The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 300</code></li>
	<li><code>nums.length == nums<sub>i</sub>.length</code></li>
	<li><code>1 &lt;= nums<span style="font-size: 10.8333px;">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-252">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/primitive-typing5427/1" target="_blank" rel="noopener noreferrer">Primitive Typing</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a screen containing alphabets from a-z, we can go from one character to </span><span style="font-size:18px">another character</span><span style="font-size:18px">&nbsp;using a remote. The remote contains left, right, top and bottom keys.</span></p>

<p><span style="font-size:18px"><strong>Remote :</strong></span><br />
<img alt="" src="https://contribute.geeksforgeeks.org/wp-content/uploads/Primitive-Typing.jpg" /></p>

<p><span style="font-size:18px">Find the&nbsp;shortest possible path to type all characters of given string using the remote. The initial position is top left and all characters of input string should be printed in order. Find&nbsp;the total number of moves in such a path(Move UP, DOWN, LEFT, RIGHT).&nbsp;Pressing OK also accounts for one move.</span></p>

<p><span style="font-size:18px"><strong>Screen:</strong></span></p>

<pre>
<span style="font-size:18px">a b c d e
f g h i j
k l m n o
p q r s t
u v w x y
z</span>
</pre>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>str = &quot;abc&quot;
<strong>Output: </strong>5
<strong>Explanation: </strong>Remote&#39;s position is at &#39;a&#39;
initially. So &#39;a&#39; -&gt; &#39;b&#39; = 1 step, 
&#39;b&#39;-&gt; &#39;c&#39;= 1 step. Three OK moves will also
be needed to print the three characters.</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>str = &quot;a&quot;
<strong>Output: </strong>1
<strong>Explanation: </strong>Remote is initially at &#39;a&#39;.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anything. Your task is to complete the function&nbsp;<strong>FindPath()</strong>&nbsp;which takes the string str as input parameter and returns the minimum number of moves to cover all characters of the given string.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Compelxity:&nbsp;</strong>O(n)<br />
<strong>Expected Space Complexity:&nbsp;</strong>O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= |str| &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-253">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-diagonally4331/1" target="_blank" rel="noopener noreferrer">Print Diagonally</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">misc</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Give a <strong>N * N</strong> square matrix <strong>A</strong>, return all the elements of its anti-diagonals from <strong>top to bottom</strong>. </span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong> 
N = 2
A = [[1, 2],
     [3, 4]]
<strong>Output:</strong>
1 2 3 4
<strong>Explanation:</strong> 
<img alt="" src="https://media.geeksforgeeks.org/img-practice/ScreenShot2022-10-17at9-1665980852.png" />
</span><span style="font-size:18px">Hence, elements will be returned in the 
order {1, 2, 3, 4}.</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: 
</strong>N = 3 
A = [[1, 2, 3],
     [4, 5, 6],
     [7, 8, 9]]
<strong>Output:</strong> 
1 2 4 3 5 7 6 8 9
<strong>Explanation:</strong> 
<img alt="" src="https://media.geeksforgeeks.org/img-practice/ScreenShot2022-10-17at9-1665980941.png" />
Hence, elements will be returned in 
the order {1, 2, 4, 3, 5, 7, 6, 8, 9}.
</span>
</pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>downwardDiagonal()</strong> which takes an integer <strong>N</strong> and a 2D matrix <strong>A[ ][ ]</strong> as input parameters and returns the list of all elements of its anti-diagonals from <strong>top to bottom</strong>.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(N*N)<br />
<strong>Expected Auxillary Space:&nbsp;</strong>O(N*N)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N, M &le; 10<sup>3</sup><br />
0 &le; A[i][j] &le; 10<sup>6</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-254">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/waves-b18625d7/" target="_blank" rel="noopener noreferrer">Printing patterns</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">breadthfirstsearch</span> <span class="topic-badge">graphs</span> <span class="topic-badge">implementation</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are requiredÂ to form a matrix of size <span class="mathjax-latex">\(r\times c\)</span> where <span class="mathjax-latex">\(r\)</span> is the number of rows and <span class="mathjax-latex">\(c\)</span> is the number of columns.Â You are required to form the waves of numbers around the provided center,Â <span class="mathjax-latex">\((C_i,\ C_j)\)</span> (0-based indexing).</p>

<p>Example:</p>

<ul>
	<li>Size of the matrix: <span class="mathjax-latex">\(r = 9\)</span> andÂ <span class="mathjax-latex">\(c = 9\)</span></li>
	<li>Center coordinates: <span class="mathjax-latex">\(C_i = 4\)</span>Â andÂ <span class="mathjax-latex">\(C_j = 4\)</span> (0 based indexing)</li>
	<li>Pattern:</li>
</ul>

<p style="margin-left: 40px;">Â Â Â Â Â Â Â Â Â Â Â Â 4 4 4 4 4 4 4 4 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 3 3 3 3 3 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 2 2 2 2 2 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 2 1 1 1 2 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 2 1 0 1 2 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 2 1 1 1 2 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 2 2 2 2 2 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 3 3 3 3 3 3 3 4Â <br>
Â Â  Â Â Â  Â Â Â  Â 4 4 4 4 4 4 4 4 4</p>

<p>You are given the values of <span class="mathjax-latex">\(r,\ c,\ C_i,\ C_j\)</span> (the values of <span class="mathjax-latex">\(C_i\)</span> and <span class="mathjax-latex">\(C_j\)</span> is 0-based indexed). Your task is to print the provided pattern.</p>

<p><strong>Input format</strong></p>

<p>The first line contains four integers <span class="mathjax-latex">\(r\)</span>, <span class="mathjax-latex">\(c\)</span>, <span class="mathjax-latex">\(C_i\)</span>, and <span class="mathjax-latex">\(C_j\)</span> denoting the numberÂ of rows, numberÂ of columns, <span class="mathjax-latex">\(x\)</span> coordinate of center,Â and <span class="mathjax-latex">\(y\)</span> coordinate of center.</p>

<p><strong>Output format</strong></p>

<p>Print the pattern for the provided input.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1 \le r \le 1e3\\
1 \le c \le 1e3\\
0 \le C_i &lt; r\\
0 \le C_j &lt; c\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Given input have shown output.</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-255">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-matrix-in-diagonal-pattern/1" target="_blank" rel="noopener noreferrer">Print matrix in diagonal pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square matrix <strong>mat[][]</strong> of <strong>n*n</strong> size, the task is to determine the <strong>diagonal pattern</strong> which is a linear arrangement of the elements of the matrix as depicted in the following example:</span></p>
<p><span style="font-size: 18px;"><img style="height: 324px; width: 393px;" src="https://contribute.geeksforgeeks.org/wp-content/uploads/matrix-6.png" alt="" /></span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:
</strong><span style="font-size: 18px;">n = 3
mat[][] = {{1, 2, 3},<br />           {4, 5, 6},<br />           {7, 8, 9}}
</span><strong style="font-size: 18px;">Output: {</strong><span style="font-size: 18px;">1, 2, 4, 7, 5, 3, 6, 8, 9}<br /></span><strong style="font-size: 18px;">Explaination:<br /></strong><span style="font-size: 18px;"><span style="font-size: 18px;">Starting from (0, 0): 1,
Move to the right to (0, 1): 2,
Move diagonally down to (1, 0): 4,
Move diagonally down to (2, 0): 7,<br />Move diagonally up to (1, 1): 5,
Move diagonally up to (0, 2): 3,
Move to the right to (1, 2): 6,
Move diagonally up to (2, 1): 8,
Move diagonally up to (2, 2): 9<br />There for the output is {1, 2, 4, 7, 5, 3, 6, 8, 9}.</span></span><span style="font-size: 18px;"><br /></span></span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:
</strong><span style="font-size: 18px;">n = 2
mat[][] = {{1, 2},<br />           {3, 4}}
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">{1, 2, 3, 4}<br /></span><strong style="font-size: 18px;">Explaination:</strong><span style="font-size: 18px;"><br />Starting from (0, 0): 1,
Move to the right to (0, 1): 2,
Move diagonally down to (1, 0): 3,
Move to the right to (1, 1): 4<br />There for the output is {1, 2, 3, 4}.</span></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You only need to implement the given function&nbsp;<strong>matrixDiagonally()&nbsp;</strong>which takes a matrix <strong>mat[][]</strong> of size <strong>n*n</strong> as an input and returns a list of integers containing the matrix diagonally. Do not read input, instead use the arguments given in the function.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n*n).<br /><strong>Expected Auxiliary Space:</strong> O(</span><span style="font-size: 18px;">n*n</span><span style="font-size: 18px;">).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 100<br />-100 &lt;= elements of matrix &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-256">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-matrix-in-snake-pattern-1587115621/1" target="_blank" rel="noopener noreferrer">Print Matrix in snake Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a<strong> </strong>matrix<strong> mat[][] </strong>of size<strong> n x n</strong>. Print the elements of the matrix in the snake like pattern depicted below.<br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701263/Web/Other/blobid0_1749128162.webp" width="235" height="235" /><br /></span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 3, mat[][] = [[45, 48, 54], [21, 89, 87], [70, 78, 15]]
<strong>Output</strong>: [45, 48, 54, 87, 89, 21, 70, 78, 15]&nbsp;
<strong>Explanation</strong>: Printing it in snake pattern will lead to the output as [45, 48, 54, 87, 89, 21, 70, 78, 15] <br /></span>.</pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: n = 2, mat[][] = [[1, 2], [3, 4]]<br /></span><span style="font-size: 18px;"><strong>Output</strong>: [1, 2, 4, 3] <br /></span><span style="font-size: 18px;"><strong>Explanation</strong>: Printing it in snake pattern will give output as [1, 2, 4, 3].</span>.</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 10<sup>3</sup><br />1 &lt;= mat[i][j] &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-257">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/projection-area-of-3d-shapes/description" target="_blank" rel="noopener noreferrer">Projection Area of 3D Shapes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">geometry</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> <code>grid</code> where we place some <code>1 x 1 x 1</code> cubes that are axis-aligned with the <code>x</code>, <code>y</code>, and <code>z</code> axes.</p>

<p>Each value <code>v = grid[i][j]</code> represents a tower of <code>v</code> cubes placed on top of the cell <code>(i, j)</code>.</p>

<p>We view the projection of these cubes onto the <code>xy</code>, <code>yz</code>, and <code>zx</code> planes.</p>

<p>A <strong>projection</strong> is like a shadow, that maps our <strong>3-dimensional</strong> figure to a <strong>2-dimensional</strong> plane. We are viewing the &quot;shadow&quot; when looking at the cubes from the top, the front, and the side.</p>

<p>Return <em>the total area of all three projections</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png" style="width: 800px; height: 214px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[3,4]]
<strong>Output:</strong> 17
<strong>Explanation:</strong> Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[2]]
<strong>Output:</strong> 5
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0],[0,2]]
<strong>Output:</strong> 8
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-mathematical">Approach 1: Mathematical</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>From the top, the shadow made by the shape will be 1 square for each non-zero value.</p>
<p>From the side, the shadow made by the shape will be the largest value for each row in the grid.</p>
<p>From the front, the shadow made by the shape will be the largest value for each column in the grid.</p>
<p><strong>Example</strong></p>
<p>With the example <code>[[1,2],[3,4]]</code>:</p>
<ul>
<li>
<p>The shadow from the top will be 4, since there are four non-zero values in the grid;</p>
</li>
<li>
<p>The shadow from the side will be <code>2 + 4</code>, since the maximum value of the first row is <code>2</code>, and the maximum value of the second row is <code>4</code>;</p>
</li>
<li>
<p>The shadow from the front will be <code>3 + 4</code>, since the maximum value of the first column is <code>3</code>, and the maximum value of the second column is <code>4</code>.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/8KjgTxTA/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>grid</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(1)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-258">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/queens-that-can-attack-the-king/description" target="_blank" rel="noopener noreferrer">Queens That Can Attack the King</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On a <strong>0-indexed</strong> <code>8 x 8</code> chessboard, there can be multiple black queens and one white king.</p>

<p>You are given a 2D integer array <code>queens</code> where <code>queens[i] = [xQueen<sub>i</sub>, yQueen<sub>i</sub>]</code> represents the position of the <code>i<sup>th</sup></code> black queen on the chessboard. You are also given an integer array <code>king</code> of length <code>2</code> where <code>king = [xKing, yKing]</code> represents the position of the white king.</p>

<p>Return <em>the coordinates of the black queens that can directly attack the king</em>. You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/21/chess1.jpg" style="width: 400px; height: 400px;" />
<pre>
<strong>Input:</strong> queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]
<strong>Output:</strong> [[0,1],[1,0],[3,3]]
<strong>Explanation:</strong> The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/12/21/chess2.jpg" style="width: 400px; height: 400px;" />
<pre>
<strong>Input:</strong> queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]
<strong>Output:</strong> [[2,2],[3,4],[4,4]]
<strong>Explanation:</strong> The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= queens.length &lt; 64</code></li>
	<li><code>queens[i].length == king.length == 2</code></li>
	<li><code>0 &lt;= xQueen<sub>i</sub>, yQueen<sub>i</sub>, xKing, yKing &lt; 8</code></li>
	<li>All the given positions are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-259">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/queries-on-a-matrix0443/1" target="_blank" rel="noopener noreferrer">Queries on a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a matrix of dimension n*n. All the cells are initially, zero.&nbsp;You are given Q queries, which contains 4 integers&nbsp;a b c d where (a,b) is the&nbsp;TOP LEFT cell and (c,d) is the Bottom Right cell of a submatrix. Now, all the cells of this submatrix have&nbsp;to be incremented by one. After all the Q queries have been performed. Your task is to find&nbsp;the final resulting Matrix.<br /><strong>Note</strong> : Zero-Based Indexing is used for cells of the matrix.&nbsp;</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 6, q = 6,
Queries = {
{4,0,5,3},
{0,0,3,4},
{1,2,1,2},
{1,1,2,3},
{0,0,3,1},
{1,0,2,4}}.
<strong>Output: </strong>
2 2 1 1 1 0
3 4 4 3 2 0 
3 4 3 3 2 0
2 2 1 1 1 0
1 1 1 1 0 0
1 1 1 1 0 0
<strong>Explanation:</strong>After incrementing all the
sub-matrices of given queries we will 
get the final output.</span>

</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, q = 2,
Queries = {
{0,0,3,3},
{0,0,2,2}}.
<strong>Output: </strong>
2 2 2 1 
2 2 2 1  
2 2 2 1 
1 1 1 1 
<strong>Explanation:</strong>After incrementing all the
sub-matrices of given queries we will
get the final output.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>solveQueries()&nbsp;</strong>which takes n and Queries and input parameter and returns a matrix after performing all the queries.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n<sup>2</sup>)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n<sup>2</sup>)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 1000<br />0 &lt;= a &lt;= c &lt;&nbsp;n<br />0 &lt;= b &lt;= d &lt;&nbsp;n<br />1 &lt;= No. of Queries &lt;= 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-260">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-query-2d-immutable/description" target="_blank" rel="noopener noreferrer">Range Sum Query 2D - Immutable</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:</p>

<ul>
	<li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>
</ul>

<p>Implement the <code>NumMatrix</code> class:</p>

<ul>
	<li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li>
	<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>
</ul>

<p>You must design an algorithm where <code>sumRegion</code> works on <code>O(1)</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" style="width: 415px; height: 415px;" />
<pre>
<strong>Input</strong>
[&quot;NumMatrix&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
<strong>Output</strong>
[null, 8, 11, 12]

<strong>Explanation</strong>
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>-10<sup>4</sup> &lt;= matrix[i][j] &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>
	<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRegion</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-261">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rank-transform-of-a-matrix/description" target="_blank" rel="noopener noreferrer">Rank Transform of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">topological-sort</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return <em>a new matrix </em><code>answer</code><em> where </em><code>answer[row][col]</code><em> is the </em><em><strong>rank</strong> of </em><code>matrix[row][col]</code>.</p>

<p>The <strong>rank</strong> is an <strong>integer</strong> that represents how large an element is compared to other elements. It is calculated using the following rules:</p>

<ul>
	<li>The rank is an integer starting from <code>1</code>.</li>
	<li>If two elements <code>p</code> and <code>q</code> are in the <strong>same row or column</strong>, then:
	<ul>
		<li>If <code>p &lt; q</code> then <code>rank(p) &lt; rank(q)</code></li>
		<li>If <code>p == q</code> then <code>rank(p) == rank(q)</code></li>
		<li>If <code>p &gt; q</code> then <code>rank(p) &gt; rank(q)</code></li>
	</ul>
	</li>
	<li>The <strong>rank</strong> should be as <strong>small</strong> as possible.</li>
</ul>

<p>The test cases are generated so that <code>answer</code> is unique under the given rules.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2],[3,4]]
<strong>Output:</strong> [[1,2],[2,3]]
<strong>Explanation:</strong>
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] &gt; matrix[0][1], matrix[1][1] &gt; matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[7,7],[7,7]]
<strong>Output:</strong> [[1,1],[1,1]]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg" style="width: 601px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
<strong>Output:</strong> [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-262">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rat-maze-with-multiple-jumps3852/1" target="_blank" rel="noopener noreferrer">Rat Maze With Multiple Jumps</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A maze is given as <strong>n*n</strong>&nbsp;matrix of blocks where source block is the upper left most block i.e., <strong>matrix[0][0]</strong> and destination block is lower rightmost block i.e., <strong>matrix[n-1][n-1]</strong>. A rat starts from source and has to reach the destination. </span></p>
<p><span style="font-size: 18px;">The rat can move in only two directions: first forward (if possible) or down. </span></p>
<p><span style="font-size: 18px;">In the maze matrix, <strong>0</strong> means the block is the <strong>dead </strong>end and <strong>non-zero number </strong>means the block can be used in the path from source to destination. The <strong>non-zero value</strong> of mat[i][j] indicates number of <strong>maximum </strong>jumps rat can make from cell <strong>mat[i][j]</strong>.&nbsp;</span></p>
<p><span style="font-size: 18px;">Return a maxtrix of size <strong>n*n </strong>in<strong> </strong>which&nbsp;</span><span style="font-size: 18px;"><strong>1</strong> at (i, j) represents the cell is taken into the path otherwise <strong>0</strong> .</span></p>
<p><span style="font-size: 18px;"><strong>Note :</strong> If multiple solutions exist, the shortest earliest hop will be accepted. For the same hop distance at any point, <strong>forward </strong>will be <strong>preferred </strong>over <strong>downward</strong>.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Example:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>{{2,1,0,0},{3,0,0,1},{0,1,0,1},
{0,0,0,1}}
<strong>Output: </strong>{{1,0,0,0},{1,0,0,1},{0,0,0,1},
{0,0,0,1}}
<strong>Explanation: </strong>Rat started with matrix[0][0] and 
can jump up to 2 steps right/down. First check 
matrix[0][1] as it is 1, next check 
matrix[0][2] ,this won't lead to the solution. 
Then check matrix[1][0], as this is 3(non-zero)
,so we can make 3 jumps to reach matrix[1][3]. 
From matrix[1][3] we can move downwards taking 
1 jump each time to reach destination at 
matrix[3][3].</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>{{2,1,0,0},{2,0,0,1},{0,1,0,1},
{0,0,0,1}}
<strong>Output:</strong> {{-1}}
<strong>Explanation: </strong>As no path exists so, -1.</span>
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anyhting, Your task is to complete the function&nbsp;<strong>ShortestDistance()&nbsp;</strong>which takes the matrix as input parameter and returns a matrix of size n if path exists otherwise returns a matrix of 1x1 which contains -1. In output matrix, 1&nbsp;at (i, j) represents the cell is taken into the path otherwise 0 if any path exists.</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n*n*k) where k is max(matrix[i][j])<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span><br />&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n &lt;= 50<br />1 &lt;= matrix[i][j] &lt;= 20</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-263">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reconstruct-a-2-row-binary-matrix/description" target="_blank" rel="noopener noreferrer">Reconstruct a 2-Row Binary Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the following details of a matrix with <code>n</code> columns and <code>2</code> rows :</p>

<ul>
	<li>The matrix is a binary matrix, which means each element in the matrix can be <code>0</code> or <code>1</code>.</li>
	<li>The sum of elements of the 0-th(upper) row is given as <code>upper</code>.</li>
	<li>The sum of elements of the 1-st(lower) row is given as <code>lower</code>.</li>
	<li>The sum of elements in the i-th column(0-indexed) is <code>colsum[i]</code>, where <code>colsum</code> is given as an integer array with length <code>n</code>.</li>
</ul>

<p>Your task is to reconstruct the matrix with <code>upper</code>, <code>lower</code> and <code>colsum</code>.</p>

<p>Return it as a 2-D integer array.</p>

<p>If there are more than one valid solution, any of them will be accepted.</p>

<p>If no valid solution exists, return an empty 2-D array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> upper = 2, lower = 1, colsum = [1,1,1]
<strong>Output:</strong> [[1,1,0],[0,0,1]]
<strong>Explanation: </strong>[[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> upper = 2, lower = 3, colsum = [2,2,1,1]
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]
<strong>Output:</strong> [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= colsum.length &lt;= 10^5</code></li>
	<li><code>0 &lt;= upper, lower &lt;= colsum.length</code></li>
	<li><code>0 &lt;= colsum[i] &lt;= 2</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-264">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/regions-cut-by-slashes/description" target="_blank" rel="noopener noreferrer">Regions Cut By Slashes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An <code>n x n</code> grid is composed of <code>1 x 1</code> squares where each <code>1 x 1</code> square consists of a <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or blank space <code>&#39; &#39;</code>. These characters divide the square into contiguous regions.</p>

<p>Given the grid <code>grid</code> represented as a string array, return <em>the number of regions</em>.</p>

<p>Note that backslash characters are escaped, so a <code>&#39;\&#39;</code> is represented as <code>&#39;\\&#39;</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/1.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;/ &quot;]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/2.png" style="width: 200px; height: 198px;" />
<pre>
<strong>Input:</strong> grid = [&quot; /&quot;,&quot;  &quot;]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/15/4.png" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> grid = [&quot;/\\&quot;,&quot;\\/&quot;]
<strong>Output:</strong> 5
<strong>Explanation: </strong>Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, or <code>&#39; &#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Many have found this problem to be a difficult medium problem, so if that is how you are feeling, you are not alone. <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a> is a good starter problem if you find yourself struggling with this one.</p>
<p>We are given an array of strings called <code>grid</code>, which contains three types of characters: forward slash <code>/</code>, backslash <code>\\</code>, and space <code>' '</code>. Each slash divides its cell into two contiguous sections, as shown in the following image:</p>
<p><img src="../Figures/959__re/image_1.png" alt="examples to show how the grid is formed" /></p>
<p>Our objective is to determine the total number of distinct regions formed within the grid as a result of these slash divisions.</p>
<hr />
<h3 id="approach-1-expanded-grid">Approach 1: Expanded Grid</h3>
<h4 id="intuition">Intuition</h4>
<p>When a cell in the grid contains a slash, it effectively divides it into two parts. A forward slash divides the cell into top-left and bottom-right sections, while a backslash divides it into top-right and bottom-left sections. As you can see in Example 2 of the problem, counting the regions directly is challenging since a divided cell does not always lead to an additional region.</p>
<p>To address this, we can magnify the grid by expanding each cell into a <span class="math inline">\(3 \times 3\)</span> sub-grid, with slashes represented by diagonal cells marked as barriers:</p>
<p><img src="../Figures/959__re/image_2.png" alt="" /></p>
<p>This transformation simplifies our task. If we treat the slashes and grid boundaries as water, and the remaining cells as land, the problem becomes analogous to the <a href="https://leetcode.com/problems/number-of-islands/description/">Number of Islands</a>.</p>
<p>We can solve this using the <a href="https://en.wikipedia.org/wiki/Flood_fill">flood-fill algorithm</a> to visit each connected region in the grid. We iterate over each cell of the grid and invoke <code>floodfill</code> whenever we encounter an unvisited land cell. The <code>floodfill</code> function explores all reachable land cells from the current cell and marks them as visited.  Then, we continue to iterate over each cell in the grid until we reach the next unvisited cell, which signifies the next land region. The total number of <code>floodfill</code> calls corresponds to the number of regions in the grid, which is our desired answer.</p>
<blockquote>
<p>Note: In our implementation, we use Breadth-First Search (BFS) for the flood-fill algorithm. Alternatively, Depth-First Search (DFS) can also be employed, yielding similar time and space complexities.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize an array <code>DIRECTIONS</code> to specify traversal directions: right, left, down, and up.</li>
</ul>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the original grid.</li>
<li>Create a new 2D array <code>expandedGrid</code> with dimensions three times the original grid size.</li>
<li>Iterate through each cell <code>(i, j)</code> in the original <code>grid</code>:
<ul>
<li>Calculate <code>baseRow</code> and <code>baseCol</code> as three times of <code>i</code> and <code>j</code>.</li>
<li>Check the character in the current cell:
<ul>
<li>If it is a backslash (<code>\\</code>):
<ul>
<li>Mark the cells in the main diagonal <code>(baseRow, baseCol)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol+2)</code> as <code>1</code>.</li>
</ul>
</li>
<li>If it is a forward slash (<code>/</code>):
<ul>
<li>Mark the other diagonal <code>(baseRow, baseCol+2)</code>, <code>(baseRow+1, baseCol+1)</code>, <code>(baseRow+2, baseCol)</code> as <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Initialize a counter <code>regionCount</code> to <code>0</code>.</li>
<li>Iterate through each cell <code>(i, j)</code> in <code>expandedGrid</code>:
<ul>
<li>If the cell is unvisited (value <code>0</code>):
<ul>
<li>Call the <code>floodfill</code> method to fill the region.</li>
<li>Increment <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as the total number of distinct regions.</li>
</ul>
<p>Helper method <code>floodfill</code>:</p>
<ul>
<li>Define a method <code>floodfill</code> with parameters: <code>expandedGrid</code> and the <code>row</code> and <code>col</code> indices.</li>
<li>Initialize a queue and add the starting cell <code>(row, col)</code> to it.</li>
<li>Mark the starting cell as visited by setting <code>expandedGrid[row][col]</code> to <code>1</code>.</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Dequeue <code>currentCell</code>.</li>
<li>For each <code>direction</code> in <code>DIRECTIONS</code>:
<ul>
<li>Set <code>newRow</code> as <code>currentCell[0] + direction[0]</code>.</li>
<li>Set <code>newCol</code> as <code>currentCell[1] + direction[1]</code>.</li>
<li>Check if the new cell is valid and unvisited using the <code>isValidCell</code> method:
<ul>
<li>If valid, mark the cell as visited and add it to the <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Helper method <code>isValidCell</code>.</p>
<ul>
<li>Define a method <code>isValidCell</code> with parameters: <code>expandedGrid</code>, <code>row</code>, and <code>col</code>.</li>
<li>Return <code>true</code> if the cell <code>(row, col)</code> is within bounds and unvisited.</li>
<li>Otherwise, return <code>false</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/MHLtBUxW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm populates the expanded grid by iterating over the original grid, which takes <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>In the worst case, the flood fill algorithm will visit every cell in the expanded grid once. The expanded grid is <span class="math inline">\(3n \times 3n\)</span>, resulting in <span class="math inline">\(O((3n)^2) = O(9n^2) = O(n^2)\)</span> operations.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(2 \cdot O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The expanded grid has dimensions <span class="math inline">\(3n \times 3n\)</span>, which requires <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>In the flood fill algorithm, the queue can store all <span class="math inline">\(9n^2\)</span> cells of the expanded grid in the worst case. This results in a space complexity of <span class="math inline">\(O(9n^2) = O(n^2)\)</span>.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2) + O(n^2) = O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-disjoint-set-union-triangles">Approach 2: Disjoint Set Union (Triangles)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our previous approach involved magnifying each cell into a <span class="math inline">\(3 \times 3\)</span> grid, increasing the number of unit cells by a factor of 9. We can further optimize this process by reconceptualizing how regions are formed and connected. Instead of viewing the grid as squares, let's envision each cell divided into four triangles. This allows for a more precise representation of slashes.</p>
<p><img src="../Figures/959__re/image_3.png" alt="cell divided into four triangles" /></p>
<p>Initially, each triangle is considered its own region. As we traverse the grid, we can group together all triangles not separated by slashes as belonging to one component (region). The total number of these groups will be our required answer.</p>
<p>A widely used data structure for grouping connected components is the Disjoint Set Union (DSU). A DSU assigns each component (a unit triangle) a parent, which is initially itself. To connect or union two components, we assign them to the same parent, meaning units with the same parent belong to the same connected component. To learn more about how the disjoint set union data structure is implemented, refer to this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/">Explore Card</a>.</p>
<p>We iterate over the grid and perform two main types of operations:</p>
<ol>
<li>
<p>Union adjacent components:</p>
<p>Regardless of whether a cell contains a forward slash or backslash, the top triangle of a cell will always connect to the bottom triangle of the cell above it. The same principle applies to the left triangle of a cell and the right triangle of the cell to its left.</p>
<p><img src="../Figures/959__re/image_4.png" alt="connecting top and left cells" /></p>
</li>
<li>
<p>Union intra-cell components:</p>
<p>A slash divides the cell diagonally, allowing us to combine the two adjacent triangles on each side of the diagonal.</p>
</li>
</ol>
<p>We begin with the total number of triangles as our initial region count. Each successful union operation indicates that two distinct components have been merged into one, reducing the total number of regions by one. After processing all cells, the remaining count represents the number of distinct regions.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Set <code>gridSize</code> as the size of the <code>grid</code>.</li>
<li>Calculate <code>totalTriangles</code> in the grid as <code>gridSize * gridSize * 4</code>.</li>
<li>Create a <code>parentArray</code> to represent the disjoint sets of triangles and initialize each element to <code>-1</code>.</li>
<li>Initialize <code>regionCount</code> to <code>totalTriangles</code>, assuming each triangle is initially a separate region.</li>
<li>Iterate through each cell of <code>grid</code>:
<ul>
<li>If there is a cell above the current cell, union the bottom triangle of the above cell with the top triangle of the current cell.</li>
<li>If there is a cell to the left of the current cell, union the right triangle of the left cell with the left triangle of the current cell.</li>
<li>If the current cell is not <code>/</code>:
<ul>
<li>Union the top triangle with the right triangle.</li>
<li>Union the bottom triangle with the left triangle.</li>
</ul>
</li>
<li>If the current cell is not <code>\\</code>:
<ul>
<li>Union the top triangle with the left triangle.</li>
<li>Union the bottom triangle with the right triangle.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>regionCount</code> as our answer.</li>
</ul>
<p>Helper method <code>getTriangleIndex</code>:</p>
<ul>
<li>Define a method <code>getTriangleIndex</code> with parameters: <code>gridSize</code>, the <code>row</code> and <code>col</code> indices, and the <code>triangleNum</code>.</li>
<li>Return <code>(gridSize * row + col) * 4 + triangleNum</code>.</li>
</ul>
<p>Helper method <code>unionTriangles</code>:</p>
<ul>
<li>Define a method <code>unionTriangles</code> with parameters: <code>parentArray</code> and the two indices <code>x</code> and <code>y</code>.</li>
<li>Find <code>parentX</code> and <code>parentY</code> using the <code>findParent</code> method.</li>
<li>If <code>parentX</code> is not equal to <code>parentY</code>:
<ul>
<li>Set <code>parentArray[parentX]</code> to <code>parentY</code> and return <code>1</code>.</li>
</ul>
</li>
<li>Return <code>0</code>.</li>
</ul>
<p>Helper method <code>findParent</code>:</p>
<ul>
<li>Define a method <code>findParent</code> with parameters: <code>parentArray</code> and the index <code>x</code>.</li>
<li>If <code>parentArray[x]</code> is equal to <code>-1</code>:
<ul>
<li><code>x</code> has no parent. Return <code>x</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[x]</code> to the parent of <code>parentArray[x]</code> using <code>findParent</code>. Return <code>parentArray[x]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gejLBoVS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span></p>
<p>Initializing the <code>parentArray</code> takes <span class="math inline">\(O(4 \cdot n^2)\)</span> time.</p>
<p>The main loop iterates over all <span class="math inline">\(n^2\)</span> cells in the grid. In each iteration, it calls the <code>unionTriangles</code> method which includes <code>findPath</code> operations. With path compression, the amortized time complexity of <code>findPath</code> is denoted as <span class="math inline">\(\alpha(n)\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. Thus, the time complexity of the loop comes out to be <span class="math inline">\(O(n^2 \cdot \alpha (n))\)</span>.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(4 \cdot n^2) + O(n^2 \cdot \alpha (n)) = O(n^2 \cdot \alpha (n))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The only additional data structure used by the algorithm is the <code>parentArray</code>, which takes <span class="math inline">\(O(n^2)\)</span> space.</p>
<p>The recursive <code>find</code> operation can have a call stack of size <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the overall space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-disjoint-set-union-graph">Approach 3: Disjoint Set Union (Graph)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's shift our perspective and consider slashes as connectors rather than dividers. Imagine each cell as a graph with four vertices at its corners, with slashes acting as edges between these vertices. The following diagram illustrates this concept:</p>
<p><img src="../Figures/959__re/image_5.png" alt="cell as a graph" /></p>
<p>In this paradigm, a slash can be represented as follows:</p>
<ul>
<li>A <code>/</code> slash connects the top-right point of a cell to the bottom-left point.</li>
<li>A <code>\</code> slash connects the top-left point to the bottom-right point.</li>
<li>An empty space doesn't add any new connections.</li>
</ul>
<p>The edges of the grid form the boundaries of the graph, creating an initial region. As we connect vertices (slashes), cycles may form, indicating the creation of new regions within the graph. By tracking the total number of cycles formed while iterating over all slashes, we determine the final count of regions.</p>
<p>To manage connected components, we use a DSU (Disjoint Set Union) data structure. We start by connecting the boundary points as the first region. As we process each cell, we treat each slash as an edge and union the corresponding vertices. If a union operation reveals that the vertices already share the same parent, it indicates a cycle, prompting us to increment our counter.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p>Main method <code>regionsBySlashes</code>:</p>
<ul>
<li>Initialize variables:
<ul>
<li><code>gridSize</code> to the length of <code>grid</code>.</li>
<li><code>pointsPerSide</code> to <code>gridSize + 1</code>.</li>
<li><code>totalPoints</code> to <code>pointsPerSide * pointsPerSide</code>.</li>
</ul>
</li>
<li>Create an array <code>parentArray</code> to represent the disjoint set, initialized with <code>-1</code>.</li>
<li>Loop over the each point:
<ul>
<li>If the point lies on the border, set its <code>parent</code> to <code>0</code>.</li>
</ul>
</li>
<li>Set <code>parent[0]</code> (top-left corner) to <code>-1</code> to make it the root.</li>
<li>Initialize <code>regionCount</code> to <code>1</code>, accounting for the border region.</li>
<li>Iterate through each cell <code>(i, j)</code> in the <code>grid</code>:
<ul>
<li>If it's a forward slash (<code>/</code>):
<ul>
<li>Calculate the <code>topRight</code> and <code>bottomLeft</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
<li>If it's a backslash (<code>\\</code>):
<ul>
<li>Calculate the <code>topLeft</code> and <code>bottomRight</code> indices.</li>
<li>Call <code>union</code> on these points and add the result to <code>regionCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the final <code>regionCount</code>.</li>
</ul>
<p>Helper method <code>find</code>:</p>
<ul>
<li>Define a method <code>find</code> with parameters: <code>parentArray</code> and the <code>node</code>.</li>
<li>If <code>parentArray[node]</code> is equal to <code>-1</code>:
<ul>
<li><code>node</code> does not have any parent. Return <code>node</code>.</li>
</ul>
</li>
<li>Set <code>parentArray[node]</code> to the parent of <code>parentArray[node]</code> using the <code>find</code> method. Return <code>parentArray[node]</code>.</li>
</ul>
<p>Helper method <code>union</code>:</p>
<ul>
<li>Define a method union with parameters: <code>parentArray</code> and nodes <code>node1</code> and <code>node2</code>.</li>
<li>Set <code>parent1</code> to <code>parent2</code> to the parents of <code>node1</code> and <code>node2</code> respectively.</li>
<li>If <code>parent1</code> is equal to <code>parent2</code>, return <code>1</code>.</li>
<li>Set <code>parentArray[parent2]</code> to <code>parent1</code>.</li>
<li>Return <code>0</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/C84Mt6ZN/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the height and width of the <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span></p>
<p>Filling the parent array requires <span class="math inline">\(O((n+1) \cdot (n+1))\)</span> time, which can be simplified to <span class="math inline">\(O(n^2)\)</span>. Connecting the border points requires another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>As the algorithm iterates over the grid, it potentially performs two <code>union</code> operations for each cell. The time complexity of a single <code>find</code>/<code>union</code> operation is <span class="math inline">\(O(\alpha (n^2))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function. We perform at most <span class="math inline">\(O(n^2)\)</span> union operations, making the complexity of this part <span class="math inline">\(O(n^2 \cdot \alpha (n^2))\)</span>.</p>
<p>Thus, the overall time complexity is <span class="math inline">\(2 \cdot O(n^2) + O(n^2 \cdot 2 \alpha (n^2)) = O(n^2 \cdot \alpha (n^2))\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm creates an array of size <span class="math inline">\((n+1)^2\)</span>, which is <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The recursive call stack for <code>find</code> operation is <span class="math inline">\(O(\log n)\)</span> in the worst case.</p>
<p>Thus, the total time complexity of the algorithm is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-265">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/replace-os-with-xs0052/1" target="_blank" rel="noopener noreferrer">Replace O&#39;s with X&#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">recursion</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix <strong>mat</strong>&nbsp;where every element is either 'O' or 'X'. Replace all 'O' or a group of 'O' with 'X' that are surrounded by 'X'. </span></p>
<p><span style="font-size: 18px;">A 'O' (or a set of 'O') is considered to be surrounded by 'X' if there are 'X' at locations just below, just above, just left and just right of it.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'X', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Output:</strong> <br />[['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Explanation:</strong> We only changed those 'O' that are surrounded by 'X'</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'O', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Output:</strong> <br />[['X', 'O', 'X', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'O', 'O', 'X'], <br />['X', 'O', 'X', 'X'], <br />['X', 'X', 'O', 'O']]
<strong>Explanation:</strong> There's no 'O' that's surround by 'X'.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong> mat = <br />[['X', 'X', 'X'], <br />['X', 'O', 'X'], <br />['X', 'X', 'X']]
<strong>Output:</strong> <br />[['X', 'X', 'X'], <br />['X', 'X', 'X'], <br />['X', 'X', 'X']]
<strong>Explanation:</strong> There's only one 'O' that's surround by 'X'.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 100<br />1 &le; mat[0].size() &le; 100<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-266">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reshape-the-matrix/description" target="_blank" rel="noopener noreferrer">Reshape the Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In MATLAB, there is a handy function called <code>reshape</code> which can reshape an <code>m x n</code> matrix into a new one with a different size <code>r x c</code> keeping its original data.</p>

<p>You are given an <code>m x n</code> matrix <code>mat</code> and two integers <code>r</code> and <code>c</code> representing the number of rows and the number of columns of the wanted reshaped matrix.</p>

<p>The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>

<p>If the <code>reshape</code> operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg" style="width: 613px; height: 173px;" />
<pre>
<strong>Input:</strong> mat = [[1,2],[3,4]], r = 1, c = 4
<strong>Output:</strong> [[1,2,3,4]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg" style="width: 453px; height: 173px;" />
<pre>
<strong>Input:</strong> mat = [[1,2],[3,4]], r = 2, c = 4
<strong>Output:</strong> [[1,2],[3,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>
	<li><code>1 &lt;= r, c &lt;= 300</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-267">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/retroactive-integers/" target="_blank" rel="noopener noreferrer">Retroactive Integers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">medium</span> <span class="topic-badge">segmenttrees</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You're maintaining 20 variables: <span class="mathjax-latex">\(a, b, c, \dots, r, s, t\)</span>. At any moment of time value of any variable is integer between <em>0</em> and <span class="mathjax-latex">\(1,000,000,006\)</span>, inclusive. All arithmetic operations with variables are modulo <span class="mathjax-latex">\(1,000,000,007\)</span>. 
Initially (at moment <em>0</em>) all variables are set to <em>0</em>. At some moments of time, you get queries. Queries have 5 different types:  </p>
<ol>
<li><span class="mathjax-latex">\(\textrm{"?  x"}\)</span> print value of variable <em>x</em>. </li>
<li><span class="mathjax-latex">\(\textrm{"=  x   y"}\)</span> write value of variable <em>y</em> to variable <em>x</em>.  </li>
<li><span class="mathjax-latex">\(\textrm{"!  x  c"}\)</span> set variable <em>x</em> to <em>c</em>.  </li>
<li><span class="mathjax-latex">\(\textrm{"+  x  c"}\)</span> add <em>c</em> to variable <em>x</em>.  </li>
<li><span class="mathjax-latex">\(\textrm{"*  x  c"}\)</span> multiply variable <em>x</em> by <em>c</em>.  </li>
</ol>
<p>Also with each query you are given a positive integer --- time when you need to apply this query to variables.  Times can go in arbitrary order. See sample for further clarification.  </p>
<p><strong>Input Format:</strong><br />
First line contain one integer <em>q</em>  --- number of queries.<br />
Next <em>q</em> lines contains queries. <em>i</em>-th query starts with integer <span class="mathjax-latex">\(t_i\)</span> --- time this query should be made at.<br />
Then one of 5 query goes in format, described in the statement.  </p>
<p><strong>Output Format:</strong><br />
For each query of the first time print the corresponding value.  </p>
<p><strong>Constraints:</strong><br />
<span class="mathjax-latex">\(1 \leqslant q \leqslant 100,000.\)</span><br />
<span class="mathjax-latex">\(1 \leqslant t_i \leqslant 1,000,000,000.\)</span><br />
All <span class="mathjax-latex">\(t_i\)</span> are distinct.<br />
In all queries, <span class="mathjax-latex">\(x, y \in \{a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t \}.\)</span> <br />
Also in all queries <span class="mathjax-latex">\(0 \leqslant c \leqslant 1,000,000,006.\)</span>  </p>
<p><strong>Scoring:</strong><br />
<strong>20 points</strong><br />
Additionally <span class="mathjax-latex">\(q \leqslant 5,000\)</span>.<br />
<strong>20 points</strong><br />
Additionally, in all queries, <span class="mathjax-latex">\(x = y = a\)</span>.<br />
Also queries only of types <span class="mathjax-latex">\(\textrm{*, +, ?}\)</span> are present.<br />
<strong>20 points</strong> <br />
Additionally, in all queries <span class="mathjax-latex">\(x, y \in \{a, b, c, d, e\}\)</span>.<br />
<strong>40 points</strong> <br />
No additional constraints.</p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><ol>
<li>No queries added before time <span class="mathjax-latex">\(10\)</span>, so value of <em>e</em> is <em>0</em>.  </li>
<li>From moment <span class="mathjax-latex">\(20\)</span>, <span class="mathjax-latex">\(b=a\)</span>.  </li>
<li>From moment <span class="mathjax-latex">\(30\)</span>, <span class="mathjax-latex">\(b=10a\)</span>.  </li>
<li>From moment <span class="mathjax-latex">\(40\)</span>, <span class="mathjax-latex">\(b=10a+1\)</span>.  </li>
<li>At moment <span class="mathjax-latex">\(60\)</span>: <span class="mathjax-latex">\(b = 10a + 1 = 10 \cdot 0 + 1 = 1\)</span>.  </li>
<li>From moment <em>5</em>, <span class="mathjax-latex">\(a = 10\)</span>.  </li>
<li>So, at moment <span class="mathjax-latex">\(70\)</span>, <span class="mathjax-latex">\(b=10a + 1 = 10\cdot 10 + 1 = 101\)</span> because <em>a</em> changed its value at moment 5.  </li>
<li>At moment <span class="mathjax-latex">\(25\)</span>: <span class="mathjax-latex">\(b = a = 10\)</span>.</li>
</ol></div>
				</div>
			
		</div>

<div class="question-card" id="question-268">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reverse-spiral-form-of-matrix4033/1" target="_blank" rel="noopener noreferrer">Reverse Spiral Form of Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a matrix as 2D array. Find the reverse&nbsp;spiral traversal of the matrix.&nbsp;<br />
<br />
<strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input</strong>: R = 3, C = 3
  a = {{9, 8, 7},
       {6, 5, 4},
&nbsp;      {3, 2, 1}}
<strong>Output: </strong>5 6 3 2 1 4 7 8 9
<strong>Explanation</strong>: Spiral form of the matrix
in reverse order starts from the centre 
and goes outward.
<img alt="" src="https://media.geeksforgeeks.org/img-practice/ScreenShot2022-10-17at10-1665981362.png" style="height:181px; width:200px" /></span>

</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>R = 4, C = 4<strong> 
</strong>  a = {{1, 2, 3, 4},
       {5, 6, 7, 8},
&nbsp;      {9, 10, 11, 12}, 
&nbsp;      {13, 14, 15, 16}}
<strong>Output: </strong>10 11 7 6 5 9 13 14 15 16 12 8 4 3 2 1
<strong>Explanation</strong>: 
<img alt="" src="https://media.geeksforgeeks.org/img-practice/ScreenShot2022-10-17at10-1665981582.png" />
</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:&nbsp;&nbsp;</strong><br />
You dont need to read input or print anything. Complete the function <strong>reverseSpiral()&nbsp;</strong>which takes <strong>R, C </strong>and<strong> a</strong>&nbsp;as input parameters and returns the matrix in reverse spiral form.</span><br />
<br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(R*C)<br />
<strong>Expected Auxiliary Space:</strong> O(R*C)<br />
<br />
<strong>Constraints:</strong><br />
1&nbsp;&lt;= R,C&nbsp;&lt;=100<br />
1&nbsp;&lt;= a[R][C] &lt;=100</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-269">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/reversing-the-columns-of-a-matrix-1587115621/1" target="_blank" rel="noopener noreferrer">Reversing the columns of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix of size <strong>n x m</strong>, reverse the order of its columns in-place so that the last column becomes the first, the second-last becomes the second, and so on.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 4, m = 3, matrix[][] = [[1, 2, 3], [5, 6, 7], [11, 10, 9], [13, 14, 15]]
<strong>Output: </strong>[[3, 2, 1], [7, 6, 5], [9, 10, 11], [15, 14, 13]]
<strong>Explanation: </strong>Array after exchanging columns:
              [[3, 2, 1],
               [7, 6, 5],
               [9, 10, 11],
               [15, 14, 13]]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>n = 2, m = 5, matrix[][] = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
<strong>Output:</strong> [[5, 4, 3, 2, 1], [10, 9, 8, 7, 6]]
<strong>Explanation: </strong>After reversing the column of matrix
                [[5, 4, 3, 2, 1]
                 [10, 9, 8, 7, 6]]</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 100<br />0 &le; matrix[i][j] &le; 1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-270">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/rhezo-and-special-gift-2882de10/" target="_blank" rel="noopener noreferrer">Rhezo and Special Gift</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">medium</span> <span class="topic-badge">twodimensional</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given infinite arrow-bundles, but there are exactly <em>M</em> <strong>distinct</strong> arrow-bundles. Let us denote them from <em>1</em> to <em>M</em>. An arrow-bundle is defined as a set of some number of arrows.</p>

<p>You are also given a target, on which you need to shoot exactly <em>N</em> arrows. In order to do this, you need to pick some arrow-bundles. If you pick some arrow-bundle, you have to use all its arrows and shoot it at the target.</p>

<p>If you can shoot <em>N</em> arrows at the target, you will receive a special gift from Rhezo. For shooting the arrows at target, you have to choose some sequence of arrow-bundles. You are pro at shooting arrows and never miss any shot.</p>

<p>You want to find the number of distinct ways of choosing some sequence of indices of arrow-bundles such that you will receive the gift from Rhezo. Two sequences of indices are distinct if they have different lengths or value at some index is not equal in them.</p>

<p><strong>Input:</strong></p>

<p>First line contains <em>2</em> space separated integers <em>N</em> and <em>M</em>. Next line contains <em>M</em> space separated integers where <span class="mathjax-latex">\(i^{th}\)</span> number denotes the number of arrows in <span class="mathjax-latex">\(i^{th}\)</span> arrow-bundle.</p>

<p><strong>Output:</strong></p>

<p>Please find the number of distinct ways in which you can get the special gift from Rhezo. As this number can be very large, output your answer modulo <span class="mathjax-latex">\(10^9+7\)</span>.</p>

<p><strong>Constraints:</strong></p>

<p><span class="mathjax-latex">\(1 \le N \le 10^{18}\)</span></p>

<p><span class="mathjax-latex">\(1\le M \le 100\)</span></p>

<p><span class="mathjax-latex">\(1 \le \)</span> Arrows in each arrow-bundle <span class="mathjax-latex">\( \le 100\)</span></p>

<p><span class="mathjax-latex">\(40\%\)</span> tests have <span class="mathjax-latex">\(1 \le N \le 10000\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>The <em>5</em> sequences are:</p>

<p><span class="mathjax-latex">\(1.[1,1,1,1]\)</span></p>

<p><span class="mathjax-latex">\(2.[2,1,1]\)</span></p>

<p><span class="mathjax-latex">\(3.[1,2,1]\)</span></p>

<p><span class="mathjax-latex">\(4.[1,1,2]\)</span></p>

<p><span class="mathjax-latex">\(5.[2,2]\)</span></p></div>
				</div>
			
		</div>

<div class="question-card" id="question-271">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/richest-customer-wealth/description" target="_blank" rel="noopener noreferrer">Richest Customer Wealth</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer grid <code>accounts</code> where <code>accounts[i][j]</code> is the amount of money the <code>iâ€‹â€‹â€‹â€‹â€‹<sup>â€‹â€‹â€‹â€‹â€‹â€‹th</sup>â€‹â€‹â€‹â€‹</code> customer has in the <code>jâ€‹â€‹â€‹â€‹â€‹<sup>â€‹â€‹â€‹â€‹â€‹â€‹th</sup></code>â€‹â€‹â€‹â€‹ bank. Return<em> the <strong>wealth</strong> that the richest customer has.</em></p>

<p>A customer&#39;s <strong>wealth</strong> is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum <strong>wealth</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[1,2,3],[3,2,1]]
<strong>Output:</strong> 6
<strong>Explanation</strong><strong>:</strong>
<code>1st customer has wealth = 1 + 2 + 3 = 6
</code><code>2nd customer has wealth = 3 + 2 + 1 = 6
</code>Both customers are considered the richest with a wealth of 6 each, so return 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[1,5],[7,3],[3,5]]
<strong>Output:</strong> 10
<strong>Explanation</strong>: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> accounts = [[2,8,7],[7,1,3],[1,9,5]]
<strong>Output:</strong> 17
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;accounts.length</code></li>
	<li><code>n ==&nbsp;accounts[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-272">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rohans-love-for-matrix4723/1" target="_blank" rel="noopener noreferrer">Rohan&#39;s Love for Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Rohan has a special love for matrices especially for the first element of the matrix. Being good at Mathematics, he also loves to solve the different problems on matrices. So one day he started to <strong>multiply</strong>&nbsp;the matrix with the&nbsp;<strong>original matrix</strong>.&nbsp; The elements of the&nbsp;<strong>original matrix</strong>&nbsp;<strong>a&nbsp;</strong>are given by&nbsp;<strong>[a<sub>00</sub>=1, a<sub>01</sub>=1, a<sub>10</sub>=1, a<sub>11</sub>=0]</strong>.<br />Given the power of the matrix,<strong>&nbsp;n</strong> calculates the&nbsp;<strong>a<sup>n</sup></strong> and returns&nbsp;the&nbsp;<strong>a<sub>10</sub></strong>&nbsp;element&nbsp;<strong>mod</strong>&nbsp;<strong>1000000007</strong>.</span><br /><br /><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: <br />n = 3
<strong>Output:</strong>&nbsp;<br />2&nbsp;
<strong>Explanation</strong>: Take the cube of the original matrix 
i.e <strong>a<sup>3</sup></strong> and the (<strong>a<sub>10</sub></strong>)<sup>th</sup> element is 2.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: <br /></strong><span style="font-size: 18px;">n = 4
</span><strong style="font-size: 18px;">Output:&nbsp;<br /></strong><span style="font-size: 18px;">3
</span><strong style="font-size: 18px;">Explanation</strong><span style="font-size: 18px;">: Take the quartic of the original matrix 
i.e </span><strong style="font-size: 18px;">a<sup>4</sup></strong><span style="font-size: 18px;"> and the (</span><strong style="font-size: 18px;">a<sub>10</sub></strong><span style="font-size: 18px;">)</span><sup style="font-size: 18px;">th </sup><span style="font-size: 18px;">element is 3.
</span></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:&nbsp;&nbsp;</strong><br />You don't need to read input or print anything. Complete the function <strong>firstElement()&nbsp;</strong>which takes&nbsp;<strong>n</strong> as the input parameter and returns the&nbsp;<strong>a<sub>10</sub></strong>&nbsp;element&nbsp;<strong>mod 1000000007&nbsp;</strong>of&nbsp;<strong>a<sup>n</sup></strong><sup>.</sup></span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(n)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;= n&nbsp;&lt;=10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-273">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/c-matrix-rotation-by-180-degree0745/1" target="_blank" rel="noopener noreferrer">Rotate a Matrix by 180 Counterclockwise</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D square matrix <strong>mat</strong>[][] of size <strong>n x n</strong>, rotate it by <strong>180</strong> <strong>degrees</strong> without using extra space.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;</span><span style="font-size: 18px;">You must rotate the matrix<strong> in place </strong>and</span><span style="font-size: 18px;">&nbsp;modify the input matrix directly.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] =<strong> </strong>[[1, 2],
                [3, 4]]
<strong>Output: </strong>[[4, 3], 
        [2, 1]]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong> mat[][] = [[1, 2, 3], 
                [4, 5, 6],
                [7, 8, 9]]
<strong>Output: </strong>[[9, 8, 7], 
        [6, 5, 4], 
        [3, 2, 1]]</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 500<br />0 &le; mat[i][j] &le;&nbsp;10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-274">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rotate-by-90-degree-1587115621/1" target="_blank" rel="noopener noreferrer">Rotate by 90 degree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a<strong> </strong>square<strong> </strong>matrix <strong>mat</strong>[][] of size <strong>n x n</strong>. The task is to rotate it by<strong> 90 degrees</strong> in an<strong> anti-clockwise</strong> direction without using any extra space.&nbsp;</span><br /><br /><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[0, 1, 2], <br />                [3, 4, 5], <br />                [6, 7, 8]] 
<strong>Output</strong>: [[2, 5, 8],
        [1, 4, 7],
        [0, 3, 6]]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[1, 2],
&nbsp;               [3, 4]]
<strong>Output</strong>: [[2, 4],<br /></span><span style="font-size: 18px;">        [1, 3]]<br /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>2</sup><br />0 &le; mat[i][j] &le; 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-275">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/left-rotate-matrix-k-times2351/1" target="_blank" rel="noopener noreferrer">Rotate Each Row of Matrix K Times</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">modulararithmetic</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an integer <strong>k </strong>and<strong> </strong>matrix&nbsp;<strong>mat.&nbsp;</strong>Rotate the elements of the given matrix to the left <strong>k</strong> times and return the resulting matrix.</span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>k=1, mat=[[1,2,3]<br />                 [4,5,6]<br />                 [7,8,9]]
<strong>Output: </strong>[[2, 3, 1]<br />         [5, 6, 4]
         [8, 9, 7]]
<strong>Explanation: </strong>Rotate the matrix by one<br />1 2 3       2 3 1<br />4 5 6  =&gt;  5 6 4<br /></span><span style="font-size: 14pt;">7 8 9       8 9 7</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>k=2, mat=[[1, 2, 3]<br />                 [4, 5, 6]<br />                 [7, 8, 9]]
<strong>Output: </strong>[[3, 1, 2]
         [6, 4, 5]
         [9, 7, 8]]
<strong>Explanation:<span style="font-size: 14pt;"> </span></strong><span style="font-size: 14pt;">After rotating the matrix looks like<br />1 2 3       2 3 1       3 1 2<br />4 5 6  =&gt;  5 6 4  =&gt;   6 4 5<br /></span></span><span style="font-size: 14pt;">7 8 9       8 9 7       9 7 8</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity: </strong>O(n*m)<br /><strong>Expected Auxillary Space: </strong>O(n*m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1&lt;=k&lt;=10<sup>4</sup><strong><br /></strong></span><span style="font-size: 18px;">1&lt;= mat.size(), mat[0].size, mat[i][j] &lt;=1000<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-276">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotate-image/description" target="_blank" rel="noopener noreferrer">Rotate Image</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>

<p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" style="width: 500px; height: 188px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" style="width: 500px; height: 201px;" />
<pre>
<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == matrix.length == matrix[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-277">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rotate-matrix-elements-clockwise2336/1" target="_blank" rel="noopener noreferrer">Rotate matrix elements clockwise</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two integers M, N, and a 2D matrix Mat of dimensions MxN, clockwise rotate the elements in it.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
M=3,N=3
Mat=[[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong>
4 1 2
7 5 3
8 9 6
<strong>Explanation:</strong>
Rotating the matrix clockwise gives this result.</span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
M=2,N=3
Mat=[[1,2,3],[2,3,3]]
<strong>Output:</strong>
2 1 2
3 3 3
<strong>Explanation:</strong>
Rotating the matrix clockwise gives this result.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>rotateMatrix()</strong> which takes two integers M, N, and a 2D matrix as input parameters and returns the clockwise rotated matrix.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>O(M*N)<br /><strong>Expected Auxillary Space:</strong>O(1)</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=M,N,Mat[i][j]&lt;=1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-278">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotating-the-box/description" target="_blank" rel="noopener noreferrer">Rotating the Box</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two-pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix of characters <code>boxGrid</code> representing a side-view of a box. Each cell of the box is one of the following:</p>

<ul>
	<li>A stone <code>&#39;#&#39;</code></li>
	<li>A stationary obstacle <code>&#39;*&#39;</code></li>
	<li>Empty <code>&#39;.&#39;</code></li>
</ul>

<p>The box is rotated <strong>90 degrees clockwise</strong>, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity <strong>does not</strong> affect the obstacles&#39; positions, and the inertia from the box&#39;s rotation <strong>does not </strong>affect the stones&#39; horizontal positions.</p>

<p>It is <strong>guaranteed</strong> that each stone in <code>boxGrid</code> rests on an obstacle, another stone, or the bottom of the box.</p>

<p>Return <em>an </em><code>n x m</code><em> matrix representing the box after the rotation described above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png" style="width: 300px; height: 150px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> [[&quot;.&quot;],
&nbsp;        [&quot;#&quot;],
&nbsp;        [&quot;#&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png" style="width: 375px; height: 195px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;.&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;]]
<strong>Output:</strong> [[&quot;#&quot;,&quot;.&quot;],
&nbsp;        [&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;*&quot;,&quot;*&quot;],
&nbsp;        [&quot;.&quot;,&quot;.&quot;]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png" style="width: 400px; height: 218px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;]]
<strong>Output:</strong> [[&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;#&quot;,&quot;#&quot;,&quot;*&quot;],
&nbsp;        [&quot;#&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;        [&quot;#&quot;,&quot;.&quot;,&quot;*&quot;],
&nbsp;        [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == boxGrid.length</code></li>
	<li><code>n == boxGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>boxGrid[i][j]</code> is either <code>&#39;#&#39;</code>, <code>&#39;*&#39;</code>, or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> grid that represents the side view of a box, containing stones (denoted as <code>'#'</code>) and immovable obstacles (denoted as <code>'*'</code>), as well as some empty cells in between (<code>'.'</code>).</p>
<p>Our task is to simulate a 90-degree clockwise rotation of this box. After rotating, we must apply &quot;gravity&quot; to make the rocks fall as far down as possible, without moving the obstacles. The goal is to return the final layout of the box, as a new <code>n x m</code> grid, after both the rotation and gravity effects.</p>
<hr />
<h3 id="approach-1-row-by-row-brute-force">Approach 1: Row by Row (Brute Force)</h3>
<h4 id="intuition">Intuition</h4>
<p>In this approach, we separate the task into two distinct operations: first, rotating the grid; then, applying the gravity effect. We execute each operation independently to simplify the process.</p>
<h6 id="1-rotate-the-grid">1. Rotate the grid</h6>
<p>Let's start by observing how the grid changes after a 90-degree clockwise rotation:</p>
<ul>
<li>The first row of the input grid becomes the last column of the output grid.</li>
<li>The second row of the input grid becomes the second-to-last column of the output grid.</li>
<li>...</li>
<li>The last row of the input grid becomes the first column of the output grid.</li>
</ul>
<blockquote>
<p>The <strong>transpose</strong> of a matrix is obtained by interchanging rows into columns or columns to rows.</p>
</blockquote>
<p>If you aren't familiar with this concept, you might want to try out this problem first: <a href="https://leetcode.com/problems/transpose-matrix/description/">867. Transpose Matrix</a>, as a good lead-in to this one.<br />
Let's try to express this pattern, using the <strong>transpose</strong> of the original grid:</p>
<ul>
<li>The first column of the transpose grid becomes the last column of the output grid.</li>
<li>The second column of the transpose grid becomes the second-to-last column of the output grid.</li>
<li>...</li>
<li>The last column of the transpose grid becomes the first column of the output grid.</li>
</ul>
<p>We can break down this rotation step further: first, find the transpose of the input grid, then reverse each row in the transpose grid.</p>
<p><img src="../Figures/1861/1861_rotate_operation.png" alt="rotate operation" /></p>
<h6 id="2-apply-the-gravity-effect">2. Apply the gravity effect</h6>
<p>To apply the gravity effect to the rotated grid, we can follow a simple approach: for each empty cell, identify the first stone directly above it, ensuring there are no obstacles in between. This way, each stone falls to the lowest possible empty cell beneath it.</p>
<p>!?!../Documents/1861/1861_approach1_fix.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>.</li>
<li>Set <code>result</code> to be the transpose of the input grid:
<ul>
<li>Iterate over the rows with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>Iterate over the columns with <code>j</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Set <code>result[j][i] = box[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Reverse the order of elements in each row of the transpose grid.</li>
<li>Iterate over the columns of the rotated grid with <code>j</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each column <code>j</code>, iterate over its elements with <code>i</code> from <code>n-1</code> to <code>0</code>:
<ul>
<li>If <code>result[i][j]</code> is an empty cell:
<ul>
<li>Initialize <code>nextRowWithStone</code> to <code>-1</code>.</li>
<li>Loop through all rows above <code>i</code> with <code>k</code> from <code>i-1</code> to <code>0</code>.
<ul>
<li>If <code>result[k][j]</code> contains an obstacle, exit the loop.</li>
<li>If <code>result[k][j]</code> contains a stone, set <code>nextRowWithStone</code> equal to <code>k</code> and exit the loop.</li>
</ul>
</li>
<li>If the loop ends and <code>nextRowWithStone</code> remains equal to <code>-1</code>, no stone exists above the current empty cell with no obstacles in between; continue.</li>
<li>Else, let the stone in <code>result[nextRowWithStone][j]</code> land on <code>result[i][j]</code> by setting <code>result[nextRowWithStone][j] = '.'</code> and <code>result[i][j] = '#'</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Po6ADV3z/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n^2)\)</span></p>
<p>We need to access each cell to compute the transpose of the grid. This requires <span class="math inline">\(O(m \times n)\)</span> time since there are <span class="math inline">\(m\)</span> rows and <span class="math inline">\(n\)</span> columns in the grid.</p>
<p>After transposing, we reverse each of the <span class="math inline">\(n\)</span> rows. Reversing a row involves swapping elements from the start and end until we reach the middle, which takes <span class="math inline">\(O(m)\)</span> time per row. Since there are <span class="math inline">\(n\)</span> rows, the total time for this operation is: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The gravity effect is implemented using an outer loop that iterates through the <span class="math inline">\(m\)</span> columns. For each column, two inner nested loops iterate through the rows:</p>
<ul>
<li>The first inner loop checks each row from the bottom to the top, running up to <span class="math inline">\(O(n)\)</span> times.</li>
<li>The second inner loop checks the rows above the current empty cell to find a stone, which in the worst case can also iterate up to <span class="math inline">\(O(n)\)</span> times.</li>
</ul>
<p>Therefore, for each column, the worst-case scenario for the gravity application results in <span class="math inline">\(O(n) \times O(n) = O(n^2)\)</span></p>
<p>Consequently, for all <span class="math inline">\(m\)</span> columns, the total time complexity for applying gravity is <span class="math inline">\(O(m \times n^2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Since we avoid modifying the input, we create a second grid, <code>result</code>, of size <span class="math inline">\(n \times m\)</span>. Note that if we were allowed to alter the input directly, we could reduce the space complexity to <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-row-by-row-optimized">Approach 2: Row By Row (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When optimizing our solution, it's important to consider the lower bound of the algorithm's complexity. In this case, we need to somehow fill an <span class="math inline">\(n \times m\)</span> grid, with a minimum required time of <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>This prompts us to investigate whether we can reduce the time complexity of our previous approach to this lower bound. It turns out that we can achieve this because the third inner loop, which currently increases the time complexity to <span class="math inline">\(O(m \times n^2)\)</span>, is actually redundant.</p>
<p>Specifically, instead of checking each empty cell to see if a stone can land on it, we can maintain a pointer to the lowest empty cell in the current column that has no obstacles above it. When we encounter a stone, we allow it to fall to the cell indicated by this pointer and then update the pointer to the row directly above where the stone landed. If we encounter an obstacle, we reset the pointer to the row directly above the obstacle.</p>
<p>We will use the <a href="#1-rotate-the-grid">same algorithm</a> from our initial approach to simulate the rotation of the grid, before applying the gravity effect as described above.</p>
<p>!?!../Documents/1861/1861_approach2_fix.json:960,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>.</li>
<li>Set <code>result</code> to be the transpose of the input grid:
<ul>
<li>Iterate over the rows with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>Iterate over the columns with <code>j</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Set <code>result[j][i] = box[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Reverse the order of elements in each row of the transpose grid.</li>
<li>Iterate over the columns of the rotated grid with <code>j</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each column <code>j</code>:
<ul>
<li>Initialize a variable <code>lowestRowWithEmptyCell</code> to <code>n-1</code></li>
<li>Iterate over all of its elements in reversed order with <code>i</code> from <code>n-1</code> to <code>0</code>. On each iteration:
<ul>
<li>If <code>result[i][j]</code> contains a stone, let it fall to the lowest empty cell:
<ul>
<li>Set <code>result[lowestRowWithEmptyCell][j] = '#'</code>.</li>
<li>Set <code>result[i][j] = '.'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
<li>if <code>result[i][j]</code> contains an obstacle, set <code>lowestRowWithEmptyCell = i-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/S8dHpXwx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Similar to the first approach, the rotation operation takes <span class="math inline">\(O(m \times n)\)</span> time. The gravity effect is now implemented using two nested loops instead of three. The outer loop iterates over the <span class="math inline">\(m\)</span> columns, and for each column, the inner loop processes all <span class="math inline">\(n\)</span> elements. As a result, the total time complexity of the algorithm remains <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Once again, we avoid modifying the input directly by creating a second grid, <code>result</code>, of size <span class="math inline">\(n \times m\)</span>. However, if we were allowed to modify the input in place, the space complexity could be reduced to <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-combine-rotation-and-gravity-operations">Approach 3: Combine rotation and gravity operations</h3>
<h4 id="intuition-2">Intuition</h4>
<p>As mentioned earlier, the time complexity of <span class="math inline">\(O(m \times n)\)</span> achieved with the second approach represents a lower bound for this particular problem. This means we cannot further optimize our algorithm in terms of complexity. However, in this approach, we aim to streamline our code by combining the operations of rotation and the effects of gravity. This will allow us to generate the result in a single pass instead of three, potentially reducing the runtime of our program.</p>
<p>First, let's derive the formula to find the position of the cell originally located at <span class="math inline">\((i, j)\)</span> in the rotated grid. Following the strategy outlined for the transpose grid, we will first map the position <span class="math inline">\((i, j)\)</span> to <span class="math inline">\((j, i)\)</span>. Then, we will reverse each row, meaning that the first element becomes the last, the second element becomes the second-to-last, and so on. Specifically, the element at index <span class="math inline">\(i\)</span> will move to the position <span class="math inline">\(m-i-1\)</span>. Combining these two conversions, we get that the cell originally located at <span class="math inline">\((i, j)\)</span> will end up in the position <span class="math inline">\((j, m-i-1)\)</span>.</p>
<p>Now, we are ready to execute the same algorithm as before. This time, we will read the type of each cell from the original grid, <code>box</code>, and place the results into the <code>result</code> grid using the positions determined by the formula outlined above.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>, and initialize all of its elements to be empty cells (<code>'.'</code>).</li>
<li>Iterate over the rows of the original grid, <code>box</code>, with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each row <code>i</code>, initialize a variable <code>lowestRowWithEmptyCell</code> to <code>n-1</code>.</li>
<li>Iterate over all of its elements in reversed order with <code>j</code> from <code>n-1</code> to <code>0</code>. On each iteration:
<ul>
<li>If <code>box[i][j]</code> contains a stone, let it fall to the lowest empty cell:
<ul>
<li>Set <code>result[lowestRowWithEmptyCell][m-i-1] = '#'</code>.</li>
<li>(Optionally) Set <code>result[j][m-i-1] = '.'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
<li>If <code>box[i][j]</code> contains an obstacle:
<ul>
<li>Set <code>result[j][m-i-1] = '*'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/WNSuvFk7/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The rotation of the grid and the gravity effect are implemented using two nested loops. The outer loop iterates over the <span class="math inline">\(m\)</span> rows of the original grid, and for each row, the inner loop processes all <span class="math inline">\(n\)</span> elements. Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Similar to the other two approaches, we prefer not to modify the input, by creating a new <span class="math inline">\(n \times m\)</span> grid.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-279">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/rotten-oranges2536/1" target="_blank" rel="noopener noreferrer">Rotten Oranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">queue</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix <strong>mat[][]</strong> of dimension <strong>n * m</strong> where each cell in the matrix can have values <strong>0, 1 or 2</strong> which has the following meaning:</span><br /><span style="font-size: 18px;"><strong>0 </strong>: Empty cell </span><br /><span style="font-size: 18px;"><strong>1</strong> : Cell have fresh oranges </span><br /><span style="font-size: 18px;"><strong>2</strong> : Cell have rotten oranges </span></p>
<p><span style="font-size: 18px;">We have to determine what is the earliest time after which all the oranges are rotten. A rotten orange at index (i, j) can rot other fresh orange at indexes (i-1, j), (i+1, j), (i, j-1), (i, j+1) (<strong>up</strong>, <strong>down</strong>, <strong>left</strong> and <strong>right</strong>) in a unit time. </span></p>
<p><strong><span style="font-size: 18px;">Note</span></strong><span style="font-size: 18px;"><strong>:</strong> Your task is to return the minimum time to rot all the fresh oranges. If not possible returns</span><strong><span style="font-size: 18px;"> -1.</span></strong></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[0, 1, 2], [0, 1, 2], [2, 1, 1]]
<strong>Output: </strong>1
<strong>Explanation: </strong>Oranges at positions (0,2), (1,2), (2,0) will rot oranges at (0,1), (1,1), (2,2) and (2,1) in unit time.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[2, 2, 0, 1]]
<strong>Output: </strong>-1
<strong>Explanation: </strong>Oranges at (0,0) and (0,1) can't rot orange at (0,3).</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[2, 2, 2], [0, 2, 0]]
<strong>Output: </strong>0
<strong>Explanation: </strong></span><span style="font-size: 18px;">There is no fresh orange. </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 500<br /></span><span style="font-size: 18px;">1 &le; mat[0].size() &le; 500<br /></span><span style="font-size: 18px;">mat[i][j] = {0, 1, 2}&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-280">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotting-oranges/description" target="_blank" rel="noopener noreferrer">Rotting Oranges</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>

<ul>
	<li><code>0</code> representing an empty cell,</li>
	<li><code>1</code> representing a fresh orange, or</li>
	<li><code>2</code> representing a rotten orange.</li>
</ul>

<p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>

<p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" style="width: 650px; height: 137px;" />
<pre>
<strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-281">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-sum-in-a-matrix/1" target="_blank" rel="noopener noreferrer">Row Sum in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2-D integer matrix <strong>mat[][]</strong> of size <strong>n</strong>*<strong>m</strong>. Return a list of integers where <strong>list[i]&nbsp;</strong>represents the sum of elements of the&nbsp;<strong>i<sup>th</sup>&nbsp;</strong>row of the matrix.</span></p>
<p><strong><span style="font-size: 14pt;">Note: </span></strong><span style="font-size: 14pt;">The sum of any row will remain within the range of an integer</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br /></span><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">[6, 15, 24]<br /><strong>Explanation: </strong>Row 1 -&gt; 1+2+3=6, Row 2 -&gt; 4+5+6=15, Row 3 -&gt; 7+8+9=24 </span></pre>
<pre><strong><span style="font-size: 14pt;">Input: </span></strong><span style="font-size: 14pt;">mat = [[1, 2], [10, 2], [3, 3]]<br /></span><strong><span style="font-size: 14pt;">Output: </span></strong><span style="font-size: 14pt;">[3, 12, 6]<br /><strong>Explanation: </strong>Row 1 -&gt; 1+2=3, Row 2 -&gt; 10+2=12, Row 3 -&gt; 3+3=6 </span></pre>
<p><strong><span style="font-size: 14pt;">Constraints:<br /></span></strong><span style="font-size: 14pt;">1 &nbsp;&lt;= &nbsp;n, m &nbsp;&lt;= &nbsp;1000</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-282">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-with-max-1s0023/1" target="_blank" rel="noopener noreferrer">Row with max 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a 2D binary array <code><strong>arr[][]</strong></code> consisting of only <code>1</code>s and <code>0</code>s. Each row of the array is sorted in non-decreasing order. Your task is to find and return the index of the first row that contains the maximum number of <code>1</code>s. If no such row exists, return <code>-1</code>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong></span></p>
<ul>
<li><span style="font-size: 14pt;">The array follows 0-based indexing.</span></li>
<li><span style="font-size: 14pt;">The number of rows and columns in the array are denoted by <code>n</code> and <code>m</code> respectively.</span></li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[][] = [[0,1,1,1], [0,0,1,1], [1,1,1,1], [0,0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Row 2 contains the most number of <code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s (4 </span><code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s). Hence, the output is </span><code>2</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[][] = [[0,0], [1,1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Row 1 contains the most number of <code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s (2 </span><code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s). Hence, the output is </span><code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[][] = [[0,0], [0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No row contains any <code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s, so the output is </span><code>-1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size(), arr[i].size()&nbsp;&le; 10<sup>3<br /></sup>0 &le; arr[i][j] &le; 1&nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-283">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-with-max-1s--162208/1" target="_blank" rel="noopener noreferrer">Row with Max 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two-pointer-algorithm</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D&nbsp;</span><span style="font-size: 18px;">binary matrix</span><strong style="font-size: 18px;">&nbsp;mat[][] </strong><span style="font-size: 18px;"><span style="font-size: 18px;">of size n x m,&nbsp;where each row contains only 0s and 1s, and each row is sorted in </span><strong style="font-size: 18px;">non-decreasing</strong><span style="font-size: 18px;"> order (all the 0s come before any 1s).</span><br /><span style="font-size: 18px;">Find the <strong>index </strong>of the <strong>row </strong>that contains the highest number of <strong>1s</strong>.</span></span></p>
<p><strong style="font-size: 18px;">Note:&nbsp;</strong><span style="font-size: 18px;">If multiple rows have the same maximum count of 1s, return the row with the smallest index.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[0, 0, 1, 1],<br />                [0, 1, 1, 1],<br />                [0, 0, 0, 1]]
<strong>Output: </strong>1
<strong>Explanation: </strong>Row at index 1 has three 1s, which is the highest among all rows.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[1, 1, 1],<br />                [0, 1, 1],<br />                [1, 1, 1]]
<strong>Output: </strong>0
<strong>Explanation: </strong>The first row (index 0) and the last row (index 2) both contain three 1s, which is the maximum among all rows. Since we return the smallest index in case of a tie, the answer is 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 1000<br /></span><span style="font-size: 18px;">0 &le; mat[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-284">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/row-with-maximum-ones/description" target="_blank" rel="noopener noreferrer">Row With Maximum Ones</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>m x n</code> binary matrix <code>mat</code>, find the <strong>0-indexed</strong> position of the row that contains the <strong>maximum</strong> count of <strong>ones,</strong> and the number of ones in that row.</p>

<p>In case there are multiple rows that have the maximum count of ones, the row with the <strong>smallest row number</strong> should be selected.</p>

<p>Return<em> an array containing the index of the row, and the number of ones in it.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,1],[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> Both rows have the same number of 1&#39;s. So we return the index of the smaller row, 0, and the maximum count of ones (1<code>)</code>. So, the answer is [0,1]. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,0,0],[0,1,1]]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The row indexed 1 has the maximum count of ones <code>(2)</code>. So we return its index, <code>1</code>, and the count. So, the answer is [1,2].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> mat = [[0,0],[1,1],[0,0]]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code>&nbsp;</li>
	<li><code>n == mat[i].length</code>&nbsp;</li>
	<li><code>1 &lt;= m, n &lt;= 100</code>&nbsp;</li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-285">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-with-minimum-number-of-1s5430/1" target="_blank" rel="noopener noreferrer">Row with Minimum 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D <strong>binary matrix</strong>(1-based indexed)<strong> mat</strong>&nbsp;of dimensions <strong>nxm </strong>, determine the <strong>row</strong> that contains the <strong>minimum number </strong>of<strong> 1's</strong>.<br /><strong>Note: </strong>The matrix contains only <strong>1's</strong> and <strong>0's</strong>. Also, if two or more rows contain the <strong>minimum number</strong> of <strong>1's</strong>, the answer is the <strong>lowest</strong> of those<strong> indices</strong>.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat = [[1, 1, 1, 1], [1, 1, 0, 0], [0, 0, 1, 1], [1, 1, 1, 1]]
<strong>Output: </strong>2
<strong>Explanation: </strong>Rows 2 and 3 contain the minimum number of 1's (2 each). Since, row 2 is less than row 3. Thus, the answer is 2.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
<strong>Output: </strong>1
<strong>Explanation: </strong>All the rows contain the same number of 1's (0 each). Among them, index 1 is the smallest, so the answer is 1.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n,m &lt;= 1000</span></p>
<p><span style="font-size: 18px;">0 &lt;= mat[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-286">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/save-the-nation3110/1" target="_blank" rel="noopener noreferrer">Save The Nation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">An Encryption algorithm works in the following way<br />
<strong>Message:</strong> eNEMYwILLaTTACK<br />
<strong>Enrypted Form:</strong> eYLA NwaC EITK MLT<br />
<br />
The way to do it is that the number of rows and the number of columns in the figure (formed from the alphabets of the Message) lie between <strong>floor</strong> (sqrt(len(message))) and <strong>ceil </strong>(sqrt(len(message))). It also states that the number of rows is less than or equal to the number of columns, and that the area of rectangle thus formed is minimum. Based on the this criteria, we have to choose a set of values for rows and columns.<br />
<br />
For the string<strong> haveaniceday,</strong>&nbsp;we have floor(sqrt(len(message))) = 3 and ceil(sqrt(len(message))) = 4.<br />
<br />
3 * 3 = 9 &lt; len(message) = 15<br />
3 * 4 = 12 = len(message)<br />
4 * 3 = 12 = len(message)<br />
4 * 4 = 16 &gt; len(message)<br />
<br />
Out of the 4 possible squares, we can see that, rows = 3 and columns = 4 is the best fit.<br />
On building the figure, we get<br />
<br />
have<br />
anic<br />
eday<br />
<br />
So, the Encrypted form is &quot;hae and via ecy&quot;.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>S = </strong>&quot;</span><span style="font-size:18px">eNEMYwILLaTTACK&quot;</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">eYLA NwaC EITK MLT</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The encrypted form of the given String
is printed.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong></span>
<span style="font-size:18px"><strong>S = </strong>&quot;</span><span style="font-size:18px">SavetheMines&quot;</span>
<span style="font-size:18px"><strong>Output:</strong></span>
<span style="font-size:18px">Sti ahn vee eMs</span>
<span style="font-size:18px"><strong>Explanation:</strong></span>
<span style="font-size:18px">The encrypted form of the given String
is printed.</span></pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>encryptString()</strong> which takes an String S as input and returns the encrypted form as a String.</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(|S|)<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong></span><br />
<span style="font-size:18px">1 &lt;= |S| &lt;= 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-287">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/score-after-flipping-matrix/description" target="_blank" rel="noopener noreferrer">Score After Flipping Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A <strong>move</strong> consists of choosing any row or column and toggling each value in that row or column (i.e., changing all <code>0</code>&#39;s to <code>1</code>&#39;s, and all <code>1</code>&#39;s to <code>0</code>&#39;s).</p>

<p>Every row of the matrix is interpreted as a binary number, and the <strong>score</strong> of the matrix is the sum of these numbers.</p>

<p>Return <em>the highest possible <strong>score</strong> after making any number of <strong>moves</strong> (including zero moves)</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg" style="width: 500px; height: 299px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]
<strong>Output:</strong> 39
<strong>Explanation:</strong> 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a matrix containing only <code>0</code>'s and <code>1</code>'s, and we have the ability to flip the values of any row or column of the matrix. Our goal is to find the maximum sum (<code>score</code>) that can be obtained by summing the integer values created by each row of the matrix.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Flipping a row or a column consists of changing all the <code>1</code>'s to <code>0</code>'s and vice versa.</li>
<li>The value of each row of the matrix is the integer value of the row when interpreted as a binary number.</li>
<li>We can flip a row or column any number of times (possibly 0).</li>
</ol>
<hr />
<h3 id="approach-1-greedy-way-modifying-input">Approach 1: Greedy Way (Modifying Input)</h3>
<h4 id="intuition">Intuition</h4>
<p>Since our goal is to maximize the sum of the matrix's rows, our initial focus should be on maximizing the integer value of each row.</p>
<p>In a binary number, the bits in higher-order positions carry more weight in determining the decimal value than those in lower-order positions. Therefore, a single <code>1</code> in the leftmost position always contributes more to the decimal value than any combination of <code>1</code>'s in less significant positions. This concept is illustrated in the diagram below.</p>
<p><img src="../Figures/861/binary_decimal.png" alt="Binary to Decimal" /></p>
<p>Since higher-order bits contribute more significantly to the value, our initial strategy will focus on maximizing them. Ideally, we want all bits in the first column of the matrix (first digit) to be <code>1</code>. This can be achieved using the row modification operation. If the first value of a row is <code>0</code>, we traverse the row and toggle each element. This effectively ensures the first digit is <code>1</code>, increasing the overall integer value of the row.</p>
<p>Now that we have optimized each row, let's shift our focus to optimizing the columns. The contribution of a column to the score of the matrix depends solely on the number of <code>1</code>'s in the column. So, it would be ideal for us to maximize the number of <code>1</code>'s in each column. To do so, we can use the column modification operation. We flip a column if it has more <code>0</code>'s than <code>1</code>'s, effectively interchanging the number of <code>0</code>'s and <code>1</code>'s in the column.</p>
<p>The entire process is illustrated in the slideshow below.</p>
<p>!?!../Documents/861/flip_slideshow.json:782,582!?!</p>
<p>Finally, to calculate the score of the matrix, we need to accumulate the integer equivalent of each row. Since the integer value of a row is the sum of the decimal values of each bit, the total score can be obtained by summing the decimal equivalent of every element in the matrix. To determine the contribution of a bit, we left-shift it by its position within the row, representing its place value. This effectively assigns the correct weight (power of 2) to each bit.</p>
<p>For example, consider a row <code>[1, 1, 0, 0]</code>. The third <code>1</code> from the right needs to be left shifted by 2, which effectively multiples it with <span class="math inline">\(2^2\)</span> (its place value). The resultant value is the contribution of this <code>1</code> to the score of the matrix.</p>
<p>In summary, the maximal score for a matrix is obtained by following two key steps:</p>
<ol>
<li>Flip rows to ensure all elements in the first column of the matrix are <code>1</code>'s.</li>
<li>Flip a column if it contains more <code>0</code>'s than <code>1</code>'s.</li>
</ol>
<blockquote>
<p>Note: In binary numbers, each digit represents a power of <span class="math inline">\(2\)</span>, with the rightmost digit being <span class="math inline">\(2^0\)</span> (one's place), the next digit being <span class="math inline">\(2^1\)</span> (two's place), and so on. The decimal value of a bit in a binary number can be represented by left shifting the bit by its place value. For example, in the binary number <span class="math inline">\(100101\)</span>, the decimal contribution of the third bit from the left is <span class="math inline">\(1<<2\)</span>, which is equivalent to <span class="math inline">\(4\)</span>.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize variables:
<ul>
<li><code>m</code> and <code>n</code> as the number of rows and columns in <code>grid</code> respectively.</li>
<li><code>score</code> to store the maximum score of the matrix</li>
</ul>
</li>
<li>Iterate through the first column of the matrix.
<ul>
<li>If the element is <code>0</code>, flip the entire row.</li>
</ul>
</li>
<li>Iterate from the second column to the last column of the matrix. For each column:
<ul>
<li>Count the number of <code>0</code>'s and store it in <code>countZero</code>.</li>
<li>If number of <code>0</code>'s is greater, flip the entire column.</li>
</ul>
</li>
<li>Iterate over the modified matrix.
<ul>
<li>For each element, add it to <code>score</code> by left shifting it by the place value of the current column.</li>
</ul>
</li>
<li>Return <code>score</code>, which stores the highest possible score of the matrix.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6Ns9FkMb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the number of rows and columns of the matrix, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>In the worst case, we traverse the entire matrix twice. The total number of cells in the matrix is <span class="math inline">\(m \cdot n\)</span>. Thus, the time complexity is <span class="math inline">\(O(2 \cdot m \cdot n)\)</span>, which simplifies to <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not use any additional data structures in our implementation. Therefore, the space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-greedy-way-without-modifying-input">Approach 2: Greedy Way (Without Modifying Input)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>It is often not recommended to modify the input data in place. Therefore, let us try to solve the problem without modifying the matrix.</p>
<p>Let <code>m</code> and <code>n</code> be the number of rows and columns in the matrix, respectively. As we saw previously, to maximize the score, the first element of each row has to be <code>1</code>. Thus, we can add <span class="math inline">\(1<<(n-1)\)</span> to the result <code>m</code> times to account for the first element of each row. This adds the contribution of the first column to the result.</p>
<p>Now, we need to maximize the contribution of the remaining columns in the matrix. Similar to our previous approach, we need to count the total number of <code>0</code>'s and <code>1</code>'s in each column and flip the column if the number of <code>0</code>'s is greater. However, if the first element in a particular row is <code>0</code>, it means that the row has been flipped previously to make the first element <code>1</code>. Let us consider all possible scenarios in this regard:</p>
<table>
<thead>
<tr>
<th align="center">First Element</th>
<th align="center">Current Element</th>
<th align="center">Current Element (after potential flip)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>We can see that an element resolves to <code>1</code> only when it matches the first element in its row. Thus, to count the number of <code>1</code>'s in the column, we can simply count the instances where the first element is equal to the current element.</p>
<p>Once we have the total number of <code>1</code>'s in the column, we can decide whether it is profitable to flip the column or not. We will get the maximum contribution from the column if the number of <code>1</code>'s is greater than the number of <code>0</code>'s. Thus, the number of <code>1</code>'s contributing to the score from that particular column would be the higher value between the counts of <code>0</code>'s and <code>1</code>'s.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code>m</code> and <code>n</code> as the number of rows and columns in <code>grid</code> respectively.</li>
<li>Initialize <code>score</code> to <code>(1&lt;&lt;(n-1))*m</code> to account for the first column of <code>1</code>'s.</li>
<li>Iterate from the second column to the last column of the matrix. For each column:
<ul>
<li>Initialize <code>countSameBits</code> as <code>0</code>.</li>
<li>For each element, check if it matches with the first element of the row.
<ul>
<li>If it matches, increment <code>countSameBits</code>.</li>
</ul>
</li>
<li>Left shift <code>1</code> by the place value of the column and add it to the result <code>max(countSameBits, m-countSameBits)</code> times.</li>
</ul>
</li>
<li>Return <code>score</code>, which is our required result.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3BCUNdNL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> be the number of rows and columns of the matrix, respectively.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>We traverse the entire matrix only once. The total number of cells in the matrix is <span class="math inline">\(m \cdot n\)</span>, resulting in a time complexity of <span class="math inline">\(O(m \cdot n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We do not use any additional space in our implementation. Therefore, our space complexity remains <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-288">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-a-2d-matrix/description" target="_blank" rel="noopener noreferrer">Search a 2D Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>

<ul>
	<li>Each row is sorted in non-decreasing order.</li>
	<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>

<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-289">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/search-a-2d-matrix-ii/description" target="_blank" rel="noopener noreferrer">Search a 2D Matrix II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">divide-and-conquer</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>

<ul>
	<li>Integers in each row are sorted in ascending from left to right.</li>
	<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 300</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
	<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>
	<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>
	<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-290">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-a-matrix--021840/1" target="_blank" rel="noopener noreferrer">Search in a  Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2D integer array <strong>mat[][] </strong>and<strong>&nbsp;</strong>a number&nbsp;<strong>x</strong>, find whether element x is present in the matrix or not.<br /></span><br /><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[6, 23, 21],[4, 45, 32],[69, 11, 87]], x = 32
<strong>Output</strong>: true
<strong>Explanation</strong>: 32 is present in the matrix, so the output is 1.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[14, 34, 23, 95, 43, 28]], x = 55<br /><strong>Output</strong>: false
<strong>Explanation</strong>: 55 is not present in the matrix, so the output is 0.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[87, 9, 99],[101, 3, 111]], x = 101</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: true
<strong>Explanation</strong>: 101 is present in the matrix.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &lt;= mat.size(), mat[0].size() &lt;= 1000<br />1 &lt;= mat[][] &lt;= 10<sup>5</sup><br />1 &lt;= x &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-291">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-a-matrix17201720/1" target="_blank" rel="noopener noreferrer">Search in a Row-Column sorted matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a 2D integer matrix <strong>mat</strong>[][] of size <strong>n x m</strong>, where every row and column is sorted in increasing order and a number <strong>x</strong>,<strong> </strong>the task is to find whether element <strong>x</strong> is present in the matrix.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[3, 30, 38],[20, 52, 54],[35, 60, 69]], x = 62
<strong>Output</strong>: false
<strong>Explanation</strong>: 62 is not present in the matrix, so output is false.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[18, 21, 27],[38, 55, 67]], x = 55
<strong>Output</strong>: true
<strong>Explanation</strong>: 55 is present in the matrix.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 3],[4, 5, 6],[7, 8, 9]], x = 3
<strong>Output</strong>: true
<strong>Explanation</strong>: 3 is present in the matrix.<br /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints</strong>:<br />1 &lt;= n, m &lt;=1000<br />1 &lt;= mat[i][j] &lt;= 10<sup>9 <br /></sup>1&lt;= x &lt;= 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-292">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-a-row-wise-sorted-matrix/1" target="_blank" rel="noopener noreferrer">Search in a row-wise sorted matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a row-wise sorted 2D matrix <strong>mat</strong>[][] of size <strong>n x m&nbsp;</strong>and<strong>&nbsp;</strong>an integer <strong>x,</strong> find whether element <strong>x</strong> is present in the matrix.<br />Note: In a row-wise sorted matrix, each row is sorted in itself, i.e. for any i, j within bounds, mat[i][j] &lt;= mat[i][j+1].</span><br style="font-size: 18px;" /><br /><span style="font-size: 14pt;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[3, 4, 9],[2, 5, 6],[9, 25, 27]], x = 9
<strong>Output</strong>: true
<strong>Explanation</strong>: 9 is present in the matrix, so the output is true.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[19, 22, 27, 38, 55, 67]], x = 56<br /><strong>Output</strong>: false
<strong>Explanation</strong>: 56 is not present in the matrix, so the output is false.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 9],[65, 69, 75]], x = 91</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: false
<strong>Explanation</strong>: 91 is not present in the matrix.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &lt;= n, m &lt;= 1000<br />1 &lt;= mat[i][j] &lt;= 10<sup>5</sup><br />1 &lt;= x &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-293">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-a-matrix-1587115621/1" target="_blank" rel="noopener noreferrer">Search in a sorted Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">searching</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a strictly sorted 2D matrix<strong> mat</strong>[][] of size <strong>n x m&nbsp;</strong>and<strong>&nbsp;</strong>a number&nbsp;<strong>x.</strong> Find whether the number <strong>x</strong> is present in the matrix or not.<br /><strong>Note:</strong> In a strictly sorted matrix, each row is sorted in strictly increasing order, and&nbsp;the first element of the <strong>i</strong><sup>th</sup>&nbsp;row (<strong>i</strong>!=0) is greater than the last element of the (<strong>i-1</strong>)<sup>th&nbsp;</sup>row.</span><br style="font-size: 18px;" /><br /><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 5, 9], [14, 20, 21], [30, 34, 43]], x = 14
<strong>Output</strong>: true
<strong>Explanation</strong>: 14 is present in the matrix, so output is true.
</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 5, 9, 11], [14, 20, 21, 26], [30, 34, 43, 50]], x = 42<br /><strong>Output</strong>: false
<strong>Explanation</strong>: 42 is not present in the matrix.<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[87, 96, 99], [101, 103, 111]], x = 101</span><br /><span style="font-size: 14pt;"><strong>Output</strong>: true
<strong>Explanation</strong>: 101 is present in the matrix.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; n, m &le; 1000<br />1 &le; mat[i][j] &le; 10<sup>9</sup><br />1 &le; x &le; 10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-294">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/search-in-fully-rotated-sorted-2d-matrix/1" target="_blank" rel="noopener noreferrer">Search in fully rotated sorted 2D matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binarysearch</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p class="MsoNormal"><span style="font-size: 14pt;">You are given a 2D matrix <strong>mat[][] </strong>of size n x m that was initially filled in the following manner:</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<ul style="margin-top: 0cm;" type="disc">
<li class="MsoNormal" style="mso-list: l0 level1 lfo1; tab-stops: list 36.0pt;"><span style="font-size: 14pt;">Each row is sorted in increasing order from left to right.</span></li>
<li class="MsoNormal" style="mso-list: l0 level1 lfo1; tab-stops: list 36.0pt;"><span style="font-size: 14pt;">The first element of every row is greater than the last element of the previous row.</span></li>
</ul>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;">This implies that if the matrix is flattened row-wise, it forms a strictly sorted 1D array.<br />Later, this sorted 1D array was rotated at some unknown pivot. The rotated array was then written back into the matrix row-wise to form the current matrix.</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;">Given such a matrix <strong>mat[][]</strong> and an integer <strong>x</strong>, determine whether x exists in the matrix.</span></p>
<p><span style="font-size: 14pt;"> </span></p>
<p class="MsoNormal"><span style="font-size: 14pt;"><strong><span style="mso-ansi-language: EN-IN;">Examples:<br /></span></strong></span></p>
<pre class="MsoNormal"><span style="font-size: 14pt;"><span style="mso-ansi-language: EN-IN;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">x = 3,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 14pt;">mat[][] = </span><span style="font-size: 18.6667px;">[[7, 8, 9, 10],           
          [11, 12, 13, 1],
          [2, 3, 4, 5]] </span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">true</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span></span><span style="font-size: 18.6667px;">3 is located at the 3rd row and 2nd column.</span></pre>
<pre><span style="font-size: 14pt;"><span style="mso-ansi-language: EN-IN;"><strong style="font-size: 14pt;">Input:</strong><span style="font-size: 14pt;"> x = 10,</span><strong style="font-size: 14pt;"><br /></strong><span style="font-size: 18.6667px;">mat[][] <strong>= </strong>[[6, 7, 8],                         
          [9, 1, 2],
          [3, 4, 5]]</span><strong style="font-size: 14pt;"><br />Output: </strong><span style="font-size: 14pt;">false</span><strong style="font-size: 14pt;"><br />Explanation: </strong></span></span><span style="font-size: 18.6667px;">The value 10 does not exist in the matrix.</span></pre>
<p><strong><span style="font-size: 18.6667px;">Constraint:<br /></span></strong><span style="font-size: 18.6667px;">1 &le; n &times; m &le; 10<sup>5</sup><br /></span><span style="font-size: 18.6667px;">1 &le; mat[i][j], x &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-295">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/select-cells-in-grid-with-maximum-score/description" target="_blank" rel="noopener noreferrer">Select Cells in Grid With Maximum Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D matrix <code>grid</code> consisting of positive integers.</p>

<p>You have to select <em>one or more</em> cells from the matrix such that the following conditions are satisfied:</p>

<ul>
	<li>No two selected cells are in the <strong>same</strong> row of the matrix.</li>
	<li>The values in the set of selected cells are <strong>unique</strong>.</li>
</ul>

<p>Your score will be the <strong>sum</strong> of the values of the selected cells.</p>

<p>Return the <strong>maximum</strong> score you can achieve.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,3],[4,3,2],[1,1,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/29/grid1drawio.png" /></p>

<p>We can select the cells with values 1, 3, and 4 that are colored above.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[8,7,6],[8,3,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">15</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/29/grid8_8drawio.png" style="width: 170px; height: 114px;" /></p>

<p>We can select the cells with values 7 and 8 that are colored above.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= grid.length, grid[i].length &lt;= 10</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-296">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/set-matrix-zeroes/description" target="_blank" rel="noopener noreferrer">Set Matrix Zeroes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>&#39;s.</p>

<p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in place</a>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" style="width: 450px; height: 169px;" />
<pre>
<strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" style="width: 450px; height: 137px;" />
<pre>
<strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
<strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[0].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li>
	<li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li>
	<li>Could you devise a constant space solution?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-297">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/set-matrix-zeroes/1" target="_blank" rel="noopener noreferrer">Set Matrix Zeros</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">You are given a 2D matrix <strong>mat</strong>[][] of size </span><span style="font-size: 18px;"><strong>n x m</strong>.&nbsp;</span><span style="font-size: 18px;">The task is to modify the matrix such that if <strong>mat[i][j]</strong> is 0, all the elements in the&nbsp;</span><span style="font-size: 18px;"><strong>i</strong>-th row and </span><span style="font-size: 18px;"><strong>j</strong>-th column are set to 0.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;"><br /><strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">&nbsp; &nbsp; <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/898467/Web/Other/blobid1_1751352682.jpg" width="246" height="197" /></strong>
</span><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;"> <br />    <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/898467/Web/Other/blobid3_1751352733.jpg" width="234" height="187" />
</span><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> </span></span><span style="font-size: 18px;">mat[1][1] = 0, so all elements in row 1 and column 1 are updated to zeroes.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: <br /></strong></span><span style="font-size: 18px;"><span style="font-size: 18px;"> &nbsp; &nbsp;<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/874880/Web/Other/blobid0_1753182969.jpg" width="254" height="166" /><br /></span><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;"> <br /> &nbsp; &nbsp;<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/874880/Web/Other/blobid1_1753183001.jpg" width="254" height="166" /><br /></span></span><span style="font-size: 18px;"><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> </span></span><span style="font-size: 18px;">mat[0][0] and mat[0][3] are 0s, so all elements in row 0, column 0 and column 3 are updated to zeroes.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, </span><span style="font-size: 18px;">m</span><span style="font-size: 18px;"> &le; 500</span><sup><br /></sup><span style="font-size: 18px;">- 2<sup>31</sup> &le; mat[i][j] &le; 2<sup>31</sup> - 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-298">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shift-2d-grid/description" target="_blank" rel="noopener noreferrer">Shift 2D Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D <code>grid</code> of size <code>m x n</code>&nbsp;and an integer <code>k</code>. You need to shift the <code>grid</code>&nbsp;<code>k</code> times.</p>

<p>In one shift operation:</p>

<ul>
	<li>Element at <code>grid[i][j]</code> moves to <code>grid[i][j + 1]</code>.</li>
	<li>Element at <code>grid[i][n - 1]</code> moves to <code>grid[i + 1][0]</code>.</li>
	<li>Element at <code>grid[m&nbsp;- 1][n - 1]</code> moves to <code>grid[0][0]</code>.</li>
</ul>

<p>Return the <em>2D grid</em> after applying shift operation <code>k</code> times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/05/e1.png" style="width: 400px; height: 178px;" />
<pre>
<strong>Input:</strong> <code>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 1
<strong>Output:</strong> [[9,1,2],[3,4,5],[6,7,8]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/11/05/e2.png" style="width: 400px; height: 166px;" />
<pre>
<strong>Input:</strong> <code>grid</code> = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
<strong>Output:</strong> [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> <code>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 9
<strong>Output:</strong> [[1,2,3],[4,5,6],[7,8,9]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m ==&nbsp;grid.length</code></li>
	<li><code>n ==&nbsp;grid[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 50</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li>
	<li><code>0 &lt;= k &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-299">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-bridge/description" target="_blank" rel="noopener noreferrer">Shortest Bridge</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary matrix <code>grid</code> where <code>1</code> represents land and <code>0</code> represents water.</p>

<p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>&#39;s not connected to any other <code>1</code>&#39;s. There are <strong>exactly two islands</strong> in <code>grid</code>.</p>

<p>You may change <code>0</code>&#39;s to <code>1</code>&#39;s to connect the two islands to form <strong>one island</strong>.</p>

<p>Return <em>the smallest number of </em><code>0</code><em>&#39;s you must flip to connect the two islands</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1],[1,0]]
<strong>Output:</strong> 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[0,1,0],[0,0,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
	<li>There are exactly two islands in <code>grid</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>As shown in the examples below, we need to flip at least <strong>3</strong> cells to connect island <code>A</code> and island <code>B</code> in the left case, and flip at least <strong>5</strong> cells in the right case.</p>
<p><img src="../Figures/934/intro.png" alt="img" /></p>
<hr />
<h3 id="approach-1-depth-first-search--breadth-first-search">Approach 1: Depth-First-Search + Breadth-First-Search</h3>
<h4 id="intuition">Intuition</h4>
<p>If you are not familiar with the Depth-First-Search (DFS) or the Breadth-First-Search (BFS) algorithms, please refer to our explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth-First-Search Explore Card</a></li>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First-Search Explore Card</a></li>
</ul>
<p>In order to find the minimum number of flips required to reach the destination island, or in other words, the minimum distance between the two islands, we can use a combination of DFS and BFS algorithms. Start by finding all the land cells on the first island (let's call it island <code>A</code>) using the DFS method.</p>
<p>Here's how: we start with one cell of island <code>A</code> and try to move to its four neighboring cells. If there is an unvisited neighboring land cell, we move to that cell and change its value to a number like <code>2</code> to avoid revisiting it again in the future and distinguish it from the land cells of the other island. We then repeat the same strategy from the new cell. If we find that the current cell has no unvisited neighbors, we will backtrack to the previous cell and try the next neighboring cell from there. The numbers on the cells in the following figure represent the order of our visits.</p>
<p><img src="../Figures/934/2.png" alt="img" /></p>
<p>Now that we have found all the cells in island <code>A</code> and set them to <code>2</code>, in <code>grid</code> we have:</p>
<ul>
<li><code>0</code> for the water cells.</li>
<li><code>2</code> for the land cells of the first island (island <code>A</code>)</li>
<li><code>1</code> for the land cells of the second island (island <code>B</code>)</li>
</ul>
<p>Then, we can use BFS to find the shortest distance from island <code>A</code> to island <code>B</code>. Here is the step-by-step process for the BFS algorithm:</p>
<ol>
<li>We start with all the cells in island <code>A</code> as the source, and set <code>distance</code> to <code>0</code>.</li>
<li>Add all the cells of island <code>A</code> to a list <code>bfs_queue</code>.</li>
<li>While <code>bfs_queue</code> is not empty, we build an empty list <code>new_bfs</code> as the candidate cells for the next BFS round, then we iterate over every cell <code>(x, y)</code> in <code>bfs_queue</code>.</li>
<li>Check the four neighbors of <code>(x, y)</code> (up, down, left, and right). If a valid neighbor has value of <code>0</code>, we can mark it as visited by setting the value as <code>-1</code>, then we can add this cell to the list <code>new_bfs</code>. If a neighbor cell has a value of <code>1</code>, it means that we have found a land cell of the second island (island <code>B</code>). Since we are traversing water cells in BFS approach, it means that the first cell of island <code>B</code> we found has the shortest distance from island <code>A</code> among all cells on island <code>B</code>.</li>
<li>Once the iteration (current round) ends, if we still haven't reached island <code>B</code>, it means that we should look for cells that have a longer distance from island <code>A</code>. Therefore, we increment <code>distance</code> by 1, set <code>bfs_queue = new_bfs</code>, and repeat step 3.</li>
</ol>
<p>This approach is shown in the picture below. The distance of each cell from island <code>A</code> is also shown.</p>
<ul>
<li>We start with all cells in island <code>A</code> that have a distance of 0.</li>
<li>In the first round, we visit all water cells that have a distance of 1 from island <code>A</code>.</li>
<li>In the second round, we visit all water cells that have a distance of 2 from island <code>A</code>.</li>
<li>In the third round, we visit all water cells that have a distance of 3 from island <code>A</code>.</li>
</ul>
<p>After 3 rounds of BFS search, we find some land cells of island <code>B</code> being the neighbors of water cells that have a distance of <code>3</code> from island <code>A</code>, we can stop the BFS search.</p>
<p><img src="../Figures/934/4.png" alt="img" /></p>
<p>The shortest distance between the two islands is 3, so we need at least 3 flips (highlighted in yellow) to connect them.</p>
<blockquote>
<p>Note that in this approach we are directly modifying the input to help us distinguish cells. It is generally not good practice to modify the input, and if the interviewer is against it, you can accomplish the same functionality by using a set to store cells that have already been visited instead.</p>
</blockquote>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Iterate over the grid <code>grid</code> until we find a land cell, suppose it is <code>grid[first_x][first_y]</code>.</p>
</li>
<li>
<p>Start from <code>grid[first_x][first_y]</code> and use depth-first search to find and set the values of all cells of the same island (island <code>A</code>) to <code>2</code>.</p>
</li>
<li>
<p>Create a list <code>bfs_queue</code> and add all cells on island <code>A</code> to it, starting with <code>distance = 0</code>.</p>
</li>
<li>
<p>While <code>bfs_queue</code> is not empty, we create another list <code>new_bfs</code> to collect the water cells we need to visit in the next round. Iterate over cells in <code>bfs_queue</code>, for each cell <code>(x, y)</code>:</p>
<ul>
<li>if <code>grid[x][y] = 1</code>, it means we have reached the second island, return <code>distance</code>.</li>
<li>Otherwise, we look for its unvisited water neighbors (cells with value <code>0</code>), mark them as <code>-1</code>, and add them to <code>new_bfs</code>.</li>
</ul>
</li>
<li>
<p>Once the iteration ends, set <code>bfs_queue = new_bfs</code>, increment <code>distance</code> by 1, and start the next round by repeating step 4.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/XZAZVSEy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \times n\)</span> be the size of the input matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>
<p>The general time complexity of Depth-First-Search is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of cells in the first island is <span class="math inline">\(n^2\)</span>, so iterating over its cells will take <span class="math inline">\(O(n^2)\)</span> time. <span class="math inline">\(E\)</span> is a constant here since we are only allowed to traverse in up to 4 directions.</p>
</li>
<li>
<p>The general time complexity of Breadth-First-Search is <span class="math inline">\(O(V + E)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of water cells we need to check before reaching the second island is <span class="math inline">\(n^2\)</span>, which will take <span class="math inline">\(O(n^2)\)</span> time.</p>
</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>
<p>The general space complexity of Depth-First-Search is <span class="math inline">\(O(V)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of cells in the first island is <span class="math inline">\(n^2\)</span>, thus the space used by the recursive stack during DFS is <span class="math inline">\(O(n^2)\)</span></p>
</li>
<li>
<p>The general space complexity of Breadth-First-Search is <span class="math inline">\(O(V)\)</span>, where <span class="math inline">\(V\)</span> stands for the number of vertices. The maximum number of water cells we need to check using BFS before reaching the second island is <span class="math inline">\(n^2\)</span>, thus the space used by the queue is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>To sum up, the overall space complexity is <span class="math inline">\(O(n^2)\)</span></p>
</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth-First-Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In this approach, we will use the same strategy as in the previous approach, but we will use BFS instead of DFS to search for all cells of island <code>A</code>. Again, we will first traverse <code>grid</code>, take the first land found (assume it is <code>grid[first_x][first_y]</code>) and treat it as a land cell of Island <code>A</code>. Then, we BFS over all cells of island <code>A</code> and set their values to <code>2</code> to distinguish them from the other island.</p>
<p><img src="../Figures/934/3.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Iterate over the <code>grid</code> until we find the first land cell, suppose it is <code>grid[first_x][first_y]</code>.</p>
</li>
<li>
<p>Create:</p>
<ul>
<li>a list <code>bfs_queue</code> and add <code>grid[first_x][first_y]</code> on island <code>A</code> to it.</li>
<li>an empty list <code>new_bfs</code> for the next round's search.</li>
<li>an empty list <code>second_bfs_queue</code> for searching the distance between two islands later.</li>
</ul>
</li>
<li>
<p>Iterate over <code>bfs_queue</code>, for each cell <code>grid[x][y]</code>, if <code>grid[x][y] = 1</code>:</p>
<ul>
<li>set <code>grid[x][y] = 2</code></li>
<li>add <code>(x, y)</code> to <code>new_bfs</code> for the next round's search.</li>
<li>add <code>(x, y)</code> to <code>second_bfs_queue</code> for searching over water cells later.</li>
</ul>
</li>
<li>
<p>If <code>new_bfs</code> is not empty, we set <code>bfs_queue = new_bfs</code> and repeat step 3. Otherwise, move on to step 5.</p>
</li>
<li>
<p>Set <code>distance = 0</code>.</p>
</li>
<li>
<p>Now we start BFS on water cells. While <code>second_bfs_queue</code> is not empty, we create an empty list <code>new_bfs</code> to collect the cells we need to visit in the next round. Iterate over cells in <code>second_bfs_queue</code>, for each cell <code>(x, y)</code>:</p>
<ul>
<li>if <code>grid[x][y] = 1</code>, it means we have reached the second island, return <code>distance</code>.</li>
<li>Otherwise, we look for its unvisited water neighbors (cells with value of <code>0</code>), mark them as <code>-1</code> and add them to <code>new_bfs</code>.</li>
</ul>
</li>
<li>
<p>Once the iteration ends, set <code>second_bfs_queue = new_bfs</code>, increment <code>distance</code> by 1, and repeat the step 6.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/n5yNZrVo/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n \times n\)</span> be the size of the input matrix <code>grid</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>The maximum number of water cells and the maximum number of land cells in island <code>A</code> we need to check are <span class="math inline">\(n^2\)</span>, which will take <span class="math inline">\(O(n^2)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>The maximum number of land cells of island <code>A</code> that we need to check with BFS is <span class="math inline">\(n^2\)</span>, thus the space used by <code>bfs_queue</code> is <span class="math inline">\(O(n^2)\)</span>.</li>
<li>The maximum number of water cells we need to check using BFS before reaching the second island is <span class="math inline">\(n^2\)</span>, thus the space used by <code>second_bfs_queue</code> is also <span class="math inline">\(O(n^2)\)</span>.</li>
<li>To sum up, the overall space complexity is <span class="math inline">\(O(n^2)\)</span><br />
<br/></li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-300">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1" target="_blank" rel="noopener noreferrer">Shortest Distance in a Binary Maze</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>n * m</strong>&nbsp;matrix <strong>grid</strong> where each element can either be <strong>0</strong> or <strong>1</strong>. You&nbsp;need to find the shortest distance&nbsp;between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.&nbsp;</span></p>
<p><span style="font-size: 18px;">If the path is not possible between source cell and destination cell, then return <strong>-1</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Note :&nbsp;</strong>You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of the four directions, Up, Down, Left and Right. The source and destination cell are based on the zero based indexing. The destination cell should be 1.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1},
            {1, 1, 0, 1},
            {1, 1, 1, 1},
            {1, 1, 0, 0},
            {1, 0, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 1}</span>
<span style="font-size: 18px;">destination = {2, 2}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">1 <strong>1</strong> 1 1
1 <strong>1</strong> 0 1
1 <strong>1</strong> <strong>1</strong> 1
1 1 0 0
1 0 0 1
The highlighted part in the matrix denotes the 
shortest path from source to destination cell.</span>
</pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input:</span></strong>
<span style="font-size: 18px;">grid[][] = {{1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0},
            {1, 0, 1, 0, 1}}</span>
<span style="font-size: 18px;">source = {0, 0}</span>
<span style="font-size: 18px;">destination = {3, 4}</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">-1</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">The path is not possible between source and</span>&nbsp;
<span style="font-size: 18px;">destination, hence return -1.</span>
</pre>
<p><strong><span style="font-size: 18px;">Your Task:</span></strong></p>
<p><span style="font-size: 18px;">You don't need to read or print anything. Your task is to complete the function <strong>shortestPath()&nbsp;</strong>which takes the a 2D integer array&nbsp;<strong>grid</strong>, <strong>source</strong> cell and <strong>destination</strong> cell&nbsp;as an input parameters and returns the shortest distance between source and destination cell.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n * m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(n * m)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span></p>
<ul>
<li><span style="font-size: 18px;">1 &le; n, m &le; 500</span></li>
<li><span style="font-size: 18px;">grid[i][j] == 0 or grid[i][j] == 1</span></li>
<li><span style="font-size: 18px;">The source and destination cells are always inside the given matrix.</span></li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-301">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-path-by-removing-k-walls/1" target="_blank" rel="noopener noreferrer">Shortest Path by Removing K walls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a 2-D binary <strong>matrix</strong> of size <strong>n*m</strong>, where 0 represents an empty space while 1 represents a wall you cannot walk through. You are also given an integer <strong>k</strong>.<br />
You can walk up, down, left, or right. Given that you can remove up to <strong>k</strong> walls, return the minimum number of steps to walk from the top left corner (0, 0) to the bottom right corner (n-1, m-1).</span><br />
<span style="font-size:18px"><strong>Note: </strong>If there is no way to walk from the top left corner to the bottom right corner, return -1.</span></p>

<p><br />
<span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>n = 3, m = 3, k = 1
mat = {{0, 0, 0},
       {0, 0, 1},
       {0, 1, 0}}
<strong>Output:
</strong>4<strong>
Explanation:
</strong>We can remove any one of the walls and
reach the bottom in 4 moves. </span> 
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:
</strong>n = 2, m = 2, k = 0
mat[] = {{0, 1},
         {1, 0}}
<strong>Output:
</strong>-1<strong>
Explanation:
</strong>There&#39;s no way of reaching the bottom
corner without removing any walls.</span>
</pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
The task is to complete the function <strong>shotestPath</strong>() which takes three integers n, m, and k and also a matrix of size n*m as input and returns the minimum number of steps to walk from the top left corner to the bottom right corner.</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; n,m &le; 50<br />
0 &le; k &le; n*m<br />
Top left and bottom right corners doesn&#39;t have 1</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:&nbsp;</strong>O(n*m*k).<br />
<strong>Expected Auxiliary Space:&nbsp;</strong>O(n*m*k).</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-302">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description" target="_blank" rel="noopener noreferrer">Shortest Path in a Grid with Obstacles Elimination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.</p>

<p>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code><em> given that you can eliminate <strong>at most</strong> </em><code>k</code><em> obstacles</em>. If it is not possible to find such walk return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg" style="width: 244px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The shortest path without eliminating any obstacle is 10.
The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
<strong>Output:</strong> -1
<strong>Explanation:</strong> We need to eliminate at least two obstacles to find such a walk.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 40</code></li>
	<li><code>1 &lt;= k &lt;= m * n</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>
	<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-303">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-in-binary-matrix/description" target="_blank" rel="noopener noreferrer">Shortest Path in Binary Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> binary matrix <code>grid</code>, return <em>the length of the shortest <strong>clear path</strong> in the matrix</em>. If there is no clear path, return <code>-1</code>.</p>

<p>A <strong>clear path</strong> in a binary matrix is a path from the <strong>top-left</strong> cell (i.e., <code>(0, 0)</code>) to the <strong>bottom-right</strong> cell (i.e., <code>(n - 1, n - 1)</code>) such that:</p>

<ul>
	<li>All the visited cells of the path are <code>0</code>.</li>
	<li>All the adjacent cells of the path are <strong>8-directionally</strong> connected (i.e., they are different and they share an edge or a corner).</li>
</ul>

<p>The <strong>length of a clear path</strong> is the number of visited cells of this path.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example1_1.png" style="width: 500px; height: 234px;" />
<pre>
<strong>Input:</strong> grid = [[0,1],[1,0]]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/example2_1.png" style="height: 216px; width: 500px;" />
<pre>
<strong>Input:</strong> grid = [[0,0,0],[1,1,0],[1,1,0]]
<strong>Output:</strong> 4
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,0]]
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>grid[i][j] is 0 or 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-304">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-path-to-get-all-keys/description" target="_blank" rel="noopener noreferrer">Shortest Path to Get All Keys</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> grid <code>grid</code> where:</p>

<ul>
	<li><code>&#39;.&#39;</code> is an empty cell.</li>
	<li><code>&#39;#&#39;</code> is a wall.</li>
	<li><code>&#39;@&#39;</code> is the starting point.</li>
	<li>Lowercase letters represent keys.</li>
	<li>Uppercase letters represent locks.</li>
</ul>

<p>You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.</p>

<p>If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.</p>

<p>For some <code><font face="monospace">1 &lt;= k &lt;= 6</font></code>, there is exactly one lowercase and one uppercase letter of the first <code>k</code> letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.</p>

<p>Return <em>the lowest number of moves to acquire all keys</em>. If it is impossible, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" style="width: 404px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@.a..&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]
<strong>Output:</strong> 8
<strong>Explanation:</strong> Note that the goal is to obtain all the keys not to open all the locks.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" style="width: 404px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]
<strong>Output:</strong> 6
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" style="width: 244px; height: 85px;" />
<pre>
<strong>Input:</strong> grid = [&quot;@Aa&quot;]
<strong>Output:</strong> -1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 30</code></li>
	<li><code>grid[i][j]</code> is either an English letter, <code>&#39;.&#39;</code>, <code>&#39;#&#39;</code>, or <code>&#39;@&#39;</code>.&nbsp;</li>
	<li>There is exactly one&nbsp;<code>&#39;@&#39;</code>&nbsp;in the grid.</li>
	<li>The number of keys in the grid is in the range <code>[1, 6]</code>.</li>
	<li>Each key in the grid is <strong>unique</strong>.</li>
	<li>Each key in the grid has a matching lock.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force--permutations">Approach 1: Brute Force + Permutations</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We have to pick up the keys <span class="math inline">\(K\)</span> in some order, say <span class="math inline">\(K_{\sigma_i}\)</span>.</p>
<p>For each ordering, let's do a breadth first search to find the distance to the next key.</p>
<p>For example, if the keys are <code>'abcdef'</code>, then for each ordering such as <code>'bafedc'</code>, we will try to calculate the candidate distance from <code>'@' -&gt; 'b' -&gt; 'a' -&gt; 'f' -&gt; 'e' -&gt; 'd' -&gt; 'c'</code>.</p>
<p>Between each segment of our path (and corresponding breadth-first search), we should remember what keys we've picked up.  Keys that are picked up become part of a mask that helps us identify what locks we are allowed to walk through during the next breadth-first search.</p>
<p>Each part of the algorithm is relatively straightforward, but the implementation in total can be quite challenging.  See the comments for more details.</p>
<p><a href="https://leetcode.com/playground/bMednP5j/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(R * C * \mathcal{A} * \mathcal{A}!)\)</span>, where <span class="math inline">\(R, C\)</span> are the dimensions of the grid, and <span class="math inline">\(\mathcal{A}\)</span> is the maximum number of keys (<span class="math inline">\(\mathcal{A}\)</span> because it is the &quot;size of the alphabet&quot;.)  Each <code>bfs</code> is performed up to <span class="math inline">\(\mathcal{A} * \mathcal{A}!\)</span> times.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(R * C + \mathcal{A}!)\)</span>, the space for the <code>bfs</code> and to store the candidate key permutations.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-points-of-interest--dijkstra">Approach 2: Points of Interest + Dijkstra</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Clearly, we only really care about walking between points of interest: the keys, locks, and starting position.  We can use this insight to speed up our calculation.</p>
<p>Let's make this intuition more formal: any walk can be decomposed into <em>primitive</em> segments, where each segment (between two points of interest) is primitive if and only if it doesn't touch any other point of interest in between.</p>
<p>Then, we can calculate the distance (of a primitive segment) between any two points of interest, using a breadth first search.</p>
<p>Afterwards, we have some graph (where each node refers to at most <span class="math inline">\(13\)</span> places, and at most <span class="math inline">\(2^6\)</span> states of keys).  We have a starting node (at <code>'@'</code> with no keys) and ending nodes (at anywhere with all keys.)  We also know all the costs to go from one node to another - each node has outdegree at most 13.  This shortest path problem is now ideal for using Dijkstra's algorithm.</p>
<p>Dijkstra's algorithm uses a priority queue to continually searches the path with the lowest cost to destination, so that when we reach the target, we know it must have been through the lowest cost path.  Refer to <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">this link</a> for more detail.</p>
<p>Again, each part of the algorithm is relatively straightforward (for those familiar with BFS and Dijkstra's algorithm), but the implementation in total can be quite challenging.</p>
<p><a href="https://leetcode.com/playground/Mox2BNP6/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(RC(2\mathcal{A} + 1) + \mathcal{E} \log \mathcal{N})\)</span>, where <span class="math inline">\(R, C\)</span> are the dimensions of the grid, and <span class="math inline">\(\mathcal{A}\)</span> is the maximum number of keys, <span class="math inline">\(\mathcal{N} = (2\mathcal{A} + 1) * 2^\mathcal{A}\)</span> is the number of nodes when we perform Dijkstra's, and <span class="math inline">\(\mathcal{E} = \mathcal{N} * (2 \mathcal{A} + 1)\)</span> is the maximum number of edges.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(\mathcal{N})\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-305">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-source-to-destination-path3544/1" target="_blank" rel="noopener noreferrer">Shortest Source to Destination Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">bfs</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dfs</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a&nbsp;2D binary matrix A(0-based index) of dimensions NxM. Find the minimum number of steps required to reach from (0,0) to (X, Y).<br />Note: You can only move left, right, up and down, and only through cells that <strong>contain 1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,0,0,0], 
   [1,1,0,1],<br />   [0,1,1,1]]
X=2, Y=3 
<strong>Output:</strong>
5
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(1,0)-&gt;(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong>
N=3, M=4
A=[[1,1,1,1],
   [0,0,0,1],<br />   [0,0,0,1]]
X=0, Y=3
<strong>Output:</strong>
3
<strong>Explanation:</strong>
The shortest path is as follows:
(0,0)-&gt;(0,1)-&gt;(0,2)-&gt;(0,3).</span></pre>
<p><span style="font-size: 14pt;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>shortestDistance()</strong> which takes the integer N, M, X, Y, and the 2D binary matrix A as input parameters and returns the minimum number of steps required to go from (0,0) to (X, Y).If it is impossible to go from (0,0) to&nbsp;(X, Y),then function returns -1. If value of the cell (0,0) is 0&nbsp;(i.e&nbsp; A[0][0]=0)&nbsp;then return -1.</span></p>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 250<br /></span><span style="font-size: 14pt;">0 &lt;= X &lt; N<br /></span><span style="font-size: 14pt;">0 &lt;= Y &lt; M<br />0 &lt;= A[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-306">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sliding-puzzle/description" target="_blank" rel="noopener noreferrer">Sliding Puzzle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>On an <code>2 x 3</code> board, there are five tiles labeled from <code>1</code> to <code>5</code>, and an empty square represented by <code>0</code>. A <strong>move</strong> consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>

<p>The state of the board is solved if and only if the board is <code>[[1,2,3],[4,5,0]]</code>.</p>

<p>Given the puzzle board <code>board</code>, return <em>the least number of moves required so that the state of the board is solved</em>. If it is impossible for the state of the board to be solved, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[4,0,5]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Swap the 0 and the 5 in one move.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,2,3],[5,4,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No number of moves will make the board solved.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg" style="width: 244px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[4,1,2],[5,0,3]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 2</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>
	<li>Each value <code>board[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-depth-first-search-dfs">Approach 1: Depth-First Search (DFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>A brute-force approach is feasible due to the problem's small constraints. We can explore all possible board states and track the number of moves taken to reach each one. Once we reach the solved state, we return the move count.</p>
<p>The first step is to identify the possible moves from each board position. Each move shifts the '0' (blank square) in one of the four cardinal directions. To simplify, weâ€™ll flatten the 2-D board to a 1-D string by appending the first row to the second. The moves at each square are now converted as given below, where each index represents the position of the zero, and lists the indices in the 1-D string it can go to:</p>
<p><img src="../Figures/773/2dto1d.png" alt="" /></p>
<p>The above figure demonstrates how each tile position is mapped to an index in the 1-D string, and how the tile movements are simulated in the string.</p>
<p>We'll use depth-first search (DFS) to explore all board states. DFS is well-suited here because it allows us to explore each possible path to the solution one by one, fully exploring each path before backtracking. Starting from the initial board state as a flattened string, we maintain a <code>visited</code> map, where each board state is a key, and the value is the number of moves taken to reach it. In our DFS, if the current state already exists in the map with fewer moves, we return early. Otherwise, we update the map with the current move count and explore all possible moves.</p>
<p>Next, we can put the current state in the map with the current move count and start exploring all possible moves from this position. We modify the board based on the next move and recursively call the DFS function to explore further.</p>
<p>After exploring all moves, if the solved state appears in the map, we return its move count; if not, we return -1, as solving the board is impossible.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a 2-D array <code>directions</code> which represents the possible moves for the empty tile (<code>0</code>) at each position on a flattened 1D representation of the <span class="math inline">\(2 \times 3\)</span> board.</li>
</ul>
<p>Main method <code>slidingPuzzle</code>:</p>
<ul>
<li>Initialize a string <code>startState</code> to represent the initial state of the board in a 1-D string format.</li>
<li>Iterate over each cell in the 2-D board and append each element to <code>startState</code>.</li>
<li>Initialize a map <code>visited</code> to store each unique state of the board encountered during the search.</li>
<li>Call a helper function <code>dfs</code> on <code>startState</code>, passing <code>visited</code>, the index of <code>0</code> in <code>startState</code>, and a move count initialized to <code>0</code>.</li>
<li>Return the minimum moves required to reach the solved state (<code>&quot;123450&quot;</code>), or -1 if the state was not found in <code>visited</code>.</li>
</ul>
<p>Helper method <code>dfs</code>:</p>
<ul>
<li>Check if the <code>state</code> has already been visited with fewer or equal moves than the current count (<code>moves</code>).
<ul>
<li>If so, skip further exploration of this path.</li>
</ul>
</li>
<li>Update <code>visited</code> with the current state and move count.</li>
<li>For each adjacent position <code>nextPos</code> in <code>directions</code>:
<ul>
<li>Swap the characters at <code>zeroPos</code> and <code>nextPos</code> in <code>state</code>.</li>
<li>Recursively call <code>dfs</code> on the newly generated state with <code>moves</code> incremented by 1.</li>
</ul>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/7xoehmiw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<blockquote>
<p>Note: The values of m and n are fixed by the problem constraints, so their complexities can be considered constant. However, we have kept them as variables for clarity and better understanding.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span></p>
<p>In DFS, each of the <span class="math inline">\((m \cdot n)!\)</span> possible board states can be revisited multiple times due to different move sequences, as DFS doesnâ€™t prioritize the shortest path and may explore all possible paths, reaching the same state repeatedly. Since each state has up to four possible moves on a 2D board, DFS could re-explore each configuration from different directions, leading to up to <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span> recursive calls. Generating each new configuration requires <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Thus, the time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n)^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The DFS approach requires storing each of the <span class="math inline">\((m \cdot n)!\)</span> unique states in a <code>visited</code> map to avoid recalculations when a state is reached with the same or fewer moves. In the worst case, the DFS call stack can reach a maximum depth of <span class="math inline">\(O((m \cdot n)!)\)</span>, giving a space complexity of <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-breadth-first-search-bfs">Approach 2: Breadth-First Search (BFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The DFS approach explores all possible board states before reaching the final state, which can be inefficient. Although we might find the solution early, DFS will still continue to explore all paths, potentially with non-optimal move counts. To address this, we switch to Breadth-First Search (BFS). BFS is better suited in scenarios like this because it explores all states at the current move level before going deeper, ensuring that the first time it reaches the goal, it has found the shortest path.</p>
<p>Our setup remains similar: we convert the board to a 1-D string and use a set to track visited states. A queue will handle the BFS traversal, starting from the initial state. The queueâ€™s structure works well to support BFSâ€™s layered exploration, since each level is processed sequentially and we stop as soon as we reach the goal.</p>
<p>We then loop while the queue is not empty, processing all states at the current move count. If we encounter the final state, we return the current move count as the answer. Otherwise, we explore all possible moves from the current state, modify the board accordingly, and, if unvisited, add the new state to the queue for further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Define an array <code>directions</code> to map the possible moves for the empty tile (<code>0</code>) at each position.</li>
<li>Initialize a string:
<ul>
<li><code>target</code> to &quot;123450&quot;, representing the goal state of the board.</li>
<li><code>startState</code> to store the initial configuration of the board in string form.</li>
</ul>
</li>
<li>Iterate through each row and column of <code>board</code>:
<ul>
<li>Append each tile value to <code>startState</code> to create a single string representing the initial board state.</li>
</ul>
</li>
<li>Initialize:
<ul>
<li>a set <code>visited</code> to store all the board states already processed to prevent redundant calculations.</li>
<li>a <code>queue</code> for the Breadth-First Search (BFS) traversal.</li>
<li>an integer <code>moves</code> to 0, which will track the number of moves taken to reach the goal state.</li>
</ul>
</li>
<li>Add <code>startState</code> to <code>visited</code> to mark it as processed.</li>
<li>Start a while loop that continues as long as <code>queue</code> is not empty:
<ul>
<li>Store the current size of <code>queue</code> in <code>size</code>. For each item in the current level:
<ul>
<li>Remove the front element of <code>queue</code> and assign it to <code>currentState</code>.</li>
<li>Check if <code>currentState</code> matches <code>target</code>. If it does, return <code>moves</code> as the minimum moves required to reach the solved state.</li>
<li>Set <code>zeroPos</code> to the position of zero in <code>currentState</code>.</li>
<li>For each valid new position <code>newPos</code> in <code>directions[zeroPos]</code>:
<ul>
<li>Generate <code>nextState</code> by swapping <code>zeroPos</code> and <code>newPos</code>.</li>
<li>If <code>nextState</code> is already in <code>visited</code>, skip it to avoid redundant processing.</li>
<li>Otherwise, add <code>nextState</code> to both <code>visited</code> and <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Increment <code>moves</code> to continue to the next level of BFS.</li>
</ul>
</li>
<li>If <code>queue</code> becomes empty without reaching the target, return -1, indicating the puzzle is unsolvable.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/2hGW2Z7j/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> be the number of columns of the board.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span></p>
<p>The algorithm uses Breadth-First Search (BFS) to explore all possible board configurations. With <span class="math inline">\((m \cdot n)!\)</span> unique configurations, BFS may process each configuration once. Each configuration requires checking moves and generating new ones, taking <span class="math inline">\(O(m \cdot n)\)</span> operations.</p>
<p>Therefore, the overall time complexity is <span class="math inline">\(O((m \cdot n)! \times (m \cdot n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((m \cdot n)!)\)</span></p>
<p>The space complexity is determined by the <code>visited</code> set and the BFS queue, each of which can hold up to <span class="math inline">\((m \cdot n)!\)</span> unique configurations in the worst case. Therefore, the space complexity is <span class="math inline">\(O((m \cdot n)!)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-307">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/snakes-and-ladders/description" target="_blank" rel="noopener noreferrer">Snakes and Ladders</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n<sup>2</sup></code> in a <a href="https://en.wikipedia.org/wiki/Boustrophedon" target="_blank"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.</p>

<p>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:</p>

<ul>
	<li>Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n<sup>2</sup>)]</code>.

	<ul>
		<li>This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.</li>
	</ul>
	</li>
	<li>If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.</li>
	<li>The game ends when you reach the square <code>n<sup>2</sup></code>.</li>
</ul>

<p>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n<sup>2</sup></code> are not the starting points of any snake or ladder.</p>

<p>Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent&nbsp;snake or ladder.</p>

<ul>
	<li>For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.</li>
</ul>

<p>Return <em>the least number of dice rolls required to reach the square </em><code>n<sup>2</sup></code><em>. If it is not possible to reach the square, return </em><code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" style="width: 500px; height: 394px;" />
<pre>
<strong>Input:</strong> board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = [[-1,-1],[-1,3]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == board.length == board[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 20</code></li>
	<li><code>board[i][j]</code> is either <code>-1</code> or in the range <code>[1, n<sup>2</sup>]</code>.</li>
	<li>The squares labeled <code>1</code> and <code>n<sup>2</sup></code> are not the starting points of any snake or ladder.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-308">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/solve-the-sudoku-1587115621/1" target="_blank" rel="noopener noreferrer">Solve the Sudoku</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an&nbsp;incomplete&nbsp;<a href="https://www.geeksforgeeks.org/introduction-to-sudoku-puzzles-and-how-to-solve-them/"><strong>Sudoku</strong></a> configuration in terms of a 9x9&nbsp; 2-D interger square matrix, <strong>mat[][]</strong>, the task is to solve the Sudoku.&nbsp;</span><span style="font-size: 18px;">It is <strong>guaranteed </strong>that the input Sudoku will have exactly <strong>one </strong>solution.</span></p>
<p><span style="font-size: 18px;">A sudoku solution must satisfy&nbsp;all of the following rules:</span></p>
<ol>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each row.</span></li>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each column.</span></li>
<li><span style="font-size: 18px;">Each of the digits&nbsp;<code>1-9</code>&nbsp;must occur exactly once in each of the 9&nbsp;<code>3x3</code>&nbsp;sub-boxes of the grid.</span></li>
</ol>
<p><span style="font-size: 18px;"><strong>Note:</strong> Zeros represent blanks to be filled with numbers 1-9, while non-zero cells are <strong>fixed </strong>and cannot be changed.</span><span style="font-size: 18px;"><br /></span></p>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">mat[][] = 
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306620.png" alt="" width="260" height="212" />
</span><strong style="font-size: 18px;">Output:</strong><span style="font-size: 18px;">
<img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306722.png" alt="" width="258" height="203" /><br /></span><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> Each row, column and 3 x 3 box of the output matrix contains unique numbers.</span></pre>
<pre><strong><span style="font-size: 18px;">Input: </span></strong><span style="font-size: 18px;">mat[][] = 
</span><span style="font-size: 18px;"><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/886267/Web/Other/blobid1_1738136756.png" alt="" width="262" height="209" /><br /></span><strong style="font-size: 18px;">Output:</strong><br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701375/Web/Other/blobid0_1738306722.png" alt="" width="258" height="203" /><br /><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;"> Each row, column and 3 x 3 box of the output matrix contains unique numbers.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />mat.size() = 9<br />mat[i].size() = 9<br />0 &le; mat[i][j] &le; 9<br /></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-309">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/diagonal-morning-assembly0028/1" target="_blank" rel="noopener noreferrer">Sort a 2D vector diagonally</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an <strong>NxM</strong> 2D matrix, rearrange such that&nbsp;<br />Each diagonal in the lower left triangle of the rectangular grid is sorted in ascending order.&nbsp;<br />Each diagonal in the upper right triangle of the rectangular grid is sorted in descending order.&nbsp;<br />The major diagonal in the grid starting from the top-left corner is not rearranged.&nbsp;</span></p>
<p><br /><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 4, M = 5 
matrix = {{3 6 3 8 2},
          {4 1 9 5 9},
          {5 7 2 4 8},
          {8 3 1 7 6}}
<strong>Output:</strong>
3 9 8 9 2
1 1 6 5 8
3 4 2 6 3
8 5 7 7 4
<strong>Explanation:</strong></span>
<span style="font-size: 18px;">Before:
<img style="height: 139px; width: 180px;" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20201012182216/after1.png" alt="" /></span>
<span style="font-size: 18px;">After:
<img style="height: 150px; width: 185px;" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20201012182218/before.png" alt="" /></span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>diagonalSort()</strong> which takes the matrix, n and m as input parameter and rearranges the elements of the matrix.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(N*M*log(min(N,M)))<br /><strong>Expected Auxiliary Space: </strong>O(min(N,M))</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N,M &lt;= 10<sup>4&nbsp;</sup>,&nbsp;1&lt;=N*M&lt;=10<sup>5</sup><br />1 &lt;= matrix[i] &lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-310">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sorted-matrix2333/1" target="_blank" rel="noopener noreferrer">Sorted matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an NxN&nbsp;matrix Mat. Sort&nbsp;all elements of the matrix.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=4
Mat=[[10,20,30,40],
[15,25,35,45] 
[27,29,37,48] 
[32,33,39,50]]
<strong>Output:</strong>
10 15 20 25 
27 29 30 32
33 35 37 39
40 45 48 50
<strong>Explanation:</strong>
Sorting the matrix gives this result.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3
Mat=[[1,5,3],[2,8,7],[4,6,9]]
<strong>Output:</strong>
1 2 3 
4 5 6
7 8 9
<strong>Explanation:</strong>
Sorting the matrix gives this result.</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>sortedMatrix()</strong> which takes the integer N and the matrix Mat as input parameters and returns the sorted matrix.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N<sup>2</sup>LogN)<br />
<strong>Expected Auxillary Space:</strong>O(N<sup>2</sup>)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N&lt;=1000<br />
1&lt;=Mat[i][j]&lt;=10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-311">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-matrix-by-diagonals/description" target="_blank" rel="noopener noreferrer">Sort Matrix by Diagonals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> square matrix of integers <code>grid</code>. Return the matrix such that:</p>

<ul>
	<li>The diagonals in the <strong>bottom-left triangle</strong> (including the middle diagonal) are sorted in <strong>non-increasing order</strong>.</li>
	<li>The diagonals in the <strong>top-right triangle</strong> are sorted in <strong>non-decreasing order</strong>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,7,3],[9,8,2],[4,5,6]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[8,2,3],[9,6,7],[4,5,1]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/29/4052example1drawio.png" style="width: 461px; height: 181px;" /></p>

<p>The diagonals with a black arrow (bottom-left triangle) should be sorted in non-increasing order:</p>

<ul>
	<li><code>[1, 8, 6]</code> becomes <code>[8, 6, 1]</code>.</li>
	<li><code>[9, 5]</code> and <code>[4]</code> remain unchanged.</li>
</ul>

<p>The diagonals with a blue arrow (top-right triangle) should be sorted in non-decreasing order:</p>

<ul>
	<li><code>[7, 2]</code> becomes <code>[2, 7]</code>.</li>
	<li><code>[3]</code> remains unchanged.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1],[1,2]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[2,1],[1,0]]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/12/29/4052example2adrawio.png" style="width: 383px; height: 141px;" /></p>

<p>The diagonals with a black arrow must be non-increasing, so <code>[0, 2]</code> is changed to <code>[2, 0]</code>. The other diagonals are already in the correct order.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[1]]</span></p>

<p><strong>Explanation:</strong></p>

<p>Diagonals with exactly one element are already in order, so no changes are needed.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>grid.length == grid[i].length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>-10<sup>5</sup> &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem requires us to sort the diagonal elements of the lower-left triangle (including the diagonal) of the matrix in non-increasing order, and to sort the diagonal elements of the upper-right triangle in non-decreasing order.</p>
<p>We can directly perform a simulation: extract the elements along the diagonals, sort them, and then place the sorted elements back into the matrix. Therefore, we only need to know how to traverse the elements along the diagonals. Let the element at the <span class="math inline">\(i\)</span>-th row and <span class="math inline">\(j\)</span>-th column be denoted as <span class="math inline">\(\textit{grid}[i][j]\)</span>.</p>
<p>First, consider the triangle in the lower-left corner. Starting from the upper-left corner and moving toward the lower-right corner, as the row index <span class="math inline">\(i\)</span> increases, the column index <span class="math inline">\(j\)</span> also increases. Since the diagonal runs from the upper-left to the lower-right, each time <span class="math inline">\(j\)</span> starts from <span class="math inline">\(0\)</span>, we can traverse column by column, with the row index <span class="math inline">\(i\)</span> changing along with <span class="math inline">\(j\)</span>. Therefore, each diagonal in the lower-left triangle can be represented as <span class="math inline">\(\textit{grid}[i+j][j]\)</span>.</p>
<p>Next, consider the triangle in the upper-right corner. Again, starting from the upper-left corner and moving toward the lower-right corner, as the column index <span class="math inline">\(j\)</span> increases, the row index <span class="math inline">\(i\)</span> also increases. Since all the elements on the diagonals of the upper-right triangle start from the <span class="math inline">\(0\)</span>-th row, we can traverse row by row, with the column index <span class="math inline">\(j\)</span> changing along with <span class="math inline">\(i\)</span>. Therefore, the elements on each diagonal of the upper-right triangle are <span class="math inline">\(\textit{grid}[i][j+i]\)</span>.</p>
<p>At the same time, for each diagonal, the last element satisfies <span class="math inline">\(i + j = n - 1\)</span>, which ensures that we traverse all elements on the diagonals without repetition, omission, or boundary violations.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3vVF6EBV/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of rows and columns of <span class="math inline">\(\textit{grid}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \log n)\)</span>.</p>
<p>Traversing all diagonals of the matrix takes <span class="math inline">\(O(n^2)\)</span> in total, and sorting each diagonal (up to <span class="math inline">\(n\)</span> elements) costs <span class="math inline">\(O(n \log n)\)</span>. Combined, the overall complexity is <span class="math inline">\(O(n^2 \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We use a temporary array to store the elements of a diagonal before sorting them.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-312">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-the-matrix-diagonally/description" target="_blank" rel="noopener noreferrer">Sort the Matrix Diagonally</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&#39;s end. For example, the <strong>matrix diagonal</strong> starting from <code>mat[2][0]</code>, where <code>mat</code> is a <code>6 x 3</code> matrix, includes cells <code>mat[2][0]</code>, <code>mat[3][1]</code>, and <code>mat[4][2]</code>.</p>

<p>Given an <code>m x n</code> matrix <code>mat</code> of integers, sort each <strong>matrix diagonal</strong> in ascending order and return <em>the resulting matrix</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/01/21/1482_example_1_2.png" style="width: 500px; height: 198px;" />
<pre>
<strong>Input:</strong> mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
<strong>Output:</strong> [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
<strong>Output:</strong> [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-313">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-the-students-by-their-kth-score/description" target="_blank" rel="noopener noreferrer">Sort the Students by Their Kth Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a class with <code>m</code> students and <code>n</code> exams. You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>score</code>, where each row represents one student and <code>score[i][j]</code> denotes the score the <code>i<sup>th</sup></code> student got in the <code>j<sup>th</sup></code> exam. The matrix <code>score</code> contains <strong>distinct</strong> integers only.</p>

<p>You are also given an integer <code>k</code>. Sort the students (i.e., the rows of the matrix) by their scores in the <code>k<sup>th</sup></code>&nbsp;(<strong>0-indexed</strong>) exam from the highest to the lowest.</p>

<p>Return <em>the matrix after sorting it.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/30/example1.png" style="width: 600px; height: 136px;" />
<pre>
<strong>Input:</strong> score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
<strong>Output:</strong> [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
<strong>Explanation:</strong> In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/11/30/example2.png" style="width: 486px; height: 121px;" />
<pre>
<strong>Input:</strong> score = [[3,4],[5,6]], k = 0
<strong>Output:</strong> [[5,6],[3,4]]
<strong>Explanation:</strong> In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == score.length</code></li>
	<li><code>n == score[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 250</code></li>
	<li><code>1 &lt;= score[i][j] &lt;= 10<sup>5</sup></code></li>
	<li><code>score</code> consists of <strong>distinct</strong> integers.</li>
	<li><code>0 &lt;= k &lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-314">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/special-positions-in-a-binary-matrix/description" target="_blank" rel="noopener noreferrer">Special Positions in a Binary Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> binary matrix <code>mat</code>, return <em>the number of special positions in </em><code>mat</code><em>.</em></p>

<p>A position <code>(i, j)</code> is called <strong>special</strong> if <code>mat[i][j] == 1</code> and all other elements in row <code>i</code> and column <code>j</code> are <code>0</code> (rows and columns are <strong>0-indexed</strong>).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/special1.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[1,0,0],[0,0,1],[1,0,0]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/special-grid.jpg" style="width: 244px; height: 245px;" />
<pre>
<strong>Input:</strong> mat = [[1,0,0],[0,1,0],[0,0,1]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> (0, 0), (1, 1) and (2, 2) are special positions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Intuition</strong></p>
<p>For our first approach, we will apply a brute force search for each square in <code>mat</code>.</p>
<p>We iterate over every square <code>(row, col)</code> in <code>mat</code>. For each <code>(row, col)</code>, we first check if <code>mat[row][col] = 1</code>. If it is, then it could possibly be a special position. Next, we check if there are any squares with the same <code>row</code> or same <code>col</code> that have a value of <code>1</code>. If there are, then the current square <code>(row, col)</code> is not special, otherwise, <code>(row, col)</code> is special.</p>
<p>To perform this check, we initialize a boolean flag <code>good = true</code> indicating that the current square is special. We then iterate over each row in the <code>mat</code> using another variable <code>r</code>. For each value of <code>r</code> other than <code>row</code>, we check if <code>mat[r][col] = 1</code>. If it is, it means that there is another cell with value 1 in the same column, so the current square is not special, and we set <code>good = false</code>.</p>
<p>Then, we do the same for the columns with a variable <code>c</code>. For each value of <code>c</code> other than <code>col</code>, we check if <code>mat[row][c] = 1</code>. If it is, we set <code>good = false</code>.</p>
<p><img src="../Figures/1582/1.png" alt="example" /><br />
<br></p>
<p>After checking the rows and columns, if <code>good</code> is still <code>true</code>, then the current square is special. We can increment our answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Set the answer <code>ans = 0</code>, and the size of the matrix <code>m = mat.length, n = mat[0].length</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> until <code>m</code>:
<ul>
<li>Iterate <code>col</code> from <code>0</code> until <code>n</code>:
<ul>
<li>If <code>mat[row][col] = 0</code>, <code>continue</code> to the next iteration.</li>
<li>Set <code>good = true</code>.</li>
<li>Iterate <code>r</code> from <code>0</code> until <code>m</code>:
<ul>
<li>If <code>r != row</code> and <code>mat[r][col] = 1</code>, set <code>good = false</code> and <code>break</code> from the loop.</li>
</ul>
</li>
<li>Iterate <code>c</code> from <code>0</code> until <code>n</code>:
<ul>
<li>If <code>c != col</code> and <code>mat[row][c] = 1</code>, set <code>good = false</code> and <code>break</code> from the loop.</li>
</ul>
</li>
<li>If <code>good = true</code>, increment <code>ans</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Riw46JHS/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(m\)</span> as the number of rows in <code>mat</code> and <span class="math inline">\(n\)</span> as the number of columns in <code>mat</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span></p>
<p>There are <span class="math inline">\(m \cdot n\)</span> squares. For each square, in the worst case, we perform iterations over <span class="math inline">\(m\)</span> squares of the same column and <span class="math inline">\(n\)</span> squares of the same row. Thus, the time complexity is <span class="math inline">\(O(m \cdot n \cdot (m + n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-precompute-the-number-of-ones-in-each-row-and-column">Approach 2: Precompute the Number of Ones in each Row and Column</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, for each square <code>(row, col)</code>, we iterated over every other square that shared a <code>row</code> or <code>col</code> to determine if the current square was special, but you might have noticed that this involved a lot of repetitive traversals. Is there a more efficient way for us to determine if a square is special?</p>
<p>For a given <code>(row, col)</code>, we are trying to answer: &quot;is there another square in this <code>row</code> or this <code>col</code> with a value of <code>1</code>?&quot;.</p>
<p>We can pre-process two arrays <code>rowCount</code> and <code>colCount</code> that tell us how many squares each row or column have with a value of <code>1</code>. For example, <code>rowCount[3]</code> would tell us how many squares in the row with index <code>3</code> have a value of <code>1</code>. Similarly, <code>colCount[7]</code> would tell us how many squares in the column with index <code>7</code> have a value of <code>1</code>.</p>
<p><img src="../Figures/1582/2.png" alt="example" /><br />
<br></p>
<p>Once we have these arrays, we iterate over every square <code>(row, col)</code> and first check if <code>mat[row][col] = 1</code>. If it is, we now check if there are any other squares that share a row or column with a value of <code>1</code>. Because <code>(row, col)</code> itself has a value of <code>1</code>, it is special if <code>rowCount[row] = 1</code> and <code>colCount[col] = 1</code>.</p>
<p>If these values are both <code>1</code>, then it means <code>(row, col)</code> is the <strong>only</strong> square with either coordinate that has a value of <code>1</code>, and thus it is special.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the size of the matrix <code>m = mat.length, n = mat[0].length</code>.</li>
<li>Initialize two integer arrays <code>rowCount</code> of length <code>m</code> and <code>colCount</code> of length <code>n</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> until <code>m</code>:
<ul>
<li>Iterate <code>col</code> from <code>0</code> until <code>n</code>:
<ul>
<li>If <code>mat[row][col] = 1</code>, increment <code>rowCount[row]</code> and <code>colCount[col]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize the answer <code>ans = 0</code>.</li>
<li>Iterate <code>row</code> from <code>0</code> until <code>m</code>:
<ul>
<li>Iterate <code>col</code> from <code>0</code> until <code>n</code>:
<ul>
<li>If <code>mat[row][col] = 1</code>:
<ul>
<li>If <code>rowCount[row] = 1</code> and <code>colCount[col] = 1</code>, increment <code>ans</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/DhGjHAfy/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(m\)</span> as the number of rows in <code>mat</code> and <span class="math inline">\(n\)</span> as the number of columns in <code>mat</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n)\)</span></p>
<p>To calculate <code>rowCount</code> and <code>colCount</code>, we iterate over each square once, which costs <span class="math inline">\(O(m \cdot n)\)</span>.</p>
<p>Next, we iterate over each square again to determine if it is special. Each iteration costs <span class="math inline">\(O(1)\)</span>, so in total we spend <span class="math inline">\(O(m \cdot n)\)</span> here.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<p><code>rowCount</code> has a size of <span class="math inline">\(m\)</span> and <code>colCount</code> has a size of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-315">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1" target="_blank" rel="noopener noreferrer">Spirally traversing a matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">arrays</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a rectangular matrix <strong>mat[][]</strong> of size <strong>n x m</strong>, and your task is to return an array while <strong>traversing</strong>&nbsp;the matrix in <strong>spiral</strong> form.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[1, 2, 3, 4],<br />                [5, 6, 7, 8],<br />                [9, 10, 11, 12], <br />                [13, 14, 15, 16]]
<strong>Output</strong>: [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]
<strong>Explanation</strong>: <br /><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701264/Web/Other/blobid1_1734498654.png" width="456" height="228" /><br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[2, 7, 10],<br />                [5, 1, 3],<br />                [4, 2, 8]]
<strong>Output</strong>: [2, 7, 10, 3, 8, 2, 4, 5, 1]
<strong>Explanation</strong>: Applying same technique as shown above.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: mat[][] = [[32, 44, 27, 23],<br />                [54, 28, 50, 62]]
<strong>Output</strong>: [32, 44, 27, 23, 62, 50, 28, 54]
<strong>Explanation</strong>: Applying same technique as shown above, output will be [32, 44, 27, 23, 62, 50, 28, 54].</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n, m &le;1000<br />0 &le; mat[i][j] &le;100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-316">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/spiral-matrix/description" target="_blank" rel="noopener noreferrer">Spiral Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10</code></li>
	<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-317">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/spiral-matrix--141631/1" target="_blank" rel="noopener noreferrer">Spiral Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">constructivealgo</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a matrix of size<strong> N x M</strong>. You have&nbsp;to find the <strong>K<sup>th</sup></strong> element which will&nbsp;obtain&nbsp;while traversing the matrix <strong>spirally</strong> starting from the top-left corner of the matrix.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: 
</strong>N = 3, M = 3, K = 4
A[] = {</span><span style="font-size:18px">{1, 2, 3}, 
       {4, 5, 6},&nbsp;
       {7, 8, 9</span><span style="font-size:18px">}}</span>
<span style="font-size:18px"><strong>Output:</strong> 
6</span>
<span style="font-size:18px"><strong>Explanation: </strong>Spiral traversal of matrix: 
{1, 2, 3, 6, 9, 8, 7, 4, 5}. Fourth element
is 6.</span>
</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: 
</strong>N = 2, M = 2, K = 2 
A[] = {</span><span style="font-size:18px">{1, 2},
       {3, 4}</span><span style="font-size:18px">}</span> 
<span style="font-size:18px"><strong>Output:</strong> 
2
<strong>Explanation: </strong>Spiral traversal of matrix: 
{1, 2, 4, 3}. Second element is 2.</span></pre>

<p><span style="font-size:18px"><strong>Your Task: </strong>&nbsp;<br />
You don&#39;t need to read input or print anything. Complete the function <strong>findK()</strong> which takes the matrix <strong>A[ ][ ]</strong>, number of rows <strong>N</strong>, number of columns <strong>M</strong>, and integer <strong>K</strong> as input parameters and returns the<strong> K<sup>th</sup> </strong>element in the spiral traversal of the matrix.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N*M)<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span></p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; K&nbsp;&le; N*M &le; 10<sup>6</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-318">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/spiral-matrix-ii/description" target="_blank" rel="noopener noreferrer">Spiral Matrix II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>There are various problems in spiral matrix series with some variations like <a href="https://leetcode.com/problems/spiral-matrix/">Spiral Matrix</a> and <a href="https://leetcode.com/problems/spiral-matrix-iii/">Spiral Matrix III</a>.</p>
<p>In order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given <span class="math inline">\(n\)</span>.<br />
Let's discuss a few approaches.</p>
<hr />
<h3 id="approach-1-traverse-layer-by-layer-in-spiral-form">Approach 1: Traverse Layer by Layer in Spiral Form</h3>
<p><strong>Intuition</strong></p>
<p>If we try to build a pattern for a given <span class="math inline">\(n\)</span>, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as  <em>layer</em>. We start traversing from the outer layer and move towards inner layers on every iteration.</p>
<p><img src="../Figures/59/spiral_layers.png" alt="img" /></p>
<p><strong>Algorithm</strong></p>
<p>Let's devise an algorithm for the spiral traversal:</p>
<ul>
<li>We can observe that, for any given <span class="math inline">\(n\)</span>, the total number of layers is given by :</li>
</ul>
<p><span class="math display">\[This works for both even and odd $$n$$.

_Example_

For $$n = 3$$, $$layers = 2$$

For $$n = 6$$, total $$layers = 3$$

- Also, for each layer, we traverse in _at most_ 4 directions :


![img](../Figures/59/spiral_traverse.png)


In every direction, either row or column remains constant and other parameter changes (increments/decrements).

_Direction 1: From top left corner to top right corner._

The row remains constant as $$\text{layer}$$ and column increments from $$\text{layer}$$ to  $$n-\text{layer}-1$$

_Direction 2: From top right corner to the bottom right corner._

The column remains constant as $$n-layer-1$$ and row increments from
$$\text{layer}+1$$ to $$n-\text{layer}$$.

_Direction 3: From bottom right corner to bottom left corner._

The row remains constant as $$n-\text{layer}-1$$ and column decrements from $$n-\text{layer}-2$$ to $$\text{layer}$$.

_Direction 4: From bottom left corner to top left corner._

The column remains constant as $$\text{layer}$$ and column decrements from $$n-\text{layer}-2$$ to $$\text{layer}+1$$.

This process repeats $$(n+1)/2$$ times until all layers are traversed.

![img](../Figures/59/spiral_detailed_fix.png)


[code](https://leetcode.com/playground/fs3Ga77r/shared)

**Complexity Analysis**

* Time Complexity: $$\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\cdot n$$ matrix in spiral form.
* Space Complexity: $$\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.

---
### Approach 2: Optimized spiral traversal

**Intuition**

Our main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.

**Algorithm**

- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co-ordinates in each direction.

_Example_

In left to right walk ( _direction #1_ ), $$x$$ co-ordinates remains same and $$y$$ increments ($$x = 0$$, $$y = 1$$).

In right to left walk ( _direction #3_ ), $$x$$ remains same and $$y$$ decrements ($$x = 0$$, $$y = -1$$).

Using this intuition, we pre-define an array $$dir$$ having $$x$$ and $$y$$ co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.

- The $$\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co-ordinates respectively. It updates based on the direction in which we are moving.

_How do we know when we have to change the direction?_

When we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction.

Let $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d+ 1) \% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .

> It must be noted that we use `floorMod` in Java instead of modulo $$\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\%$$ won't give desired results in such cases.  

[code](https://leetcode.com/playground/97g6k8bX/shared)

**Complexity Analysis**

* Time Complexity: $$\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\cdot n$$ matrix in spiral form.
* Space Complexity: $$\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-319">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/spiral-matrix-iii/description" target="_blank" rel="noopener noreferrer">Spiral Matrix III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You start at the cell <code>(rStart, cStart)</code> of an <code>rows x cols</code> grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.</p>

<p>You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid&#39;s boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all <code>rows * cols</code> spaces of the grid.</p>

<p>Return <em>an array of coordinates representing the positions of the grid in the order you visited them</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png" style="width: 174px; height: 99px;" />
<pre>
<strong>Input:</strong> rows = 1, cols = 4, rStart = 0, cStart = 0
<strong>Output:</strong> [[0,0],[0,1],[0,2],[0,3]]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png" style="width: 202px; height: 142px;" />
<pre>
<strong>Input:</strong> rows = 5, cols = 6, rStart = 1, cStart = 4
<strong>Output:</strong> [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= rows, cols &lt;= 100</code></li>
	<li><code>0 &lt;= rStart &lt; rows</code></li>
	<li><code>0 &lt;= cStart &lt; cols</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-simulation">Approach 1: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>Initially, we are located at the coordinates <code>rStart</code> and <code>cStart</code> and must make our first movement toward the East. Let's simulate the clockwise movement and note the distances moved with each direction to identify any patterns:</p>
<ul>
<li>Move 1 unit towards the East.</li>
<li>Move 1 unit towards the South.</li>
<li>Move 2 units towards the West.</li>
<li>Move 2 units towards the North.</li>
<li>Move 3 units towards the East.</li>
<li>Move 3 units towards the South.</li>
<li>Move 4 units towards the West.</li>
<li>Move 4 units towards the North.</li>
<li>and so on...</li>
</ul>
<p>We observe a pattern where distances are covered in pairs of directions, increasing the distance by 1 after each pair. Specifically, we move in the order of East, South, West, and North, increasing the distance after every pair.</p>
<p>To implement this, we can store the directional movements in an array: for instance, East corresponds to <code>(x+0, y+1)</code> and South to <code>(x+1, y+0)</code>. We then simulate the process by taking two directions simultaneously and increasing the step size after every pair. If the current cell lies within the matrix, we append it to the <code>traversed</code> matrix. We return <code>traversed</code> once all matrix cells have been covered.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array <code>dir</code> with all possible directional movements in the movement.</li>
<li>Initialize a matrix <code>traversed</code> to store the coordinates of cells.</li>
<li>Initialize the integers <code>step = 1</code>, <code>direction = 0</code> and iterate until all cells have been traversed:
<ul>
<li>Iterate <code>i</code> from <code>0</code> to <code>1</code>:
<ul>
<li>Iterate <code>j</code> from <code>0</code> to <code>step - 1</code>:
<ul>
<li>If <code>rStart &gt;= 0</code>, <code>rStart &lt; rows</code>, <code>cStart &gt;= 0</code>, <code>cStart &lt; cols</code>:
<ul>
<li>Append <code>{rStart,cstart}</code> to <code>traversed</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add <code>dir[direction][0]</code> to <code>rStart</code> and <code>dir[direction][1]</code> to <code>cStart</code>.</li>
</ul>
</li>
<li>Increment <code>step</code> by 1.</li>
</ul>
</li>
<li>Return <code>traversed</code>.</li>
</ol>
<p>!?!../Documents/885/slideshow.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HaUS9nMW/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(rows\)</span> be the number of rows and <span class="math inline">\(cols\)</span> be the number of columns in the matrix.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(\max(\text{rows}, \text{cols})^2)\)</span></p>
<p>We fill the <code>traversed</code> matrix with the values on the simulated path. However, we might also move out of the matrix during traversal. The total distance covered depends on <span class="math inline">\(\max(\text{rows}, \text{cols})^2\)</span>. Can you think of some cases with the worst case time complexity? An example is shown below for the 2x2 matrix:</p>
<p><img src="../Figures/885/example.png" alt="img" /></p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(\max(\text{rows}, \text{cols})^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\text{rows} \cdot \text{cols})\)</span></p>
<p>Apart from the <code>traversed</code> matrix, no additional memory is used. The <code>traversed</code> matrix stores all the cells of the matrix, so its size is <span class="math inline">\(\text{rows} \times \text{cols}\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(\text{rows} \cdot \text{cols})\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-320">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/spiral-matrix-iv/description" target="_blank" rel="noopener noreferrer">Spiral Matrix IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">linked-list</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integers <code>m</code> and <code>n</code>, which represent the dimensions of a matrix.</p>

<p>You are also given the <code>head</code> of a linked list of integers.</p>

<p>Generate an <code>m x n</code> matrix that contains the integers in the linked list presented in <strong>spiral</strong> order <strong>(clockwise)</strong>, starting from the <strong>top-left</strong> of the matrix. If there are remaining empty spaces, fill them with <code>-1</code>.</p>

<p>Return <em>the generated matrix</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" style="width: 240px; height: 150px;" />
<pre>
<strong>Input:</strong> m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
<strong>Output:</strong> [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
<strong>Explanation:</strong> The diagram above shows how the values are printed in the matrix.
Note that the remaining spaces in the matrix are filled with -1.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" style="width: 221px; height: 60px;" />
<pre>
<strong>Input:</strong> m = 1, n = 4, head = [0,1,2]
<strong>Output:</strong> [[0,1,2,-1]]
<strong>Explanation:</strong> The diagram above shows how the values are printed from left to right in the matrix.
The last space in the matrix is set to -1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li>The number of nodes in the list is in the range <code>[1, m * n]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-simulation">Approach: Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>We have two integers, <code>m</code> and <code>n</code>, representing the dimensions of a matrix. We are also given the <code>head</code> of a linked list containing the elements of the matrix in spiral order. Our task is to reconstruct the original matrix.</p>
<p>We can simulate the spiral movement by following these steps:</p>
<ul>
<li>Start by moving to the right until reaching the boundary.</li>
<li>Then move downwards until reaching the boundary.</li>
<li>Next, move to the left until reaching the boundary.</li>
<li>Finally, move upwards until reaching the boundary.</li>
<li>Repeat these steps until all elements are placed in the matrix.</li>
</ul>
<p>The movement pattern repeats in the order of right, down, left, and up. We can store these directional movements in an array. For example, moving right corresponds to <code>(x+0, y+1)</code> and moving down to <code>(x+1, y+0)</code>. We simulate the process by following each direction until we reach the matrix boundary, then switch to the next direction, continuing until all nodes in the linked list are used.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Set <code>i</code> (row index) to 0, <code>j</code> (column index) to 0, and <code>cur_d</code> (current direction) to 0.</li>
<li>Define a <code>movement</code> matrix that stores the directions for east, south, west, and north movements:
<ul>
<li><code>East: (0, 1)</code></li>
<li><code>South: (1, 0)</code></li>
<li><code>West: (0, -1)</code></li>
<li><code>North: (-1, 0)</code></li>
</ul>
</li>
<li>Initialize a 2D matrix <code>res</code> with dimensions <code>m x n</code>, filled with -1.</li>
<li>Iterate over the linked list until you reach the end (<code>head</code> is not <code>nullptr</code>):
<ul>
<li>Assign the current node's value <code>head-&gt;val</code> to the matrix at position <code>res[i][j]</code>.</li>
<li>Calculate the next position <code>newi</code> and <code>newj</code> using the current direction from the movement matrix.</li>
<li>If the next position <code>newi, newj</code> is out of the matrix bounds (less than 0 or greater than/equal to m or n), or is already filled (<code>res[newi][newj]</code> is not -1):
<ul>
<li>Then, change the direction by incrementing <code>cur_d</code> (<code>modulus 4</code> to keep within the bounds of the direction matrix).</li>
</ul>
</li>
<li>Update the current position <code>i, j</code> using the updated direction.</li>
</ul>
</li>
<li>Once the linked list is fully traversed and the matrix is filled, return the resulting matrix <code>res</code>.</li>
</ol>
<p>!?!../Documents/2326/slideshow.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/o2rpHqJ2/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(k\)</span> be the size of the linked list with the first node <code>head</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>We start by creating a matrix of size <code>n * m</code> and fill it with <code>-1</code>, which takes <span class="math inline">\(O(n \cdot m)\)</span> time. After that, we loop through the linked list once. In the worst case, the list has <code>k</code> nodes, which can go up to <code>n * m</code>. So, the overall time complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No additional space is used proportional to the list size <code>k</code>. Therefore, the space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-321">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/squares-in-a-matrix5716/1" target="_blank" rel="noopener noreferrer">Squares in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a <strong>mxn</strong> matrix, count the number of squares in the matrix. </span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:</strong> </span><span style="font-size: 18px;">m<strong> = </strong>2, n<strong> = </strong>2</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">5</span>
<span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">There are a total of 5 squares in a 2*2 matrix. Four 1*1 squares and one 2*2 square.</span></pre>
<pre><span style="font-size: 18px;"><strong><span style="font-size: 18px;">Input:</span> </strong></span><span style="font-size: 18px;">m<strong> = </strong>4, n<strong> = </strong>3</span>
<span style="font-size: 18px;"><strong>Output: </strong></span><span style="font-size: 18px;">20</span>
<span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">There are a total of 20 squares in a 4*3 matrix. </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= m,n &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-322">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/stamping-the-grid/description" target="_blank" rel="noopener noreferrer">Stamping the Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">matrix</span> <span class="topic-badge">prefix-sum</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (occupied).</p>

<p>You are then given stamps of size <code>stampHeight x stampWidth</code>. We want to fit the stamps such that they follow the given <strong>restrictions</strong> and <strong>requirements</strong>:</p>

<ol>
	<li>Cover all the <strong>empty</strong> cells.</li>
	<li>Do not cover any of the <strong>occupied</strong> cells.</li>
	<li>We can put as <strong>many</strong> stamps as we want.</li>
	<li>Stamps can <strong>overlap</strong> with each other.</li>
	<li>Stamps are not allowed to be <strong>rotated</strong>.</li>
	<li>Stamps must stay completely <strong>inside</strong> the grid.</li>
</ol>

<p>Return <code>true</code> <em>if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return</em> <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex1.png" style="width: 180px; height: 237px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
<strong>Output:</strong> true
<strong>Explanation:</strong> We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex2.png" style="width: 170px; height: 179px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
<strong>Output:</strong> false 
<strong>Explanation:</strong> There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[r].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>grid[r][c]</code> is either <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-323">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/starting-point0909/1" target="_blank" rel="noopener noreferrer">Starting Point</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are a traveler, lost in a jungle. <strong>Backtrack your steps and find the starting point. </strong></span></p>

<p><span style="font-size:18px">Currently, you are at coordinates (x,y). You are also given an array <strong>pathCoordinates [ ] </strong>where&nbsp;each element is a&nbsp;(a,b)&nbsp;pair. </span></p>

<blockquote>
<p><span style="font-size:18px">The <strong>i<sup>th</sup></strong>&nbsp;pair&nbsp;(a,b), in the array, denotes&nbsp;that in the i<sup>th</sup> move you moved your X co-ordinate by a and Y co-ordinate by b.&nbsp;<br />
if X,Y coordinates in an instant are (c,d)&nbsp;then your next move will be to&nbsp;(&nbsp;c+a,&nbsp;d+b).&nbsp;</span></p>
</blockquote>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>x = 2, y = 2, 
pathCoordinates = {{1,0},{0,1},{1,1}}
<strong>Output: </strong>{0,0}
<strong>Explaination:</strong>
{0,0} was the starting point of the traveler.
At first he changed his X co-ordinate by 1 and
Y co-ordinate by 0.
{0,0} -&gt; {1,0}
After that he changed his X co-ordinate by 0 and
Y co-ordinate by 1.
{0,0} -&gt; {1,0} -&gt; {1,1}
And finally, he changed his X co-ordinate by 1 and
Y co-ordinate by 1.
{0,0} -&gt; {1,0} -&gt; {1,1} -&gt; {2,2}
</span>

</pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input: </strong>x = 1, y = 2,
pathCoordinates = {{1,1}}
<strong>Output: </strong>{0,1}
<strong>Explaination:</strong>
The route followed by the traveller is
{0,1} -&gt; {1,2}.</span>
</pre>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read or print anything. Your task is to complete the function&nbsp;<strong>findStartingPoint()&nbsp;</strong>which takes x, y, and pathCoordinates as input parameters and returns a list containing the starting point.</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Expected Time Compelxity:&nbsp;</strong>O(n) where n = length of pathCoordinates.<br />
<strong>Expected Space Complexity:&nbsp;</strong>O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= n &lt;= 10<sup>3</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-324">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/strange-printer-ii/description" target="_blank" rel="noopener noreferrer">Strange Printer II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological-sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a strange printer with the following two special requirements:</p>

<ul>
	<li>On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.</li>
	<li>Once the printer has used a color for the above operation, <strong>the same color cannot be used again</strong>.</li>
</ul>

<p>You are given a <code>m x n</code> matrix <code>targetGrid</code>, where <code>targetGrid[row][col]</code> is the color in the position <code>(row, col)</code> of the grid.</p>

<p>Return <code>true</code><em> if it is possible to print the matrix </em><code>targetGrid</code><em>,</em><em> otherwise, return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print1.jpg" style="width: 600px; height: 175px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print2.jpg" style="width: 600px; height: 367px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to form targetGrid because it is not allowed to print the same color in different turns.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == targetGrid.length</code></li>
	<li><code>n == targetGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 60</code></li>
	<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-325">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subrectangle-queries/description" target="_blank" rel="noopener noreferrer">Subrectangle Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">design</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Implement the class <code>SubrectangleQueries</code>&nbsp;which receives a <code>rows x cols</code> rectangle as a matrix of integers in the constructor and supports two methods:</p>

<p>1.<code>&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</code></p>

<ul>
	<li>Updates all values with <code>newValue</code> in the subrectangle whose upper left coordinate is <code>(row1,col1)</code> and bottom right coordinate is <code>(row2,col2)</code>.</li>
</ul>

<p>2.<code>&nbsp;getValue(int row, int col)</code></p>

<ul>
	<li>Returns the current value of the coordinate <code>(row,col)</code> from&nbsp;the rectangle.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
<strong>Output</strong>
[null,1,null,5,5,null,10,5]
<strong>Explanation</strong>
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// The initial rectangle (4x3) looks like:
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// After this update the rectangle looks like:
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // return 5
subrectangleQueries.getValue(3, 1); // return 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// After this update the rectangle looks like:
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // return 10
subrectangleQueries.getValue(0, 2); // return 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input</strong>
[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
<strong>Output</strong>
[null,1,null,100,100,null,20]
<strong>Explanation</strong>
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // return 100
subrectangleQueries.getValue(2, 2); // return 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // return 20
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>There will be at most <code><font face="monospace">500</font></code>&nbsp;operations considering both methods:&nbsp;<code>updateSubrectangle</code> and <code>getValue</code>.</li>
	<li><code>1 &lt;= rows, cols &lt;= 100</code></li>
	<li><code>rows ==&nbsp;rectangle.length</code></li>
	<li><code>cols == rectangle[i].length</code></li>
	<li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li>
	<li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li>
	<li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li>
	<li><code>0 &lt;= row &lt; rows</code></li>
	<li><code>0 &lt;= col &lt; cols</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-326">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sudoku-solver/description" target="_blank" rel="noopener noreferrer">Sudoku Solver</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>

<ol>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
	<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>
</ol>

<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" style="height:250px; width:250px" />
<pre>
<strong>Input:</strong> board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Output:</strong> [[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Explanation:</strong>&nbsp;The input board is shown above and the only valid solution is shown below:

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" style="height:250px; width:250px" />
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 9</code></li>
	<li><code>board[i].length == 9</code></li>
	<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>
	<li>It is <strong>guaranteed</strong> that the input board has only one solution.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-327">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Sum in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> 2D integer array <code>nums</code>. Initially, your score is <code>0</code>. Perform the following operations until the matrix becomes empty:</p>

<ol>
	<li>From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.</li>
	<li>Identify the highest number amongst all those removed in step 1. Add that number to your <strong>score</strong>.</li>
</ol>

<p>Return <em>the final <strong>score</strong>.</em></p>
<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
<strong>Output:</strong> 15
<strong>Explanation:</strong> In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [[1]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> We remove 1 and add it to the answer. We return 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 300</code></li>
	<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>
	<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-328">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/summed-matrix5834/1" target="_blank" rel="noopener noreferrer">Summed Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">mathematical</span> <span class="topic-badge">matrix</span> <span class="topic-badge">number-theory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px; color: #000000;"><span style="font-family: Mulish, sans-serif; font-size: 14pt; background-color: #ffffff;">A matrix is constructed of size<strong> n*n</strong> and given an integer &lsquo;<strong>q&rsquo;.</strong> The value at every cell of the matrix is given as, <strong>M(i,j) = i+j,</strong> where &lsquo;<strong>M(i,j)</strong>' is the value of a cell, &lsquo;<strong>i</strong>&rsquo; is the row number, and &lsquo;<strong>j&rsquo;</strong> is the column number. Return the number of cells having value &lsquo;<strong>q</strong>&rsquo;.</span></span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Assume, the array is in 1-based indexing.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:</strong> </span><span style="font-size: 18px;"><strong>n = </strong>4, <strong>q = </strong>7</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">2</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Explanation:</span> </strong></span><span style="font-size: 18px;">Matrix becomes
2 3 4 5 
3 4 5 6 
4 5 6 7
5 6 7 8
</span><span style="font-size: 18px;">The count of 7 is 2.</span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input:</strong> </span><span style="font-size: 18px;"><strong>n = </strong>5, <strong>q = </strong>4</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Output:</span> </strong></span><span style="font-size: 18px;">3</span>
<span style="font-size: 18px;"><strong><span style="font-size: 18px;">Explanation:</span> </strong></span><span style="font-size: 18px;">Matrix becomes
2 3 4 5 6&nbsp;
3 4 5 6 7&nbsp;
4 5 6 7 8&nbsp;
5 6 7 8 9&nbsp;
6 7 8 9 10&nbsp;
The count of 4 is 3.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(1)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; n,q &le; 10<sup>18</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-329">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/summing-the-weird-series-12c1cec6/" target="_blank" rel="noopener noreferrer">Sum of a series</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">basicsofcombinatorics</span> <span class="topic-badge">combinatorics</span> <span class="topic-badge">math</span> <span class="topic-badge">mathematics</span> <span class="topic-badge">matrix</span> <span class="topic-badge">modulararithmetic</span> <span class="topic-badge">numbertheory</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a functionÂ <span class="mathjax-latex">\(f(n,k) = \sum_{s=0}^{s=n} \sum_{r=s}^{r=n} \sum_{t=0}^{t=s} \frac {\binom nr \binom rs \binom st t(3k^2)^{t/2} I(t)}{(s+1)}\)</span></p>

<p>whereÂ <span class="mathjax-latex">\(I(x) = \begin{cases} 1 &amp; x \equiv 0\ (mod\ 4) \\ 0 &amp; x \equiv 1\ (mod\ 4) \\ -1 &amp; x \equiv 2\ (mod\ 4) \\ 0 &amp; x \equiv 3\ (mod\ 4) \\ \end{cases} \)</span></p>

<p>andÂ <span class="mathjax-latex">\(\binom nr\)</span>Â known as Binomial CoefficientÂ denotes the number of ways to choose an unordered subset ofÂ <span class="mathjax-latex">\(r\)</span>Â elements from a fixed set ofÂ <span class="mathjax-latex">\(n\)</span>Â elements.</p>

<p>You must find the value ofÂ <span class="mathjax-latex">\(f(n,k)\)</span>Â (modulo <span class="mathjax-latex">\(10^9+21\)</span>).</p>

<p>IntegersÂ <span class="mathjax-latex">\(n\)</span>Â andÂ <span class="mathjax-latex">\(k\)</span>Â are given to you.</p>

<p><strong>Input format</strong></p>

<ul>
	<li>The first line consists of a singleÂ integerÂ <span class="mathjax-latex">\(T\)</span>Â denoting the number of test cases.</li>
	<li>Each of the next <span class="mathjax-latex">\(T\)</span>Â lines consists of two space-separated integersÂ <span class="mathjax-latex">\(n\)</span>Â andÂ <span class="mathjax-latex">\(k\)</span>Â respectively.</li>
</ul>

<p><strong>Output format</strong></p>

<p>The output should consist of <span class="mathjax-latex">\(T\)</span>Â lines each containing a single integer corresponding to the required valueÂ <span class="mathjax-latex">\(f(n,k)\)</span>.</p>

<p>Print the answer moduloÂ <span class="mathjax-latex">\(10^9+21\)</span>. If the answerÂ isÂ of the formÂ <span class="mathjax-latex">\(\frac PQ\)</span>, then printÂ <span class="mathjax-latex">\(PQ^{-1} (mod\ 10^9+21)\)</span>.</p>

<p><strong>Constraints</strong></p>

<p><span class="mathjax-latex">\(1\le T \le 10^5\\ 1\le n \le 10^{18}\\ 0\le k \le 10^{18}\)</span></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>For the first test case: f(1,2) = 0</p>

<p>For the second test case:Â f(2,1) = -2</p>

<p>For the third test case: f(3,1) = -6-6-9/2 = -33/2</p>

<p>For the fourth test case: f(5,3) = 4464</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-330">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-elements-in-a-matrix2000/1" target="_blank" rel="noopener noreferrer">Sum of elements in a matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a non null integer matrix Grid of dimensions NxM.Calculate the sum of its elements.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=2,M=3
Grid=
[[1,0,1],
[-8,9,-2]]
<strong>Output:</strong>
1
<strong>Explanation:</strong>
The sum of all elements of the matrix is 
(1+0+1-8+9-2)=1.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3,M=5
Grid=
[[1,0,1,0,1],
[0,1,0,1,0],
[-1,-1,-1,-1,-1]]
<strong>Output:</strong>
0
<strong>Explanation:</strong>
The sum of all elements of the matrix are
(1+0+1+0+1+0+1+0+1+0-1-1-1-1-1)=0.</span></pre>

<p><br />
<br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything.Your task is to complete the function <strong>sumOfMatrix()</strong> which takes two integers N ,M and a 2D array Grid as input parameters and returns the sum of all the elements of the Grid.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N*M)<br />
<strong>Expected Auxillary Space:</strong>O(1)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N,M&lt;=1000<br />
-1000&lt;=Grid[i][j]&lt;=1000</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-331">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-upper-and-lower-triangles-1587115621/1" target="_blank" rel="noopener noreferrer">Sum of upper and lower triangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a square matrix<strong>&nbsp;</strong>of size<strong> n*n</strong>, print the <strong>sum of upper and lower triangular elements</strong>. Upper Triangle consists of elements on the diagonal and above it. The lower triangle consists of elements on the diagonal and below it.&nbsp;</span><br /><br /><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>:n = 3,mat[][] = [[6, 5, 4],
&nbsp;                   [1, 2, 5],
&nbsp;                   [7, 9, 7]]
<strong>Output</strong>: [29, 32]
<strong>Explanation</strong>:The given matrix is
6 5 4
1 2 5
7 9 7</span></pre>
<pre><span style="font-size: 18px;">Upper triangular matrix:
6 5 4
&nbsp;&nbsp;2 5
&nbsp;&nbsp;&nbsp; 7
Sum of these elements is 6 + 5 + 4 + 2 + 5 + 7=29.</span></pre>
<pre><span style="font-size: 18px;">Lower triangular matrix:
6
1 2
7 9 7
Sum of these elements is 6 + 1 + 2 + 7 + 9 + 7= 32.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>:n = 2, mat[][] = [[1, 2],
&nbsp;                    [3, 4]]
<strong>Output</strong>: [7, 8]
<strong>Explanation:</strong>Upper triangular matrix:
1 2
&nbsp; 4
Sum of these elements are 7.
Lower triangular matrix:
1
3 4
Sum of these elements are 8.</span></pre>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong>&nbsp;<br />1 &lt;= n &lt;= 10<sup>3</sup><br />1 &lt;= mat[i][j] &lt;= 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-332">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sums-of-i-th-row-and-i-th-column3054/1" target="_blank" rel="noopener noreferrer">Sums of i-th row and i-th column</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a matrix A of dimensions NxM. Check whether the sum of the&nbsp;<strong>i<sup>th</sup></strong>&nbsp;row is equal to the sum of the&nbsp;<strong>i<sup>th</sup>&nbsp;</strong>column.<br />
Note: Check only up to valid&nbsp;row and column numbers i.e if the dimensions are 3x5, check only for the first 3 rows and columns, i.e. min(N, M).</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=2,M=2
A=[[1,2],[2,1]]
<strong>Output:</strong>
1
<strong>Explanation:</strong>
The sum of 1st row is equal to sum of
1st column and also sum of 2nd row is equal 
to the sum of 2nd column.So, Answer is 1.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=1,M=3
A=[[5],[0],[0]]
<strong>Output:</strong>
1
<strong>Explanation:</strong>
The sum of 1st column is equal
to the sum of 1st row.Thus,answer is 1.
(We do not check for the 2nd and 3rd rows
because there are no 2nd and 3rd columns.)</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>sumOfRowCol()</strong> which takes two integers N, M and a 2D array A as input parameters and returns 1 if all the valid sum of rows is equal to the valid sum of columns. Otherwise, returns 0.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N*M)<br />
<strong>Expected Auxillary Space:</strong>O(min(N,M))</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N,M,A[i][j]&lt;=10<sup>3</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-333">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/surface-area-of-3d-shapes/description" target="_blank" rel="noopener noreferrer">Surface Area of 3D Shapes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">geometry</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> <code>grid</code> where you have placed some <code>1 x 1 x 1</code> cubes. Each value <code>v = grid[i][j]</code> represents a tower of <code>v</code> cubes placed on top of cell <code>(i, j)</code>.</p>

<p>After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.</p>

<p>Return <em>the total surface area of the resulting shapes</em>.</p>

<p><strong>Note:</strong> The bottom face of each shape counts toward its surface area.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> grid = [[1,2],[3,4]]
<strong>Output:</strong> 34
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> 32
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> grid = [[2,2,2],[2,1,2],[2,2,2]]
<strong>Output:</strong> 46
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-334">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/surrounded-regions/description" target="_blank" rel="noopener noreferrer">Surrounded Regions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix <code>board</code> containing <strong>letters</strong> <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>:</p>

<ul>
	<li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li>
	<li><strong>Region</strong>: To form a region <strong>connect every</strong> <code>&#39;O&#39;</code> cell.</li>
	<li><strong>Surround</strong>: The region is surrounded with <code>&#39;X&#39;</code> cells if you can <strong>connect the region </strong>with <code>&#39;X&#39;</code> cells and none of the region cells are on the edge of the <code>board</code>.</li>
</ul>

<p>To capture a <strong>surrounded region</strong>, replace all <code>&#39;O&#39;</code>s with <code>&#39;X&#39;</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>

<p><strong>Explanation:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" style="width: 367px; height: 158px;" />
<p>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">board = [[&quot;X&quot;]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[[&quot;X&quot;]]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-335">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/surround-the-1s2505/1" target="_blank" rel="noopener noreferrer">Surround the 1&#39;s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix of order <strong>n</strong>x<strong>m</strong>, composed of only 0's and 1's, find the number of 1's in the matrix that are surrounded by an <strong>even number (&gt;0) of 0's</strong>. The surrounding of a cell in the matrix is defined as the <strong>elements above</strong>, <strong>below</strong>, on <strong>left</strong>, on <strong>right</strong> as well as the<strong> 4 diagonal elements</strong> around the cell of the matrix. Hence, the surrounding of any matrix elements is composed of 8 elements. Find the number of such 1's.</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>matrix = {{1, 0, 0}, <br />          {1, 1, 0}, 
          {0, 1, 0}}
<strong>Output: <br /></strong>1
<strong>Explanation: <br /></strong>1 that occurs in the 1st row and 1st column, has 3 surrounding elements 0,1 and 1. The occurrence of zero is odd. <br />1 that occurs in 2nd row and 1st column has 5 surrounding elements 1,0,1,1 and 0. The occurrence of zero is even. <br />1 that occurs in 2nd row and 2nd column has 8 surrounding elements. The occurrence of 0 is odd. <br />Similarly, for the 1 that occurs in 3rd row and 2nd column, the occurrence of zero in it's 5 surrounding elements is odd. 
Hence, the output is 1.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>matrix = {{1}}
<strong>Output: <br /></strong>0
<strong>Explanation: <br /></strong>There is only 1 element in the matrix. Hence, it has no surroundings, so it's count for even 0's is 0 for the whole matrix. <br />0 is even but we want occurrence of a zero in the surrounding at least once. 
Hence, output is 0.</span>
</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read or print anything. Your task is to complete the function&nbsp;<strong>Count()</strong> which takes the matrix as input parameter and returns the number of 1's which are surrounded by even number of 0's.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n * m)<br /><strong>Expected Space Complexity:&nbsp;</strong>O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= n, m &lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-336">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/swap-major-and-minor-diagonals-of-a-square-matrix/1" target="_blank" rel="noopener noreferrer">Swap  diagonals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="69" data-end="197"><span style="font-size: 14pt;">Given a square matrix <strong>mat[][]</strong>, the task is to <strong data-start="142" data-end="196">swap the elements </strong>of the<strong data-start="142" data-end="196"> major and minor diagonals</strong>.</span></p>
<p dir="ltr" style="box-sizing: border-box; margin: 0px 0px 10px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="font-size: 14pt;"> </span></p>
<ul data-start="199" data-end="521">
<li data-start="199" data-end="357"><span style="font-size: 14pt;"> </span>
<p data-start="201" data-end="357"><span style="font-size: 14pt;"><strong data-start="201" data-end="219">Major Diagonal</strong>: Elements that lie from the <strong data-start="248" data-end="260">top-left</strong> corner to the <strong data-start="275" data-end="291">bottom-right</strong> corner of the matrix (i.e., where row index equals column index).</span></p>
<span style="font-size: 14pt;"> </span></li>
<li data-start="358" data-end="521"><span style="font-size: 14pt;"> </span>
<p data-start="360" data-end="521"><span style="font-size: 14pt;"><strong data-start="360" data-end="378">Minor Diagonal</strong>: Elements that lie from the <strong data-start="407" data-end="420">top-right</strong> corner to the <strong data-start="435" data-end="450">bottom-left</strong> corner (i.e., where the sum of row and column indices equals n - 1).</span></p>
</li>
</ul>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[0, 1, 2],<br />                [3, 4, 5],<br />                [6, 7, 8]]<strong><br /></strong><strong>Output: </strong>[[2, 1, 0],<br />        [3, 4, 5],<br />        [8, 7, 6]]<strong><br /></strong><strong>Explanation: </strong>Major Diagonal = [0, 4, 8], Minor Diagonal = [2, 4, 6]. We are required to swap the diagonal elements of same row, thus after doing so, major diagonal will become minor and vice-versa.<strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> </strong></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[2, 3],<br />                [5, 4]]<strong><br /></strong><strong>Output: </strong>[[3, 2],<br /><strong>        </strong> [4, 5]] <strong><br /></strong><strong>Explanation: </strong>Major Diagonal = [2, 4], Minor Diagonal = [3, 5]. We are required to swap the diagonal elements of same row, thus after doing so, major diagonal will become minor and vice-versa.<strong style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> </strong></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong><span class="base"><span class="mrel">1 &le; mat.size() </span></span><span class="base"><span class="mrel">&le; 500<br /><span class="base"><span class="mrel">1&nbsp;&le; mat[i][j] </span></span><span class="base"><span class="mrel">&le; 10<sup>6</sup></span></span></span></span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-337">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/swapping-triangles5209/1" target="_blank" rel="noopener noreferrer">Swapping Triangles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given an integer N and a matrix A of dimensions NxN.Swap the values of the triangle above the primary&nbsp;diagonal with the values of the triangle below the primary diagonal.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=3
A=[[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong>
1 4 7
2 5 8
3 6 9
<strong>Explanation:</strong>
Swapping the upper triangle with the
 lower triangle gives this result.</span></pre>

<p><span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
N=4
A=[[2,7,3,1],[10,1,5,1],[10,4,7,6],[6,9,1,8]]
<strong>Output:</strong>
2 10 10 6 
7 1 4 9 
3 5 7 1 
1 1 6 8
<strong>Explanation:</strong>
Swapping upper triangle with the
lower triangle leads to this result.</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Your task is to complete the function <strong>swapTriangle()</strong> which takes the integer N and matrix A as input parameters and returns a matrix with the upper and lower triangles swapped.</span></p>

<p><br />
<span style="font-size:18px"><strong>Expected Time Complexity:</strong>O(N<sup>2</sup>)<br />
<strong>Expected Auxillary Space:</strong>O(1)</span><br />
&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints:</strong><br />
1&lt;=N,A[i][j]&lt;=1000, for 0&lt;=i &nbsp;</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-338">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swim-in-rising-water/description" target="_blank" rel="noopener noreferrer">Swim in Rising Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">union-find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>

<p>It starts raining, and water gradually rises over time. At time <code>t</code>, the water level is <code>t</code>, meaning <strong>any</strong> cell with elevation less than equal to <code>t</code> is submerged or reachable.</p>

<p>You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>

<p>Return <em>the minimum time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,2],[1,3]]
<strong>Output:</strong> 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg" style="width: 404px; height: 405px;" />
<pre>
<strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 50</code></li>
	<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>
	<li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-339">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-k-weakest-rows-in-a-matrix/description" target="_blank" rel="noopener noreferrer">The K Weakest Rows in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>mat</code> of <code>1</code>&#39;s (representing soldiers) and <code>0</code>&#39;s (representing civilians). The soldiers are positioned <strong>in front</strong> of the civilians. That is, all the <code>1</code>&#39;s will appear to the <strong>left</strong> of all the <code>0</code>&#39;s in each row.</p>

<p>A row <code>i</code> is <strong>weaker</strong> than a row <code>j</code> if one of the following is true:</p>

<ul>
	<li>The number of soldiers in row <code>i</code> is less than the number of soldiers in row <code>j</code>.</li>
	<li>Both rows have the same number of soldiers and <code>i &lt; j</code>.</li>
</ul>

<p>Return <em>the indices of the </em><code>k</code><em> <strong>weakest</strong> rows in the matrix ordered from weakest to strongest</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
<strong>Output:</strong> [2,0,3]
<strong>Explanation:</strong> 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
<strong>Output:</strong> [0,2]
<strong>Explanation:</strong> 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == mat.length</code></li>
	<li><code>n == mat[i].length</code></li>
	<li><code>2 &lt;= n, m &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= m</code></li>
	<li><code>matrix[i][j]</code> is either 0 or 1.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-340">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/the-palindrome-pattern3900/1" target="_blank" rel="noopener noreferrer">The Palindrome Pattern</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">functions</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;">Given a two-dimensional integer array <strong>arr</strong> of dimensions <strong>n x n</strong>, consisting solely of zeros and ones, identify the row or column (using 0-based indexing) where all elements form a palindrome. If multiple palindromes are identified, prioritize the palindromes found in rows over those in columns. Within rows or columns, the palindrome with the smaller index takes precedence. The result should be represented by the index followed by either <strong>'R'</strong> or <strong>'C'</strong>, indicating whether the palindrome was located in a row or column. The output should be space-separated. If no palindrome is found, return the string <strong>-1</strong>.</span></span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: <br /></span><span style="font-size: 18px;">arr[][] =  [[1, 0, 0], <br /></span><span style="font-size: 18px;">           [0, 1, 0],<br />           [1, 1, 0]]
<strong>Output:</strong>&nbsp;1 R
<strong>Explanation</strong>: In the first test case, 0-1-0 is a palindrome 
occuring in a row having index 1.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: <br /></strong>arr[][] =   [[1, 0],<br />           [1, 0]]</span><br /><span style="font-size: 18px;"><strong>Output: </strong>0 C</span><br /><span style="font-size: 18px;"><strong>Explanation</strong>: 1-1 occurs before 0-0 in the 0th column. And there is no palindrome in the two rows.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints: <br /></strong></span><span style="font-size: 18px;">1&lt;= arr.size &lt;= 50<br /></span><span style="font-size: 18px;">0 &lt;= arr[i][j] &lt;= 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-341">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/toeplitz-matrix/1" target="_blank" rel="noopener noreferrer">Toeplitz matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">A Toeplitz (or diagonal-constant) matrix is a matrix in which each descending diagonal from left to right is constant, i.e., all elements in a diagonal are the same. Given a rectangular matrix <strong>mat,</strong>&nbsp;your task is to complete the function <strong>isToeplitz</strong> which returns <strong>true</strong> if the matrix is Toeplitz otherwise, it returns <strong>false</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span><span style="font-size: 18px;"><br />mat = [[6, 7, 8],<br />       [4, 6, 7],<br />       [1, 4, 6]]<br /></span><span style="font-size: 18px;"><strong>Output: </strong>true</span><br /><span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">The test case represents a 3x3 matrix</span>
<span style="font-size: 18px;"> 6 7 8 </span>
<span style="font-size: 18px;"> 4 6 7 </span>
<span style="font-size: 18px;"> 1 4 6</span>
<span style="font-size: 18px;">Output will be<strong> </strong>true, as values in all downward diagonals from left to right contain the same elements.</span></pre>
<pre><strong><span style="font-size: 18px;">Input: <br /></span></strong><span style="font-size: 18px;">mat = [[1,2,3],<br />       [4,5,6]]<br /></span><strong><span style="font-size: 18px;">Output: </span></strong><span style="font-size: 18px;">false<br /></span><span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">Matrix of order 2x3 will be 1 2 3 4 5 6 Output: false as values in all diagonals are not the same.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong> <br /></span><span style="font-size: 18px;">1&lt;=mat.size,mat[0].size&lt;=40 <br /></span><span style="font-size: 18px;">0&lt;=mat[i][j]&lt;=100</span></p>
<p><span style="font-size: 18px;"><strong>Expected time complexity: </strong>O(n*m</span><span style="font-size: 18px;">)<br /></span><span style="font-size: 18px;"><strong>Expected space complexity: </strong>O(1)</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-342">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/toeplitz-matrix/description" target="_blank" rel="noopener noreferrer">Toeplitz Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return&nbsp;<em><code>true</code>&nbsp;if the matrix is Toeplitz. Otherwise, return <code>false</code>.</em></p>

<p>A matrix is <strong>Toeplitz</strong> if every diagonal from top-left to bottom-right has the same elements.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong>
In the above grid, the&nbsp;diagonals are:
&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.
In each diagonal all elements are the same, so the answer is True.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2],[2,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong>
The diagonal &quot;[1, 2]&quot; has different elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>What if the <code>matrix</code> is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?</li>
	<li>What if the <code>matrix</code> is so large that you can only load up a partial row into the memory at once?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-343">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/trace-path3840/1" target="_blank" rel="noopener noreferrer">Trace Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There is a rectangular path for a Train to travel consisting of <strong>n&nbsp;</strong>rows and <strong>m</strong>&nbsp;columns. The train will start from one of the grid's cells and it will be given a command in the form of string <strong>s</strong>&nbsp;consisting of characters <strong>L</strong>, <strong>R</strong>,<strong> D</strong>, <strong>U</strong>. Find if it is possible to travel the train inside the grid only.<br /><strong>Note: <br /></strong>If the train is at position (i,j) <br />on taking 'L' it goes to (i,j-1),<br />on taking 'R' it goes to (i,j+1),<br />on taking 'D' it goes to (i-1,j),<br />on taking 'U' it goes to (i+1,j).<br />You just need to tell if it's possible or not, you don't have to tell number of ways in which it is possible.</span></p>
<p><strong><span style="font-size: 18px;">Example 1:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
n = 1, m = 1
s = "R"
<strong>Output:</strong> 0
<strong>Explaination:</strong> There is only one cell(1,1). So train can only start from (1,1). On taking right(R) train moves to (1,2), which is out of grid.<br />Therefore there is no cell from where train can start and remain inside the grid after tracing the route. </span></pre>
<p><strong><span style="font-size: 18px;">Example 2:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong> 
n = 2, m = 3
s = "LLRU"
<strong>Output:</strong> 1
<strong>Explaination:</strong> One possible cell is (1,3)<br />(1,3) --&gt; (1,2) --&gt; (1,1) --&gt; (1,2) --&gt; (2,2). Thus there is a cell from where if train starts, it remains inside the grid throughout tracing the route.</span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You do not need to read input or print anything. Your task is to complete the function <strong>isPossible()</strong> which takes n, m and s as input parameters and <strong>returns 1</strong> if there is such a cell for which the train always remains inside the grid. Otherwise <strong>returns</strong> <strong>0</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(|s|)<br /><strong>Expected Auxiliary Space:</strong> O(1)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 10<sup>4</sup><br />1 &le; |s| &le; 10<sup>4</sup>&nbsp; &nbsp;</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-344">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/transform-to-chessboard/description" target="_blank" rel="noopener noreferrer">Transform to Chessboard</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>n x n</code> binary grid <code>board</code>. In each move, you can swap any two rows with each other, or any two columns with each other.</p>

<p>Return <em>the minimum number of moves to transform the board into a <strong>chessboard board</strong></em>. If the task is impossible, return <code>-1</code>.</p>

<p>A <strong>chessboard board</strong> is a board where no <code>0</code>&#39;s and no <code>1</code>&#39;s are 4-directionally adjacent.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg" style="width: 500px; height: 145px;" />
<pre>
<strong>Input:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One potential sequence of moves is shown.
The first move swaps the first and second column.
The second move swaps the second and third row.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[0,1],[1,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Also note that the board with 0 in the top left corner, is also a valid chessboard.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> board = [[1,0],[1,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> No matter what sequence of moves you make, you cannot end with a valid chessboard.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 30</code></li>
	<li><code>board[i][j]</code> is either&nbsp;<code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-345">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/transpose-matrix/description" target="_blank" rel="noopener noreferrer">Transpose Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a 2D integer array <code>matrix</code>, return <em>the <strong>transpose</strong> of</em> <code>matrix</code>.</p>

<p>The <strong>transpose</strong> of a matrix is the matrix flipped over its main diagonal, switching the matrix&#39;s row and column indices.</p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png" style="width: 600px; height: 197px;" /></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [[1,4,7],[2,5,8],[3,6,9]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1,2,3],[4,5,6]]
<strong>Output:</strong> [[1,4],[2,5],[3,6]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-copy-directly">Approach 1: Copy Directly</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>The transpose of a matrix <code>A</code> with dimensions <code>R x C</code> is a matrix <code>ans</code> with dimensions <code>C x R</code> for which <code>ans[c][r] = A[r][c]</code>.</p>
<p>Let's initialize a new matrix <code>ans</code> representing the answer.  Then, we'll copy each entry of the matrix as appropriate.</p>
<p><a href="https://leetcode.com/playground/caa5uZ7X/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(R * C)\)</span>, where <span class="math inline">\(R\)</span> and <span class="math inline">\(C\)</span> are the number of rows and columns in the given matrix <code>A</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(R * C)\)</span>, the space used by the answer.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-346">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/transpose-of-matrix-1587115621/1" target="_blank" rel="noopener noreferrer">Transpose of Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="161" data-end="269"><span style="font-size: 14pt;">You are given a square matrix of size <strong data-start="199" data-end="208">n x n</strong>. Your task is to find the<strong data-start="226" data-end="248"> transpose</strong> of the given matrix.</span><br /><span style="font-size: 14pt;">The <strong data-start="275" data-end="288">transpose</strong> of a matrix is obtained by converting all the rows to columns and all the columns to rows.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] = [[1, 1, 1, 1],<br />                [2, 2, 2, 2],<br />                [3, 3, 3, 3],<br />                [4, 4, 4, 4]]
<strong>Output</strong>: [[1, 2, 3, 4],<br />       [1, 2, 3, 4],<br />       [1, 2, 3, 4],<br />       [1, 2, 3, 4]]</span>
<strong><span style="font-size: 14pt;">Explanation: </span></strong><span style="font-size: 14pt;">Converting rows into columns and columns into rows.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: mat[][] =  [[1, 2],<br />                 [9, -2]]
<strong>Output</strong>: [[1, 9],<br />        [2, -2]]<br /><strong>Explanation: </strong>C</span><span style="font-size: 14pt;">onverting rows into columns and columns into rows.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n &le; 10<sup>3</sup><br />-10<sup>9</sup> &le; mat[i][j] &le;10<sup>9</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-347">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trapping-rain-water-ii/description" target="_blank" rel="noopener noreferrer">Trapping Rain Water II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first-search</span> <span class="topic-badge">heap-priority-queue</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return <em>the volume of water it can trap after raining</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg" style="width: 361px; height: 321px;" />
<pre>
<strong>Input:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg" style="width: 401px; height: 321px;" />
<pre>
<strong>Input:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
<strong>Output:</strong> 10
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == heightMap.length</code></li>
	<li><code>n == heightMap[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a grid, <code>heightMap</code>, where each element represents the height of the corresponding cell in the 3D representation of the map. Our task is to calculate the total amount of water trapped on the map after it rains.</p>
<p>We can assume that it rains an infinite amount of water, but the water stays inside any area of the map only if there is a boundary that traps it. Specifically, the water remains on top of a cell as long as its combined height (the height of the cell plus the water above it) is less than or equal to the height of all its neighbors. If any neighbor is lower, the water will flow out to that lower cell.</p>
<hr />
<h3 id="approach-bfs--priority-queue">Approach: BFS + Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>Building on the earlier observation, the total height of any cell (its original height plus any trapped water) must not exceed the smallest total height of its neighbors. Specifically, it cannot exceed the smallest total height of its neighboring cells. This constraint propagates outward from the gridâ€™s edges, which act as the ultimate boundary since no water can be trapped beyond them.</p>
<p>In simpler terms, the cells around a region of the grid act as a boundary, and the smallest height of this boundary determines how much water can be stored in that region. To solve the problem, we begin by treating the edges of the grid as the initial boundary since water cannot spill beyond them. From there, we move inward, processing cells in a manner that respects the relationship between a cellâ€™s height and the boundary:</p>
<ol>
<li>
<p><strong>Trapping Water</strong>: When we process a cell, if its height is lower than the current boundary height, water can be trapped above it. The amount of water trapped is equal to the difference between the boundary height and the cellâ€™s height. We then add this trapped water to our running total. To ensure the boundary remains valid, the cell is added to the boundary with its effective height adjusted to match the current boundary height. This adjustment prevents water from &quot;spilling&quot; through this cell and invalidating the boundary.</p>
</li>
<li>
<p><strong>Updating the Boundary</strong>: If the cell's height is greater than or equal to the boundary height, no water can be trapped above it. However, the cell still becomes part of the boundary because it might help trap water in adjacent, higher regions as we continue processing.</p>
</li>
</ol>
<p>To efficiently manage the boundary and dynamically update the smallest height, we use a min-heap (priority queue). The heap lets us quickly find the lowest boundary height and ensure the traversal always processes the most constrained regions first.</p>
<blockquote>
<p>For a more comprehensive understanding of heaps and priority queues, check out the <a href="https://leetcode.com/explore/learn/card/heap/">Heap Explore Card ðŸ”—</a>. This resource provides an in-depth look at heap-based algorithms, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>!?!../Documents/407/407_approach1_fix.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Define a struct <code>Cell</code> that stores the height and the coordinates of a cell in the map.</li>
<li>Define two direction arrays, that will help us explore the neighbors of each cell: <code>dRow = [0, 0, -1, 1], dCol = [-1, 1, 0, 0]</code>.</li>
<li>Initialize <code>numOfRows</code> and <code>numOfCols</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create a <code>numOfRows x numOfCols</code> boolean grid, called <code>visited</code>, with all its values initialized to <code>false</code>.</li>
<li>Initialize a priority queue (min-heap) of <code>Cells</code>, called <code>boundary</code>.</li>
<li>Push the cells of the first and last row and column of the grid into the <code>boundary</code> and mark them as visited.</li>
<li>Initialize <code>totalWaterVolume</code> to <code>0</code>.</li>
<li>While the <code>boundary</code> is not empty:
<ul>
<li>Pop the top cell out of the <code>boundary</code>, as <code>[minBoundaryHeight, [currentRow, currentCol]]</code> - this is the cell with the minimum height in the unexplored part of the boundary.</li>
<li>Update <code>minBoundaryHeight</code> to <code>height</code>.</li>
<li>Loop through all neighbors of the current cell, with <code>direction</code> from <code>0</code> to <code>3</code>:
<ul>
<li>Initialize <code>neighborRow</code> to <code>currentRow + dRow[direction]</code> and <code>neighborCol</code> to <code>currentCol + dCol[direction]</code>.</li>
<li>If the cell <code>(neighborRow, neighborCol)</code> is valid, i.e. it is not out of the bounds of the grid and not visited:
<ul>
<li>If the height of the cell, <code>neighborHeight</code> is lower than <code>minBoundaryHeight</code>, add the difference <code>minBoundaryHeight - neighborHeight</code> to the <code>totalWaterVolume</code>.</li>
<li>Push the neighboring cell into the <code>boundary</code> with its height set to the maximum of its value and <code>minBoundayHeight</code>, as the lowest height of the boundary cannot fall below its current value.</li>
<li>Mark the neighboring cell as visited.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>totalWaterVolume</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/dt4uER9y/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the number of rows and <span class="math inline">\(n\)</span> the number of columns of the input grid.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \cdot n \times \log{m \cdot n})\)</span></p>
<p>Each cell is pushed in the <code>boundary</code> exactly once, so the while loops runs <span class="math inline">\(O(mn)\)</span> times. On each iteration, an element is popped from the priority queue and four other elements (the neighboring cells) are potentially pushed into it. Since the push and pop operations of the priority queue have a time complexity of <span class="math inline">\(O(k)\)</span>, where <span class="math inline">\(k\)</span> represents the size of the priority queue, the overall time complexity of the algorithm becomes <span class="math inline">\(O(m \cdot n \times \log{m \cdot n})\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>We create a <code>visited</code> grid of size <span class="math inline">\(m \times n\)</span> to keep track of the cells already explored. The priority queue, <code>boundary</code> can also grow up to <span class="math inline">\(O(m \times n)\)</span> in size, so the algorithm requires <span class="math inline">\(O(m \times n)\)</span> extra space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-348">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/travelling-salesman-problem2732/1" target="_blank" rel="noopener noreferrer">Travelling Salesman Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">arrays</span> <span class="topic-badge">bitmagic</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a matrix cost of size n where cost[i][j] denotes the cost of moving from city i to city j. Your task is to complete a tour from city 0 (0-based index) to all other cities such that you visit each city exactly once and then at the end come back to city 0 at minimum cost.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>cost = [[0, 111], [112, 0]]
<strong>Output: </strong>223
<strong>Explanation: </strong>We can visit 0-&gt;1-&gt;0 and cost = 111 + 112.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>cost = [[0, 1000, 5000], [5000, 0, 1000], [1000, 5000, 0]]
<strong>Output: </strong>3000
<strong>Explanation: </strong>We can visit 0-&gt;1-&gt;2-&gt;0 and cost = 1000+1000+1000 = 3000</span>
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= cost.size() &lt;= 20<br />1 &lt;= cost[i][j] &lt;= 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-349">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/turtles-path-4/" target="_blank" rel="noopener noreferrer">Turtle&#39;s Path</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">depthfirstsearch</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span> <span class="topic-badge">medium</span> <span class="topic-badge">twodimensional</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>To be good at problem solving, Monk thinks that Graphs are a topic one can definitely not skip. They have a variety of applications in Networks, flows , Routing and so on. </p>
<p>He has prepared some really interesting problems based on the same for talented programmers like you. He really adores his friends, and has chosen one of this close friends Mona as the main character for this task. So, this is how it goes :    </p>
<p>You've got a table of size <strong>N*M</strong> containing positive integers. We'll consider the table rows numbered from top to bottom <strong>1</strong> through <strong>N</strong>, and the columns numbered from left to right <strong>1</strong> through <strong>M</strong>. Then we'll denote the cell in row <strong>x</strong> and column <strong>y</strong> as <strong>(x,â€‰y)</strong>.</p>
<p>Initially cell <strong>(1,â€‰1)</strong> contains one turtle named Mona. Mona wants to get to cell <strong>(N,â€‰M)</strong>. Some cells of the table have obstacles. A cell is considered to be containing an <strong>obstacle</strong> if value of the cell is a <strong>NON-PRIME NUMBER</strong>. That means that Mona can only move through PRIME Numbers. It is guaranteed that upper left corner <strong>(1,1)</strong> contains a prime number.</p>
<p>Mona can go from cell <strong>(x,â€‰y)</strong> to one of three cells <strong>(xâ€‰+â€‰1,â€‰y )</strong>, <strong>( x ,â€‰yâ€‰+â€‰1 )</strong> and <strong>( x + 1, y + 1 )</strong> only if the required cell doesn't contain an obstacle. Help him find the number of ways in which it can go from cell (1,â€‰1) to cell (N,â€‰M).  </p>
<p>In addition, you need to print the lexicographical largest path to reach cell (N,M).  </p>
<p><strong>Note:</strong> A cell (<span class="mathjax-latex">\(x_1, y_1\)</span>) is lexicographical larger than another cell (<span class="mathjax-latex">\(x_2, y_2\)</span>) if either <span class="mathjax-latex">\(x_1 \gt x_2\)</span> or if <span class="mathjax-latex">\(x_1 = x_2\)</span> and <span class="mathjax-latex">\(y_1 &gt; y_2\)</span>. A path <em>X</em> is lexicographical larger than another path <em>Y</em>, if the first cell that does not match is  lexicographical larger in <em>X</em> than in <em>Y</em>. For example, cell <span class="mathjax-latex">\((3, 2)\)</span> is lexicographical larger than cell <span class="mathjax-latex">\((3, 1)\)</span>. <br />
Let, Path Y: <span class="mathjax-latex">\((1,1) (2,1) (3,1) (3,2) (3,3)\)</span><br />
Path X: <span class="mathjax-latex">\((1,1) (2,1) (3,2) (3,3)\)</span><br />
Path X is lexicographical larger than another path Y, because the first cell that does not match (i.e. (<span class="mathjax-latex">\(3, 2\)</span>) in X and (<span class="mathjax-latex">\(3, 1\)</span>) in Y) is  lexicographical larger in X than in Y.</p>
<p><strong>Input Format</strong></p>
<p>The first line contains two space separated integers, <strong>N</strong> (number of rows) and <strong>M</strong> (number of columns).</p>
<p>Then N lines follow, each containing <strong>M</strong> space separated integers.<br /></p>
<p><strong>Constraints</strong></p>
<p>1 &lt;= N,M &lt;= 10<sup>3</sup><br />
2 &lt;= A[x][y] &lt;= 10<sup>5</sup>  (the elements of the matrix)</p>
<p><strong>Output Format</strong></p>
<p>In the first line, print the total number of possible ways to reach <strong>(N,M)</strong> from <strong>(1,1)</strong>. Since this number may be too large, print the answer modulo <strong>10<sup>9</sup>  +7</strong>.<br /></p>
<p>Print the cell indexes (space separated) of each step of his lexicographically largest path in a new line .<br />
If no path exists, only print <strong>0</strong> in first line.<br /></p>
<p>(See sample test case for clarification)<br /></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>There are four ways to reach (3,3) from (1,1).<br /></p>
<p>Path 1. (1,1) (1,2) (1,3) (2,3) (3,3)<br />
Path 2. (1,1) (1,2) (2,3) (3,3)<br />
Path 3. (1,1) (2,1) (3,1) (3,2) (3,3)<br />
Path 4. (1,1) (2,1) (3,2) (3,3)<br /></p>
<p>Lexicographical Order -&gt; 4 &gt; 3 &gt; 2 &gt; 1</p></div>
				</div>
			
		</div>

<div class="question-card" id="question-350">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-paths-ii/description" target="_blank" rel="noopener noreferrer">Unique Paths II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">dynamic-programming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>

<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>

<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>

<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right -&gt; Right
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == obstacleGrid.length</code></li>
	<li><code>n == obstacleGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-351">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/unique-paths-iii/description" target="_blank" rel="noopener noreferrer">Unique Paths III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">bit-manipulation</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer array <code>grid</code> where <code>grid[i][j]</code> could be:</p>

<ul>
	<li><code>1</code> representing the starting square. There is exactly one starting square.</li>
	<li><code>2</code> representing the ending square. There is exactly one ending square.</li>
	<li><code>0</code> representing empty squares we can walk over.</li>
	<li><code>-1</code> representing obstacles that we cannot walk over.</li>
</ul>

<p>Return <em>the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique1.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique2.jpg" style="width: 324px; height: 245px;" />
<pre>
<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg" style="width: 164px; height: 165px;" />
<pre>
<strong>Input:</strong> grid = [[0,1],[2,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 20</code></li>
	<li><code>1 &lt;= m * n &lt;= 20</code></li>
	<li><code>-1 &lt;= grid[i][j] &lt;= 2</code></li>
	<li>There is exactly one starting cell and one ending cell.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-352">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/unique-paths-in-a-grid--170647/1" target="_blank" rel="noopener noreferrer">Unique Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a 2d list <strong>grid[][]</strong> of size n x m consisting of values <strong>0</strong> and <strong>1</strong>.<br />A value of <strong>0</strong> means that you can enter that cell and <strong>1</strong> implies that entry to that cell is not allowed. <br />You start at the upper-left corner of the grid <strong>(1, 1)</strong> and you have to reach the bottom-right corner <strong>(n, m)</strong> such that you can only move in the<strong> right</strong> or <strong>down</strong> direction from every cell. <br /></span><span style="font-size: 14pt;"><span style="font-size: 14pt;">Your task is to calculate the total number of <strong>ways</strong> of reaching the target.<br /></span></span></p>
<p><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Note:</strong><span style="font-size: 14pt;"> The </span><strong style="font-size: 14pt;">first (1, 1)</strong><span style="font-size: 14pt;"> and </span><strong style="font-size: 14pt;">last (n, m) </strong><span style="font-size: 14pt;">cell of the grid can also be </span><strong style="font-size: 14pt;">1</strong><span style="font-size: 14pt;">.</span><br /><span style="font-size: 18.6667px;">It is guaranteed that the total number of ways<strong> </strong>will fit within a <strong>32-bit</strong> integer.<br /><br /></span></span><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 3, m = 3,
grid[][] = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
<strong>Output: </strong>2
<strong>Explanation: </strong>There are two ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down</span><br /><span style="font-size: 14pt;">2. Down -&gt; Down -&gt; Right -&gt; Right</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>n = 1, m = 3,
grid[][] = [[1, 0, 1]]
<strong>Output: </strong>0
<strong>Explanation: </strong>There is no possible path to reach the end.
</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; n*m &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-353">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/unique-rows-in-boolean-matrix/1" target="_blank" rel="noopener noreferrer">Unique rows in boolean matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">advanceddatastructure</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">matrix</span> <span class="topic-badge">set</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a binary matrix your task is to find all unique rows of the given matrix in the order of their appearance in the matrix. </span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>row = 3, col = 4 
M[][] = {{1 1 0 1},{1 0 0 1},{1 1 0 1}}
<strong>Output: </strong>$1 1 0 1 $1 0 0 1 $<strong>
Explanation: </strong>Above the matrix of size 3x4
looks like
1 1 0 1
1 0 0 1
1 1 0 1
The two unique rows are R<sub>1</sub>: {1 1 0 1} and R<sub>2</sub>: {1 0 0 1}. <br />As R<sub>1 </sub>first appeared at row-0 and R<sub>2</sub> appeared at row-1, in the resulting list, R<sub>1</sub> is kept before R<sub>2</sub>.</span></pre>
<p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: medium; white-space: normal;"><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><strong>Input:
</strong>row = 2, col = 4 
M[][] = {{0 0 0 1}, {0 0 0 1}}
<strong>Output: $</strong>0 0 0 1 $<strong>
Explanation: </strong>Above the matrix of size 2x4
looks like
0 0 0 1
0 0 0 1
Only unique row is $0 0 0 1 $</pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You only need to implement the given function&nbsp;<strong>uniqueRow()</strong>.&nbsp;The function takes three arguments the first argument is a matrix <strong>M</strong> and the next two arguments are <strong>row</strong>&nbsp;and <strong>col</strong>&nbsp;denoting the rows and columns&nbsp;of the matrix.&nbsp;The function should <strong>return</strong> the list of the unique row of the matrix. Do not read input, instead use the arguments given in the function.</span></p>
<p><span style="font-size: 18px;"><strong>Note:&nbsp;</strong>The driver code prints the rows "$" separated. You have to just return list of rows, you do not have to worry about printing anything.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong>&nbsp;O(row * col)<br /><strong>Expected Auxiliary Space:</strong>&nbsp;O(row * col)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1&lt;=row,col&lt;=40<br />0&lt;=M[][]&lt;=1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-354">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-sudoku/description" target="_blank" rel="noopener noreferrer">Valid Sudoku</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash-table</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>

<ol>
	<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>
	<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>
	<li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>
</ol>

<p><strong>Note:</strong></p>

<ul>
	<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
	<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" style="height:250px; width:250px" />
<pre>
<strong>Input:</strong> board = 
[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]
,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]
,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]
,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]
,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> board = 
[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]
,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]
,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]
,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]
,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
<strong>Output:</strong> false
<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 9</code></li>
	<li><code>board[i].length == 9</code></li>
	<li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-355">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-tic-tac-toe-state/description" target="_blank" rel="noopener noreferrer">Valid Tic-Tac-Toe State</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a Tic-Tac-Toe board as a string array <code>board</code>, return <code>true</code> if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.</p>

<p>The board is a <code>3 x 3</code> array that consists of characters <code>&#39; &#39;</code>, <code>&#39;X&#39;</code>, and <code>&#39;O&#39;</code>. The <code>&#39; &#39;</code> character represents an empty square.</p>

<p>Here are the rules of Tic-Tac-Toe:</p>

<ul>
	<li>Players take turns placing characters into empty squares <code>&#39; &#39;</code>.</li>
	<li>The first player always places <code>&#39;X&#39;</code> characters, while the second player always places <code>&#39;O&#39;</code> characters.</li>
	<li><code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> characters are always placed into empty squares, never filled ones.</li>
	<li>The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.</li>
	<li>The game also ends if all squares are non-empty.</li>
	<li>No more moves can be played if the game is over.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> board = [&quot;O  &quot;,&quot;   &quot;,&quot;   &quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> The first player always plays &quot;X&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> board = [&quot;XOX&quot;,&quot; X &quot;,&quot;   &quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> Players take turns making moves.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> board = [&quot;XOX&quot;,&quot;O O&quot;,&quot;XOX&quot;]
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>board.length == 3</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>board[i][j]</code> is either <code>&#39;X&#39;</code>, <code>&#39;O&#39;</code>, or <code>&#39; &#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-356">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/champagne-overflow2636/1" target="_blank" rel="noopener noreferrer">Water Overflow</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">dynamicprogramming</span> <span class="topic-badge">matrix</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">There is a stack of water glasses in the form of a Pascal triangle and a person wants to pour the water at the topmost glass, but the capacity of each glass is 1 unit. Overflow takes place in such a way that after 1 unit, 1/2 of the remaining unit gets into the bottom left glass and the other half in the bottom right glass. Now John pours <strong>K</strong> units of water in the topmost glass and wants to know how much water is there in the <strong>C</strong>th glass of the <strong>R</strong>th row.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong> Assume that there are enough glasses in the triangle till no glass overflows.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>K = </strong>3</span><strong>, </strong><span style="font-size: 18px;"><strong>R = </strong>2</span><strong>, </strong><span style="font-size: 18px;"><strong>C = </strong>1</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">1.000000</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">After the first glass, 2 units of water
will remain and they will spread equally
on the two glasses on the second row.
Therefore, the glass on the 2nd row and
1st column will have 1 unit of water.</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong></span>
<span style="font-size: 18px;"><strong>K = </strong>3</span><strong>, </strong><span style="font-size: 18px;"><strong>R = </strong>2</span><strong>, </strong><span style="font-size: 18px;"><strong>C = </strong>2</span>
<span style="font-size: 18px;"><strong>Output:</strong></span>
<span style="font-size: 18px;">1.000000</span>
<span style="font-size: 18px;"><strong>Explanation:</strong></span>
<span style="font-size: 18px;">After the first glass, 2 units of water
will remain and they will spread equally
on the two glasses on the second row.
Therefore, the glass on the 2nd row and
2nd column will have 1 unit of water.</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br />You don't need to read input or print anything. Your task is to complete the function <strong>waterOverflow()</strong> which takes 3 Integers K, R, and C as input and returns the amount of water(<strong>6 digits of precision</strong>) in the Cth glass of Rth row.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(K<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(K<sup>2</sup>)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &lt;= K &lt;= 500<br />1 &lt;= R,C &lt;= K</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-357">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/where-will-the-ball-fall/description" target="_blank" rel="noopener noreferrer">Where Will the Ball Fall</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have a 2-D <code>grid</code> of size <code>m x n</code> representing a box, and you have <code>n</code> balls. The box is open on the top and bottom sides.</p>

<p>Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.</p>

<ul>
	<li>A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as <code>1</code>.</li>
	<li>A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as <code>-1</code>.</li>
</ul>

<p>We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a &quot;V&quot; shaped pattern between two boards or if a board redirects the ball into either wall of the box.</p>

<p>Return <em>an array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the column that the ball falls out of at the bottom after dropping the ball from the </em><code>i<sup>th</sup></code><em> column at the top, or <code>-1</code><em> if the ball gets stuck in the box</em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/26/ball.jpg" style="width: 500px; height: 385px;" /></strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
<strong>Output:</strong> [1,-1,-1,-1,-1]
<strong>Explanation:</strong> This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[-1]]
<strong>Output:</strong> [-1]
<strong>Explanation:</strong> The ball gets stuck against the left wall.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
<strong>Output:</strong> [0,1,2,3,4,-1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 100</code></li>
	<li><code>grid[i][j]</code> is <code>1</code> or <code>-1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-358">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-search/description" target="_blank" rel="noopener noreferrer">Word Search</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">depth-first-search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>

<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n = board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 6</code></li>
	<li><code>1 &lt;= word.length &lt;= 15</code></li>
	<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-359">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/word-search-ii/description" target="_blank" rel="noopener noreferrer">Word Search II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">backtracking</span> <span class="topic-badge">matrix</span> <span class="topic-badge">string</span> <span class="topic-badge">trie</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>

<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" style="width: 322px; height: 322px;" />
<pre>
<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]
<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" style="width: 162px; height: 162px;" />
<pre>
<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>board[i][j]</code> is a lowercase English letter.</li>
	<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>words</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-360">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.hackerearth.com/problem/algorithm/zeus-and-his-wrath-for-fibonacci/" target="_blank" rel="noopener noreferrer">Zeus and Fibonacci</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">HackerEarth</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge explanation">Explanation</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">approved</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hard</span> <span class="topic-badge">matrix</span> <span class="topic-badge">segmenttrees</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <em>A</em> consisting of <em>N</em> integers.
You have to process two types of queries on this array.<br /> 
Type 1: Change the <em>i</em>th element to <em>X</em><br />
Type 2: Given <em>l</em> and <em>r</em>, calculate:
<span class="mathjax-latex">\(\sum_{i=l}^{r} \sum_{j=i}^{r} Fib ( \sum_{k=i}^{j} A_k ) \)</span> </p>
<p>Note: <span class="mathjax-latex">\(Fib(i)\)</span> is the <em>i</em>th Fibonacci number. <span class="mathjax-latex">\(Fib(0)=0 \space.\space Fib(1)=1 \)</span></p>
<p><strong>Input</strong></p>
<p>First line contains an integer <em>N</em>.<br />
Next line contains <em>N</em> space separated integers denoting array <em>A</em>.<br />
Next line contains the integer <em>Q</em>.<br />
Next <em>Q</em> lines are of the following format:<br />
<span class="mathjax-latex">\(1 \space i \space X\)</span> : for type 1 query<br />
<span class="mathjax-latex">\(2 \space l \space r\)</span> : for type 2 query<br />
<br />
<strong>Output</strong></p>
<p>For each type 2 query output the answer modulo <span class="mathjax-latex">\(10^9+7\)</span> on a new line.</p>
<p><strong>Constraints</strong></p>
<p><span class="mathjax-latex">\(1 â‰¤ N,Q â‰¤ 10^5\)</span> <br />
<span class="mathjax-latex">\(1 â‰¤ A[i],x â‰¤ 10^9\)</span> <br />
<span class="mathjax-latex">\(1 â‰¤ l,r,i â‰¤ N \)</span> <br />
<span class="mathjax-latex">\(l â‰¤ r \)</span> <br /></p></div>
			</div>
			<div class="explanation-section">
					<h3>Explanation</h3>
					<div class="content-section"><p>Query 1:<br />
possible subarrays     :     (1),(2),(1,2)<br />
Corresponding sums :    1   ,2   ,3<br />
Corresponding fibonacci: 1 , 1, 2<br />
Sum of fibnoacci : 1 + 1+2=4<br />
output : 4%(10^9+7)=4<br />
Query 2:<br />
possible subarrays     :     (1),(2),(3),(1,2),(2,3),(1,2,3)<br />
Corresponding sums :    1,2,3,3,5,6<br />
Corresponding fibonacci: 1,1,2,2,5,8<br />
Sum of fibnoacci : 19<br />
output : 19%(10^9+7)=19<br /></p></div>
				</div>
			
		</div>

<div class="question-card" id="question-361">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/zigzag-grid-traversal-with-skip/description" target="_blank" rel="noopener noreferrer">Zigzag Grid Traversal With Skip</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> 2D array <code>grid</code> of <strong>positive</strong> integers.</p>

<p>Your task is to traverse <code>grid</code> in a <strong>zigzag</strong> pattern while skipping every <strong>alternate</strong> cell.</p>

<p>Zigzag pattern traversal is defined as following the below actions:</p>

<ul>
	<li>Start at the top-left cell <code>(0, 0)</code>.</li>
	<li>Move <em>right</em> within a row until the end of the row is reached.</li>
	<li>Drop down to the next row, then traverse <em>left</em> until the beginning of the row is reached.</li>
	<li>Continue <strong>alternating</strong> between right and left traversal until every row has been traversed.</li>
</ul>

<p><strong>Note </strong>that you <strong>must skip</strong> every <em>alternate</em> cell during the traversal.</p>

<p>Return an array of integers <code>result</code> containing, <strong>in order</strong>, the value of the cells visited during the zigzag traversal with skips.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2],[3,4]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,4]</span></p>

<p><strong>Explanation:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/11/23/4012_example0.png" style="width: 200px; height: 200px;" /></strong></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[2,1],[2,1],[2,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[2,1,2]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/23/4012_example1.png" style="width: 200px; height: 240px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,2,3],[4,5,6],[7,8,9]]</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,3,5,7,9]</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/11/23/4012_example2.png" style="width: 260px; height: 250px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == grid.length &lt;= 50</code></li>
	<li><code>2 &lt;= m == grid[i].length &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 2500</code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = 'â†‘';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>