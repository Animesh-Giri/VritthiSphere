<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>topological sort - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>topological sort</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">28</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">All Ancestors of a Node in a Directed Acyclic Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-1" class="toc-link">Build a Matrix With Conditions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">Cat and Mouse</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-3" class="toc-link">Cat and Mouse II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">Collect Coins in a Tree</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">Count Ways to Build Rooms in an Ant Colony</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">Course Schedule</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-7" class="toc-link">Course Schedule II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Course Schedule IV</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Find All Possible Recipes from Given Supplies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Find Eventual Safe States</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Frequencies of Shortest Supersequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Largest Color Value in a Directed Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Longest Cycle in a Graph</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Longest Increasing Path in a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-15" class="toc-link">Longest Path With Different Adjacent Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Loud and Rich</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Maximum Employees to Be Invited to a Meeting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-18" class="toc-link">Maximum Profit from Valid Topological Order in DAG</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Minimum Height Trees</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Network Recovery Pathways</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Number of Increasing Paths in a Grid</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Number of Restricted Paths From First to Last Node</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Number of Ways to Arrive at Destination</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-24" class="toc-link">Parallel Courses III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Rank Transform of a Matrix</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-26" class="toc-link">Sort Items by Groups Respecting Dependencies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Strange Printer II</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description" target="_blank" rel="noopener noreferrer">All Ancestors of a Node in a Directed Acyclic Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer <code>n</code> representing the number of nodes of a <strong>Directed Acyclic Graph</strong> (DAG). The nodes are numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>).</p>

<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> denotes that there is a <strong>unidirectional</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> in the graph.</p>

<p>Return <em>a list</em> <code>answer</code><em>, where </em><code>answer[i]</code><em> is the <strong>list of ancestors</strong> of the</em> <code>i<sup>th</sup></code> <em>node, sorted in <strong>ascending order</strong></em>.</p>

<p>A node <code>u</code> is an <strong>ancestor</strong> of another node <code>v</code> if <code>u</code> can reach <code>v</code> via a set of edges.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e1.png" style="width: 322px; height: 265px;" />
<pre>
<strong>Input:</strong> n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
<strong>Output:</strong> [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Nodes 0, 1, and 2 do not have any ancestors.
- Node 3 has two ancestors 0 and 1.
- Node 4 has two ancestors 0 and 2.
- Node 5 has three ancestors 0, 1, and 3.
- Node 6 has five ancestors 0, 1, 2, 3, and 4.
- Node 7 has four ancestors 0, 1, 2, and 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/12/12/e2.png" style="width: 343px; height: 299px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
<strong>Output:</strong> [[],[0],[0,1],[0,1,2],[0,1,2,3]]
<strong>Explanation:</strong>
The above diagram represents the input graph.
- Node 0 does not have any ancestor.
- Node 1 has one ancestor 0.
- Node 2 has two ancestors 0 and 1.
- Node 3 has three ancestors 0, 1, and 2.
- Node 4 has four ancestors 0, 1, 2, and 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
	<li>There are no duplicate edges.</li>
	<li>The graph is <strong>directed</strong> and <strong>acyclic</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed acyclic graph of <code>n</code> nodes, and our task is to return a list where each sub-list contains the ancestors of the node at that index, sorted in ascending order.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a> is a graph where each edge has a defined direction from one vertex to another and following these edges will never create a closed loop.</p>
<p>A prerequisite for solving this problem is knowledge of graph traversals, namely depth-first search and breadth-first search. If you are not familiar with popular graph traversal techniques, we strongly encourage you to check out this LeetCode <a href="https://leetcode.com/explore/learn/card/graph/">Explore Card</a>.</p>
<hr />
<h3 id="approach-1-depth-first-search-reversed-graph">Approach 1: Depth First Search (Reversed Graph)</h3>
<h4 id="intuition">Intuition</h4>
<p>A node <code>u</code> is an ancestor of node <code>v</code> if we can reach <code>v</code> by following a series of directed edges from <code>u</code>. Thus, all nodes from which we can reach <code>v</code> are its ancestors. But how can we efficiently find all ancestors for each node?</p>
<p>The brute force strategy to determine if node <code>u</code> is an ancestor of node <code>v</code> involves performing a graph traversal from <code>u</code> to check if <code>v</code> can be reached. However, this approach has a time complexity of <span class="math inline">\(O(n^3)\)</span>, which is too slow for our constraints. We need a more optimized technique.</p>
<p>The key insight lies in reversing the traversal direction. By starting from each node and tracing back to all its ancestors directly, we can simplify our task. This is achieved by reversing the edges of the graph, flipping parent-child connections to child-parent. Consequently, nodes reachable from a given node in the reversed graph were its ancestors in the original graph. Have a look at the slides below:</p>
<p>!?!../Documents/2192/reversed_slideshow.json:1162,1142!?!</p>
<p>To find the descendants of a node <code>v</code>, we start a depth-first traversal from <code>v</code> in the reversed graph, using a <code>visited</code> set to track nodes. After the traversal, we collect all nodes in <code>visited</code> (except <code>v</code>) in a list, representing the ancestors of <code>v</code> in the original graph. Performing this traversal for each node provides the required ancestors for all nodes.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Main method <code>getAncestors</code>:</p>
<ul>
<li>Initialize <code>adjacencyList</code> to store the graph representation.</li>
<li>Add the edges to the <code>adjacencyList</code> but reverse their direction.</li>
<li>Initialize a list of lists <code>ancestorsList</code> to store the ancestors of each node.</li>
<li>Iterate through each node:
<ul>
<li>Initialize:
<ul>
<li>An empty list <code>ancestors</code> to store ancestors of the current node.</li>
<li>A set <code>visited</code> to store the nodes already visited in the traversal.</li>
</ul>
</li>
<li>Call the <code>findChildren</code> method to perform DFS and find all descendants of the current node.</li>
<li>Add all nodes present in the <code>visited</code> set to <code>ancestors</code>.</li>
<li>Add <code>ancestors</code> to <code>ancestorsList</code>.</li>
</ul>
</li>
<li>Return <code>ancestorsList</code> containing the ancestors for each node.</li>
</ul>
</li>
<li>
<p>Helper method <code>findChildren</code>:</p>
<ul>
<li>Define the <code>findChildren</code> method with parameters: <code>currentNode</code>, <code>adjacencyList</code> and the <code>visited</code> set for the current traversal.</li>
<li>Add <code>currentNode</code> to the <code>visited</code> set.</li>
<li>Iterate through the neighbors of <code>currentNode</code>. If <code>neighbor</code> has not been visited yet:
<ul>
<li>Recursively call <code>findChildren</code> on <code>neighbor</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TMApG9fd/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The algorithm calls the the DFS method a total of <span class="math inline">\(n\)</span> times. The depth-first search has a worst-case time complexity of <span class="math inline">\(O(n + m)\)</span>. Thus, finding the ancestors take a total of <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>Forming the list of ancestors requires <span class="math inline">\(O(n)\)</span> time, which also occurs <span class="math inline">\(n\)</span> times. This equates to a <span class="math inline">\(O(n^2)\)</span> complexity.</p>
<p>Thus, the total time complexity is <span class="math inline">\(O(n + m)\)</span> + <span class="math inline">\(O(n^2 + n \cdot m)\)</span> + <span class="math inline">\(O(n^2)\)</span>, which simplifies to <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(n + m)\)</span> space, while the <code>ancestors</code> list and the <code>visited</code> set each require <span class="math inline">\(O(n)\)</span> space. The recursion call stack can go as deep as <span class="math inline">\(O(n)\)</span> in the worst case. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + 3 \cdot O(n)\)</span>, which simplifies to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We are not considering the space required by <code>ancestorsList</code> in our analysis, since it is part of the output space. If we do consider it, <code>ancestorsList</code> would have a worst-case space complexity of <span class="math inline">\(O(n^2)\)</span>, making the space complexity of the algorithm <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-optimized">Approach 2: Depth First Search (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can solve this problem without reversing the edges. Observe that a vertex <code>v</code> will be an ancestor for all nodes reachable from it. Therefore, we can initiate a depth-first traversal from each vertex and designate that vertex as an ancestor to all nodes it can reach.</p>
<p>Our depth-first search would be very similar to Approach 1; but with a key difference: we add the given node as an <code>ancestor</code> to all children of the node we're currently exploring. We then recursively call our depth-first search function on each child until all descendants of <code>ancestor</code> are marked with its presence.</p>
<p>Have a look at this slideshow to better understand this process:</p>
<p>!?!../Documents/2192/ancestors_slideshow.json:1742,1310!?!</p>
<p>Another optimization we can implement is eliminating the <code>visited</code> set. In each traversal, we add <code>ancestor</code> to the list of ancestors for each node. To determine if a node has been visited, we check if its last ancestor matches the current ancestor. If it does, the node has been visited and can be safely skipped from further exploration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Main method <strong>getAncestors</strong>:</p>
<ul>
<li>Initialize:
<ul>
<li>A list of lists <code>adjacencyList</code> to store the adjacency list of the graph.</li>
<li>A list of lists <code>ancestors</code> to store the ancestors of each node.</li>
</ul>
</li>
<li>Populate <code>adjacencyList</code> with edges from the input.</li>
<li>For each node, use depth-first search (DFS) to find all its ancestors.</li>
<li>Return <code>ancestors</code> containing the ancestors of each node.</li>
</ul>
</li>
<li>
<p>Helper method <strong>findAncestorsDFS</strong>:</p>
<ul>
<li>Define a method <code>findAncestorsDFS</code> that takes four parameters: the <code>ancestor</code> node, <code>adjacencyList</code>, the current node being visited, and <code>ancestors</code>.</li>
<li>Loop through each child node <code>childNode</code> of the current node in the adjacency list:
<ul>
<li>Check if <code>ancestor</code> is already added to the child node's ancestor list. If not:
<ul>
<li>Add <code>ancestor</code> to the child node's ancestor list.</li>
<li>Recursively call <code>findAncestorsDFS</code> for <code>childNode</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ejRveq7U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + n \cdot m)\)</span></p>
<p>Initializing and populating the adjacency list requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>The depth-first search (DFS) has a time complexity of <span class="math inline">\(O(n + m)\)</span> and is executed <span class="math inline">\(n\)</span> times. Therefore, the total time complexity of this section is <span class="math inline">\(O(n^2 + n \cdot m)\)</span>.</p>
<p>The overall time complexity of the algorithm combines <span class="math inline">\(O(n + m)\)</span> for initialization and <span class="math inline">\(O(n^2 + n \cdot m)\)</span> for the DFS, resulting in <span class="math inline">\(O(n^2 + n \cdot m)\)</span> complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The adjacency list representation of the graph takes <span class="math inline">\(O(n + m)\)</span> space. The call stack for the DFS could go as deep as the height of the graph, which in the worst case is <span class="math inline">\(O(n)\)</span>. Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + m) + O(n)\)</span>, simplifying to <span class="math inline">\(O(n + m)\)</span>.</p>
<blockquote>
<p>Note: We have not considered the space required by <code>ancestors</code> in our analysis, since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort-bfs">Approach 3: Topological Sort (BFS)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The problem revolves around the nature of the graph as a Directed Acyclic Graph (DAG). In a DAG, cycles are absent, and each path progresses clearly from a starting point to an endpoint. This characteristic implies that by processing nodes in a specific order, we can systematically determine each node's ancestors.</p>
<p>The key to identifying this optimal processing order lies in topological sorting. In a DAG, topological sorting arranges nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, <code>u</code> precedes <code>v</code> in the ordering. This arrangement is crucial because it ensures that when we process a node <code>v</code>, we have already considered all its potential ancestors. To achieve this ordering, we will use Kahn's algorithm.</p>
<p>Kahn's algorithm is a method for topologically sorting a directed acyclic graph. It starts by identifying all nodes without incoming edges and placing them in a queue. At each step, it removes a node from this queue, adds it to the sorted list, and eliminates its outgoing edges from the graph. This process may create new nodes without incoming edges, which are then added to the queue. The algorithm continues until the queue is empty. The resulting list provides a valid topological ordering of the graph. For a more detailed explanation of Kahn's algorithm and its implementation, refer to this <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">Explore Card</a>.</p>
<p>After establishing the topological order, we process each node sequentially. For each <code>node</code>, we iterate through its <code>neighbors</code>, designating both the node itself and its ancestors as ancestors of the <code>neighbor</code>. To efficiently track each node's ancestors, we use a list of sets. Sets, unlike lists, maintain unique elements, ensuring each ancestor appears only once in a node's ancestor set.</p>
<p>In the final step, we'll convert these sets of ancestors into lists, as required by the problem statement.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a list of lists <code>adjacencyList</code> to store the edges of the graph.</li>
<li>Initialize an array <code>indegree</code> to store the in-degree of each node.</li>
<li>Fill <code>adjacencyList</code> and the <code>indegree</code> array based on the given edges.</li>
<li>Initialize a queue <code>nodesWithZeroIndegree</code> and add all such nodes to the queue.</li>
<li>Initialize a list <code>topologicalOrder</code> to store the topological order of nodes and process nodes in the queue. For each node:
<ul>
<li>Reduce the in-degree of its neighbors.</li>
<li>Add neighbors with zero in-degree to the queue.</li>
</ul>
</li>
<li>Initialize a list <code>ancestorsList</code> to store the result and a list of sets <code>ancestorsSetList</code> to store the ancestors of each node.</li>
<li>For each <code>node</code> in the topological order:
<ul>
<li>Loop over all neighbors <code>neighbor</code> of <code>node</code>. For each <code>neighbor</code>:
<ul>
<li>Add <code>node</code> as the immediate parent of <code>neighbor</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
<li>Add all other ancestors of <code>node</code> to the set <code>ancestorsSetList[neighbor]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add the contents of each set to it's corresponding list in <code>ancestorsList</code> in ascending order.</li>
<li>Return <code>ancestorsList</code>, which contains the ancestors of each node in the graph.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/BGfz4pY8/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of vertices in the graph and <span class="math inline">\(m\)</span> be the length of the <code>edges</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>Creating and filling the adjacency list and in-degree array requires <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>Topological sort on the graph also needs <span class="math inline">\(O(n + m)\)</span> time.</p>
<p>In the worst-case scenario, if the graph forms a chain, the time complexity could be <span class="math inline">\(O(n^2)\)</span>. This is because each node in the chain would have a growing number of ancestors. So, the sizes of the ancestor lists would be <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, ..., <span class="math inline">\(n-2\)</span>, <span class="math inline">\(n-1\)</span>. Forming these lists would take another <span class="math inline">\(O(n^2)\)</span> time.</p>
<p>Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n^2 + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2 + m)\)</span></p>
<p>We use an adjacency list which takes <span class="math inline">\(O(n + m)\)</span> space.</p>
<p>We store an array of size <span class="math inline">\(n\)</span> to keep track of the indegree of each node, taking <span class="math inline">\(O(n)\)</span> space.</p>
<p>All nodes are added to the queue once, requiring <span class="math inline">\(O(n)\)</span> space.</p>
<p>The topological order list requires <span class="math inline">\(O(n)\)</span> space.</p>
<p>Maintaining a list of sets to store the ancestors requires <span class="math inline">\(O(n^2)\)</span> space in the worst case.</p>
<p>Considering all individual components, the total space complexity comes out to be <span class="math inline">\(O(n^2 + m)\)</span>.</p>
<blockquote>
<p>Note: As stated in the previous approaches, the space taken by <code>ancestorsList</code> is not taken into consideration since it is part of the output space.</p>
</blockquote>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/build-a-matrix-with-conditions/description" target="_blank" rel="noopener noreferrer">Build a Matrix With Conditions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>positive</strong> integer <code>k</code>. You are also given:</p>

<ul>
	<li>a 2D integer array <code>rowConditions</code> of size <code>n</code> where <code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>, and</li>
	<li>a 2D integer array <code>colConditions</code> of size <code>m</code> where <code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>.</li>
</ul>

<p>The two arrays contain integers from <code>1</code> to <code>k</code>.</p>

<p>You have to build a <code>k x k</code> matrix that contains each of the numbers from <code>1</code> to <code>k</code> <strong>exactly once</strong>. The remaining cells should have the value <code>0</code>.</p>

<p>The matrix should also satisfy the following conditions:</p>

<ul>
	<li>The number <code>above<sub>i</sub></code> should appear in a <strong>row</strong> that is strictly <strong>above</strong> the row at which the number <code>below<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>n - 1</code>.</li>
	<li>The number <code>left<sub>i</sub></code> should appear in a <strong>column</strong> that is strictly <strong>left</strong> of the column at which the number <code>right<sub>i</sub></code> appears for all <code>i</code> from <code>0</code> to <code>m - 1</code>.</li>
</ul>

<p>Return <em><strong>any</strong> matrix that satisfies the conditions</em>. If no answer exists, return an empty matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png" style="width: 211px; height: 211px;" />
<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]
<strong>Output:</strong> [[3,0,0],[0,0,1],[0,2,0]]
<strong>Explanation:</strong> The diagram above shows a valid example of a matrix that satisfies all the conditions.
The row conditions are the following:
- Number 1 is in row <u>1</u>, and number 2 is in row <u>2</u>, so 1 is above 2 in the matrix.
- Number 3 is in row <u>0</u>, and number 2 is in row <u>2</u>, so 3 is above 2 in the matrix.
The column conditions are the following:
- Number 2 is in column <u>1</u>, and number 1 is in column <u>2</u>, so 2 is left of 1 in the matrix.
- Number 3 is in column <u>0</u>, and number 2 is in column <u>1</u>, so 3 is left of 2 in the matrix.
Note that there may be multiple correct answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]
<strong>Output:</strong> []
<strong>Explanation:</strong> From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.
No matrix can satisfy all the conditions, so we return the empty matrix.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= k &lt;= 400</code></li>
	<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>
	<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>
	<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>
	<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>
	<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer <code>k</code> and two 2D integer arrays <code>rowConditions</code> and <code>colConditions</code>. The constructed matrix's size should be <code>k x k</code> containing each value from <code>1</code> to <code>k</code> exactly once. <code>rowConditions</code> contains tuples of the form: <code>[above, below]</code> for every index <code>i</code>, which denotes that the integer <code>above</code> should appear in a row strictly above the integer <code>below</code>. Similarly, in <code>colConditions</code>, the tuples are of the form <code>[left, right]</code> and denote that <code>left</code> should appear in a column strictly to the left of <code>right</code>. We need to return any matrix that satisfies these conditions.</p>
<p>Let's say that <code>rowConditions</code> is given by <code>[1,2],[2,3],[3,4]</code> for <code>k=4</code>. This implies that 1 should appear above 2, 2 should appear above 3, and 3 should appear above 4 in the matrix. Therefore, <code>[1,2,3,4]</code> is the only solution possible for the row arrangement. Now, observe that any possible column arrangement can be used to create this row solution i.e. if we have found the solution arrays for rows and columns we can merge them to create the desired matrix.</p>
<p>Therefore, we can solve this problem for rows and columns, by calculating their solutions independently and then merging those solutions in a matrix as given above. Let's try to calculate the solution array for <code>rowConditions</code> first by representing the information in the form of a graph:</p>
<ul>
<li>Let <code>G(V,E)</code> represent directed, unweighted graphs.</li>
<li>Each value from <code>1</code> to <code>k</code> would represent a vertex in the graph.</li>
<li>The edges are modeled after the prerequisite relationship between the numbers. So, a pair <code>[a,b]</code> in the <code>rowConditions</code> array means <code>a</code> must appear before <code>b</code>. The graph represents this as a directed edge <code>a ➔ b</code>.</li>
<li>If the graph would be acyclic, then an ordering would always be possible. Since it's mentioned that such an ordering may not always be possible, we may have a cyclic graph.</li>
</ul>
<p>We are trying to order nodes based on the edges such that if <code>a-&gt;b</code> is an edge, <code>a</code> must appear before <code>b</code> in the ordering. Such an ordering of subjects is referred to as a <a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorted Order</a>. There are two approaches that we will be looking at in this article to solve this problem.</p>
<hr />
<h3 id="approach-1-depth-first-search">Approach 1: Depth-First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>During depth-first traversal in a graph, starting from node <code>A</code>, DFS explores all paths stemming from <code>A</code> before completing its recursion for <code>A</code> and moving to other nodes. Consequently, all nodes in these paths have <code>A</code> as an ancestor, making <code>A</code> a prerequisite for all paths originating from it.</p>
<p>Now, we know how to get all the integers that have a particular integer as a prerequisite. If a valid ordering of integers is possible, the node <code>A</code> would come before all the other sets of integers that have it as a prerequisite. This idea for solving the problem can be explored using a depth-first search.</p>
<p>Initialize a recursive function given by <code>dfs</code> where the recursive stack will contain the topologically sorted order of the nodes in our graph.</p>
<p>For each node in our graph, we will run a depth-first search in case that node was not already visited in some other node's DFS traversal. Once the processing of all the neighbors is done, we will add this node to the stack. We are using the recursion stack to simulate the ordering we need.</p>
<p>Once all the nodes have been processed, we will return the nodes as they are returned in the recursion stack from top to bottom.</p>
<p>Now that we have topologically sorted arrays for both <code>rowConditions</code> and <code>colConditions</code>, how can we utilize them to construct the matrix? Each row and column should correspond to their respective sorted arrays. Therefore, the value at position <code>matrix[i][j]</code> is derived from <code>rowConditions[i]</code> and <code>colConditions[j]</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions,k)</code> and <code>topoSort(colConditions,k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create a <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>0</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] == orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges,n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, and an empty array <code>order</code>. Also, initialize a <code>visited</code> array and a boolean <code>hasCycle</code> variable with <code>false</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> denoting an edge from <code>a</code> to <code>b</code>.</li>
<li>For all nodes with an index from <code>1</code> to <code>n</code>:
<ul>
<li>If the current node is not visited, perform <code>dfs(i, adj, visited, order, hasCycle)</code>. If the <code>hasCycle</code> value is <code>true</code>, return an empty array.</li>
</ul>
</li>
<li>Reverse the <code>order</code> array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p><strong><code>dfs(node, adj, visited, order, hasCycle)</code></strong></p>
<ol>
<li>Set <code>visited[node]</code> to <code>1</code>.</li>
<li>Iterate over all neighbors of <code>node</code>:
<ul>
<li>If <code>visited[neighbor] == 0</code>, perform <code>dfs(neighbor, adj, visited, order, hasCycle)</code>. If <code>hasCycle</code> is true, return.</li>
<li>If <code>visited[neighbor] == 1</code>, set <code>hasCycle</code> to true, return.</li>
</ul>
</li>
<li>Set <code>visited[node]</code> as <code>2</code>.</li>
<li>Push <code>node</code> in <code>order</code> array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HcR3PUwv/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the depth-first search operation is <span class="math inline">\(O(n)\)</span>. The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-kahns-algorithm">Approach 2: Kahn's Algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Kahn’s algorithm works by keeping track of the number of incoming edges into each node (in-degree). It works by repeatedly visiting the nodes with an in-degree of zero and deleting all the edges associated with it leading to a decrement of in-degree for the nodes whose incoming edges are deleted. This process continues until no elements with zero in-degree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>After constructing the graph, we can push all the nodes with in-degree 0 to a queue. These nodes represent integers that are not constrained by the position of other integers. In a queue, push these integers first, since they can be completed without any prerequisites.</p>
<p>Now, iterate over all the queue elements, push them in the topologically sorted array, and reduce the in-degree by 1 of each direct neighbor of the current node. If the in-degree of the direct neighbor becomes 0, push it in the queue. Repeat the process till you have visited all the nodes with zero in-degree.</p>
<p>For example, let's say the given graph has three edges: <code>1 -&gt; 2</code>, <code>2 -&gt; 3</code>, and <code>1 -&gt; 3</code>. In this graph, the in-degree of each node represents the number of prerequisites that must be completed before reaching that node:</p>
<ul>
<li>Node <code>1</code> has an in-degree of <code>0</code></li>
<li>Node <code>2</code> has an in-degree of <code>1</code></li>
<li>Node <code>3</code> has an in-degree of <code>2</code></li>
</ul>
<p>We start with node <code>1</code>, as it has no prerequisites. We add it to our queue and process it first. Node <code>1</code> is a direct prerequisite for both nodes <code>2</code> and <code>3</code>, so we decrement their in-degrees:</p>
<ul>
<li>Node <code>2</code>'s in-degree becomes <code>0</code></li>
<li>Node <code>3</code>'s in-degree becomes <code>1</code></li>
</ul>
<p>Now we can add node <code>2</code> to our queue, as its in-degree is <code>0</code>. Processing node <code>2</code>, we decrement the in-degree of its neighbor, node <code>3</code>:</p>
<ul>
<li>Node <code>3</code>'s in-degree becomes <code>0</code></li>
</ul>
<p>Finally, we add node <code>3</code> to our queue and process it.</p>
<p>The resulting topologically sorted order is <code>1 -&gt; 2 -&gt; 3</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p><strong>Main function - <code>buildMatrix(k, rowConditions, colConditions)</code></strong></p>
<ol>
<li>Create two arrays given by <code>orderRows</code> and <code>orderColumns</code> to store the topological sorted sequence.</li>
<li>Store the values of <code>topoSort(rowConditions, k)</code> and <code>topoSort(colConditions, k)</code> in them.</li>
<li>If either of the arrays is empty, return <code>{}</code>.</li>
<li>Create <code>matrix</code> of size <code>k x k</code> and initialize all values with 0.</li>
<li>Iterate <code>i</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>Iterate <code>j</code> through all values from <code>1</code> to <code>k</code>:
<ul>
<li>If <code>orderRows[i] = orderColumns[j]</code>, store <code>orderRows[i]</code> in <code>matrix[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the <code>matrix</code>.</li>
</ol>
<p><strong><code>topoSort(edges, n)</code></strong></p>
<ol>
<li>Initialize an adjacency matrix <code>adj</code> with <code>n+1</code> rows, an array <code>deg</code> with size <code>n+1</code>, and an empty array <code>order</code>.</li>
<li>Store all the <code>edges</code> in <code>adj</code> by pushing <code>b</code> in <code>adj[a]</code> (denoting an edge from <code>a</code> to <code>b</code>). Also, increment the in-degree of <code>b</code> in the <code>deg</code> array.</li>
<li>Initialize a queue <code>q</code> and push all nodes with in-degree values 0 to the queue.</li>
<li>While <code>q</code> is not empty:
<ul>
<li>Store the front element of <code>q</code> in <code>f</code> and pop it.</li>
<li>Push <code>f</code> in <code>order</code>.</li>
<li>Decrement <code>n</code> by 1.</li>
<li>Iterate through each neighbor of <code>f</code>:
<ul>
<li>Decrement the in-degree of the neighbor. If the in-degree becomes 0, push it in <code>q</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>n</code> is not equal to 0, return an empty array.</li>
<li>Return <code>order</code>.</li>
</ol>
<p>!?!../Documents/2392/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/7Ckf6TjR/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>rowConditions</code> and <code>colConditions</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span> and all the nodes are visited exactly once, the time complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The time complexity of creating and filling the values of a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the time complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(max(k\cdot k,n))\)</span></p>
<p>Since the total edges in the graph are <span class="math inline">\(n\)</span>, the space complexity of the breadth-first search operation is <span class="math inline">\(O(n)\)</span>.</p>
<p>The space complexity of creating a <span class="math inline">\(k \cdot k\)</span> sized matrix is <span class="math inline">\(O(k\cdot k)\)</span>. Both these operations are performed independently.</p>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(max(k\cdot k,n))\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse/description" target="_blank" rel="noopener noreferrer">Cat and Mouse</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>

<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>

<p>The mouse starts at node <code>1</code> and goes first, the cat starts at node <code>2</code> and goes second, and there is a hole at node <code>0</code>.</p>

<p>During each player&#39;s turn, they <strong>must</strong> travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node 1, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>

<p>Additionally, it is not allowed for the Cat to travel to the Hole (node <code>0</code>).</p>

<p>Then, the game can end in three&nbsp;ways:</p>

<ul>
	<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>
	<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>
	<li>If ever a position is repeated (i.e., the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw.</li>
</ul>

<p>Given a <code>graph</code>, and assuming both players play optimally, return</p>

<ul>
	<li><code>1</code>&nbsp;if the mouse wins the game,</li>
	<li><code>2</code>&nbsp;if the cat wins the game, or</li>
	<li><code>0</code>&nbsp;if the game is a draw.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg" style="width: 300px; height: 300px;" />
<pre>
<strong>Input:</strong> graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg" style="width: 200px; height: 200px;" />
<pre>
<strong>Input:</strong> graph = [[1,3],[0],[3],[0,2]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= graph.length &lt;= 50</code></li>
	<li><code>1&nbsp;&lt;= graph[i].length &lt; graph.length</code></li>
	<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
	<li><code>graph[i][j] != i</code></li>
	<li><code>graph[i]</code> is unique.</li>
	<li>The mouse and the cat can always move.&nbsp;</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-minimax--percolate-from-resolved-states">Approach 1: Minimax / Percolate from Resolved States</h3>
<p><strong>Intuition</strong></p>
<p>The state of the game can be represented as <code>(m, c, t)</code> where <code>m</code> is the location of the mouse, <code>c</code> is the location of the cat, and <code>t</code> is <code>1</code> if it is the mouse's move, else <code>2</code>.  Let's call these states <em>nodes</em>.  These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.</p>
<p>Some of these nodes are already resolved: if the mouse is at the hole <code>(m = 0)</code>, then the mouse wins; if the cat is where the mouse is <code>(c = m)</code>, then the cat wins.  Let's say that nodes will either be colored <span class="math inline">\(\small\text{MOUSE}\)</span>, <span class="math inline">\(\small\text{CAT}\)</span>, or <span class="math inline">\(\small\text{DRAW}\)</span> depending on which player is assured victory.</p>
<p>As in a standard minimax algorithm, the Mouse player will prefer <span class="math inline">\(\small\text{MOUSE}\)</span> nodes first, <span class="math inline">\(\small\text{DRAW}\)</span> nodes second, and <span class="math inline">\(\small\text{CAT}\)</span> nodes last, and the Cat player prefers these nodes in the opposite order.</p>
<p><strong>Algorithm</strong></p>
<p>We will color each <code>node</code> marked <span class="math inline">\(\small\text{DRAW}\)</span> according to the following rule.  (We'll suppose the <code>node</code> has <code>node.turn = Mouse</code>: the other case is similar.)</p>
<ul>
<li>
<p>(&quot;Immediate coloring&quot;):  If there is a child that is colored <span class="math inline">\(\small\text{MOUSE}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{MOUSE}\)</span>.</p>
</li>
<li>
<p>(&quot;Eventual coloring&quot;):  If all children are colored <span class="math inline">\(\small\text{CAT}\)</span>, then this node will also be colored <span class="math inline">\(\small\text{CAT}\)</span>.</p>
</li>
</ul>
<p>We will repeatedly do this kind of coloring until no <code>node</code> satisfies the above conditions.  To perform this coloring efficiently, we will use a queue and perform a <em>bottom-up percolation</em>:</p>
<ul>
<li>
<p>Enqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)</p>
</li>
<li>
<p>For every <code>node</code> in the queue, for each <code>parent</code> of that <code>node</code>:</p>
<ul>
<li>
<p>Do an immediate coloring of <code>parent</code> if you can.</p>
</li>
<li>
<p>If you can't, then decrement the side-count of the number of children marked <span class="math inline">\(\small\text{DRAW}\)</span>.  If it becomes zero, then do an &quot;eventual coloring&quot; of this parent.</p>
</li>
<li>
<p>All <code>parents</code> that were colored in this manner get enqueued to the queue.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Proof of Correctness</strong></p>
<p>Our proof is similar to a proof that minimax works.</p>
<p>Say we cannot color any nodes any more, and say from any node colored <span class="math inline">\(\small\text{CAT}\)</span> or <span class="math inline">\(\small\text{MOUSE}\)</span> we need at most <span class="math inline">\(K\)</span> moves to win.  If say, some node marked <span class="math inline">\(\small\text{DRAW}\)</span> is actually a win for Mouse, it must have been with <span class="math inline">\(> K\)</span> moves.  Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored <span class="math inline">\(\small\text{MOUSE}\)</span> (as eventually the Mouse reaches the Hole.)  Thus, there must have been some transition <span class="math inline">\(\small\text{DRAW} \rightarrow \small\text{MOUSE}\)</span> along this path.</p>
<p>If this transition occurred at a <code>node</code> with <code>node.turn = Mouse</code>, then it breaks our immediate coloring rule.  If it occured with <code>node.turn = Cat</code>, and all children of <code>node</code> have color <span class="math inline">\(\small\text{MOUSE}\)</span>, then it breaks our eventual coloring rule.  If some child has color <span class="math inline">\(\small\text{CAT}\)</span>, then it breaks our immediate coloring rule.  Thus, in this case <code>node</code> will have some child with <span class="math inline">\(\small\text{DRAW}\)</span>, which breaks our optimal play assumption, as moving to this child ends the game in <span class="math inline">\(> K\)</span> moves, whereas moving to the colored neighbor ends the game in <span class="math inline">\(\leq K\)</span> moves.</p>
<p><a href="https://leetcode.com/playground/TQVY6JML/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N^3)\)</span>, where <span class="math inline">\(N\)</span> is the number of nodes in the graph.  There are <span class="math inline">\(O(N^2)\)</span> states, and each state has an outdegree of <span class="math inline">\(N\)</span>, as there are at most <span class="math inline">\(N\)</span> different moves.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N^2)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/cat-and-mouse-ii/description" target="_blank" rel="noopener noreferrer">Cat and Mouse II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">game-theory</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A game is played by a cat and a mouse named Cat and Mouse.</p>

<p>The environment is represented by a <code>grid</code> of size <code>rows x cols</code>, where each element is a wall, floor, player (Cat, Mouse), or food.</p>

<ul>
	<li>Players are represented by the characters <code>&#39;C&#39;</code>(Cat)<code>,&#39;M&#39;</code>(Mouse).</li>
	<li>Floors are represented by the character <code>&#39;.&#39;</code> and can be walked on.</li>
	<li>Walls are represented by the character <code>&#39;#&#39;</code> and cannot be walked on.</li>
	<li>Food is represented by the character <code>&#39;F&#39;</code> and can be walked on.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
</ul>

<p>Mouse and Cat play according to the following rules:</p>

<ul>
	<li>Mouse <strong>moves first</strong>, then they take turns to move.</li>
	<li>During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the <code>grid</code>.</li>
	<li><code>catJump, mouseJump</code> are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.</li>
	<li>Staying in the same position is allowed.</li>
	<li>Mouse can jump over Cat.</li>
</ul>

<p>The game can end in 4 ways:</p>

<ul>
	<li>If Cat occupies the same position as Mouse, Cat wins.</li>
	<li>If Cat reaches the food first, Cat wins.</li>
	<li>If Mouse reaches the food first, Mouse wins.</li>
	<li>If Mouse cannot get to the food within 1000 turns, Cat wins.</li>
</ul>

<p>Given a <code>rows x cols</code> matrix <code>grid</code> and two integers <code>catJump</code> and <code>mouseJump</code>, return <code>true</code><em> if Mouse can win the game if both Cat and Mouse play optimally, otherwise return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_111_1955.png" style="width: 580px; height: 239px;" />
<pre>
<strong>Input:</strong> grid = [&quot;####F&quot;,&quot;#C...&quot;,&quot;M....&quot;], catJump = 1, mouseJump = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> Cat cannot catch Mouse on its turn nor can it get the food before Mouse.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/12/sample_2_1955.png" style="width: 580px; height: 175px;" />
<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 4
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>rows == grid.length</code></li>
	<li><code>cols = grid[i].length</code></li>
	<li><code>1 &lt;= rows, cols &lt;= 8</code></li>
	<li><code>grid[i][j]</code> consist only of characters <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, <code>&#39;F&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39;#&#39;</code>.</li>
	<li>There is only one of each character <code>&#39;C&#39;</code>, <code>&#39;M&#39;</code>, and <code>&#39;F&#39;</code> in <code>grid</code>.</li>
	<li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/collect-coins-in-a-tree/description" target="_blank" rel="noopener noreferrer">Collect Coins in a Tree</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There exists an undirected and unrooted tree with <code>n</code> nodes indexed from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and a 2D integer array edges of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. You are also given&nbsp;an array <code>coins</code> of size <code>n</code> where <code>coins[i]</code> can be either <code>0</code> or <code>1</code>, where <code>1</code> indicates the presence of a coin in the vertex <code>i</code>.</p>

<p>Initially, you choose to start at any vertex in&nbsp;the tree.&nbsp;Then, you can perform&nbsp;the following operations any number of times:&nbsp;</p>

<ul>
	<li>Collect all the coins that are at a distance of at most <code>2</code> from the current vertex, or</li>
	<li>Move to any adjacent vertex in the tree.</li>
</ul>

<p>Find <em>the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex</em>.</p>

<p>Note that if you pass an edge several times, you need to count it into the answer several times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/01/graph-2.png" style="width: 522px; height: 522px;" />
<pre>
<strong>Input:</strong> coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/03/02/graph-4.png" style="width: 522px; height: 522px;" />
<pre>
<strong>Input:</strong> coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == coins.length</code></li>
	<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= coins[i] &lt;= 1</code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li><code>edges</code> represents a valid tree.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/description" target="_blank" rel="noopener noreferrer">Count Ways to Build Rooms in an Ant Colony</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">combinatorics</span> <span class="topic-badge">graph</span> <span class="topic-badge">math</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are an ant tasked with adding <code>n</code> new rooms numbered <code>0</code> to <code>n-1</code> to your colony. You are given the expansion plan as a <strong>0-indexed</strong> integer array of length <code>n</code>, <code>prevRoom</code>, where <code>prevRoom[i]</code> indicates that you must build room <code>prevRoom[i]</code> before building room <code>i</code>, and these two rooms must be connected <strong>directly</strong>. Room <code>0</code> is already built, so <code>prevRoom[0] = -1</code>. The expansion&nbsp;plan is given such that once all the rooms are built, every room will be reachable from room <code>0</code>.</p>

<p>You can only build <strong>one room</strong> at a time, and you can travel freely between rooms you have <strong>already built</strong> only if they are <strong>connected</strong>.&nbsp;You can choose to build <strong>any room</strong> as long as its <strong>previous room</strong>&nbsp;is already built.</p>

<p>Return <em>the <strong>number of different orders</strong> you can build all the rooms in</em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d1.JPG" style="width: 200px; height: 212px;" />
<pre>
<strong>Input:</strong> prevRoom = [-1,0,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>&nbsp;There is only one way to build the additional rooms: 0 &rarr; 1 &rarr; 2
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d2.JPG" style="width: 200px; height: 239px;" /></strong>

<pre>
<strong>Input:</strong> prevRoom = [-1,0,0,1,2]
<strong>Output:</strong> 6
<strong>Explanation:
</strong>The 6 ways are:
0 &rarr; 1 &rarr; 3 &rarr; 2 &rarr; 4
0 &rarr; 2 &rarr; 4 &rarr; 1 &rarr; 3
0 &rarr; 1 &rarr; 2 &rarr; 3 &rarr; 4
0 &rarr; 1 &rarr; 2 &rarr; 4 &rarr; 3
0 &rarr; 2 &rarr; 1 &rarr; 3 &rarr; 4
0 &rarr; 2 &rarr; 1 &rarr; 4 &rarr; 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == prevRoom.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>prevRoom[0] == -1</code></li>
	<li><code>0 &lt;= prevRoom[i] &lt; n</code> for all <code>1 &lt;= i &lt; n</code></li>
	<li>Every room is reachable from room <code>0</code> once all the rooms are built.</li>
</ul></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule/description" target="_blank" rel="noopener noreferrer">Course Schedule</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-ii/description" target="_blank" rel="noopener noreferrer">Course Schedule II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
<strong>Output:</strong> [0,2,1,3]
<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 1, prerequisites = []
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/course-schedule-iv/description" target="_blank" rel="noopener noreferrer">Course Schedule IV</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>a<sub>i</sub></code> first if you want to take course <code>b<sub>i</sub></code>.</p>

<ul>
	<li>For example, the pair <code>[0, 1]</code> indicates that you have to take course <code>0</code> before you can take course <code>1</code>.</li>
</ul>

<p>Prerequisites can also be <strong>indirect</strong>. If course <code>a</code> is a prerequisite of course <code>b</code>, and course <code>b</code> is a prerequisite of course <code>c</code>, then course <code>a</code> is a prerequisite of course <code>c</code>.</p>

<p>You are also given an array <code>queries</code> where <code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>. For the <code>j<sup>th</sup></code> query, you should answer whether course <code>u<sub>j</sub></code> is a prerequisite of course <code>v<sub>j</sub></code> or not.</p>

<p>Return <i>a boolean array </i><code>answer</code><i>, where </i><code>answer[j]</code><i> is the answer to the </i><code>j<sup>th</sup></code><i> query.</i></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg" style="width: 222px; height: 62px;" />
<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
<strong>Output:</strong> [false,false]
<strong>Explanation:</strong> There are no prerequisites, and each course is independent.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg" style="width: 222px; height: 222px;" />
<pre>
<strong>Input:</strong> numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
<strong>Output:</strong> [true,true]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= numCourses &lt;= 100</code></li>
	<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>
	<li><code>prerequisites[i].length == 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>unique</strong>.</li>
	<li>The prerequisites graph has no cycles.</li>
	<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= numCourses - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph representing course dependencies. The graph consists of <code>numCourses</code> nodes (denoted as <code>N</code> for simplicity) and <code>E</code> directed edges, where each edge is represented as a pair <code>(u, v)</code>. An edge <code>(u, v)</code> indicates that course <code>u</code> is a prerequisite for course <code>v</code>.</p>
<p>Additionally, we are given <code>Q</code> queries. Each query is a pair <code>(u, v)</code>, and the goal is to determine if course <code>u</code> is a prerequisite for course <code>v</code>.  The answer to each query should be <code>true</code> if <code>u</code> is a prerequisite of <code>v</code>, and <code>false</code> otherwise.</p>
<hr />
<h3 id="approach-1-tree-traversal---on-demand">Approach 1: Tree Traversal - On Demand</h3>
<h4 id="intuition">Intuition</h4>
<p>We can simplify the problem by recognizing that the answer to the query <code>(u, v)</code> is <code>true</code> if there exists a path from node <code>u</code> to node <code>v</code>. This is because the edges are directed to represent dependencies, so if we can reach node <code>v</code> from node <code>u</code>, it indicates that node <code>u</code> is a prerequisite for node <code>v</code>.</p>
<p>This relationship is an example of <em>transitive closure</em>. For instance, consider a path with three nodes: <code>u -&gt; v -&gt; w</code>.  In this case:</p>
<ul>
<li>Node <code>u</code> is a prerequisite for node <code>v</code></li>
<li>Node <code>v</code> is a prerequisite for node <code>w</code>. By transitivity, we can conclude that node <code>u</code> is also a prerequisite for node <code>w</code>.</li>
</ul>
<p>Therefore, the problem reduces to determining whether there exists a path between two nodes. To solve this, we can use <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Depth-First Search (DFS)</a> to explore the graph. Alternatively, other traversal methods like <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">Breadth-First Search (BFS)</a> can also be used. In this approach, we begin at node <code>u</code> and explore its adjacent nodes recursively until we reach node <code>v</code>. If we find node <code>v</code> during the traversal, we return <code>true</code>. If we exhaust all possible paths without reaching node <code>v</code>, we return <code>false</code>.</p>
<p>To efficiently track visited nodes and prevent revisiting them, we maintain a <code>visited</code> array. This array is reset for each query to ensure that each DFS traversal starts with a clean slate, avoiding interference from previous queries.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Define a function <code>isPrerequisite</code> that takes the adjacency list of the graph, a <code>visited</code> array, and two nodes <code>src</code> and <code>target</code>, and returns whether a path exists from <code>src</code> to <code>target</code>:</p>
<ul>
<li>Mark the current node <code>src</code> as visited.</li>
<li>If <code>src</code> is the same as <code>target</code>, return <code>true</code> (we found the path).</li>
<li>For each neighboring node <code>adj</code> of <code>src</code>:
<ul>
<li>If <code>adj</code> has not been visited yet, recursively call the DFS to check if a path exists from <code>adj</code> to <code>target</code>.</li>
</ul>
</li>
<li>Return the <code>true</code> if the result of at least one recursive call is <code>true</code> and <code>false</code> otherwise.</li>
</ul>
</li>
<li>
<p>Create the adjacency list <code>adjList</code> using the prerequisite pairs <code>[u, v]</code>.</p>
</li>
<li>
<p>For each query <code>[u, v]</code>, check if there is a path from <code>u</code> to <code>v</code> using DFS:</p>
<ul>
<li>Initialize a visited array with all entries as <code>false</code></li>
<li>Call the i<code>sPrerequisite</code> function to check if there exists a path from <code>u</code> to <code>v</code>.</li>
<li>Store the result for each query in a result list <code>answer</code>.</li>
</ul>
</li>
<li>
<p>Return <code>answer</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/33jKrZ6q/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. Then we iterate over queries and for each we perform DFS that can take <span class="math inline">\(O(V + E)\)</span> which is equivalent to <span class="math inline">\(O(N^2)\)</span>. Hence, the total time complexity equals <span class="math inline">\(O(Q \cdot N ^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list requires <span class="math inline">\(O(N^2)\)</span> as it stores every edge in the list <code>prerequisites</code>. For the DFS traversal, we need a visited array of size <span class="math inline">\(O(N)\)</span> and the recursive stack for DFS calls requires <span class="math inline">\(O(N)\)</span> space in the worsts case. Therefore, the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-tree-traversal---preprocessed">Approach 2: Tree Traversal - Preprocessed</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach is similar to the previous one, where we traverse the graph to determine if there is a path from node <code>u</code> to node <code>v</code>. However, the key difference here is that instead of performing DFS/BFS for each query, we precompute the reachability for all nodes. Specifically, for each node <code>i</code> in the range from <code>0</code> to <code>N - 1</code>, we perform BFS (can do DFS as well) to identify all nodes that can be reached from <code>i</code> and store this information in a 2D array <code>isPrerequisite</code>.</p>
<p>A value of <code>isPrerequisite[u][v] = true</code> indicates that node <code>u</code> is a prerequisite for node <code>v</code>. During the BFS, starting from node <code>i</code>, we mark all nodes <code>adj</code> in the path as <code>isPrerequisite[i][adj] = true</code>, signifying that <code>i</code> is a prerequisite for <code>adj</code>. In the BFS process, instead of using a separate visited array, we will just use an <code>isPrerequisite</code> array. This is because if <code>isPrerequisite[i][adj]</code> is <code>true</code>, then we can deduce that <code>adj</code> is already visited and skip it.</p>
<p>This method is particularly useful when the number of queries is much larger than the number of nodes. In contrast to the previous approach, where we performed DFS/BFS for each query, this method allows for constant-time query answers since the reachability information has already been preprocessed and stored.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Construct an adjacency list <code>adjList</code> from the prerequisites list where each course points to the courses that depend on it.</p>
</li>
<li>
<p>Preprocessing (BFS from each node):</p>
<ul>
<li>For each node<code> i</code> (from <code>0</code> to <code>N - 1</code>):
<ul>
<li>
<p>Start a BFS from <code>i</code> to explore all reachable nodes.</p>
</li>
<li>
<p>Repeat the following while the queue is not empty:</p>
<ul>
<li>Pop the front in the queue as <code>node</code>.</li>
<li>Iterate over the adjacent <code>node</code> and if the node <code>i</code> is not already marked as its prerequisite, mark it and add <code>node</code> to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For each query <code>[u, v]</code> return <code>isPrerequisite[u][v]</code>.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/Ycdpa23U/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> requires <span class="math inline">\(O(N^2)\)</span> time, as we need to iterate over the <code>prerequisites</code> list. Next, we perform BFS starting from each of the <span class="math inline">\(N\)</span> nodes. Each BFS traversal takes <span class="math inline">\(O(N^2)\)</span> in the worst case, as the time complexity of BFS is <span class="math inline">\(O(V + E)\)</span>. Therefore, the total preprocessing is <span class="math inline">\(O(N \cdot N^2) = O(N^3)\)</span>.</p>
<p>To answer each query, we can retrieve results in constant time from a precomputed map, so answering all <span class="math inline">\(Q\)</span> queries takes <span class="math inline">\(O(Q)\)</span> time. Thus, the total time complexity will be <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The adjacency list takes <span class="math inline">\(O(N^2)\)</span> space as it will store every edge in the list <code>prerequisites</code>. For BFS, we need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes. The queue required for the BFS will take <span class="math inline">\(O(N)\)</span> size for each node, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort---kahns-algorithm">Approach 3: Topological Sort - Kahn's Algorithm</h3>
<h4 id="intuition-2">Intuition</h4>
<p>We need to find a way to process nodes in the correct order, ensuring that each node is processed only after its dependencies are handled. This is where <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/">topological sorting</a> comes into play. Kahn’s algorithm is a great fit for this task because it respects the dependencies of each node, ensuring nodes are only visited once their prerequisites are completed.</p>
<blockquote>
<p>Topological sorting is an algorithm used in directed graphs to arrange nodes such that for every directed edge from node <code>u</code> to node <code>v</code>, node <code>u</code> comes before <code>v</code>. This is a natural approach when dealing with dependencies, like in project scheduling, task ordering, or handling prerequisites.</p>
</blockquote>
<p>Now, to adapt Kahn's algorithm to our needs, we need to keep track of a node’s prerequisites. Instead of just processing nodes in topological order, we'll modify the algorithm to maintain a list of dependencies for each node. As we move from node <code>u</code> to node <code>v</code>, we’ll add all of <code>u</code>'s prerequisites to <code>v</code>'s prerequisites. This is important because it computes the transitive closure, meaning we’re not just tracking immediate dependencies, but also indirect ones.</p>
<p>By the end of this process, each node will have a complete list of all nodes that must be visited before it. With this setup, when we need to answer a query <code>(u, v)</code>, all we have to do is check if <code>u</code> is in the list of prerequisites for <code>v</code>.</p>
<p>The general structure of Kahn’s algorithm stays the same. We start by calculating the indegree of each node, which tells us how many nodes depend on it. Nodes with an indegree of zero are independent and can be processed first, so we enqueue them. Then, using a queue, we dequeue nodes, process their neighbors, update the prerequisite lists, and enqueue any neighbors whose indegree drops to zero. This continues until we’ve processed all nodes, ensuring the correct order of traversal.</p>
<p>!?!../Documents/1462/1462_Course_Schedule_IV.json:960,720!?! <br></p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Create an adjacency list (<code>adjList</code>) to store the directed graph representing course dependencies.</p>
</li>
<li>
<p>Initialize an array (<code>indegree</code>) to track the number of prerequisites (in-degree) for each course.</p>
</li>
<li>
<p>Iterate over the prerequisites array to populate the adjacency list and update the indegree for each course.</p>
</li>
<li>
<p>Initialize a queue (<code>q</code>) to process courses with zero in-degree (no prerequisites).</p>
</li>
<li>
<p>While the queue is not empty:</p>
<ul>
<li>Dequeue a course (<code>node</code>).</li>
<li>For each adjacent course (<code>adj</code>) in the adjacency list of nodes, add the prerequisites of <code>node</code> to the list <code>nodePrerequisites[adj]</code>.</li>
<li>Decrement the in-degree of the node <code>adj</code>, and if the in-degree becomes zero, enqueue it for further processing.</li>
</ul>
</li>
<li>
<p>For each query <code>(u, v)</code>, check if course <code>u</code> is in the prerequisite list of course <code>v</code> by checking <code>nodePrerequisites[v]</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/76eFh22K/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>Creating the adjacency list <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> time as we need to iterate over the list <code>prerequisites</code>. The array <code>indegree</code>  will be of size <span class="math inline">\(O(N)\)</span>. In Kahn's algorithm, we iterate over each node and edge of the vertex which is <span class="math inline">\(O(N^2)\)</span> and for each edge traversed we will also add the prerequisites to the next node which is another <span class="math inline">\(O(N)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>List <code>adjList</code> takes <span class="math inline">\(O(N^2)\)</span> as it will store every edge in the list <code>prerequisites</code>. Array <code>indegree</code> will take <span class="math inline">\(O(N)\)</span> space and the queue for Kahn's algorithm will also be <span class="math inline">\(O(N)\)</span> size. Map <code>nodePrerequisites</code> will be from the node to its prerequisites and thus the total number of entries can be equal to <span class="math inline">\(O(N^2)\)</span>. Hence the total space complexity equals <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-floyd-warshall-algorithm">Approach 4: Floyd Warshall Algorithm</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the first approach, we discussed the concept of transitive closure, which simplified the problem. The key insight was that the transitive closure allows us to determine if a path exists between two nodes, even indirectly. This concept is central to solving the All-Pairs Shortest Path (APSP) problem, for which the Floyd-Warshall algorithm is commonly used. This algorithm works by systematically considering every possible intermediate node and checking if a path between two nodes can be improved by going through that intermediate node. It then updates the shortest distance between the nodes.</p>
<p>For our problem, however, we don't need to calculate the shortest path, just whether a path exists. This leads us to a simple modification of the Floyd-Warshall algorithm: instead of keeping track of distances, we’ll use boolean values to represent whether a path exists between two nodes.</p>
<p>The main idea is to check if there’s a path from <code>src</code> to <code>target</code> by looking at all possible intermediate nodes. For each intermediate node, we check if there’s a path from <code>src</code> to that node and a path from that node to <code>target</code>. If both conditions hold, then we can confirm that a path exists between <code>src</code> and <code>target</code>. We then set <code>isPrerequisite[src][target]</code> to <code>true</code>.</p>
<p>At the end of this process, we’ll have a 2D array, <code>isPrerequisite</code>, where each entry <code>isPrerequisite[u][v]</code> tells us whether <code>u</code> is a prerequisite for <code>v</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>
<p>Initialize a 2D boolean array <code>isPrerequisite</code> of size <code>numCourses x numCourses</code> to track direct prerequisite relationships between courses.</p>
</li>
<li>
<p>Populate the <code>isPrerequisite</code> matrix based on the <code>prerequisites</code>:</p>
</li>
</ol>
<ul>
<li>For each pair in <code>prerequisites</code>, mark <code>isPrerequisite[edge[0]][edge[1]]</code> as <code>true</code> to indicate that <code>edge[0]</code> is a prerequisite for <code>edge[1]</code>.</li>
</ul>
<ol start="3">
<li>Compute transitive closure of the prerequisite relationships using the Floyd-Warshall algorithm:</li>
</ol>
<ul>
<li>For each possible intermediate course <code>intermediate</code>:
<ul>
<li>For each source course <code>src</code>:
<ul>
<li>For each target course <code>target</code>:
<ul>
<li>Update <code>isPrerequisite[src][target]</code> to include indirect relationships:
<ul>
<li>If <code>src</code> can reach <code>intermediate</code> and <code>intermediate</code> can reach <code>target</code>, then <code>src</code> can reach <code>target</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p>Initialize an empty list <code>answer</code> to store the results of the queries.</p>
</li>
<li>
<p>For each query in <code>queries</code>:</p>
</li>
</ol>
<ul>
<li>Add the value of <code>isPrerequisite[query[0]][query[1]]</code> to the <code>answer</code> list, indicating whether <code>query[0]</code> is a prerequisite for <code>query[1]</code>.</li>
</ul>
<ol start="6">
<li>Return the <code>answer</code> list containing the results for all queries.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/LU6eyzQL/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of courses (<code>numCourses</code>) and let <span class="math inline">\(Q\)</span> be the size of the <code>queries</code> list. In the worst case, the size of the <code>prerequisites</code> list can grow up to <span class="math inline">\(\frac{N \cdot (N - 1)}{2}\)</span>, when every course is a prerequisite for every other course, forming a complete directed graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
<p>We iterate over each node in three nested loops, so this step takes <span class="math inline">\(O(N^3)\)</span>. To answer each query we need constant time to retrieve from the map and hence it's <span class="math inline">\(O(Q)\)</span> to answer all queries. Hence, the total time complexity equals <span class="math inline">\(O(N^3 + Q)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>We need a 2D array <code>isPrerequisite</code> with size <span class="math inline">\(O(N^2)\)</span> to store the answer for every pair of nodes, hence the total space complexity is equal to <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-possible-recipes-from-given-supplies/description" target="_blank" rel="noopener noreferrer">Find All Possible Recipes from Given Supplies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have information about <code>n</code> different recipes. You are given a string array <code>recipes</code> and a 2D string array <code>ingredients</code>. The <code>i<sup>th</sup></code> recipe has the name <code>recipes[i]</code>, and you can <strong>create</strong> it if you have <strong>all</strong> the needed ingredients from <code>ingredients[i]</code>. A recipe can also be an ingredient for <strong>other </strong>recipes, i.e., <code>ingredients[i]</code> may contain a string that is in <code>recipes</code>.</p>

<p>You are also given a string array <code>supplies</code> containing all the ingredients that you initially have, and you have an infinite supply of all of them.</p>

<p>Return <em>a list of all the recipes that you can create. </em>You may return the answer in <strong>any order</strong>.</p>

<p>Note that two recipes may contain each other in their ingredients.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;corn&quot;]
<strong>Output:</strong> [&quot;bread&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]
<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
We can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;],[&quot;sandwich&quot;,&quot;meat&quot;,&quot;bread&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]
<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;]
<strong>Explanation:</strong>
We can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.
We can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.
We can create &quot;burger&quot; since we have the ingredient &quot;meat&quot; and can create the ingredients &quot;bread&quot; and &quot;sandwich&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == recipes.length == ingredients.length</code></li>
	<li><code>1 &lt;= n &lt;= 100</code></li>
	<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>
	<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>
	<li><code>recipes[i], ingredients[i][j]</code>, and <code>supplies[k]</code> consist only of lowercase English letters.</li>
	<li>All the values of <code>recipes</code> and <code>supplies</code>&nbsp;combined are unique.</li>
	<li>Each <code>ingredients[i]</code> does not contain any duplicate values.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Let's first try to equate our problem to a real-world cooking scenario. Imagine you have a kitchen stocked with basic ingredients and a cookbook filled with recipes. Each recipe specifies the exact ingredients needed to prepare it. Some recipes are simple, requiring only basic ingredients, while others are more complex, needing not just raw ingredients but also other prepared dishes as part of their recipe. Our goal is to determine which recipes can be made using the given set of available ingredients.</p>
<p>At first glance, this might seem straightforward. If we have all the ingredients listed for a recipe, we can make it. However, the problem becomes more complex when recipes depend on other recipes. Suppose Recipe A requires Recipe B, but Recipe B itself needs Recipe C, and Recipe C, in turn, depends on Recipe A. This creates a circular dependency, making it unclear where to begin. If we do not account for these dependencies properly, we could end up in an infinite loop, never determining which recipes can actually be made. Our approach needs to handle these interdependencies properly.</p>
<hr />
<h3 id="approach-1-breadth-first-search-bfs">Approach 1: Breadth-First Search (BFS)</h3>
<h4 id="intuition">Intuition</h4>
<p>One straightforward way to solve this problem is to make new recipes in rounds using our available ingredients. During each round, we check every recipe and ask, &quot;Can we make this recipe with what we have?&quot; If we can, we make it; if we can't, we'll try again later.</p>
<p>Let's break down how to write code for this approach. First, we need to track all our available ingredients. Since we'll frequently check if we have specific ingredients, we should use a data structure that allows quick lookups. A hash set is perfect for this because it lets us check and add ingredients almost instantly.</p>
<p>Next, we need a way to manage the recipes we want to attempt. We can use a queue to keep track of the recipes that we still need to process. Initially, the queue contains all the recipes since none have been prepared yet.</p>
<p>Now, we start processing the recipes. For each recipe in the queue, we check if all its required ingredients are available. If they are, we mark the recipe as completed and add it to our list of available ingredients, making it usable for other recipes. If we can't make a recipe yet, we put it back in the queue and try again in the next round.</p>
<p>But how do we know when to stop? Before each round, we note how many ingredients we have. If, after processing all recipes in the queue, the ingredient count has increased, it means we’ve made progress and should continue. However, if the ingredient count remains unchanged, it means no more recipes can be made, and we return the list of completed recipes.</p>
<p>Notice how this approach handles dependencies. If Recipe A depends on Recipe B, but we haven't made Recipe B yet, Recipe A remains in the queue. Later, once we successfully prepare Recipe B, Recipe A will have all the required ingredients and can be processed. This natural progression handles even complex dependency chains.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Create a hash set <code>available</code> to track all available items.</li>
<li>Add each supply from the <code>supplies</code> array into the <code>available</code> set.</li>
<li>Create a Queue <code>recipeQueue</code> to store recipe indices.</li>
<li>Add indices from <code>0</code> to <code>recipes.length-1</code> into the <code>recipeQueue</code>.</li>
<li>Initialize:
<ul>
<li>a list <code>createdRecipes</code> to store the final result.</li>
<li>a variable <code>lastSize</code> to <code>-1</code>.</li>
</ul>
</li>
<li>While the size of <code>available</code> is greater than <code>lastSize</code>:
<ul>
<li>Set <code>lastSize</code> to the current size of <code>available</code>.</li>
<li>Set a variable <code>queueSize</code> to the size of <code>recipeQueue</code>.</li>
<li>While <code>queueSize</code> is greater than <code>0</code>:
<ul>
<li>Decrement <code>queueSize</code>.</li>
<li>Remove the front element from <code>recipeQueue</code> and put it in a variable <code>recipeIdx</code>.</li>
<li>Set a boolean <code>canCreate</code> to <code>true</code>.</li>
<li>For each <code>ingredient</code> in <code>ingredients[recipeIdx]</code>:
<ul>
<li>If <code>ingredient</code> is not present in the <code>available</code> set:
<ul>
<li>Set <code>canCreate</code> to <code>false</code> and break out of the loop.</li>
</ul>
</li>
<li>If <code>canCreate</code> is <code>false</code>:
<ul>
<li>Add <code>recipeIdx</code> back to <code>recipeQueue</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Add <code>recipes[recipeIdx]</code> to the <code>available</code> set and the <code>createdRecipes</code> list.</li>
</ul>
</li>
<li>Decrease <code>count</code> by <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>createdRecipes</code> as the answer.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hHVZHDUF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot m + s)\)</span></p>
<p>Initially, all supplies are inserted into a set in <span class="math inline">\(O(s)\)</span> time.</p>
<p>In the worst case, a recipe may be reprocessed up to <span class="math inline">\(O(n)\)</span> times—each time it’s checked, it might still be uncreatable and gets added back to the queue. Since there are <span class="math inline">\(n\)</span> recipes, and checking whether a recipe is creatable involves scanning all its ingredients (which takes up to <span class="math inline">\(O(m)\)</span> per recipe), this leads to a worst-case bound of <span class="math inline">\(O(n^2 \cdot m)\)</span> for repeatedly checking recipe feasibility.</p>
<p>Additionally, set insertion and membership checks are <span class="math inline">\(O(1)\)</span> on average and do not significantly impact the total complexity.</p>
<p>Therefore, the total time complexity is <span class="math inline">\(O(n^2 \cdot m + s)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + s)\)</span></p>
<p>The algorithm maintains a set to store available ingredients, which can grow up to <span class="math inline">\(O(n + s)\)</span>. The queue holds up to <span class="math inline">\(O(n)\)</span> elements, and we use no additional structures beyond these. Thus, the overall space complexity is <span class="math inline">\(O(n + s)\)</span>. We do not consider the output space as part of our analysis.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search-dfs">Approach 2: Depth-First Search (DFS)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In our previous approach, we gathered as many recipes as we could make with the current set of ingredients in each iteration and then proceeded to find further recipes in the next iteration, mimicking a BFS approach. Let's try a different way.</p>
<p>Think about how you would actually make a recipe in real life. When you check your ingredients, you might find that one of them is actually another recipe you need to make first. Naturally, you'd pause your main recipe to figure out how to make this sub-recipe. This thought process matches perfectly with a depth-first search (DFS) solution.</p>
<p>Since our task is to find the number of recipes we can make from the given list, let's create a function <code>checkRecipe</code> which returns <code>true</code> if we can make the recipe. To check if we can, we go over the list of ingredients. Let's say we come across an ingredient that is itself another recipe. We can now use the <code>checkRecipe</code> function recursively to check if the recipe can be made, and then in turn, used as an ingredient to make the parent recipe.</p>
<p>However, there's a challenging aspect to this problem: circular dependencies. Here's a simple example:</p>
<ul>
<li>Recipe A requires Recipe B to make it.</li>
<li>Recipe B requires Recipe C to make it.</li>
<li>Recipe C requires Recipe A to make it.</li>
</ul>
<p>Without proper safeguards, our code could get stuck in an endless loop. To prevent this, we keep track of which recipes we're currently checking in a <code>visited</code> set. As we explore each recipe's dependencies, we mark it as visited. If we encounter a recipe that's already in our <code>visited</code> set, we know we've found a cycle and can immediately determine that the recipe isn't possible to make.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a list <code>possibleRecipes</code> to store the recipes that can be made.</li>
<li>a hash map <code>canMake</code> to track if an ingredient/recipe can be made, mapping from the name to a boolean value.</li>
<li>a hash map <code>recipeToIndex</code> to store the mapping from a recipe name to its index in the ingredients list.</li>
</ul>
</li>
<li>Loop through all the initial <code>supplies</code> and mark each one as available (<code>true</code>) in the <code>canMake</code> map.</li>
<li>Loop through all the <code>recipes</code> and create a mapping from each recipe name to its index in the <code>recipeToIndex</code> map.</li>
<li>For each <code>recipe</code> in the <code>recipes</code> array:
<ul>
<li>Call the <code>checkRecipe</code> function with the current <code>recipe</code>.</li>
<li>If the <code>recipe</code> can be made (<code>true</code> in <code>canMake</code>), add it to the <code>possibleRecipes</code> list.</li>
</ul>
</li>
<li>Return the list of possible recipes.</li>
</ul>
<p>Helper method <code>checkRecipe(recipe, ingredients, visited, canMake, recipeToIndex)</code>:</p>
<ul>
<li>If the recipe is already marked as makeable (<code>true</code>) in <code>canMake</code>, return immediately.</li>
<li>If the recipe doesn't exist in the <code>recipeToIndex</code> map or is already in the <code>visited</code> set (indicating a cycle), mark it as unmakeable (<code>false</code>) and return.</li>
<li>Add the current <code>recipe</code> to the <code>visited</code> set.</li>
<li>Get the list of required ingredients for the current recipe using its index.</li>
<li>For each <code>ingredient</code> in the required ingredients:
<ul>
<li>Recursively call <code>checkRecipe</code> on the <code>ingredient</code>.</li>
<li>If the ingredient cannot be made (<code>false</code> in <code>canMake</code>), mark the current <code>recipe</code> as unmakeable (<code>false</code>) and return.</li>
</ul>
</li>
<li>After checking all ingredients successfully, mark the current <code>recipe</code> as makeable (<code>true</code>).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/WjdwJagJ/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>The algorithm uses DFS to check each recipe's ingredients. Initially, we process supplies and create recipe mappings in <span class="math inline">\(O(s)\)</span> and <span class="math inline">\(O(n)\)</span> time, respectively. For each recipe, we perform DFS through its ingredients, visiting each ingredient exactly once due to the <code>visited</code> set preventing cycles. Since we memoize results in the <code>canMake</code> map, each ingredient and recipe is processed at most once across all DFS calls. Therefore, the total number of operations is proportional to the number of recipes plus the total number of ingredients, giving us <span class="math inline">\(O(n + m + s)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + s)\)</span></p>
<p>The solution utilizes several key data structures that contribute to its space requirements. The hash map <code>canMake</code> initially stores supply information, requiring <span class="math inline">\(O(s)\)</span> space. The dictionary <code>recipeToIndex</code> maps recipes to indices, using <span class="math inline">\(O(n)\)</span> space. For cycle detection, the <code>visited</code> set and the result list <code>possibleRecipes</code> each take <span class="math inline">\(O(n)\)</span> space. The recursion stack depth in the worst case is bounded by the number of recipes rather than all ingredients, contributing at most <span class="math inline">\(O(n)\)</span> space. Since all operations and structures operate primarily on recipes, the total auxiliary space complexity is <strong><span class="math inline">\(O(n + s)\)</span></strong>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-topological-sort-kahns-algorithm">Approach 3: Topological Sort (Kahn's Algorithm)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Our previous solutions had some drawbacks. The BFS approach kept trying recipes repeatedly until we couldn't make any more, which could be slow when recipes had complex dependencies. While the DFS solution handled dependencies well, it needed careful tracking to avoid infinite loops. Let's explore a more organized approach using something called topological sorting.</p>
<p>Making recipes is really about the order we make them, since some recipes must be created before others. We can think of this like a map where arrows point from one recipe to another, showing what needs to be made first. Topological sorting is perfect for solving this kind of problem because it's designed to handle these &quot;what comes first&quot; relationships.</p>
<p>Instead of constantly checking which ingredients a recipe needs, we can reverse our perspective. Instead of focusing on what each recipe depends on, we track which recipes depend on a given ingredient. This shift in thinking allows us to process recipes in an optimal order i.e., whenever a new recipe is made, we immediately know which other recipes can now be completed.</p>
<p>The most important component of the topological sorting algorithm is the <code>inDegree</code> array. For each recipe, this array counts how many ingredients we still need to find. Here's what that means:</p>
<ol>
<li>If a recipe has an in-degree of zero, it means all of its required ingredients are already available, and we can make it immediately.</li>
<li>Each time we complete a recipe, it becomes available as an ingredient for other recipes, so we decrease the in-degree of all recipes that depend on it.</li>
<li>When a recipe’s in-degree reaches zero, it becomes the next recipe we can make.</li>
</ol>
<p>Here's how the <code>inDegree</code> array would look for Example 3 of the problem description:</p>
<p><img src="../Figures/2115/indegree.png" alt="indegree array" /></p>
<p>To implement the algorithm, we first create the dependency graph and populate the <code>inDegree</code> array. For each recipe, we iterate over its ingredients and add a directed edge from each ingredient to the recipe, but only if the ingredient is not already available in the initial supplies. This ensures that the in-degree of a recipe reflects only the number of unavailable ingredients it depends on.</p>
<p>Then, we iterate over each recipe using a queue and try to resolve the dependencies. Initially, we add to the queue all recipes that have an in-degree of zero, meaning they only require ingredients from our supplies and don't depend on any other recipes. As we complete each recipe, it becomes available as an ingredient for other recipes, so decrease the in-degree of all its dependent recipes by one. When all required ingredients for a recipe become available (its in-degree reaches zero), we can make that recipe too. It also becomes an ingredient by itself, so we add it to the queue.</p>
<p>We keep track of each recipe we make in a list called <code>createdRecipes</code>. When the queue is empty and all dependencies have been resolved, we return this list as our answer.</p>
<blockquote>
<p>For a more comprehensive understanding of Topological Sorting, check out the <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">Topological Sort Explore Card</a>. This resource provides an in-depth look at topological sorting, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize:
<ul>
<li>a hash set <code>availableSupplies</code> to store the initial supplies.</li>
<li>a hash map <code>recipeToIndex</code> to store the mapping from recipe names to their indices.</li>
<li>a hash map <code>dependencyGraph</code> to store which recipes depend on each ingredient.</li>
</ul>
</li>
<li>Loop through all the supplies and add each one to the <code>availableSupplies</code> set.</li>
<li>Loop through all the recipes and create a mapping from each recipe to its corresponding index.</li>
<li>Initialize an array <code>inDegree</code> to track the count of remaining ingredients needed for each recipe.</li>
</ul>
<p>To build the dependency graph:</p>
<ul>
<li>For each recipe:
<ul>
<li>For each <code>ingredient</code> in the current recipe:
<ul>
<li>If the <code>ingredient</code> is not in the available supplies, add it to the <code>dependencyGraph</code> if not present.</li>
<li>Add the current recipe to the list of recipes that need this ingredient.</li>
<li>Increment the <code>inDegree</code> count for the current recipe.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For finding makeable recipes:</p>
<ul>
<li>Initialize a <code>queue</code> to store the indices of recipes that can be made immediately.</li>
<li>Loop through all the <code>recipes</code>:
<ul>
<li>If a recipe's <code>inDegree</code> is zero (only needs available supplies), add it to the <code>queue</code>.</li>
</ul>
</li>
<li>Initialize a list <code>createdRecipes</code> to store the result</li>
<li>While the <code>queue</code> is not empty:
<ul>
<li>Get the next recipe index from the <code>queue</code>.</li>
<li>Get the recipe name using the index.</li>
<li>Add the recipe to the <code>createdRecipes</code> list.</li>
<li>If no other recipes depend on this recipe, continue to the next iteration.</li>
<li>For each recipe that depends on the current recipe:
<ul>
<li>Decrease its <code>inDegree</code> count by one.</li>
<li>If the <code>inDegree</code> becomes zero, add it to the queue.</li>
</ul>
</li>
</ul>
</li>
<li>Return the list of created recipes.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/dUEVdEvN/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of recipes, <span class="math inline">\(m\)</span> be the total number of ingredients across all recipes, and <span class="math inline">\(s\)</span> be the number of supplies.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>Initially, we process all supplies to mark them as available, taking <span class="math inline">\(O(s)\)</span> time. Then we create recipe mappings in <span class="math inline">\(O(n)\)</span> time. Building the dependency graph requires examining each ingredient for each recipe once, taking <span class="math inline">\(O(m)\)</span> time. When processing recipes in topological order, we visit each recipe once and process its dependencies. Since each ingredient-to-recipe edge in the dependency graph is processed exactly once, and the total number of such edges is bounded by <span class="math inline">\(m\)</span>, the queue processing takes <span class="math inline">\(O(n + m)\)</span> time. Therefore, the total time complexity is <span class="math inline">\(O(n + m + s)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + m + s)\)</span></p>
<p>The algorithm uses several auxiliary data structures to track the recipe creation process. We use a hash set to store available supplies and a hash map to maintain recipe indices taking <span class="math inline">\(O(s)\)</span> and <span class="math inline">\(O(n)\)</span> space respectively. The core of our space usage comes from the dependency graph, which stores ingredient-to-recipe relationships and could grow up to <span class="math inline">\(O(m)\)</span> size. Additional structures include an array for tracking ingredient counts per recipe (<span class="math inline">\(O(n)\)</span>), a queue for our topological sort (<span class="math inline">\(O(n)\)</span>), and a list for storing our final results (<span class="math inline">\(O(n)\)</span>). When we combine all these components, our total auxiliary space requirement becomes <span class="math inline">\(O(n + m + s)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-eventual-safe-states/description" target="_blank" rel="noopener noreferrer">Find Eventual Safe States</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a <strong>0-indexed</strong> 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes adjacent to node <code>i</code>, meaning there is an edge from node <code>i</code> to each node in <code>graph[i]</code>.</p>

<p>A node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a <strong>terminal node</strong> (or another safe node).</p>

<p>Return <em>an array containing all the <strong>safe nodes</strong> of the graph</em>. The answer should be sorted in <strong>ascending</strong> order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="Illustration of graph" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" style="height: 171px; width: 600px;" />
<pre>
<strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]]
<strong>Output:</strong> [2,4,5,6]
<strong>Explanation:</strong> The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
<strong>Output:</strong> [4]
<strong>Explanation:</strong>
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= graph[i].length &lt;= n</code></li>
	<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>
	<li><code>graph[i]</code> is sorted in a strictly increasing order.</li>
	<li>The graph may contain self-loops.</li>
	<li>The number of edges in the graph will be in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes that have an incoming edge from node <code>i</code>.</p>
<p>The problem states that a node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a <strong>safe node</strong> if every possible path starting from that node leads to a terminal node (or another safe node).</p>
<p>Our task is to return a sorted array of all the safe nodes of the graph.</p>
<hr />
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the problem, we must first consider when a node is safe or unsafe. If we begin at any node and proceed along any path from that node, we will eventually reach either a terminal node or enter a cycle and continue to loop in it without ever reaching a terminal node.</p>
<p>If there is no path from the node that enters a cycle, we will always be able to reach a terminal node. As a result, such a node is a safe node and should be added to our answer array.</p>
<blockquote>
<p>The problem is reduced to finding the nodes that do not have any paths that lead to a cycle.</p>
</blockquote>
<p>Intuitively, we can realize that a node is safe if all of its outgoing edges are to nodes that are also safe. This is due to the fact that if no neighbor leads to a cycle, no path from the node can either.</p>
<p>We know the terminal nodes are safe. As a result, nodes that solely have outgoing edges to terminal nodes are eventually safe nodes. Then we may check the nodes that have just outgoing edges to safe nodes again and keep updating until no new safe node is discovered.</p>
<p>The question is, how do we efficiently traverse from terminal nodes to nodes that only have outgoing edges to terminal nodes? We can reverse the edges of the graph to create a new graph with reversed edges. After we have visited all of the terminal nodes, we can use this new graph to go to the nodes that have edges to the terminal nodes in the original graph by using the reverse edges that we added.</p>
<p>Let's put this new graph to use now. A node is a safe node if all of its incoming edges come from previously identified safe nodes in the graph. If we erase the edges outgoing from the safe node and discover a node with no incoming edges, it is a new safe node. This gives us hints for thinking about Kahn's method, which does a topological sort by removing the edges in the exact way we want.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahn’s algorithm works by keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/">LeetCode Explore Card</a>.</p>
<p>The advantage of using Kahn's technique is that it also aids in the discovery of graph cycles. The Kahn's method does not visit any node in a cycle. As a result, nodes with outgoing edges from nodes in the cycle (in this reversed graph) will never be visited and so will never be marked safe. Nodes with outgoing edges from these unsafe nodes will never be visited as well, and so on. Basically, every node in the original network that has a path to the cycle will never be visited by Kahn's algorithm, which is exactly what we want.</p>
<p>Let's perform Kahn's algorithm on a directed graph having a cycle. Here's a visual step-by-step representation of how it would work:</p>
<p><img src="../Figures/802/802-1.png" alt="img" /></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic dependency. We are unable to visit the cycle's nodes. We are also unable to visit any node with an incoming edge from any node in the cycle. Similarly, realize that any node with an incoming edge from nodes <code>3</code> or <code>5</code> would not have been visited as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an integer <code>n</code> equal to the length of <code>graph</code> to get the number of nodes in the given graph.</li>
<li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number of edges entering node <code>x</code>.</li>
<li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by iterating over <code>graph</code> and adding the <strong>reverse edges</strong>. For a node <code>i</code> which originally has outgoing edges to nodes in <code>graph[i]</code>, we push <code>i</code> into <code>adj[node]</code> to add a reverse edge from <code>node</code> to <code>i</code>.</li>
<li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent nodes.</li>
<li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the queue.</li>
<li>Create a boolean array <code>safe</code> of size <code>n</code> to track the safe nodes in the graph.</li>
<li>While the queue is not empty;
<ul>
<li>Dequeue the first <code>node</code> from the queue.</li>
<li>Mark <code>node</code> as safe.</li>
<li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of <code>node</code>, we decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node -&gt; neighbor</code> edge.</li>
<li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so we push <code>neighbor</code> in the queue.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FWjfs3PY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>adj</code> list takes <span class="math inline">\(O(m)\)</span> time as we go through all the edges. The <code>indegree</code> array take <span class="math inline">\(O(n)\)</span> time.</li>
<li>Initializing the boolean <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> time.</li>
<li>Each queue operation takes <span class="math inline">\(O(1)\)</span> time, and a single node will be pushed once, leading to <span class="math inline">\(O(n)\)</span> operations for <span class="math inline">\(n\)</span> nodes. We iterate over the neighbors of each node that is popped out of the queue iterating over all the edges once. Since there are total of <code>m</code> edges, it would take <span class="math inline">\(O(m)\)</span> time to iterate over the edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>The <code>adj</code> arrays takes <span class="math inline">\(O(m)\)</span> space. The <code>indegree</code> array takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The <code>safe</code> array also takes <span class="math inline">\(O(n)\)</span> space.</li>
<li>The queue can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use a depth-first search (DFS) traversal to detect the nodes that lead to a cycle, i.e., unsafe nodes.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>A node remains in the DFS recursion stack until all of its branches (all nodes in its subtree) have not been explored. When we have examined all of a node's branches, i.e. visited all of the nodes in its subtree, the node is removed from the DFS recursive stack.</p>
<p>If you are new to Depth First Search, please see our <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/">Leetcode Explore Card</a> for more information on it!</p>
<p>To find the unsafe nodes, we must first recognize a cycle in the graph. If we find a cycle, we will mark all of the nodes in the cycle as unsafe and then go back and mark all of the nodes that led to this cycle as unsafe. Let's find a cycle first.</p>
<p>If the graph has a cycle, we must have a <strong>back edge</strong> connecting a node to one of its ancestors while traversing nodes in the DFS manner.</p>
<p>Let's think how we can establish whether or not a node's neighbor is an ancestor when navigating from one node to another.</p>
<p>If the neighboring node has not yet been visited, it cannot be an ancestor (it is a child node).</p>
<p>Otherwise, if a neighboring node is visited, it may or may not be an ancestor. If the neighboring node is an ancestor, i.e. there is a back edge, it means that we visited this ancestor node first in the DFS traversal, then visited and explored some other nodes, and eventually visited a node that connects back to the ancestor node. As we are still exploring the ancestor node's subtree while iterating over this path, hence this node must be in the current DFS recursive stack.</p>
<p>However, if a neighboring node is visited but not in the recursion stack, it signifies we have previously explored that node in a different branch, and it does not form a cycle in the current branch.</p>
<p>As a result, to detect the cycle we must keep track of the visited nodes (like in a normal DFS) and also the nodes in the function's recursion call stack for DFS traversal. The nodes in the stack store the current path that we are on. There is a cycle in the graph if a node is reached that is already in the recursion stack. We use a boolean array <code>inStack</code> of length <code>n</code> to track which nodes are in the call stack so we can check if a node exists in <span class="math inline">\(O(1)\)</span>. Note that this <code>inStack</code> array is emulating the call stack that the computer is using under the hood to execute recursion. We mark an unvisited node in <code>inStack</code> when we make a recursive call to it and then unmark it when we return from that call.</p>
<p>Now that we've identified the cycle, let's look for the unsafe nodes. When we get a cycle, all of the nodes in the recursion stack either form or lead to a cycle. If we start a DFS traversal from node <code>1</code> in a graph <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 2</code>, nodes <code>2</code>, <code>3</code>, and <code>4</code> form a cycle. When we discovered this cycle, node <code>1</code> was also in the stack. So, when we have a cycle, all the nodes in the recursion stack are unsafe since they form or lead to a loop.</p>
<p>In addition to detecting cycles, we can use the same <code>inStack</code> array to store the unsafe nodes. We do not unmark any of the unsafe nodes from <code>inStack</code> to keep track of them. When any <code>node</code> has an outgoing edge to any of the unsafe nodes, we can immediately return the DFS call for <code>node</code> without unmarking it from <code>inStack</code>, i.e, we do not perform <code>inStack[node] = false</code>. This is because if any <code>neighbor</code> of <code>node</code> is marked <code>inStack</code>, it signifies that either <code>neighbor</code> and <code>node</code> are part of a cycle or <code>neighbor</code> is a previously detected unsafe node. In both the cases, <code>node</code> is also an unsafe node and hence we return the DFS call without unmarking <code>node</code> from <code>inStack</code>.</p>
<p>We only unmark a node from <code>inStack</code>, if we have explored all of its branches and no branch leads to an unsafe node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<blockquote>
<p>Here, we can use the input graph as the adjacency list <code>adj</code></p>
</blockquote>
<ol>
<li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code> array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the ongoing DFS stack. It will help us to detect a cycle in the graph and the unsafe nodes.</li>
<li>For each node we begin a DFS traversal. We implement the <code>dfs</code> method which takes four parameters: an integer <code>node</code> from which the current traversal begins, <code>adj</code>, <code>visit</code>, and <code>inStack</code>. It returns a boolean indicating whether <code>node</code> is unsafe. We perform the following in this method:
<ul>
<li>If <code>node</code> is already present in <code>inStack</code>, either we just got a cycle or a previously detected unsafe node. We return <code>true</code> in this case as the <code>node</code> is unsafe.</li>
<li>If <code>node</code> is already visited (but not in <code>inStack</code>), we return <code>false</code> because we already visited this <code>node</code> and didn't find it as unsafe node. It is a safe node.</li>
<li>We mark <code>node</code> as visited and also mark it in <code>inStack</code> (<code>inStack[node] = true</code>).</li>
<li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we recursively call <code>dfs(neighbor, adj, visit, inStack)</code>. If we get a cycle from <code>neighbor</code> (or <code>neighbor</code> is a previously detected unsafe node), we return <code>true</code> without unmarking <code>node</code> in <code>inStack</code>.</li>
<li>After we have processed all the outgoing edges of <code>node</code>, we mark <code>inStack[node] = false</code> to mark <code>node</code> as safe. We return <code>false</code>.</li>
</ul>
</li>
<li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>, i.e., the nodes with <code>inStack[node] == false</code>.</li>
<li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/V99UanNc/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(n\)</span> is the number of nodes and <span class="math inline">\(m\)</span> is number of edges in the graph.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Initializing the <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> time each.</li>
<li>The <code>dfs</code> function handles each node once, which takes <span class="math inline">\(O(n)\)</span> time in total. From each node, we iterate over all the outgoing edges, which further takes <span class="math inline">\(O(m)\)</span> time to iterate over all the edges as there are a total of <code>m</code> edges.</li>
<li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span class="math inline">\(O(n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<ul>
<li>The <code>visit</code> and <code>inStack</code> arrays take <span class="math inline">\(O(n)\)</span> space each.</li>
<li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math inline">\(n\)</span> elements in the worst-case scenario. It would take up <span class="math inline">\(O(n)\)</span> space in that case.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/frequencies-of-shortest-supersequences/description" target="_blank" rel="noopener noreferrer">Frequencies of Shortest Supersequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of strings <code>words</code>. Find all <strong>shortest common supersequences (SCS)</strong> of <code><font face="monospace">words</font></code> that are not <span data-keyword="permutation-string">permutations</span> of each other.</p>

<p>A <strong>shortest common supersequence</strong> is a string of <strong>minimum</strong> length that contains each string in <code>words</code> as a <span data-keyword="subsequence-string-nonempty">subsequence</span>.</p>

<p>Return a 2D array of integers <code>freqs</code> that represent all the SCSs. Each <code>freqs[i]</code> is an array of size 26, representing the frequency of each letter in the lowercase English alphabet for a single SCS. You may return the frequency arrays in any order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;ab&quot;,&quot;ba&quot;]</span></p>

<p><strong>Output: </strong>[[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p>The two SCSs are <code>&quot;aba&quot;</code> and <code>&quot;bab&quot;</code>. The output is the letter frequencies for each one.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = [&quot;aa&quot;,&quot;ac&quot;]</span></p>

<p><strong>Output: </strong>[[2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p>The two SCSs are <code>&quot;aac&quot;</code> and <code>&quot;aca&quot;</code>. Since they are permutations of each other, keep only <code>&quot;aac&quot;</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">words = </span>[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</p>

<p><strong>Output: </strong>[[2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]</p>

<p><strong>Explanation:</strong></p>

<p><code>&quot;aabbcc&quot;</code> and all its permutations are SCSs.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 256</code></li>
	<li><code>words[i].length == 2</code></li>
	<li>All strings in <code>words</code> will altogether be composed of no more than 16 unique lowercase letters.</li>
	<li>All strings in <code>words</code> are unique.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-color-value-in-a-directed-graph/description" target="_blank" rel="noopener noreferrer">Largest Color Value in a Directed Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>

<p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>

<p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>

<p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;" /></p>

<pre>
<strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is a cycle from 0 to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == colors.length</code></li>
	<li><code>m == edges.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>
	<li><code>colors</code> consists of lowercase English letters.</li>
	<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-cycle-in-a-graph/description" target="_blank" rel="noopener noreferrer">Longest Cycle in a Graph</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>

<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from node <code>i</code>, then <code>edges[i] == -1</code>.</p>

<p>Return <em>the length of the <strong>longest</strong> cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>

<p>A cycle is a path that starts and ends at the <strong>same</strong> node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png" style="width: 335px; height: 191px;" />
<pre>
<strong>Input:</strong> edges = [3,3,4,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest cycle in the graph is the cycle: 2 -&gt; 4 -&gt; 3 -&gt; 2.
The length of this cycle is 3, so 3 is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png" style="width: 171px; height: 161px;" />
<pre>
<strong>Input:</strong> edges = [2,-1,3,1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == edges.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>-1 &lt;= edges[i] &lt; n</code></li>
	<li><code>edges[i] != i</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-increasing-path-in-a-matrix/description" target="_blank" rel="noopener noreferrer">Longest Increasing Path in a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>

<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 200</code></li>
	<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-path-with-different-adjacent-characters/description" target="_blank" rel="noopener noreferrer">Longest Path With Different Adjacent Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">string</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">tree</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>tree</strong> (i.e. a connected, undirected graph that has no cycles) <strong>rooted</strong> at node <code>0</code> consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>. The tree is represented by a <strong>0-indexed</strong> array <code>parent</code> of size <code>n</code>, where <code>parent[i]</code> is the parent of node <code>i</code>. Since node <code>0</code> is the root, <code>parent[0] == -1</code>.</p>

<p>You are also given a string <code>s</code> of length <code>n</code>, where <code>s[i]</code> is the character assigned to node <code>i</code>.</p>

<p>Return <em>the length of the <strong>longest path</strong> in the tree such that no pair of <strong>adjacent</strong> nodes on the path have the same character assigned to them.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png" style="width: 201px; height: 241px;" />
<pre>
<strong>Input:</strong> parent = [-1,0,0,1,1,2], s = &quot;abacbe&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -&gt; 1 -&gt; 3. The length of this path is 3, so 3 is returned.
It can be proven that there is no longer path that satisfies the conditions. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png" style="width: 201px; height: 221px;" />
<pre>
<strong>Input:</strong> parent = [-1,0,0,0], s = &quot;aabc&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest path where each two adjacent nodes have different characters is the path: 2 -&gt; 0 -&gt; 3. The length of this path is 3, so 3 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == parent.length == s.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= parent[i] &lt;= n - 1</code> for all <code>i &gt;= 1</code></li>
	<li><code>parent[0] == -1</code></li>
	<li><code>parent</code> represents a valid tree.</li>
	<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/loud-and-rich/description" target="_blank" rel="noopener noreferrer">Loud and Rich</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a group of <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> where each person has a different amount of money and a different level of quietness.</p>

<p>You are given an array <code>richer</code> where <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that <code>a<sub>i</sub></code> has more money than <code>b<sub>i</sub></code> and an integer array <code>quiet</code> where <code>quiet[i]</code> is the quietness of the <code>i<sup>th</sup></code> person. All the given data in richer are <strong>logically correct</strong> (i.e., the data will not lead you to a situation where <code>x</code> is richer than <code>y</code> and <code>y</code> is richer than <code>x</code> at the same time).</p>

<p>Return <em>an integer array </em><code>answer</code><em> where </em><code>answer[x] = y</code><em> if </em><code>y</code><em> is the least quiet person (that is, the person </em><code>y</code><em> with the smallest value of </em><code>quiet[y]</code><em>) among all people who definitely have equal to or more money than the person </em><code>x</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
<strong>Output:</strong> [5,5,2,5,4,5,6,7]
<strong>Explanation:</strong> 
answer[0] = 5.
Person 5 has more money than 3, which has more money than 1, which has more money than 0.
The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.
answer[7] = 7.
Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.
The other answers can be filled out with similar reasoning.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> richer = [], quiet = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == quiet.length</code></li>
	<li><code>1 &lt;= n &lt;= 500</code></li>
	<li><code>0 &lt;= quiet[i] &lt; n</code></li>
	<li>All the values of <code>quiet</code> are <strong>unique</strong>.</li>
	<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>
	<li>All the pairs of <code>richer</code> are <strong>unique</strong>.</li>
	<li>The observations in <code>richer</code> are all logically consistent.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-cached-depth-first-search-accepted">Approach #1: Cached Depth-First Search [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Consider the directed graph with edge <code>x -&gt; y</code> if <code>y</code> is richer than <code>x</code>.</p>
<p>For each person <code>x</code>, we want the quietest person in the subtree at <code>x</code>.</p>
<p><strong>Algorithm</strong></p>
<p>Construct the graph described above, and say <code>dfs(person)</code> is the quietest person in the subtree at <code>person</code>.   Notice because the statements are logically consistent, the graph must be a DAG - a directed graph with no cycles.</p>
<p>Now <code>dfs(person)</code> is either <code>person</code>, or <code>min(dfs(child) for child in person)</code>.  That is to say, the quietest person in the subtree is either the <code>person</code> itself, or the quietest person in some subtree of a child of <code>person</code>.</p>
<p>We can cache values of <code>dfs(person)</code> as <code>answer[person]</code>, when performing our <em>post-order traversal</em> of the graph.  That way, we don't repeat work.  This technique reduces a quadratic time algorithm down to linear time.</p>
<p><a href="https://leetcode.com/playground/UXq5wv8E/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity: <span class="math inline">\(\mathcal{O}(N^2)\)</span>, where <span class="math inline">\(N\)</span> is the number of people.<br />
We are iterating here over array <code>richer</code>. It could contain up to</li>
</ul>
<p><span class="math display">\[when each new person is richer than the previous one.  

* Space Complexity: $$\mathcal{O}(N^2)$$, to keep the graph with $$N^2$$ edges.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description" target="_blank" rel="noopener noreferrer">Maximum Employees to Be Invited to a Meeting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A company is organizing a meeting and has a list of <code>n</code> employees, waiting to be invited. They have arranged for a large <strong>circular</strong> table, capable of seating <strong>any number</strong> of employees.</p>

<p>The employees are numbered from <code>0</code> to <code>n - 1</code>. Each employee has a <strong>favorite</strong> person and they will attend the meeting <strong>only if</strong> they can sit next to their favorite person at the table. The favorite person of an employee is <strong>not</strong> themself.</p>

<p>Given a <strong>0-indexed</strong> integer array <code>favorite</code>, where <code>favorite[i]</code> denotes the favorite person of the <code>i<sup>th</sup></code> employee, return <em>the <strong>maximum number of employees</strong> that can be invited to the meeting</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex1.png" style="width: 236px; height: 195px;" />
<pre>
<strong>Input:</strong> favorite = [2,2,1,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.
All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.
Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.
The maximum number of employees that can be invited to the meeting is 3. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> favorite = [1,2,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.
The seating arrangement will be the same as that in the figure given in example 1:
- Employee 0 will sit between employees 2 and 1.
- Employee 1 will sit between employees 0 and 2.
- Employee 2 will sit between employees 1 and 0.
The maximum number of employees that can be invited to the meeting is 3.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex2.png" style="width: 219px; height: 220px;" />
<pre>
<strong>Input:</strong> favorite = [3,0,1,4,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.
Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.
So the company leaves them out of the meeting.
The maximum number of employees that can be invited to the meeting is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == favorite.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>
	<li><code>favorite[i] != i</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>A company is planning a round table meeting for a group of employees who will only come if they can sit next to their favorite coworker at the circular table. Given the number of people the company hopes will attend and each employee's favorite coworker, we must return the largest number of people who can attend while sticking to the requirement that each person must be seated next to their favorite coworker.</p>
<p>At this point, we can observe that the problem can be seen as a directed graph where each employee points to their favorite person. The key observation here is that this graph has cycles, and those cycles are important because any group of employees in a cycle can sit next to each other in the meeting. So, detecting these cycles will be central to solving the problem.</p>
<p>However, we also need to account for the fact that there might be chains of employees, not forming cycles by themselves, but who are connected in such a way that they can potentially be linked to form a larger cycle. This gives us the idea that even if a group of employees doesn’t form a cycle initially, they might still be part of a larger group that can be arranged in a circle.</p>
<p>A final thing to note is that the circular nature of the seating arrangement may influence how you connect the employees, especially when identifying 'groups' or 'cycles' that can sit next to each other.</p>
<p>We have two main types of structures that can form when we try to seat employees based on their favorite people:</p>
<ol>
<li>
<p><strong>A one-way connected cycle</strong>: This is where employees form a directed chain, like <code>a -&gt; b -&gt; c -&gt; d -&gt; a</code>. This means each person’s favorite is part of a larger cycle, and everyone must sit next to someone else in the cycle. These cycles will only be able to seat as many employees as the cycle's size.</p>
</li>
<li>
<p><strong>A mutual two-way cycle</strong>: In this case, two people like each other mutually, meaning <code>a &lt;-&gt; b</code>. This is a two-way connection, forming a 2-cycle group. These types of cycle groups allow us to put more people on the table because we can treat them as a smaller unit that can connect to other parts of the graph.</p>
</li>
</ol>
<p>Let’s go over two examples to break this down more clearly.</p>
<h5 id="example-1-1-0-3-2-5-6-7-4-9-8-11-10-11-12-10">Example 1: <code>[1, 0, 3, 2, 5, 6, 7, 4, 9, 8, 11, 10, 11, 12, 10]</code></h5>
<p>We can visualize this as a graph where each node has an edge pointing to their favorite person.</p>
<p>If person A likes B, we construct an edge of A -&gt; B. Then we can construct a graph like below:</p>
<p><img src="../Figures/2127/diff_cases.png" alt="alt text" /></p>
<ol>
<li>
<p><strong>Cycle with size &gt; 2 (green cycle)</strong>:</p>
<ul>
<li>For cycles like this, no additional employees can be added to the cycle because everyone must sit next to their favorite person, and adding others would disrupt that. For instance, in the cycle <code>(4, 5, 6, 7)</code>, no one else can sit in that cycle unless we break it, which is not allowed.</li>
</ul>
</li>
<li>
<p><strong>Cycle with size == 2 (red cycle)</strong>:</p>
<ul>
<li>For these types of cycles, we can have multiple 2-cycles sitting next to each other. These cycles can connect with extended paths (chains of employees) as long as they don’t disrupt the seating order.</li>
<li>For example, we can allocate the employees like <code>[(0, 1), (2, 3), (8, 9), [13, 12, (11, 10), 14]]</code></li>
<li>Notice that we can also put extended paths (like the blue circles in the diagram) next to the two endpoints of the 2-cycle. This allows us to extend the cycle by adding more people without violating the seating constraints.</li>
</ul>
</li>
</ol>
<h5 id="example-2-9-14-15-8-22-15-12-11-10-7-1-12-15-6-5-12-10-21-4-1-16-3-7">Example 2: <code>[9, 14, 15, 8, 22, 15, 12, 11, 10, 7, 1, 12, 15, 6, 5, 12, 10, 21, 4, 1, 16, 3, 7]</code></h5>
<p>Check out the below diagram, as we will be referring to it in the future for explanation:</p>
<p><img src="../Figures/2127/mutual_2nd_testcase.png" alt="alt text" /></p>
<p>In this example, there are more complex cycles and paths to consider. We need to find the longest possible extended paths for each endpoint of a 2-cycle and combine them efficiently.</p>
<p><strong>Extended Path for 2-Cycles</strong>:</p>
<ul>
<li>For instance, for the 2-cycle <code>(12, 15)</code> (blue rectangle), we need to find the longest paths from each of these employees. Starting from <code>12</code>, we can trace a path: <code>[18, 4, 22, 7, 11, 12]</code>, and from <code>15</code>, we trace a path: <code>[17, 21, 3, 8, 10, 1, 14, 5, 15]</code>.</li>
</ul>
<p>The idea is that these paths can be connected to the cycle, forming larger groups of people that can sit together.</p>
<p>So our core solution consists of three parts:</p>
<ol>
<li>
<p><strong>Cycle Detection</strong>:</p>
<ul>
<li>Since every node points to exactly one other node (the favorite person), the graph is simple. We can detect cycles by walking through the graph from unexplored nodes and stopping when we revisit an already visited node. This works well because each node has at most one outgoing edge, simplifying the process.</li>
</ul>
</li>
<li>
<p><strong>Finding the Longest Path</strong>:</p>
<ul>
<li>Once we have detected all the cycles, we need to handle two cases:
<ul>
<li>Single cycle with size &gt; 2: We treat it as a unit and cannot add more people.</li>
<li>Multiple 2-cycles: We look for the longest extended path for each endpoint of a 2-cycle, using <a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS</a> or <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">DFS</a> to find the longest path starting from each of the two mutual-favoriting people. The maximum possible length for any group is the sum of the longest paths from both endpoints plus 2 (for the mutual-favoriting people themselves).</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="../Figures/2127/mutual_favs.png" alt="mutual_favs" /></p>
<ol start="3">
<li><strong>Final Comparison</strong>:
<ul>
<li>Once we have the maximum length from extended paths and the size of the largest cycle, we simply compare these two values. The answer is the larger of the two, as that represents the maximum number of employees that can be seated together.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="approach-1-cycle-detection-with-extended-paths">Approach 1: Cycle Detection with Extended Paths</h3>
<h4 id="intuition">Intuition</h4>
<p>From the overview, the problem boils down to identifying cycles in the directed graph, determining how chains can be connected, and ensuring that employees are seated next to their favorites.</p>
<p>To implement this, we first need to create a graph that represents the relationships between people based on their favorite person. This is done by constructing a reversed graph where each person points to the people who have them as their favorite. This structure allows us to easily trace back to the people that lead into each person’s chain.</p>
<p>Next, we iterate through the graph nodes. If a node hasn’t been visited, we start a traversal, tracking visited nodes and the distance from the start using a map.</p>
<ul>
<li>If a node is visited during the traversal, we've detected a cycle. The cycle length is the difference in the distances at which we first encounter and revisit the node.</li>
<li>A cycle length greater than 2 forms a self-contained group, which we compare with the largest cycle found.</li>
</ul>
<p>When we detect a two-node cycle (mutual favorites), the approach changes slightly. In this case, the cycle itself only accounts for two people, so we look for the longest chains that lead into both people of the cycle. This is done by implementing a <strong>BFS</strong> function that explores the reversed graph and finds the maximum path leading into each of the two nodes forming the cycle. The length of the chain for each node is determined by how far we can trace back in the graph.</p>
<ul>
<li>Once we know the longest chain for each of the two nodes, we calculate the total size of the group by adding the two chain lengths plus 2 (for the two people in the cycle itself). This extended group size is then added to the total count of two-node cycle groups.</li>
</ul>
<p>Finally, the result is the larger of the largest standalone cycle or the largest extended group from the two-node cycle. This ensures the largest valid seating arrangement is found.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable <code>n</code> to store the size of the <code>favorite</code> array, and create a <code>reversedGraph</code> to store the reversed edges (in this case, favorite relationships).</p>
</li>
<li>
<p>Build the reversed graph:</p>
<ul>
<li>Iterate through each person in the <code>favorite</code> array, and for each person, add them to the reversed graph using <code>favorite[person]</code> as the key.</li>
</ul>
</li>
<li>
<p>Define a helper function <code>bfs</code> to perform breadth-first search:</p>
<ul>
<li>Initialize a queue to hold the node and its distance.</li>
<li>Process each node in the queue and explore its neighbors (reverse of the favorite relationship).</li>
<li>Track the maximum distance during BFS and return this value after all nodes have been visited.</li>
</ul>
</li>
<li>
<p>Initialize <code>longestCycle</code> to keep track of the length of the longest cycle found.</p>
</li>
<li>
<p>Initialize <code>twoCycleInvitations</code> to store the count of invitations for cycles of length 2.</p>
</li>
<li>
<p>Iterate through each person in the <code>favorite</code> array:</p>
<ul>
<li>If the person hasn't been visited, start detecting a cycle from that person:
<ul>
<li>Use a map <code>visitedPersons</code> to track the distance from the current node.</li>
<li>Traverse through the favorite relationships to detect cycles.</li>
<li>If a cycle is detected, calculate its length and update <code>longestCycle</code>.</li>
<li>If the cycle length is 2, calculate invitations from both nodes of the cycle by performing BFS from each node, ensuring that both nodes are marked as visited.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum of <code>longestCycle</code> and <code>twoCycleInvitations</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kYoqLnsm/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>favorite</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We build a reversed graph where each node points to its favorite. This involves iterating over all <span class="math inline">\(n\)</span> elements and adding edges, which takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The outer loop iterates over all <span class="math inline">\(n\)</span> people, and the inner while loop processes each person in the cycle exactly once. This ensures that each node is visited at most once, resulting in <span class="math inline">\(O(n)\)</span> time for cycle detection.</p>
<p>For cycles of length 2, we perform a BFS to calculate the maximum distance from each node in the cycle. Since each node is visited at most once during the BFS, and the BFS is performed only for 2-length cycles, the total time for this step is also <span class="math inline">\(O(n)\)</span>.</p>
<p>Since all these steps are sequential and each takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The reversed graph is stored as an adjacency list, which requires <span class="math inline">\(O(n)\)</span> space. The <code>visited</code> array tracks whether a node has been processed, requiring <span class="math inline">\(O(n)\)</span> space. The <code>visitedPersons</code> map stores the distance of each node in the current cycle, which can take up to <span class="math inline">\(O(n)\)</span> space in the worst case. The BFS queue and the <code>visitedNodes</code> set used for 2-length cycle processing can store up to <span class="math inline">\(O(n)\)</span> nodes in total.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-topological-sort-to-reduce-non-cyclic-nodes">Approach 2: Topological Sort to Reduce Non-Cyclic Nodes</h3>
<h4 id="intuition-1">Intuition</h4>
<p><a href="https://leetcode.com/explore/featured/card/graph/623/kahns-algorithm-for-topological-sorting/">Topological sort</a> is an algorithm traditionally used in DAGs (Directed Acyclic Graphs) to order nodes in a way that for every directed edge <code>u</code> to <code>v</code>, node <code>u</code> comes before node <code>v</code>. This ordering allows us to process nodes one by one, ensuring that we handle dependencies before processing dependent nodes.</p>
<p>However, in this context, we don't have a pure DAG because of the cycles. But we can still use topological sorting to help with eliminating non-cycle nodes and focusing on cycles that we need to handle more carefully. In fact, identifying and processing these cycles is key to finding the solution.</p>
<p>The idea is to first process nodes in topological order to remove non-cycle nodes and focus on the cycles that need further examination.</p>
<p>To implement this, we begin by calculating the in-degree for each node. The in-degree of a node indicates how many nodes point to it. In this case, the &quot;favorite&quot; relationship can be seen as a directed edge from one person to another. After populating the in-degree array, we initialize a queue that will help us with the topological sort. The queue initially contains all nodes that have an in-degree of zero (i.e., nodes with no incoming edges). These are the nodes that do not form part of any cycle and can be processed in topological order.</p>
<p>Next, we start the process of topologically sorting the nodes while calculating the depth of each node. The depth represents the longest path from any starting node to that particular node. As we process each node, we decrement the in-degree of its neighbor (as we &quot;remove&quot; the edge), and if any neighbor's in-degree becomes zero, it is added to the queue. During this process, we also update the depth of each node, ensuring that it reflects the longest path leading to that node.</p>
<p>Once the topological sort is completed and we have processed all non-cycle nodes, we move on to detect cycles. For each node that remains in the graph (i.e., nodes with a non-zero in-degree), we trace the cycle by following the favorite links. As we trace the cycle, we mark the nodes as visited by setting their in-degree to zero, and count the length of the cycle.</p>
<ul>
<li>
<p>If the cycle length is 2, we know it’s a two-person mutual favorite cycle. In this case, we add the combined depths of both nodes in the cycle to the total invitation count for two-cycles. This is because both nodes can invite the maximum number of people based on their depths.</p>
</li>
<li>
<p>For longer cycles, we simply update the longest cycle length, since a longer cycle can accommodate more people in the seating arrangement.</p>
</li>
</ul>
<p>At the end, the result is the maximum of the longest cycle length and the total size of the two-cycle groups.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a variable <code>n</code> to store the size of the <code>favorite</code> array and create an <code>inDegree</code> array to store the in-degree of each node.</p>
</li>
<li>
<p>Calculate the in-degree for each node:</p>
<ul>
<li>For each person, increment the in-degree of their favorite node.</li>
</ul>
</li>
<li>
<p>Perform topological sorting to process non-cycle nodes:</p>
<ul>
<li>Use a queue <code>q</code> to store nodes with in-degree 0 (no incoming edges).</li>
<li>For each node in the queue, update the depth of its favorite node and reduce its in-degree. If the in-degree of the favorite node becomes 0, add it to the queue.</li>
</ul>
</li>
<li>
<p>Initialize <code>longestCycle</code> and <code>twoCycleInvitations</code> to 0.</p>
</li>
<li>
<p>Detect cycles:</p>
<ul>
<li>For each person, if their in-degree is non-zero (indicating they are part of a cycle):
<ul>
<li>Track the cycle length while marking each node in the cycle as visited by setting its in-degree to <code>0</code>.</li>
<li>If the cycle length is 2, add the depth of both nodes involved in the cycle to <code>twoCycleInvitations</code>.</li>
<li>If the cycle length is greater than 2, update <code>longestCycle</code> with the maximum cycle length found.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the maximum of <code>longestCycle</code> and <code>twoCycleInvitations</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/GAkEKqjf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>favorite</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates over all <span class="math inline">\(n\)</span> elements to calculate the in-degree of each node. This takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The second loop iterates over all <span class="math inline">\(n\)</span> elements to initialize the queue with nodes that have an in-degree of 0. The subsequent BFS-like traversal processes each node and edge exactly once, which also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>The final loop iterates over all <span class="math inline">\(n\)</span> elements to detect cycles. Each node is visited at most once, and the inner while loop processes each node in the cycle exactly once. This also takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Since all these steps are sequential and each takes <span class="math inline">\(O(n)\)</span> time, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>inDegree</code> array stores the in-degree of each node, which requires <span class="math inline">\(O(n)\)</span> space. The <code>depth</code> array stores the depth of each node, which also requires <span class="math inline">\(O(n)\)</span> space. The queue used for topological sorting can store up to <span class="math inline">\(O(n)\)</span> nodes in the worst case. The variables used for cycle detection and other operations require constant space, which is negligible compared to the arrays and queue.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-profit-from-valid-topological-order-in-dag/description" target="_blank" rel="noopener noreferrer">Maximum Profit from Valid Topological Order in DAG</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>Directed Acyclic Graph (DAG)</strong> with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, represented by a 2D array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a directed edge from node <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>. Each node has an associated <strong>score</strong> given in an array <code>score</code>, where <code>score[i]</code> represents the score of node <code>i</code>.</p>

<p>You must process the nodes in a <strong>valid topological order</strong>. Each node is assigned a <strong>1-based position</strong> in the processing order.</p>

<p>The <strong>profit</strong> is calculated by summing up the product of each node&#39;s score and its position in the ordering.</p>

<p>Return the <strong>maximum </strong>possible profit achievable with an optimal topological order.</p>

<p>A <strong>topological order</strong> of a DAG is a linear ordering of its nodes such that for every directed edge <code>u &rarr; v</code>, node <code>u</code> comes before <code>v</code> in the ordering.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 2, edges = [[0,1]], score = [2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-021131.png" style="width: 200px; height: 89px;" /></p>

<p>Node 1 depends on node 0, so a valid order is <code>[0, 1]</code>.</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th style="border: 1px solid black;">Node</th>
			<th style="border: 1px solid black;">Processing Order</th>
			<th style="border: 1px solid black;">Score</th>
			<th style="border: 1px solid black;">Multiplier</th>
			<th style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2 &times; 1 = 2</td>
		</tr>
		<tr>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>2 + 6 = 8</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">n = 3, edges = [[0,1],[0,2]], score = [1,6,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">25</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/03/10/screenshot-2025-03-11-at-023558.png" style="width: 200px; height: 124px;" /></p>

<p>Nodes 1 and 2 depend on node 0, so the most optimal valid order is <code>[0, 2, 1]</code>.</p>

<table data-end="1197" data-start="851" node="[object Object]" style="border: 1px solid black;">
	<thead data-end="920" data-start="851">
		<tr data-end="920" data-start="851">
			<th data-end="858" data-start="851" style="border: 1px solid black;">Node</th>
			<th data-end="877" data-start="858" style="border: 1px solid black;">Processing Order</th>
			<th data-end="885" data-start="877" style="border: 1px solid black;">Score</th>
			<th data-end="898" data-start="885" style="border: 1px solid black;">Multiplier</th>
			<th data-end="920" data-start="898" style="border: 1px solid black;">Profit Calculation</th>
		</tr>
	</thead>
	<tbody data-end="1197" data-start="991">
		<tr data-end="1059" data-start="991">
			<td style="border: 1px solid black;">0</td>
			<td style="border: 1px solid black;">1st</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">1 &times; 1 = 1</td>
		</tr>
		<tr data-end="1128" data-start="1060">
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">2nd</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">2</td>
			<td style="border: 1px solid black;">3 &times; 2 = 6</td>
		</tr>
		<tr data-end="1197" data-start="1129">
			<td style="border: 1px solid black;">1</td>
			<td style="border: 1px solid black;">3rd</td>
			<td style="border: 1px solid black;">6</td>
			<td style="border: 1px solid black;">3</td>
			<td style="border: 1px solid black;">6 &times; 3 = 18</td>
		</tr>
	</tbody>
</table>

<p>The maximum total profit achievable over all valid topological orders is <code>1 + 6 + 18 = 25</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == score.length &lt;= 22</code></li>
	<li><code>1 &lt;= score[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>]</code> denotes a directed edge from <code>u<sub>i</sub></code> to <code>v<sub>i</sub></code>.</li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>
	<li>There are no duplicate edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-height-trees/description" target="_blank" rel="noopener noreferrer">Minimum Height Trees</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>

<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>

<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>

<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" style="width: 800px; height: 213px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" style="width: 800px; height: 321px;" />
<pre>
<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
<strong>Output:</strong> [3,4]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>edges.length == n - 1</code></li>
	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
	<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>
	<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/network-recovery-pathways/description" target="_blank" rel="noopener noreferrer">Network Recovery Pathways</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="502" data-start="75">You are given a directed acyclic graph of <code>n</code> nodes numbered from 0 to <code>n &minus; 1</code>. This is represented by a 2D array <code data-end="201" data-start="194">edges</code> of length<font face="monospace"> <code>m</code></font>, where <code data-end="255" data-start="227">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code> indicates a one‑way communication from node <code data-end="304" data-start="300">u<sub>i</sub></code> to node <code data-end="317" data-start="313">v<sub>i</sub></code> with a recovery cost of <code data-end="349" data-start="342">cost<sub>i</sub></code>.</p>

<p data-end="502" data-start="75">Some nodes may be offline. You are given a boolean array <code data-end="416" data-start="408">online</code> where <code data-end="441" data-start="423">online[i] = true</code> means node <code data-end="456" data-start="453">i</code> is online. Nodes 0 and <code>n &minus; 1</code> are always online.</p>

<p data-end="547" data-start="504">A path from 0 to <code>n &minus; 1</code> is <strong data-end="541" data-start="532">valid</strong> if:</p>

<ul>
	<li>All intermediate nodes on the path are online.</li>
	<li data-end="676" data-start="605">The total recovery cost of all edges on the path does not exceed <code>k</code>.</li>
</ul>

<p data-end="771" data-start="653">For each valid path, define its <strong data-end="694" data-start="685">score</strong> as the minimum edge‑cost along that path.</p>

<p data-end="913" data-start="847">Return the <strong>maximum</strong> path score (i.e., the largest <strong>minimum</strong>-edge cost) among all valid paths. If no valid path exists, return -1.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,5],[1,3,10],[0,2,3],[2,3,4]], online = [true,true,true,true], k = 10</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-10.png" style="width: 239px; height: 267px;" /></p>

<ul data-end="551" data-start="146">
	<li data-end="462" data-start="146">
	<p data-end="206" data-start="148">The graph has two possible routes from node 0 to node 3:</p>

	<ol data-end="462" data-start="209">
		<li data-end="315" data-start="209">
		<p data-end="228" data-start="212">Path <code>0 &rarr; 1 &rarr; 3</code></p>

		<ul data-end="315" data-start="234">
			<li data-end="315" data-start="234">
			<p data-end="315" data-start="236">Total cost = <code>5 + 10 = 15</code>, which exceeds k (<code>15 &gt; 10</code>), so this path is invalid.</p>
			</li>
		</ul>
		</li>
		<li data-end="462" data-start="318">
		<p data-end="337" data-start="321">Path <code>0 &rarr; 2 &rarr; 3</code></p>

		<ul data-end="462" data-start="343">
			<li data-end="397" data-start="343">
			<p data-end="397" data-start="345">Total cost = <code>3 + 4 = 7 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="462" data-start="403">
			<p data-end="462" data-start="405">The minimum edge‐cost along this path is <code>min(3, 4) = 3</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="551" data-start="463">
	<p data-end="551" data-start="465">There are no other valid paths. Hence, the maximum among all valid path‐scores is 3.</p>
	</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">edges = [[0,1,7],[1,4,5],[0,2,6],[2,3,6],[3,4,2],[2,4,6]], online = [true,true,true,false,true], k = 12</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/06/06/graph-11.png" style="width: 343px; height: 194px;" /></p>

<ul>
	<li data-end="790" data-start="726">
	<p data-end="790" data-start="728">Node 3 is offline, so any path passing through 3 is invalid.</p>
	</li>
	<li data-end="1231" data-start="791">
	<p data-end="837" data-start="793">Consider the remaining routes from 0 to 4:</p>

	<ol data-end="1231" data-start="840">
		<li data-end="985" data-start="840">
		<p data-end="859" data-start="843">Path <code>0 &rarr; 1 &rarr; 4</code></p>

		<ul data-end="985" data-start="865">
			<li data-end="920" data-start="865">
			<p data-end="920" data-start="867">Total cost = <code>7 + 5 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="985" data-start="926">
			<p data-end="985" data-start="928">The minimum edge‐cost along this path is <code>min(7, 5) = 5</code>.</p>
			</li>
		</ul>
		</li>
		<li data-end="1083" data-start="988">
		<p data-end="1011" data-start="991">Path <code>0 &rarr; 2 &rarr; 3 &rarr; 4</code></p>

		<ul data-end="1083" data-start="1017">
			<li data-end="1083" data-start="1017">
			<p data-end="1083" data-start="1019">Node 3 is offline, so this path is invalid regardless of cost.</p>
			</li>
		</ul>
		</li>
		<li data-end="1231" data-start="1086">
		<p data-end="1105" data-start="1089">Path <code>0 &rarr; 2 &rarr; 4</code></p>

		<ul data-end="1231" data-start="1111">
			<li data-end="1166" data-start="1111">
			<p data-end="1166" data-start="1113">Total cost = <code>6 + 6 = 12 &lt;= k</code>, so this path is valid.</p>
			</li>
			<li data-end="1231" data-start="1172">
			<p data-end="1231" data-start="1174">The minimum edge‐cost along this path is <code>min(6, 6) = 6</code>.</p>
			</li>
		</ul>
		</li>
	</ol>
	</li>
	<li data-end="1314" data-is-last-node="" data-start="1232">
	<p data-end="1314" data-is-last-node="" data-start="1234">Among the two valid paths, their scores are 5 and 6. Therefore, the answer is 6.</p>
	</li>
</ul>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="42" data-start="20"><code data-end="40" data-start="20">n == online.length</code></li>
	<li data-end="63" data-start="45"><code data-end="61" data-start="45">2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="102" data-start="66"><code data-end="100" data-start="66">0 &lt;= m == edges.length &lt;= </code><code>min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li data-end="102" data-start="66"><code data-end="127" data-start="105">edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cost<sub>i</sub>]</code></li>
	<li data-end="151" data-start="132"><code data-end="149" data-start="132">0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li data-end="166" data-start="154"><code data-end="164" data-start="154">u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="191" data-start="169"><code data-end="189" data-start="169">0 &lt;= cost<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li data-end="213" data-start="194"><code data-end="211" data-start="194">0 &lt;= k &lt;= 5 * 10<sup>13</sup></code></li>
	<li data-end="309" data-start="216"><code data-end="227" data-start="216">online[i]</code> is either <code data-end="244" data-is-only-node="" data-start="238">true</code> or <code data-end="255" data-start="248">false</code>, and both <code data-end="277" data-start="266">online[0]</code> and <code data-end="295" data-start="282">online[n &minus; 1]</code> are <code data-end="306" data-start="300">true</code>.</li>
	<li data-end="362" data-is-last-node="" data-start="312">The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-increasing-paths-in-a-grid/description" target="_blank" rel="noopener noreferrer">Number of Increasing Paths in a Grid</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">memoization</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>

<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" style="width: 181px; height: 121px;" />
<pre>
<strong>Input:</strong> grid = [[1,1],[3,4]]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].
- Paths with length 3: [1 -&gt; 3 -&gt; 4].
The total number of paths is 4 + 3 + 1 = 8.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> grid = [[1],[2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -&gt; 2].
The total number of paths is 2 + 1 = 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 1000</code></li>
	<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/description" target="_blank" rel="noopener noreferrer">Number of Restricted Paths From First to Last Node</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is an undirected weighted connected graph. You are given a positive integer <code>n</code> which denotes that the graph has <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, and an array <code>edges</code> where each <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there is an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with weight equal to <code>weight<sub>i</sub></code>.</p>

<p>A path from node <code>start</code> to node <code>end</code> is a sequence of nodes <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> such that <code>z<sub>0 </sub>= start</code> and <code>z<sub>k</sub> = end</code> and there is an edge between <code>z<sub>i</sub></code> and <code>z<sub>i+1</sub></code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>The distance of a path is the sum of the weights on the edges of the path. Let <code>distanceToLastNode(x)</code> denote the shortest distance of a path between node <code>n</code> and node <code>x</code>. A <strong>restricted path</strong> is a path that also satisfies that <code>distanceToLastNode(z<sub>i</sub>) &gt; distanceToLastNode(z<sub>i+1</sub>)</code> where <code>0 &lt;= i &lt;= k-1</code>.</p>

<p>Return <em>the number of restricted paths from node</em> <code>1</code> <em>to node</em> <code>n</code>. Since that number may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex1.png" style="width: 351px; height: 341px;" />
<pre>
<strong>Input:</strong> n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The three restricted paths are:
1) 1 --&gt; 2 --&gt; 5
2) 1 --&gt; 2 --&gt; 3 --&gt; 5
3) 1 --&gt; 3 --&gt; 5
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex22.png" style="width: 356px; height: 401px;" />
<pre>
<strong>Input:</strong> n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Each circle contains the node number in black and its <code>distanceToLastNode value in blue. </code>The only restricted path is 1 --&gt; 3 --&gt; 7.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>n - 1 &lt;= edges.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>edges[i].length == 3</code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
	<li>There is at most one edge between any two nodes.</li>
	<li>There is at least one path between any two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-to-arrive-at-destination/description" target="_blank" rel="noopener noreferrer">Number of Ways to Arrive at Destination</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">graph</span> <span class="topic-badge">shortest path</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are in a city that consists of <code>n</code> intersections numbered from <code>0</code> to <code>n - 1</code> with <strong>bi-directional</strong> roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</p>

<p>You are given an integer <code>n</code> and a 2D integer array <code>roads</code> where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> means that there is a road between intersections <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. You want to know in how many ways you can travel from intersection <code>0</code> to intersection <code>n - 1</code> in the <strong>shortest amount of time</strong>.</p>

<p>Return <em>the <strong>number of ways</strong> you can arrive at your destination in the <strong>shortest amount of time</strong></em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/02/14/1976_corrected.png" style="width: 255px; height: 400px;" />
<pre>
<strong>Input:</strong> n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2, roads = [[1,0,10]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
	<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>
	<li><code>roads[i].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
	<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li>There is at most one road connecting any two intersections.</li>
	<li>You can reach any intersection from any other intersection.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have <code>n</code> intersections in a city, represented as nodes in a fully connected graph with bidirectional roads as edges. Each road has a given travel time. Our goal is to determine the number of distinct ways to travel from intersection <code>0</code> to intersection <code>n - 1</code> while taking the shortest possible time. The problem guarantees that every intersection is reachable from any other intersection, ensuring that the graph is fully connected. Additionally, there is at most one road between any two intersections, so we do not have to consider duplicate edges.</p>
<p>One important detail is that the number of ways can be large, so the answer must be returned modulo <span class="math inline">\(10^9 + 7\)</span>. A common mistake is assuming that all roads have unique travel times, but the problem does not impose this restriction. Multiple roads may contribute to the shortest path calculation, and all must be considered. Since the roads are bidirectional, each one can be traversed in either direction. However, backtracking is unnecessary here, meaning we can ignore paths that visit the same road twice, as they will definitely take more time to reach the destination.</p>
<p>For instance, in the first example of the problem description, the shortest time to travel from intersection <code>0</code> to intersection <code>6</code> is <code>7</code> minutes. There are four distinct paths that achieve this travel time, each taking different routes but resulting in the same minimum duration.</p>
<p>Our approach will be based on two fundamental concepts: graph theory and Dijkstra’s shortest path algorithm. Since these topics are crucial to understanding the solution, we recommend having some prior knowledge of them. However, we will also provide a thorough explanation to ensure clarity.</p>
<ol>
<li>
<p><strong>Graph Theory</strong> – Understanding graphs, nodes, edges, and different types of graph representations (adjacency list, adjacency matrix).</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/">Graph Theory - LeetCode Explore Card</a></li>
</ul>
</li>
<li>
<p><strong>Dijkstra’s Algorithm</strong> – A fundamental shortest path algorithm that efficiently finds the minimum distance from a source node to all other nodes in a weighted graph.</p>
<ul>
<li><a href="https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3885/">Dijkstra’s Algorithm - LeetCode Explore Card</a></li>
</ul>
</li>
</ol>
<hr />
<h3 id="approach-1-dijkstras-algorithm">Approach 1: Dijkstra's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>Dijkstra’s algorithm is the best fit for this problem because it efficiently finds the shortest path from a single source node to all other nodes in a graph with edges that have non-negative weights. The core principle of Dijkstra’s algorithm is that it always expands the currently known shortest path first, ensuring that when we reach a node, we do so in the minimum time possible.</p>
<p>Other approaches, such as Breadth-First Search (BFS), Depth-First Search (DFS), or the Bellman-Ford algorithm, would not be efficient. BFS does not work for weighted graphs unless modified with a priority queue, which ultimately turns it into Dijkstra’s algorithm. DFS would be highly inefficient because it would explore all possible paths, many of which would be unnecessary since they do not guarantee the shortest travel time. The brute-force approach of checking all paths using DFS would have an exponential time complexity and would be infeasible for large inputs.</p>
<p>Dijkstra’s algorithm is a greedy algorithm that uses a min-heap (priority queue) to process nodes in increasing order of their shortest known distance. The algorithm starts from the source node, which is node <code>0</code>, and initializes its distance to <code>0</code> while setting the distance for all other nodes to infinity. The priority queue ensures that the node with the shortest known distance is always processed first.</p>
<p>For each node that is extracted from the priority queue, its neighbors are checked. If traveling through the current node provides a shorter path to a neighboring node, the shortest time to that node is updated, and the neighbor is added to the priority queue for further processing. This continues until all nodes have been processed, at which point the shortest time to each node is known.</p>
<p>The reason Dijkstra’s algorithm works correctly is that once a node is extracted from the priority queue, we are guaranteed that we have found the shortest possible path to that node. Any future attempts to update its distance will fail. This is because any other node that could have led to a shorter path already has a greater cost (otherwise, we would have extracted it first from the heap). Additionally, since all edges have a positive weight, any further paths to that node will only add a positive value to the total cost, increasing it further.</p>
<p>The standard implementation of Dijkstra’s algorithm only finds the shortest distance to each node. However, this problem also requires us to count how many different ways exist to reach the last node (<code>n - 1</code>) using the shortest possible time.</p>
<p>To achieve this, we introduce an additional array, <code>pathCount</code>, where <code>pathCount[i]</code> keeps track of the number of ways to reach node <code>i</code> in the shortest time possible. This modification allows us to not only compute the shortest travel time but also count all valid paths that follow this time constraint.</p>
<p>Initially, <code>pathCount[0] = 1</code>, since there is exactly one way to start at node <code>0</code>. When we find a new shorter path to a node, we reset its path count to be the same as the number of ways we could reach the previous node, since we have discovered a new optimal route.</p>
<p>If we encounter another way to reach a node with the same shortest time, we do not reset the path count. Instead, we add the number of ways we could reach the previous node to the current node’s path count. Since the number of ways can be large, we take the result modulo <span class="math inline">\(10^9 + 7\)</span> to prevent integer overflow.</p>
<p>This problem is notorious for its edge cases, which often cause issues when submitted. A common mistake is using <code>INT_MAX</code> (or similar equivalent in the language of your choice) as the initial value, assuming it is large enough to represent an unreachable node. However, for this problem, using <code>INT_MAX</code> causes incorrect results or even integer overflow in certain test cases.</p>
<p>To understand why, we need to analyze the constraints. The number of nodes (<code>n</code>) is at most <span class="math inline">\(200\)</span>, and the edge weights (<code>time[i]</code>) can be as large as <span class="math inline">\(10^9\)</span>. The worst-case scenario occurs when the shortest path to a node involves traversing <code>199</code> edges, forming a nearly linear path. In such a case, the total shortest path value can reach:</p>
<p><span class="math inline">\(199 \times 10^9 = 1.99 \times 10^{11}\)</span></p>
<p>This is far greater than <code>INT_MAX</code> (which is <span class="math inline">\(2.1 × 10^9\)</span>). If we initialize our distances with <code>INT_MAX</code>, adding even a single edge weight (<span class="math inline">\(10^9\)</span>) could exceed this limit, causing integer overflow. As a result, the algorithm may produce incorrect results when comparing distances, leading to failures in large test cases like test case 53.</p>
<p>To avoid this issue, we should initialize the <code>shortestTime</code> array with <code>LLONG_MAX</code>, which is <span class="math inline">\(9.2 × 10^18\)</span>, or use a sufficiently large constant like <code>1e12</code>. Both options ensure that our algorithm can correctly compute distances without encountering overflow. This small but crucial adjustment is necessary to handle the problem’s constraints correctly.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/1976/dijikstra.json:690,608!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define <code>MOD = 1e9 + 7</code> for modular arithmetic.</p>
</li>
<li>
<p>Build an adjacency list <code>graph</code> where <code>graph[i]</code> stores <code>{neighbor, travelTime}</code> pairs.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) for Dijkstra's algorithm.</p>
</li>
<li>
<p>Create <code>shortestTime</code> array to store the shortest time to each node, initialized to <code>LLONG_MAX</code> (or its equivalent in other preferred languages).</p>
</li>
<li>
<p>Create <code>pathCount</code> array to store the number of shortest paths to each node, initialized to <code>0</code>.</p>
</li>
<li>
<p>Set <code>shortestTime[0] = 0</code> and <code>pathCount[0] = 1</code> (starting node has distance <code>0</code> and one valid path).</p>
</li>
<li>
<p>Push <code>{0, 0}</code> into <code>minHeap</code> to start processing.</p>
</li>
<li>
<p>While <code>minHeap</code> is not empty:</p>
<ul>
<li>Extract the node <code>currNode</code> with the current shortest known time <code>currTime</code>.</li>
<li>If <code>currTime &gt; shortestTime[currNode]</code>, skip outdated distances.</li>
<li>Iterate over neighbors of <code>currNode</code>:
<ul>
<li>If a new shortest path is found:
<ul>
<li>Update <code>shortestTime[neighborNode]</code>.</li>
<li>Reset <code>pathCount[neighborNode]</code> to match <code>pathCount[currNode]</code>.</li>
<li>Push <code>{shortestTime[neighborNode], neighborNode}</code> into <code>minHeap</code>.</li>
</ul>
</li>
<li>If an equally short path is found:
<ul>
<li>Add <code>pathCount[currNode]</code> to <code>pathCount[neighborNode]</code>, modulo <code>MOD</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>pathCount[n - 1]</code>, the number of shortest paths to the last node.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Time-saving coding tip:</p>
<p>Whenever a problem involves calculating distances or counting paths, it's a good idea to use long long (or an equivalent large integer type) and apply the modulo operator when required. This helps prevent integer overflow and ensures accurate results, especially in graph and dynamic programming problems.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/faYwk3KQ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N + E \log E)\)</span></p>
<p>Building the adjacency list takes <span class="math inline">\(O(E)\)</span> time, since we iterate over all the edges once.</p>
<p>The main part of the algorithm is Dijkstra’s algorithm using a min-heap. In this implementation, a node can be added to the heap multiple times (if a shorter path to it is found later). For each edge, we may perform a heap insertion, and the heap can grow up to size <span class="math inline">\(O(E)\)</span> in the worst case. Each insertion or extraction from the heap takes <span class="math inline">\(O(\log E)\)</span> time. Thus, the total time spent on heap operations is <span class="math inline">\(O(E \log E)\)</span>.</p>
<p>Combining both parts, the overall time complexity is: <span class="math inline">\(O(E) + O(E \log E) = O(N + E \log E)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N + E)\)</span></p>
<p>The adjacency list stores <span class="math inline">\(O(2 \cdot E)\)</span> edges, but it requires <span class="math inline">\(O(N + 2E) \approx O(N + E)\)</span> space in total, as it also includes the <span class="math inline">\(N\)</span> nodes in the outer list. The priority queue stores at most <span class="math inline">\(O(N)\)</span> elements at any time. Additionally, the <code>shortestTime</code> and <code>pathCount</code> arrays require <span class="math inline">\(O(N)\)</span> space. Since the total space used is dominated by <span class="math inline">\(O(N + E)\)</span> for storing the graph, the overall space complexity is <span class="math inline">\(O(N + E)\)</span>.</p>
<p>Other auxiliary variables, such as integers and loop variables, contribute <span class="math inline">\(O(1)\)</span> space, which is negligible compared to <span class="math inline">\(O(N + E)\)</span>. Therefore, the dominant space complexity remains <span class="math inline">\(O(N + E)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-floyd-warshall-algorithm">Approach 2: Floyd-Warshall algorithm</h3>
<h4 id="intuition-1">Intuition</h4>
<p>An alternate acceptable approach is to use the concept of Floyd-Warshall algorithm. The core idea of this algorithm is to check whether using an intermediate node <code>mid</code> can create a shorter path between <code>src</code> and <code>dest</code>. Instead of expanding outward from a single source like Dijkstra’s algorithm, Floyd-Warshall updates the shortest path between all pairs of nodes at the same time. This guarantees that once the algorithm completes, every possible shortest path has been counted. However, the Floyd-Warshall algorithm runs in <span class="math inline">\(O(n^3)\)</span> time complexity, which makes it impractical for very large graphs.</p>
<p>To implement this, we define a three-dimensional dynamic programming table <code>dp[src][dest][x]</code>. The first value, <code>dp[src][dest][0]</code>, stores the shortest time required to travel from <code>src</code> to <code>dest</code>, while <code>dp[src][dest][1]</code> keeps track of how many different ways this shortest time can be achieved. At the beginning, the shortest time between any two distinct nodes is set to a very large value, representing that they are initially unreachable. The number of ways is set to <code>0</code> because no path has been established yet. The only exception is when <code>src</code> and <code>dest</code> are the same, in which case the shortest time is <code>0</code> and the number of ways is <code>1</code>, as staying at the node is trivially possible in exactly one way.</p>
<p>Once the table is initialized, we update it with the given roads. If there is a direct connection between <code>startNode</code> and <code>endNode</code> with a given travel time, then the shortest time between these nodes is simply that travel time, and there is exactly one way to travel along this road. Since the roads are bidirectional, the same update applies in both directions.</p>
<p>Once all direct edges are accounted for, we use Floyd-Warshall to iteratively improve our shortest paths by considering each node <code>mid</code> as a possible bridge between every pair of nodes <code>(src, dest)</code>. For every such pair, we check whether traveling through <code>mid</code> results in a smaller total travel time than the best-known value stored in <code>dp[src][dest][0]</code>. If a strictly shorter path is found, we update <code>dp[src][dest][0]</code> to reflect this new shortest time and reset <code>dp[src][dest][1]</code> to be the product of <code>dp[src][mid][1]</code> and <code>dp[mid][dest][1]</code>, which accounts for all possible ways to reach <code>mid</code> from <code>src</code> and then travel from <code>mid</code> to <code>dest</code>. If the new path through <code>mid</code> results in the same shortest time that was already recorded, we do not update <code>dp[src][dest][0]</code>, but we add the newly found paths to <code>dp[src][dest][1]</code>, since they provide additional routes that achieve the minimum distance.</p>
<p>Once we have iterated through all possible intermediate nodes, <code>dp[n - 1][0][1]</code> contains the number of ways to travel between nodes <code>n - 1</code> and <code>0</code> in either direction, using the shortest possible time. This value represents our final answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize a 3D DP table <code>dp[n][n][2]</code> where:
<ul>
<li><code>dp[src][dest][0]</code> stores the minimum time to reach <code>dest</code> from <code>src</code>.</li>
<li><code>dp[src][dest][1]</code> stores the number of ways to achieve the minimum time.</li>
</ul>
</li>
<li>Initialize the DP table:
<ul>
<li>Set the time needed to travel from a node to itself to <code>0</code> and the number of ways to <code>1</code>.</li>
<li>Set the time needed to travel between any two different nodes to a large value (<code>1e12</code>) and the number of ways to <code>0</code>.</li>
</ul>
</li>
<li>Populate the DP table with direct roads (<code>[u, v, time]</code>) from the input:
<ul>
<li>Update the time needed to travel between <code>u</code> and <code>v</code> to <code>time</code> in both directions, and set the number of ways to <code>1</code>.</li>
</ul>
</li>
<li>Apply the Floyd-Warshall algorithm to compute shortest paths:
<ul>
<li>For each intermediate node <code>mid</code>:
<ul>
<li>For each starting node <code>src</code>:
<ul>
<li>For each destination node <code>dest</code>:
<ul>
<li>If <code>src != mid</code> and <code>dest != mid</code>:
<ul>
<li>Calculate <code>newTime</code> as <code>dp[src][mid][0] + dp[mid][dest][0]</code>.</li>
<li>If <code>newTime &lt; dp[src][dest][0]</code> (current time):
<ul>
<li>Update <code>dp[src][dest][0]</code> to <code>newTime</code>.</li>
<li>Update the number of ways <code>dp[src][dest][1]</code> to the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
<li>If <code>newTime == dp[src][dest][0]</code> (current time):
<ul>
<li>Increment the number of ways <code>dp[src][dest][1]</code> by the number of ways to reach <code>mid</code> from <code>src</code> (<code>dp[src][mid][1]</code>) multiplied by the number of ways to reach <code>dest</code> from <code>mid</code> (<code>dp[mid][dest][1]</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the number of shortest paths from node <code>n - 1</code> to node <code>0</code> stored in <code>dp[n - 1][0][1]</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/H2DorSwM/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of nodes in the graph and <span class="math inline">\(E\)</span> be the number of edges in the given road connections.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N^3)\)</span></p>
<p>The time complexity is dominated by the Floyd-Warshall algorithm. The algorithm involves three nested loops, each iterating over all nodes (from <code>0</code> to <code>N - 1</code>). Therefore, the time complexity is <span class="math inline">\(O(N^3)\)</span>.</p>
<p>Additionally, the initialization of the <code>dp</code> table takes <span class="math inline">\(O(N^2)\)</span> time, and the initialization of the roads (edges) takes <span class="math inline">\(O(E)\)</span> time. However, these are dominated by the <span class="math inline">\(O(N^3)\)</span> complexity of the Floyd-Warshall algorithm.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N^2)\)</span></p>
<p>The space complexity is determined by the size of the <code>dp</code> table, which is a 3D array of size <span class="math inline">\(N \times N \times 2\)</span>. This results in a space complexity of <span class="math inline">\(O(N^2)\)</span>, as the third dimension is a constant factor (<code>2</code>).</p>
<p>The input roads (edges) are stored in an array, which takes <span class="math inline">\(O(E)\)</span> space, but this is negligible compared to the <span class="math inline">\(O(N^2)\)</span> space used by the <code>dp</code> table. Therefore, the overall space complexity is <span class="math inline">\(O(N^2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/parallel-courses-iii/description" target="_blank" rel="noopener noreferrer">Parallel Courses III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer <code>n</code>, which indicates that there are <code>n</code> courses labeled from <code>1</code> to <code>n</code>. You are also given a 2D integer array <code>relations</code> where <code>relations[j] = [prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> denotes that course <code>prevCourse<sub>j</sub></code> has to be completed <strong>before</strong> course <code>nextCourse<sub>j</sub></code> (prerequisite relationship). Furthermore, you are given a <strong>0-indexed</strong> integer array <code>time</code> where <code>time[i]</code> denotes how many <strong>months</strong> it takes to complete the <code>(i+1)<sup>th</sup></code> course.</p>

<p>You must find the <strong>minimum</strong> number of months needed to complete all the courses following these rules:</p>

<ul>
	<li>You may start taking a course at <strong>any time</strong> if the prerequisites are met.</li>
	<li><strong>Any number of courses</strong> can be taken at the <strong>same time</strong>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of months needed to complete all the courses</em>.</p>

<p><strong>Note:</strong> The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex1.png" style="width: 392px; height: 232px;" /></strong>

<pre>
<strong>Input:</strong> n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The figure above represents the given graph and the time required to complete each course. 
We start course 1 and course 2 simultaneously at month 0.
Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.
</pre>

<p><strong class="example">Example 2:</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex2.png" style="width: 500px; height: 365px;" /></strong>

<pre>
<strong>Input:</strong> n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
<strong>Output:</strong> 12
<strong>Explanation:</strong> The figure above represents the given graph and the time required to complete each course.
You can start courses 1, 2, and 3 at month 0.
You can complete them after 1, 2, and 3 months respectively.
Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.
Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.
Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 10<sup>4</sup>)</code></li>
	<li><code>relations[j].length == 2</code></li>
	<li><code>1 &lt;= prevCourse<sub>j</sub>, nextCourse<sub>j</sub> &lt;= n</code></li>
	<li><code>prevCourse<sub>j</sub> != nextCourse<sub>j</sub></code></li>
	<li>All the pairs <code>[prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> are <strong>unique</strong>.</li>
	<li><code>time.length == n</code></li>
	<li><code>1 &lt;= time[i] &lt;= 10<sup>4</sup></code></li>
	<li>The given graph is a directed acyclic graph.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-topological-sort-kahns-algorithm">Approach 1: Topological Sort, Kahn's Algorithm</h3>
<p><strong>Intuition</strong></p>
<blockquote>
<p>If you are not familiar with topological sorting, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/">Topological Sorting Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>We can think of each course as a node in a graph, with the prerequisites being directed edges. Each node has a value, given in <code>time</code>. The problem tells us two things:</p>
<ol>
<li>We can start taking a course as soon as the prerequisites are met</li>
<li>We can take any number of courses simultaneously</li>
</ol>
<p>Take a look at the following graph.</p>
<p><img src="../Figures/2050/1.png" alt="example" /><br />
<br></p>
<p>Before we can start the course in green, we must finish the three other prerequisite courses first. However, only the completion time of the course in blue matters. Because of the 2nd rule, we can take all of them simultaneously. The course in blue requires the longest completion time, so by the time we take 4 months to finish it, the other two courses will have already been completed. Thus, we can complete the course in green after 4 + 5 = 9 months.</p>
<p>Let's extend the graph.</p>
<p><img src="../Figures/2050/2.png" alt="example" /><br />
<br></p>
<p>The nodes in green are the same ones from the first image. We already established that it takes 9 months to complete those courses. Thus, to start the red course, the other two nodes with values 7 and 8 are irrelevant because, by the time we take 9 months to finish the green nodes, they will already have been completed. To finish the red course, we need 9 + 5 = 14 months.</p>
<p><img src="../Figures/2050/3.png" alt="example" /><br />
<br></p>
<p>Without loss of generality, we can consider all the green nodes as a single node with value 9. If we were to extend the graph further, then we could consider the entire previous graph as a single node with value 14.</p>
<p><img src="../Figures/2050/4.png" alt="example" /><br />
<br></p>
<p>The takeaway from these examples is that we don't need to worry about the order in which the courses are taken. The only thing that matters for the completion time of each course is the latest prerequisite to be completed.</p>
<p>This simplifies the problem: let's define the <strong>value</strong> of a path as the sum of values for each node on the path. Consider all paths starting from nodes without any prerequisites. The answer to the problem is the maximum value of all such paths.</p>
<p>We can topologically sort the courses using Kahn's algorithm to solve this problem by simulating the process we talked about in the above example.</p>
<p>Consider an array <code>maxTime</code>. Let <code>maxTime[node]</code> represent the maximum value of all paths <strong>ending</strong> at <code>node</code>. Essentially, this array represents the simplifications from the above examples.</p>
<p><img src="../Figures/2050/5.png" alt="example" /><br />
<br></p>
<p>We initially consider all nodes with an indegree of 0 (no prerequisites). For each node, we iterate over each <code>neighbor</code> and try to update <code>maxTime[neighbor]</code> with a larger value. We also decrease the indegree of <code>neighbor</code>, and if it becomes 0, we push <code>neighbor</code> to our queue. In the end, the answer is the maximum value in <code>maxTime</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize the following data structures:
<ul>
<li>A <code>graph</code> from <code>relations</code>. For convenience, we will change the nodes to be 0-indexed.</li>
<li>An array <code>indegree</code> of length <code>n</code>, representing the indegree of each node.</li>
<li>A <code>queue</code> to perform Kahn's algorithm.</li>
<li>An array <code>maxTime</code> of length <code>n</code>, representing the maximum value of all paths ending at certain nodes.</li>
</ul>
</li>
<li>For all nodes with <code>indegree[node] = 0</code>, push them to the queue and initialize <code>maxTime[node] = time[node]</code>.</li>
<li>While <code>queue</code> is not empty:
<ul>
<li>Pop a <code>node</code>.</li>
<li>Iterate over <code>graph[node]</code>. For each <code>neighbor</code>:
<ul>
<li>Update <code>maxTime[neighbor]</code> with <code>maxTime[node] + time[neighbor]</code> if it is larger.</li>
<li>Decrement <code>indegree[neighbor]</code>.</li>
<li>If <code>indegree[neighbor] == 0</code>, push <code>neighbor</code> to <code>queue</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>max(maxTime)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/4QGkyzB7/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(e\)</span> as the length of <code>relations</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p>It costs <span class="math inline">\(O(e)\)</span> to build <code>graph</code> and <span class="math inline">\(O(n)\)</span> to initialize <code>maxTime</code>, <code>queue</code>, and <code>indegree</code>.</p>
<p>During Kahn's algorithm, each node is pushed and popped to <code>queue</code> once, costing <span class="math inline">\(O(n)\)</span>. We have a for loop inside the while loop, but this for loop is iterating over edges. Because we only visit each node once, each edge in the input can only be iterated over once as well. This means all for loop iterations across the algorithm will cost <span class="math inline">\(O(e)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p><code>graph</code> takes <span class="math inline">\(O(n + e)\)</span> space, the <code>queue</code> can take up to <span class="math inline">\(O(n)\)</span> space, <code>maxTime</code> and <code>indegree</code> both take <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-dfs--memoization-top-down-dp">Approach 2: DFS + Memoization (Top-Down DP)</h3>
<p><strong>Intuition</strong></p>
<p>We can also use DFS to solve this problem in the other direction. Let's define <code>dfs(node)</code> as the maximum value of all paths starting with <code>node</code>. If <code>node</code> is not a prerequisite to any courses, then we can simply return the value of <code>node</code> since the only path starting at <code>node</code> is <code>node</code> itself.</p>
<p>Otherwise, we iterate over each <code>neighbor</code> of <code>node</code> and call <code>dfs(neighbor)</code>. We take the maximum value of all these calls, add the value of <code>node</code> to it, and return that as <code>dfs(node)</code>. The answer to the original problem is the maximum value of <code>dfs</code> across all nodes. Because <code>dfs(node)</code> may be called many times, we will memoize our function to improve performance.</p>
<blockquote>
<p>This approach is very similar to the first one. In the first approach, for each <code>node</code>, we consider all paths ending at <code>node</code>, and we update <code>maxTime[node]</code> using the prerequisites of <code>node</code>.</p>
<p>In this approach, for each <code>node</code>, we consider all paths starting at <code>node</code>, and we update <code>dfs(node)</code> using the courses that <code>node</code> is a prerequisite of.</p>
<p>Due to the nature of recursion, we do not need to worry about the order in which we visit nodes, and thus a simple DFS works - we don't need to topologically sort.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a <code>graph</code> from <code>relations</code>. For convenience, we will change the nodes to be 0-indexed.</li>
<li>Define a memoized function <code>dfs(node)</code>:
<ul>
<li>If <code>node</code> has no outgoing edges, return <code>time[node]</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate over <code>graph[node]</code>. For each <code>neighbor</code>, set <code>ans = max(ans, dfs(neighbor))</code>.</li>
<li>Return <code>time[node] + ans</code>.</li>
</ul>
</li>
<li>Call <code>dfs(node)</code> for all nodes and return the maximum value.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/eDAN7FLi/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(e\)</span> as the length of <code>relations</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p>It costs <span class="math inline">\(O(e)\)</span> to build <code>graph</code>.</p>
<p>Because we memoized <code>dfs</code>, we never calculate <code>dfs</code> for a given <code>node</code> more than once. In <code>dfs</code>, we have a for loop. This for loop will iterate <span class="math inline">\(O(e)\)</span> times across all iterations, since we can never iterate over an edge more than once. Thus, the total time for all <code>dfs</code> calls is <span class="math inline">\(O(n + e)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + e)\)</span></p>
<p><code>graph</code> takes <span class="math inline">\(O(n + e)\)</span> space, <code>memo</code> takes <span class="math inline">\(O(n)\)</span> space, and the recursion call stack can take up to <span class="math inline">\(O(n)\)</span> space in the worst-case scenario (when this directed graph degenerates into a linked list.)</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rank-transform-of-a-matrix/description" target="_blank" rel="noopener noreferrer">Rank Transform of a Matrix</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">topological sort</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>m x n</code> <code>matrix</code>, return <em>a new matrix </em><code>answer</code><em> where </em><code>answer[row][col]</code><em> is the </em><em><strong>rank</strong> of </em><code>matrix[row][col]</code>.</p>

<p>The <strong>rank</strong> is an <strong>integer</strong> that represents how large an element is compared to other elements. It is calculated using the following rules:</p>

<ul>
	<li>The rank is an integer starting from <code>1</code>.</li>
	<li>If two elements <code>p</code> and <code>q</code> are in the <strong>same row or column</strong>, then:
	<ul>
		<li>If <code>p &lt; q</code> then <code>rank(p) &lt; rank(q)</code></li>
		<li>If <code>p == q</code> then <code>rank(p) == rank(q)</code></li>
		<li>If <code>p &gt; q</code> then <code>rank(p) &gt; rank(q)</code></li>
	</ul>
	</li>
	<li>The <strong>rank</strong> should be as <strong>small</strong> as possible.</li>
</ul>

<p>The test cases are generated so that <code>answer</code> is unique under the given rules.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[1,2],[3,4]]
<strong>Output:</strong> [[1,2],[2,3]]
<strong>Explanation:</strong>
The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.
The rank of matrix[0][1] is 2 because matrix[0][1] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][0] is 2 because matrix[1][0] &gt; matrix[0][0] and matrix[0][0] is rank 1.
The rank of matrix[1][1] is 3 because matrix[1][1] &gt; matrix[0][1], matrix[1][1] &gt; matrix[1][0], and both matrix[0][1] and matrix[1][0] are rank 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg" style="width: 442px; height: 162px;" />
<pre>
<strong>Input:</strong> matrix = [[7,7],[7,7]]
<strong>Output:</strong> [[1,1],[1,1]]
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg" style="width: 601px; height: 322px;" />
<pre>
<strong>Input:</strong> matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
<strong>Output:</strong> [[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description" target="_blank" rel="noopener noreferrer">Sort Items by Groups Respecting Dependencies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">graph</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are&nbsp;<code>n</code>&nbsp;items each&nbsp;belonging to zero or one of&nbsp;<code>m</code>&nbsp;groups where <code>group[i]</code>&nbsp;is the group that the <code>i</code>-th item belongs to and it&#39;s equal to <code>-1</code>&nbsp;if the <code>i</code>-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.</p>

<p>Return a sorted list of the items such that:</p>

<ul>
	<li>The items that belong to the same group are next to each other in the sorted list.</li>
	<li>There are some&nbsp;relations&nbsp;between these items where&nbsp;<code>beforeItems[i]</code>&nbsp;is a list containing all the items that should come before the&nbsp;<code>i</code>-th item in the sorted array (to the left of the&nbsp;<code>i</code>-th item).</li>
</ul>

<p>Return any solution if there is more than one solution and return an <strong>empty list</strong>&nbsp;if there is no solution.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2019/09/11/1359_ex1.png" style="width: 191px; height: 181px;" /></strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
<strong>Output:</strong> [6,3,4,1,5,2,0,7]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
<strong>Output:</strong> []
<strong>Explanation:</strong>&nbsp;This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>group.length == beforeItems.length == n</code></li>
	<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
	<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
	<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
	<li><code>i != beforeItems[i][j]</code></li>
	<li><code>beforeItems[i]&nbsp;</code>does not contain&nbsp;duplicates elements.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/strange-printer-ii/description" target="_blank" rel="noopener noreferrer">Strange Printer II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">matrix</span> <span class="topic-badge">topological sort</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There is a strange printer with the following two special requirements:</p>

<ul>
	<li>On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.</li>
	<li>Once the printer has used a color for the above operation, <strong>the same color cannot be used again</strong>.</li>
</ul>

<p>You are given a <code>m x n</code> matrix <code>targetGrid</code>, where <code>targetGrid[row][col]</code> is the color in the position <code>(row, col)</code> of the grid.</p>

<p>Return <code>true</code><em> if it is possible to print the matrix </em><code>targetGrid</code><em>,</em><em> otherwise, return </em><code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print1.jpg" style="width: 600px; height: 175px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/23/print2.jpg" style="width: 600px; height: 367px;" />
<pre>
<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to form targetGrid because it is not allowed to print the same color in different turns.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == targetGrid.length</code></li>
	<li><code>n == targetGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 60</code></li>
	<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>