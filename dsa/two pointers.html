<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>two pointers - Programming Questions</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background-color: #0d1117;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #f0f6fc;
            padding: 40px 30px;
            border-bottom: 2px solid #30363d;
        }
        
        .header h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: #58a6ff;
            text-transform: capitalize;
            letter-spacing: -0.02em;
        }
        
        .header-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 15px;
        }
        
        .header-info p {
            font-size: 1.1rem;
            color: #8b949e;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-info strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .header-badge {
            background-color: #238636;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .content {
            padding: 40px 30px;
        }
        
        .toc {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toc h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
        }
        
        .toc li {
            padding: 12px 0;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .toc li:last-child {
            border-bottom: none;
        }
        
        .toc li:hover {
            background-color: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .toc-link {
            color: #e0e0e0;
            text-decoration: none;
            flex: 1;
            font-weight: 500;
            transition: color 0.2s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin-right: 10px;
        }
        
        .toc-link:hover {
            color: #58a6ff;
        }
        
        .toc-platform {
            color: #8b949e;
            font-size: 0.85rem;
            background-color: #30363d;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 500;
            flex-shrink: 0;
        }
        
        .question-card {
            border: 1px solid #30363d;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .question-title-section {
            flex: 1;
            min-width: 200px;
        }
        
        .question-title {
            margin: 0;
        }
        
        .question-title a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 1.4rem;
            font-weight: 600;
            line-height: 1.3;
            transition: color 0.2s ease;
        }
        
        .question-title a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        .question-meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        
        .platform-badge {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .difficulty-badge.easy {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
        }
        
        .difficulty-badge.medium {
            background: linear-gradient(135deg, #da7633 0%, #fb8500 100%);
        }
        
        .difficulty-badge.hard {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
        }
        
        .availability-badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .availability-badge.solution {
            background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
        }
        
        .availability-badge.explanation {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        }
        
        .topics-section {
            margin-bottom: 25px;
            padding: 20px;
            background-color: #0d1117;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        
        .topics-section strong {
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .topic-badge {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-right: 8px;
            margin-bottom: 6px;
            display: inline-block;
            font-weight: 500;
            border: 1px solid #30363d;
            transition: all 0.2s ease;
        }
        
        .topic-badge:hover {
            background: linear-gradient(135deg, #58a6ff 0%, #79c0ff 100%);
            color: white;
            transform: translateY(-1px);
        }
        
        .content-section {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .solution-section, .explanation-section {
            margin: 25px 0;
        }
        
        .solution-section h3, .explanation-section h3 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Enhanced content styling */
        .content-section h1, .content-section h2, .content-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f0f6fc;
            font-weight: 600;
        }
        
        .content-section p {
            margin-bottom: 15px;
            color: #e0e0e0;
            line-height: 1.7;
        }
        
        .content-section ul, .content-section ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        
        .content-section li {
            margin-bottom: 8px;
        }
        
        .content-section pre {
            background: linear-gradient(135deg, #161b22 0%, #0d1117 100%);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 15px 0;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .content-section code {
            background-color: #21262d;
            border-radius: 4px;
            font-size: 0.9rem;
            padding: 0.3em 0.5em;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: #f85149;
            border: 1px solid #30363d;
        }
        
        .content-section pre code {
            background-color: transparent;
            padding: 0;
            color: #e0e0e0;
            border: none;
        }
        
        .content-section a {
            color: #58a6ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .content-section a:hover {
            color: #79c0ff;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header-info {
                gap: 15px;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .content {
                padding: 25px 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .question-meta {
                width: 100%;
            }
            
            .toc {
                padding: 20px;
            }
            
            .question-card {
                padding: 25px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>two pointers</h1>
            <div class="header-info">
                <p><strong>Total Questions:</strong> <span class="header-badge">219</span></p>
                <p><strong>Generated by:</strong> pushkar</p>
                <p><strong>Date:</strong> August 24, 2025</p>
            </div>
        </header>
        
        <div class="content">
            <div class="toc">
                <h2>📋 Table of Contents</h2>
                <ul>
                    <li><a href="#question-0" class="toc-link">2 Sum - Find a pair with given sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-1" class="toc-link">3Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-2" class="toc-link">3 Sum Closest</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-3" class="toc-link">3Sum Closest</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-4" class="toc-link">3Sum With Multiplicity</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-5" class="toc-link">4Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-6" class="toc-link">4 Sum - All Quadruples</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-7" class="toc-link">Adding Spaces to a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-8" class="toc-link">Advantage Shuffle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-9" class="toc-link">Append Characters to String to Make Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-10" class="toc-link">Apply Operations to an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-11" class="toc-link">Assign Cookies</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-12" class="toc-link">Backspace String Compare</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-13" class="toc-link">Bag of Tokens</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-14" class="toc-link">Binary Array Sorting</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-15" class="toc-link">Boats to Save People</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-16" class="toc-link">Camelcase Matching</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-17" class="toc-link">Check if a String is Subsequence of Other</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-18" class="toc-link">Check If a Word Occurs As a Prefix of Any Word in a Sentence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-19" class="toc-link">Check If N and Its Double Exist</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-20" class="toc-link">Check If String Is a Prefix of Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-21" class="toc-link">Checking Existence of Edge Length Limited Paths</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-22" class="toc-link">Circular Array Loop</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-23" class="toc-link">Closest Pair Sum in an unsorted Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-24" class="toc-link">Closest Subsequence Sum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-25" class="toc-link">Coin Piles</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-26" class="toc-link">Compare Version Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-27" class="toc-link">Container With Most Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-28" class="toc-link">Count Binary Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-29" class="toc-link">Count Pairs Of Nodes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-30" class="toc-link">Count Pairs whose sum is less than target</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-31" class="toc-link">Count Pairs Whose Sum is Less than Target</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-32" class="toc-link">Count the Number of Fair Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-33" class="toc-link">Count the Number of Incremovable Subarrays I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-34" class="toc-link">Count the Number of Incremovable Subarrays II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-35" class="toc-link">Count the triplets</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-36" class="toc-link">Create Maximum Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-37" class="toc-link">Delete the Middle Node of a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-38" class="toc-link">DI String Match</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-39" class="toc-link">Divide Intervals Into Minimum Number of Groups</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-40" class="toc-link">Divide Players Into Teams of Equal Skill</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-41" class="toc-link">Dominant Pairs</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-42" class="toc-link">Duplicate Zeros</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-43" class="toc-link">Earliest Common Slot</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-44" class="toc-link">Earliest Finish Time for Land and Water Rides I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-45" class="toc-link">Earliest Finish Time for Land and Water Rides II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-46" class="toc-link">Expressive Words</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-47" class="toc-link">Find all distinct triplets with given sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-48" class="toc-link">Find All K-Distant Indices in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-49" class="toc-link">Find all triplets with given sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-50" class="toc-link">Find Beautiful Indices in the Given Array I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-51" class="toc-link">Find Beautiful Indices in the Given Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-52" class="toc-link">Find First Palindromic String in the Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-53" class="toc-link">Find Indices With Index and Value Difference I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-54" class="toc-link">Find Indices With Index and Value Difference II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-55" class="toc-link">Find K Closest Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-56" class="toc-link">Find K-th Smallest Pair Distance</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-57" class="toc-link">Find Maximum Removals From Source String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-58" class="toc-link">Find Median from Data Stream</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-59" class="toc-link">Find pair with sum target in an absolute sorted array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-60" class="toc-link">Find Positive Integer Solution for a Given Equation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-61" class="toc-link">Find the Array Concatenation Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-62" class="toc-link">Find the Distance Value Between Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-63" class="toc-link">Find the Duplicate Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-64" class="toc-link">Find the Index of the First Occurrence in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-65" class="toc-link">Find the Integer Added to Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-66" class="toc-link">Find the Lexicographically Largest String From the Box I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-67" class="toc-link">Find the Lexicographically Smallest Valid Sequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-68" class="toc-link">Find the Maximum Number of Marked Indices</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-69" class="toc-link">Find triplets with zero sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-70" class="toc-link">First negative in every window of size k</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-71" class="toc-link">Flipping an Image</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-72" class="toc-link">Flip Square Submatrix Vertically</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-73" class="toc-link">Form Array by Concatenating Subarrays of Another Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-74" class="toc-link">Friends Of Appropriate Ages</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-75" class="toc-link">Get the Maximum Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-76" class="toc-link">Happy Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-77" class="toc-link">Heaters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-78" class="toc-link">Intersection of Two Arrays</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-79" class="toc-link">Intersection of Two Arrays II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-80" class="toc-link">Intersection of Two arrays with Duplicate Elements</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-81" class="toc-link">Intersection of Two Linked Lists</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-82" class="toc-link">Interval List Intersections</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-83" class="toc-link">Ishaan Loves Chocolates</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-84" class="toc-link">Is Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-85" class="toc-link">K-diff Pairs in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-86" class="toc-link">K-th Smallest Prime Fraction</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-87" class="toc-link">Largest Merge Of Two Strings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-88" class="toc-link">Largest Positive Integer That Exists With Its Negative</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-89" class="toc-link">Last Substring in Lexicographical Order</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-90" class="toc-link">Lexicographically Smallest Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-91" class="toc-link">Linked List Cycle</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-92" class="toc-link">Linked List Cycle II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-93" class="toc-link">Longest Chunked Palindrome Decomposition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-94" class="toc-link">Longest Mountain in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-95" class="toc-link">Longest Palindrome After Substring Concatenation I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-96" class="toc-link">Longest Palindrome After Substring Concatenation II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-97" class="toc-link">Longest Palindromic Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-98" class="toc-link">Longest String Chain</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-99" class="toc-link">Longest Uncommon Subsequence II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-100" class="toc-link">Longest Word in Dictionary through Deleting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-101" class="toc-link">Long Pressed Name</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-102" class="toc-link">Magical String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-103" class="toc-link">Make String a Subsequence Using Cyclic Increments</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-104" class="toc-link">Maximize Greatness of an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-105" class="toc-link">Maximum Distance Between a Pair of Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-106" class="toc-link">Maximum Enemy Forts That Can Be Captured</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-107" class="toc-link">Maximum Matching of Players With Trainers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-108" class="toc-link">Maximum Number of Non-overlapping Palindrome Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-109" class="toc-link">Maximum Number of Points From Grid Queries</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-110" class="toc-link">Maximum Number of Removable Characters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-111" class="toc-link">Maximum Number of Tasks You Can Assign</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-112" class="toc-link">Maximum Product of First and Last Elements of a Subsequence</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-113" class="toc-link">Maximum Score of a Good Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-114" class="toc-link">Maximum subarray sum 2</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-115" class="toc-link">Maximum Total Beauty of the Gardens</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-116" class="toc-link">Maximum Total Damage With Spell Casting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-117" class="toc-link">Maximum Total from Optimal Activation Order</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-118" class="toc-link">Maximum Twin Sum of a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-119" class="toc-link">Maximum Width Ramp</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-120" class="toc-link">Max Number of K-Sum Pairs</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-121" class="toc-link">Meeting Rooms II</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-122" class="toc-link">Merge Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-123" class="toc-link">Merge Strings Alternately</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-124" class="toc-link">Merge Two 2D Arrays by Summing Values</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-125" class="toc-link">Merge Without Extra Space</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-126" class="toc-link">Middle of the Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-127" class="toc-link">Minimize Maximum Pair Sum in Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-128" class="toc-link">Minimize the Heights I</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-129" class="toc-link">Minimum Adjacent Swaps to Reach the Kth Smallest Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-130" class="toc-link">Minimum Array Length After Pair Removals</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-131" class="toc-link">Minimum Average of Smallest and Largest Elements</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-132" class="toc-link">Minimum Changes to Make K Semi-palindromes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-133" class="toc-link">Minimum Common Value</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-134" class="toc-link">Minimum Length of String After Deleting Similar Ends</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-135" class="toc-link">Minimum Number of Flips to Make Binary Grid Palindromic I</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-136" class="toc-link">Minimum Number of Flips to Make Binary Grid Palindromic II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-137" class="toc-link">Minimum Number of Moves to Make Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-138" class="toc-link">Minimum Number of Swaps to Make the String Balanced</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-139" class="toc-link">Most Profit Assigning Work</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-140" class="toc-link">Move Pieces to Obtain a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-141" class="toc-link">Move Zeroes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-142" class="toc-link">Next Greater Element III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-143" class="toc-link">Next Permutation</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-144" class="toc-link">Number of Arithmetic Triplets</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-145" class="toc-link">Number of Distinct Averages</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-146" class="toc-link">Number of Subarrays with Bounded Maximum</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-147" class="toc-link">Number of Subsequences That Satisfy the Given Sum Condition</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-148" class="toc-link">Number of Ways Where Square of Number Is Equal to Product of Two Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-149" class="toc-link">Palindrome Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-150" class="toc-link">Palindromic Substrings</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-151" class="toc-link">Pancake Sorting</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-152" class="toc-link">Partition Array According to Given Pivot</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-153" class="toc-link">Partition Array Into Two Arrays to Minimize Sum Difference</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-154" class="toc-link">Partition Labels</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-155" class="toc-link">Partition List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-156" class="toc-link">Permutation in String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-157" class="toc-link">Police and Thieves</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-158" class="toc-link">Push Dominoes</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-159" class="toc-link">Range Sum of Sorted Subarray Sums</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-160" class="toc-link">Rearrange Array Elements by Sign</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-161" class="toc-link">Recover the Original Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-162" class="toc-link">Remove Duplicates from Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-163" class="toc-link">Remove Duplicates from Sorted Array II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-164" class="toc-link">Remove Duplicates from Sorted List II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-165" class="toc-link">Remove Element</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-166" class="toc-link">Remove Nth Node From End of List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-167" class="toc-link">Remove Palindromic Subsequences</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-168" class="toc-link">Reorder List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-169" class="toc-link">Reverse Only Letters</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-170" class="toc-link">Reverse Prefix of Word</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-171" class="toc-link">Reverse String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-172" class="toc-link">Reverse String II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-173" class="toc-link">Reverse Vowels of a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-174" class="toc-link">Reverse Words in a String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-175" class="toc-link">Reverse Words in a String III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-176" class="toc-link">Rotate Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-177" class="toc-link">Rotate List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-178" class="toc-link">Rotating the Box</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-179" class="toc-link">Row with Max 1s</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-180" class="toc-link">Sentence Similarity III</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-181" class="toc-link">Separate Black and White Balls</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-182" class="toc-link">Shortest Distance to a Character</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-183" class="toc-link">Shortest Matching Substring</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-184" class="toc-link">Shortest Range In BST</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-185" class="toc-link">Shortest Subarray to be Removed to Make Array Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-186" class="toc-link">Shortest Unsorted Continuous Subarray</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-187" class="toc-link">Sort Array By Parity</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-188" class="toc-link">Sort Array By Parity II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-189" class="toc-link">Sort Colors</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-190" class="toc-link">Sort List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-191" class="toc-link">Sort the Half Sorted</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-192" class="toc-link">Split Two Strings to Make Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-193" class="toc-link">Squares of a Sorted Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-194" class="toc-link">Strictly Palindromic Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-195" class="toc-link">String Compression</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-196" class="toc-link">Subsequence With the Minimum Score</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-197" class="toc-link">Successful Pairs of Spells and Potions</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-198" class="toc-link">Sum of Mode</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-199" class="toc-link">Sum of Square Numbers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-200" class="toc-link">Swap Adjacent in LR String</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-201" class="toc-link">Swapping Nodes in a Linked List</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-202" class="toc-link">The Celebrity Problem</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-203" class="toc-link">The k Strongest Values in an Array</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-204" class="toc-link">The Latest Time to Catch a Bus</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-205" class="toc-link">Three Sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-206" class="toc-link">Total Cost to Hire K Workers</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-207" class="toc-link">Trapping Rain Water</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-208" class="toc-link">Trapping Rain Water</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-209" class="toc-link">Triplet Sum in Array</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-210" class="toc-link">Two Sum II - Input Array Is Sorted</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-211" class="toc-link">Two Sum IV - Input is a BST</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-212" class="toc-link">Two sum -Pairs with 0 Sum</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-213" class="toc-link">Valid Palindrome</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-214" class="toc-link">Valid Palindrome II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-215" class="toc-link">Valid Substring</a> <span class="toc-platform">GeeksForGeeks</span></li>
<li><a href="#question-216" class="toc-link">Valid Triangle Number</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-217" class="toc-link">Watering Plants II</a> <span class="toc-platform">LeetCode</span></li>
<li><a href="#question-218" class="toc-link">Ways to Split Array Into Three Subarrays</a> <span class="toc-platform">LeetCode</span></li>
                </ul>
            </div>
            
            <div class="question-card" id="question-0">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/2-sum-find-a-pair-with-given-sum/1" target="_blank" rel="noopener noreferrer">2 Sum - Find a pair with given sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;and an integer&nbsp;<strong>target</strong>.&nbsp;</span><span style="font-size: 18px;">You have to return the pair of elements which sum upto <strong>target</strong>.<strong> </strong></span><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">You cannot use the same element&nbsp;</span><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;"><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;">twice</span></span><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">.<br /></span><span style="font-size: 18px;"><strong>Note:</strong> Inputs are given such that only one valid answer exists.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">arr[] = [2, 9, 10, 4, 15], target = 12</span><span style="font-size: 18px;">
<strong>Output: </strong>[2, 10]<strong>
Explanation: </strong></span><span style="font-size: 18px;">Pair with sum equal to 12 is (2, 10).</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [3, 2, 4], target = 8
<strong>Output: </strong>[]<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">No pair exists with sum equal to 8.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 4, 5, 6, 1],</span><span style="font-size: 18px;"> target = 2</span><span style="font-size: 18px;">
<strong>Output: </strong>[1, 1]</span><span style="font-size: 14pt;"><strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">Pair with sum equal to 2 is (1, 1).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= arr.size() &lt;= 10<sup>5</sup><strong><br /></strong></span><span style="font-size: 18px;">0 &lt;= arr[i]&nbsp;</span><span style="font-size: 18px;">&lt;= 10<sup>4</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">1 &lt;= target &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-1">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/3sum/description" target="_blank" rel="noopener noreferrer">3Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>

<p>Notice that the solution set must not contain duplicate triplets.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]
<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]
<strong>Explanation:</strong> 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,1]
<strong>Output:</strong> []
<strong>Explanation:</strong> The only possible triplet does not sum up to 0.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0]
<strong>Output:</strong> [[0,0,0]]
<strong>Explanation:</strong> The only possible triplet sums up to 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-2">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/3-sum-closest/1" target="_blank" rel="noopener noreferrer">3 Sum Closest</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;and an integer&nbsp;<strong>target</strong>, the task is to find the sum of three integers in&nbsp;<strong>arr[]</strong>&nbsp;such that the sum is closest to&nbsp;<strong>target</strong>.&nbsp;</span></p>
<p><strong><span style="font-size: 18px;">Note:</span></strong><span style="font-size: 18px;"> If multiple sums are closest to target, return the maximum one.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [-1, 2, 2, 4], target = 4
<strong>Output:</strong> 5
<strong>Explanation:</strong> All possible triplets<br /></span><span style="font-size: 18px;">[-1, 2, 2], sum = (-1) + 2 + 2 = 3
[-1, 2, 4], sum = (-1) + 2 + 4 = 5
[-1, 2, 4], sum = (-1) + 2 + 4 = 5
[2, 2, 4], sum = 2 + 2 + 4 = 8
Triplet [-1, 2, 2], [-1, 2, 4] and [-1, 2, 4] have sum closest to target, so return the maximum one, that is 5.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 10, 4, 5], target = 10
<strong>Output:</strong> 10
<strong>Explanation:</strong> All possible triplets<br /></span><span style="font-size: 18px;">[1, 10, 4], sum = (1 + 10 + 4) = 15<br /></span><span style="font-size: 18px;">[1, 10, 5], sum = (1 + 10 + 5) = 16<br /></span><span style="font-size: 18px;">[1, 4, 5], sum = (1 + 4 + 5) = 10<br /></span><span style="font-size: 18px;">[10, 4, 5], sum = (10 + 4 + 5) = 19&nbsp;<br /></span><span style="font-size: 18px;">Triplet [1, 4, 5] has sum = 10 which is closest to target.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />3 &le; arr.size() &le; 10<sup>3</sup><br />-10<sup>3</sup>&nbsp;&le; arr[i] &le; 10<sup>3</sup><br />-10<sup>4</sup>&nbsp;&le; target &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-3">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/3sum-closest/description" target="_blank" rel="noopener noreferrer">3Sum Closest</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>

<p>Return <em>the sum of the three integers</em>.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,2,1,-4], target = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,0], target = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 500</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-4">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/3sum-with-multiplicity/description" target="_blank" rel="noopener noreferrer">3Sum With Multiplicity</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, and an integer <code>target</code>, return the number of tuples <code>i, j, k</code> such that <code>i &lt; j &lt; k</code> and <code>arr[i] + arr[j] + arr[k] == target</code>.</p>

<p>As the answer can be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,2,2,3,3,4,4,5,5], target = 8
<strong>Output:</strong> 20
<strong>Explanation: </strong>
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,2,2,2,2], target = 5
<strong>Output:</strong> 12
<strong>Explanation: </strong>
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,3], target = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> (1, 2, 3) occured one time in the array so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= arr.length &lt;= 3000</code></li>
	<li><code>0 &lt;= arr[i] &lt;= 100</code></li>
	<li><code>0 &lt;= target &lt;= 300</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-5">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/4sum/description" target="_blank" rel="noopener noreferrer">4Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>

<ul>
	<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>
	<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>
	<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>

<p>You may return the answer in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0
<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,2,2], target = 8
<strong>Output:</strong> [[2,2,2,2]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 200</code></li>
	<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<p>This problem is a follow-up of <a href="https://leetcode.com/articles/3sum/">3Sum</a>, so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.</p>
<p>As you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value <code>v</code>, it finds all pairs whose sum is equal to <code>target - v</code> using one of these approaches:</p>
<ol>
<li><a href="https://leetcode.com/articles/two-sum/">Two Sum</a> uses a hash set to check for a matching value.</li>
<li><a href="https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/">Two Sum II</a> uses the two pointers pattern in a sorted array.</li>
</ol>
<p>Following a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.</p>
<hr />
<h3 id="approach-1-two-pointers">Approach 1: Two Pointers</h3>
<p><strong>Intuition</strong></p>
<p>The two pointers pattern requires the array to be sorted, so we do that first.  Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.</p>
<p>For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have <code>k - 2</code> nested loops to enumerate all combinations of <code>k - 2</code> values.</p>
<p>!?!../Documents/18_4Sum.json:1200,440!?!</p>
<p><strong>Algorithm</strong></p>
<p>We can implement <code>k - 2</code> loops using a recursion. We will pass the starting point and <code>k</code> as the parameters. When <code>k == 2</code>, we will call <code>twoSum</code>, terminating the recursion.</p>
<ol>
<li>
<p>For the main function:</p>
<ul>
<li>Sort the input array <code>nums</code>.</li>
<li>Call <code>kSum</code> with <code>start = 0</code>, <code>k = 4</code>, and <code>target</code>, and return the result.</li>
</ul>
</li>
<li>
<p>For <code>kSum</code> function:</p>
<ul>
<li>At the start of the <code>kSum</code> function, we will check three conditions:
<ol>
<li>Have we run out of numbers to choose from?</li>
<li>Is the smallest number remaining greater than <code>target / k</code>? <br>If so, then any <code>k</code> numbers we choose will be too large.</li>
<li>Is the largest number remaining smaller than <code>target / k</code>? <br>If so, then any <code>k</code> numbers we choose will be too small.</li>
</ol>
<ul>
<li>If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to <code>target</code>.</li>
</ul>
</li>
<li>If <code>k</code> equals <code>2</code>, call <code>twoSum</code> and return the result.</li>
<li>Iterate <code>i</code> through the array from <code>start</code>:
<ul>
<li>If the current value is the same as the one before, skip it.</li>
<li>Recursively call <code>kSum</code> with <code>start = i + 1</code>, <code>k = k - 1</code>, and <code>target - nums[i]</code>.</li>
<li>For each returned <code>subset</code> of values:
<ul>
<li>Include the current value <code>nums[i]</code> into <code>subset</code>.</li>
<li>Add <code>subset</code> to the result <code>res</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the result <code>res</code>.</li>
</ul>
</li>
<li>
<p>For <code>twoSum</code> function:</p>
<ul>
<li>Set the low pointer <code>lo</code> to <code>start</code>, and high pointer <code>hi</code> to the last index.</li>
<li>While low pointer is smaller than high:
<ul>
<li>If the sum of <code>nums[lo]</code> and <code>nums[hi]</code> is less than <code>target</code>, increment <code>lo</code>.
<ul>
<li>Also increment <code>lo</code> if the value is the same as for <code>lo - 1</code>.</li>
</ul>
</li>
<li>If the sum is greater than <code>target</code>, decrement <code>hi</code>.
<ul>
<li>Also decrement <code>hi</code> if the value is the same as for <code>hi + 1</code>.</li>
</ul>
</li>
<li>Otherwise, we found a pair:
<ul>
<li>Add it to the result <code>res</code>.</li>
<li>Decrement <code>hi</code> and increment <code>lo</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return the result <code>res</code>.</li>
</ul>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/mQdTCUXD/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^{k - 1})\)</span>, or <span class="math inline">\(O(n^3)\)</span> for 4Sum. We have <span class="math inline">\(k - 2\)</span> loops, and <code>twoSum</code> is <span class="math inline">\(O(n)\)</span>.</p>
<p>Note that for <span class="math inline">\(k > 2\)</span>, sorting the array does not change the overall time complexity.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span>. We need <span class="math inline">\(O(k)\)</span> space for the recursion. <span class="math inline">\(k\)</span> can be the same as <span class="math inline">\(n\)</span> in the worst case for the generalized algorithm.</p>
<p>Note that, for the purpose of complexity analysis, we ignore the memory required for the output.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-hash-set">Approach 2: Hash Set</h3>
<p><strong>Intuition</strong></p>
<p>Since elements must sum up to the exact target value, we can also use the <a href="https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table">Two Sum: One-pass Hash Table</a> approach.</p>
<p>In <a href="https://leetcode.com/articles/3sum/#approach-2-hash-set">3Sum: Hash Set</a>, we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.</p>
<p>So, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the <code>twoSum</code> implementation.</p>
<p><strong>Algorithm</strong></p>
<p><code>twoSum</code> implementation here is almost the same as in <a href="https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table">Two Sum: One-pass Hash Table</a>. The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result <code>res</code>.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/oAq3g56d/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^{k - 1})\)</span>, or <span class="math inline">\(O(n^3)\)</span> for 4Sum. We have <span class="math inline">\(k - 2\)</span> loops iterating over <span class="math inline">\(n\)</span> elements, and <code>twoSum</code> is <span class="math inline">\(O(n)\)</span>.</p>
<p>Note that for <span class="math inline">\(k > 2\)</span>, sorting the array does not change the overall time complexity.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span> for the hash set. The space needed for the recursion will not exceed <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-6">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-all-four-sum-numbers1732/1" target="_blank" rel="noopener noreferrer">4 Sum - All Quadruples</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;"><span style="font-size: 18px;">Given an array </span><strong style="font-size: 18px;">arr[]</strong><span style="font-size: 18px;"> of integers and another integer </span><strong style="font-size: 18px;">target</strong><span style="font-size: 18px;">. You have to find all </span><strong style="font-size: 18px;">unique </strong><span style="font-size: 18px;">quadruples from the given array whose <strong>sum </strong>is equal to the given <strong>target</strong>.</span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong>Note:</strong> All the quadruples should be internally sorted, i.e for any quadruple [q1, q2, q3, q4] it should be : q1 &le; q2 &le; q3 &le; q4.</span></span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [0, 0, 2, 1, 1], target = 3<br /><strong>Output:</strong> [[0, 0, 1, 2]]<strong>
Explanation: </strong>Sum of 0, 0, 1, 2 is equal to 3.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [10, 2, 3, 4, 5, 7, 8], target = 23
<strong>Output: </strong>[[2, 3, 8, 10], [2, 4, 7, 10], [3, 5, 7, 8]] <strong>
Explanation: </strong>Sum of [2, 3, 8, 10] is 23, sum of [2, 4, 7, 10] is 23 and sum of [3, 5, 7, 8] is also 23.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [0, 0, 2, 1, 1], target = 2<br /><strong>Output:</strong> [[0, 0, 1, 1]]<strong>
Explanation: </strong>Sum of [0, 0, 1, 1] is equal to 2.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 200<br />-10<sup>6</sup> &le; target &le; 10<sup>6</sup><br />-10<sup>6</sup> &le; arr[i] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-7">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/adding-spaces-to-a-string/description" target="_blank" rel="noopener noreferrer">Adding Spaces to a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> and a <strong>0-indexed</strong> integer array <code>spaces</code> that describes the indices in the original string where spaces will be added. Each space should be inserted <strong>before</strong> the character at the given index.</p>

<ul>
	<li>For example, given <code>s = &quot;EnjoyYourCoffee&quot;</code> and <code>spaces = [5, 9]</code>, we place spaces before <code>&#39;Y&#39;</code> and <code>&#39;C&#39;</code>, which are at indices <code>5</code> and <code>9</code> respectively. Thus, we obtain <code>&quot;Enjoy <strong><u>Y</u></strong>our <u><strong>C</strong></u>offee&quot;</code>.</li>
</ul>

<p>Return<strong> </strong><em>the modified string <strong>after</strong> the spaces have been added.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;LeetcodeHelpsMeLearn&quot;, spaces = [8,13,15]
<strong>Output:</strong> &quot;Leetcode Helps Me Learn&quot;
<strong>Explanation:</strong> 
The indices 8, 13, and 15 correspond to the underlined characters in &quot;Leetcode<u><strong>H</strong></u>elps<u><strong>M</strong></u>e<u><strong>L</strong></u>earn&quot;.
We then place spaces before those characters.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;icodeinpython&quot;, spaces = [1,5,7,9]
<strong>Output:</strong> &quot;i code in py thon&quot;
<strong>Explanation:</strong>
The indices 1, 5, 7, and 9 correspond to the underlined characters in &quot;i<u><strong>c</strong></u>ode<u><strong>i</strong></u>n<u><strong>p</strong></u>y<u><strong>t</strong></u>hon&quot;.
We then place spaces before those characters.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;spacing&quot;, spaces = [0,1,2,3,4,5,6]
<strong>Output:</strong> &quot; s p a c i n g&quot;
<strong>Explanation:</strong>
We are also able to place spaces before the first character of the string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of lowercase and uppercase English letters.</li>
	<li><code>1 &lt;= spaces.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li>
	<li>All the values of <code>spaces</code> are <strong>strictly increasing</strong>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> and an integer array <code>spaces</code>. The task is to return a modified string with spaces inserted at the indices specified in the given array.</p>
<p>For example, let's take <code>s = &quot;LeetcodeHelpsMeLearn&quot;</code> and <code>spaces = [8, 13, 15]</code>. We will insert a space before the <code>'H'</code> at index <code>8</code>, the <code>'M'</code> at index <code>13</code>, and the <code>'L'</code> at index <code>15</code>. After inserting the spaces, the string will look like this: <code>&quot;Leetcode Helps Me Learn&quot;</code>.</p>
<p>Before moving to the approach, let's discuss a few built-in functions that are designed to help build or modify strings.</p>
<h5 id="for-java-users">For Java Users</h5>
<ul>
<li><code>StringBuilder</code>: The <code>StringBuilder</code> class is designed for building and manipulating strings. It is more efficient than using the <code>String</code> class directly because it is mutable, meaning its contents can be changed without creating a new object each time.</li>
</ul>
<p>Let's break down some common operations you can perform with <code>StringBuilder</code>:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1. Initializing a StringBuilder Object
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>StringBuilder result <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> StringBuilder<span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2. Appending a Space
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>result<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">append</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#39; &#39;</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 3. Appending a Character from a String
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>result<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">append</span><span style="color:#000;font-weight:bold">(</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>stringIndex<span style="color:#000;font-weight:bold">));</span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 4. Converting StringBuilder to a String
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>String finalString <span style="color:#000;font-weight:bold">=</span> result<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">toString</span><span style="color:#000;font-weight:bold">();</span>
</span></span></code></pre><h3 id="for-python-users">For Python Users</h3>
<ul>
<li><code>List</code>: Lists are mutable sequences, typically used to store collections of items. They allow for efficient append operations, making them ideal for building and manipulating strings dynamically.</li>
</ul>
<p>Let's break down some common operations you can perform with <code>List</code>:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 1. Initializing an empty list</span>
</span></span><span style="display:flex;"><span>result <span style="color:#000;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 2. Appending a space to the list</span>
</span></span><span style="display:flex;"><span>result<span style="color:#000;font-weight:bold">.</span>append(<span style="color:#d14">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 3. Appending the character at the specified index from the string `s`</span>
</span></span><span style="display:flex;"><span>result<span style="color:#000;font-weight:bold">.</span>append(s[string_index])
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 4. Joining all elements in the list into a single string</span>
</span></span><span style="display:flex;"><span>final_string <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span><span style="color:#000;font-weight:bold">.</span>join(result)
</span></span></code></pre><h3 id="for-c-users">For C++ Users</h3>
<ul>
<li><code>stringstream</code>: The <code>stringstream</code> class is used for dynamically constructing and manipulating strings. It allows for efficient insertion and extraction of data.</li>
</ul>
<p>Let's break down some common operations you can perform with <code>stringstream</code>:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 1. Initializing a new stringstream object
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>stringstream result;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2. Inserting a space into the stringstream
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>result <span style="color:#000;font-weight:bold">&lt;&lt;</span> <span style="color:#d14">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 3. Inserting the character at the specified index from the string `s`
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>result <span style="color:#000;font-weight:bold">&lt;&lt;</span> s[stringIndex];
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 4. Converting the stringstream to a string
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>string finalString <span style="color:#000;font-weight:bold">=</span> result.str();
</span></span></code></pre><hr />
<h3 id="approach-1-using-built-in-functions">Approach 1: Using Built-in Functions</h3>
<h4 id="intuition">Intuition</h4>
<p>A simple approach to solving this problem is to use built-in functions from the string libraries of your preferred programming language. For example, in C++, the <code>stringstream</code> class provides a higher-level way to build strings dynamically. Instead of manually pre-allocating space, you can append characters and spaces into a stream as you traverse the original string. Each time you encounter an index in the <code>spaces</code> array, you can append a space to the stream, followed by the current character.</p>
<p>This is easier to implement and more intuitive for programmers who are familiar with built-in functions. However, because the underlying buffer of these built-in functions grows dynamically, it is not as memory-efficient as manually constructing the string for this problem.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create a <code>result</code> to dynamically construct the output string.</p>
</li>
<li>
<p>Initialize <code>spaceIndex</code> to <code>0</code> to track the current position in the <code>spaces</code> array.</p>
</li>
<li>
<p>For each <code>stringIndex</code> from <code>0</code> to the end of the string <code>s</code>:</p>
<ul>
<li>If <code>spaceIndex</code> is within bounds of the <code>spaces</code> array and <code>stringIndex</code> matches <code>spaces[spaceIndex]</code>:
<ul>
<li>Append a space (<code>' '</code>) to <code>result</code> to insert a space at the specified position.</li>
<li>Increment <code>spaceIndex</code> to move to the next position in the <code>spaces</code> array.</li>
</ul>
</li>
<li>Append the character <code>s[stringIndex]</code> to <code>result</code>.</li>
</ul>
</li>
<li>
<p>After iterating through the string, convert <code>result</code> to a string and return it as the final output.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/5uUNLTyX/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>, and <code>m</code> be the size of the array <code>spaces</code>, which represents the number of spaces to be added.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The <code>for</code> loop iterates through the string <code>s</code> of length <span class="math inline">\(n\)</span>, which contributes <span class="math inline">\(O(n)\)</span>.</p>
<p>Within the loop, the comparison of <code>stringIndex</code> with <code>spaces[spaceIndex]</code> involves accessing the array <code>spaces</code>, which occurs <code>m</code> times at most (since <code>spaceIndex</code> is incremented for each space insertion). This contributes <span class="math inline">\(O(m)\)</span>.</p>
<p>Using built-in functions to append characters to a dynamic buffer is efficient because append operations are amortized <span class="math inline">\(O(1)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> (if we only count auxiliary space) or <span class="math inline">\(O(n + m)\)</span> (if we count the space for the result)</p>
<p>The built-in function dynamically constructs the result string, which requires space for <span class="math inline">\(n\)</span> characters from the input string <code>s</code> and <code>m</code> spaces to be inserted. This results in <span class="math inline">\(O(n + m)\)</span> space usage for the result string, as this space is required to hold the final output.</p>
<p>However, if we only consider auxiliary space for variables like <code>spaceIndex</code> and <code>stringIndex</code>, which are used to control the loop, the space complexity can be considered <span class="math inline">\(O(1)\)</span>, as they require constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span> when including the space for the result string, but <span class="math inline">\(O(1)\)</span> if we only account for the auxiliary space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer-technique">Approach 2: Two-Pointer Technique</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To further optimize the solution, we can use a two-pointer technique. This involves maintaining two pointers:</p>
<ol>
<li><code>stringIndex</code>, which tracks the current character in the string <code>s</code>.</li>
<li><code>spaceIndex</code>, which tracks the current position in the <code>spaces</code> array.&quot;</li>
</ol>
<p>As we iterate through the string using <code>stringIndex</code>, we check if it matches the current space position given by <code>spaces[spaceIndex]</code>. If they match, we insert a space at that position and move to the next space by incrementing <code>spaceIndex</code>. Regardless of whether a space was added, we append the current character from the string to the <code>result</code>. After processing all the characters, we return the final string with spaces inserted at the specified positions.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2109/2109_adding_spaces.json:700,505!?!</p>
<blockquote>
<p>For a more comprehensive understanding of the two-pointer technique, check out the <a href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">Two Pointer Explore Card 🔗</a>. This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty string <code>result</code> to build the output string with spaces added.</p>
</li>
<li>
<p>Pre-allocate memory for <code>result</code> to improve efficiency, reserving the original string length plus the number of spaces.</p>
</li>
<li>
<p>Initialize <code>spaceIndex</code> to <code>0</code> to track the current position in the <code>spaces</code> array.</p>
</li>
<li>
<p>Iterate through the input string <code>s</code> using <code>stringIndex</code>:</p>
<ul>
<li>
<p>If <code>spaceIndex</code> is less than the size of <code>spaces</code> and <code>stringIndex</code> equals <code>spaces[spaceIndex]</code>:</p>
<ul>
<li>Append a space character <code>' '</code> to <code>result</code> at the specified position.</li>
<li>Increment <code>spaceIndex</code> to process the next space position.</li>
</ul>
</li>
<li>
<p>Append the current character <code>s[stringIndex]</code> to <code>result</code>.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code> after processing all characters in <code>s</code> and adding the specified spaces.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p>Note: By calculating the final size of the string beforehand (original length plus the number of spaces), we can allocate the necessary memory in one go, thereby saving time and avoiding the overhead of resizing the result every time we add something.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/862CsKhj/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the string <code>s</code>, and <code>m</code> be the size of the array <code>spaces</code>, which represents the number of spaces to be added.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>The algorithm iterates through the string <code>s</code> of length <span class="math inline">\(n\)</span> using a <code>for</code> loop, making the primary contribution to the time complexity <span class="math inline">\(O(n)\)</span>.</p>
<p>For every position in <code>s</code>, it checks against the current space index in the <code>spaces</code> array, which has a maximum size of <code>m</code>. Since <code>spaceIndex</code> is incremented only when a space is added, this contributes <span class="math inline">\(O(m)\)</span> to the time complexity.</p>
<p>Appending characters and spaces to the <code>result</code> string is efficient due to the pre-allocation of memory, which ensures these operations occur in amortized <span class="math inline">\(O(1)\)</span>. Thus, the total time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> (if we only count auxiliary space) or <span class="math inline">\(O(n + m)\)</span> (if we count the space for the result)</p>
<p>If we only account for auxiliary space, the space complexity can be considered <span class="math inline">\(O(1)\)</span> because we are using a few integer variables (<code>spaceIndex</code>, <code>stringIndex</code>) to control the flow.</p>
<p>However, since the result string (constructed via built-in functions) holds <span class="math inline">\(n\)</span> characters from <code>s</code> and <code>m</code> spaces, the space required to store the result is <span class="math inline">\(O(n + m)\)</span>. This is the space required for the output string and is a direct consequence of the problem's input/output constraints.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n + m)\)</span> when including the space for the result string, but <span class="math inline">\(O(1)\)</span> if we only account for the auxiliary space.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-8">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/advantage-shuffle/description" target="_blank" rel="noopener noreferrer">Advantage Shuffle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> both of the same length. The <strong>advantage</strong> of <code>nums1</code> with respect to <code>nums2</code> is the number of indices <code>i</code> for which <code>nums1[i] &gt; nums2[i]</code>.</p>

<p>Return <em>any permutation of </em><code>nums1</code><em> that maximizes its <strong>advantage</strong> with respect to </em><code>nums2</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums1 = [2,7,11,15], nums2 = [1,10,4,11]
<strong>Output:</strong> [2,11,7,15]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums1 = [12,24,8,32], nums2 = [13,25,32,11]
<strong>Output:</strong> [24,32,8,12]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums2.length == nums1.length</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-greedy">Approach 1: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>If the smallest card <code>a</code> in <code>A</code> beats the smallest card <code>b</code> in <code>B</code>, we should pair them.  Otherwise, <code>a</code> is useless for our score, as it can't beat any cards.</p>
<p>Why should we pair <code>a</code> and <code>b</code> if <code>a &gt; b</code>?  Because every card in <code>A</code> is larger than <code>b</code>, any card we place in front of <code>b</code> will score a point.  We might as well use the weakest card to pair with <code>b</code> as it makes the rest of the cards in <code>A</code> strictly larger, and thus have more potential to score points.</p>
<p><strong>Algorithm</strong></p>
<p>We can use the above intuition to create a greedy approach.  The current smallest card to beat in <code>B</code> will always be <code>b = sortedB[j]</code>.  For each card <code>a</code> in <code>sortedA</code>, we will either have <code>a</code> beat that card <code>b</code> (put <code>a</code> into <code>assigned[b]</code>), or throw <code>a</code> out (put <code>a</code> into <code>remaining</code>).</p>
<p>Afterwards, we can use our annotations <code>assigned</code> and <code>remaining</code> to reconstruct the answer.  Please see the comments for more details.</p>
<p><a href="https://leetcode.com/playground/PGVMbL48/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N \log N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>A</code> and <code>B</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-9">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/append-characters-to-string-to-make-subsequence/description" target="_blank" rel="noopener noreferrer">Append Characters to String to Make Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code> consisting of only lowercase English letters.</p>

<p>Return <em>the minimum number of characters that need to be appended to the end of </em><code>s</code><em> so that </em><code>t</code><em> becomes a <strong>subsequence</strong> of </em><code>s</code>.</p>

<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;coaching&quot;, t = &quot;coding&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> Append the characters &quot;ding&quot; to the end of s so that s = &quot;coachingding&quot;.
Now, t is a subsequence of s (&quot;<u><strong>co</strong></u>aching<u><strong>ding</strong></u>&quot;).
It can be shown that appending any 3 characters to the end of s will never make t a subsequence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcde&quot;, t = &quot;a&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> t is already a subsequence of s (&quot;<u><strong>a</strong></u>bcde&quot;).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;z&quot;, t = &quot;abcde&quot;
<strong>Output:</strong> 5
<strong>Explanation:</strong> Append the characters &quot;abcde&quot; to the end of s so that s = &quot;zabcde&quot;.
Now, t is a subsequence of s (&quot;z<u><strong>abcde</strong></u>&quot;).
It can be shown that appending any 4 characters to the end of s will never make t a subsequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This problem asks us to find the number of letters we would need to add to the end of <code>s</code> so that <code>s</code> contains every letter in <code>t</code>, in the same order it occurs in <code>t</code>.</p>
<p>From Examples 1 and 3 in the problem, you can see it's necessary for the letters in <code>t</code> to occur in <code>s</code> in the same order as they are in <code>t</code>. This ordering is what will make <code>t</code> a subsequence of <code>s</code>. From Example 2, you can see that we won't need to add any letters to <code>s</code> if <code>t</code> is already a subsequence of it.</p>
<p><strong>Key Observations:</strong></p>
<ol>
<li>Both <code>s</code> and <code>t</code> consist of only lowercase letters.</li>
<li>The constraints of the problem indicate that we need to think of a solution with linear or log-linear time complexity, in terms of the length of given strings.</li>
</ol>
<hr />
<h3 id="approach-1-greedy-two-pointers">Approach 1: Greedy (Two Pointers)</h3>
<h4 id="intuition">Intuition</h4>
<p>We want to start by identifying all of the characters in <code>t</code> that are already a subsequence of <code>s</code>. These characters would occur as a prefix in <code>t</code>. After finding the longest such prefix of <code>t</code>, we can append the remaining characters at the end of <code>s</code>. Of course, if <code>t</code> is already a subsequence of <code>s</code>, we won't need to add any characters. This would minimize the number of characters that are appended to the string <code>s</code> for it to contain <code>t</code> as a subsequence. This idea can be explained using the image given below:</p>
<p><img src="../Figures/2486/Slide1.png" alt="img" /></p>
<p>Although the first character in <code>t</code> could appear at various positions throughout <code>s</code>, we want to pick the first time it appears in <code>s</code> as the start of the subsequence. If we determine that the first character of <code>t</code> is in <code>s</code>, we will start looking for the second character. We will pick the first occurrence of the second character of <code>t</code> after the first character. We will repeat this process till we can no longer find a character that can be picked in the string <code>s</code>.</p>
<p>We can accomplish this using a two-pointer approach to iterate through each string, counting the number of characters in <code>t</code> that appear in the same order in <code>s</code>. When we reach the end of <code>s</code>, we know that the number of uncounted characters in <code>t</code> need to be added to the end of <code>s</code>.</p>
<p>The first pointer,<code>first</code>, will iterate through <code>s</code>, one character at a time. The second pointer,<code>longestPrefix</code>, will be initially placed at the first character of the string <code>t</code>. When the first pointer reaches the end of string <code>s</code>, the <code>longestPrefix</code> will store the length of the longest prefix of <code>t</code> which is a subsequence of <code>s</code>. We can now subtract <code>longestPrefix</code> from the length of <code>t</code> to find the number of characters that need to be added to <code>s</code>.</p>
<p>We can prove the optimality of the algorithm using contradiction. Let's say that the greedy approach returns the minimum number of characters as <code>c</code>. By contradiction, assume that there exists a better solution where the number of characters that need to be appended is <code>c-1</code>.</p>
<p>This would mean that the first character appended in the greedy solution is part of a subsequence of <code>s</code> in the assumed optimal solution. However, this cannot be true since we have selected the characters of <code>t</code> in the order in which they appear in <code>s</code> (i.e., we have picked the first occurrences). Therefore, the assumption is incorrect, and the greedy approach gives the most optimal solution here.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialise two pointers <code>first</code> and <code>longestPrefix</code> with 0.</li>
<li>Iterate while <code>first</code> is less than <code>s.length</code> and <code>longestPrefix</code> is less than <code>t.length</code>:
<ul>
<li>If the <code>s[first]</code> is equal to <code>t[longestPrefix]</code>:
<ul>
<li>Increment <code>longestPrefix</code> by 1.</li>
</ul>
</li>
<li>Increment <code>first</code> by 1.</li>
</ul>
</li>
<li>Return the difference of <code>t.length</code> and <code>longestPrefix</code>.</li>
</ol>
<p>!?!../Documents/2486/slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/guYGAd95/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>s</code> and <span class="math inline">\(m\)</span> be the length of <code>t</code>.</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span></li>
</ul>
<p>  Since we iterate through the string <code>s</code> exactly once, the time complexity can be stated as <span class="math inline">\(O(n)\)</span>.</p>
<ul>
<li>Space complexity: <span class="math inline">\(O(1)\)</span></li>
</ul>
<p>  We do not allocate any additional auxiliary memory proportional to the size of the given strings. Therefore, overall space complexity is given by <span class="math inline">\(O(1)\)</span>.</p>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-10">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/apply-operations-to-an-array/description" target="_blank" rel="noopener noreferrer">Apply Operations to an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array <code>nums</code> of size <code>n</code> consisting of <strong>non-negative</strong> integers.</p>

<p>You need to apply <code>n - 1</code> operations to this array where, in the <code>i<sup>th</sup></code> operation (<strong>0-indexed</strong>), you will apply the following on the <code>i<sup>th</sup></code> element of <code>nums</code>:</p>

<ul>
	<li>If <code>nums[i] == nums[i + 1]</code>, then multiply <code>nums[i]</code> by <code>2</code> and set <code>nums[i + 1]</code> to <code>0</code>. Otherwise, you skip this operation.</li>
</ul>

<p>After performing <strong>all</strong> the operations, <strong>shift</strong> all the <code>0</code>&#39;s to the <strong>end</strong> of the array.</p>

<ul>
	<li>For example, the array <code>[1,0,2,0,0,1]</code> after shifting all its <code>0</code>&#39;s to the end, is <code>[1,2,1,0,0,0]</code>.</li>
</ul>

<p>Return <em>the resulting array</em>.</p>

<p><strong>Note</strong> that the operations are applied <strong>sequentially</strong>, not all at once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,1,1,0]
<strong>Output:</strong> [1,4,2,0,0,0]
<strong>Explanation:</strong> We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,<strong><u>4</u></strong>,<strong><u>0</u></strong>,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,<strong><u>2</u></strong>,<strong><u>0</u></strong>,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,<strong><u>0</u></strong>,<strong><u>0</u></strong>].
After that, we shift the 0&#39;s to the end, which gives the array [1,4,2,0,0,0].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [1,0]
<strong>Explanation:</strong> No operation can be applied, we just shift the 0 to the end.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an integer array <code>nums</code> consisting of <code>n</code> non-negative integers. We must iterate through the array, one step at a time, checking each pair of adjacent numbers starting from the first element:</p>
<ul>
<li>If two neighboring numbers are the same, we double the first number and turn the second one into 0.</li>
<li>If they are different, we leave them as they are.</li>
</ul>
<p>We repeat this process from left to right, one pair at a time. Finally, we must move all <code>0</code>s to the end of the array while preserving the order of non-zero elements and return the resulting array.</p>
<p>Because of the smaller constraints on the size of <code>nums</code> (<code>n ≤ 2000</code>), we can start from a brute force approach that simulates the rules mentioned in the problem and then think of further optimizing the approach.</p>
<hr />
<h3 id="approach-1-brute-force-simulation">Approach 1: Brute Force Simulation</h3>
<h4 id="intuition">Intuition</h4>
<p>A simple way to approach this problem is to iterate through the array in pairs and apply the given set of rules. Once we finish processing the entire array, we must rearrange it so that all non-zero elements appear first, preserving their order, while pushing all zeros to the end.</p>
<p>Let's break this down with an example. Consider the array <code>nums = [1, 1, 2, 2, 2]</code>.</p>
<ul>
<li>We start at index <code>0</code> and examine the pair <code>{nums[0], nums[1]}</code>. Since both values are equal (<code>1 == 1</code>), we replace <code>nums[0]</code> with <code>2 * nums[0] = 2</code> and set <code>nums[1]</code> to <code>0</code>. The array now looks like <code>[2, 0, 2, 2, 2]</code>.</li>
<li>Moving to index <code>1</code>, the pair <code>{nums[1], nums[2]}</code> is <code>{0, 2}</code>. Since the values are different, we skip this step.</li>
<li>At index <code>2</code>, the pair <code>{nums[2], nums[3]}</code> is <code>{2, 2}</code>. Both values are equal, so we double <code>nums[2]</code> to <code>4</code> and set <code>nums[3]</code> to <code>0</code>. The array updates to <code>[2, 0, 4, 0, 2]</code>.</li>
<li>Finally, at index <code>3</code>, the pair <code>{nums[3], nums[4]}</code> is <code>{0, 2}</code>. Since they are not equal, we make no changes.</li>
</ul>
<p>At this stage, the array is <code>[2, 0, 4, 0, 2]</code>. However, zeros are scattered throughout, and we need to move them to the end while maintaining the order of non-zero elements.</p>
<p>To achieve this, we move all non-zero values to the beginning of the array. We can create a new array <code>modifiedNums</code> and append all non-zero values to it. The total number of zeros in the array is given by <code>number of zeros = n - number of non-zero values</code>. We then append zeros to <code>modifiedNums</code> until its size matches <code>nums</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize <code>n</code> as the size of the <code>nums</code> array.</li>
<li>Create an array<code>modifiedNums</code> to store the processed values.</li>
<li>Apply operations on the array:
<ul>
<li>Iterate through the array from <code>index = 0</code> to <code>n - 2</code>:
<ul>
<li>If <code>nums[index]</code> is equal to <code>nums[index + 1]</code> and is non-zero:
<ul>
<li>Update <code>nums[index]</code> to <code>nums[index] * 2</code>.</li>
<li>Set <code>nums[index + 1]</code> to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Move non-zero elements to the front:
<ul>
<li>Iterate through <code>nums</code>, and for each non-zero element, push it into <code>modifiedNums</code>.</li>
</ul>
</li>
<li>Append zeros to maintain the original size:
<ul>
<li>While <code>modifiedNums</code> has fewer elements than <code>n</code>, append <code>0</code> to it.</li>
</ul>
</li>
<li>Return <code>modifiedNums</code> as the final modified array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jwvjGyyB/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given array <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array twice:</p>
<ol>
<li>The first loop processes the array, performing at most <code>n-1</code> operations.</li>
<li>The second loop collects non-zero elements, which takes <span class="math inline">\(O(n)\)</span>.</li>
<li>The third loop appends zeros to maintain the original size, which also takes <span class="math inline">\(O(n)\)</span>.</li>
</ol>
<p>Since each operation runs in <span class="math inline">\(O(n)\)</span>, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses an additional <code>modifiedNums</code> array to store the processed values. However, since this is the expected output, it is not counted in auxiliary space. Apart from this, the algorithm does not use any extra data structures that scale with <code>n</code>, making the auxiliary space complexity <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-memory-optimization">Approach 2: Memory Optimization</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we created a separate array to rearrange the elements and push all zeros to the end. However, this extra space usage can be avoided if we directly modify the given array while iterating through it. The key observation here is that all non-zero elements should appear at the beginning of the array while maintaining their original order. We achieve this by shifting non-zero elements in-place instead of using a new array.</p>
<p>To accomplish this, we introduce two indices: <code>nonZeroIndex</code> and <code>iterateIndex</code>. The <code>iterateIndex</code> moves through the array, scanning each element one by one. Whenever it encounters a non-zero value, we place it at <code>nonZeroIndex</code>, ensuring that all non-zero values are stored in their correct positions as we iterate. After processing all elements, any leftover positions in the array are filled with zeros.</p>
<p>Now, let's go through an example to understand how this works. Consider the array <code>nums = [1, 0, 2]</code>.</p>
<ul>
<li>We start with <code>nonZeroIndex = 0</code>, which keeps track of where the next non-zero value should be placed. <code>iterateIndex = 0</code> begins scanning the array.</li>
<li>At <code>iterateIndex = 0</code>, we find <code>nums[0] = 1</code>, which is non-zero. Since it is already at the correct position (<code>nonZeroIndex = 0</code>), we simply move <code>nonZeroIndex</code> to the next available position (<code>nonZeroIndex = 1</code>).</li>
<li>At <code>iterateIndex = 1</code>, <code>nums[1] = 0</code>, which we ignore, as zeros will be handled later.</li>
<li>At <code>iterateIndex = 2</code>, <code>nums[2] = 2</code>, which is non-zero. We place it at <code>nums[nonZeroIndex]</code>, which is <code>nums[1]</code>. The array updates to <code>[1, 2, 2]</code>, and we move <code>nonZeroIndex</code> forward (<code>nonZeroIndex = 2</code>).</li>
</ul>
<p>At this point, all non-zero elements are correctly positioned. Now, we overwrite the remaining elements with zeros. Since <code>nonZeroIndex = 2</code>, we set <code>nums[2] = 0</code>, resulting in the final array <code>[1, 2, 0]</code>.</p>
<p>The crucial part of this approach is that we never overwrite a necessary value during the shifting process. Any value that might be replaced was either a duplicate or a zero, ensuring that the transformation happens in-place while preserving order.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Initialize Variables:</p>
<ul>
<li><code>n</code> to store the size of the <code>nums</code> array.</li>
</ul>
</li>
<li>
<p>Apply Operations on the Array:</p>
<ul>
<li>Iterate through the array from index <code>0</code> to <code>n - 2</code>:
<ul>
<li>If <code>nums[index]</code> is equal to <code>nums[index + 1]</code> and not <code>0</code>:
<ul>
<li>Double <code>nums[index]</code> (<code>nums[index] *= 2</code>).</li>
<li>Set <code>nums[index + 1]</code> to <code>0</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Shift Non-Zero Elements to the Beginning:</p>
<ul>
<li>Initialize <code>nonZeroIndex = 0</code> to track where the next non-zero element should be placed.</li>
<li>Iterate through the array using <code>iterateIndex</code>:
<ul>
<li>If <code>nums[iterateIndex]</code> is not <code>0</code>:
<ul>
<li>Assign <code>nums[iterateIndex]</code> to <code>nums[nonZeroIndex]</code>.</li>
<li>Increment <code>nonZeroIndex</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Fill Remaining Positions with Zeros:</p>
<ul>
<li>Iterate from <code>nonZeroIndex</code> to <code>n</code>:
<ul>
<li>Set <code>nums[nonZeroIndex]</code> to <code>0</code> and increment <code>nonZeroIndex</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the modified <code>nums</code> array.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p><strong>Interview Tip: In-Place Algorithms</strong></p>
<p>In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Here are a couple of situations where an in-place algorithm might not be suitable:</p>
<ol>
<li>The algorithm needs to run in a multi-threaded environment without exclusive access to the array. Other threads might need to read the array as well and may not expect it to be modified.</li>
<li>Even if there is only a single thread or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</li>
</ol>
<p>In an interview, always check whether the interviewer is okay with you overwriting the input. Be prepared to explain the pros and cons of doing so if asked!</p>
</blockquote>
<p><a href="https://leetcode.com/playground/gkv4shGw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates through the array once to apply operations, which takes <span class="math inline">\(O(n)\)</span>. The second loop iterates through the array to shift non-zero elements, which takes <span class="math inline">\(O(n)\)</span>. The third loop fills the remaining positions with zeros, which also takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Since all operations are linear, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm modifies the input array in place without using extra space. Only a few integer variables are used, which take constant space.</p>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-one-pass">Approach 3: One Pass</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In this approach, we process the array in a single pass. The key idea is to first merge adjacent equal elements and then shift all non-zero elements to the front while maintaining their relative order.</p>
<p>We iterate through the array using <code>index</code>, checking whether consecutive elements are equal and non-zero. If they are, we double the current element and set the next element to zero.</p>
<p>As we continue iterating, we also keep track of <code>writeIndex</code>, which represents the position where the next non-zero element should be placed. Whenever we encounter a non-zero element, we swap it with the element at <code>writeIndex</code>, effectively shifting all non-zero values forward while preserving order. This ensures that zeros naturally accumulate at the end of the array without requiring an explicit second pass to move them.</p>
<p>For example, given <code>nums = [2, 2, 0, 4, 4]</code>, we start processing from the first element. The first two elements are equal (<code>2</code> and <code>2</code>), so we double the first (<code>nums[0] = 4</code>) and set the second to zero (<code>nums[1] = 0</code>). As we continue iterating, we encounter a zero, which is skipped, and then a <code>4</code>, which is moved forward. The same process happens with the second pair of <code>4</code>s, resulting in the final modified array <code>[4, 8, 0, 0, 0]</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Get the length of <code>nums</code> as <code>n</code>.</p>
</li>
<li>
<p>Initialize <code>writeIndex</code> to track the position for non-zero elements.</p>
</li>
<li>
<p>Iterate through <code>nums</code>:</p>
<ul>
<li>If <code>index</code> is within bounds and <code>nums[index]</code> is equal to <code>nums[index + 1]</code> (both non-zero), merge:
<ul>
<li>Double <code>nums[index]</code>.</li>
<li>Set <code>nums[index + 1]</code> to zero.</li>
</ul>
</li>
<li>If <code>nums[index]</code> is non-zero, move it to <code>writeIndex</code>:
<ul>
<li>Swap <code>nums[index]</code> and <code>nums[writeIndex]</code> if needed.</li>
<li>Increment <code>writeIndex</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the modified <code>nums</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<blockquote>
<p><strong>Interview Tip: In-Place Algorithms</strong></p>
<p>In-place algorithms overwrite the input to save space, but sometimes this can cause problems. Here are a couple of situations where an in-place algorithm might not be suitable:</p>
<ol>
<li>The algorithm needs to run in a multi-threaded environment without exclusive access to the array. Other threads might need to read the array as well and may not expect it to be modified.</li>
<li>Even if there is only a single thread or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</li>
</ol>
<p>In an interview, always check whether the interviewer is okay with you overwriting the input. Be prepared to explain the pros and cons of doing so if asked!</p>
</blockquote>
<p><a href="https://leetcode.com/playground/STvY8w9w/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through the array only once, performing constant-time operations for each element. The merging operation modifies elements in-place, and the shifting of non-zero values is handled dynamically as we iterate, ensuring that no additional passes are required. Since every operation is handled in a single pass, the overall complexity remains linear.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm modifies the input array in place without using extra space. Only a few integer variables are used, which take constant space. Therefore, the overall space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-11">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/assign-cookies/description" target="_blank" rel="noopener noreferrer">Assign Cookies</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>

<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> g = [1,2,3], s = [1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> g = [1,2], s = [1,2,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= g.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= g[i], s[j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/maximum-matching-of-players-with-trainers/description/" target="_blank"> 2410: Maximum Matching of Players With Trainers.</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our objective is to determine the maximum number of content children given cookie sizes and greed factors.</p>
<p>Each index <code>i</code> in <code>g</code> represents a child whose minimum cookie size is <code>g[i]</code>.<br />
Each index <code>j</code> in <code>s</code> represents a cookie with the size <code>s[j]</code>.</p>
<p>A child will be content if their cookie's size <code>s[j]</code> meets or exceeds their greed <code>g[i]</code>, represented as cookie size <code>s[j] &gt;= g[i]</code></p>
<p>Each child should receive at most one cookie. We must note that we could have many small cookies, but that will not satisfy a greedy child, because they want 1 large cookie. If there are lots of small cookies but no children with small greed, we can't use those cookies.</p>
<h3 id="approach-greedy-two-pointer">Approach: Greedy, Two-Pointer</h3>
<h4 id="intuition">Intuition</h4>
<p>Given the test case 2 <code>g = [1, 2]</code> and <code>s = [1, 2, 3]</code>, we could attempt a naive approach, iterating through both arrays and assigning cookies to the children in order.</p>
<p>Would this approach work for all cases? With the test case <code>g = [2, 1]</code> and <code>s = [1, 2]</code> we realize we cannot assign cookies in order because the first cookie isn't large enough for the first child, and if we allocate the second cookie to the second child, we satisfy only one child when we could satisfy two.</p>
<p>We need to be able to ensure that each child receives the smallest cookie that meets their greed so that larger cookies can be saved for children with more greed. We also want to make sure there are no leftover cookies that could have satisfied children.</p>
<p>The optimal solution will satisfy these conditions:</p>
<ul>
<li>Every child that receives a cookie receives the smallest cookie that meets their greed so no larger cookies are wasted on children with smaller greed</li>
<li>After cookies are assigned, no cookies are remaining that could satisfy the available children's greed</li>
</ul>
<p>How do we ensure that we don't waste larger cookies on children with smaller greed? We notice that in the first example, both arrays are sorted in ascending order. We need to sort the cookies and children in ascending order so that we can guarantee that for each child, we always try the currently smallest available cookie.</p>
<p>To solve the problem, we will start by sorting both arrays. That way we can ensure the children with the smallest greed and the smallest cookies are at the beginning, and the children with the largest greed and the largest cookies are at the end.</p>
<p>Next, we will use a while loop to iterate through our array of cookies, attempting to assign cookies to children.  We will continue while we have more cookies and children. We will create a variable <code>cookieIndex</code> that keeps track of which cookies we have assigned or passed. We will store the number of satisfied children in <code>contentChildren</code>. If the next cookie meets the current child's greed, we increment <code>contentChildren</code> and <code>cookieIndex</code> as that cookie is assigned to a child. If the next cookie doesn't meet the current child's greed, we iterate <code>cookieIndex</code> to move on to the next cookie, until we find a cookie large enough for the child or we run out of cookies. Finally, we return <code>contentChildren</code>.</p>
<p>How can we be sure this provides the optimal solution?</p>
<p>With this approach, each child is offered the smallest available cookie first. Since the cookies are offered in order of ascending size, this ensures every child receives the smallest cookie that meets their greed. While assigning cookies to children, the children are sorted in increasing order of greed, which means that when we offer a cookie that doesn't meet the current child's greed, we also know there are no children less greedy than the current child. This means that any leftover cookies will not satisfy any available children. The approach provides an optimal solution.</p>
<p>This is a greedy approach because the current child always receives the cookie, even if the cookie could have satisfied the next child. This is the locally optimal choice.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Sort arrays <code>g</code> and <code>s</code> in ascending order.</li>
<li>Initialize variable <code> contentChildren = 0</code> to represent the number of children who receive cookies that meet their greed.</li>
<li>Initialize variable <code>cookieIndex = 0</code> to represent the number of cookies that have been assigned or skipped.</li>
<li>while <code>cookieIndex</code> is less than the size of <code>s</code> and <code>contentChildren</code> is less than the size of <code>g</code>:
<ul>
<li>If the current cookie's size is greater than or equal to the current child's greed:
<ul>
<li>Increment <code>contentChildren</code> to allocate the cookie.</li>
</ul>
</li>
<li>Increment <code>cookieIndex</code> to move on to the next cookie.</li>
</ul>
</li>
<li>Return <code>contentChildren</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/aAJwA8BN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O (n \cdot \log n + m \cdot \log m)\)</span> where <span class="math inline">\(n\)</span> is the size of the array <code>g</code> and <span class="math inline">\(m\)</span> is the size of the array <code>s</code>.</p>
<p>Sorting an array of length <span class="math inline">\(k\)</span> takes <span class="math inline">\(O (k \cdot\log k)\)</span>, we need to sort two given arrays. The while loop iterates over each cookie and child once, taking <span class="math inline">\(O(m + n)\)</span>. To sum up, the overall time complexity is <span class="math inline">\(O (n \cdot \log n + m \cdot \log m)\)</span></p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(m + n)\)</span> or <span class="math inline">\(O(\log m + \log n)\)</span></p>
<ul>
<li>Some extra space is used when we sort <span class="math inline">\(s\)</span> and <span class="math inline">\(g\)</span> in place. The space complexity of the sorting algorithm depends on the programming language.
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Timesort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n + m)\)</span> additional space.</li>
<li>In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O(\log n + \log m)\)</span>.</li>
<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log n + \log m)\)</span> for sorting two arrays.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-12">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/backspace-string-compare/description" target="_blank" rel="noopener noreferrer">Backspace String Compare</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">simulation</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if they are equal when both are typed into empty text editors</em>. <code>&#39;#&#39;</code> means a backspace character.</p>

<p>Note that after backspacing an empty text, the text will continue empty.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab#c&quot;, t = &quot;ad#c&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both s and t become &quot;ac&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ab##&quot;, t = &quot;c#d#&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Both s and t become &quot;&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a#c&quot;, t = &quot;b&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> s becomes &quot;c&quot; while t becomes &quot;b&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code><span>1 &lt;= s.length, t.length &lt;= 200</span></code></li>
	<li><span><code>s</code> and <code>t</code> only contain lowercase letters and <code>&#39;#&#39;</code> characters.</span></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time and <code>O(1)</code> space?</p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-build-string-accepted">Approach #1: Build String [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Let's individually build the result of each string (<code>build(S)</code> and <code>build(T)</code>), then compare if they are equal.</p>
<p><strong>Algorithm</strong></p>
<p>To build the result of a string <code>build(S)</code>, we'll use a stack based approach, simulating the result of each keystroke.</p>
<p><a href="https://leetcode.com/playground/g7aBaNuB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(M + N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>S</code> and <code>T</code> respectively.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(M + N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer-accepted">Approach #2: Two Pointer [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>When writing a character, it may or may not be part of the final string depending on how many backspace keystrokes occur in the future.</p>
<p>If instead we iterate through the string in reverse, then we will know how many backspace characters we have seen, and therefore whether the result includes our character.</p>
<p><strong>Algorithm</strong></p>
<p>Iterate through the string in reverse.  If we see a backspace character, the next non-backspace character is skipped.  If a character isn't skipped, it is part of the final answer.</p>
<p>See the comments in the code for more details.</p>
<p><a href="https://leetcode.com/playground/DGF5YvNa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(M + N)\)</span>, where <span class="math inline">\(M, N\)</span> are the lengths of <code>S</code> and <code>T</code> respectively.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-13">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/bag-of-tokens/description" target="_blank" rel="noopener noreferrer">Bag of Tokens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You start with an initial <strong>power</strong> of <code>power</code>, an initial <strong>score</strong> of <code>0</code>, and a bag of tokens given as an integer array <code>tokens</code>, where each&nbsp;<code>tokens[i]</code> denotes the value of token<em><sub>i</sub></em>.</p>

<p>Your goal is to <strong>maximize</strong> the total <strong>score</strong> by strategically playing these tokens. In one move, you can play an <strong>unplayed</strong> token in one of the two ways (but not both for the same token):</p>

<ul>
	<li><strong>Face-up</strong>: If your current power is <strong>at least</strong> <code>tokens[i]</code>, you may play token<em><sub>i</sub></em>, losing <code>tokens[i]</code> power and gaining <code>1</code> score.</li>
	<li><strong>Face-down</strong>: If your current score is <strong>at least</strong> <code>1</code>, you may play token<em><sub>i</sub></em>, gaining <code>tokens[i]</code> power and losing <code>1</code> score.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> possible score you can achieve after playing <strong>any</strong> number of tokens</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tokens = [100], power = 50</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">0</span></p>

<p><strong>Explanation</strong><strong>:</strong> Since your score is <code>0</code> initially, you cannot play the token face-down. You also cannot play it face-up since your power (<code>50</code>) is less than <code>tokens[0]</code>&nbsp;(<code>100</code>).</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tokens = [200,100], power = 150</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">1</span></p>

<p><strong>Explanation:</strong> Play token<em><sub>1</sub></em> (<code>100</code>) face-up, reducing your power to&nbsp;<code>50</code> and increasing your score to&nbsp;<code>1</code>.</p>

<p>There is no need to play token<em><sub>0</sub></em>, since you cannot play it face-up to add to your score. The maximum score achievable is <code>1</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block" style="
    border-color: var(--border-tertiary);
    border-left-width: 2px;
    color: var(--text-secondary);
    font-size: .875rem;
    margin-bottom: 1rem;
    margin-top: 1rem;
    overflow: visible;
    padding-left: 1rem;
">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">tokens = [100,200,300,400], power = 200</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">2</span></p>

<p><strong>Explanation:</strong> Play the tokens in this order to get a score of <code>2</code>:</p>

<ol>
	<li>Play token<em><sub>0</sub></em> (<code>100</code>) face-up, reducing power to <code>100</code> and increasing score to <code>1</code>.</li>
	<li>Play token<em><sub>3</sub></em> (<code>400</code>) face-down, increasing power to <code>500</code> and reducing score to <code>0</code>.</li>
	<li>Play token<em><sub>1</sub></em> (<code>200</code>) face-up, reducing power to <code>300</code> and increasing score to <code>1</code>.</li>
	<li>Play token<em><sub>2</sub></em> (<code>300</code>) face-up, reducing power to <code>0</code> and increasing score to <code>2</code>.</li>
</ol>

<p><span style="color: var(--text-secondary); font-size: 0.875rem;">The maximum score achievable is </span><code style="color: var(--text-secondary); font-size: 0.875rem;">2</code><span style="color: var(--text-secondary); font-size: 0.875rem;">.</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= tokens.length &lt;= 1000</code></li>
	<li><code>0 &lt;= tokens[i], power &lt; 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Our goal is to return the highest score possible. We gain score by placing tokens face-up, which costs power. We gain power by playing tokens face-down, which costs score. We can only play a token face-up when we have enough power, and we can only play a token face-down when we have enough score. Note that the value of each token is positive, and the initial power is also positive.</p>
<p>A crucial insight is that we can play a token face-up to trade any amount <code>tokens[i]</code> for <code>1</code> score as long as we have at least that much power. Alternatively, we can play a token face-down to trade <code>1</code> score for any amount <code>tokens[i]</code> of power.</p>
<hr />
<h3 id="approach-sort-and-greedy">Approach: Sort and Greedy</h3>
<h4 id="intuition">Intuition</h4>
<p><strong>How do we determine which tokens to play face-up and which to play face-down?</strong></p>
<p>Let's look at some examples:</p>
<p>Example A: (Example 3 from the problem description)</p>
<blockquote>
<p><strong>Input:</strong> tokens = [100, 200, 300, 400], power = 200<br />
<strong>Output:</strong> 2</p>
</blockquote>
<p>Tokens played face-up: <span class="math inline">\(\text{token}_0\)</span> (100), <span class="math inline">\(\text{token}_1\)</span> (200), <span class="math inline">\(\text{token}_2\)</span> (300).<br />
Tokens played face-down: <span class="math inline">\(\text{token}3\)</span> (400).</p>
<p>Example B:</p>
<blockquote>
<p><strong>Input:</strong> tokens = [1, 4, 1, 1], power = 1<br />
<strong>Output:</strong> 2</p>
</blockquote>
<p>Tokens played face-up: <span class="math inline">\(\text{token}_0\)</span> (1), <span class="math inline">\(\text{token}_2\)</span> (1), <span class="math inline">\(\text{token}_3\)</span> (1).<br />
Tokens played face-down: <span class="math inline">\(\text{token}_1\)</span> (4).</p>
<p><strong>What patterns do we notice in how the tokens are played to maximize the score in the above examples?</strong></p>
<ul>
<li>
<p>The lowest power tokens are played face-up to increase the score.</p>
</li>
<li>
<p>The highest power tokens are played face-down to increase power.</p>
</li>
</ul>
<p><strong>We can develop a strategy based on these observations:</strong></p>
<ul>
<li>
<p>When you have enough power to play face-up, maximize the score by playing the lowest power tokens face-up. This way you are increasing the score without losing a significant amount of power.</p>
</li>
<li>
<p>When you do not have enough power to play face-up, maximize power by playing the highest power tokens face-down. This way you trade a relatively small amount of score for a relatively large amount of power.</p>
</li>
<li>
<p>We should play the lowest tokens face-up until we do not have enough power, then play token(s) face-down until we can play face-up again.</p>
</li>
<li>
<p>We continue while we can either play a token face-up or face-down.</p>
</li>
</ul>
<p><strong>How can we identify the lowest and highest power tokens?</strong></p>
<p>We will need to do the above process repeatedly, so we will sort the array from lowest power to highest power.</p>
<p>We can then use two pointers, <code>low</code> and <code>high</code>. <code>low</code> will point to the lowest power token in <code>tokens</code> that hasn't been used, and <code>high</code> will point to the highest power token in <code>tokens</code> that hasn't been used. We can process the tokens in the array, one at a time.</p>
<p>If we have enough power to play the lowest power token face-up, we play it, increase the score and the <code>low</code> pointer, and decrease power accordingly.</p>
<p>When we don't have enough power to play the lowest power token face-up, but we have at least <code>1</code> score, we play the highest power token face-down. The exception is if this is our last token remaining. Since we lose a score point every time we play a token face-up, it would not maximize our score to play a token face-down unless there is one to play after it. We increase power accordingly and decrease the score and the <code>high</code> pointer.</p>
<p>If we can't play face-up or down, we return the score.</p>
<p>This playing strategy is visualized below:</p>
<p>!?!../Documents/948/948_bag_of_tokens_slideshow.json: 960,540!?!</p>
<p><strong>How do we know this method will lead to the highest score?</strong></p>
<p>Assume the greedy strategy of playing the lowest power tokens face-up, and the highest power token face-down when we can't afford to play any tokens face-up is not optimal. Then, it would be possible to obtain a higher score with a different playing strategy.</p>
<p>Let's discuss Example A with a different playing strategy: Play the highest token we can afford face-up, and the lowest token face-down.<br />
Input: tokens = [100, 200, 300, 400], power = 200<br />
Move 1: Play <span class="math inline">\(\text{token}_1\)</span> (200) face-up, reducing power to 0 and increasing score to 1.<br />
Move 2: Play <span class="math inline">\(\text{token}_0\)</span> (100) face-down, increasing power to 100 and reducing score to 0.<br />
Output: 0</p>
<p>After these two moves, have neither enough score nor enough power to play either of the remaining tokens, <span class="math inline">\(\text{token}_2\)</span> (300), and <span class="math inline">\(\text{token}_3\)</span> (400), face-up or face-down. The greedy approach of playing the highest power tokens face-down and the lowest power tokens face-up is more effective because for each token played, the amount of score gained or lost is always <code>1</code>, but we minimize the power spent to gain score and the score spent to gain power. Therefore, the way to obtain the highest score is to play the lowest power tokens face-up.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initializations:
<ul>
<li>Initialize a pointer <code>low</code> to <code>0</code> and <code>high</code> to <code>tokens.length - 1</code>. <code>low</code> points to the first index of <code>tokens</code> and <code>high</code> points the the last index of <code>tokens</code>.</li>
<li>Initialize a variable <code>score</code> to <code>0</code>.</li>
</ul>
</li>
<li>Sort <code>tokens</code> in ascending order.</li>
<li>While <code>low</code> is less than or equal to <code>high</code>:
<ul>
<li>If <code>power</code> is greater than or equal to <code>tokens[low]</code>, we have enough power to play a token face-up. We increment <code>score</code> by <code>1</code>, reduce <code>power</code> by <code>tokens[low]</code>, and increase <code>low</code> by <code>1</code>.</li>
<li>Else if <code>score</code> is greater than <code>0</code>, and <code>low</code> is less than <code>high</code>, we play a token face-down. We decrease <code>score</code> by <code>1</code>, increase our power by <code>tokens[high]</code>, and decrease <code>high</code> by <code>1</code>.</li>
<li>Otherwise, we don't have enough power to play a token face-up, and we either don't have enough score to play a token face-down or not enough tokens remain to make it worth playing a token face-down, so we return <code>score</code>.</li>
</ul>
</li>
<li>We have played all the tokens, so we return <code>score</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><strong>Implementation 1: Two Pointer</strong></p>
<p><a href="https://leetcode.com/playground/YfsXFNi3/shared">code</a></p>
<p><strong>Implementation 2: Deque</strong></p>
<p>Like in the previous implementation, we will sort the array to facilitate the identification of the lowest and highest power tokens.</p>
<p>Instead of using two pointers, we store the values of <code>tokens</code> in a deque, a double-ended queue where values can be accessed from both ends. We can pop the rear (leftmost) token to access the lowest power token and pop the front (rightmost) token to access the highest power token.</p>
<p>The rest of the gameplay proceeds similarly to the above approach. When we play the lowest remaining token, we pop the leftmost value from the deque, and when we play the highest remaining token, we pop the rightmost token.</p>
<p><a href="https://leetcode.com/playground/Q4U5dSFX/shared">code</a></p>
<p>The time complexity of the deque implementation is the same as the two-pointer implementation. The deque, <code>deque</code> contains all of the elements of <code>tokens</code> so it uses <span class="math inline">\(n\)</span> space. The space complexity of this implementation is <span class="math inline">\(O(n)\)</span>.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>tokens</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Sorting <code>tokens</code> takes <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>We process <code>tokens</code> using the pointers <code>low</code> and <code>high</code> until they meet in the middle or we can't play any more tokens. With each iteration, <code>low</code> is incremented, or <code>high</code> is decremented, or the loop terminates because we can't make any more moves that increase our score. We handle each token in <code>tokens</code> at most once, so the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p><span class="math inline">\(O(n \log n)\)</span> is the dominating term.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O( \log n )\)</span></p>
<p>Sorting uses extra space, which depends on the implementation of each programming language.<br />
- In Python, the <code>sort</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.<br />
- In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.<br />
- In C++, the sort() function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</p>
<p>Other than sorting, we use a handful of variables that use constant, <span class="math inline">\(O(1)\)</span> space, so the space used for sorting is the dominant term.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-14">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/binary-array-sorting-1587115620/1" target="_blank" rel="noopener noreferrer">Binary Array Sorting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given a binary array <strong>arr[]</strong>, where each element is either <strong>0 </strong>or <strong>1</strong>. Your task is to rearrange the array in increasing order in place (without using extra space). You do not need to return anything; simply modify the input array.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 0, 1, 1, 0]
<strong>Output</strong>: [0, 0, 1, 1, 1]
<strong>Explanation</strong>: After arranging the elements in increasing order, elements will be as 0 0 1 1 1.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 0, 1, 1, 1, 1, 1, 0, 0, 0]
<strong>Output</strong>: [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
<strong>Explanation</strong>: After arranging the elements in increasing order, elements will be 0 0 0 0 1 1 1 1 1 1.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 1, 1, 1]
<strong>Output</strong>: [1, 1, 1, 1]
<strong>Explanation</strong>: Since the array already contains only <code>1</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">s, no change is needed.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>6</sup><br /><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><strong><span class="mord mathnormal">a</span><span class="mord mathnormal">rr</span><span class="mopen">[</span><span class="mord mathnormal">i</span></strong><span class="mclose"><strong>]</strong> </span><span class="mrel">&isin; </span></span><span class="base"><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mord">1</span><span class="mclose">}</span></span></span></span> for all valid indices <strong>i</strong>.</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-15">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/boats-to-save-people/description" target="_blank" rel="noopener noreferrer">Boats to Save People</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array <code>people</code> where <code>people[i]</code> is the weight of the <code>i<sup>th</sup></code> person, and an <strong>infinite number of boats</strong> where each boat can carry a maximum weight of <code>limit</code>. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p>

<p>Return <em>the minimum number of boats to carry every given person</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> people = [1,2], limit = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 boat (1, 2)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> people = [3,2,2,1], limit = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 boats (1, 2), (2) and (3)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> people = [3,5,3,4], limit = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> 4 boats (3), (3), (4), (5)
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-16">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/camelcase-matching/description" target="_blank" rel="noopener noreferrer">Camelcase Matching</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">trie</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>queries</code> and a string <code>pattern</code>, return a boolean array <code>answer</code> where <code>answer[i]</code> is <code>true</code> if <code>queries[i]</code> matches <code>pattern</code>, and <code>false</code> otherwise.</p>

<p>A query word <code>queries[i]</code> matches <code>pattern</code> if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters <strong>at all</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;
<strong>Output:</strong> [true,false,true,true,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.
&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.
&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;
<strong>Output:</strong> [true,false,true,false,false]
<strong>Explanation:</strong> &quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.
&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;
<strong>Output:</strong> [false,true,false,false,false]
<strong>Explanation:</strong> &quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= pattern.length, queries.length &lt;= 100</code></li>
	<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
	<li><code>queries[i]</code> and <code>pattern</code> consist of English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-17">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/given-two-strings-find-if-first-string-is-a-subsequence-of-second/1" target="_blank" rel="noopener noreferrer">Check if a String is Subsequence of Other</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two strings <strong>s1</strong> and <strong>s2</strong>. You have to check that <strong>s1</strong> is a subsequence of <strong>s2 </strong> or not. <br /><strong>Note:</strong> A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s1 = "AXY", s2 = "YADXCP"
<strong>Output: </strong>false
<strong>Explanation:</strong> s1 is not a subsequence of s2 as 'Y' appears before 'A'.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>s1 = "gksrek", s2 = "geeksforgeeks"
<strong>Output:</strong> true
<strong>Explanation: </strong>If we combine the bold character of "<strong>g</strong>ee<strong>ks</strong>fo<strong>r</strong>g<strong>e</strong>e<strong>k</strong>s", it equals to s1. So s1</span> <span style="font-size: 14pt;">is a subsequence of s2. </span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; s1.size(), s2.size() &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-18">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/description" target="_blank" rel="noopener noreferrer">Check If a Word Occurs As a Prefix of Any Word in a Sentence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <code>sentence</code> that consists of some words separated by a <strong>single space</strong>, and a <code>searchWord</code>, check if <code>searchWord</code> is a prefix of any word in <code>sentence</code>.</p>

<p>Return <em>the index of the word in </em><code>sentence</code><em> (<strong>1-indexed</strong>) where </em><code>searchWord</code><em> is a prefix of this word</em>. If <code>searchWord</code> is a prefix of more than one word, return the index of the first word <strong>(minimum index)</strong>. If there is no such word return <code>-1</code>.</p>

<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> &quot;burg&quot; is prefix of &quot;burger&quot; which is the 4th word in the sentence.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> &quot;pro&quot; is prefix of &quot;problem&quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it&#39;s the minimal index.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> &quot;you&quot; is not a prefix of any word in the sentence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sentence.length &lt;= 100</code></li>
	<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>
	<li><code>sentence</code> consists of lowercase English letters and spaces.</li>
	<li><code>searchWord</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to determine if a given search word is a prefix of any word in a sentence. If it is, we return the 1-based index of the first matching word. If no match is found, we return -1.</p>
<p>Let’s first define what a prefix is: it’s the starting portion of a word. For example, in the word <code>&quot;burger&quot;</code>, the string <code>&quot;burg&quot;</code> is a prefix. Given a sentence like <code>&quot;I love eating burger&quot;</code> and a search word <code>&quot;burg&quot;</code>, we need to identify whether any word in the sentence begins with <code>&quot;burg&quot;</code>. In this example, the word <code>&quot;burger&quot;</code> starts with <code>&quot;burg&quot;</code>, and it is the fourth word in the sentence, so the correct output would be <code>4</code>.</p>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The simplest way to check if <code>searchWord</code> is a prefix of any word in the sentence is by directly comparing each word with <code>searchWord</code>.</p>
<p>We can start by splitting the sentence into individual words. Since words in the sentence are separated by single spaces, we can use space as the delimiter to split the sentence into a list of words. While we might generally need to handle extra spaces or leading/trailing spaces carefully, the problem guarantees that words are separated by single spaces, so these edge cases are not a concern here.</p>
<p>Next, we iterate through the list of words, comparing each word's prefix with <code>searchWord</code>. We use a nested loop to compare characters of the word and <code>searchWord</code> up to the length of <code>searchWord</code>. If all characters match, we return the 1-based index of the word. If no word matches, we return <code>-1</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty <code>wordsList</code> to store the words in the sentence.</p>
</li>
<li>
<p>Initialize an empty <code>currentWord</code> to build words as we traverse the sentence.</p>
</li>
<li>
<p>For each <code>character</code> in <code>sentence</code>:</p>
<ul>
<li>If the <code>character</code> is not a space, append it to <code>currentWord</code>.</li>
<li>If the <code>character</code> is a space and <code>currentWord</code> is not empty:
<ul>
<li>Add <code>currentWord</code> to <code>wordsList</code>.</li>
<li>Reset <code>currentWord</code> to an empty string.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing the sentence, if <code>currentWord</code> is not empty, add it to <code>wordsList</code> (handles the last word).</p>
</li>
<li>
<p>For each word in <code>wordsList</code> (indexed by <code>wordIndex</code>):</p>
<ul>
<li>If the length of the current word is greater than or equal to the length of <code>searchWord</code>:
<ul>
<li>Compare each character in <code>searchWord</code> with the corresponding character in the current word.</li>
<li>If all characters match:
<ul>
<li>Return <code>wordIndex + 1</code> (1-based index of the matching word).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no word matches <code>searchWord</code> as a prefix, return <code>-1</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/EHZG3vUK/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The first part of the algorithm involves iterating over the <code>sentence</code> to split it into words, which requires traversing all <span class="math inline">\(n\)</span> characters. Each character is processed exactly once to either build a word or identify word boundaries (spaces). This step has a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The second part involves checking whether each word in the <code>wordsList</code> starts with the <code>searchWord</code>. For each of the <span class="math inline">\(w\)</span> words, we compare up to <span class="math inline">\(m\)</span> characters with <code>searchWord</code>. In the worst case, all <span class="math inline">\(w\)</span> words are of length <span class="math inline">\(m\)</span> or more, making this step <span class="math inline">\(O(w \cdot m)\)</span>. Adding both parts together, the total time complexity becomes <span class="math inline">\(O(n + w \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The <code>wordsList</code> vector stores all the words from <code>sentence</code>, and the total memory required to hold these words is proportional to the size of the input string <span class="math inline">\(n\)</span>. Additionally, the <code>currentWord</code> string temporarily holds one word at a time during the processing, requiring <span class="math inline">\(O(k)\)</span> space, but this is reused and does not add extra memory. Other variables, such as the loop counters and boolean flags, require constant space <span class="math inline">\(O(1)\)</span>. Hence, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of splitting the sentence into words first, we can directly iterate through the sentence while keeping track of the current word's position. This way, we can avoid storing all words in memory and instead process the sentence in a single pass. We skip over spaces to find the start of each word and then check if the word starts with the <code>searchWord</code>.</p>
<p>To do this, we use a two-pointer approach: the first pointer keeps track of where we are in the sentence, and the second pointer tracks how far we’ve matched the <code>searchWord</code>. If a match is found, we immediately return the current word's position. If no match is found by the end of the sentence, we return <code>-1</code>.</p>
<p>This is particularly efficient for large sentences, as it avoids the overhead of storing and managing a list of words.</p>
</br>
<p>!?!../Documents/1455/1455_two_pointer.json:770,445!?!</p>
<blockquote>
<p>For a more comprehensive understanding of the two-pointer technique, explore the <a href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">Two Pointer Explore Card 🔗</a>. This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>currentWordPosition</code> to 1 to keep track of the current word's position in the sentence.</p>
</li>
<li>
<p>Initialize <code>currentIndex</code> to 0 to traverse the sentence character by character.</p>
</li>
<li>
<p>Store the length of the sentence in <code>sentenceLength</code>.</p>
</li>
<li>
<p>While <code>currentIndex</code> is less than <code>sentenceLength</code>:</p>
<ul>
<li>
<p>Skip leading spaces:</p>
<ul>
<li>While the current character is a space, increment <code>currentIndex</code> and also increment <code>currentWordPosition</code> to move to the next word.</li>
</ul>
</li>
<li>
<p>Check if the current word starts with <code>searchWord</code>:</p>
<ul>
<li>Initialize <code>matchCount</code> to 0 to track how many characters match <code>searchWord</code>.</li>
<li>While characters match between <code>sentence</code> and <code>searchWord</code>:
<ul>
<li>Increment <code>currentIndex</code> and <code>matchCount</code>.</li>
</ul>
</li>
<li>If <code>matchCount</code> equals the length of <code>searchWord</code>, return <code>currentWordPosition</code> since a match is found.</li>
</ul>
</li>
<li>
<p>Skip the rest of the current word:</p>
<ul>
<li>While the current character is not a space, increment <code>currentIndex</code> to move to the end of the word.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no word in the sentence matches <code>searchWord</code> as a prefix, return <code>-1</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PEcbcEFY/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, and <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The algorithm processes the input string <code>sentence</code> in a single pass. During this traversal, it skips spaces to identify the start of each word, checks for a prefix match between <code>searchWord</code> and the current word, and moves to the end of the word if there is no match. This traversal covers all <span class="math inline">\(n\)</span> characters in <code>sentence</code>.</p>
<p>Additionally, for each word in <code>sentence</code>, the algorithm compares up to <span class="math inline">\(m\)</span> characters with <code>searchWord</code> to check for a prefix match. In the worst case, this adds an <span class="math inline">\(O(m)\)</span> cost for the comparison. Since each word is processed exactly once, the prefix-checking step is effectively absorbed into the overall traversal of <span class="math inline">\(n\)</span>, making the total time complexity <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space. Variables like <code>currentWordPosition</code>, <code>currentIndex</code>, and <code>matchCount</code> are simple integers, and there are no auxiliary data structures (e.g., arrays) used to store intermediate results. Thus, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-built-in-function">Approach 3: Using Built-In Function</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Now that we have explored the approaches where we handle strings manually, let's leverage built-in string libraries for more efficient and cleaner solutions. This will simplify our code and make it easier to understand and maintain.</p>
<h5 id="for-c-users">For C++ Users</h5>
<p>In C++, the <code>istringstream</code> class from the <code>&lt;sstream&gt;</code> library processes strings efficiently. It treats a string as a stream and extracts words using the <code>&gt;&gt;</code> operator. This avoids manual string splitting and space handling. The complexity of extracting words is <span class="math inline">\(O(n)\)</span>, where <code>n</code> is the string length. To check if a word starts with a prefix, the <code>compare</code> function is used, which operates in <span class="math inline">\(O(k)\)</span>, where <code>k</code> is the prefix length.</p>
<h5 id="for-java-users">For Java Users</h5>
<p>In Java, the <code>split</code> method from the <code>String</code> class divides a sentence into words in <span class="math inline">\(O(n)\)</span> time. The <code>startsWith</code> method, operating in <span class="math inline">\(O(k)\)</span>, then checks if each word begins with the given prefix. This combination of <code>split</code> and <code>startsWith</code> ensures clean, efficient code without manual handling of spaces.</p>
<h5 id="for-python3-users">For Python3 Users</h5>
<p>In Python3, the <code>split</code> method separates a sentence into words by whitespace in <span class="math inline">\(O(n)\)</span> time, while the <code>startswith</code> method checks prefixes in <span class="math inline">\(O(k)\)</span>. Then proceed with the implementation.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize a string stream <code>sentenceStream</code> from the input <code>sentence</code> to tokenize the sentence.</p>
</li>
<li>
<p>Initialize <code>currentWord</code> to store each word from the sentence as we process it.</p>
</li>
<li>
<p>Initialize <code>wordPosition</code> to 1 to keep track of the position of the current word in the sentence.</p>
</li>
<li>
<p>While there are words left in the sentence (i.e., <code>sentenceStream &gt;&gt; currentWord</code>):</p>
<ul>
<li>Check if the current word's length is greater than or equal to <code>searchWord</code>'s length and if the current word starts with <code>searchWord</code>:
<ul>
<li>If true, return the current <code>wordPosition</code> (this is the first word that starts with <code>searchWord</code>).</li>
</ul>
</li>
<li>Otherwise, increment <code>wordPosition</code> to check the next word.</li>
</ul>
</li>
<li>
<p>If no word matches, return <code>-1</code> to indicate that no word in the sentence starts with <code>searchWord</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/LWE8FPtk/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + w \cdot m)\)</span></p>
<p>The algorithm first splits the <code>sentence</code> into individual words using built-in functions. This process involves iterating through all <span class="math inline">\(n\)</span> characters of the string once, resulting in a time complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>Next, for each word extracted from the sentence, the algorithm compares the first <span class="math inline">\(m\)</span> characters of the word with the <code>searchWord</code>. This comparison is done using a built-in function that checks the prefix of length <span class="math inline">\(m\)</span>, which takes <span class="math inline">\(O(m)\)</span> time per word. Since there are <span class="math inline">\(w\)</span> words in the <code>sentence</code>, this part of the algorithm takes <span class="math inline">\(O(w \cdot m)\)</span> time.</p>
<p>Combining both parts, the total time complexity of the algorithm is <span class="math inline">\(O(n + w \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses built-in functions that process the input <code>sentence</code> directly, requiring <span class="math inline">\(O(n)\)</span> space to store the <code>sentence</code> string. The <code>currentWord</code> variable temporarily holds one word at a time, requiring <span class="math inline">\(O(k)\)</span> space, but this space is reused across iterations. Additionally, the algorithm uses constant space <span class="math inline">\(O(1)\)</span> for variables like <code>wordPosition</code>. Therefore, the overall space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-trie">Approach 4: Using Trie</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of processing the entire sentence multiple times, we can use a data structure called a <code>Trie</code> (prefix tree). A <code>Trie</code> organizes words so that characters in common prefixes are shared, forming a tree-like structure. This makes it much faster and more efficient to search for prefixes, as both building the <code>Trie</code> and searching for a prefix can be done in linear time relative to the length of the <code>searchWord</code>.</p>
<p>To implement this, we start by creating an empty <code>Trie</code>, which is made up of nodes where each node represents a character. As we add each word from the sentence to the <code>Trie</code>, we also store the word’s position in the sentence. This is done by keeping a list of positions at each node that corresponds to a character in the word. Later, when we search for a prefix, we can quickly find all the words that match it using this stored information.</p>
<p>For each word in the sentence, we go through the <code>Trie</code> one character at a time. If a character is not already in the Trie, we create a new node for it. As we move through the <code>Trie</code>, we update the list at each node to keep track of which words pass through that character. By the end, the <code>Trie</code> will store all the words in the sentence, organized by their common prefixes.</p>
<p>Once the <code>Trie</code> is built, we can search for the <code>searchWord</code> by going through the <code>Trie</code> one character at a time. If we find all the characters of the <code>searchWord</code>, it means some words in the sentence start with that prefix. The list of word positions at the final node of the <code>searchWord</code> tells us which words match. If we can’t find the node for the <code>searchWord</code>, it means no word in the sentence starts with it.</p>
<p>If we find matching words, we return the smallest position from the list of word positions. This tells us the first word in the sentence that starts with the <code>searchWord</code>. If no matches are found, we return <code>-1</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize the <code>Trie</code> data structure with the root node.</p>
</li>
<li>
<p>Add each word in the sentence to the Trie:</p>
<ul>
<li>Split the sentence into words using an <code>istringstream</code>.</li>
<li>For each word, call <code>addToTrie(word, currentWordPosition)</code> to insert the word into the Trie, associating the word's position in the sentence with it.</li>
<li>Increment <code>currentWordPosition</code> for each word.</li>
</ul>
</li>
<li>
<p>Once all words are added to the Trie, check if the <code>searchWord</code> is a prefix of any word in the sentence:</p>
<ul>
<li>Call <code>checkPrefix(searchWord)</code> to find the positions of words starting with the <code>searchWord</code> prefix.</li>
<li>If no words match the prefix, return <code>-1</code>.</li>
<li>Otherwise, return the smallest position (first occurrence) where the prefix is found in the list of positions.</li>
</ul>
</li>
<li>
<p><code>addToTrie</code> function:</p>
<ul>
<li>Start from the root node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>If <code>c</code> is not found in the current node's children, create a new TrieNode for <code>c</code>.</li>
<li>Move to the child node corresponding to <code>c</code>.</li>
<li>Add the <code>currentWordPosition</code> to the node’s <code>currentWordPosition</code> list.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>checkPrefix</code> function:</p>
<ul>
<li>Start from the root node.</li>
<li>For each character <code>c</code> in the word:
<ul>
<li>If <code>c</code> is not found in the current node's children, return an empty list (no matching prefix).</li>
<li>Move to the child node corresponding to <code>c</code>.</li>
</ul>
</li>
<li>Return the list of word positions stored in the node corresponding to the last character of the prefix.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/76kWke3Z/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>sentence</code>, <span class="math inline">\(m\)</span> be the size of the input string <code>searchWord</code>, <span class="math inline">\(k\)</span> be the average length of words in <code>sentence</code>, and <span class="math inline">\(w\)</span> be the total number of words in <code>sentence</code> such that <span class="math inline">\(w \cdot k = n\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m) \approx O(n)\)</span></p>
<p>The algorithm involves splitting the <code>sentence</code> into words, which takes <span class="math inline">\(O(n)\)</span> time. Building the Trie structure involves inserting each word into the Trie, which takes <span class="math inline">\(O(n)\)</span> time in total (since each character is processed once). Checking the prefix of <code>searchWord</code> in the Trie takes <span class="math inline">\(O(m)\)</span> time, as it involves traversing the Trie for each character in <code>searchWord</code>. Thus, the overall time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the Trie structure, which stores all the words from the <code>sentence</code>. In the worst case, the Trie will store all characters of all words, resulting in <span class="math inline">\(O(n)\)</span> space. Additionally, the <code>words</code> list created by splitting the <code>sentence</code> also consumes <span class="math inline">\(O(n)\)</span> space. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-19">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-n-and-its-double-exist/description" target="_blank" rel="noopener noreferrer">Check If N and Its Double Exist</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>arr</code> of integers, check if there exist two indices <code>i</code> and <code>j</code> such that :</p>

<ul>
	<li><code>i != j</code></li>
	<li><code>0 &lt;= i, j &lt; arr.length</code></li>
	<li><code>arr[i] == 2 * arr[j]</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [10,2,5,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,1,7,11]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no i and j that satisfy the conditions.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 500</code></li>
	<li><code>-10<sup>3</sup> &lt;= arr[i] &lt;= 10<sup>3</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>This problem is designed to help beginners get comfortable with basic array operations and the implementation of basic data structures. We are given an array and our goal is to find out if there are two different indices, represented by <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, where the value of one is twice the value of the other.</p>
<p>How to interpret the three conditions:</p>
<ul>
<li><code>i</code> and <code>j</code> must be different indices. This might seem like an obvious point unless you consider that <span class="math inline">\(0 = 2 \times 0\)</span>. Without this condition, we'd be able to count just one <code>0</code> in the array as satisfying the goal. With this condition, an array would need two <code>0</code>s to satisfy the conditions.</li>
<li><code>0 &lt;= i, j &lt; arr.length</code> just means that the indices are within the bounds of the array. This condition doesn't mean much, it's essentially a requirement for any array-based algorithm.</li>
<li><code>arr[i] == 2 * arr[j]</code> is how we know <code>i</code> needs to be double <code>j</code>.</li>
</ul>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>One simple approach is to calculate the double of each number and then check if that value is in the array. This brute force method directly explores all possible pairs for each element until the result is found. This approach works but is not the most efficient.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Iterate through all pairs of indices <code>i</code> and <code>j</code> in the array <code>arr</code>.</p>
<ul>
<li>For each pair, check if:
<ul>
<li><code>i != j</code> (to ensure we aren't comparing the same element).</li>
<li><code>arr[i] == 2 * arr[j]</code> (one element is double the other).</li>
</ul>
</li>
<li>If both conditions are met, return <code>true</code> to indicate a valid pair is found.</li>
</ul>
</li>
<li>
<p>If no valid pair is found after checking all pairs, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/4wc64szF/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm consists of two nested loops. The outer loop iterates over each element in the array <code>arr</code>, and the inner loop also iterates over all elements of <code>arr</code>. For each pair of indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, the algorithm checks the condition <span class="math inline">\(arr[i] == 2 \times arr[j]\)</span> and ensures <span class="math inline">\(i \neq j\)</span>.</p>
<p>Since both loops iterate <code>n</code> times, the time complexity of the nested loops is <span class="math inline">\(O(n \times n) = O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm does not use any additional data structures that grow with the size of the input. The space used by the algorithm is constant, as it only requires a few variables for the loop indices and condition checking. Therefore, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-set-lookup">Approach 2: Set Lookup</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The brute force method doesn’t keep track of what it’s seen, so it wastes effort by revisiting the same values each time it loops through the array. Let's break down a solution where we can &quot;store what we’ve seen&quot; to speed up lookups.</p>
<p>A hash set works well here because it allows constant-time insertion and lookup. Instead of scanning the array multiple times, we use the set to check if <span class="math inline">\(2 \times arr[i]\)</span> or <span class="math inline">\(arr[i] / 2\)</span> (when divisible) already exists. If neither condition is met, we add <span class="math inline">\(arr[i]\)</span> to the set and continue.</p>
<p>This way, we only iterate through the array once and eliminate the unnecessary comparisons we made in the brute force approach.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty set named <code>seen</code> to store numbers encountered so far.</p>
</li>
<li>
<p>For each <code>num</code> in the array <code>arr</code>:</p>
<ul>
<li>Check if <code>2 * num</code> or <code>num / 2</code> exists in the <code>seen</code> set:
<ul>
<li>If <code>2 * num</code> is found in the set, or if <code>num</code> is divisible by 2 and <code>num / 2</code> is found in the set, return <code>true</code> (a valid pair is found).</li>
</ul>
</li>
<li>Add the current number <code>num</code> to the <code>seen</code> set for future checks.</li>
</ul>
</li>
<li>
<p>If no valid pair is found after checking all elements, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/XXqGNvZy/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the array <code>arr</code> once, processing each element individually. For each element, it performs two operations:</p>
<ol>
<li>Checking if <span class="math inline">\(2 \times \text{num}\)</span> or <span class="math inline">\(\text{num} / 2\)</span> is in the set, which takes <span class="math inline">\(O(1)\)</span> on average due to the constant-time lookup in the set.</li>
<li>Adding the current element to the set, which also takes <span class="math inline">\(O(1)\)</span> on average for each insertion.</li>
</ol>
<p>Since both operations inside the loop take constant time, and the loop runs <code>n</code> times, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The primary space usage comes from the set, which stores up to <code>n</code> unique elements from the array <code>arr</code>. In the worst case, when all elements are unique, the set will contain <code>n</code> elements, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>No additional significant data structures are used, so the auxiliary space complexity is <span class="math inline">\(O(1)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-sorting--binary-search">Approach 3: Sorting + Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Let's make a simple observation: except when the values of <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are both 0, <span class="math inline">\(j\)</span> will always be greater than <span class="math inline">\(i\)</span>. Since the relationship between the two is directional, we can sort the array in ascending order and apply one of the most fundamental search algorithms: binary search.</p>
<p>Binary search is a two-pointer technique for efficiently locating a value in an ordered collection. Unlike Approach One, which checks each element individually, binary search repeatedly divides the search range in half which significantly reduces the number of comparisons we need to make.</p>
<blockquote>
<p>For a more comprehensive understanding of binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card 🔗</a>. This resource offers an in-depth look at binary search, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<p>We start by setting one pointer to the first possible element and the second pointer to the last. At each step, we compare the target value to the middle element of the current range. If the target is greater than the midpoint, we eliminate all elements before the midpoint by moving the first pointer to the position just right of it. If the target is smaller, we eliminate all elements after the midpoint by moving the second pointer to the position just left of it. This process continues until the target is found or the range is empty.</p>
<p>!?!../Documents/1346/1346_approach3.json:805,545!?!</p>
</br>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>arr</code> in ascending order to enable efficient searching.</p>
</li>
<li>
<p>For each element <code>arr[i]</code> in the array:</p>
<ul>
<li>
<p>Calculate the target value as <code>2 * arr[i]</code> (double the current number).</p>
</li>
<li>
<p>Perform a custom binary search for the target in the array:</p>
<ul>
<li>In the <code>customBinarySearch</code> function:
<ul>
<li>Set <code>left</code> to 0 and <code>right</code> to <code>arr.length - 1</code> to define the search range.</li>
<li>While <code>left &lt;= right</code>, calculate the midpoint <code>mid</code>.
<ul>
<li>If <code>arr[mid] == target</code>, return the index <code>mid</code> (target found).</li>
<li>If <code>arr[mid] &lt; target</code>, move the <code>left</code> pointer to <code>mid + 1</code> to search the right half.</li>
<li>If <code>arr[mid] &gt; target</code>, move the <code>right</code> pointer to <code>mid - 1</code> to search the left half.</li>
</ul>
</li>
<li>If the target is not found, return <code>-1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the target exists and its index is not the same as the current index <code>i</code>, return <code>true</code> (found a pair where one element is double the other).</p>
</li>
</ul>
</li>
<li>
<p>If no valid pair is found after iterating through the array, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/nk58Tg9Z/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The sort function sorts the array in <span class="math inline">\(O(n \log n)\)</span> time. Sorting is the most time-consuming operation here.</p>
<p>The for loop iterates through each element in the array, and for each element, it calls the <code>customBinarySearch</code> function. The binary search operation itself takes <span class="math inline">\(O(\log n)\)</span> time, as it divides the search space in half at each step.</p>
<p>Therefore, the time complexity of the loop is <span class="math inline">\(O(n)\)</span> for iterating through the array, and for each iteration, the binary search takes <span class="math inline">\(O(\log n)\)</span>. Thus, the total time complexity for the loop is <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Combining both parts, the overall time complexity is <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span></p>
<p>The space taken by the sorting algorithm depends on the language of implementation:</p>
<p>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</p>
<p>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</p>
<p>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The binary search uses constant space for variables like <code>left</code>, <code>right</code>, and <code>mid</code>. The loop also does not use any additional space other than a few variables. Therefore, the space used by the loop is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-frequency-hash-map">Approach 4: Frequency Hash Map</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of using a hash set to find the pair like we did in Approach 2, we can use a frequency map. Some may understandably wonder why we don't use a frequency array instead of a map, which could be more memory-efficient and an excellent choice if the constraint were <code>&gt;= 0</code>. However, since this problem allows negative numbers, a frequency map is the better choice.</p>
<p>First, we will count the number of occurrences of each number and store their counts in their respective indices. Then, we will iterate again and check each element:</p>
<ol>
<li>If <code>num</code> is in the array, we check if <code>2 * num</code> also exists using the map.</li>
<li>If <code>num = 0</code>, we ensure its count is at least 2 to satisfy <code>i ≠ j</code>.</li>
</ol>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty hash map called <code>map</code> to store the count of occurrences of each number in the array.</p>
</li>
<li>
<p>For each number <code>num</code> in <code>arr</code>:</p>
<ul>
<li>Update the map with the count of <code>num</code> by incrementing the value associated with <code>num</code> in <code>map</code>.</li>
</ul>
</li>
<li>
<p>After populating the map, check for the condition where a number has a double in the array:</p>
<ul>
<li>For each <code>num</code> in <code>arr</code>, if <code>num</code> is not zero and <code>map</code> contains <code>2 * num</code>, return <code>true</code> (found a number with its double).</li>
<li>If <code>num</code> is zero and there are more than one zero in the array (i.e., <code>map.get(num) &gt; 1</code>), return <code>true</code> (special case where 0 is double of 0).</li>
</ul>
</li>
<li>
<p>If no such pair is found, return <code>false</code> (no number has its double in the array).</p>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/9e6gbmPT/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <code>n</code> be the size of the input array <code>arr</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm consists of two main loops. The first loop iterates through the array <code>arr</code> and inserts or updates each element in the hash map. The insertion operation in the hash map takes <span class="math inline">\(O(1)\)</span> on average, so the time complexity of this loop is <span class="math inline">\(O(n)\)</span>.</p>
<p>The second loop also iterates through the array <code>arr</code> and performs constant-time operations for each element, including lookups in the hash map (which are <span class="math inline">\(O(1)\)</span> on average). Therefore, the time complexity of this loop is also <span class="math inline">\(O(n)\)</span>.</p>
<p>As a result, the overall time complexity is <span class="math inline">\(O(n) + O(n) = O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is dominated by the hash map, which stores up to <code>n</code> unique elements from the array <code>arr</code>. Each key-value pair in the hash map consumes space, so in the worst case, the space required is proportional to the number of unique elements in <code>arr</code>, which is <span class="math inline">\(O(n)\)</span>.</p>
<p>No additional data structures that depend on the size of the input are used, so the auxiliary space is <span class="math inline">\(O(1)\)</span>. Therefore, the total space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</br>
<h4 id="note-on-hash-maps-and-sets">Note on Hash Maps and Sets</h4>
<p>Hash maps and hash sets are widely used data structures that provide efficient storage and retrieval of data. Their average-case time complexity for most operations, such as insertion, deletion, and lookup, is often <span class="math inline">\(O(1)\)</span>. However, this efficiency depends on several factors, and there are edge cases where performance can degrade.</p>
<h5 id="average-case-complexity-o1">Average-Case Complexity: <span class="math inline">\(O(1)\)</span></h5>
<p>Hashing Process: The operation relies on a hash function, which maps keys to specific &quot;buckets&quot; in memory.</p>
<ul>
<li>A well-designed hash function ensures uniform distribution of keys across buckets. The hash computation itself is expected to be a constant-time operation in most cases.</li>
<li>Once the hash is computed, the bucket corresponding to the hash is accessed directly, making the lookup process efficient.</li>
</ul>
<h5 id="worst-case-complexity-on">Worst-Case Complexity: <span class="math inline">\(O(n)\)</span></h5>
<p>Hash Collisions: When multiple keys map to the same bucket due to the hash function returning the same hash code, a collision occurs.</p>
<ul>
<li>In such cases, the hash map stores all colliding entries in a bucket, typically as a linked list.</li>
<li>To resolve collisions, the hash map iterates through the bucket, checking each entry with an equality comparison, leading to <span class="math inline">\(O(n)\)</span> time complexity if all keys hash to the same bucket.</li>
<li>This worst-case scenario is extremelly rare with a good hash function, but it is still a theoretical limitation to consider when designing or selecting algorithms.</li>
</ul>
<h5 id="improvements-in-modern-implementations-eg-java-hashmap-in-jdk-8">Improvements in Modern Implementations (e.g., Java HashMap in JDK 8)</h5>
<p>Tree-Backed Buckets: In modern hash map implementations, buckets that become densely populated are converted into balanced binary trees.</p>
<ul>
<li>This reduces the lookup time complexity in such cases from <span class="math inline">\(O(n)\)</span> to <span class="math inline">\(O(\log n)\)</span>. The tree structure leverages key ordering for efficient traversal.</li>
<li>If the key type's equality (<code>equals</code>) and ordering (<code>compareTo</code>) logic are inconsistent, this optimization sometimes leads to unpredictable behavior.</li>
</ul>
<h5 id="takeaway">Takeaway:</h5>
<p>In most real-world scenarios, hash maps and sets offer excellent performance and are the default choice for many applications requiring fast lookups.</p>
<p>However, be cautious of:</p>
<ul>
<li>Poor hash functions.</li>
<li>Memory limitations.</li>
<li>Keys with inconsistent equality and ordering logic in modern implementations.</li>
</ul>
<p>In general, when analyzing time complexity and space complexity in editorials, videos or discussions on the internet, most assume that hash functions are well-designed. This assumption allows us to consider the complexity of hash table operations as <span class="math inline">\(O(1)\)</span>, rather than <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>. This consistent behavior is reflected in almost all articles or videos you may encounter, where lookups are always described as constant time, never as <span class="math inline">\(O(n)\)</span> due to the underlying principles of hash functions.</p>
<p>To deepen your understanding of hash maps, sets, and their underlying principles, the following resources are highly recommended:</p>
<ol>
<li><a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>: This card has some great explanations on how it is applied to different DSA problems and how to recognize this pattern.</li>
<li><a href="https://en.wikipedia.org/wiki/Universal_hashing">Universal Hashing</a>: This explains the principles behind creating hash functions that achieve the ideal <span class="math inline">\(O(1)\)</span> performance.</li>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table</a>: This covers collision handling techniques (like chaining and open addressing) and practical trade-offs in hash table design.</li>
</ol>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-20">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/check-if-string-is-a-prefix-of-array/description" target="_blank" rel="noopener noreferrer">Check If String Is a Prefix of Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an array of strings <code>words</code>, determine whether <code>s</code> is a <strong>prefix string</strong> of <code>words</code>.</p>

<p>A string <code>s</code> is a <strong>prefix string</strong> of <code>words</code> if <code>s</code> can be made by concatenating the first <code>k</code> strings in <code>words</code> for some <strong>positive</strong> <code>k</code> no larger than <code>words.length</code>.</p>

<p>Return <code>true</code><em> if </em><code>s</code><em> is a <strong>prefix string</strong> of </em><code>words</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;apples&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong>
s can be made by concatenating &quot;i&quot;, &quot;love&quot;, and &quot;leetcode&quot; together.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;apples&quot;,&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong>
It is impossible to make s using a prefix of arr.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>words[i]</code> and <code>s</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-21">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description" target="_blank" rel="noopener noreferrer">Checking Existence of Edge Length Limited Paths</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An undirected graph of <code>n</code> nodes is defined by <code>edgeList</code>, where <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with distance <code>dis<sub>i</sub></code>. Note that there may be <strong>multiple</strong> edges between two nodes.</p>

<p>Given an array <code>queries</code>, where <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code>, your task is to determine for each <code>queries[j]</code> whether there is a path between <code>p<sub>j</sub></code> and <code>q<sub>j</sub></code><sub> </sub>such that each edge on the path has a distance <strong>strictly less than</strong> <code>limit<sub>j</sub></code> .</p>

<p>Return <em>a <strong>boolean array</strong> </em><code>answer</code><em>, where </em><code>answer.length == queries.length</code> <em>and the </em><code>j<sup>th</sup></code> <em>value of </em><code>answer</code> <em>is </em><code>true</code><em> if there is a path for </em><code>queries[j]</code><em> is </em><code>true</code><em>, and </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/h.png" style="width: 267px; height: 262px;" />
<pre>
<strong>Input:</strong> n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
<strong>Output:</strong> [false,true]
<strong>Explanation:</strong> The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/08/q.png" style="width: 390px; height: 358px;" />
<pre>
<strong>Input:</strong> n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
<strong>Output:</strong> [true,false]
<strong>Explanation:</strong> The above figure shows the given graph.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>edgeList[i].length == 3</code></li>
	<li><code>queries[j].length == 3</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>
	<li><code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
	<li>There may be <strong>multiple</strong> edges between two nodes.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-22">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/circular-array-loop/description" target="_blank" rel="noopener noreferrer">Circular Array Loop</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are playing a game involving a <strong>circular</strong> array of non-zero integers <code>nums</code>. Each <code>nums[i]</code> denotes the number of indices forward/backward you must move if you are located at index <code>i</code>:</p>

<ul>
	<li>If <code>nums[i]</code> is positive, move <code>nums[i]</code> steps <strong>forward</strong>, and</li>
	<li>If <code>nums[i]</code> is negative, move <code>nums[i]</code> steps <strong>backward</strong>.</li>
</ul>

<p>Since the array is <strong>circular</strong>, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.</p>

<p>A <strong>cycle</strong> in the array consists of a sequence of indices <code>seq</code> of length <code>k</code> where:</p>

<ul>
	<li>Following the movement rules above results in the repeating index sequence <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>
	<li>Every <code>nums[seq[j]]</code> is either <strong>all positive</strong> or <strong>all negative</strong>.</li>
	<li><code>k &gt; 1</code></li>
</ul>

<p>Return <code>true</code><em> if there is a <strong>cycle</strong> in </em><code>nums</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/01/img1.jpg" style="width: 402px; height: 289px;" />
<pre>
<strong>Input:</strong> nums = [2,-1,1,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --&gt; 2 --&gt; 3 --&gt; 0 --&gt; ..., and all of its nodes are white (jumping in the same direction).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/01/img2.jpg" style="width: 402px; height: 390px;" />
<pre>
<strong>Input:</strong> nums = [-1,-2,-3,-4,-5,6]
<strong>Output:</strong> false
<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
The only cycle is of size 1, so we return false.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/09/01/img3.jpg" style="width: 497px; height: 242px;" />
<pre>
<strong>Input:</strong> nums = [1,-1,5,1,4]
<strong>Output:</strong> true
<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --&gt; 1 --&gt; 0 --&gt; ..., and while it is of size &gt; 1, it has a node jumping forward and a node jumping backward, so <strong>it is not a cycle</strong>.
We can see the cycle 3 --&gt; 4 --&gt; 3 --&gt; ..., and all of its nodes are white (jumping in the same direction).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>nums[i] != 0</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you solve it in <code>O(n)</code> time complexity and <code>O(1)</code> extra space complexity?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-23">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/closest-pair-sum-in-an-unsorted-array/1" target="_blank" rel="noopener noreferrer">Closest Pair Sum in an unsorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;and an integer&nbsp;<strong>target</strong>.&nbsp;</span><span style="font-size: 18px;">You have to find a&nbsp;</span><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; text-align: justify;">pair in an array whose sum is closest to&nbsp;<strong>target</strong>.</span></p>
<p><strong><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; text-align: justify;">Note:&nbsp;</span></strong><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; text-align: justify;">Return the pair in sorted order and i</span><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">f there are multiple such pairs return the pair with maximum absolute difference. If no such pair exists return an empty array.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">arr[] = [40, 10, 29, 28, 22, 1, 30], target = 54 </span><span style="font-size: 18px;">
<strong>Output: </strong>[22, 30]<strong>
Explanation: </strong></span><span style="font-size: 18px;">The pair 22 and 30 sums to 52 which is the closest sum to 54.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [10, 3, 4, 7, 1], target = 15 
<strong>Output: </strong>[4, 10]<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">The pair 4 and 10 sums to 14 which is the closest sum to 15.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= arr.size() &lt;= 10<sup>5</sup><strong><br /></strong></span><span style="font-size: 18px;">0 &lt;= arr[i]&nbsp;</span><span style="font-size: 18px;">&lt;= 10<sup>4</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">1 &lt;= target &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-24">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/closest-subsequence-sum/description" target="_blank" rel="noopener noreferrer">Closest Subsequence Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>goal</code>.</p>

<p>You want to choose a subsequence of <code>nums</code> such that the sum of its elements is the closest possible to <code>goal</code>. That is, if the sum of the subsequence&#39;s elements is <code>sum</code>, then you want to <strong>minimize the absolute difference</strong> <code>abs(sum - goal)</code>.</p>

<p>Return <em>the <strong>minimum</strong> possible value of</em> <code>abs(sum - goal)</code>.</p>

<p>Note that a subsequence of an array is an array formed by removing some elements <strong>(possibly all or none)</strong> of the original array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,-7,3,5], goal = 6
<strong>Output:</strong> 0
<strong>Explanation:</strong> Choose the whole array as a subsequence, with a sum of 6.
This is equal to the goal, so the absolute difference is 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,-9,15,-2], goal = -5
<strong>Output:</strong> 1
<strong>Explanation:</strong> Choose the subsequence [7,-9,-2], with a sum of -4.
The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], goal = -7
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 40</code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-25">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/coin-piles5152/1" target="_blank" rel="noopener noreferrer">Coin Piles</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-start="246" data-end="383"><span style="font-size: 14pt;">You are given an array <strong>arr[]</strong> of integers, where each element represents the number of coins in a pile. You are also given an integer <strong>k.</strong><br /></span><span style="font-size: 14pt;">Your task is to remove the minimum number of <strong>coins</strong> such that the absolute difference between the number of coins in any two updated piles is at most <strong>k.</strong></span></p>
<p><span style="font-size: 18px;"> <strong>Note</strong>:&nbsp;You can also remove a pile by removing all the coins of that pile.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 2, 2, 2], k = 0
<strong>Output: </strong>0
<strong>Explanation: </strong></span><span style="font-size: 18px;">For any two piles the difference in the number of coins is &lt;= 0. So no need to remove any coin.</span> 
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[]<strong> = </strong>[1, 5, 1, 2, 5, 1], k = 3
<strong>Output: </strong>2</span>
<span style="font-size: 18px;"><strong>Explanation: </strong></span><span style="font-size: 18px;">If we remove one coin each from both the piles containing 5 coins, then for any two piles the absolute difference in the number of coins is &lt;= 3.</span> 
</pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; arr.size() &le; 10<sup>5<br /></sup><span style="font-size: 18.6667px;">1 &le; arr[i] &le; 10</span><sup>4</sup><sup><br /></sup></span><span style="font-size: 18px;">0 &le; k &le; 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-26">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/compare-version-numbers/description" target="_blank" rel="noopener noreferrer">Compare Version Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two <strong>version strings</strong>, <code>version1</code> and <code>version2</code>, compare them. A version string consists of <strong>revisions</strong> separated by dots <code>&#39;.&#39;</code>. The <strong>value of the revision</strong> is its <strong>integer conversion</strong> ignoring leading zeros.</p>

<p>To compare version strings, compare their revision values in <strong>left-to-right order</strong>. If one of the version strings has fewer revisions, treat the missing revision values as <code>0</code>.</p>

<p>Return the following:</p>

<ul>
	<li>If <code>version1 &lt; version2</code>, return -1.</li>
	<li>If <code>version1 &gt; version2</code>, return 1.</li>
	<li>Otherwise, return 0.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>version1&#39;s second revision is &quot;2&quot; and version2&#39;s second revision is &quot;10&quot;: 2 &lt; 10, so version1 &lt; version2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">version1 = &quot;1.0&quot;, version2 = &quot;1.0.0.0&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>version1 has less revisions, which means every missing revision are treated as &quot;0&quot;.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>
	<li><code>version1</code> and <code>version2</code>&nbsp;only contain digits and <code>&#39;.&#39;</code>.</li>
	<li><code>version1</code> and <code>version2</code>&nbsp;<strong>are valid version numbers</strong>.</li>
	<li>All the given revisions in&nbsp;<code>version1</code> and <code>version2</code>&nbsp;can be stored in&nbsp;a&nbsp;<strong>32-bit integer</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-27">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/container-with-most-water/description" target="_blank" rel="noopener noreferrer">Container With Most Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>

<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>

<p>Return <em>the maximum amount of water a container can store</em>.</p>

<p><strong>Notice</strong> that you may not slant the container.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" style="width: 600px; height: 287px;" />
<pre>
<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]
<strong>Output:</strong> 49
<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> height = [1,1]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == height.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-28">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-binary-substrings/description" target="_blank" rel="noopener noreferrer">Count Binary Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a binary string <code>s</code>, return the number of non-empty substrings that have the same number of <code>0</code>&#39;s and <code>1</code>&#39;s, and all the <code>0</code>&#39;s and all the <code>1</code>&#39;s in these substrings are grouped consecutively.</p>

<p>Substrings that occur multiple times are counted the number of times they occur.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;00110011&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, &quot;00110011&quot; is not a valid substring because all the 0&#39;s (and 1&#39;s) are not grouped together.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;10101&quot;
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h3 id="approach-1-group-by-character-accepted">Approach #1: Group By Character [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>We can convert the string <code>s</code> into an array <code>groups</code> that represents the length of same-character contiguous blocks within the string. For example, if <code>s = &quot;110001111000000&quot;</code>, then <code>groups = [2, 3, 4, 6]</code>.</p>
<p>For every binary string of the form <code>'0' * k + '1' * k</code> or <code>'1' * k + '0' * k</code>, the middle of this string must occur between two groups.</p>
<p>Let's try to count the number of valid binary strings between <code>groups[i]</code> and <code>groups[i+1]</code>. If we have <code>groups[i] = 2, groups[i+1] = 3</code>, then it represents either <code>&quot;00111&quot;</code> or <code>&quot;11000&quot;</code>. We clearly can make <code>min(groups[i], groups[i+1])</code> valid binary strings within this string.  Because the binary digits to the left or right of this string must change at the boundary, our answer can never be larger.</p>
<p><strong>Algorithm</strong></p>
<p>Let's create <code>groups</code> as defined above. The first element of <code>s</code> belongs in its own group. From then on, each element either doesn't match the previous element, so that it starts a new group of size 1, or it does match, so that the size of the most recent group increases by 1.</p>
<p>Afterward, we will take the sum of <code>min(groups[i-1], groups[i])</code>.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">countBinarySubstrings</span>(<span style="color:#999">self</span>, s):
</span></span><span style="display:flex;"><span>        groups <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> xrange(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(s)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> s[i<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">!=</span> s[i]:
</span></span><span style="display:flex;"><span>                groups<span style="color:#000;font-weight:bold">.</span>append(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                groups[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ans <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> xrange(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(groups)):
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> <span style="color:#0086b3">min</span>(groups[i<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>], groups[i])
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans
</span></span></code></pre><p><em>Alternate Implentation</em></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">countBinarySubstrings</span>(<span style="color:#999">self</span>, s):
</span></span><span style="display:flex;"><span>        groups <span style="color:#000;font-weight:bold">=</span> [<span style="color:#0086b3">len</span>(<span style="color:#0086b3">list</span>(v)) <span style="color:#000;font-weight:bold">for</span> _, v <span style="color:#000;font-weight:bold">in</span> itertools<span style="color:#000;font-weight:bold">.</span>groupby(s)]
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">sum</span>(<span style="color:#0086b3">min</span>(a, b) <span style="color:#000;font-weight:bold">for</span> a, b <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">zip</span>(groups, groups[<span style="color:#099">1</span>:]))
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">countBinarySubstrings</span><span style="color:#000;font-weight:bold">(</span>String s<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[]</span> groups <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">[</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">()];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> t <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        groups<span style="color:#000;font-weight:bold">[</span>0<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">();</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">!=</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                groups<span style="color:#000;font-weight:bold">[++</span>t<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                groups<span style="color:#000;font-weight:bold">[</span>t<span style="color:#000;font-weight:bold">]++;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;=</span> t<span style="color:#000;font-weight:bold">;</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#000;font-weight:bold">+=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>groups<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">],</span> groups<span style="color:#000;font-weight:bold">[</span>i<span style="color:#000;font-weight:bold">]);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>s</code>. Every loop is through <span class="math inline">\(O(N)\)</span> items with <span class="math inline">\(O(1)\)</span> work inside the for-block.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the space used by <code>groups</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-linear-scan-accepted">Approach #2: Linear Scan [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can amend our <em>Approach #1</em> to calculate the answer on the fly. Instead of storing <code>groups</code>, we will remember only <code>prev = groups[-2]</code> and <code>cur = groups[-1]</code>.  Then, the answer is the sum of <code>min(prev, cur)</code> over each different final <code>(prev, cur)</code> we see.</p>
<p><strong>Python</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span>(<span style="color:#0086b3">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">countBinarySubstrings</span>(<span style="color:#999">self</span>, s):
</span></span><span style="display:flex;"><span>        ans, prev, cur <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> xrange(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(s)):
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> s[i<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">!=</span> s[i]:
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">+=</span> <span style="color:#0086b3">min</span>(prev, cur)
</span></span><span style="display:flex;"><span>                prev, cur <span style="color:#000;font-weight:bold">=</span> cur, <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>                cur <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">min</span>(prev, cur)
</span></span></code></pre><p><strong>Java</strong></p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">Solution</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">public</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">countBinarySubstrings</span><span style="color:#000;font-weight:bold">(</span>String s<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">int</span> ans <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> prev <span style="color:#000;font-weight:bold">=</span> 0<span style="color:#000;font-weight:bold">,</span> cur <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span> i <span style="color:#000;font-weight:bold">&lt;</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">length</span><span style="color:#000;font-weight:bold">();</span> i<span style="color:#000;font-weight:bold">++)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">-</span>1<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">!=</span> s<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">charAt</span><span style="color:#000;font-weight:bold">(</span>i<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#000;font-weight:bold">+=</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>prev<span style="color:#000;font-weight:bold">,</span> cur<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>                prev <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>                cur <span style="color:#000;font-weight:bold">=</span> 1<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                cur<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ans <span style="color:#000;font-weight:bold">+</span> Math<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">min</span><span style="color:#000;font-weight:bold">(</span>prev<span style="color:#000;font-weight:bold">,</span> cur<span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>s</code>. Every loop is through <span class="math inline">\(O(N)\)</span> items with <span class="math inline">\(O(1)\)</span> work inside the for-block.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>, the space used by <code>prev</code>, <code>cur</code>, and <code>ans</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-29">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-of-nodes/description" target="_blank" rel="noopener noreferrer">Count Pairs Of Nodes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">graph</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an undirected graph defined by an integer <code>n</code>, the number of nodes, and a 2D integer array <code>edges</code>, the edges in the graph, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates that there is an <strong>undirected</strong> edge between <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>. You are also given an integer array <code>queries</code>.</p>

<p>Let <code>incident(a, b)</code> be defined as the <strong>number of edges</strong> that are connected to <strong>either</strong> node <code>a</code> or <code>b</code>.</p>

<p>The answer to the <code>j<sup>th</sup></code> query is the <strong>number of pairs</strong> of nodes <code>(a, b)</code> that satisfy <strong>both</strong> of the following conditions:</p>

<ul>
	<li><code>a &lt; b</code></li>
	<li><code>incident(a, b) &gt; queries[j]</code></li>
</ul>

<p>Return <em>an array </em><code>answers</code><em> such that </em><code>answers.length == queries.length</code><em> and </em><code>answers[j]</code><em> is the answer of the </em><code>j<sup>th</sup></code><em> query</em>.</p>

<p>Note that there can be <strong>multiple edges</strong> between the same two nodes.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/winword_2021-06-08_00-58-39.png" style="width: 529px; height: 305px;" />
<pre>
<strong>Input:</strong> n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
<strong>Output:</strong> [6,5]
<strong>Explanation:</strong> The calculations for incident(a, b) are shown in the table above.
The answers for each of the queries are as follows:
- answers[0] = 6. All the pairs have an incident(a, b) value greater than 2.
- answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
<strong>Output:</strong> [10,10,9,8,6]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
	<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
	<li><code>1 &lt;= queries.length &lt;= 20</code></li>
	<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-30">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-pairs-whose-sum-is-less-than-target/1" target="_blank" rel="noopener noreferrer">Count Pairs whose sum is less than target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array&nbsp;<strong>arr[]</strong>&nbsp;and an integer&nbsp;<strong>target</strong>.&nbsp;</span><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px; text-align: justify;">You have to find the number of pairs in the array whose sum is strictly less than the&nbsp;<strong>target</strong>.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">arr[] = [7, 2, 5, 3], target = 8</span><span style="font-size: 18px;">
<strong>Output: </strong>2<strong>
Explanation: </strong></span><span style="font-size: 18px;">There are 2 pairs with sum less than 8: (2, 5) and (2, 3). </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [5, 2, 3, 2, 4, 1], target = 5
<strong>Output: </strong>4<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">There are 4 pairs whose sum is less than 5: (2, 2), (2, 1), (3, 1) and (2, 1).<br /></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [2, 1, 8, 3, 4, 7, 6, 5], target = 7
<strong>Output: </strong>6<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">There are 6 pairs whose sum is less than 7: (2, 1), (2, 3), (2, 4), (1, 3), (1, 4) and (1, 5).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= arr.size() &lt;= 10<sup>5</sup><strong><br /></strong></span><span style="font-size: 18px;">0 &lt;= arr[i]&nbsp;</span><span style="font-size: 18px;">&lt;= 10<sup>4</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">1 &lt;= target &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-31">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/description" target="_blank" rel="noopener noreferrer">Count Pairs Whose Sum is Less than Target</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section">Given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, return <em>the number of pairs</em> <code>(i, j)</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; n</code> <em>and</em> <code>nums[i] + nums[j] &lt; target</code>.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,1,2,3,1], target = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are 3 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = 0 &lt; target
- (0, 2) since 0 &lt; 2 and nums[0] + nums[2] = 1 &lt; target 
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = 0 &lt; target
Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-6,2,5,-2,-7,-1,3], target = -2
<strong>Output:</strong> 10
<strong>Explanation:</strong> There are 10 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = -4 &lt; target
- (0, 3) since 0 &lt; 3 and nums[0] + nums[3] = -8 &lt; target
- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = -13 &lt; target
- (0, 5) since 0 &lt; 5 and nums[0] + nums[5] = -7 &lt; target
- (0, 6) since 0 &lt; 6 and nums[0] + nums[6] = -3 &lt; target
- (1, 4) since 1 &lt; 4 and nums[1] + nums[4] = -5 &lt; target
- (3, 4) since 3 &lt; 4 and nums[3] + nums[4] = -9 &lt; target
- (3, 5) since 3 &lt; 5 and nums[3] + nums[5] = -3 &lt; target
- (4, 5) since 4 &lt; 5 and nums[4] + nums[5] = -8 &lt; target
- (4, 6) since 4 &lt; 6 and nums[4] + nums[6] = -4 &lt; target
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length == n &lt;= 50</code></li>
	<li><code>-50 &lt;= nums[i], target &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-32">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-fair-pairs/description" target="_blank" rel="noopener noreferrer">Count the Number of Fair Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of fair pairs</em>.</p>

<p>A pair <code>(i, j)</code> is <b>fair </b>if:</p>

<ul>
	<li><code>0 &lt;= i &lt; j &lt; n</code>, and</li>
	<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,7,4,4,5], lower = 3, upper = 6
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,7,9,2,5], lower = 11, upper = 11
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is a single fair pair: (2,3).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums.length == n</code></li>
	<li><code><font face="monospace">-10<sup>9</sup></font>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code><font face="monospace">-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></font></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We have an array called <code>nums</code> with <code>n</code> elements, along with two integers, <code>lower</code> and <code>upper</code>. Our task is to find out how many pairs of indices <code>(i, j)</code> exist in the array such that the sum of the elements at these indices, <code>nums[i] + nums[j]</code>, falls between <code>lower</code> and <code>upper</code>. Plus, we need to make sure that <code>i</code> is less than <code>j</code>.</p>
<p>Given that the number of elements in the array can be as large as <span class="math inline">\(10^5\)</span>, we need to think about an efficient solution—something that works in linear or log-linear time.</p>
<p>If you're feeling stuck, it might help to look at <a href="https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/description/">this similar problem</a> before diving deeper.</p>
<p>Since we’re dealing with specific lower and upper bounds, it’s natural to think about using binary search. However, for binary search to be effective, we need to sort the array first. You might wonder if sorting will mess up our index requirements. The good news is that it won’t! Sorting the array allows us to find pairs easily because the order of addition doesn’t change the sum; that is, <code>nums[i] + nums[j]</code> is the same as <code>nums[j] + nums[i]</code>.</p>
<p>So, our goal is to count unique pairs where <code>i</code> is not equal to <code>j</code> while ensuring their sums fall within the specified range.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with binary search, please refer to our explore cards <a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>
</blockquote>
<p>We can iterate through the sorted array while keeping one element of the pair fixed. For each fixed element, we'll find out how many valid choices we have for the second element. Because the array is sorted, the first valid choice will give us a sum that is just greater than or equal to <code>lower</code>, and the last valid choice will yield a sum that is just less than or equal to <code>upper</code>. Since the sums increase steadily, all valid second elements will cluster together in the array.</p>
<p>To count the number of pairs with sums that fall within the range <code>[lower, upper]</code>, we can use a clever technique. First, we calculate how many pairs have sums that are less than <code>lower</code>. Then, we count how many pairs have sums that are less than <code>upper + 1</code>. By taking the difference between these two counts, we can easily determine how many pairs have sums within the desired range.</p>
<p>Now, how do we find the number of pairs for the lower limit using binary search? After fixing the first element <code>nums[i]</code>, the second element must be less than <code>lower - nums[i]</code> to keep the sum below <code>lower</code>. We can efficiently find how many elements meet this condition by performing a binary search in the array for values less than or equal to <code>lower - nums[i]</code>.</p>
<p>Similarly, we can find the number of elements that are less than or equal to <code>upper + 1 - nums[i]</code>. The difference between these two counts will give us the total number of valid pairs for that particular fixed element.</p>
<h4 id="algorithm">Algorithm</h4>
<blockquote>
<p>Note: The typical way to calculate the midpoint is <code>(left + right) / 2</code>. However, a safer approach is to use <code>left + (right - left) / 2</code>. While both formulas yield the same result, the second method is safer because it prevents overflow by ensuring that no value larger than <code>right</code> is stored. In contrast, the first method can lead to overflow if <code>left</code> and <code>right</code> are very large.</p>
</blockquote>
<p>Function - <code>lower_bound(nums, low, high, element)</code>:</p>
<ol>
<li>Initialize a loop that continues as long as <code>low</code> is less than or equal to <code>high</code>:
<ul>
<li>Calculate the middle index <code>mid</code> using the formula <code>low + (high - low) / 2</code>.</li>
<li>If <code>nums[mid]</code> is greater than or equal to <code>element</code>, adjust the <code>high</code> index to <code>mid - 1</code>.</li>
<li>Otherwise, adjust the <code>low</code> index to <code>mid + 1</code>.</li>
</ul>
</li>
<li>Return the <code>low</code> index after the loop ends, which represents the lower bound position.</li>
</ol>
<p>Main Function - <code>countFairPairs(nums, lower, upper)</code>:</p>
<ol>
<li>Sort the array <code>nums</code>.</li>
<li>Initialize a variable <code>ans</code> to 0, which will hold the count of valid pairs.</li>
<li>Iterate through each element in the sorted array using index <code>i</code>:
<ul>
<li>For each element <code>nums[i]</code>, determine the number of possible pairs with a sum less than <code>lower</code>:
<ul>
<li>Use <code>lower_bound</code> to find the index of the first element in the subarray <code>nums[i + 1]</code> to <code>nums[end]</code> that is greater than or equal to <code>lower - nums[i]</code>.</li>
</ul>
</li>
<li>Similarly, determine the number of possible pairs with a sum less than or equal to <code>upper</code>:
<ul>
<li>Use <code>lower_bound</code> to find the index of the first element in the subarray that is greater than or equal to <code>upper - nums[i] + 1</code>.</li>
</ul>
</li>
<li>The difference <code>high - low</code> gives the count of valid pairs with sums within the range <code>[lower, upper]</code> for the current element.</li>
<li>Update <code>ans</code> by adding the difference calculated.</li>
</ul>
</li>
<li>After iterating through all elements, return the value of <code>ans</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/PtF5DvjT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Sorting the <code>nums</code> array takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The loop iterates through each element of the sorted array and calls the <code>lower_bound</code> function twice, which itself takes <span class="math inline">\(O(logn)\)</span> time. Therefore, the overall time complexity for processing all <code>n</code> elements is <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Combining these, the total time complexity is: <span class="math inline">\(O(n \log n + n \log n)\)</span> = <span class="math inline">\(O(n \log n)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
</li>
</ul>
<blockquote>
<p>In this problem, we’re assuming it’s okay to sort the input to solve it. But in real-world scenarios, that might not always be the best approach. Sorting can change the original order of the input, which might be important in some cases where we have to use it later.</p>
</blockquote>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous solution, we noticed that when selecting the second element of our pair, it’s important to consider only those that are consecutive to the first element. This creates a “window” of valid choices. Specifically, this window starts from the index right after our chosen first element (which we can call <code>current index + 1</code>). We ignore elements before this index because they would lead to redundant pairs.</p>
<p>As we move to the next element in the array, we adjust this window. Since the new first element we’re considering is larger but we want the same target sum, the second element must now be smaller. This means we gradually shift the end of our window backward to focus on smaller values in the array.</p>
<p>To visualize this, we can use two pointers: <code>left</code> for the current element and <code>right</code> for the end of our window. The size of the window can be calculated with the formula <code>right - (left + 1) + 1</code>, which simplifies to <code>right - left</code>. As we progress through the array, we keep moving the <code>right</code> pointer back until we find that the sum of <code>nums[left] + nums[right]</code> is just below our target sum. For each index, we then add the size of this window to our result.</p>
<p>The difference between these two counts will give us the number of pairs that fall within our desired range.</p>
<h4 id="algorithm-1">Algorithm</h4>
<p>Function - <code>lower_bound(nums, value)</code>:</p>
<ol>
<li>Initialize two pointers, <code>left</code> to 0 and <code>right</code> to the last index of <code>nums</code>.</li>
<li>Initialize a variable <code>result</code> to 0.</li>
<li>While <code>left</code> is less than <code>right</code>:
<ul>
<li>Calculate the sum of <code>nums[left]</code> and <code>nums[right]</code>.</li>
<li>If the sum is less than <code>value</code>:
<ul>
<li>Add the number of valid pairs <code>(right - left)</code> to <code>result</code>.</li>
<li>Increment <code>left</code> to consider the next element.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Decrement <code>right</code> to reduce the sum.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>result</code>.</li>
</ol>
<p>Main Function - <code>countFairPairs(nums, lower, upper)</code>:</p>
<ol>
<li>Sort the array <code>nums</code>.</li>
<li>Return the difference between the result of <code>lower_bound(nums, upper + 1)</code> and <code>lower_bound(nums, lower)</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/iidN9v9x/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given <code>nums</code> array.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>Sorting the <code>nums</code> array takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The method lower_bound is called twice, but its complexity is <span class="math inline">\(O(n)\)</span> because it iterates through the entire array to count the valid pairs.</p>
<p>Thus, the overall time complexity is dominated by the sorting step, resulting in <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
<p>The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and  Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n )\)</span> for sorting two arrays.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n )\)</span>.</li>
</ul>
<p>Therefore, the space complexity is given by <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-33">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description" target="_blank" rel="noopener noreferrer">Count the Number of Incremovable Subarrays I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>A subarray of <code>nums</code> is called <strong>incremovable</strong> if <code>nums</code> becomes <strong>strictly increasing</strong> on removing the subarray. For example, the subarray <code>[3, 4]</code> is an incremovable subarray of <code>[5, 3, 4, 6, 7]</code> because removing this subarray changes the array <code>[5, 3, 4, 6, 7]</code> to <code>[5, 6, 7]</code> which is strictly increasing.</p>

<p>Return <em>the total number of <strong>incremovable</strong> subarrays of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that an empty array is considered strictly increasing.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,7,8]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
It can be shown that there are only 7 incremovable subarrays in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,7,6,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-34">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/count-the-number-of-incremovable-subarrays-ii/description" target="_blank" rel="noopener noreferrer">Count the Number of Incremovable Subarrays II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> array of <strong>positive</strong> integers <code>nums</code>.</p>

<p>A subarray of <code>nums</code> is called <strong>incremovable</strong> if <code>nums</code> becomes <strong>strictly increasing</strong> on removing the subarray. For example, the subarray <code>[3, 4]</code> is an incremovable subarray of <code>[5, 3, 4, 6, 7]</code> because removing this subarray changes the array <code>[5, 3, 4, 6, 7]</code> to <code>[5, 6, 7]</code> which is strictly increasing.</p>

<p>Return <em>the total number of <strong>incremovable</strong> subarrays of</em> <code>nums</code>.</p>

<p><strong>Note</strong> that an empty array is considered strictly increasing.</p>

<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The 10 incremovable subarrays are: [1], [2], [3], [4], [1,2], [2,3], [3,4], [1,2,3], [2,3,4], and [1,2,3,4], because on removing any one of these subarrays nums becomes strictly increasing. Note that you cannot select an empty subarray.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,5,7,8]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The 7 incremovable subarrays are: [5], [6], [5,7], [6,5], [5,7,8], [6,5,7] and [6,5,7,8].
It can be shown that there are only 7 incremovable subarrays in nums.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [8,7,6,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The 3 incremovable subarrays are: [8,7,6], [7,6,6], and [8,7,6,6]. Note that [8,7] is not an incremovable subarray because after removing [8,7] nums becomes [6,6], which is sorted in ascending order but not strictly increasing.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-35">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-the-triplets4615/1" target="_blank" rel="noopener noreferrer">Count the triplets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><div>
<p class="" data-start="440" data-end="526"><span style="font-size: 14pt;">Given an array <code data-start="455" data-end="460">arr</code>, count the number of <strong data-start="482" data-end="503">distinct triplets</strong> (a, b, c) such that:</span></p>
<ul data-start="531" data-end="766">
<li class="" data-start="531" data-end="544">
<p class="" data-start="533" data-end="544"><span style="font-size: 14pt;">a + b = c</span></p>
</li>
<li class="" data-start="547" data-end="627">
<p class="" data-start="549" data-end="627"><span style="font-size: 14pt;">Each triplet is counted <strong data-start="573" data-end="586">only once</strong>, regardless of the order of <code data-start="615" data-end="618">a</code> and <code data-start="623" data-end="626">b</code>.</span></p>
</li>
</ul>
</div>
<p><span style="font-size: 14pt;"><strong>Examples:</strong> </span></p>
<pre><span style="font-size: 14pt;"><strong>Input:</strong> arr[] = [1, 5, 3, 2]
<strong>Output:</strong> 2 
<strong>Explanation</strong>: There are 2 triplets: 1 + 2 = 3 and 3 +2 = 5</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [2, 3, 4]
<strong>Output:</strong> 0
<strong>Explanation</strong>: No such triplet exits</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>3</sup><br />1 &le; arr[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-36">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/create-maximum-number/description" target="_blank" rel="noopener noreferrer">Create Maximum Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>

<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>

<p>Return an array of the <code>k</code> digits representing the answer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5
<strong>Output:</strong> [9,8,6,5,3]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5
<strong>Output:</strong> [6,7,6,0,4]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3
<strong>Output:</strong> [9,8,9]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == nums1.length</code></li>
	<li><code>n == nums2.length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>
	<li><code>1 &lt;= k &lt;= m + n</code></li>
	<li><code>nums1</code> and <code>nums2</code> do not have leading zeros.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-37">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/delete-the-middle-node-of-a-linked-list/description" target="_blank" rel="noopener noreferrer">Delete the Middle Node of a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list. <strong>Delete</strong> the <strong>middle node</strong>, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>

<p>The <strong>middle node</strong> of a linked list of size <code>n</code> is the <code>&lfloor;n / 2&rfloor;<sup>th</sup></code> node from the <b>start</b> using <strong>0-based indexing</strong>, where <code>&lfloor;x&rfloor;</code> denotes the largest integer less than or equal to <code>x</code>.</p>

<ul>
	<li>For <code>n</code> = <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>, the middle nodes are <code>0</code>, <code>1</code>, <code>1</code>, <code>2</code>, and <code>2</code>, respectively.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png" style="width: 500px; height: 77px;" />
<pre>
<strong>Input:</strong> head = [1,3,4,7,1,2,6]
<strong>Output:</strong> [1,3,4,1,2,6]
<strong>Explanation:</strong>
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png" style="width: 250px; height: 43px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,2,4]
<strong>Explanation:</strong>
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png" style="width: 150px; height: 58px;" />
<pre>
<strong>Input:</strong> head = [2,1]
<strong>Output:</strong> [2]
<strong>Explanation:</strong>
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-38">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/di-string-match/description" target="_blank" rel="noopener noreferrer">DI String Match</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A permutation <code>perm</code> of <code>n + 1</code> integers of all the integers in the range <code>[0, n]</code> can be represented as a string <code>s</code> of length <code>n</code> where:</p>

<ul>
	<li><code>s[i] == &#39;I&#39;</code> if <code>perm[i] &lt; perm[i + 1]</code>, and</li>
	<li><code>s[i] == &#39;D&#39;</code> if <code>perm[i] &gt; perm[i + 1]</code>.</li>
</ul>

<p>Given a string <code>s</code>, reconstruct the permutation <code>perm</code> and return it. If there are multiple valid permutations perm, return <strong>any of them</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "IDID"
<strong>Output:</strong> [0,4,1,3,2]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "III"
<strong>Output:</strong> [0,1,2,3]
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> s = "DDI"
<strong>Output:</strong> [3,2,0,1]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;I&#39;</code> or <code>&#39;D&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-ad-hoc">Approach 1: Ad-Hoc</h3>
<h4 id="intuition">Intuition</h4>
<p>If we see <code>S[0] == 'I'</code>, we can always put <code>0</code> as the first element; similarly, if we see <code>S[0] == 'D'</code>, we can always put <code>N</code> as the first element.</p>
<p>Say we have a match for the rest of the string <code>S[1], S[2], ...</code> using <code>N</code> distinct elements.  Notice it doesn't matter what the elements are, only that they are distinct and totally ordered.  Then, putting <code>0</code> or <code>N</code> at the first character will match, and the rest of the elements (<code>1, 2, ..., N</code> or <code>0, 1, ..., N-1</code>) can use the matching we have.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Keep track of the smallest and largest element we haven't placed.  If we see an <code>'I'</code>, place the small element; otherwise place the large element.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/H555URr8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>S</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(1)\)</span>, we don't count the answer as part of the space complexity.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-39">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/description" target="_blank" rel="noopener noreferrer">Divide Intervals Into Minimum Number of Groups</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>intervals</code> where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> represents the <strong>inclusive</strong> interval <code>[left<sub>i</sub>, right<sub>i</sub>]</code>.</p>

<p>You have to divide the intervals into one or more <strong>groups</strong> such that each interval is in <strong>exactly</strong> one group, and no two intervals that are in the same group <strong>intersect</strong> each other.</p>

<p>Return <em>the <strong>minimum</strong> number of groups you need to make</em>.</p>

<p>Two intervals <strong>intersect</strong> if there is at least one common number between them. For example, the intervals <code>[1, 5]</code> and <code>[5, 8]</code> intersect.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can divide the intervals into the following groups:
- Group 1: [1, 5], [6, 8].
- Group 2: [2, 3], [5, 10].
- Group 3: [1, 10].
It can be proven that it is not possible to divide the intervals into fewer than 3 groups.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,3],[5,6],[8,10],[11,13]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> None of the intervals overlap, so we can put all of them in one group.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>
	<li><code>intervals[i].length == 2</code></li>
	<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting-or-priority-queue">Approach 1: Sorting or Priority Queue</h3>
<h4 id="intuition">Intuition</h4>
<p>The problem is very similar to  <a href="https://leetcode.com/problems/meeting-rooms-ii/solution/">Meeting Rooms II</a>, and thus the solutions are alike. The problem provides <span class="math inline">\(N\)</span> intervals in the form <code>[start, end]</code>, where both start and end are inclusive. Our goal is to divide the intervals into multiple groups such that each interval belongs to exactly one group and no intervals within the same group overlap. We need to minimize the number of groups created.</p>
<p>Intervals that share a common number must be placed in different groups. For example, given the intervals <code>[3, 7], [5, 6], and [1, 8]</code>, all of these intervals overlap between <code>5</code> and <code>6</code>. Therefore, they must be placed in separate groups. In this case, we would need three groups to ensure no two intervals in the same group overlap.</p>
<p>We can generalize this by stating that if there are <span class="math inline">\(K\)</span> overlapping intervals, we need at least <span class="math inline">\(K\)</span> groups to separate them. Some intervals may not overlap with one or more intervals within the <span class="math inline">\(K\)</span> overlapping ones, and they can be placed into any group where there is no conflict. For example, consider adding two more intervals, <code>[10, 12]</code> and <code>[2, 3]</code>, to the previous set. Despite having five intervals now, we still need only three groups. A valid grouping could be:</p>
<ul>
<li>Group 1: <code>[1, 8], [10, 12]</code></li>
<li>Group 2: <code>[3, 7]</code></li>
<li>Group 3: <code>[5, 6], [2, 3]</code></li>
</ul>
<p>The core of the problem is determining the maximum number of overlapping intervals at any given point. These overlapping intervals define the minimum number of groups required. Once we find the number of intervals that overlap at the same point, we can allocate non-overlapping intervals into existing groups.</p>
<p>To find the maximum number of overlapping intervals, we need to determine how many intervals cover each point in the range. For each interval <code>[start, end]</code>, all numbers between start and end (inclusive) belong to that interval. Then by iterating over each number, we can find out the maximum number of intervals any number has. An interval <code>[start, end]</code> represents that there is an interval for each number between <code>start</code> and <code>end</code> inclusive. Similar to the <a href="https://leetcode.com/problems/meeting-rooms-ii/solution/">Meeting Rooms II</a> solution, we will need to find the number of intervals at each number using the prefix sum. We will mark <code>1</code> at each <code>start</code> point denoting that an interval starts here and mark <code>-1</code> at each of the <code>end + 1</code> points denoting that an interval ends here (as <code>end</code> is inclusive).</p>
<p>To do this efficiently, we can use either a priority queue or a list with sorting. This approach uses the second one where we will create two events for each interval as <code>{start, 1}</code> and <code>{end + 1, -1}</code>  denoting the start and end of an interval. We can then sort this list in ascending order of the point and then by the value. The prefix sum of this list will provide the number of overlapping intervals in each point and we can also track the maximum sum we have achieved so far. This maximum sum can be returned as the minimum number of groups required.</p>
<p><img src="../Figures/2406/2406A.png" alt="fig" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Convert Intervals to Events:
<ul>
<li>For each interval <code>[start, end]</code>, create two events:
<ul>
<li>A start event at <code>start</code> with a value of <code>+1</code> (indicating an interval is starting).</li>
<li>An end event at <code>end + 1</code> with a value of <code>-1</code> (indicating an interval is ending just after right).</li>
</ul>
</li>
</ul>
</li>
<li>Sort Events:
<ul>
<li>Sort the events based on the time (first element of the pair).</li>
<li>If two events occur at the same time, process them in the order of their values (+1 first, -1 second). This ensures correct overlap counting.</li>
</ul>
</li>
<li>Find the prefix sum:
<ul>
<li>Initialize <code>concurrentIntervals</code> to 0. This will track the number of intervals active at any point in time.</li>
<li>Traverse the sorted events:
<ul>
<li>For each event, update <code>concurrentIntervals</code> by adding the value of the event (+1 for start, -1 for end).</li>
<li>Track the maximum value of <code>concurrentIntervals</code> as <code>maxConcurrentIntervals</code> which represents the maximum number of overlapping intervals.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxConcurrentIntervals</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/8Qwp7cnE/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>We create two events for each interval, hence the number of events is <span class="math inline">\(2 *N\)</span>. Then we sort these events, which will take <span class="math inline">\(O(N \log N)\)</span>. To find the prefix sum, we iterated over each event to find the maximum sum. Hence, the total time complexity is <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will store the <code>start</code> and <code>end</code> numbers along with an integer to denote the start or end of an interval. For <span class="math inline">\(N\)</span> intervals there will be <span class="math inline">\(2* N\)</span> events. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-line-sweep-algorithm-with-ordered-container">Approach 2: Line Sweep Algorithm With Ordered Container</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This approach is similar to the previous one but uses a method called the Line Sweep algorithm. It's useful for solving problems involving intervals.</p>
<p>The Line Sweep algorithm tracks when intervals start and end. For each interval <code>(start, end)</code>, we mark the start by increasing the count at <code>start</code> by <code>1</code> (indicating a new interval starts), and we mark the point <code>end + 1</code> by decreasing its count by <code>1</code> (indicating an interval ends). These changes are stored in a map, which keeps track of how many intervals start or end at each point.</p>
<p>After processing all the intervals, we calculate a running total (prefix sum) over the map. This running total shows how many intervals are active at any given point. The highest value of this total tells us the minimum number of groups needed to avoid overlap.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an ordered map (<code>pointToCount</code>) to track the count of intervals starting or ending at a point.</li>
<li>Populate the map:
<ul>
<li>For each interval <code>[start, end]</code>, increment <code>pointToCount[start]</code> by <code>1</code>.</li>
<li>Decrement <code>pointToCount[end + 1]</code> by <code>1</code>.</li>
</ul>
</li>
<li>Iterate over the sorted entries of the map (automatically sorted by key).
<ul>
<li>Traverse the sorted map, and add the value to <code>concurrentIntervals</code>.</li>
<li>Track the maximum number of overlapping intervals in <code>maxConcurrentIntervals</code>.</li>
</ul>
</li>
<li>Return <code>maxConcurrentIntervals</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/h5VK4QoK/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>We insert the intervals into an ordered map in which insertion takes <span class="math inline">\(O(\log N)\)</span> time, and hence for <span class="math inline">\(N\)</span> insertion the time required would be <span class="math inline">\(O(N \log N)\)</span>. Then we iterate over the <span class="math inline">\(2* N\)</span> entries in the map and find the value for <code>maxConcurrentIntervals</code>. Therefore the total time complexity is equal to  <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We will store the <code>start</code> and <code>end</code> numbers along with an integer to denote the start or end of an interval in the map. For <span class="math inline">\(N\)</span> intervals there will be <span class="math inline">\(2* N\)</span> events. Hence the total space complexity is equal to <span class="math inline">\(O(N)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-line-sweep-algorithm-without-ordered-container">Approach 3: Line Sweep Algorithm Without Ordered Container</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The core idea of this approach is the same as the previous one. However, instead of using an ordered map to keep track of interval start and end points, we employ a list or vector to store the counts of intervals starting or ending at each point. Once all intervals have been processed, we avoid sorting the list as done in the earlier approach. Instead, we apply a counting sort technique to efficiently compute the prefix sum.</p>
<p>First, we determine the smallest starting point (<code>rangeStart</code>) and the largest ending point (<code>rangeEnd</code>) across all intervals. These values define the range for our counting sort. We then iterate from <code>rangeStart</code> to <code>rangeEnd</code>, updating the list by adding interval counts, similar to the previous approach, while keeping track of the maximum number of overlapping intervals at any point in the variable <code>maxConcurrentIntervals</code>.</p>
<p>This approach offers a potential advantage over the previous method, particularly in cases where the number of intervals is large but the range of those intervals is relatively small. The time complexity of this approach depends on the interval range rather than the number of intervals, making it more efficient when the value range of the intervals is limited.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Iterate through the intervals to determine the minimum (<code>rangeStart</code>) and maximum (<code>rangeEnd</code>) points.</li>
<li>Create an array <code>pointToCount</code> of size <code>rangeEnd + 2</code> initialized to zero.</li>
<li>Iterate over the intervals:
<ul>
<li>For each interval <code>[start, end]</code>, increment <code>pointToCount[start</code>] to indicate the start of an interval.</li>
<li>Decrement <code>pointToCount[end + 1]</code> to mark the point where the interval ends.</li>
</ul>
</li>
<li>Loop from <code>rangeStart</code> to <code>rangeEnd</code> and maintain a running sum <code>concurrentIntervals</code> of active intervals. Track the maximum number of concurrent intervals as <code>maxConcurrentIntervals</code></li>
<li>Return <code>maxConcurrentIntervals</code></li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/N9ZPeQo4/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N\)</span> is the number of intervals, and <span class="math inline">\(K\)</span> are the numbers between <code>rangeStart</code> and <code>rangeEnd</code></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N + K)\)</span></p>
<p>We iterate over the <span class="math inline">\(N\)</span> intervals to find the value of <code>rangeStart</code> and <code>rangeEnd</code>. We again iterated over the intervals to mark the points in the list <code>pointToCount</code>. Then we iterate over the <span class="math inline">\(K\)</span> numbers between <code>rangeStart</code> and <code>rangeEnd</code> to find the <code>maxConcurrentIntervals</code>. Hence the total time complexity is equal to <span class="math inline">\(O(N + K)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(K)\)</span></p>
<p>The size of the array <code>pointToCount</code> is <span class="math inline">\(O(K)\)</span> which is the only space requirement. Hence the space complexity is equal to <span class="math inline">\(O(K)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-40">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/divide-players-into-teams-of-equal-skill/description" target="_blank" rel="noopener noreferrer">Divide Players Into Teams of Equal Skill</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a positive integer array <code>skill</code> of <strong>even</strong> length <code>n</code> where <code>skill[i]</code> denotes the skill of the <code>i<sup>th</sup></code> player. Divide the players into <code>n / 2</code> teams of size <code>2</code> such that the total skill of each team is <strong>equal</strong>.</p>

<p>The <strong>chemistry</strong> of a team is equal to the <strong>product</strong> of the skills of the players on that team.</p>

<p>Return <em>the sum of the <strong>chemistry</strong> of all the teams, or return </em><code>-1</code><em> if there is no way to divide the players into teams such that the total skill of each team is equal.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> skill = [3,2,5,1,3,4]
<strong>Output:</strong> 22
<strong>Explanation:</strong> 
Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> skill = [3,4]
<strong>Output:</strong> 12
<strong>Explanation:</strong> 
The two players form a team with a total skill of 7.
The chemistry of the team is 3 * 4 = 12.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> skill = [1,1,2,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
There is no way to divide the players into teams such that the total skill of each team is equal.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= skill.length &lt;= 10<sup>5</sup></code></li>
	<li><code>skill.length</code> is even.</li>
	<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting">Approach 1: Sorting</h3>
<h4 id="intuition">Intuition</h4>
<p>We have a <code>skill</code> array, and we need to form teams of two players, ensuring each team has the same combined skill level.</p>
<p>First, we calculate the target skill level for each team. Since all teams should have equal skill and there are <code>n/2</code> teams (where <code>n</code> is the length of the <code>skill</code> array), we find the target by dividing the total of all skills by the number of teams.</p>
<p>With the target skill level set, our goal is to identify pairs of players whose skills add up to this target. A brute force method, where we test each player against every other player, would take too long and may not meet our constraints.</p>
<p>To improve efficiency, we should pair players with the lowest skills with those who have the highest skills. This approach helps us reach the target skill level, as the target is essentially the median of all skills. By matching the lowest-skilled player with the highest-skilled player, we increase the chance of achieving the target. The second-lowest skilled player should pair with the second-highest, and this pattern continues.</p>
<details>
  <summary>A formal proof using the method of contradiction</summary>
<p>Claim: To balance each team with the required skill, we should pair the unmatched player of the lowest skill (<span class="math inline">\(L\)</span>) with the unmatched player of the highest skill (<span class="math inline">\(H\)</span>).</p>
<p>Proof by Contradiction:</p>
<p>Assume the claim is false. This means there exists a valid solution where <span class="math inline">\(L\)</span> is not paired with <span class="math inline">\(H\)</span>, but instead:</p>
<ol>
<li><span class="math inline">\(L\)</span> is paired with some player <span class="math inline">\(X\)</span></li>
<li><span class="math inline">\(H\)</span> is paired with some player <span class="math inline">\(Y\)</span>,<br />
where <span class="math inline">\(X \neq H\)</span> and <span class="math inline">\(Y \neq L\)</span></li>
</ol>
<p>Let S be the required sum of skills for each team. Given that this is a valid solution:</p>
<p><span class="math display">\[
$$H + Y = S \space\space\space \ldots (2)$$

Since $H$ is the highest unmatched skill and $L$ is the lowest unmatched skill, we know:

$$L \leq Y < X \leq H$$

From Equation 1: $X = S - L$

From Equation 2: $Y = S - H$

Since $X \leq H$, we can substitute this into Equation 1:

$$L + H \geq S  \space\space\space \ldots (3)$$

Since $Y \geq L$, we can substitute this into Equation 2:

$$H + L \leq S \space\space\space \ldots  (4)$$

From Equations 3 and 4, we can conclude:

$$L + H = S$$

This means that to produce a team with the required skill sum $S$, we need to pair $L$ with $H$.
However, this contradicts our initial assumption that there exists a valid solution where $L$ is not paired with $H$.

Therefore, our initial assumption must be false, and the claim must be true.
</details>
<br>

To match players efficiently, we start by sorting the `skill` array. Next, we iterate through the array, pairing the `i`th player from the start with the `i`th player from the end to form teams. If the cumulative skill of any team does not equal the target skill, we determine that equal division is impossible and return -1. If all teams meet the target, we calculate each team's chemistry by multiplying the skill levels of its players. The final answer is the sum of all team chemistries.

The algorithm is visualized below:

![sorting demonstration](../Figures/2491/sorted.png)

#### Algorithm

- Sort the input array `skill` in ascending order.
- Initialize:
  - a variable `n` to the length of the `skill` array.
  - a variable `totalChemistry` to 0, which will store the sum of all team chemistries.
- Calculate the `targetTeamSkill` by adding the first and last elements of the sorted array.
- Iterate through the first half of the array:
  - Calculate `currentTeamSkill` by adding the `i`-th element from the start and the `i`-th element from the end.
  - If `currentTeamSkill` doesn't match `targetTeamSkill`, return -1.
  - Calculate the chemistry of the current team by multiplying the skills of the two team members.
  - Add the calculated chemistry to `totalChemistry`.
- Return `totalChemistry` as the answer.

#### Implementation

[code](https://leetcode.com/playground/M2QSzxER/shared)

#### Complexity Analysis

Let $n$ be the length of the input array `skill`. 

- Time complexity: $(n \cdot \log n)$

    Sorting the array takes $O(n \cdot \log n)$ time. The algorithm iterates through half of the array, which takes $O(n/2) = O(n)$ time. All operations within the loop are constant time operations. 

    Thus, the overall time complexity of the algorithm is $O(n \cdot \log n) + O(n) = (n \cdot \log n)$.

- Space complexity: $O(S)$

    The only additional space used is for the sorting algorithm. The space taken by the sorting algorithm ($S$) depends on the language of implementation:
    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \log n)$.
    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\log n)$.
    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.

---

### Approach 2: Frequency Table

#### Intuition

We know the target team skill before pairing players. Let’s call this target skill `s`. When matching a player with skill `x`, we need to find another player with skill `s - x`.

One way to implement this is by looping through the `skill` array for each player to find their matching skill. However, this approach won't meet the problem's constraints. We need an efficient method to check if a player with a specific skill exists.

A frequency table works well here because it allows constant-time lookups. This table stores key-value pairs, where the key represents the skill value, and the value indicates how many players have that skill. While hash maps are common for frequency tables, we will use an array in this case due to the limited skill range (1000).

In our table, the index serves as the key (the skill value), and the value is the frequency from the `skill` array. We will iterate through the `skill` array and check for each skill's complement in the table. If we don’t find a complement, we conclude that forming a valid team is impossible and return -1. If we do find a complement, we calculate and accumulate the chemistry for each team. The total chemistry gives us the answer.

#### Algorithm

- Initialize:
  - a variable `n` to the length of the input array `skill`.
  - a variable `totalSkill` to 0.
- Create an array `skillFrequency` of size 1001 to store the frequency of each skill level.
- Iterate through the `skill` array:
  - Add each player's skill to `totalSkill`.
  - Increment the count for each skill level in `skillFrequency`.
- Check if `totalSkill` is evenly divisible by `n/2`. If not, return -1.
- Calculate `targetTeamSkill` by dividing `totalSkill` by `n/2`.
- Initialize `totalChemistry` to 0.
- Iterate through the `skill` array again:
  - Set `partnerSkill` as `targetTeamSkill` minus the current skill.
  - If no player with `partnerSkill` exists (frequency is 0), return -1.
  - Add the product of the current skill and `partnerSkill` to `totalChemistry`.
  - Decrement the frequency of `partnerSkill`.
- Return half of `totalChemistry` (as each pair was counted twice).

#### Implementation

[code](https://leetcode.com/playground/ZYMxucQg/shared)

#### Complexity Analysis

Let $n$ be the length of the input array `skill`. 

* Time complexity: $O(n)$

    The algorithm performs two passes through the array, each taking $O(n)$ time. All operations within these loops are constant time. Thus, the time complexity of the algorithm is $O(n)$.

* Space complexity: $O(1)$

    The most significant additional space used is the `skillFrequency` array. This array has a fixed size of $1001$, regardless of the input size, as it's based on the constraint that each player's skill is between $1$ and $1000$. The other variables used occupy constant space.

    Since the extra space used doesn't grow with the input size, the space complexity is constant, $O(1)$.

---

### Approach 3: Map

#### Intuition

While iterating through the `skill` array, we often encounter duplicate pairs. For example, if the target value is 8 and we have two 3's and two 5's, the algorithm would consider each 3 separately to pair with each 5. We can improve this method.

The hash map already counts all skill values. Instead of pairing each skill separately, we can match them all at once. We will look at each key (skill value) in the map. For each key, we check if its complementary skill value is in the map and if their counts are equal. If the counts are not equal, the skill with the higher count will remain unmatched. If either condition fails, we cannot form the required pairs, and we return -1.

If both conditions are met, we can calculate the combined chemistry for all pairs at once. We add up these chemistry values as we go through the map and return the total as our answer.

#### Algorithm

- Initialize:
  - a variable `n` to store the length of the `skill` array.
  - a variable `totalSkill` to 0 to accumulate the sum of all skills.
- Create a hash map `skillMap` to store the frequency of each skill value.
- Iterate through each skill value in `skill`:
  - Add the current skill to `totalSkill`.
  - Update the frequency of the current skill in `skillMap`.
- Check if `totalSkill` can be divided by `n/2`. If not, return -1.
- Calculate the `targetSkill` by dividing `totalSkill` by half the number of players.
- Initialize a variable `totalChemistry` to 0 to accumulate the sum of team chemistry.
- Iterate through each unique skill value in `skillMap`:
  - Get the frequency of the current skill as `currFreq`.
  - Calculate `partnerSkill` by subtracting the current skill from `targetSkill`.
  - Check if the frequency of `partnerSkill` matches `currFreq`:
    - If not, return -1 as it's impossible to form valid teams.
  - Calculate the chemistry for all pairs with this skill and add to `totalChemistry`.
- Return half of `totalChemistry` as the final result.

#### Implementation

[code](https://leetcode.com/playground/NJP2MA62/shared)

#### Complexity Analysis

Let $n$ be the length of the input array `skill`. 

* Time complexity: $O(n)$

    The algorithm begins by iterating through the `skill` array to populate the frequency map, an operation that takes linear time. It then proceeds to iterate over the keys in the map, which, in the worst-case scenario (where each skill is unique), also takes $O(n)$ time.

    Thus, the overall time complexity of the algorithm is $O(n)$.

* Space complexity: $O(n)$

    The only additional data structure used is the map, which can take $O(n)$ space in the worst case (every skill value is unique).

---\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-41">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/dominant-pairs/1" target="_blank" rel="noopener noreferrer">Dominant Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">You are given an array of integers of size <strong>n </strong>where n being <strong>even</strong>.. You have to calculate the number of <strong>dominate pairs (i,j)</strong>&nbsp;.&nbsp;Where a pair is called dominant if (&nbsp;<strong>0&lt;=i&lt;n/2, n/2&lt;=j&lt;n, arr[i]&gt;=5*arr[j] </strong>)&nbsp;these&nbsp;relation are&nbsp;fulfilled.</span>&nbsp;<span style="font-size:18px">&nbsp;For example&nbsp;&nbsp;in arr=[10,3,3,1] index i=0, j=3 form a dominating pair<strong><strong> </strong></strong></span></p>

<p><strong><strong><span style="font-size:18px"><strong>Note </strong>: <strong>0</strong> based </span></strong></strong><span style="font-size:18px">indexing is used&nbsp; and n is </span><strong><strong><span style="font-size:18px"><strong>even&nbsp;</strong></span></strong></strong></p>

<p><strong><strong><span style="font-size:18px">Example 1:</span></strong></strong></p>

<pre>
<strong><strong><span style="font-size:18px"><strong>Input:</strong>
</span></strong></strong><span style="font-size:18px">n=4
arr={10,2,2,1}</span><strong><strong><span style="font-size:18px">
<strong>Output:
</strong></span></strong></strong><span style="font-size:18px">2</span><strong><strong><span style="font-size:18px">
<strong>Explanation:</strong>
</span></strong></strong><span style="font-size:18px">As we can see index i=0 and j=2 where
arr[0]&gt;=5*arr[2] (10&gt;=5*2)is fulfilled so
this forms a dominant pair and in same
manner index i=0 and j=3 forms dominant
pair.So total 2 dominant pairs.</span></pre>

<p><strong><strong><span style="font-size:18px">Example 2:</span></strong></strong><strong><strong> </strong></strong></p>

<pre>
<strong><strong><span style="font-size:18px"><strong>Input:</strong>
</span></strong></strong><span style="font-size:18px">n=6
arr={10,8,2,1,1,2}</span><strong><strong><span style="font-size:18px">
<strong>Output:
</strong></span></strong></strong><span style="font-size:18px">5<strong><strong><span style="font-size:18px">
</span></strong></strong><strong>Explanation:</strong>
As we can see index i=0 and j=3 where
arr[0]&gt;=5*arr[3] (10&gt;=5*1) is fulfilled so
this forms a dominant pair and in same
manner (0,4),(0,5),(1,3),(1,4) also form
dominant pair.So total 5 dominant pairs.</span></pre>

<p><strong><strong><span style="font-size:18px"><strong>Your Task:</strong></span></strong></strong><br />
<span style="font-size:18px">You don&#39;t need to read input or print anything. Your task is to complete the function <strong>dominantPairs()</strong> which takes an <strong>integer n</strong> and <strong>an&nbsp;array</strong> of integers <strong>arr</strong>&nbsp;respectively and returns&nbsp;the <strong>count </strong>of dominate pairs.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(nlogn)<br />
<strong>Expected Auxiliary Space:</strong> O(1)</span><br />
<br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &lt;= <strong>n</strong>&lt;= 10^4<br />
-10^4&lt;=<strong>arr[i]</strong>&lt;= 10^4<br />
The sum of n over all test cases won&#39;t exceed 10^6</span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-42">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/duplicate-zeros/description" target="_blank" rel="noopener noreferrer">Duplicate Zeros</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a fixed-length integer array <code>arr</code>, duplicate each occurrence of zero, shifting the remaining elements to the right.</p>

<p><strong>Note</strong> that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,0,2,3,0,4,5,0]
<strong>Output:</strong> [1,0,0,2,3,0,0,4]
<strong>Explanation:</strong> After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> [1,2,3]
<strong>Explanation:</strong> After calling your function, the input array is modified to: [1,2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 9</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<p>The problem demands the array to be modified in-place. If <code>in-place</code> was not a constraint we might have just copied the elements from a source array to a destination array.</p>
<center>
<img src="../Figures/1089/1089_Duplicate_Zeros_1.png" width="600"/>
</center>
<br>
Notice, how we copied zero twice.
<pre><code>  s = 0
  d = 0

  # Copy is performed until the destination array is full.
  for s in range(N):
    if source[s] == 0:
      # Copy zero twice.
      destination[d] = 0
      d += 1
      destination[d] = 0
    else:
      destination[d] = source[s]

    d += 1
</code></pre>
<p>The problem statement also mentions that we do not grow the new array, rather we just trim it to its original array length. This means we have to discard some elements from the end of the array. These are the elements whose new indices are beyond the length of the original array.</p>
<center>
<img src="../Figures/1089/1089_Duplicate_Zeros_2.png" width="600"/>
</center>
<p>Let's remind ourselves about the problem constraint that we are given. Since we can't use extra space, our source and destination array is essentially the same. We just can't go about copying the source into destination array the same way. If we do that we would lose some elements. Since, we would be overwriting the array.</p>
<center>
<img src="../Figures/1089/1089_Duplicate_Zeros_3.png" width="600"/>
</center>
<p>Keeping this in mind, in the approach below we start copying to the end of the array.</p>
<h3 id="approach-1-two-pass-o1-space">Approach 1: Two pass, O(1) space</h3>
<p><strong>Intuition</strong></p>
<p>If we know the number of elements which would be discarded from the end of the array, we can copy the rest. How do we find out how many elements would be discarded in the end? The number would be equal to the number of extra zeros which would be added to the array. The extra zero would create space for itself by pushing out an element from the end of the array.</p>
<p>Once we know how many elements from the original array would be part of the final array, we can just start copying from the end. Copying from the end ensures we don't lose any element since, the last few extraneous elements can be overwritten.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Find the number of zeros which would be duplicated. Let's call it <code>possible_dups</code>. We do need to make sure we are not counting the zeros which would be trimmed off. Since, the discarded zeros won't be part of the final array. The count of <code>possible_dups</code> would give us the number of elements to be trimmed off the original array. Hence at any point, <code>length_ - possible_dups</code> is the number of elements which would be included in the final array.</p>
 <center>
 <img src="../Figures/1089/1089_Duplicate_Zeros_4.png" width="600"/>
 </center>
 <br>
 Note: In the diagram above we just show source and destination array for understanding purpose. We will be doing these operations only on one array.
</li>
<li>
<p>Handle the edge case for a zero present on the boundary of the leftover elements.</p>
<p>Let's talk about the edge case of this problem. We need to be extra careful when we are duplicating the zeros in the leftover array. This care should be taken for the <code>zero</code> which is lying on the boundary. Since, this zero might be counted as with possible duplicates, or may be just got included in the left over when there was no space left to accommodate its duplicate. If it is part of the <code>possible_dups</code> we would want to duplicate it otherwise we don't.</p>
<blockquote>
<p>An example of the edge case is - [8,4,5,0,0,0,0,7].<br />
In this array there is space to accommodate the duplicates of first and second occurrences of zero. But we don't have enough space for the duplicate of the third occurrence of zero.<br />
Hence when we are copying we need to make sure for the third occurrence we don't copy twice. Result = [8,4,5,0,<code>0</code>,0,<code>0</code>,0]</p>
</blockquote>
</li>
<li>
<p>Iterate the array from the end and copy a non-zero element once and zero element twice.<br />
When we say we discard the extraneous elements, it simply means we start from the left of the extraneous elements and start overwriting them with new values, eventually right shifting the left over elements and creating space for all the duplicated elements in the array.</p>
</li>
</ol>
<center>
<img src="../Figures/1089/1089_Duplicate_Zeros_5.png" width="500"/>
</center>
<br>
<p><a href="https://leetcode.com/playground/NxrFE4fw/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the number of elements in the array. We do two passes through the array, one to find the number of <code>possible_dups</code> and the other to copy the elements. In the worst case we might be iterating the entire array, when there are less or no zeros in the array.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span>. We do not use any extra space.</p>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-43">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/earliest-common-slot/1" target="_blank" rel="noopener noreferrer">Earliest Common Slot</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given two lists of availability time slots, <strong>slots1 and slots2</strong>, for two people. Each slot is represented as [start, end], and it is gurranted that within each list, no two slots overlap (i.e., for any two intervals, either <strong>start1&gt;end2 or start2&gt;end1</strong>). Given a metting duration <strong>d</strong>, return the earliest common time slot of length of least d. If no such slot exits, return an empty array.</span></p>
<p><strong><span style="font-size: 14pt;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>slots1 = [[10,50], [60,120], [140,210]], slots2 = [[0,15], [60,70]], d = 8
<strong>Output:</strong> [60,68]
<strong>Explanation:</strong> </span><span style="font-size: 14pt;">The only overlap is [60,70] (10 minutes), which is enough for an 8-minute meeting, so answer is [60,68]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>slots1 = [[10,50], [60,120], [140,210]], slots2 = [[0,15], [60,70]], d = 12<br /></span><span style="font-size: 18px;"><strong>Output:</strong> []<br /><strong>Explanation:</strong> </span><span style="font-size: 14pt;"><span style="font-size: 14pt;">The only overlap is [60, 70] (10 minutes), but 12 minutes are needed, so no valid slot exists.</span></span></pre>
<p><span style="font-size: 14pt;"><strong style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">Constraints:</strong><br style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: 18px; white-space: normal;" /><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">1 &le; slots1.size(), slots2.size()&nbsp; &le; 10<sup>5</sup></span><br style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: 18px; white-space: normal;" /><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">-10<sup>9</sup> &le; slots1[i], slots2[i] &le; 10<sup>9</sup><br /></span></span><span style="font-size: 14pt;"><span style="font-size: 18px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; white-space: normal;">1 &le; d &le; 10<sup>6</sup><br /></span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-44">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-finish-time-for-land-and-water-rides-i/description" target="_blank" rel="noopener noreferrer">Earliest Finish Time for Land and Water Rides I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="143" data-start="53">You are given two categories of theme park attractions: <strong data-end="122" data-start="108">land rides</strong> and <strong data-end="142" data-start="127">water rides</strong>.</p>

<ul>
	<li data-end="163" data-start="147"><strong data-end="161" data-start="147">Land rides</strong>

	<ul>
		<li data-end="245" data-start="168"><code data-end="186" data-start="168">landStartTime[i]</code> &ndash; the earliest time the <code>i<sup>th</sup></code> land ride can be boarded.</li>
		<li data-end="306" data-start="250"><code data-end="267" data-start="250">landDuration[i]</code> &ndash; how long the <code>i<sup>th</sup></code> land ride lasts.</li>
	</ul>
	</li>
	<li><strong data-end="325" data-start="310">Water rides</strong>
	<ul>
		<li><code data-end="351" data-start="332">waterStartTime[j]</code> &ndash; the earliest time the <code>j<sup>th</sup></code> water ride can be boarded.</li>
		<li><code data-end="434" data-start="416">waterDuration[j]</code> &ndash; how long the <code>j<sup>th</sup></code> water ride lasts.</li>
	</ul>
	</li>
</ul>

<p data-end="569" data-start="476">A tourist must experience <strong data-end="517" data-start="502">exactly one</strong> ride from <strong data-end="536" data-start="528">each</strong> category, in <strong data-end="566" data-start="550">either order</strong>.</p>

<ul>
	<li data-end="641" data-start="573">A ride may be started at its opening time or <strong data-end="638" data-start="618">any later moment</strong>.</li>
	<li data-end="715" data-start="644">If a ride is started at time <code data-end="676" data-start="673">t</code>, it finishes at time <code data-end="712" data-start="698">t + duration</code>.</li>
	<li data-end="834" data-start="718">Immediately after finishing one ride the tourist may board the other (if it is already open) or wait until it opens.</li>
</ul>

<p data-end="917" data-start="836">Return the <strong data-end="873" data-start="847">earliest possible time</strong> at which the tourist can finish both rides.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [2,8], landDuration = [4,1], waterStartTime = [6], waterDuration = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul>
	<li data-end="181" data-start="145">Plan A (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="272" data-start="186">Start land ride 0 at time <code data-end="234" data-start="212">landStartTime[0] = 2</code>. Finish at <code data-end="271" data-start="246">2 + landDuration[0] = 6</code>.</li>
		<li data-end="392" data-start="277">Water ride 0 opens at time <code data-end="327" data-start="304">waterStartTime[0] = 6</code>. Start immediately at <code data-end="353" data-start="350">6</code>, finish at <code data-end="391" data-start="365">6 + waterDuration[0] = 9</code>.</li>
	</ul>
	</li>
	<li data-end="432" data-start="396">Plan B (water ride 0 &rarr; land ride 1):
	<ul>
		<li data-end="526" data-start="437">Start water ride 0 at time <code data-end="487" data-start="464">waterStartTime[0] = 6</code>. Finish at <code data-end="525" data-start="499">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="632" data-start="531">Land ride 1 opens at <code data-end="574" data-start="552">landStartTime[1] = 8</code>. Start at time <code data-end="593" data-start="590">9</code>, finish at <code data-end="631" data-start="605">9 + landDuration[1] = 10</code>.</li>
	</ul>
	</li>
	<li data-end="672" data-start="636">Plan C (land ride 1 &rarr; water ride 0):
	<ul>
		<li data-end="763" data-start="677">Start land ride 1 at time <code data-end="725" data-start="703">landStartTime[1] = 8</code>. Finish at <code data-end="762" data-start="737">8 + landDuration[1] = 9</code>.</li>
		<li data-end="873" data-start="768">Water ride 0 opened at <code data-end="814" data-start="791">waterStartTime[0] = 6</code>. Start at time <code data-end="833" data-start="830">9</code>, finish at <code data-end="872" data-start="845">9 + waterDuration[0] = 12</code>.</li>
	</ul>
	</li>
	<li data-end="913" data-start="877">Plan D (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1007" data-start="918">Start water ride 0 at time <code data-end="968" data-start="945">waterStartTime[0] = 6</code>. Finish at <code data-end="1006" data-start="980">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="1114" data-start="1012">Land ride 0 opened at <code data-end="1056" data-start="1034">landStartTime[0] = 2</code>. Start at time <code data-end="1075" data-start="1072">9</code>, finish at <code data-end="1113" data-start="1087">9 + landDuration[0] = 13</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1161" data-is-last-node="" data-is-only-node="" data-start="1116">Plan A gives the earliest finish time of 9.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [5], landDuration = [3], waterStartTime = [1], waterDuration = [10]</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul data-end="1589" data-start="1086">
	<li data-end="1124" data-start="1088">Plan A (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1219" data-start="1129">Start water ride 0 at time <code data-end="1179" data-start="1156">waterStartTime[0] = 1</code>. Finish at <code data-end="1218" data-start="1191">1 + waterDuration[0] = 11</code>.</li>
		<li data-end="1338" data-start="1224">Land ride 0 opened at <code data-end="1268" data-start="1246">landStartTime[0] = 5</code>. Start immediately at <code data-end="1295" data-start="1291">11</code> and finish at <code data-end="1337" data-start="1310">11 + landDuration[0] = 14</code>.</li>
	</ul>
	</li>
	<li data-end="1378" data-start="1342">Plan B (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="1469" data-start="1383">Start land ride 0 at time <code data-end="1431" data-start="1409">landStartTime[0] = 5</code>. Finish at <code data-end="1468" data-start="1443">5 + landDuration[0] = 8</code>.</li>
		<li data-end="1589" data-start="1474">Water ride 0 opened at <code data-end="1520" data-start="1497">waterStartTime[0] = 1</code>. Start immediately at <code data-end="1546" data-start="1543">8</code> and finish at <code data-end="1588" data-start="1561">8 + waterDuration[0] = 18</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1640" data-is-last-node="" data-is-only-node="" data-start="1591">Plan A provides the earliest finish time of 14.<strong>​​​​​​​</strong></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="38" data-start="16"><code data-end="36" data-start="16">1 &lt;= n, m &lt;= 100</code></li>
	<li data-end="93" data-start="41"><code data-end="91" data-start="41">landStartTime.length == landDuration.length == n</code></li>
	<li data-end="150" data-start="96"><code data-end="148" data-start="96">waterStartTime.length == waterDuration.length == m</code></li>
	<li data-end="237" data-start="153"><code data-end="235" data-start="153">1 &lt;= landStartTime[i], landDuration[i], waterStartTime[j], waterDuration[j] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-45">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/earliest-finish-time-for-land-and-water-rides-ii/description" target="_blank" rel="noopener noreferrer">Earliest Finish Time for Land and Water Rides II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p data-end="143" data-start="53">You are given two categories of theme park attractions: <strong data-end="122" data-start="108">land rides</strong> and <strong data-end="142" data-start="127">water rides</strong>.</p>

<ul>
	<li data-end="163" data-start="147"><strong data-end="161" data-start="147">Land rides</strong>

	<ul>
		<li data-end="245" data-start="168"><code data-end="186" data-start="168">landStartTime[i]</code> &ndash; the earliest time the <code>i<sup>th</sup></code> land ride can be boarded.</li>
		<li data-end="306" data-start="250"><code data-end="267" data-start="250">landDuration[i]</code> &ndash; how long the <code>i<sup>th</sup></code> land ride lasts.</li>
	</ul>
	</li>
	<li><strong data-end="325" data-start="310">Water rides</strong>
	<ul>
		<li><code data-end="351" data-start="332">waterStartTime[j]</code> &ndash; the earliest time the <code>j<sup>th</sup></code> water ride can be boarded.</li>
		<li><code data-end="434" data-start="416">waterDuration[j]</code> &ndash; how long the <code>j<sup>th</sup></code> water ride lasts.</li>
	</ul>
	</li>
</ul>

<p data-end="569" data-start="476">A tourist must experience <strong data-end="517" data-start="502">exactly one</strong> ride from <strong data-end="536" data-start="528">each</strong> category, in <strong data-end="566" data-start="550">either order</strong>.</p>

<ul>
	<li data-end="641" data-start="573">A ride may be started at its opening time or <strong data-end="638" data-start="618">any later moment</strong>.</li>
	<li data-end="715" data-start="644">If a ride is started at time <code data-end="676" data-start="673">t</code>, it finishes at time <code data-end="712" data-start="698">t + duration</code>.</li>
	<li data-end="834" data-start="718">Immediately after finishing one ride the tourist may board the other (if it is already open) or wait until it opens.</li>
</ul>

<p data-end="917" data-start="836">Return the <strong data-end="873" data-start="847">earliest possible time</strong> at which the tourist can finish both rides.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [2,8], landDuration = [4,1], waterStartTime = [6], waterDuration = [3]</span></p>

<p><strong>Output:</strong> <span class="example-io">9</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul>
	<li data-end="181" data-start="145">Plan A (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="272" data-start="186">Start land ride 0 at time <code data-end="234" data-start="212">landStartTime[0] = 2</code>. Finish at <code data-end="271" data-start="246">2 + landDuration[0] = 6</code>.</li>
		<li data-end="392" data-start="277">Water ride 0 opens at time <code data-end="327" data-start="304">waterStartTime[0] = 6</code>. Start immediately at <code data-end="353" data-start="350">6</code>, finish at <code data-end="391" data-start="365">6 + waterDuration[0] = 9</code>.</li>
	</ul>
	</li>
	<li data-end="432" data-start="396">Plan B (water ride 0 &rarr; land ride 1):
	<ul>
		<li data-end="526" data-start="437">Start water ride 0 at time <code data-end="487" data-start="464">waterStartTime[0] = 6</code>. Finish at <code data-end="525" data-start="499">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="632" data-start="531">Land ride 1 opens at <code data-end="574" data-start="552">landStartTime[1] = 8</code>. Start at time <code data-end="593" data-start="590">9</code>, finish at <code data-end="631" data-start="605">9 + landDuration[1] = 10</code>.</li>
	</ul>
	</li>
	<li data-end="672" data-start="636">Plan C (land ride 1 &rarr; water ride 0):
	<ul>
		<li data-end="763" data-start="677">Start land ride 1 at time <code data-end="725" data-start="703">landStartTime[1] = 8</code>. Finish at <code data-end="762" data-start="737">8 + landDuration[1] = 9</code>.</li>
		<li data-end="873" data-start="768">Water ride 0 opened at <code data-end="814" data-start="791">waterStartTime[0] = 6</code>. Start at time <code data-end="833" data-start="830">9</code>, finish at <code data-end="872" data-start="845">9 + waterDuration[0] = 12</code>.</li>
	</ul>
	</li>
	<li data-end="913" data-start="877">Plan D (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1007" data-start="918">Start water ride 0 at time <code data-end="968" data-start="945">waterStartTime[0] = 6</code>. Finish at <code data-end="1006" data-start="980">6 + waterDuration[0] = 9</code>.</li>
		<li data-end="1114" data-start="1012">Land ride 0 opened at <code data-end="1056" data-start="1034">landStartTime[0] = 2</code>. Start at time <code data-end="1075" data-start="1072">9</code>, finish at <code data-end="1113" data-start="1087">9 + landDuration[0] = 13</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1161" data-is-last-node="" data-is-only-node="" data-start="1116">Plan A gives the earliest finish time of 9.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">landStartTime = [5], landDuration = [3], waterStartTime = [1], waterDuration = [10]</span></p>

<p><strong>Output:</strong> <span class="example-io">14</span></p>

<p><strong>Explanation:</strong>​​​​​​​</p>

<ul data-end="1589" data-start="1086">
	<li data-end="1124" data-start="1088">Plan A (water ride 0 &rarr; land ride 0):
	<ul>
		<li data-end="1219" data-start="1129">Start water ride 0 at time <code data-end="1179" data-start="1156">waterStartTime[0] = 1</code>. Finish at <code data-end="1218" data-start="1191">1 + waterDuration[0] = 11</code>.</li>
		<li data-end="1338" data-start="1224">Land ride 0 opened at <code data-end="1268" data-start="1246">landStartTime[0] = 5</code>. Start immediately at <code data-end="1295" data-start="1291">11</code> and finish at <code data-end="1337" data-start="1310">11 + landDuration[0] = 14</code>.</li>
	</ul>
	</li>
	<li data-end="1378" data-start="1342">Plan B (land ride 0 &rarr; water ride 0):
	<ul>
		<li data-end="1469" data-start="1383">Start land ride 0 at time <code data-end="1431" data-start="1409">landStartTime[0] = 5</code>. Finish at <code data-end="1468" data-start="1443">5 + landDuration[0] = 8</code>.</li>
		<li data-end="1589" data-start="1474">Water ride 0 opened at <code data-end="1520" data-start="1497">waterStartTime[0] = 1</code>. Start immediately at <code data-end="1546" data-start="1543">8</code> and finish at <code data-end="1588" data-start="1561">8 + waterDuration[0] = 18</code>.</li>
	</ul>
	</li>
</ul>

<p data-end="1640" data-is-last-node="" data-is-only-node="" data-start="1591">Plan A provides the earliest finish time of 14.<strong>​​​​​​​</strong></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li data-end="38" data-start="16"><code data-end="36" data-start="16">1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
	<li data-end="93" data-start="41"><code data-end="91" data-start="41">landStartTime.length == landDuration.length == n</code></li>
	<li data-end="150" data-start="96"><code data-end="148" data-start="96">waterStartTime.length == waterDuration.length == m</code></li>
	<li data-end="237" data-start="153"><code data-end="235" data-start="153">1 &lt;= landStartTime[i], landDuration[i], waterStartTime[j], waterDuration[j] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-46">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/expressive-words/description" target="_blank" rel="noopener noreferrer">Expressive Words</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Sometimes people repeat letters to represent extra feeling. For example:</p>

<ul>
	<li><code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code></li>
	<li><code>&quot;hi&quot; -&gt; &quot;hiiii&quot;</code></li>
</ul>

<p>In these strings like <code>&quot;heeellooo&quot;</code>, we have groups of adjacent letters that are all the same: <code>&quot;h&quot;</code>, <code>&quot;eee&quot;</code>, <code>&quot;ll&quot;</code>, <code>&quot;ooo&quot;</code>.</p>

<p>You are given a string <code>s</code> and an array of query strings <code>words</code>. A query word is <strong>stretchy</strong> if it can be made to be equal to <code>s</code> by any number of applications of the following extension operation: choose a group consisting of characters <code>c</code>, and add some number of characters <code>c</code> to the group so that the size of the group is <strong>three or more</strong>.</p>

<ul>
	<li>For example, starting with <code>&quot;hello&quot;</code>, we could do an extension on the group <code>&quot;o&quot;</code> to get <code>&quot;hellooo&quot;</code>, but we cannot get <code>&quot;helloo&quot;</code> since the group <code>&quot;oo&quot;</code> has a size less than three. Also, we could do another extension like <code>&quot;ll&quot; -&gt; &quot;lllll&quot;</code> to get <code>&quot;helllllooo&quot;</code>. If <code>s = &quot;helllllooo&quot;</code>, then the query word <code>&quot;hello&quot;</code> would be <strong>stretchy</strong> because of these two extension operations: <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s</code>.</li>
</ul>

<p>Return <em>the number of query strings that are <strong>stretchy</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;heeellooo&quot;, words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.
We can&#39;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;zzzzzyyyyy&quot;, words = [&quot;zzyy&quot;,&quot;zy&quot;,&quot;zyy&quot;]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>s</code> and <code>words[i]</code> consist of lowercase letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-47">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-all-distinct-triplets-with-given-sum/1" target="_blank" rel="noopener noreferrer">Find all distinct triplets with given sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[]</strong>, and an integer <strong>target</strong>, find all possible <strong>unique</strong> triplets in the array whose sum is equal to the given <strong>target</strong> value. We can return triplets in any order, but all the returned triplets should be <strong>internally sorted</strong>, i.e., for any triplet [q1, q2, q3], the condition q1 &le; q2 &le; q3 should hold.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">arr[] = [12, 3, 6, 1, 6, 9], target = 24 </span><span style="font-size: 18px;">
<strong>Output: </strong>[[3, 9, 12], [6, 6, 12]]<strong>
Explanation: </strong></span><span style="font-size: 18px;">Triplets with sum 24 are (3, 9, 12) and (6, 6, 12). </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 1, 1, 1], target = 3
<strong>Output: </strong>[[1, 1, 1]]<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">Triplets with sum 3 are (1, 1, 1). </span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [10, 12, 10, 15],</span><span style="font-size: 18px;"> target = 32</span><span style="font-size: 18px;">
<strong>Output: </strong>[[10, 10, 12]]</span><span style="font-size: 14pt;"><strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">Triplets with sum 32 are (10, 10, 12).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>3 &lt;= arr.size() &lt;= 10<sup>3</sup><strong><br /></strong></span><span style="font-size: 18px;">0 &lt;= arr[i] </span><span style="font-size: 18px;">&lt;= 10<sup>4</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">1 &lt;= target &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-48">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-all-k-distant-indices-in-an-array/description" target="_blank" rel="noopener noreferrer">Find All K-Distant Indices in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and two integers <code>key</code> and <code>k</code>. A <strong>k-distant index</strong> is an index <code>i</code> of <code>nums</code> for which there exists at least one index <code>j</code> such that <code>|i - j| &lt;= k</code> and <code>nums[j] == key</code>.</p>

<p>Return <em>a list of all k-distant indices sorted in <strong>increasing order</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,4,9,1,3,9,5], key = 9, k = 1
<strong>Output:</strong> [1,2,3,4,5,6]
<strong>Explanation:</strong> Here, <code>nums[2] == key</code> and <code>nums[5] == key.
- For index 0, |0 - 2| &gt; k and |0 - 5| &gt; k, so there is no j</code> where <code>|0 - j| &lt;= k</code> and <code>nums[j] == key. Thus, 0 is not a k-distant index.
- For index 1, |1 - 2| &lt;= k and nums[2] == key, so 1 is a k-distant index.
- For index 2, |2 - 2| &lt;= k and nums[2] == key, so 2 is a k-distant index.
- For index 3, |3 - 2| &lt;= k and nums[2] == key, so 3 is a k-distant index.
- For index 4, |4 - 5| &lt;= k and nums[5] == key, so 4 is a k-distant index.
- For index 5, |5 - 5| &lt;= k and nums[5] == key, so 5 is a k-distant index.
- For index 6, |6 - 5| &lt;= k and nums[5] == key, so 6 is a k-distant index.
</code>Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,2,2,2], key = 2, k = 2
<strong>Output:</strong> [0,1,2,3,4]
<strong>Explanation:</strong> For all indices i in nums, there exists some index j such that |i - j| &lt;= k and nums[j] == key, so every index is a k-distant index. 
Hence, we return [0,1,2,3,4].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>key</code> is an integer from the array <code>nums</code>.</li>
	<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-enumerate">Approach 1: Enumerate</h3>
<h4 id="intuition">Intuition</h4>
<p>We can enumerate all index pairs <span class="math inline">\((i, j)\)</span> and determine whether <span class="math inline">\(\textit{nums}[j] = \textit{key}\)</span> and <span class="math inline">\(|i - j| \le k\)</span>. At the same time, we use the array <span class="math inline">\(\textit{res}\)</span> to maintain all indices of the <span class="math inline">\(k\)</span> nearest neighbors. If both conditions are satisfied, we add <span class="math inline">\(i\)</span> to the array <span class="math inline">\(\textit{res}\)</span>.</p>
<p>To ensure that <span class="math inline">\(\textit{res}\)</span> does not contain duplicate indices and is in ascending order, we can first enumerate <span class="math inline">\(i\)</span> in ascending order, then enumerate <span class="math inline">\(j\)</span>, and terminate the inner loop each time <span class="math inline">\(i\)</span> is added to <span class="math inline">\(\textit{res}\)</span>, proceeding to the next <span class="math inline">\(i\)</span>. Finally, the array <span class="math inline">\(\textit{res}\)</span> will contain the indices of all the <span class="math inline">\(k\)</span> nearest neighbors that meet the requirements, and we can return it as the answer.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NzZoDHBG/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span>.</p>
<p>This is the time complexity for traversing indices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> to find the target index.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>The output array is not counted in the space complexity.</p>
</li>
</ul>
<h3 id="approach-2-one-time-traversal">Approach 2: One-time Traversal</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Let's assume the length of the array <span class="math inline">\(\textit{nums}\)</span> is <span class="math inline">\(n\)</span>. Then, for any index <span class="math inline">\(j\)</span> that satisfies <span class="math inline">\(\textit{nums}[j] = \textit{key}\)</span>, all indices within the closed interval <span class="math inline">\([\max(0, j - k), \min(n - 1, j + k)]\)</span> are <span class="math inline">\(K\)</span>-neighbor indices (the maximum and minimum functions are used here to ensure the indices are valid).</p>
<p>So, we can find all indices <span class="math inline">\(j\)</span> such that <span class="math inline">\(\textit{nums}[j] = \textit{key}\)</span> by traversing the array <span class="math inline">\(\textit{nums}\)</span> once, and then adding the integers within the corresponding interval to <span class="math inline">\(\textit{res}\)</span>. However, this can still lead to the possibility of duplicate indices being added to the answer array. To avoid this, we can use <span class="math inline">\(r\)</span> to represent the smallest index that has not yet been determined to be a <span class="math inline">\(K\)</span>-nearest neighbor index. Before the traversal begins, let <span class="math inline">\(r = 0\)</span>. Whenever we reach an index <span class="math inline">\(j\)</span> that satisfies the condition, we just need to add all indices within the closed interval <span class="math inline">\([\max(0, j - k), \min(n - 1, j + k)]\)</span> in order to <span class="math inline">\(\textit{res}\)</span>, starting from <span class="math inline">\(r\)</span>, and at the same time, update <span class="math inline">\(r\)</span> to <span class="math inline">\(\min(n - 1, j + k) + 1\)</span>. After the traversal is complete, <span class="math inline">\(\textit{res}\)</span> will contain all <span class="math inline">\(K\)</span>-nearest neighbor indices, sorted in ascending order and without duplicates.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/gmq5ssqs/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the array <span class="math inline">\(\textit{nums}\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>We only need to traverse the array once.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>The output array is not counted in the space complexity.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-49">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/print-all-triplets-with-given-sum/1" target="_blank" rel="noopener noreferrer">Find all triplets with given sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr</strong>. The task is to find triplets in an array whose sum equals a given number <strong>k</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples :</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [0, -1, 2, -3, 1], k = -2<br /><strong>Output:</strong> [[0, -3, 1], [-1, 2, -3]] <strong>
Explanation: </strong>If we calculate the sum of the output, 0 + (-3) + 1 = -2, (-1) + 2 + (-3) = -2</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong>arr[] = [1, -2, 1, 0, 5], k = 0
<strong>Output: </strong>[[1, -2, 1]] <strong>
Explanation: </strong>If we calculate the sum of the output, 1 + (-2) + 1 = 0</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>3</sup><br />-1000 &lt;= k &lt;= 1000<br />-100 &lt;= arr[] &lt;= 100</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-50">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-i/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 10</code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-51">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/description" target="_blank" rel="noopener noreferrer">Find Beautiful Indices in the Given Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code>, a string <code>a</code>, a string <code>b</code>, and an integer <code>k</code>.</p>

<p>An index <code>i</code> is <strong>beautiful</strong> if:</p>

<ul>
	<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>
	<li><code>s[i..(i + a.length - 1)] == a</code></li>
	<li>There exists an index <code>j</code> such that:
	<ul>
		<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>
		<li><code>s[j..(j + b.length - 1)] == b</code></li>
		<li><code>|j - i| &lt;= k</code></li>
	</ul>
	</li>
</ul>

<p>Return <em>the array that contains beautiful indices in <strong>sorted order from smallest to largest</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;isawsquirrelnearmysquirrelhouseohmy&quot;, a = &quot;my&quot;, b = &quot;squirrel&quot;, k = 15
<strong>Output:</strong> [16,33]
<strong>Explanation:</strong> There are 2 beautiful indices: [16,33].
- The index 16 is beautiful as s[16..17] == &quot;my&quot; and there exists an index 4 with s[4..11] == &quot;squirrel&quot; and |16 - 4| &lt;= 15.
- The index 33 is beautiful as s[33..34] == &quot;my&quot; and there exists an index 18 with s[18..25] == &quot;squirrel&quot; and |33 - 18| &lt;= 15.
Thus we return [16,33] as the result.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;, a = &quot;a&quot;, b = &quot;a&quot;, k = 4
<strong>Output:</strong> [0]
<strong>Explanation:</strong> There is 1 beautiful index: [0].
- The index 0 is beautiful as s[0..0] == &quot;a&quot; and there exists an index 0 with s[0..0] == &quot;a&quot; and |0 - 0| &lt;= 4.
Thus we return [0] as the result.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>1 &lt;= a.length, b.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>s</code>, <code>a</code>, and <code>b</code> contain only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-52">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-first-palindromic-string-in-the-array/description" target="_blank" rel="noopener noreferrer">Find First Palindromic String in the Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>words</code>, return <em>the first <strong>palindromic</strong> string in the array</em>. If there is no such string, return <em>an <strong>empty string</strong> </em><code>&quot;&quot;</code>.</p>

<p>A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abc&quot;,&quot;car&quot;,&quot;ada&quot;,&quot;racecar&quot;,&quot;cool&quot;]
<strong>Output:</strong> &quot;ada&quot;
<strong>Explanation:</strong> The first string that is palindromic is &quot;ada&quot;.
Note that &quot;racecar&quot; is also palindromic, but it is not the first.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;notapalindrome&quot;,&quot;racecar&quot;]
<strong>Output:</strong> &quot;racecar&quot;
<strong>Explanation:</strong> The first and only string that is palindromic is &quot;racecar&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;def&quot;,&quot;ghi&quot;]
<strong>Output:</strong> &quot;&quot;
<strong>Explanation:</strong> There are no palindromic strings, so the empty string is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 100</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
	<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-reverse-string">Approach 1: Reverse String</h3>
<h4 id="intuition">Intuition</h4>
<p>A string is said to be a palindrome if it remains the same, reading forward and backward. An intuitive way to check if the string is a palindrome is to create a new string by reversing the characters and then comparing the original with it. If the reversed and original string are the same then the string is palindrome. In this approach, we will iterate over the list <code>words,</code> and then for each string <code>s</code> in it, we will reverse it and check if this is equal to the original string, and if true, then we will return this string.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Iterate over the list <code>words</code> and for each string <code>s</code>:</li>
<li>Create a new string <code>reversed</code> which is the reverse of the original string <code>s</code>.</li>
<li>If <code>s</code> and <code>reversed</code> are the same, then return the string; it is a valid palindrome.</li>
<li>Return the empty string after iterating over all the strings.  If the loop terminates without finding and returning a palindrome, it means <code>words</code> has no palindromes.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kPmqSvGw/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of strings in <code>words</code> and <span class="math inline">\(M\)</span> be the maximum length of a string in it.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>We iterate over the strings in the list words which takes <span class="math inline">\(O(N)\)</span>, and for each string, we reverse the string which takes <span class="math inline">\(O(M)\)</span> and compare it with the original. Hence, the time complexity is equal to <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M)\)</span></p>
<p>We create a new string for each string in the list <code>words</code> and therefore the space complexity is equal to the maximum length of a string that is created which is <span class="math inline">\(O(M)\)</span>.<br />
<br/></p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The above approach requires the creation of making new string by reversing it. Can we somehow avoid this space requirement?</p>
<p>One way to think of palindromes is that they read the same from both ends. So, if we compare the characters from the two ends of the string, they should be the same in a valid palindrome. If the string is of even length, then there would be a pair for each index; otherwise, if the string is odd, there would be one character in the middle that doesn't need to be compared with any counterpart.</p>
<p><img src="../Figures/2108/2108A.png" alt="Even Length" /></p>
<p><img src="../Figures/2108/2108B.png" alt="Odd Length" /></p>
<p><span class="math inline">\(c_n\)</span> represents a character</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Define the method <code>isPalindrome()</code> which returns <code>true</code> if the provided string <code>s</code> is a palindrome and <code>false</code> otherwise:</p>
<ol>
<li>Keep one pointer of left <code>start = 0</code> and one on the right end <code>end = s.size() - 1</code>.</li>
<li>Keep iterating over the string until <code>start &gt; end</code>.</li>
<li>If the characters at <code>start</code> and <code>end</code> are not the same then return <code>false</code>.</li>
<li>Increment <code>start</code> and decrement <code>end</code>.</li>
<li>Return <code>true</code> after iterating over all the characters.</li>
</ol>
</li>
<li>
<p>Iterate over each string in <code>words</code> from left to right and call <code>isPalindrome()</code> for each string and return the first one for which the method returns <code>true</code>.</p>
</li>
<li>
<p>After the loop terminates, return an empty string. If the loop terminates without finding and returning a palindrome, it means <code>words</code> has no palindromes.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/jaU7vxEG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the number of strings in <code>words</code> and <span class="math inline">\(M\)</span> be the maximum length of a string in it.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N \cdot M)\)</span></p>
<p>For each of the <span class="math inline">\(N\)</span> strings in the list <code>words</code>, we iterate over each character once, and hence the time complexity is equal to <span class="math inline">\(O(N \cdot M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>No extra space is required while checking for palindromes, and hence, the space complexity is constant.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-53">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-indices-with-index-and-value-difference-i/description" target="_blank" rel="noopener noreferrer">Find Indices With Index and Value Difference I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> having length <code>n</code>, an integer <code>indexDifference</code>, and an integer <code>valueDifference</code>.</p>

<p>Your task is to find <strong>two</strong> indices <code>i</code> and <code>j</code>, both in the range <code>[0, n - 1]</code>, that satisfy the following conditions:</p>

<ul>
	<li><code>abs(i - j) &gt;= indexDifference</code>, and</li>
	<li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li>
</ul>

<p>Return <em>an integer array</em> <code>answer</code>, <em>where</em> <code>answer = [i, j]</code> <em>if there are two such indices</em>, <em>and</em> <code>answer = [-1, -1]</code> <em>otherwise</em>. If there are multiple choices for the two indices, return <em>any of them</em>.</p>

<p><strong>Note:</strong> <code>i</code> and <code>j</code> may be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
<strong>Output:</strong> [0,3]
<strong>Explanation:</strong> In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) &gt;= 2 and abs(nums[0] - nums[3]) &gt;= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1], indexDifference = 0, valueDifference = 0
<strong>Output:</strong> [0,0]
<strong>Explanation:</strong> In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) &gt;= 0 and abs(nums[0] - nums[0]) &gt;= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], indexDifference = 2, valueDifference = 4
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong> In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
	<li><code>0 &lt;= indexDifference &lt;= 100</code></li>
	<li><code>0 &lt;= valueDifference &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-54">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-indices-with-index-and-value-difference-ii/description" target="_blank" rel="noopener noreferrer">Find Indices With Index and Value Difference II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> having length <code>n</code>, an integer <code>indexDifference</code>, and an integer <code>valueDifference</code>.</p>

<p>Your task is to find <strong>two</strong> indices <code>i</code> and <code>j</code>, both in the range <code>[0, n - 1]</code>, that satisfy the following conditions:</p>

<ul>
	<li><code>abs(i - j) &gt;= indexDifference</code>, and</li>
	<li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li>
</ul>

<p>Return <em>an integer array</em> <code>answer</code>, <em>where</em> <code>answer = [i, j]</code> <em>if there are two such indices</em>, <em>and</em> <code>answer = [-1, -1]</code> <em>otherwise</em>. If there are multiple choices for the two indices, return <em>any of them</em>.</p>

<p><strong>Note:</strong> <code>i</code> and <code>j</code> may be <strong>equal</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
<strong>Output:</strong> [0,3]
<strong>Explanation:</strong> In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) &gt;= 2 and abs(nums[0] - nums[3]) &gt;= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1], indexDifference = 0, valueDifference = 0
<strong>Output:</strong> [0,0]
<strong>Explanation:</strong> In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) &gt;= 0 and abs(nums[0] - nums[0]) &gt;= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3], indexDifference = 2, valueDifference = 4
<strong>Output:</strong> [-1,-1]
<strong>Explanation:</strong> In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= indexDifference &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= valueDifference &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-55">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-k-closest-elements/description" target="_blank" rel="noopener noreferrer">Find K Closest Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>sorted</strong> integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.</p>

<p>An integer <code>a</code> is closer to <code>x</code> than an integer <code>b</code> if:</p>

<ul>
	<li><code>|a - x| &lt; |b - x|</code>, or</li>
	<li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [1,2,3,4,5], k = 4, x = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,3,4]</span></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">arr = [1,1,2,3,4,5], k = 4, x = -1</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,1,2,3]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= arr.length</code></li>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>arr</code> is sorted in <strong>ascending</strong> order.</li>
	<li><code>-10<sup>4</sup> &lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-56">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-k-th-smallest-pair-distance/description" target="_blank" rel="noopener noreferrer">Find K-th Smallest Pair Distance</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>distance of a pair</strong> of integers <code>a</code> and <code>b</code> is defined as the absolute difference between <code>a</code> and <code>b</code>.</p>

<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest <strong>distance among all the pairs</strong></em> <code>nums[i]</code> <em>and</em> <code>nums[j]</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; nums.length</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1], k = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> Here are all the pairs:
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
Then the 1<sup>st</sup> smallest distance pair is (1,1), and its distance is 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1], k = 2
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,6,1], k = 3
<strong>Output:</strong> 5
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The goal is to find the <code>k</code>-th smallest distance between any two different elements in an array <code>nums</code>. The distance between two elements <code>nums[i]</code> and <code>nums[j]</code> is defined as the absolute difference between their values, <code>|nums[i] - nums[j]|</code>. We only consider pairs where <code>i</code> is less than <code>j</code> to avoid counting the same pair twice.</p>
<p>For example:</p>
<blockquote>
<p><strong>Input:</strong> <code>nums = [1, 3, 1]</code>, <code>k = 1</code><br />
<strong>Output:</strong> <code>0</code></p>
</blockquote>
<p>Let's look at all possible pairs of elements and their distances:</p>
<ol>
<li>
<p>Pair (1, 3):</p>
<ul>
<li>Distance: |1 - 3| = 2</li>
</ul>
</li>
<li>
<p>Pair (1, 1):</p>
<ul>
<li>Distance: |1 - 1| = 0</li>
</ul>
</li>
<li>
<p>Pair (3, 1):</p>
<ul>
<li>Distance: |3 - 1| = 2</li>
</ul>
</li>
</ol>
<p>So, the distances are <code>[2, 0, 2]</code>.</p>
<p>To find the <code>k</code>-th smallest distance, we sort these distances: <code>[0, 2, 2]</code>.</p>
<p>Since <code>k = 1</code>, we need the 1st smallest distance, which is <code>0</code>.</p>
<p>Thus, the result is <code>0</code>.</p>
<p>The brute-force approach involves checking the distance for every possible pair of elements in the array and maintaining the <code>k</code> smallest distances using a heap. Specifically, we iterate over all pairs, calculate their absolute distances, and use a max-heap to keep track of the <code>k</code> smallest distances. If the heap size exceeds <code>k</code>, we remove the largest element. After processing all pairs, the root of the heap will represent the <code>k-th</code> smallest distance.</p>
<p>However, this method is computationally heavy and will lead to a Time Limit Exceeded (TLE) error. The time complexity is dominated by the need to examine all pairs, which is <span class="math inline">\(O(n^2)\)</span>, combined with the overhead of maintaining a heap of size <code>k</code>, resulting in an overall time complexity of <span class="math inline">\(O(n^2 \log k)\)</span>, where <code>n</code> is the number of elements. This makes the approach impractical for large values of <code>n</code>.</p>
<hr />
<h3 id="approach-1-bucket-sort">Approach 1: Bucket Sort</h3>
<h4 id="intuition">Intuition</h4>
<p>Given that array elements can be as large as <code>1,000,000</code>, a direct comparison approach would be computationally expensive. However, since the distances are bounded by the maximum element in the array, we can leverage this property to use a bucket sort approach, which is efficient for problems with a known range of values. This transforms the problem of finding the <code>k</code>-th smallest distance into a counting problem within a fixed range.</p>
<p>We first observe that the range of possible distances is finite and bounded:</p>
<ul>
<li>The minimum distance is 0, occurring when two numbers in the array are identical.</li>
<li>The maximum distance is the difference between the largest and smallest numbers in the array.</li>
</ul>
<p>This bounded range forms the foundation of our approach. With this range established, we conceptualize a series of &quot;buckets,&quot; each representing a specific distance within our range. These buckets serve as counters, allowing us to tally the frequency of each distance without needing to store the actual pairs that produce them. This abstraction significantly reduces memory requirements and computational complexity.</p>
<p>Now for each pair of numbers in the array, calculate the absolute difference and increment the corresponding bucket count.</p>
<p>After processing all pairs, our bucket array contains a comprehensive frequency distribution of all distances present in the original array. Now traverse the bucket array from the smallest distance upwards, maintaining a running sum of counts. The distance where this running sum first equals or exceeds is the  k-th smallest distance.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Determine the size of the input array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Find the maximum element in the array <code>nums</code> and store it in <code>maxElement</code>.</p>
</li>
<li>
<p>Create a bucket array <code>distanceBucket</code> with size <code>maxElement + 1</code>, initialized to 0, to store the counts of each distance.</p>
</li>
<li>
<p>Populate the <code>distanceBucket</code> array:</p>
<ul>
<li>Iterate over all pairs of indices <code>(i, j)</code> where <code>i &lt; j</code> in the array <code>nums</code>.
<ul>
<li>Calculate the distance between <code>nums[i]</code> and <code>nums[j]</code> as <code>abs(nums[i] - nums[j])</code>.</li>
<li>Increment the count for this distance in the <code>distanceBucket</code> array.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Find the k-th smallest distance:</p>
<ul>
<li>Iterate over all possible distances from 0 to <code>maxElement</code>.
<ul>
<li>Subtract the count of pairs with the current distance from <code>k</code>.</li>
<li>If <code>k</code> becomes less than or equal to 0, return the current distance as it is the k-th smallest distance.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the function does not return within the loop, return <code>-1</code> indicating no distance was found, although this case should not occur with valid inputs.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: The Python implementation for this approach will encounter a Time Limit Exceeded (TLE) error because Python's inherent slower execution speed.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/H5scviJc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 + M)\)</span></p>
<p>The <span class="math inline">\(O(n^2)\)</span> term arises from the nested loops used to calculate all pairwise distances between elements. Since we are examining every possible pair of elements in the array, this results in <span class="math inline">\(n(n-1)/2\)</span> comparisons, which simplifies to <span class="math inline">\(O(n^2)\)</span>.</p>
<p>After calculating all distances, we traverse the <code>distanceBucket</code> array to find the k-th smallest distance. This traversal is <span class="math inline">\(O(M)\)</span>, where <span class="math inline">\(M\)</span> is the maximum possible distance, which is proportional to the largest element in the array. Thus, the total time complexity is <span class="math inline">\(O(n^2 + M)\)</span>, accounting for both the pair distance calculations and the bucket traversal.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(M)\)</span></p>
<p>The space complexity is dominated by the <code>distanceBucket</code> array, which is used to count occurrences of each possible distance. The size of this array is proportional to the maximum possible distance <span class="math inline">\(M\)</span>. Aside from this array, the space usage is minimal and does not depend on the number of elements, leading to a space complexity of <span class="math inline">\(O(M)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search--dynamic-programming-dp">Approach 2: Binary Search + Dynamic Programming (DP)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We now explore a sophisticated approach that combines binary search with dynamic programming, especially effective for arrays with a broad range of values where bucket sort might be impractical due to memory constraints.</p>
<p>First, recognize that our solution space—the range of possible distances—is bounded. The minimum distance is 0, and the maximum is the difference between the largest and smallest elements in the array. This bounded range allows us to use binary search to efficiently find the <code>k</code>-th smallest distance.</p>
<p>Our key insight is that for any given distance <code>d</code>, we can count the number of pairs in the array with a distance less than or equal to <code>d</code>. If this count is less than <code>k</code>, the <code>k</code>-th smallest distance must be greater than <code>d</code>. Conversely, if the count is at least <code>k</code>, the <code>k</code>-th smallest distance must be less than or equal to <code>d</code>. This forms the basis of our binary search approach.</p>
<p>To implement this, we first sort the input array. Sorting is crucial because it enables us to efficiently count pairs with distances less than or equal to a given value.</p>
<p>We then set up our binary search:</p>
<ul>
<li>The lower bound of our search range is <code>0</code>, and the upper bound is the difference between the maximum and minimum elements in the sorted array.</li>
<li>In each iteration, we calculate the midpoint of the current range and count the number of pairs with distances less than or equal to this midpoint.</li>
</ul>
<p>The counting process is where dynamic programming comes into play. We use two auxiliary arrays to optimize our pair counting:</p>
<ol>
<li><strong>prefixCount</strong>: This array maintains the cumulative count of elements up to each value in the sorted array. For any index <code>i</code>, <code>prefixCount[i]</code> represents the number of elements less than or equal to <code>i</code>.</li>
<li><strong>valueCount</strong>: Implemented as a hash map, <code>valueCount[i]</code> stores the count of occurrences of the value <code>i</code> in the array.</li>
</ol>
<p>To count pairs for a given distance <code>d</code>, we iterate through the sorted array. For each element <code>x</code>, we calculate:</p>
<ul>
<li>The number of elements within distance <code>d</code> of <code>x</code> using <code>prefixCount</code>.</li>
<li>The number of pairs formed by duplicate occurrences of <code>x</code> using <code>valueCount</code>.</li>
</ul>
<p>Based on the count of pairs at the current midpoint distance, we adjust our binary search range:</p>
<ul>
<li>If the count is less than <code>k</code>, we need to look at larger distances by adjusting the lower bound.</li>
<li>If the count is greater than or equal to <code>k</code>, we need to look at smaller distances by adjusting the upper bound.</li>
</ul>
<p>We repeat this process, halving the search range each time, until the lower and upper bounds converge, giving us the <code>k</code>-th smallest pair distance.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>nums</code> to simplify distance calculations.</p>
</li>
<li>
<p>Determine the size of the sorted array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Find the largest element in the sorted array <code>nums</code> and store it in <code>maxElement</code>.</p>
</li>
<li>
<p>Calculate the maximum possible distance as <code>maxElement * 2</code>.</p>
</li>
<li>
<p>Initialize arrays and maps:</p>
<ul>
<li>Create an array <code>prefixCount</code> with size <code>maxPossibleDistance</code> to store prefix counts of distances.</li>
<li>Create a map <code>valueCount</code> to count occurrences of each value in the array.</li>
</ul>
</li>
<li>
<p>Populate the <code>prefixCount</code> array:</p>
<ul>
<li>Iterate through possible distance values from 0 to <code>maxPossibleDistance - 1</code>.
<ul>
<li>For each distance value, determine the number of elements in the array <code>nums</code> that are less than or equal to this distance.</li>
<li>Store this count in <code>prefixCount</code> for the current distance.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Populate the <code>valueCount</code> map:</p>
<ul>
<li>Iterate through the array <code>nums</code>.
<ul>
<li>Count occurrences of each value and store in <code>valueCount</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Perform binary search for the k-th smallest distance:</p>
<ul>
<li>Set <code>low</code> to 0 and <code>high</code> to <code>maxElement</code>.</li>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate the middle point <code>mid</code> as <code>(low + high) / 2</code>.</li>
<li>Count the number of pairs with distance ≤ <code>mid</code> using the helper function <code>countPairs</code>.</li>
<li>Adjust the binary search bounds based on whether the count is less than or greater than or equal to <code>k</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the smallest distance found by the binary search.</p>
</li>
<li>
<p>Helper function <code>countPairs</code>:</p>
<ul>
<li>Count the number of pairs with distance ≤ <code>maxDistance</code>:
<ul>
<li>Iterate through the array <code>nums</code>.</li>
<li>Calculate the number of pairs involving the current value that are within the allowed distance.</li>
<li>Accumulate the total count of such pairs.</li>
</ul>
</li>
<li>Return the count of pairs with distance ≤ <code>maxDistance</code>.</li>
</ul>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SU4MpYrm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + n \log M + M)\)</span></p>
<p>The <span class="math inline">\(O(n \log n)\)</span> term arises from sorting the array, which is necessary for efficiently calculating distances and performing binary search. Sorting takes <span class="math inline">\(O(n \log n)\)</span> time.</p>
<p>The <span class="math inline">\(O(n \log M)\)</span> term comes from the binary search over the range of possible distances and counting pairs for each mid-value. Counting pairs involves traversing the array, and the binary search operations are logarithmic with respect to the maximum possible distance <span class="math inline">\(M\)</span>. And we populate the <code>prefixCount</code> array by iterating through the possible values from 0 to <code>maxPossibleDistance</code> - 1 taking <span class="math inline">\(O(M)\)</span>. Hence, the combined time complexity is <span class="math inline">\(O(n \log n + n \log M + M)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + M + S)\)</span></p>
<p>The space complexity includes <span class="math inline">\(O(n)\)</span> for storing the <code>prefixCount</code> array and the value counts in the <code>valueCount</code> map. The <code>prefixCount</code> array tracks the number of elements up to each possible distance, while <code>valueCount</code> stores counts of each unique element. Additionally, <span class="math inline">\(O(M)\)</span> is required for the <code>prefixCount</code> array.</p>
<p>Some extra space is used when we sort an array of size <span class="math inline">\(n\)</span> in place. The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the programming language. The value of <span class="math inline">\(S\)</span> depends on the programming language and the sorting algorithm being used:</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span></li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O( \log n )\)</span></li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span></li>
</ul>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(n + M + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search--sliding-window">Approach 3: Binary Search + Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The core idea remains similar to our previous approach: for any given distance <code>d</code>, we aim to count the number of pairs in the array with a distance less than or equal to <code>d</code>. If this count is less than <code>k</code>, we know the <code>k</code>-th smallest distance must be greater than <code>d</code>. If the count is greater than or equal to <code>k</code>, the <code>k</code>-th smallest distance must be less than or equal to <code>d</code>.</p>
<p>Where this approach diverges is in how we perform this counting operation. Instead of using pre-computed dynamic programming arrays, we employ a sliding window technique that takes advantage of the sorted nature of our array.</p>
<p>We begin by sorting the input array and then we set up binary search as before, with the lower bound at 0 and the upper bound at the difference between the maximum and minimum elements in the sorted array. In each iteration of the binary search, we calculate the midpoint of our current range.</p>
<p>The key innovation in this approach is the sliding window method used to count pairs with distances less than or equal to our current midpoint distance. Here's how it works:</p>
<ul>
<li>Start with two pointers, <code>left</code> and <code>right</code>, both at the start of the array. Move the <code>right</code> pointer to check distances.</li>
<li>As long as the distance between <code>right</code> and <code>left</code> is within the allowed range, keep moving <code>right</code> forward. Once we find a distance greater than our midpoint, we know that all elements between <code>left</code> and <code>right</code> (exclusive) form valid pairs with the element at <code>left</code>. We add this count to our total and then move the <code>left</code> pointer forward. Repeat until all pairs are checked.</li>
</ul>
<p>This sliding window technique counts valid pairs in linear time for each binary search iteration. The efficiency arises because the <code>right</code> pointer doesn't need to reset for each new <code>left</code> position; it continues from where it left off, leveraging the sorted array.</p>
<p>Based on the count of pairs for the current midpoint distance, we adjust our binary search range as follows:</p>
<ul>
<li>If the count is less than <code>k</code>, we increase the distance by adjusting our lower bound.</li>
<li>If the count is greater than or equal to <code>k</code>, we decrease the distance by adjusting our upper bound.</li>
</ul>
<p>We continue this process, halving our search range each time, until the lower and upper bounds converge. At this point, we identify the <code>k</code>-th smallest pair distance.</p>
<p>The efficiency of this approach is due to the combination of binary search, which reduces the search space logarithmically, and the sliding window technique, which allows us to count pairs in linear time for each binary search iteration, given that the array is sorted.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Sort the array <code>nums</code> to simplify distance calculations.</p>
</li>
<li>
<p>Determine the size of the sorted array <code>nums</code> and store it in <code>arraySize</code>.</p>
</li>
<li>
<p>Initialize the binary search range:</p>
<ul>
<li>Set <code>low</code> to 0.</li>
<li>Set <code>high</code> to the difference between the maximum and minimum elements in <code>nums</code> (i.e., <code>nums[arraySize - 1] - nums[0]</code>).</li>
</ul>
</li>
<li>
<p>Perform binary search to find the smallest distance:</p>
<ul>
<li>While <code>low</code> is less than <code>high</code>:
<ul>
<li>Calculate the middle point <code>mid</code> as <code>(low + high) / 2</code>.</li>
<li>Count the number of pairs with distance ≤ <code>mid</code> using the helper function <code>countPairsWithMaxDistance</code>.</li>
<li>Adjust the binary search bounds:
<ul>
<li>If the count of pairs is less than <code>k</code>, set <code>low</code> to <code>mid + 1</code>.</li>
<li>Otherwise, set <code>high</code> to <code>mid</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return the smallest distance found by the binary search.</p>
</li>
<li>
<p>Helper function <code>countPairsWithMaxDistance</code>:</p>
<ul>
<li>Count the number of pairs with distance ≤ <code>maxDistance</code> using a sliding window:
<ul>
<li>Initialize <code>count</code> to 0.</li>
<li>Set <code>left</code> pointer to 0.</li>
<li>Iterate with <code>right</code> pointer from 0 to the end of the array:
<ul>
<li>Adjust the <code>left</code> pointer to maintain the window where the distance between <code>nums[right]</code> and <code>nums[left]</code> is ≤ <code>maxDistance</code>.</li>
<li>Add the number of valid pairs ending at the current <code>right</code> index to <code>count</code> (i.e., <code>right - left</code>).</li>
</ul>
</li>
</ul>
</li>
<li>Return the total count of pairs with distance ≤ <code>maxDistance</code>.</li>
</ul>
</li>
</ul>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/719/approach4.json:980,760!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/VeCnLoRm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the number of elements and <span class="math inline">\(M\)</span> be the maximum possible distance.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log M + n \log n)\)</span></p>
<p>The <span class="math inline">\(O(n \log M)\)</span> term arises from the binary search over possible distances, where the search space is up to the maximum possible distance <span class="math inline">\(M\)</span>. For each mid-value in the binary search, the <code>countPairsWithMaxDistance</code> function is called, which operates in linear time <span class="math inline">\(O(n)\)</span>.</p>
<p>The binary search itself runs in <span class="math inline">\(O(\log M)\)</span> time. Hence, the combined time complexity is <span class="math inline">\(O(n \log M + n \log n)\)</span>, where the binary search and pair counting operations are combined.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(S)\)</span></p>
<p>The space complexity is constant because the algorithm only uses a fixed amount of extra space for the left and right pointers, the mid-value, and counters. It does not require additional data structures that scale with the input size, so the space complexity is <span class="math inline">\(O(1)\)</span>, excluding the space used to store the input array.</p>
<p>Some extra space is used when we sort an array of size <span class="math inline">\(n\)</span> in place. The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the programming language. The value of <span class="math inline">\(S\)</span> depends on the programming language and the sorting algorithm being used:</p>
<ul>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span></li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O( \log n )\)</span></li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span></li>
</ul>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(S)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-57">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-maximum-removals-from-source-string/description" target="_blank" rel="noopener noreferrer">Find Maximum Removals From Source String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>source</code> of size <code>n</code>, a string <code>pattern</code> that is a <span data-keyword="subsequence-string">subsequence</span> of <code>source</code>, and a <strong>sorted</strong> integer array <code>targetIndices</code> that contains <strong>distinct</strong> numbers in the range <code>[0, n - 1]</code>.</p>

<p>We define an <strong>operation</strong> as removing a character at an index <code>idx</code> from <code>source</code> such that:</p>

<ul>
	<li><code>idx</code> is an element of <code>targetIndices</code>.</li>
	<li><code>pattern</code> remains a <span data-keyword="subsequence-string">subsequence</span> of <code>source</code> after removing the character.</li>
</ul>

<p>Performing an operation <strong>does not</strong> change the indices of the other characters in <code>source</code>. For example, if you remove <code>&#39;c&#39;</code> from <code>&quot;acb&quot;</code>, the character at index 2 would still be <code>&#39;b&#39;</code>.</p>

<p>Return the <strong>maximum</strong> number of <em>operations</em> that can be performed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">source = &quot;abbaa&quot;, pattern = &quot;aba&quot;, </span>targetIndices<span class="example-io"> = [0,1,2]</span></p>

<p><strong>Output:</strong> 1</p>

<p><strong>Explanation:</strong></p>

<p>We can&#39;t remove <code>source[0]</code> but we can do either of these two operations:</p>

<ul>
	<li>Remove <code>source[1]</code>, so that <code>source</code> becomes <code>&quot;a_baa&quot;</code>.</li>
	<li>Remove <code>source[2]</code>, so that <code>source</code> becomes <code>&quot;ab_aa&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">source = &quot;bcda&quot;, pattern = &quot;d&quot;, </span>targetIndices<span class="example-io"> = [0,3]</span></p>

<p><strong>Output:</strong> 2</p>

<p><strong>Explanation:</strong></p>

<p>We can remove <code>source[0]</code> and <code>source[3]</code> in two operations.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">source = &quot;dda&quot;, pattern = &quot;dda&quot;, </span>targetIndices<span class="example-io"> = [0,1,2]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>We can&#39;t remove any character from <code>source</code>.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">source = </span>&quot;yeyeykyded&quot;<span class="example-io">, pattern = </span>&quot;yeyyd&quot;<span class="example-io">, </span>targetIndices<span class="example-io"> = </span>[0,2,3,4]</p>

<p><strong>Output:</strong> 2</p>

<p><strong>Explanation:</strong></p>

<p>We can remove <code>source[2]</code> and <code>source[3]</code> in two operations.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == source.length &lt;= 3 * 10<sup>3</sup></code></li>
	<li><code>1 &lt;= pattern.length &lt;= n</code></li>
	<li><code>1 &lt;= targetIndices.length &lt;= n</code></li>
	<li><code>targetIndices</code> is sorted in ascending order.</li>
	<li>The input is generated such that <code>targetIndices</code> contains distinct elements in the range <code>[0, n - 1]</code>.</li>
	<li><code>source</code> and <code>pattern</code> consist only of lowercase English letters.</li>
	<li>The input is generated such that <code>pattern</code> appears as a subsequence in <code>source</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-58">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-median-from-data-stream/description" target="_blank" rel="noopener noreferrer">Find Median from Data Stream</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">data stream</span> <span class="topic-badge">design</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>

<ul>
	<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>
	<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>
</ul>

<p>Implement the MedianFinder class:</p>

<ul>
	<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>
	<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>
	<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]
[[], [1], [2], [], [3], []]
<strong>Output</strong>
[null, null, null, 1.5, null, 2.0]

<strong>Explanation</strong>
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>-10<sup>5</sup> &lt;= num &lt;= 10<sup>5</sup></code></li>
	<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>
	<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
	<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-59">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-pair-with-sum-k-in-an-absolute-sorted-array/1" target="_blank" rel="noopener noreferrer">Find pair with sum target in an absolute sorted array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 18px; vertical-align: baseline; color: #273239; font-family: Nunito, sans-serif; letter-spacing: 0.162px; background-color: #ffffff;">Given an absolute sorted array <strong>arr[]</strong> and an integer <strong>target. </strong>You have to find a pair of elements in the given array that sum to </span><strong style="color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">target</strong><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">. An absolute sorted array is an array of numbers in which </span><strong style="color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">|arr[i]| &lt;= |arr[j]</strong><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">| whenever </span><strong style="color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">i &lt; j</strong><span style="background-color: #ffffff; color: #273239; font-family: Nunito, sans-serif; font-size: 18px; letter-spacing: 0.162px;">. You can return the pair in any order.</span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong>&nbsp;Inputs are given such that only one valid answer exists.</span></p>
<p><strong style="font-size: 18px;">Examples:</strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">arr[] = [-49, 75, 103, -147, 164, -197, -238, 314, 348, -422], target = 167</span><span style="font-size: 18px;">
<strong>Output: </strong>[-147, 314]<strong>
Explanation: </strong></span><span style="font-size: 18px;">Pair with sum equal to 167 is (-147, 314).</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [2, -3, 4], target = 8<br /><strong>Output: </strong>[]<strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">No pair exists with sum equal to 8.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [-8, 10, 12, -15, 24],</span><span style="font-size: 18px;"> target = 22<br /></span><span style="font-size: 18px;"><strong>Output: </strong>[12, 10]</span><span style="font-size: 14pt;"><strong>
Explanation: </strong></span><span style="font-size: 18.6667px;">Pair with sum equal to 22 is (12, 10).</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>1 &lt;= arr.size() &lt;= 10<sup>5</sup><strong><br /></strong></span><span style="font-size: 18px;">-10<sup>4</sup> &lt;= arr[i] </span><span style="font-size: 18px;">&lt;= 10<sup>4</sup></span><span style="font-size: 18px;"><br /></span><span style="font-size: 18px;">-10<sup>4</sup> &lt;= K &lt;= 10<sup>4</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-60">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/description" target="_blank" rel="noopener noreferrer">Find Positive Integer Solution for a Given Equation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">interactive</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a callable function <code>f(x, y)</code> <strong>with a hidden formula</strong> and a value <code>z</code>, reverse engineer the formula and return <em>all positive integer pairs </em><code>x</code><em> and </em><code>y</code><em> where </em><code>f(x,y) == z</code>. You may return the pairs in any order.</p>

<p>While the exact formula is hidden, the function is monotonically increasing, i.e.:</p>

<ul>
	<li><code>f(x, y) &lt; f(x + 1, y)</code></li>
	<li><code>f(x, y) &lt; f(x, y + 1)</code></li>
</ul>

<p>The function interface is defined like this:</p>

<pre>
interface CustomFunction {
public:
  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.
  int f(int x, int y);
};
</pre>

<p>We will judge your solution as follows:</p>

<ul>
	<li>The judge has a list of <code>9</code> hidden implementations of <code>CustomFunction</code>, along with a way to generate an <strong>answer key</strong> of all valid pairs for a specific <code>z</code>.</li>
	<li>The judge will receive two inputs: a <code>function_id</code> (to determine which implementation to test your code with), and the target <code>z</code>.</li>
	<li>The judge will call your <code>findSolution</code> and compare your results with the <strong>answer key</strong>.</li>
	<li>If your results match the <strong>answer key</strong>, your solution will be <code>Accepted</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> function_id = 1, z = 5
<strong>Output:</strong> [[1,4],[2,3],[3,2],[4,1]]
<strong>Explanation:</strong> The hidden formula for function_id = 1 is f(x, y) = x + y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=4 -&gt; f(1, 4) = 1 + 4 = 5.
x=2, y=3 -&gt; f(2, 3) = 2 + 3 = 5.
x=3, y=2 -&gt; f(3, 2) = 3 + 2 = 5.
x=4, y=1 -&gt; f(4, 1) = 4 + 1 = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> function_id = 2, z = 5
<strong>Output:</strong> [[1,5],[5,1]]
<strong>Explanation:</strong> The hidden formula for function_id = 2 is f(x, y) = x * y.
The following positive integer values of x and y make f(x, y) equal to 5:
x=1, y=5 -&gt; f(1, 5) = 1 * 5 = 5.
x=5, y=1 -&gt; f(5, 1) = 5 * 1 = 5.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= function_id &lt;= 9</code></li>
	<li><code>1 &lt;= z &lt;= 100</code></li>
	<li>It is guaranteed that the solutions of <code>f(x, y) == z</code> will be in the range <code>1 &lt;= x, y &lt;= 1000</code>.</li>
	<li>It is also guaranteed that <code>f(x, y)</code> will fit in 32 bit signed integer if <code>1 &lt;= x, y &lt;= 1000</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-61">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-array-concatenation-value/description" target="_blank" rel="noopener noreferrer">Find the Array Concatenation Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>The <strong>concatenation</strong> of two numbers is the number formed by concatenating their numerals.</p>

<ul>
	<li>For example, the concatenation of <code>15</code>, <code>49</code> is <code>1549</code>.</li>
</ul>

<p>The <strong>concatenation value</strong> of <code>nums</code> is initially equal to <code>0</code>. Perform this operation until <code>nums</code> becomes empty:</p>

<ul>
	<li>If <code>nums</code> has a size greater than one, add the value of the concatenation of the first and the last element to the <strong>concatenation value</strong> of <code>nums</code>, and remove those two elements from <code>nums</code>. For example, if the <code>nums</code> was <code>[1, 2, 4, 5, 6]</code>, add 16 to the <code>concatenation value</code>.</li>
	<li>If only one element exists in <code>nums</code>, add its value to the <strong>concatenation value</strong> of <code>nums</code>, then remove it.</li>
</ul>

<p>Return<em> the concatenation value of <code>nums</code></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,52,2,4]
<strong>Output:</strong> 596
<strong>Explanation:</strong> Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,14,13,8,12]
<strong>Output:</strong> 673
<strong>Explanation:</strong> Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-62">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-distance-value-between-two-arrays/description" target="_blank" rel="noopener noreferrer">Find the Distance Value Between Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>arr1</code> and <code>arr2</code>, and the integer <code>d</code>, <em>return the distance value between the two arrays</em>.</p>

<p>The distance value is defined as the number of elements <code>arr1[i]</code> such that there is not any element <code>arr2[j]</code> where <code>|arr1[i]-arr2[j]| &lt;= d</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
For arr1[0]=4 we have: 
|4-10|=6 &gt; d=2 
|4-9|=5 &gt; d=2 
|4-1|=3 &gt; d=2 
|4-8|=4 &gt; d=2 
For arr1[1]=5 we have: 
|5-10|=5 &gt; d=2 
|5-9|=4 &gt; d=2 
|5-1|=4 &gt; d=2 
|5-8|=3 &gt; d=2
For arr1[2]=8 we have:
<strong>|8-10|=2 &lt;= d=2</strong>
<strong>|8-9|=1 &lt;= d=2</strong>
|8-1|=7 &gt; d=2
<strong>|8-8|=0 &lt;= d=2</strong>
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>
	<li><code>-1000 &lt;= arr1[i], arr2[j] &lt;= 1000</code></li>
	<li><code>0 &lt;= d &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-63">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-duplicate-number/description" target="_blank" rel="noopener noreferrer">Find the Duplicate Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>

<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>

<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and using only constant extra space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,4,2,2]
<strong>Output:</strong> 2
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,3,4,2]
<strong>Output:</strong> 3
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,3,3,3]
<strong>Output:</strong> 3</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>nums.length == n + 1</code></li>
	<li><code>1 &lt;= nums[i] &lt;= n</code></li>
	<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>
</ul>

<p>&nbsp;</p>
<p><b>Follow up:</b></p>

<ul>
	<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>
	<li>Can you solve the problem in linear runtime complexity?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-64">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description" target="_blank" rel="noopener noreferrer">Find the Index of the First Occurrence in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;
<strong>Output:</strong> -1
<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>
	<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-65">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-integer-added-to-array-ii/description" target="_blank" rel="noopener noreferrer">Find the Integer Added to Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>.</p>

<p>From <code>nums1</code> two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable <code>x</code>.</p>

<p>As a result, <code>nums1</code> becomes <strong>equal</strong> to <code>nums2</code>. Two arrays are considered <strong>equal</strong> when they contain the same integers with the same frequencies.</p>

<p>Return the <strong>minimum</strong> possible integer<em> </em><code>x</code><em> </em>that achieves this equivalence.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">nums1 = [4,20,16,12,8], nums2 = [14,18,10]</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">-2</span></p>

<p><strong>Explanation:</strong></p>

<p>After removing elements at indices <code>[0,4]</code> and adding -2, <code>nums1</code> becomes <code>[18,14,10]</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">nums1 = [3,5,5,3], nums2 = [7,7]</span></p>

<p><strong>Output:</strong> <span class="example-io" style="
    font-family: Menlo,sans-serif;
    font-size: 0.85rem;
">2</span></p>

<p><strong>Explanation:</strong></p>

<p>After removing elements at indices <code>[0,3]</code> and adding 2, <code>nums1</code> becomes <code>[7,7]</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums1.length &lt;= 200</code></li>
	<li><code>nums2.length == nums1.length - 2</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
	<li>The test cases are generated in a way that there is an integer <code>x</code> such that <code>nums1</code> can become equal to <code>nums2</code> by removing two elements and adding <code>x</code> to each element of <code>nums1</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-66">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/description" target="_blank" rel="noopener noreferrer">Find the Lexicographically Largest String From the Box I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>word</code>, and an integer <code>numFriends</code>.</p>

<p>Alice is organizing a game for her <code>numFriends</code> friends. There are multiple rounds in the game, where in each round:</p>

<ul>
	<li><code>word</code> is split into <code>numFriends</code> <strong>non-empty</strong> strings, such that no previous round has had the <strong>exact</strong> same split.</li>
	<li>All the split words are put into a box.</li>
</ul>

<p>Find the <span data-keyword="lexicographically-smaller-string">lexicographically largest</span> string from the box after all the rounds are finished.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word = &quot;dbca&quot;, numFriends = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;dbc&quot;</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>All possible splits are:</p>

<ul>
	<li><code>&quot;d&quot;</code> and <code>&quot;bca&quot;</code>.</li>
	<li><code>&quot;db&quot;</code> and <code>&quot;ca&quot;</code>.</li>
	<li><code>&quot;dbc&quot;</code> and <code>&quot;a&quot;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word = &quot;gggg&quot;, numFriends = 4</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;g&quot;</span></p>

<p><strong>Explanation:</strong>&nbsp;</p>

<p>The only possible split is: <code>&quot;g&quot;</code>, <code>&quot;g&quot;</code>, <code>&quot;g&quot;</code>, and <code>&quot;g&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 5&nbsp;* 10<sup>3</sup></code></li>
	<li><code>word</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= numFriends &lt;= word.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-enumeration">Approach 1: Enumeration</h3>
<h4 id="intuition">Intuition</h4>
<p>When <span class="math inline">\(\textit{numFriends} = 1\)</span>, we simply return the entire <span class="math inline">\(\textit{word}\)</span>.</p>
<p>When <span class="math inline">\(\textit{numFriends} > 1\)</span>, we consider all substrings starting at index <span class="math inline">\(i\)</span>. Under the constraints of the problem, the maximum length of such a substring is <span class="math inline">\(\min(n - \textit{numFriends} + 1, n - i)\)</span>. Among substrings of a fixed starting index, longer substrings have higher lexicographical order. Therefore, we can iterate over all starting indices <span class="math inline">\(i\)</span> from <span class="math inline">\(0\)</span> to <span class="math inline">\(n - 1\)</span>, extract the substring of length <span class="math inline">\(\min(n - \textit{numFriends} + 1, n - i)\)</span> starting at <span class="math inline">\(i\)</span>, and return the lexicographically largest substring among them.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Mis8AqBb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(\textit{word}\)</span>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We need to enumerate all substrings that meet the problem’s conditions. Since there are up to <span class="math inline">\(n\)</span> possible starting indices and for each we may extract a substring of up to <span class="math inline">\(O(n)\)</span> length, the overall time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity depends on how the language handles string slicing:</p>
<ul>
<li>
<p>In languages where slicing creates a new copy of the substring (e.g., C++, Java), the space complexity is <span class="math inline">\(O(n)\)</span> due to the storage of temporary substrings.</p>
</li>
<li>
<p>In languages where slicing creates a view or reference without copying (e.g., Python), the space complexity can be considered <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<blockquote>
<p><strong>Note:</strong> To fully understand the two-pointer method used here, it's essential to first solve <a href="https://leetcode.com/problems/last-substring-in-lexicographical-order/">1163. Last Substring in Lexicographical Order</a>, which introduces the core idea behind this technique.</p>
</blockquote>
<p>As in Approach 1, when <span class="math inline">\(\textit{numFriends} > 1\)</span>, if the left endpoint of the lexicographically largest suffix of the string is <span class="math inline">\(i\)</span>, then the substring <span class="math inline">\(s_i\)</span> which starts at index <span class="math inline">\(i\)</span> and has length <span class="math inline">\(\min(n - \textit{numFriends} + 1, n - i)\)</span> will be the lexicographically largest substring that satisfies the problem's constraints.</p>
<p>We use a proof by contradiction to verify this. Suppose there exists another valid substring <span class="math inline">\(s_j\)</span>, starting at index <span class="math inline">\(j\)</span>, such that <span class="math inline">\(s_j > s_i\)</span> lexicographically. We consider two cases:</p>
<ul>
<li>
<p>Case 1: <span class="math inline">\(s_i\)</span> is a suffix substring<br />
That is, <span class="math inline">\(n - \textit{numFriends} + 1 \geq n - i\)</span>. Then <span class="math inline">\(s_i\)</span> spans to the end of the string, and <span class="math inline">\(s_j > s_i\)</span> contradicts the assumption that <span class="math inline">\(s_i\)</span> is the lexicographically largest suffix.</p>
</li>
<li>
<p>Case 2: <span class="math inline">\(s_i\)</span> is not a suffix substring<br />
That is, <span class="math inline">\(n - \textit{numFriends} + 1 < n - i\)</span>, meaning <span class="math inline">\(s_i\)</span> is shorter than the entire suffix. Since <span class="math inline">\(s_j\)</span> must also be of length at most <span class="math inline">\(n - \textit{numFriends} + 1\)</span>, it is no longer than <span class="math inline">\(s_i\)</span>. If <span class="math inline">\(s_j > s_i\)</span>, it must differ at some position where the character in <span class="math inline">\(s_j\)</span> is greater than that in <span class="math inline">\(s_i\)</span>. This implies that the suffix starting at <span class="math inline">\(j\)</span> is greater than the suffix starting at <span class="math inline">\(i\)</span>, which again contradicts the assumption that the suffix starting at <span class="math inline">\(i\)</span> is the lexicographically largest.</p>
</li>
</ul>
<p>Therefore, <span class="math inline">\(s_i\)</span> must indeed produce the answer.</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/FaCgNtGs/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <span class="math inline">\(\textit{word}\)</span>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The two pointers together traverse at most <span class="math inline">\(n\)</span> characters. Each character is compared only a constant number of times, so the overall time complexity is linear.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity depends on the language's string handling behavior.</p>
<ul>
<li>
<p>In languages where string slicing creates a new copy (e.g., C++, Java), the space complexity is <span class="math inline">\(O(n)\)</span> in the worst case due to substring creation.</p>
</li>
<li>
<p>In languages where string slices are views or references (e.g., Python), the space overhead can be considered <span class="math inline">\(O(1)\)</span> since no new characters are copied.</p>
</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-67">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-lexicographically-smallest-valid-sequence/description" target="_blank" rel="noopener noreferrer">Find the Lexicographically Smallest Valid Sequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>word1</code> and <code>word2</code>.</p>

<p>A string <code>x</code> is called <strong>almost equal</strong> to <code>y</code> if you can change <strong>at most</strong> one character in <code>x</code> to make it <em>identical</em> to <code>y</code>.</p>

<p>A sequence of indices <code>seq</code> is called <strong>valid</strong> if:</p>

<ul>
	<li>The indices are sorted in <strong>ascending</strong> order.</li>
	<li><em>Concatenating</em> the characters at these indices in <code>word1</code> in <strong>the same</strong> order results in a string that is <strong>almost equal</strong> to <code>word2</code>.</li>
</ul>

<p>Return an array of size <code>word2.length</code> representing the <span data-keyword="lexicographically-smaller-array">lexicographically smallest</span> <strong>valid</strong> sequence of indices. If no such sequence of indices exists, return an <strong>empty</strong> array.</p>

<p><strong>Note</strong> that the answer must represent the <em>lexicographically smallest array</em>, <strong>not</strong> the corresponding string formed by those indices.<!-- notionvc: 2ff8e782-bd6f-4813-a421-ec25f7e84c1e --></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word1 = &quot;vbcca&quot;, word2 = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1,2]</span></p>

<p><strong>Explanation:</strong></p>

<p>The lexicographically smallest valid sequence of indices is <code>[0, 1, 2]</code>:</p>

<ul>
	<li>Change <code>word1[0]</code> to <code>&#39;a&#39;</code>.</li>
	<li><code>word1[1]</code> is already <code>&#39;b&#39;</code>.</li>
	<li><code>word1[2]</code> is already <code>&#39;c&#39;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word1 = &quot;bacdc&quot;, word2 = &quot;abc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[1,2,4]</span></p>

<p><strong>Explanation:</strong></p>

<p>The lexicographically smallest valid sequence of indices is <code>[1, 2, 4]</code>:</p>

<ul>
	<li><code>word1[1]</code> is already <code>&#39;a&#39;</code>.</li>
	<li>Change <code>word1[2]</code> to <code>&#39;b&#39;</code>.</li>
	<li><code>word1[4]</code> is already <code>&#39;c&#39;</code>.</li>
</ul>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word1 = &quot;aaaaaa&quot;, word2 = &quot;aaabc&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[]</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no valid sequence of indices.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">word1 = &quot;abc&quot;, word2 = &quot;ab&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">[0,1]</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word2.length &lt; word1.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>word1</code> and <code>word2</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-68">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/find-the-maximum-number-of-marked-indices/description" target="_blank" rel="noopener noreferrer">Find the Maximum Number of Marked Indices</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>

<p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p>

<ul>
	<li>Pick two <strong>different unmarked</strong> indices <code>i</code> and <code>j</code> such that <code>2 * nums[i] &lt;= nums[j]</code>, then mark <code>i</code> and <code>j</code>.</li>
</ul>

<p>Return <em>the maximum possible number of marked indices in <code>nums</code> using the above operation any number of times</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,4]
<strong>Output:</strong> 2
<strong>Explanation: </strong>In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] &lt;= nums[1]. Then mark index 2 and 1.
It can be shown that there&#39;s no other valid operation so the answer is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,2,5,4]
<strong>Output:</strong> 4
<strong>Explanation: </strong>In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] &lt;= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] &lt;= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [7,6,8]
<strong>Output:</strong> 0
<strong>Explanation: </strong>There is no valid operation to do, so the answer is 0.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<style type="text/css">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; 
}
.spoiler {overflow:hidden;}
.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}
.spoilerbutton[value="Show Message"] + .spoiler > div {margin-top:-500%;}
.spoilerbutton[value="Hide Message"] + .spoiler {padding:5px;}
</style>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-69">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/find-triplets-with-zero-sum/1" target="_blank" rel="noopener noreferrer">Find triplets with zero sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">searching</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array&nbsp;<strong>arr[]</strong> of integers, determine whether it contains a triplet whose sum equals zero. Return <strong>true</strong>&nbsp;if such a triplet exists, otherwise, return <strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [0, -1, 2, -3, 1]<br /><strong>Output</strong>: true
<strong>Explanation</strong>: The triplet [0, -1, 1] <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">has a sum equal to zero.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 2, 3]<br /><strong>Output</strong>: false
<strong>Explanation</strong>: No triplet with a sum of zero exists.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [-5, 3, 2, -1, 0, 1]<br /><strong>Output</strong>: true
<strong>Explanation</strong>: The triplet [-5, 3, 2]<span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;"> has a sum equal to zero.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints</strong><strong>:</strong><br />1 &le; arr.size() &le; 10<sup>3</sup></span><br /><span style="font-size: 14pt;">-10<sup>6</sup> &le; arr[i] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-70">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/first-negative-integer-in-every-window-of-size-k3345/1" target="_blank" rel="noopener noreferrer">First negative in every window of size k</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">queue</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[] </strong>&nbsp;and a positive integer <strong>k</strong>, find the first negative integer for each and every window(contiguous subarray) of size <strong>k.</strong></span></p>
<p><span style="font-size: 18px;"><strong>Note:</strong></span><span style="font-size: 18px;">&nbsp;</span><span style="font-size: 18px;">If a window does not contain a negative integer, then return 0 for that window.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">arr[] = [-8, 2, 3, -6, 10] , k = 2
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">[-8, 0, -6, -6]
</span><strong style="font-size: 18px;">Explanation:</strong><span style="font-size: 18px;">
Window [-8, 2] First negative integer is -8.
Window [2, 3] No negative integers, output is 0.
Window [3, -6] First negative integer is -6.
Window [-6, 10] First negative integer is -6.<br /></span></span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">arr[] = [12, -1, -7, 8, -15, 30, 16, 28] , k = 3
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">[-1, -1, -7, -15, -15, 0] <br /></span><strong style="font-size: 18px;">Explanation:<br /></strong><span style="font-size: 18px;">Window [12, -1, -7] First negative integer is -1.
Window [-1, -7, 8] First negative integer is -1.
Window [-7, 8, -15] First negative integer is -7.
Window [8, -15, 30] First negative integer is -15.
Window [-15, 30, 16] First negative integer is -15.
Window [30, 16, 28] No negative integers, output is 0.<br /></span></span></pre>
<pre><span style="font-size: 18px;"><strong style="font-size: 18px;">Input: </strong><span style="font-size: 18px;">arr[] = [12, 1, 3, 5] , k = 3
</span><strong style="font-size: 18px;">Output: </strong><span style="font-size: 18px;">[0, 0] <br /></span><strong style="font-size: 18px;">Explanation:<br /></strong><span style="font-size: 18px;">Window [12, 1, 3] No negative integers, output is 0.
Window [1, 3, 5] No negative integers, output is 0.</span></span></pre>
<p><span style="font-size: 18px;"><br /><strong>Constraints:</strong><br />1 &lt;= arr.size() &lt;= 10<sup>6</sup><br />-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup><br />1 &lt;= k &lt;= arr.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-71">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flipping-an-image/description" target="_blank" rel="noopener noreferrer">Flipping an Image</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an <code>n x n</code> binary matrix <code>image</code>, flip the image <strong>horizontally</strong>, then invert it, and return <em>the resulting image</em>.</p>

<p>To flip an image horizontally means that each row of the image is reversed.</p>

<ul>
	<li>For example, flipping <code>[1,1,0]</code> horizontally results in <code>[0,1,1]</code>.</li>
</ul>

<p>To invert an image means that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>.</p>

<ul>
	<li>For example, inverting <code>[0,1,1]</code> results in <code>[1,0,0]</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> image = [[1,1,0],[1,0,1],[0,0,0]]
<strong>Output:</strong> [[1,0,0],[0,1,0],[1,1,1]]
<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
<strong>Output:</strong> [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == image.length</code></li>
	<li><code>n == image[i].length</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>images[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We can do this in place.  In each row, the <code>i</code>th value from the left is equal to the inverse of the <code>i</code>th value from the right.</p>
<p>We use <code>(C+1) / 2</code> (with floor division) to iterate over all indexes <code>i</code> in the first half of the row, including the center.</p>
<p><a href="https://leetcode.com/playground/8fjB4LMj/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <code>N</code> is the total number of elements in <code>A</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span> in <em>additional</em> space complexity.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-72">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/flip-square-submatrix-vertically/description" target="_blank" rel="noopener noreferrer">Flip Square Submatrix Vertically</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code>, and three integers <code>x</code>, <code>y</code>, and <code>k</code>.</p>

<p>The integers <code>x</code> and <code>y</code> represent the row and column indices of the <strong>top-left</strong> corner of a <strong>square</strong> submatrix and the integer <code>k</code> represents the size (side length) of the square submatrix.</p>

<p>Your task is to flip the submatrix by reversing the order of its rows vertically.</p>

<p>Return the updated matrix.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/07/20/gridexmdrawio.png" style="width: 300px; height: 116px;" />
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = </span>[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]<span class="example-io">, x = 1, y = 0, k = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">[[1,2,3,4],[13,14,15,8],[9,10,11,12],[5,6,7,16]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The diagram above shows the grid before and after the transformation.</p>
</div>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/07/20/gridexm2drawio.png" style="width: 350px; height: 68px;" />​​​​​​​
<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[3,4,2,3],[2,3,4,2]], x = 0, y = 2, k = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">[[3,4,4,2],[2,3,2,3]]</span></p>

<p><strong>Explanation:</strong></p>

<p>The diagram above shows the grid before and after the transformation.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 50</code></li>
	<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
	<li><code>0 &lt;= x &lt; m</code></li>
	<li><code>0 &lt;= y &lt; n</code></li>
	<li><code>1 &lt;= k &lt;= min(m - x, n - y)</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-73">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/description" target="_blank" rel="noopener noreferrer">Form Array by Concatenating Subarrays of Another Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 2D integer array <code>groups</code> of length <code>n</code>. You are also given an integer array <code>nums</code>.</p>

<p>You are asked if you can choose <code>n</code> <strong>disjoint </strong>subarrays from the array <code>nums</code> such that the <code>i<sup>th</sup></code> subarray is equal to <code>groups[i]</code> (<b>0-indexed</b>), and if <code>i &gt; 0</code>, the <code>(i-1)<sup>th</sup></code> subarray appears <strong>before</strong> the <code>i<sup>th</sup></code> subarray in <code>nums</code> (i.e. the subarrays must be in the same order as <code>groups</code>).</p>

<p>Return <code>true</code> <em>if you can do this task, and</em> <code>false</code> <em>otherwise</em>.</p>

<p>Note that the subarrays are <strong>disjoint</strong> if and only if there is no index <code>k</code> such that <code>nums[k]</code> belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]
<strong>Output:</strong> true
<strong>Explanation:</strong> You can choose the 0<sup>th</sup> subarray as [1,-1,0,<u><strong>1,-1,-1</strong></u>,3,-2,0] and the 1<sup>st</sup> one as [1,-1,0,1,-1,-1,<u><strong>3,-2,0</strong></u>].
These subarrays are disjoint as they share no common nums[k] element.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]
<strong>Output:</strong> false
<strong>Explanation: </strong>Note that choosing the subarrays [<u><strong>1,2,3,4</strong></u>,10,-2] and [1,2,3,4,<u><strong>10,-2</strong></u>] is incorrect because they are not in the same order as in groups.
[10,-2] must come before [1,2,3,4].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]
<strong>Output:</strong> false
<strong>Explanation: </strong>Note that choosing the subarrays [7,7,<u><strong>1,2,3</strong></u>,4,7,7] and [7,7,1,2,<u><strong>3,4</strong></u>,7,7] is invalid because they are not disjoint.
They share a common elements nums[4] (0-indexed).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>groups.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>
	<li><code>1 &lt;= groups[i].length, sum(groups[i].length) &lt;= 10<sup><span style="font-size: 10.8333px;">3</span></sup></code></li>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>3</sup></code></li>
	<li><code>-10<sup>7</sup> &lt;= groups[i][j], nums[k] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-74">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/friends-of-appropriate-ages/description" target="_blank" rel="noopener noreferrer">Friends Of Appropriate Ages</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> persons on a social media website. You are given an integer array <code>ages</code> where <code>ages[i]</code> is the age of the <code>i<sup>th</sup></code> person.</p>

<p>A Person <code>x</code> will not send a friend request to a person <code>y</code> (<code>x != y</code>) if any of the following conditions is true:</p>

<ul>
	<li><code>age[y] &lt;= 0.5 * age[x] + 7</code></li>
	<li><code>age[y] &gt; age[x]</code></li>
	<li><code>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</code></li>
</ul>

<p>Otherwise, <code>x</code> will send a friend request to <code>y</code>.</p>

<p>Note that if <code>x</code> sends a request to <code>y</code>, <code>y</code> will not necessarily send a request to <code>x</code>. Also, a person will not send a friend request to themself.</p>

<p>Return <em>the total number of friend requests made</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> ages = [16,16]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 2 people friend request each other.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> ages = [16,17,18]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Friend requests are made 17 -&gt; 16, 18 -&gt; 17.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> ages = [20,30,100,110,120]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == ages.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= ages[i] &lt;= 120</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-75">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/get-the-maximum-score/description" target="_blank" rel="noopener noreferrer">Get the Maximum Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>sorted</strong> arrays of distinct integers <code>nums1</code> and <code>nums2</code>.</p>

<p>A <strong>valid<strong><em> </em></strong>path</strong> is defined as follows:</p>

<ul>
	<li>Choose array <code>nums1</code> or <code>nums2</code> to traverse (from index-0).</li>
	<li>Traverse the current array from left to right.</li>
	<li>If you are reading any value that is present in <code>nums1</code> and <code>nums2</code> you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).</li>
</ul>

<p>The <strong>score</strong> is defined as the sum of unique values in a valid path.</p>

<p>Return <em>the maximum score you can obtain of all possible <strong>valid paths</strong></em>. Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/07/16/sample_1_1893.png" style="width: 500px; height: 151px;" />
<pre>
<strong>Input:</strong> nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
<strong>Output:</strong> 30
<strong>Explanation:</strong> Valid paths:
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)
The maximum is obtained with the path in green <strong>[2,4,6,8,10]</strong>.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,3,5,7,9], nums2 = [3,5,100]
<strong>Output:</strong> 109
<strong>Explanation:</strong> Maximum sum is obtained with the path <strong>[1,3,5,100]</strong>.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
<strong>Output:</strong> 40
<strong>Explanation:</strong> There are no common elements between nums1 and nums2.
Maximum sum is obtained with the path [6,7,8,9,10].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>nums1</code> and <code>nums2</code> are strictly increasing.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-76">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/happy-number/description" target="_blank" rel="noopener noreferrer">Happy Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write an algorithm to determine if a number <code>n</code> is happy.</p>

<p>A <strong>happy number</strong> is a number defined by the following process:</p>

<ul>
	<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
	<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>
	<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>
</ul>

<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 19
<strong>Output:</strong> true
<strong>Explanation:</strong>
1<sup>2</sup> + 9<sup>2</sup> = 82
8<sup>2</sup> + 2<sup>2</sup> = 68
6<sup>2</sup> + 8<sup>2</sup> = 100
1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 2
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-77">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/heaters/description" target="_blank" rel="noopener noreferrer">Heaters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</p>

<p>Every house can be warmed, as long as the house is within the heater&#39;s warm radius range.&nbsp;</p>

<p>Given the positions of <code>houses</code> and <code>heaters</code> on a horizontal line, return <em>the minimum radius standard of heaters&nbsp;so that those heaters could cover all houses.</em></p>

<p><strong>Notice</strong> that&nbsp;all the <code>heaters</code> follow your radius standard, and the warm radius will be the same.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,2,3], heaters = [2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,2,3,4], heaters = [1,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> houses = [1,5], heaters = [2]
<strong>Output:</strong> 3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= houses[i], heaters[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-78">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-arrays/description" target="_blank" rel="noopener noreferrer">Intersection of Two Arrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their <span data-keyword="array-intersection">intersection</span></em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [9,4]
<strong>Explanation:</strong> [4,9] is also accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sorting-and-two-pointers">Approach 1: Sorting and Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>If <code>nums1</code> and <code>nums2</code> are sorted, we can use a two pointers approach to find elements that appear in both arrays. Initialize one pointer for each array that starts at the smallest element.</p>
<p>If the numbers at both pointers are the same, add the number to a set that stores integers that appear in both arrays. Then, increase both pointers by <span class="math inline">\(1\)</span>, since this element is already processed.</p>
<p>Otherwise, if the numbers at both pointers are not equal, the smaller of the two values cannot appear in the other array because both arrays are sorted. Therefore, we can increase the pointer of the smaller value.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Sort <code>nums1</code> and <code>nums2</code> arrays.</li>
<li>Create a pointer for each array, initially set to <span class="math inline">\(0\)</span>.</li>
<li>Initialize an empty set that stores intersecting integers.</li>
<li>If the integers at both pointers equal the same value, add this value to the intersecting set and increment both pointers.</li>
<li>Otherwise, increment the pointer that points to the smaller integer value.</li>
<li>Repeat steps 4 and 5 until a pointer is out of bounds.</li>
<li>Convert the intersection set into an array.</li>
<li>Return the resulting array.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/esWGp92Z/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + m \log m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths. This dominating term comes from the need to sort both input arrays at the beginning of the solution.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\min(m, n))\)</span> in the worst case when all elements in the smaller array are unique and present in the larger array. This space is necessary to store elements in the set <code>intersection</code>.</p>
<ul>
<li>The space used to store the result array is counted in the space complexity, making the worst case <span class="math inline">\(O(\min(m, n))\)</span>.</li>
<li>Some extra space is used when sorting the arrays in place, and the space complexity depends on the programming language:
<ul>
<li>In Python, the <code>sort()</code> method uses the Timsort algorithm, which requires O(n) additional space in the worst case.</li>
<li>In Java, <code>Arrays.sort()</code> for primitive types uses a Dual-Pivot QuickSort, which has a worst-case space complexity of O(\log n) due to recursion.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-2-built-in-set-intersection">Approach 2: Built-in Set Intersection</h3>
<h4 id="intuition-1">Intuition</h4>
<p>There are built-in intersection facilities, which provide <span class="math inline">\(O(n + m)\)</span> time complexity in the average case and <span class="math inline">\(O(n \times m)\)</span> time complexity in the worst case.</p>
<blockquote>
<p>In Python it's the <a href="https://wiki.python.org/moin/TimeComplexity#set">intersection operator</a>, and in Java it's the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html#retainAll-java.util.Collection-">retainAll() function</a>.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add all elements of <code>nums1</code> to it.</li>
<li>Initialize a set <code>set2</code> and add all elements of <code>nums2</code> to it.</li>
<li>Call the built-in set intersection method (either <code>retainAll()</code> in Java, or <code>&amp;</code> operator in Python).</li>
<li>Transform the resulting set into an array and return this result.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/C2TF5Yk6/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths in the average case and <span class="math inline">\(O(n \times m)\)</span> <a href="https://wiki.python.org/moin/TimeComplexity#set">in the worst case when the load factor is high enough</a>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span> because in the worst case, when all elements in the arrays are unique, <span class="math inline">\(n\)</span> space is used to store <code>set1</code> and <span class="math inline">\(m\)</span> space is used to store <code>set2</code>. The space used to store the result is not counted in the space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-sets">Approach 3: Two Sets</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The naive approach would be to iterate through the values in the first array, <code>nums1</code>, and check whether each one is in <code>nums2</code>. If yes, add the value to the output. Such an approach would result in a less efficient solution.</p>
<blockquote>
<p>To solve the problem in linear time, let's use the data structure <code>set</code>, which provides <code>in/contains</code> operations in <span class="math inline">\(O(1)\)</span> time in the average case.</p>
</blockquote>
<p>The idea is to convert both arrays into sets and then iterate over the smallest set while checking the presence of each element in the larger set.</p>
<p>!?!../Documents/349_LIS.json:1000,352!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add all elements of <code>nums1</code> to it.</li>
<li>Initialize a set <code>set2</code> and add all elements of <code>nums2</code> to it.</li>
<li>If <code>set1</code> has more elements than <code>set2</code>, swap them.</li>
<li>For each element in <code>set1</code>, add it to the result array if it also appears in <code>set2</code>.</li>
<li>Result the result array.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/RAoCNPwG/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span>, where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are the arrays' lengths. <span class="math inline">\(O(n)\)</span> time is used to convert <code>nums1</code> into a set, <span class="math inline">\(O(m)\)</span> time is used to convert <code>nums2</code>, and <code>contains/in</code> operations are <span class="math inline">\(O(1)\)</span> in the average case.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m + n)\)</span> because in the worst case, when all elements in the arrays are unique, <span class="math inline">\(n\)</span> space is used to store <code>set1</code> and <span class="math inline">\(m\)</span> space is used to store <code>set2</code>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-one-dictionary">Approach 4: One Dictionary</h3>
<h4 id="intuition-3">Intuition</h4>
<p>This approach uses only one additional data structure and one pass through each of <code>nums1</code> and <code>nums2</code>. The idea is to use a dictionary/map rather than a set to store information about values that appear in each array.</p>
<p>Define this dictionary as <code>seen</code>, where the key is an element that exists in one or both input arrays, and the value stores either <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>. A number <code>x</code> appears as a key in this dictionary, indicating it is present in at least one array, and the value of the key indicates if <code>x</code> has been observed in both arrays and added to the <code>result</code> array.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize a dictionary/map <code>seen</code> and the <code>result</code> array.</li>
<li>For each <code>x</code> in <code>nums1</code>, set <code>seen[x]</code> to <span class="math inline">\(1\)</span>.</li>
<li>For each <code>x</code> in <code>nums2</code>, add <code>x</code> to <code>result</code> if <code>seen[x]</code> equals <span class="math inline">\(1\)</span>. Then, set <code>seen[x]</code> to <span class="math inline">\(0\)</span>, as this element has already been included in the result.</li>
<li>Result the result array.</li>
</ol>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/6m6gWp2U/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span> in the average case and <span class="math inline">\(O(n \times m)\)</span> <a href="https://wiki.python.org/moin/TimeComplexity#set">in the worst case when the load factor is high enough</a>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> because we use a map of size <span class="math inline">\(n\)</span> store the elements from <code>nums1</code>. The <code>result</code> array is just used to store the result, so it is not counted in the space complexity.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-79">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-arrays-ii/description" target="_blank" rel="noopener noreferrer">Intersection of Two Arrays II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [4,9]
<strong>Explanation:</strong> [9,4] is also accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
	<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>
	<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-80">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/intersection-of-two-arrays-with-duplicate-elements/1" target="_blank" rel="noopener noreferrer">Intersection of Two arrays with Duplicate Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given two integer&nbsp;arrays&nbsp;<span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; font-family: var(--gfg-font-secondary) !important;">a[]</span>&nbsp;and&nbsp;<span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; font-family: var(--gfg-font-secondary) !important;">b[]</span>, you have to find&nbsp;the&nbsp;<span style="box-sizing: border-box; font-weight: bolder; line-height: 1.7em; color: var(--text-color) !important; font-family: var(--gfg-font-secondary) !important;">intersection</span>&nbsp;of the two arrays.&nbsp;</span><span style="font-size: 14pt;"><strong>Intersection</strong> of two arrays is said to be elements that are common in both the arrays. The intersection should not have <strong>duplicate</strong>&nbsp;elements and the result should contain items in&nbsp;<strong>any order</strong>.</span></p>
<p><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;"><strong>Note:&nbsp;</strong>The driver code will&nbsp;<strong>sort</strong>&nbsp;the resulting array in increasing order before printing.</span></p>
<p><span style="font-size: 14pt;"><strong><span style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;">Examples:</span></strong></span></p>
<pre><span style="font-size: 14pt;"><strong><span style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;">Input: </span></strong><span style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;">a[] = [1, 2, 1, 3, 1], b[] = [3, 1, 3, 4, 1]<br /><strong>Output: </strong>[1, 3]<br /><strong>Explanation: </strong>1 and 3 are the only common elements and we need to print only one occurrence of common elements.<br /></span></span></pre>
<pre><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;"><strong>Input: </strong>a[] = [1, 1, 1], b[] = [1, 1, 1, 1, 1]<br /><strong>Output: </strong>[1]<br /><strong>Explanation: </strong>1 is the only common element present in both the arrays.<br /></span></pre>
<pre><span style="box-sizing: border-box; line-height: 1.7em; font-size: 14pt; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;"><strong>Input: </strong>a[] = [1, 2, 3], b[] = [4, 5, 6]<br /><strong>Output: </strong>[]<br /><strong>Explanation: </strong>No common element in both the arrays.</span></pre>
<p><span style="font-size: 14pt;"><span style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;"><strong>Constraints:</strong><br />1 &le; a.size(), b.size() &le; 10<sup>5<br /></sup></span><span style="box-sizing: border-box; line-height: 1.7em; font-family: var(--gfg-font-primary) !important; color: var(--text-color) !important;">0 &le; a[i], b[i] &le; 10<sup>5</sup></span></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-81">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/intersection-of-two-linked-lists/description" target="_blank" rel="noopener noreferrer">Intersection of Two Linked Lists</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>

<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" style="width: 500px; height: 162px;" />
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>

<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>

<p><strong>Custom Judge:</strong></p>

<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>

<ul>
	<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>
	<li><code>listA</code> - The first linked list.</li>
	<li><code>listB</code> - The second linked list.</li>
	<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>
	<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>
</ul>

<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" style="width: 500px; height: 162px;" />
<pre>
<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>Output:</strong> Intersected at &#39;8&#39;
<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" style="width: 500px; height: 194px;" />
<pre>
<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>Output:</strong> Intersected at &#39;2&#39;
<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" style="width: 300px; height: 189px;" />
<pre>
<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>Output:</strong> No intersection
<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>
	<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>
	<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= skipA &lt;= m</code></li>
	<li><code>0 &lt;= skipB &lt;= n</code></li>
	<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>
	<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-82">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/interval-list-intersections/description" target="_blank" rel="noopener noreferrer">Interval List Intersections</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">line sweep</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two lists of closed intervals, <code>firstList</code> and <code>secondList</code>, where <code>firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> and <code>secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</p>

<p>Return <em>the intersection of these two interval lists</em>.</p>

<p>A <strong>closed interval</strong> <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>.</p>

<p>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code>[1, 3]</code> and <code>[2, 4]</code> is <code>[2, 3]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" style="width: 700px; height: 194px;" />
<pre>
<strong>Input:</strong> firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
<strong>Output:</strong> [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> firstList = [[1,3],[5,9]], secondList = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= firstList.length, secondList.length &lt;= 1000</code></li>
	<li><code>firstList.length + secondList.length &gt;= 1</code></li>
	<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
	<li><code>end<sub>i</sub> &lt; start<sub>i+1</sub></code></li>
	<li><code>0 &lt;= start<sub>j</sub> &lt; end<sub>j</sub> &lt;= 10<sup>9</sup> </code></li>
	<li><code>end<sub>j</sub> &lt; start<sub>j+1</sub></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-83">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/ishaan-loves-chocolates2156/1" target="_blank" rel="noopener noreferrer">Ishaan Loves Chocolates</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">As we know, Ishaan has a love for chocolates. He has bought a huge chocolate bar that contains N chocolate squares. Each of the squares has a tastiness level which is denoted by an array A[].<br />
Ishaan can eat the first or the last square of the chocolate at once. Ishaan has a sister who loves chocolates too and she demands the last chocolate square. Now, Ishaan being greedy eats the more tasty square first.&nbsp;<br />
Determine the tastiness level of the square which his sister gets.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input :</strong> arr[ ] = {5, 3, 1, 6, 9}
<strong>Output :</strong> 1
<strong>Explanation:
Initially: 5 3 1 6 9</strong>
In first step: 5 3 1 6
In Second step: 5 3 1
In Third step: 3 1
In Fourth step: 1
Return 1</span></pre>

<p><br />
<br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input :</strong> arr[ ] = {5, 9, 2, 6} <strong>
Output :</strong>  2

</span></pre>

<p><span style="font-size:18px"><strong>Your Task:</strong><br />
This is a function problem. The input is already taken care of by the driver code. You only need to complete the function <strong>chocolates()</strong> that takes an array <strong>(arr)</strong>, sizeOfArray <strong>(n)</strong>&nbsp;and return the tastiness level of the square which his sister gets. The driver code takes care of the printing.</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong>&nbsp;O(N).<br />
<strong>Expected Auxiliary Space:</strong>&nbsp;O(1).</span></p>

<p>&nbsp;</p>

<p><span style="font-size:18px"><strong>Constraints :&nbsp;</strong><br />
1 &le; N &le; 10<sup>5</sup><br />
1 &le; A[i] &le; 10<sup>9</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-84">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/is-subsequence/description" target="_blank" rel="noopener noreferrer">Is Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>

<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "abc", t = "ahbgdc"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "axc", t = "ahbgdc"
<strong>Output:</strong> false
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 100</code></li>
	<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-85">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-diff-pairs-in-an-array/description" target="_blank" rel="noopener noreferrer">K-diff Pairs in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of <b>unique</b> k-diff pairs in the array</em>.</p>

<p>A <strong>k-diff</strong> pair is an integer pair <code>(nums[i], nums[j])</code>, where the following are true:</p>

<ul>
	<li><code>0 &lt;= i, j &lt; nums.length</code></li>
	<li><code>i != j</code></li>
	<li><code>|nums[i] - nums[j]| == k</code></li>
</ul>

<p><strong>Notice</strong> that <code>|val|</code> denotes the absolute value of <code>val</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,4,1,5], k = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of <strong>unique</strong> pairs.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5], k = 1
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,1,5,4], k = 0
<strong>Output:</strong> 1
<strong>Explanation:</strong> There is one 0-diff pair in the array, (1, 1).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-86">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/k-th-smallest-prime-fraction/description" target="_blank" rel="noopener noreferrer">K-th Smallest Prime Fraction</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a sorted integer array <code>arr</code> containing <code>1</code> and <strong>prime</strong> numbers, where all the integers of <code>arr</code> are unique. You are also given an integer <code>k</code>.</p>

<p>For every <code>i</code> and <code>j</code> where <code>0 &lt;= i &lt; j &lt; arr.length</code>, we consider the fraction <code>arr[i] / arr[j]</code>.</p>

<p>Return <em>the</em> <code>k<sup>th</sup></code> <em>smallest fraction considered</em>. Return your answer as an array of integers of size <code>2</code>, where <code>answer[0] == arr[i]</code> and <code>answer[1] == arr[j]</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,5], k = 3
<strong>Output:</strong> [2,5]
<strong>Explanation:</strong> The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.
The third fraction is 2/5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,7], k = 1
<strong>Output:</strong> [1,7]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= arr.length &lt;= 1000</code></li>
	<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>arr[0] == 1</code></li>
	<li><code>arr[i]</code> is a <strong>prime</strong> number for <code>i &gt; 0</code>.</li>
	<li>All the numbers of <code>arr</code> are <strong>unique</strong> and sorted in <strong>strictly increasing</strong> order.</li>
	<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you solve the problem with better than <code>O(n<sup>2</sup>)</code> complexity?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the <code class="">k<sup>th</sup></code> smallest fraction formed by dividing elements at different indices of a sorted array containing only <code>1</code> and prime numbers. The task is to return an array of two elements representing the numerator and denominator of the <code class="">k<sup>th</sup></code> smallest fraction.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>To count the number of fractions smaller than a given fraction, we can iterate through the array and consider all possible pairs of indices <code>(i, j)</code> where <code>i &lt; j</code>. For each pair, we check if the fraction formed by <code>arr[i] / arr[j]</code> is smaller than the given fraction. If it is, we increment the count.</p>
<p>Since the array is sorted, we notice that if <code>arr[i] / arr[j]</code> is smaller than the given fraction, then all subsequent fractions formed by <code>arr[i] / arr[k]</code> where <code>k &gt; j</code> will also be smaller than the given fraction.</p>
<p>If we apply the above strategy, the fractions formed by dividing elements at different indices in the sorted array will maintain their sorted order. This enables us to efficiently solve the problem using binary search.</p>
<p>Now, the key question arises: How can we determine how many fractions are smaller than a given value? Since the array is sorted, we can count fractions by comparing their values against a reference value.</p>
<p>This reference value can be any fraction between <code>0</code> and <code>1</code>. As the array contains only <code>1</code> and prime numbers, we know that all the fractions will be between <code>0</code> and <code>1</code>. Therefore, we can set the initial search range to <code>[0, 1)</code>. We initialize two pointers, <code>left</code> and <code>right</code>, representing the lower and upper bounds of the possible fractions.</p>
<p>We use binary search to iteratively narrow down the search space for the <code class="">k<sup>th</sup></code> smallest fraction. At each step, we calculate the midpoint of the range (<code>mid</code>). Using a two-pointer approach, we compare each element of the array to <code>mid</code> and keep a count of how many fractions are smaller than or equal to it. This count helps in evaluating whether to adjust the left or right bounds of our search range and also ensures that we methodically pinpoint the precise <code class="">k<sup>th</sup></code> fraction by reducing the interval based on the number of smaller fractions found.</p>
<p>However, while iterating through the array, we're also exploring the set of possible fractions, gradually revealing the smallest fractions first. During this exploration, we maintain a record of the maximum fraction encountered so far within the current search range.</p>
<p>Now, why is this maximum fraction significant? In a sorted array of unique numbers, the fractions increase gradually as we move left to right. If we've encountered <code>k</code> or more fractions smaller than or equal to this maximum fraction, then this maximum fraction is the <code class="">k<sup>th</sup></code> smallest fraction.</p>
<p>Finally, we adjust the search range based on the count of smaller fractions. If the count equals <code>k</code>, we return the current maximum fraction as the <code class="">k<sup>th</sup></code> smallest fraction. If the count is greater than <code>k</code>, we move the right pointer to <code>mid</code>. Else, we move the left pointer to <code>mid</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize the variable <code>n</code> to store the size of the input array <code>arr</code>. Set <code>left</code> to 0 and <code>right</code> to 1.0 to establish the initial range for binary search.</li>
<li>Enter a binary search loop while the left boundary (<code>left</code>) is less than the right boundary (<code>right</code>).
<ul>
<li>Calculate the midpoint of the current range, denoted as <code>mid</code>, by averaging <code>left</code> and <code>right</code>.</li>
<li>Create variables to keep track of key metrics: <code>maxFraction</code> to store the maximum fraction encountered, <code>totalSmallerFractions</code> to count the number of fractions smaller than <code>mid</code>, and <code>numeratorIdx</code> and <code>denominatorIdx</code> to record the indices of the numerator and denominator of the maximum fraction.</li>
<li>Initialize <code>j</code> to 1, representing the index for the denominator in the array.</li>
<li>Iterate through the array <code>arr</code> to identify fractions smaller than <code>mid</code>.
<ul>
<li>Increment <code>j</code> until the fraction (<code>arr[i] / arr[j]</code>) is less than or equal to <code>mid</code>, effectively finding the right boundary for the current numerator.</li>
<li>Increment <code>totalSmallerFractions</code> by the count of elements between <code>j</code> and <code>n</code>.</li>
<li>Exit the loop if <code>j</code> reaches the end of the array <code>arr</code>.</li>
<li>Calculate the fraction <code>arr[i] / arr[j]</code> and update <code>maxFraction</code>, <code>numeratorIdx</code>, and <code>denominatorIdx</code> if the calculated fraction exceeds the current maximum fraction.</li>
</ul>
</li>
<li>Check if <code>totalSmallerFractions</code> equals <code>k</code>. If it does, return the fraction with the numerator at index <code>numeratorIdx</code> and the denominator at index <code>denominatorIdx</code>.</li>
<li>If <code>totalSmallerFractions</code> exceeds <code>k</code>, update the right boundary of the search range (<code>right</code>) to <code>mid</code> to focus on the left portion of the range.</li>
<li>If <code>totalSmallerFractions</code> is less than <code>k</code>, update the left boundary of the search range (<code>left</code>) to <code>mid</code> to focus on the right portion of the range.</li>
</ul>
</li>
<li>If the loop concludes without finding the <code class="">k<sup>th</sup></code> smallest prime fraction, return an empty array.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/NesZhUEz/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array and <span class="math inline">\(m\)</span> be the maximum value in the array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot log(m))\)</span></p>
<p>The algorithm uses binary search. Within each iteration of the binary search, we perform a linear scan through the array to count the number of fractions smaller than the current <code>mid</code> value. Since the array is sorted, this linear scan takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Binary search takes <span class="math inline">\(O(\log x )\)</span> where <span class="math inline">\(x\)</span> is the number of elements in the search space because each iteration reduces the size of the search space by half. We will stop generating fractions and terminate the search when the total number of smaller fractions equals <code>k</code>. This will happen when the size of the search space becomes smaller than the smallest possible difference between two fractions, which is <span class="math inline">\(\frac{1}{m^2}\)</span>.</p>
<p>This means the size of the search space can be up to <span class="math inline">\({m^2}\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n \cdot log(m^2))\)</span>, which simplifies to <span class="math inline">\(O(n \cdot log(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses constant space becuase we only use a constant amount of extra space for storing variables regardless of the input size. We don't use any additional data structures whose size depends on the input size.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The binary search approach involves iterating through the array for each fraction being tested, which can be time-consuming, especially for large arrays.</p>
<p>To optimize this process, we can leverage the property that the smallest fractions will be formed by dividing each element by the largest element in the array. This observation leads us to the idea of using a priority queue data structure, which can efficiently maintain and update the smallest fractions as we explore the search space.</p>
<p>Consider an input array <span class="math inline">\([n_1, n_2, n_3, n_4, n_5]\)</span>, where <span class="math inline">\(n_1 < n_2 < n_3 < n_4 < n_5\)</span>. The possible fractions that can be formed from different indices of the input are:</p>
<p><span class="math inline">\(\begin{array}{cccccc} \Large{\frac{n_1}{n_5}} & \Large{\frac{n_1}{n_4}} & \Large{\frac{n_1}{n_3}} & \Large{\frac{n_1}{n_2}} \\ \\ \Large{\frac{n_2}{n_5}} & \Large{\frac{n_2}{n_4}} & \Large{\frac{n_2}{n_3}} \\ \\ \Large{\frac{n_3}{n_5}} & \Large{\frac{n_3}{n_4}} \\ \\ \Large{\frac{n_4}{n_5}} \\ \\ \\ \end{array}\)</span></p>
<p>We can observe that for each numerator, the smallest fraction will be formed by dividing by the largest element (<span class="math inline">\(n_5\)</span>).</p>
<p>The first step is to initialize a priority queue that stores pairs in the form <code>{-fraction, {numerator_index, denominator_index}}</code>. The negative sign is used to make the priority queue sort the fractions in ascending order (smallest fraction first).</p>
<p>After that, we can start by pushing all possible fractions formed by dividing each element by the last element of the array into the priority queue. This is because the last element of the sorted array is the largest.</p>
<p>After populating the priority queue, we observe that the top element of the queue will be the smallest fraction among all fractions formed by dividing each element by the last element.</p>
<p>Now, to find the <code class="">k<sup>th</sup></code> smallest fraction, we can iteratively remove the top element from the priority queue and replace it with a new fraction formed by dividing the same numerator by the next smaller denominator. This is done by decrementing the denominator index and pushing the new fraction into the priority queue.</p>
<p>The reason we decrement the denominator is that, suppose we have an array <code>[1, 2, 3, 4, 5]</code>. If we start with the largest denominator (<code>5</code>) and keep the numerator fixed (<code>1</code>), then decrement the denominator in each iteration, we will explore fractions in ascending order:</p>
<p><span class="math inline">\(\frac{1}{5}, \frac{1}{4}, \frac{1}{3}, \frac{1}{2} \)</span></p>
<p>If we were to keep the denominator fixed and increment the numerator instead, we would explore fractions in descending order:</p>
<p><span class="math inline">\( \frac{4}{5}, \frac{3}{5}, \frac{2}{5}, \frac{1}{5}\)</span></p>
<p>While both ways eventually cover all fractions formed by dividing each element by the largest element, the priority queue requires fractions to be explored in ascending order to ensure that the <code class="">k<sup>th</sup></code> smallest fraction is found efficiently.</p>
<p>By decrementing the denominator, we maintain the property that the top element of the priority queue always represents the smallest fraction among those formed by dividing each element by the largest element. This helps us identify the <code class="">k<sup>th</sup></code> smallest fraction more effectively, as the priority queue naturally orders fractions from smallest to largest</p>
<p>Essentially, we replace the smallest fraction with the next smallest fraction having the same numerator. Repeating this <code>k - 1</code> times leaves the <code class="">k<sup>th</sup></code> smallest fraction at the top of the priority queue. In a nutshell, it's about finding the <code>k</code> smallest elements in <code>n</code> sorted linked lists.</p>
<p>The following is an illustration demonstrating the priority queue approach:</p>
<p>!?!../Documents/786/pq.json:978,439!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize an empty priority queue <code>pq</code> to store pairs of fractions and their corresponding indices.</li>
<li>Iterate through the input array <code>arr</code> using a loop variable <code>i</code>.
<ul>
<li>For each element <code>arr[i]</code>, calculate the fraction formed by dividing it by the largest element in the array (<code>arr[arr.size() - 1]</code>).</li>
<li>Push a pair consisting of the negative fraction value (<code>-1.0 * arr[i] / arr[arr.size() - 1]</code>) and the corresponding indices (<code>i</code> for the numerator and <code>arr.size() - 1</code> for the denominator) into the priority queue <code>pq</code>.</li>
</ul>
</li>
<li>The priority queue <code>pq</code> now contains all the fractions formed by dividing each element by the largest element in the array, sorted in ascending order based on the fraction values.</li>
<li>Repeat the following steps <code>k - 1</code> times:
<ul>
<li>Remove the top element (smallest fraction) from the priority queue <code>pq</code> and store its indices in the <code>cur</code> variable.</li>
<li>Decrement the denominator index (<code>cur[1]--</code>).</li>
<li>Calculate the new fraction formed by dividing the numerator at <code>cur[0]</code> by the decremented denominator (<code>arr[cur[1]]</code>).</li>
<li>Push the new fraction value (<code>-1.0 * arr[cur[0]] / arr[cur[1]]</code>) and its corresponding indices (<code>cur[0]</code> for the numerator and <code>cur[1]</code> for the denominator) into the priority queue <code>pq</code>.</li>
</ul>
</li>
<li>After <code>k - 1</code> iterations, the top element of the priority queue <code>pq</code> will be the <code class="">k<sup>th</sup></code> smallest fraction.</li>
<li>Extract the numerator and denominator indices from the top element of the priority queue and store them in <code>result</code>.</li>
<li>Return a array containing the numerator (<code>arr[result[0]]</code>) and denominator (<code>arr[result[1]]</code>) values corresponding to the <code class="">k<sup>th</sup></code> smallest fraction.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/M8yvD79e/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input array and <span class="math inline">\(k\)</span> be the integer <code>k</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((n + k) \cdot \log n)\)</span></p>
<p>Pushing the initial fractions into the priority queue takes <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Iteratively removing and replacing fractions takes <span class="math inline">\(O(k \log n)\)</span> and retrieving the <code class="">k<sup>th</sup></code> smallest fraction takes <span class="math inline">\(O(\log n)\)</span>.</p>
<p>Thus the overall time complexity of the algorithm is <span class="math inline">\(O(n \log n + k \log n)\)</span>, which can write as <span class="math inline">\(O((n + k) \cdot \log n)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space required by the priority queue to store fractions is <span class="math inline">\(O(n)\)</span> since it can potentially hold all fractions formed by dividing each element by the largest element.</p>
<p>The additional space used by other variables like <code>cur</code>, <code>numeratorIndex</code>, <code>denominatorIndex</code>, etc., is constant and doesn't depend on the size of the input array.</p>
<p>Thus the overall space complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-87">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-merge-of-two-strings/description" target="_blank" rel="noopener noreferrer">Largest Merge Of Two Strings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>word1</code> and <code>word2</code>. You want to construct a string <code>merge</code> in the following way: while either <code>word1</code> or <code>word2</code> are non-empty, choose <strong>one</strong> of the following options:</p>

<ul>
	<li>If <code>word1</code> is non-empty, append the <strong>first</strong> character in <code>word1</code> to <code>merge</code> and delete it from <code>word1</code>.

	<ul>
		<li>For example, if <code>word1 = &quot;abc&quot; </code>and <code>merge = &quot;dv&quot;</code>, then after choosing this operation, <code>word1 = &quot;bc&quot;</code> and <code>merge = &quot;dva&quot;</code>.</li>
	</ul>
	</li>
	<li>If <code>word2</code> is non-empty, append the <strong>first</strong> character in <code>word2</code> to <code>merge</code> and delete it from <code>word2</code>.
	<ul>
		<li>For example, if <code>word2 = &quot;abc&quot; </code>and <code>merge = &quot;&quot;</code>, then after choosing this operation, <code>word2 = &quot;bc&quot;</code> and <code>merge = &quot;a&quot;</code>.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the lexicographically <strong>largest</strong> </em><code>merge</code><em> you can construct</em>.</p>

<p>A string <code>a</code> is lexicographically larger than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, <code>a</code> has a character strictly larger than the corresponding character in <code>b</code>. For example, <code>&quot;abcd&quot;</code> is lexicographically larger than <code>&quot;abcc&quot;</code> because the first position they differ is at the fourth character, and <code>d</code> is greater than <code>c</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;cabaa&quot;, word2 = &quot;bcaaa&quot;
<strong>Output:</strong> &quot;cbcabaaaaa&quot;
<strong>Explanation:</strong> One way to get the lexicographically largest merge is:
- Take from word1: merge = &quot;c&quot;, word1 = &quot;abaa&quot;, word2 = &quot;bcaaa&quot;
- Take from word2: merge = &quot;cb&quot;, word1 = &quot;abaa&quot;, word2 = &quot;caaa&quot;
- Take from word2: merge = &quot;cbc&quot;, word1 = &quot;abaa&quot;, word2 = &quot;aaa&quot;
- Take from word1: merge = &quot;cbca&quot;, word1 = &quot;baa&quot;, word2 = &quot;aaa&quot;
- Take from word1: merge = &quot;cbcab&quot;, word1 = &quot;aa&quot;, word2 = &quot;aaa&quot;
- Append the remaining 5 a&#39;s from word1 and word2 at the end of merge.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcabc&quot;, word2 = &quot;abdcaba&quot;
<strong>Output:</strong> &quot;abdcabcabcaba&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 3000</code></li>
	<li><code>word1</code> and <code>word2</code> consist only of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-88">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description" target="_blank" rel="noopener noreferrer">Largest Positive Integer That Exists With Its Negative</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> that <strong>does not contain</strong> any zeros, find <strong>the largest positive</strong> integer <code>k</code> such that <code>-k</code> also exists in the array.</p>

<p>Return <em>the positive integer </em><code>k</code>. If there is no such integer, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,2,-3,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 is the only valid k we can find in the array.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,10,6,7,-7,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [-10,8,6,7,-2,-3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no a single valid k, we return -1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
	<li><code>nums[i] != 0</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find the largest value <code>k</code> in the given array <code>nums</code> such that <code>-k</code> is also present in the array. In other words, we must find the largest positive number in the array that has a corresponding negative counterpart. If there is no positive number with a negative counterpart, return <code>-1</code>.</p>
<p><strong>Key Observations:</strong></p>
<ul>
<li>The <code>nums</code> array does not contain any zeros.</li>
<li>The <code>nums</code> array has up to <span class="math inline">\(1000\)</span> elements, and each element can range from <span class="math inline">\(-1000\)</span> to <span class="math inline">\(1000\)</span></li>
</ul>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force approach is to iterate through the input array using a nested loop, checking every possible pair of numbers to see if they are additive inverses. Additive inverses sum to zero. We can check this by comparing one number to the negation of the other number. If they are equal, the positive number is a possible <code>k</code> value. We update the answer if this number is larger than the current answer.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>ans</code> to -1 to ensure it starts lower than any valid absolute value, so the first encountered valid absolute value will always replace it.</li>
<li>For each <code>i</code> in <code>nums</code>, iterate through the <code>nums</code> array again for <code>j</code>.
<ul>
<li>If <code>i</code> is equal to the negation of <code>j</code>, update <code>ans</code> to <code>max(ans, abs(i))</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/HWZLzNXL/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The nested loops iterate through the entire array for each element, resulting in a quadratic time complexity.</p>
<p>Let's consider the worst-case scenario where nums has <span class="math inline">\(1000\)</span> elements, and each element can range from <span class="math inline">\(-1000\)</span> to <span class="math inline">\(1000\)</span></p>
<ul>
<li>The outer loop will run <span class="math inline">\(1000\)</span> times (once for each element).</li>
<li>For each iteration of the outer loop, the inner loop will run another <span class="math inline">\(1000\)</span> times (once for each element).</li>
<li>This results in a total of <span class="math inline">\(1000 \cdot 1000 = 1,000,000\)</span> iterations of the inner loop.</li>
</ul>
<p>For this problem, the brute force solution is accepted.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses a constant amount of extra space to store the answer.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointer">Approach 2: Two Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>The key observation is that if a pair of numbers sum to 0, they must have opposite signs.</p>
<p>This suggests that we can sort the input array first and then use a two-pointer approach to find pairs of numbers that sum to 0.</p>
<p>Since the array is sorted, <code>nums[lo]</code> begins as the largest negative number in the array, and <code>nums[hi]</code>  starts as the largest positive value in the array. If <code>-nums[lo]</code> and <code>nums[hi]</code> are equal, then we have found the largest pair of numbers with opposite signs that sum to 0, so <code>nums[hi]</code> is the answer.</p>
<p>This is similar to the classic <a href="https://leetcode.com/problems/two-sum/description/">two sum problem</a>, but with the added constraint that the numbers must have opposite signs.</p>
<p>The following is an illustration demonstrating the two pointer approach:</p>
<p>!?!../Documents/2441/twopointer.json:472,127!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Sort the <code>nums</code> array in ascending order.</li>
<li>Initialize <code>lo</code> to 0 and <code>hi</code> to the last index of the <code>nums</code> array.</li>
<li>While <code>lo</code> is less than <code>hi</code>:
<ul>
<li>If <code>-nums[lo]</code> is equal to <code>nums[hi]</code>, return <code>nums[hi]</code>.</li>
<li>If <code>-nums[lo]</code> is greater than <code>nums[hi]</code>, increment <code>lo</code>.</li>
<li>If <code>-nums[lo]</code> is less than <code>nums[hi]</code>, decrement <code>hi</code>.</li>
</ul>
</li>
<li>If the loop completes without finding a matching pair, return -1.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/6WmFFCRD/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n)\)</span></p>
<p>The sorting step takes <span class="math inline">\(O(n \cdot \log n)\)</span> time. The while loop will process each element in <code>nums</code> at most once, so this step takes <span class="math inline">\(O(n)\)</span>. The sorting step dominates the time complexity, with the two-pointer step being linear.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(\log n)\)</span></p>
<p>The algorithm only uses a constant amount of extra space to store the pointers.</p>
<p>Some extra space is used when we sort the <code>nums</code> in place. The space complexity of the sorting algorithms depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O(\log n)\)</span> for sorting two arrays.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pass-hash-set">Approach 3: Two Pass Hash Set</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the brute force approach, we sacrificed runtime to find the solution. The key insight from this approach was to use nested loops to search for the negative versions of positive numbers. If we search for values without traversing the entire range, we can eliminate the need for the nested loop. This implies the necessity of a data structure with constant lookup time (<span class="math inline">\(O(1)\)</span>), allowing us to store all negative numbers encountered during the first pass.</p>
<p>The idea is to use a hash set to store all negative numbers encountered in the first pass. Then, in the second pass, we can check if the negatives of the positive numbers exist in the hash set and update the maximum value accordingly.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a hash set named <code>neg</code> to store negative numbers.</li>
<li>Iterate over <code>nums</code> and add negative numbers to <code>neg</code>.</li>
<li>Initialize <code>ans</code> to -1.</li>
<li>Iterate over <code>nums</code>:
<ul>
<li>For each <code>num</code>, check if <code>num</code> is greater than <code>ans</code> and if <code>-num</code> exists in the <code>neg</code> set.</li>
<li>If the condition is true, update <code>ans</code> to <code>num</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/araDGa98/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a single loop to identify the negative numbers and another loop to find the maximum value <code>k</code>. The use of the hash set allows for constant-time lookups in the average case.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set used to store the negative numbers requires linear space.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-one-pass-hash-set">Approach 4: One Pass Hash Set</h3>
<h4 id="intuition-3">Intuition</h4>
<p>In the previous hash set approach, we used two passes: one to populate the <code>neg</code> set with negative numbers and another to determine the maximum value <code>k</code>.</p>
<p>However, we can optimize this process to achieve the same goal with just a single iteration through the array. During this iteration, we can simultaneously check for the existence of the negation of each encountered number and update the maximum value <code>k</code> accordingly. This optimization allows us to reduce our approach to a one-pass solution.</p>
<p>The following is an illustration demonstrating the one pass hash set approach:</p>
<p>!?!../Documents/2441/onepass_hashset.json:471,131!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>ans</code> to -1.</li>
<li>Initialize a hash set <code>seen</code> to store the absolute values of the numbers.</li>
<li>Iterate over <code>nums</code>:
<ul>
<li>For each <code>num</code>, get the absolute value <code>abs_num</code>.</li>
<li>Check if <code>abs_num</code> is greater than <code>ans</code> and if the negation of <code>num</code> is present in the <code>seen</code> set.</li>
<li>If the condition is true, update <code>ans</code> to <code>abs_num</code>.</li>
<li>Add the current <code>num</code> to the <code>seen</code> set.</li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/Qr2JUiTw/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a single loop to process the array. Hash set lookups take constant time in the average case.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The hash set used to store the encountered numbers requires linear space.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-one-pass-bitset">Approach 5: One Pass Bitset</h3>
<h4 id="intuition-4">Intuition</h4>
<p>Given the range <span class="math inline">\(-1000 <= nums[i] <= 1000\)</span>, we can track all numbers encountered using a bitset. For instance, we can set a bit if the number is negative and leave it unset if the number is positive.</p>
<p>To accomplish this, we use a bitset of size <span class="math inline">\(1024\)</span> to denote the existence of negative numbers encountered during the traversal of the input array. Initially, all bits in the bitset are set to <code>0</code>. Then, as we iterate through the array, we set the bit corresponding to the index of the negative value to <code>1</code> whenever a negative number is encountered.</p>
<p>In the subsequent pass, we check if the negatives of the positive numbers are present in the bitset. This operation is highly efficient, as bitsets offer constant-time access to individual bits.</p>
<p>This would be a two-pass solution, but we can further optimize it to use a single pass.</p>
<p>We'll track both negative and positive numbers encountered using a bitset array size of <span class="math inline">\(2048\)</span>. Each index in the bitset corresponds to a number in the range <span class="math inline">\([-1024, 1023]\)</span>. According to the constraints, this range covers the possible values in the input array.</p>
<p>During the traversal, we will check if the absolute value of the current number is greater than the current maximum value and if the negation of the current number has been encountered before. If both conditions are met, we will update <code>ans</code> to the absolute value of the current number.</p>
<p>After checking the conditions, we need to mark the current number as encountered by setting the corresponding bit in the seen bitset. This can be done by marking the <code>num + 1024</code> value as <code>true</code>. Adding <span class="math inline">\(1024\)</span> to <code>num</code> maps both positive and negative numbers to non-negative indices in the bitset. This ensures that the indices used in the bitset cover the entire range of possible values encountered in the input array.</p>
<p>The following is an illustration demonstrating the one pass bitset approach:</p>
<p>!?!../Documents/2441/onepass_bitset.json:672,262!?!</p>
<h4 id="algorithm-4">Algorithm</h4>
<ul>
<li>Initialize <code>ans</code> to -1.</li>
<li>Initialize a bitset array of size 2048 named as <code>seen</code> to store the presence of the numbers (shifted by 1024 to handle negative numbers).</li>
<li>Iterate over <code>nums</code>:
<ul>
<li>For each <code>num</code>, get the absolute value <code>abs_num</code>.</li>
<li>Check if <code>abs_num</code> is greater than <code>ans</code> and if the negation of <code>num</code> (shifted by 1024) is present in the <code>seen</code> bitset.</li>
<li>If the condition is true, update <code>ans = abs_num</code>.</li>
<li>Set the bit at index <code>num + 1024</code> in the <code>seen</code> bitset to true.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<h4 id="implementation-4">Implementation</h4>
<blockquote>
<p>Note: We have used a Set instead of the bitset function from the Bitset library. As of 9/9/2024, the Bitset library is available for installation from <a href="https://pypi.org/project/bitsets/0.4/">Python's official repository (Link)</a> but is not supported in the LeetCode environment. The implementation code below simulates similar logic to what would be achieved with the bitset function, using a Set instead.</p>
</blockquote>
<details>
  <summary>Dropdown Click to See the Python Bitset Implementation:</summary>
  <pre><code>
from bitarray import bitarray
from typing import List
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        ans = -1
        # Initialize a bitarray to keep track of seen numbers
        bitset = bitarray(2 * 1024)  # Sufficient size for positive and negative offsets
        bitset.setall(False)  # Set all bits to False initially
<pre><code>    for num in nums:
        abs_num = abs(num)
        bit_index = abs_num + 1024  # Offset for handling both positive and negative values

        # If the absolute value is greater than the current answer
        # and its negation was seen before, update the answer
        if abs_num &gt; ans and bitset[-num + 1024]:
            ans = abs_num

        # Mark the current number as seen
        bitset[bit_index] = True

    return ans
</code></pre>
<p></code></pre></p>
</details>
<blockquote>
<p>As the Bitset library is not supported in the LeetCode environment, so the above dropdown implementation is provided for illustrative purposes.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/dPaPbUEK/shared">code</a></p>
<h4 id="complexity-analysis-4">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array and <span class="math inline">\(m\)</span> be the size of the range of input values.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses a single loop to process the array and perform constant-time lookups in the bitset.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<p>The bitset is size <span class="math inline">\(2048\)</span> in our implementation, so it can store data about <span class="math inline">\(2000\)</span> numbers, as the constraints specify that the numbers will be between <span class="math inline">\(-1000\)</span> and <span class="math inline">\(1000\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-89">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/last-substring-in-lexicographical-order/description" target="_blank" rel="noopener noreferrer">Last Substring in Lexicographical Order</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the last substring of</em> <code>s</code> <em>in lexicographical order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abab&quot;
<strong>Output:</strong> &quot;bab&quot;
<strong>Explanation:</strong> The substrings are [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]. The lexicographically maximum substring is &quot;bab&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;
<strong>Output:</strong> &quot;tcode&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-90">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/lexicographically-smallest-palindrome/description" target="_blank" rel="noopener noreferrer">Lexicographically Smallest Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code node="[object Object]">s</code> consisting of <strong>lowercase English letters</strong>, and you are allowed to perform operations on it. In one operation, you can <strong>replace</strong> a character in <code node="[object Object]">s</code> with another lowercase English letter.</p>

<p>Your task is to make <code node="[object Object]">s</code> a <strong>palindrome</strong> with the <strong>minimum</strong> <strong>number</strong> <strong>of operations</strong> possible. If there are <strong>multiple palindromes</strong> that can be <meta charset="utf-8" />made using the <strong>minimum</strong> number of operations, <meta charset="utf-8" />make the <strong>lexicographically smallest</strong> one.</p>

<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.</p>

<p>Return <em>the resulting palindrome string.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;egcfe&quot;
<strong>Output:</strong> &quot;efcfe&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;egcfe&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;efcfe&quot;, by changing &#39;g&#39;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcd&quot;
<strong>Output:</strong> &quot;abba&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;abcd&quot; a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is &quot;abba&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;seven&quot;
<strong>Output:</strong> &quot;neven&quot;
<strong>Explanation:</strong> The minimum number of operations to make &quot;seven&quot; a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is &quot;neven&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code>&nbsp;consists of only lowercase English letters<b>.</b></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-91">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-cycle/description" target="_blank" rel="noopener noreferrer">Linked List Cycle</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>

<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;" />
<pre>
<strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="width: 141px; height: 74px;" />
<pre>
<strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="width: 45px; height: 45px;" />
<pre>
<strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-92">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/linked-list-cycle-ii/description" target="_blank" rel="noopener noreferrer">Linked List Cycle II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>

<p><strong>Do not modify</strong> the linked list.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" style="height: 145px; width: 450px;" />
<pre>
<strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> tail connects to node index 1
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" style="height: 105px; width: 201px;" />
<pre>
<strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> tail connects to node index 0
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" style="height: 65px; width: 65px;" />
<pre>
<strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> no cycle
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
	<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-93">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-chunked-palindrome-decomposition/description" target="_blank" rel="noopener noreferrer">Longest Chunked Palindrome Decomposition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">hash function</span> <span class="topic-badge">rolling hash</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>text</code>. You should split it to k substrings <code>(subtext<sub>1</sub>, subtext<sub>2</sub>, ..., subtext<sub>k</sub>)</code> such that:</p>

<ul>
	<li><code>subtext<sub>i</sub></code> is a <strong>non-empty</strong> string.</li>
	<li>The concatenation of all the substrings is equal to <code>text</code> (i.e., <code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code>).</li>
	<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code> for all valid values of <code>i</code> (i.e., <code>1 &lt;= i &lt;= k</code>).</li>
</ul>

<p>Return the largest possible value of <code>k</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;
<strong>Output:</strong> 7
<strong>Explanation:</strong> We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;merchant&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can split the string on &quot;(merchant)&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> text = &quot;antaprezatepzapreanta&quot;
<strong>Output:</strong> 11
<strong>Explanation:</strong> We can split the string on &quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= text.length &lt;= 1000</code></li>
	<li><code>text</code> consists only of lowercase English characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-94">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-mountain-in-array/description" target="_blank" rel="noopener noreferrer">Longest Mountain in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You may recall that an array <code>arr</code> is a <strong>mountain array</strong> if and only if:</p>

<ul>
	<li><code>arr.length &gt;= 3</code></li>
	<li>There exists some index <code>i</code> (<strong>0-indexed</strong>) with <code>0 &lt; i &lt; arr.length - 1</code> such that:
	<ul>
		<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
		<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
	</ul>
	</li>
</ul>

<p>Given an integer array <code>arr</code>, return <em>the length of the longest subarray, which is a mountain</em>. Return <code>0</code> if there is no mountain subarray.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,1,4,7,3,2,5]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The largest mountain is [1,4,7,3,2] which has length 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [2,2,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no mountain.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Can you solve it using only one pass?</li>
	<li>Can you solve it in <code>O(1)</code> space?</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-two-pointer-accepted">Approach #1: Two Pointer [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Without loss of generality, a mountain can only start after the previous one ends.</p>
<p>This is because if it starts before the peak, it will be smaller than a mountain starting previous; and it is impossible to start after the peak.</p>
<p><strong>Algorithm</strong></p>
<p>For a starting index <code>base</code>, let's calculate the length of the longest mountain <code>A[base], A[base+1], ..., A[end]</code>.</p>
<p>If such a mountain existed, the next possible mountain will start at <code>base = end</code>; if it didn't, then either we reached the end, or we have <code>A[base] &gt;= A[base+1]</code> and we can start at <code>base + 1</code>.</p>
<p><strong>Example</strong></p>
<p>Here is a worked example on the array <code>A = [1, 2, 3, 2, 1, 0, 2, 3, 1]</code>:</p>
<center>
    <img src="../Figures/845/diagram1.png" alt="Worked example of A = [1,2,3,2,1,0,2,3,1]" style="height: 150px"/>
</center>
<br>
<p><code>base</code> starts at <code>0</code>, and <code>end</code> travels using the first while loop to <code>end = 2</code> (<code>A[end] = 3</code>), the potential peak of this mountain.  After, it travels to <code>end = 5</code> (<code>A[end] = 0</code>) during the second while loop, and a candidate answer of 6 <code>(base = 0, end = 5)</code> is recorded.</p>
<p>Afterwards, base is set to <code>5</code> and the process starts over again, with <code>end = 7</code> the peak of the mountain, and <code>end = 8</code> the right boundary, and the candidate answer of 4 <code>(base = 5, end = 8)</code> being recorded.</p>
<p><a href="https://leetcode.com/playground/8NNCFqJG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>A</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-95">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindrome-after-substring-concatenation-i/description" target="_blank" rel="noopener noreferrer">Longest Palindrome After Substring Concatenation I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">enumeration</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings, <code>s</code> and <code>t</code>.</p>

<p>You can create a new string by selecting a <span data-keyword="substring">substring</span> from <code>s</code> (possibly empty) and a substring from <code>t</code> (possibly empty), then concatenating them <strong>in order</strong>.</p>

<p>Return the length of the <strong>longest</strong> <span data-keyword="palindrome-string">palindrome</span> that can be formed this way.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;a&quot;, t = &quot;a&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Concatenating <code>&quot;a&quot;</code> from <code>s</code> and <code>&quot;a&quot;</code> from <code>t</code> results in <code>&quot;aa&quot;</code>, which is a palindrome of length 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;, t = &quot;def&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>Since all characters are different, the longest palindrome is any single character, so the answer is 1.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;b&quot;, t = &quot;aaaa&quot;</span></p>

<p><strong>Output:</strong> 4</p>

<p><strong>Explanation:</strong></p>

<p>Selecting &quot;<code>aaaa</code>&quot; from <code>t</code> is the longest palindrome, so the answer is 4.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcde&quot;, t = &quot;ecdba&quot;</span></p>

<p><strong>Output:</strong> 5</p>

<p><strong>Explanation:</strong></p>

<p>Concatenating <code>&quot;abc&quot;</code> from <code>s</code> and <code>&quot;ba&quot;</code> from <code>t</code> results in <code>&quot;abcba&quot;</code>, which is a palindrome of length 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 30</code></li>
	<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-96">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindrome-after-substring-concatenation-ii/description" target="_blank" rel="noopener noreferrer">Longest Palindrome After Substring Concatenation II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings, <code>s</code> and <code>t</code>.</p>

<p>You can create a new string by selecting a <span data-keyword="substring">substring</span> from <code>s</code> (possibly empty) and a substring from <code>t</code> (possibly empty), then concatenating them <strong>in order</strong>.</p>

<p>Return the length of the <strong>longest</strong> <span data-keyword="palindrome-string">palindrome</span> that can be formed this way.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;a&quot;, t = &quot;a&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Concatenating <code>&quot;a&quot;</code> from <code>s</code> and <code>&quot;a&quot;</code> from <code>t</code> results in <code>&quot;aa&quot;</code>, which is a palindrome of length 2.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abc&quot;, t = &quot;def&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p>Since all characters are different, the longest palindrome is any single character, so the answer is 1.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;b&quot;, t = &quot;aaaa&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">4</span></p>

<p><strong>Explanation:</strong></p>

<p>Selecting &quot;<code>aaaa</code>&quot; from <code>t</code> is the longest palindrome, so the answer is 4.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abcde&quot;, t = &quot;ecdba&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">5</span></p>

<p><strong>Explanation:</strong></p>

<p>Concatenating <code>&quot;abc&quot;</code> from <code>s</code> and <code>&quot;ba&quot;</code> from <code>t</code> results in <code>&quot;abcba&quot;</code>, which is a palindrome of length 5.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>
	<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-97">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-palindromic-substring/description" target="_blank" rel="noopener noreferrer">Longest Palindromic Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword="palindromic-string"><em>palindromic</em></span> <span data-keyword="substring-nonempty"><em>substring</em></span> in <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;babad&quot;
<strong>Output:</strong> &quot;bab&quot;
<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cbbd&quot;
<strong>Output:</strong> &quot;bb&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consist of only digits and English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
 <div class='video-preview'></div>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-check-all-substrings">Approach 1: Check All Substrings</h3>
<p><strong>Intuition</strong></p>
<p>We can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is.</p>
<p>First, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on.</p>
<p><img src="../Figures/5/1.png" alt="Palindrome Check" /></p>
<p>We initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.</p>
<p>One bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length <code>1000</code> and the third and third last characters did not match, we would exit the algorithm after only 3 iterations.</p>
<p>There's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a helper method <code>check(i, j)</code> to determine if a substring is a palindrome.
<ul>
<li>To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be <code>s[i]</code> and the last character will be <code>s[j - 1]</code>.</li>
<li>In this function, declare two pointers <code>left = i</code> and <code>right = j - 1</code>.</li>
<li>While <code>left &lt; right</code>, do the following steps:</li>
<li>If <code>s[left] != s[right]</code>, return <code>false</code>.</li>
<li>Otherwise, increment <code>left</code> and decrement <code>right</code>.</li>
<li>If we get through the while loop, return <code>true</code>.</li>
</ul>
</li>
<li>Use a for loop to iterate a variable <code>length</code> starting from <code>s.length</code> until <code>1</code>. This variable represents the length of the substrings we are currently considering.</li>
<li>Use a for loop to iterate a variable <code>start</code> starting from <code>0</code> until and including <code>s.length - length</code>. This variable represents the starting point of the substring we are currently considering.</li>
<li>In each inner loop iteration, we are considering the substring starting at <code>start</code> until <code>start + length</code>. Pass these values into <code>check</code> to see if this substring is a palindrome. If it is, return the substring.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/PMqPSHFX/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^3)\)</span></p>
<p>The two nested for loops iterate <span class="math inline">\(O(n^2)\)</span> times. We check one substring of length <code>n</code>, two substrings of length <code>n - 1</code>, three substrings of length <code>n - 2</code>, and so on.</p>
<p>There are <code>n</code> substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately.</p>
<p>Therefore, the number of substrings that we check in the worst case is <code>1 + 2 + 3 + ... + n - 1</code>. This is the partial sum of <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums">this series</a> for <code>n - 1</code>, which is equal to <span class="math inline">\(\frac{n \cdot (n - 1)}{2} = O(n^2)\)</span>.</p>
<p>In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with <code>n</code> as well, giving us a time complexity of <span class="math inline">\(O(n^3)\)</span>.</p>
<p>Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h3>
<p><strong>Intuition</strong></p>
<p>Let's say that we knew the substring with inclusive bounds <code>i, j</code> was a palindrome. If <code>s[i - 1] == s[j + 1]</code>, then we know the substring with inclusive bounds <code>i - 1, j + 1</code> must also be a palindrome, and this check can be done in constant time.</p>
<p>We can flip the direction of this logic as well - if <code>s[i] == s[j]</code> and the substring <code>i + 1, j - 1</code> is a palindrome, then the substring <code>i, j</code> must also be a palindrome.</p>
<p><img src="../Figures/5/2.png" alt="DP Example" /></p>
<p>We know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every <code>i, j</code> pair where <code>j - i = 2</code>. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on.</p>
<p>What about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, <code>i, i + 1</code> is a palindrome if <code>s[i] == s[i + 1]</code>. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on.</p>
<p>Let's use a table <code>dp</code> with dimensions of <code>n * n</code>. <code>dp[i][j]</code> is a boolean representing if the substring with inclusive bounds <code>i, j</code> is a palindrome. We initialize <code>dp[i][i] = true</code> for the substrings of length 1, and then <code>dp[i][i + 1] = (s[i] == s[i + 1])</code> for the substrings of length 2.</p>
<p>Now, we need to populate the table. We iterate over all <code>i, j</code> pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each <code>i, j</code> pair, we check the condition from earlier:</p>
<p><code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p>If this condition is true, then the substring with inclusive bounds <code>i, j</code> must be a palindrome. We set <code>dp[i][j] = true</code>.</p>
<p>Because we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>
<p>Initialize <code>n = s.length</code> and a boolean table <code>dp</code> with size <code>n * n</code>, and all values to <code>false</code>.</p>
</li>
<li>
<p>Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</p>
</li>
<li>
<p>Set all <code>dp[i][i] = true</code>.</p>
</li>
<li>
<p>Iterate over all pairs <code>i, i + 1</code>. For each one, if <code>s[i] == s[i + 1]</code>, then set <code>dp[i][i + 1] = true</code> and update <code>ans = [i, i + 1]</code>.</p>
</li>
<li>
<p>Now, we populate the <code>dp</code> table. Iterate over <code>diff</code> from <code>2</code> until <code>n</code>. This variable represents the difference <code>j - i</code>.</p>
</li>
<li>
<p>In a nested for loop, iterate over <code>i</code> from <code>0</code> until <code>n - diff</code>.</p>
<ul>
<li>Set <code>j = i + diff</code>.</li>
<li>Check the condition: if <code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code>, we found a palindrome.</li>
<li>In that case, set <code>dp[i][j] = true</code> and <code>ans = [i, j]</code></li>
</ul>
</li>
<li>
<p>Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code> starting at index <code>i</code> and ending with index <code>j</code>.</p>
</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/VMs3My7i/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We declare an <code>n * n</code> table <code>dp</code>, which takes <span class="math inline">\(O(n^2)\)</span> time. We then populate <span class="math inline">\(O(n^2)\)</span> states <code>i, j</code> - each state takes <span class="math inline">\(O(1)\)</span> time to compute.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The table <code>dp</code> takes <span class="math inline">\(O(n^2)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-expand-from-centers">Approach 3: Expand From Centers</h3>
<p><strong>Intuition</strong></p>
<p>In the first approach, the palindrome check cost <span class="math inline">\(O(n)\)</span>. In the second approach, the palindrome check cost <span class="math inline">\(O(1)\)</span>. This allowed us to improve the time complexity from <span class="math inline">\(O(n^3)\)</span> to <span class="math inline">\(O(n^2)\)</span>.</p>
<p>The problem with the second approach is that we <strong>always</strong> iterated over <span class="math inline">\(O(n^2)\)</span> states of <code>i, j</code>. Can we optimize further to minimize the number of iterations required?</p>
<p>In the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on.</p>
<p>Instead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had <code>s = &quot;racecar&quot;</code>. If we start both pointers at the middle (<code>&quot;e&quot;</code>) and move them away from each other, we can see that at every iteration, the characters match: <code>e -&gt; c -&gt; a -&gt; r</code>.</p>
<p>The previous two approaches focused on the bounds of a substring - <code>i, j</code>. There are <span class="math inline">\(O(n^2)\)</span> bounds, but only <span class="math inline">\(O(n)\)</span> centers. For each index <code>i</code>, we can consider odd-length palindromes by starting the pointers at <code>i, i</code>. To consider the even length palindromes, we can start the pointers at <code>i, i + 1</code>. There are <span class="math inline">\(n\)</span> starting points for the odd-length palindromes and <span class="math inline">\(n - 1\)</span> starting points for the even-length palindromes - that's <span class="math inline">\(2n - 1 = O(n)\)</span> starting points in total.</p>
<p>This is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method <code>expand(i, j)</code> that starts two pointers <code>left = i</code> and <code>right = j</code>. In this method, we will consider <code>i, j</code> as a center. When <code>i == j</code>, we are considering odd-length palindromes. When <code>i != j</code>, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome.</p>
<p>Let's say that we have a center <code>i, i</code>. We call <code>expand</code> and find a length of <code>length</code>. What are the bounds of the palindrome? Because we are centered at <code>i, i</code>, it means <code>length</code> must be odd. If we perform floor division of <code>length</code> by 2, we will get the number of characters <code>dist</code> on each side of the palindrome. For example, given <code>s = &quot;racecar&quot;</code>, we have <code>length = 7</code> and <code>dist = 7 / 2 = 3</code>. There are 3 characters on each side - <code>&quot;rac&quot;</code> on the left and <code>&quot;car&quot;</code> on the right. Therefore, we can determine that the bounds of the palindrome are <code>i - dist, i + dist</code>.</p>
<p>What about a center at <code>i, i + 1</code>? <code>length</code> must be even now. If we have a palindrome with length <code>2</code>, then <code>length / 2 = 1</code>, but there are zero characters on each side of the center. We can see that <code>dist</code> is too large by 1. Therefore, we will calculate <code>dist</code> as <code>(length / 2) - 1</code> instead. Now, <code>dist</code> correctly represents the number of characters on each side. The bounds of the palindrome are <code>i - dist, i + 1 + dist</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Create a helper method <code>expand(i, j)</code> to find the length of the longest palindrome centered at <code>i, j</code>.
<ul>
<li>Set <code>left = i</code> and <code>right = j</code>.</li>
<li>While <code>left</code> and <code>right</code> are both in bounds and <code>s[left] == s[right]</code>, move the pointers away from each other.</li>
<li>The formula for the length of a substring starting at <code>left</code> and ending at <code>right</code> is <code>right - left + 1</code>.</li>
<li>However, when the while loop ends, it implies <code>s[left] != s[right]</code>. Therefore, we need to subtract <code>2</code>. Return <code>right - left - 1</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</li>
<li>Iterate <code>i</code> over all indices of <code>s</code>.
<ul>
<li>Find the length of the longest odd-length palindrome centered at <code>i</code>: <code>oddLength = expand(i, i)</code>.</li>
<li>If <code>oddLength</code> is the greatest length we have seen so far, i.e. <code>oddLength &gt; ans[1] - ans[0] + 1</code>, update <code>ans</code>.</li>
<li>Find the length of the longest even-length palindrome centered at <code>i</code>: <code>evenLength = expand(i, i + 1)</code>.</li>
<li>If <code>evenLength</code> is the greatest length we have seen so far, update <code>ans</code>.</li>
</ul>
</li>
<li>Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code> starting at index <code>i</code> and ending with index <code>j</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AFGFqkbR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>There are <span class="math inline">\(2n - 1 = O(n)\)</span> centers. For each center, we call <code>expand</code>, which costs up to <span class="math inline">\(O(n)\)</span>.</p>
<p>Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the <span class="math inline">\(O(n)\)</span> calls to <code>expand</code> will cost far less than <span class="math inline">\(n\)</span> iterations.</p>
<p>The worst case scenario is when every character in the string is the same.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We don't use any extra space other than a few integers. This is a big improvement on the DP approach.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-4-manachers-algorithm">Approach 4: Manacher's Algorithm</h3>
<p>Believe it or not, this problem can be solved in linear time.</p>
<p><a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm">Manacher's algorithm</a> finds the longest palindromic substring in <span class="math inline">\(O(n)\)</span> time and space.</p>
<p>Note: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.</p>
<p>If you wish to learn more about Manacher's algorithm, please reference the above link.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/8Zsn7Mso/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>s</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm):</p>
<blockquote>
<p>The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center <span class="math inline">\(\leq\)</span> 2n+1 and Radius <span class="math inline">\(\leq\)</span> n, the total number of operations in the first and second inner loops is <span class="math inline">\(O(n)\)</span> and the total number of operations in the outer loop, other than those in the inner loops, is also <span class="math inline">\(O(n)\)</span>. The overall running time is therefore <span class="math inline">\(O(n)\)</span>.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>sPrime</code> and <code>palindromeRadii</code>, both of length <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-98">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-string-chain/description" target="_blank" rel="noopener noreferrer">Longest String Chain</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of <code>words</code> where each word consists of lowercase English letters.</p>

<p><code>word<sub>A</sub></code> is a <strong>predecessor</strong> of <code>word<sub>B</sub></code> if and only if we can insert <strong>exactly one</strong> letter anywhere in <code>word<sub>A</sub></code> <strong>without changing the order of the other characters</strong> to make it equal to <code>word<sub>B</sub></code>.</p>

<ul>
	<li>For example, <code>&quot;abc&quot;</code> is a <strong>predecessor</strong> of <code>&quot;ab<u>a</u>c&quot;</code>, while <code>&quot;cba&quot;</code> is not a <strong>predecessor</strong> of <code>&quot;bcad&quot;</code>.</li>
</ul>

<p>A <strong>word chain</strong><em> </em>is a sequence of words <code>[word<sub>1</sub>, word<sub>2</sub>, ..., word<sub>k</sub>]</code> with <code>k &gt;= 1</code>, where <code>word<sub>1</sub></code> is a <strong>predecessor</strong> of <code>word<sub>2</sub></code>, <code>word<sub>2</sub></code> is a <strong>predecessor</strong> of <code>word<sub>3</sub></code>, and so on. A single word is trivially a <strong>word chain</strong> with <code>k == 1</code>.</p>

<p>Return <em>the <strong>length</strong> of the <strong>longest possible word chain</strong> with words chosen from the given list of </em><code>words</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]
<strong>Output:</strong> 4
<strong>Explanation</strong>: One of the longest word chains is [&quot;a&quot;,&quot;<u>b</u>a&quot;,&quot;b<u>d</u>a&quot;,&quot;bd<u>c</u>a&quot;].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]
<strong>Output:</strong> 5
<strong>Explanation:</strong> All the words can be put in a word chain [&quot;xb&quot;, &quot;xb<u>c</u>&quot;, &quot;<u>c</u>xbc&quot;, &quot;<u>p</u>cxbc&quot;, &quot;pcxbc<u>f</u>&quot;].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dbqca&quot;]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The trivial word chain [&quot;abcd&quot;] is one of the longest word chains.
[&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 1000</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 16</code></li>
	<li><code>words[i]</code> only consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-99">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-uncommon-subsequence-ii/description" target="_blank" rel="noopener noreferrer">Longest Uncommon Subsequence II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of strings <code>strs</code>, return <em>the length of the <strong>longest uncommon subsequence</strong> between them</em>. If the longest uncommon subsequence does not exist, return <code>-1</code>.</p>

<p>An <strong>uncommon subsequence</strong> between an array of strings is a string that is a <strong>subsequence of one string but not the others</strong>.</p>

<p>A <strong>subsequence</strong> of a string <code>s</code> is a string that can be obtained after deleting any number of characters from <code>s</code>.</p>

<ul>
	<li>For example, <code>&quot;abc&quot;</code> is a subsequence of <code>&quot;aebdc&quot;</code> because you can delete the underlined characters in <code>&quot;a<u>e</u>b<u>d</u>c&quot;</code> to get <code>&quot;abc&quot;</code>. Other subsequences of <code>&quot;aebdc&quot;</code> include <code>&quot;aebdc&quot;</code>, <code>&quot;aeb&quot;</code>, and <code>&quot;&quot;</code> (empty string).</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> strs = ["aba","cdc","eae"]
<strong>Output:</strong> 3
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> strs = ["aaa","aaa","aa"]
<strong>Output:</strong> -1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= strs.length &lt;= 50</code></li>
	<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>
	<li><code>strs[i]</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-100">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/longest-word-in-dictionary-through-deleting/description" target="_blank" rel="noopener noreferrer">Longest Word in Dictionary through Deleting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a string array <code>dictionary</code>, return <em>the longest string in the dictionary that can be formed by deleting some of the given string characters</em>. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]
<strong>Output:</strong> &quot;apple&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
<strong>Output:</strong> &quot;a&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>
	<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>
	<li><code>s</code> and <code>dictionary[i]</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>The idea behind this approach is as follows. We create a list of all the possible strings that can be formed by deleting one or more characters from the given string <span class="math inline">\(s\)</span>. In order to do so, we make use of a recursive function <code>generate(s, str, i, l)</code> which creates a string by adding and by removing the current character(<span class="math inline">\(i^{th}\)</span>) from the string <span class="math inline">\(s\)</span> to the string <span class="math inline">\(str\)</span> formed till the index <span class="math inline">\(i\)</span>. Thus, it adds the <span class="math inline">\(i^{th}\)</span> character to <span class="math inline">\(str\)</span> and calls itself as <code>generate(s, str + s.charAt(i), i + 1, l)</code>. It also omits the <span class="math inline">\(i^{th}\)</span> character to <span class="math inline">\(str\)</span> and calls itself as <code>generate(s, str, i + 1, l)</code>.</p>
<p>Thus, at the end the list <span class="math inline">\(l\)</span> contains all the required strings that can be formed using <span class="math inline">\(s\)</span>. Then, we look for the strings formed in <span class="math inline">\(l\)</span> into the dictionary available to see if a match is available. Further, in case of a match, we check for the length of the matched string to maximize the length and we also take care to consider the lexicographically smallest string in case of length match as well.</p>
<p><a href="https://leetcode.com/playground/Jgw3jgjB/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(2^n)\)</span>. <code>generate</code> calls itself <span class="math inline">\(2^n\)</span> times. Here, <span class="math inline">\(n\)</span> refers to the length of string <span class="math inline">\(s\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(2^n)\)</span>. List <span class="math inline">\(l\)</span> contains <span class="math inline">\(2^n\)</span> strings.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-2-iterative-brute-force">Approach 2: Iterative Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of using recursive <code>generate</code> to create the list of possible strings that can be formed using <span class="math inline">\(s\)</span> by performing delete operations, we can also do the same process iteratively. To do so, we use the concept of binary number generation.</p>
<p>We can treat the given string <span class="math inline">\(s\)</span> along with a binary represenation corresponding to the indices of <span class="math inline">\(s\)</span>. The rule is that the character at the position <span class="math inline">\(i\)</span> has to be added to the newly formed string <span class="math inline">\(str\)</span> only if there is a boolean 1 at the corresponding index in the binary representation of a number currently considered.</p>
<p>We know a total of <span class="math inline">\(2^n\)</span> such binary numbers are possible if there are <span class="math inline">\(n\)</span> positions to be filled(<span class="math inline">\(n\)</span> also corresponds to the number of characters in <span class="math inline">\(s\)</span>). Thus, we consider all the numbers from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^n\)</span> in their binary representation in a serial order and generate all the strings possible using the above rule.</p>
<p>The figure below shows an example of the strings generated for the given string <span class="math inline">\(s\)</span>:&quot;sea&quot;.</p>
<p><img src="../Figures/524_Longest_Word_Binary.PNG" alt="Longest_Word" /></p>
<p>A problem with this method is that the maximum length of the string can be 32 only, since we make use of an integer and perform the shift operations on it to generate the binary numbers.</p>
<p><a href="https://leetcode.com/playground/8pWWaJ9v/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(2^n)\)</span>. <span class="math inline">\(2^n\)</span> strings are generated.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(2^n)\)</span>. List <span class="math inline">\(l\)</span> contains <span class="math inline">\(2^n\)</span> strings.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-3-sorting-and-checking-subsequence">Approach 3: Sorting and Checking Subsequence</h3>
<p><strong>Algorithm</strong></p>
<p>The matching condition in the given problem requires that we need to consider the matching string in the dictionary with the longest length and in case of same length, the string which is smallest lexicographically. To ease the searching process, we can sort the given dictionary's strings based on the same criteria, such that the more favorable string appears earlier in the sorted dictionary.</p>
<p>Now, instead of performing the deletions in <span class="math inline">\(s\)</span>, we can directly check if any of the words given in the dictionary(say <span class="math inline">\(x\)</span>) is a subsequence of the given string <span class="math inline">\(s\)</span>, starting from the beginning of the dictionary. This is because, if <span class="math inline">\(x\)</span> is a subsequence of <span class="math inline">\(s\)</span>, we can obtain <span class="math inline">\(x\)</span> by performing delete operations on <span class="math inline">\(s\)</span>.</p>
<p>If <span class="math inline">\(x\)</span> is a subsequence of <span class="math inline">\(s\)</span> every character of <span class="math inline">\(x\)</span> will be present in <span class="math inline">\(s\)</span>. The following figure shows the way the subsequence check is done for one example:</p>
<p>!?!../Documents/524_Longest_Word.json:1000,563!?!</p>
<p>As soon as we find any such <span class="math inline">\(x\)</span>, we can stop the search immediately since we've already processed <span class="math inline">\(d\)</span> to our advantage.</p>
<p><a href="https://leetcode.com/playground/fQ4iHKAy/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n \cdot x \log n + n \cdot x)\)</span>. Here <span class="math inline">\(n\)</span> refers to the number of strings in list <span class="math inline">\(d\)</span> and <span class="math inline">\(x\)</span> refers to average string length. Sorting takes <span class="math inline">\(O(n\log n)\)</span> and <code>isSubsequence</code> takes <span class="math inline">\(O(x)\)</span> to check whether a string is a subsequence of another string or not.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log n)\)</span>. Sorting takes <span class="math inline">\(O(\log n)\)</span> space in average case.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-4-without-sorting">Approach 4: Without Sorting</h3>
<p><strong>Algorithm</strong></p>
<p>Since sorting the dictionary could lead to a huge amount of extra effort, we can skip the sorting and directly look for the strings <span class="math inline">\(x\)</span> in the unsorted dictionary <span class="math inline">\(d\)</span> such that <span class="math inline">\(x\)</span> is a subsequence in <span class="math inline">\(s\)</span>. If such a string <span class="math inline">\(x\)</span> is found, we compare it with the other matching strings found till now based on the required length and lexicographic criteria. Thus, after considering every string in <span class="math inline">\(d\)</span>, we can obtain the required result.</p>
<p><a href="https://leetcode.com/playground/ZQKm8jBh/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n \cdot x)\)</span>. One iteration over all strings is required. Here <span class="math inline">\(n\)</span> refers to the number of strings in list <span class="math inline">\(d\)</span> and <span class="math inline">\(x\)</span> refers to average string length.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(x)\)</span>. <span class="math inline">\(max\_str\)</span> variable is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-101">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/long-pressed-name/description" target="_blank" rel="noopener noreferrer">Long Pressed Name</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Your friend is typing his <code>name</code> into a keyboard. Sometimes, when typing a character <code>c</code>, the key might get <em>long pressed</em>, and the character will be typed 1 or more times.</p>

<p>You examine the <code>typed</code> characters of the keyboard. Return <code>True</code> if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> name = &quot;alex&quot;, typed = &quot;aaleex&quot;
<strong>Output:</strong> true
<strong>Explanation: </strong>&#39;a&#39; and &#39;e&#39; in &#39;alex&#39; were long pressed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;
<strong>Output:</strong> false
<strong>Explanation: </strong>&#39;e&#39; must have been pressed twice, but it was not in the typed output.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= name.length, typed.length &lt;= 1000</code></li>
	<li><code>name</code> and <code>typed</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-102">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/magical-string/description" target="_blank" rel="noopener noreferrer">Magical String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A magical string <code>s</code> consists of only <code>&#39;1&#39;</code> and <code>&#39;2&#39;</code> and obeys the following rules:</p>

<ul>
	<li>The string s is magical because concatenating the number of contiguous occurrences of characters <code>&#39;1&#39;</code> and <code>&#39;2&#39;</code> generates the string <code>s</code> itself.</li>
</ul>

<p>The first few elements of <code>s</code> is <code>s = &quot;1221121221221121122&hellip;&hellip;&quot;</code>. If we group the consecutive <code>1</code>&#39;s and <code>2</code>&#39;s in <code>s</code>, it will be <code>&quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot;</code> and the occurrences of <code>1</code>&#39;s or <code>2</code>&#39;s in each group are <code>&quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;</code>. You can see that the occurrence sequence is <code>s</code> itself.</p>

<p>Given an integer <code>n</code>, return the number of <code>1</code>&#39;s in the first <code>n</code> number in the magical string <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 6
<strong>Output:</strong> 3
<strong>Explanation:</strong> The first 6 elements of magical string s is &quot;122112&quot; and it contains three 1&#39;s, so return 3.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-103">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/description" target="_blank" rel="noopener noreferrer">Make String a Subsequence Using Cyclic Increments</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>0-indexed</strong> strings <code>str1</code> and <code>str2</code>.</p>

<p>In an operation, you select a <strong>set</strong> of indices in <code>str1</code>, and for each index <code>i</code> in the set, increment <code>str1[i]</code> to the next character <strong>cyclically</strong>. That is <code>&#39;a&#39;</code> becomes <code>&#39;b&#39;</code>, <code>&#39;b&#39;</code> becomes <code>&#39;c&#39;</code>, and so on, and <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>.</p>

<p>Return <code>true</code> <em>if it is possible to make </em><code>str2</code> <em>a subsequence of </em><code>str1</code> <em>by performing the operation <strong>at most once</strong></em>, <em>and</em> <code>false</code> <em>otherwise</em>.</p>

<p><strong>Note:</strong> A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> str1 = &quot;abc&quot;, str2 = &quot;ad&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Select index 2 in str1.
Increment str1[2] to become &#39;d&#39;. 
Hence, str1 becomes &quot;abd&quot; and str2 is now a subsequence. Therefore, true is returned.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> str1 = &quot;zc&quot;, str2 = &quot;ad&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> Select indices 0 and 1 in str1. 
Increment str1[0] to become &#39;a&#39;. 
Increment str1[1] to become &#39;d&#39;. 
Hence, str1 becomes &quot;ad&quot; and str2 is now a subsequence. Therefore, true is returned.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> str1 = &quot;ab&quot;, str2 = &quot;d&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. 
Therefore, false is returned.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= str1.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= str2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>str1</code> and <code>str2</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We need to find if <code>str2</code> can be made a subsequence of <code>str1</code> by performing at most one cyclic increment operation on any character of <code>str1</code>.</p>
<p>Before diving into the approaches, let's first understand two key concepts: the definition of a subsequence and the cyclic nature of characters.</p>
<h5 id="1-subsequence-definition">1. Subsequence Definition</h5>
<p>A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> because you can obtain <code>&quot;ace&quot;</code> by removing <code>'b'</code> and <code>'d'</code> from <code>&quot;abcde&quot;</code> while maintaining the order of the remaining characters.</p>
<h5 id="2-cyclic-nature-of-characters">2. Cyclic Nature of Characters</h5>
<p>The cyclic nature of characters refers to the wrap-around behavior in the alphabet. Specifically, when you increment a character, it moves to the next character in the alphabet. For example, <code>'a'</code> becomes <code>'b'</code>, <code>'b'</code> becomes <code>'c'</code>, and so on. However, when you reach <code>'z'</code>, the next character wraps around to <code>'a'</code>. This is important to consider because our problem allows for at most one cyclic increment on any character in <code>str1</code>.</p>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach 1: Brute Force (Time Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>If <code>str2</code> is already a subsequence of <code>str1</code> without any modifications, we can immediately return <code>true</code>. However, if <code>str2</code> is not a subsequence, we need to explore the possibility of transforming <code>str2</code> into a subsequence by incrementing certain characters in <code>str1</code>. A logical first solution would be to consider all possible combinations of characters in <code>str1</code> that could be incremented. For each character in <code>str1</code>, we have two options: either increment it or leave it unchanged.</p>
<p>To explore all combinations, we can use a bitmask where each bit represents whether a particular character in <code>str1</code> should be incremented. For example, if <code>str1</code> has <code>3</code> characters, there are <span class="math inline">\(2^3 = 8\)</span> possible combinations <span class="math inline">\((000, 001, 010, 011, 100, 101, 110, 111)\)</span>. A bit set to <code>1</code> means the character is incremented, and a bit set to <code>0</code> means it is not.</p>
<p>To implement this, we need two helper functions:</p>
<ol>
<li><code>getNextChar</code>: This function takes a single character as input and returns the next character in the alphabet, wrapping from <code>'z'</code> to <code>'a'</code></li>
<li><code>isSubsequence</code>: This function checks if <code>str2</code> is a subsequence of <code>str1</code> by iterating through both strings and ensuring that all characters of <code>str2</code> appear in order within <code>str1</code>.</li>
</ol>
<p>In the main function <code>canMakeSubsequence</code>, we iterate through all possible bitmasks. For each mask, we create a temporary copy of <code>str1</code> and apply the increments based on the mask. We then check if <code>str2</code> is a subsequence of the modified <code>str1</code>. If it is, we return <code>true</code>. If no combination works, we return <code>false</code>.</p>
<p>Unfortunately, this approach will time out due to its exponential time complexity, as it explores all possible combinations of character increments.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Define the helper function <code>getNextChar</code> to get the next character cyclically:</p>
<ul>
<li>If the character is <code>'z'</code>, return <code>'a'</code>.</li>
<li>Otherwise, return the next character by incrementing the ASCII value.</li>
</ul>
</li>
<li>
<p>Define the helper function <code>isSubsequence</code> to check if <code>str2</code> is a subsequence of <code>str1</code>:</p>
<ul>
<li>Initialize <code>str1Index</code> and <code>str2Index</code> to <code>0</code> to track positions in both strings.</li>
<li>Traverse through both strings with a <code>while</code> loop:
<ul>
<li>If the characters at <code>str1[str1Index]</code> and <code>str2[str2Index]</code> match, increment <code>str2Index</code>.</li>
<li>Always increment <code>str1Index</code>.</li>
</ul>
</li>
<li>After the loop, check if all characters in <code>str2</code> were matched (i.e., if <code>str2Index == lengthStr2</code>).</li>
</ul>
</li>
<li>
<p>Define the main function <code>canMakeSubsequence</code>:</p>
<ul>
<li>Get the length of <code>str1</code>.</li>
<li>Iterate through all possible combinations of character increments in <code>str1</code> using bitmasking (from <code>0</code> to <code>(1 &lt;&lt; lengthStr1) - 1</code>):
<ul>
<li>For each combination (<code>mask</code>), create a temporary string <code>temp</code> that is a copy of <code>str1</code>.</li>
<li>For each character in <code>str1</code>, check if the corresponding bit in the <code>mask</code> is set:
<ul>
<li>If set, increment the character in <code>temp</code> using <code>getNextChar</code>.</li>
</ul>
</li>
<li>After modifying <code>temp</code>, check if <code>str2</code> is a subsequence of <code>temp</code> using the <code>isSubsequence</code> function.</li>
<li>If <code>str2</code> is found as a subsequence, return <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If no combination makes <code>str2</code> a subsequence of <code>str1</code>, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/TFAwV9oY/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>str1</code> and <span class="math inline">\(m\)</span> be the length of the string <code>str2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(2^n \cdot n \cdot m)\)</span></p>
<p>The algorithm iterates through all possible combinations of character increments using a bitmask. There are <span class="math inline">\(2^n\)</span> possible masks, and for each mask, it modifies the string <code>str1</code> in <span class="math inline">\(O(n)\)</span> time. After modifying the string, it checks if <code>str2</code> is a subsequence of the modified string, which takes <span class="math inline">\(O(n \cdot m)\)</span> time in the worst case. Therefore, the overall time complexity is <span class="math inline">\(O(2^n \cdot n \cdot m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm uses an additional string <code>temp</code> of length <span class="math inline">\(n\)</span> to store the modified version of <code>str1</code>. Additionally, it uses a few integer variables to keep track of indices and lengths. The space used for these variables is constant and does not depend on the input size. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-optimized-single-pass-two-pointer">Approach 2: Optimized Single Pass (Two Pointer)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To solve this more efficiently, we can aim to complete the task in a single pass through <code>str1</code>. We start by iterating through <code>str1</code> and <code>str2</code> simultaneously using two pointers. For each character in <code>str1</code>, we check if it matches the current character in <code>str2</code> or if it can be incremented to match <code>str2</code>. Specifically, we check if <code>str1[str1Index]</code> is equal to <code>str2[str2Index]</code>, or if incrementing <code>str1[str1Index]</code> once (cyclically) results in <code>str2[str2Index]</code>. In an edge case, this means that after <code>'z'</code>, we wrap around to <code>'a'</code>.</p>
<p>To handle this cyclic increment, we need to consider two specific conditions:</p>
<ol>
<li>Direct Increment: If the character in <code>str1</code> can be directly incremented by one to match the character in <code>str2</code>, we use the condition <code>str1[str1Index] + 1 == str2[str2Index]</code>.
<ul>
<li>For example, if <code>str1[str1Index]</code> is <code>'a'</code> and <code>str2[str2Index]</code> is <code>'b'</code>, then <code>'a' + 1</code> equals <code>'b'</code>.</li>
</ul>
</li>
<li>Wrap-Around: If the character in <code>str1</code> is <code>'z'</code>, incrementing it by one should wrap around to <code>'a'</code>. To handle this wrap-around, we use the condition <code>str1[str1Index] - 25 == str2[str2Index]</code>. This is because the ASCII value of <code>'z'</code> is <code>122</code>, and the ASCII value of <code>'a'</code> is <code>97</code>. So, <code>'z' + 1</code> would be <code>123</code>, which is out of the alphabet range. Instead, we subtract <code>25</code> to wrap around to <code>'a'</code>.</li>
</ol>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2825/2825_two_pointer.json:770,555!?!</p>
<blockquote>
<p>For a more comprehensive understanding of the two-pointer technique, explore the <a href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">Two Pointer Explore Card 🔗</a>. This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>str2Index</code> to <code>0</code> to keep track of the current position in <code>str2</code>.</p>
</li>
<li>
<p>Get the length of <code>str1</code> and <code>str2</code> and store them in <code>lengthStr1</code> and <code>lengthStr2</code>.</p>
</li>
<li>
<p>Loop through each character of <code>str1</code> with <code>str1Index</code> starting from <code>0</code>, stopping when either the end of <code>str1</code> or <code>str2</code> is reached:</p>
<ul>
<li>If the character <code>str1[str1Index]</code> matches <code>str2[str2Index]</code>, or if the character <code>str1[str1Index]</code> can be incremented or decremented (by <code>1</code> or by <code>25</code> respectively) to match <code>str2[str2Index]</code>:
<ul>
<li>Move to the next character in <code>str2</code> by incrementing <code>str2Index</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After traversing <code>str1</code>, if <code>str2Index</code> equals <code>lengthStr2</code>, this means all characters in <code>str2</code> have been successfully matched with corresponding characters in <code>str1</code>. Return <code>true</code>.</p>
</li>
<li>
<p>If not all characters in <code>str2</code> were matched by the end of the loop, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3vW3wxMm/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the string <code>str1</code> and <span class="math inline">\(m\)</span> be the length of the string <code>str2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the string <code>str1</code> once using a single for loop. Within each iteration, it performs a constant amount of work (checking character equality and possible transformations). Therefore, the time complexity is linear with respect to the length of <code>str1</code>, which is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space. It only uses a few integer variables (<code>str2Index</code>, <code>lengthStr1</code>, <code>lengthStr2</code>, and <code>str1Index</code>) to keep track of indices and lengths. The space used does not depend on the input size, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-104">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximize-greatness-of-an-array/description" target="_blank" rel="noopener noreferrer">Maximize Greatness of an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a 0-indexed integer array <code>nums</code>. You are allowed to permute <code>nums</code> into a new array <code>perm</code> of your choosing.</p>

<p>We define the <strong>greatness</strong> of <code>nums</code> be the number of indices <code>0 &lt;= i &lt; nums.length</code> for which <code>perm[i] &gt; nums[i]</code>.</p>

<p>Return <em>the <strong>maximum</strong> possible greatness you can achieve after permuting</em> <code>nums</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,3,5,2,1,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
At indices = 0, 1, 3, and 4, perm[i] &gt; nums[i]. Hence, we return 4.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can prove the optimal perm is [2,3,4,1].
At indices = 0, 1, and 2, perm[i] &gt; nums[i]. Hence, we return 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-105">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-distance-between-a-pair-of-values/description" target="_blank" rel="noopener noreferrer">Maximum Distance Between a Pair of Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>non-increasing 0-indexed </strong>integer arrays <code>nums1</code>​​​​​​ and <code>nums2</code>​​​​​​.</p>

<p>A pair of indices <code>(i, j)</code>, where <code>0 &lt;= i &lt; nums1.length</code> and <code>0 &lt;= j &lt; nums2.length</code>, is <strong>valid</strong> if both <code>i &lt;= j</code> and <code>nums1[i] &lt;= nums2[j]</code>. The <strong>distance</strong> of the pair is <code>j - i</code>​​​​.</p>

<p>Return <em>the <strong>maximum distance</strong> of any <strong>valid</strong> pair </em><code>(i, j)</code><em>. If there are no valid pairs, return </em><code>0</code>.</p>

<p>An array <code>arr</code> is <strong>non-increasing</strong> if <code>arr[i-1] &gt;= arr[i]</code> for every <code>1 &lt;= i &lt; arr.length</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).
The maximum distance is 2 with pair (2,4).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [2,2,2], nums2 = [10,10,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The valid pairs are (0,0), (0,1), and (1,1).
The maximum distance is 1 with pair (0,1).
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
The maximum distance is 2 with pair (2,4).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>
	<li>Both <code>nums1</code> and <code>nums2</code> are <strong>non-increasing</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-106">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/description" target="_blank" rel="noopener noreferrer">Maximum Enemy Forts That Can Be Captured</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>forts</code> of length <code>n</code> representing the positions of several forts. <code>forts[i]</code> can be <code>-1</code>, <code>0</code>, or <code>1</code> where:</p>

<ul>
	<li><code>-1</code> represents there is <strong>no fort</strong> at the <code>i<sup>th</sup></code> position.</li>
	<li><code>0</code> indicates there is an <strong>enemy</strong> fort at the <code>i<sup>th</sup></code> position.</li>
	<li><code>1</code> indicates the fort at the <code>i<sup>th</sup></code> the position is under your command.</li>
</ul>

<p>Now you have decided to move your army from one of your forts at position <code>i</code> to an empty position <code>j</code> such that:</p>

<ul>
	<li><code>0 &lt;= i, j &lt;= n - 1</code></li>
	<li>The army travels over enemy forts <strong>only</strong>. Formally, for all <code>k</code> where <code>min(i,j) &lt; k &lt; max(i,j)</code>, <code>forts[k] == 0.</code></li>
</ul>

<p>While moving the army, all the enemy forts that come in the way are <strong>captured</strong>.</p>

<p>Return<em> the <strong>maximum</strong> number of enemy forts that can be captured</em>. In case it is <strong>impossible</strong> to move your army, or you do not have any fort under your command, return <code>0</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> forts = [1,0,0,-1,0,0,0,0,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong>
- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
- Moving the army from position 8 to position 3 captures 4 enemy forts.
Since 4 is the maximum number of enemy forts that can be captured, we return 4.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> forts = [0,0,1,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since no enemy fort can be captured, 0 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= forts.length &lt;= 1000</code></li>
	<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-107">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-matching-of-players-with-trainers/description" target="_blank" rel="noopener noreferrer">Maximum Matching of Players With Trainers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>players</code>, where <code>players[i]</code> represents the <strong>ability</strong> of the <code>i<sup>th</sup></code> player. You are also given a <strong>0-indexed</strong> integer array <code>trainers</code>, where <code>trainers[j]</code> represents the <strong>training capacity </strong>of the <code>j<sup>th</sup></code> trainer.</p>

<p>The <code>i<sup>th</sup></code> player can <strong>match</strong> with the <code>j<sup>th</sup></code> trainer if the player&#39;s ability is <strong>less than or equal to</strong> the trainer&#39;s training capacity. Additionally, the <code>i<sup>th</sup></code> player can be matched with at most one trainer, and the <code>j<sup>th</sup></code> trainer can be matched with at most one player.</p>

<p>Return <em>the <strong>maximum</strong> number of matchings between </em><code>players</code><em> and </em><code>trainers</code><em> that satisfy these conditions.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> players = [4,7,9], trainers = [8,2,5,8]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
One of the ways we can form two matchings is as follows:
- players[0] can be matched with trainers[0] since 4 &lt;= 8.
- players[1] can be matched with trainers[3] since 7 &lt;= 8.
It can be proven that 2 is the maximum number of matchings that can be formed.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> players = [1,1,1], trainers = [10]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
The trainer can be matched with any of the 3 players.
Each player can only be matched with one trainer, so the maximum answer is 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= players.length, trainers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= players[i], trainers[j] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Note:</strong> This question is the same as <a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank"> 445: Assign Cookies.</a></p>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h3 id="approach-sorting--two-pointers--greedy">Approach: Sorting + Two Pointers + Greedy</h3>
<h4 id="intuition">Intuition</h4>
<p>To match the maximum number of athletes, we can follow a greedy strategy: sort both athletes and trainers in increasing order of ability, and for each athlete, assign the trainer with the smallest possible ability who can still match that athlete. This ensures that stronger trainers are preserved for athletes who need them.</p>
<p>Let’s understand why this works.</p>
<p>Suppose there are <span class="math inline">\(m\)</span> athletes, with their abilities stored in the array <code>players[0]</code> to <code>players[m - 1]</code>, and <span class="math inline">\(n\)</span> trainers, with abilities in <code>trainers[0]</code> to <code>trainers[n - 1]</code>. We assume both arrays are sorted in non-decreasing order.</p>
<p>Now consider matching trainers to athletes one by one. Suppose we’ve already matched trainers to the first <span class="math inline">\(i - 1\)</span> athletes. For the <span class="math inline">\(i\)</span>-th athlete, we want to match the trainer with the smallest ability who can still satisfy this athlete, i.e., the first trainer <code>trainers[j]</code> such that <code>trainers[j] ≥ players[i]</code>.</p>
<p>We argue that this is optimal:</p>
<ul>
<li>
<p><strong>Case 1</strong>: If <code>players[i + 1] ≤ trainers[j]</code>, then we could match <code>trainers[j]</code> to <code>players[i + 1]</code> and <code>trainers[j + 1]</code> to <code>players[i]</code>, but this would still result in the same number of total matches.</p>
</li>
<li>
<p><strong>Case 2</strong>: If <code>trainers[j + 1]</code> is used for <code>players[i]</code> instead of <code>trainers[j]</code>, and if <code>players[i + 1] &gt; trainers[j]</code>, then <code>trainers[j]</code> will not be able to match any athlete, reducing the total number of matches.</p>
</li>
</ul>
<p>Hence, it's better to use the smallest suitable trainer for each athlete in order.</p>
<p>Based on the above analysis, we can apply a greedy method to match the maximum number of athletes. First, sort both the <code>players</code> and <code>trainers</code> arrays in increasing order. Then, use two pointers: one for iterating through the <code>players</code> array and the other for the <code>trainers</code> array. For each player, we try to find the first available trainer whose ability is greater than or equal to that of the player.</p>
<p>Because both arrays are sorted, we can find matches using a single linear pass. If a trainer can match a player, we count it and move both pointers forward. If the current trainer is not strong enough, we move to the next trainer. This continues until we reach the end of either array. At that point, the number of successful matches recorded is the maximum number of athletes that can be matched with the available trainers.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/bxD4hvHZ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the length of the <code>players</code> array, and <span class="math inline">\(n\)</span> be the length of the <code>trainers</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \log m + n \log n)\)</span>.</p>
<p>We sort both arrays, which takes <span class="math inline">\(O(m \log m)\)</span> and <span class="math inline">\(O(n \log n)\)</span> time respectively. After sorting, we traverse both arrays once using two pointers, which takes <span class="math inline">\(O(m + n)\)</span> time. So the overall time complexity is: <span class="math inline">\(O(m \log m + n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log m + \log n)\)</span></p>
<p>The space complexity mainly refers to the additional space required for sorting.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-108">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/description" target="_blank" rel="noopener noreferrer">Maximum Number of Non-overlapping Palindrome Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a <strong>positive</strong> integer <code>k</code>.</p>

<p>Select a set of <strong>non-overlapping</strong> substrings from the string <code>s</code> that satisfy the following conditions:</p>

<ul>
	<li>The <strong>length</strong> of each substring is <strong>at least</strong> <code>k</code>.</li>
	<li>Each substring is a <strong>palindrome</strong>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> number of substrings in an optimal selection</em>.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abaccdbbd&quot;, k = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can select the substrings underlined in s = &quot;<u><strong>aba</strong></u>cc<u><strong>dbbd</strong></u>&quot;. Both &quot;aba&quot; and &quot;dbbd&quot; are palindromes and have a length of at least k = 3.
It can be shown that we cannot find a selection with more than two valid substrings.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;adbcda&quot;, k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no palindrome substring of length at least 2 in the string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-109">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-points-from-grid-queries/description" target="_blank" rel="noopener noreferrer">Maximum Number of Points From Grid Queries</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span> <span class="topic-badge">union find</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>

<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>

<ul>
	<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>
	<li>Otherwise, you do not get any points, and you end this process.</li>
</ul>

<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>

<p>Return <em>the resulting array</em> <code>answer</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2025/03/15/image1.png" style="width: 571px; height: 152px;" />
<pre>
<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]
<strong>Output:</strong> [5,8,1]
<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" />
<pre>
<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]
<strong>Output:</strong> [0]
<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
	<li><code>k == queries.length</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> matrix <code>grid</code> and an array of queries, <code>queries</code>. For each query, we attempt to collect as many points as possible while following specific movement rules that dictate how far we can traverse the grid.</p>
<p>For each <code>queries[i]</code>, we begin at the top-left corner of the grid. We are allowed to move in four directions: up, down, left, and right. The primary condition governing movement is the comparison between <code>queries[i]</code> and the value of the current cell:</p>
<ol>
<li>
<p>If <code>queries[i]</code> is strictly greater than the value of the current cell, then:</p>
<ul>
<li>If this is the first time visiting the cell, we earn one point.</li>
<li>We can then move to any of the adjacent cells (if they exist).</li>
</ul>
</li>
<li>
<p>If <code>queries[i]</code> is less than or equal to the value of the current cell, then:</p>
<ul>
<li>We cannot proceed further from this cell.</li>
<li>The process for this query terminates immediately.</li>
</ul>
</li>
</ol>
<p>The final result for <code>queries[i]</code> is the number of unique cells we were able to collect points from.</p>
<blockquote>
<p>Note: Each query starts independently, meaning that the traversal for one query does not affect the traversal for another.</p>
</blockquote>
<p>Another difficult but extremely practical way to phrase this problem is to imagine you're at a buffet, where you can only eat dishes that are under a certain calorie count. Each dish represents a number in the grid, and your queries are your calorie limits. You want to know how many dishes you can indulge in without exceeding your limit. The algorithm helps you quickly determine how many dishes fit your criteria, allowing you to make the most of your buffet experience! Sometimes, the representation of data is more important than the data itself.</p>
<p>To solve this problem, we need a solid understanding of BFS, priority queues, and disjoint union. While we will explain the application of these concepts, we will not go in-depth into their theoretical aspects and their basic structure.</p>
<p>For a deeper understanding of the theory or to learn how the general conceptual implementation works, please check out the following explore cards:</p>
<ul>
<li><a href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/">BFS and Priority Queue</a></li>
<li><a href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/">Union Find</a></li>
<li><a href="https://leetcode.com/explore/learn/card/binary-search/">Binary Search</a></li>
</ul>
<hr />
<h3 id="approach-1-brute-force-tle">Approach 1: Brute Force (TLE)</h3>
<h4 id="intuition">Intuition</h4>
<p>For each query value, we need to determine how many cells in the grid have a value strictly less than the query while ensuring we only move to adjacent cells. This naturally forms a graph traversal problem where each cell is treated as a node connected to its adjacent cells. Since we are interested in finding all reachable nodes that satisfy a condition, Breadth-First Search (BFS) is a suitable choice. BFS explores all nodes at the current level before moving to the next, ensuring we do not miss any reachable cells that meet the criteria.</p>
<p>For each query, we begin at the <code>(0,0)</code> cell and initialize a queue for BFS traversal. We also maintain a <code>visited</code> boolean matrix to ensure we do not revisit cells. The traversal continues as long as there are unprocessed cells in the queue. At each step, we check if the current cell’s value is greater than or equal to the query value. If it is, we cannot proceed further from this cell. Otherwise, we count the cell as visited, increment our result, and attempt to move to its four adjacent cells (up, down, left, and right). Any adjacent cell that has not been visited and has a value strictly less than the query is added to the queue.</p>
<p>Since each query is independent, we repeat this process for each of them. The final result for each query is the total number of unique cells that we were able to visit while following the movement constraints.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Iterate over each query:</p>
<ul>
<li>
<p>Extract <code>queryValue</code> from <code>queries</code>.</p>
</li>
<li>
<p>Initialize a BFS queue starting from <code>(0,0)</code>.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track visited cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Initialize <code>points</code> to count valid cells.</p>
</li>
<li>
<p>Perform BFS:</p>
<ul>
<li>Get the current queue size to process all elements at this level.</li>
<li>Iterate over the queue:
<ul>
<li>Extract <code>currentRow</code> and <code>currentCol</code> from the front.</li>
<li>If <code>grid[currentRow][currentCol] &gt;= queryValue</code>, skip processing.</li>
<li>Otherwise, increment <code>points</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds, not visited, and value is <code>&lt; queryValue</code>, mark <code>(newRow, newCol)</code> as visited and add it to the queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Store <code>points</code> in <code>result</code> at the corresponding query index.</p>
</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/jtezm3QA/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \cdot n \cdot m)\)</span></p>
<p>The outer loop runs <span class="math inline">\(k\)</span> times, once for each query. In each iteration, a BFS is performed on the grid. In the worst case, the BFS will visit every cell in the grid, which is <span class="math inline">\(n \cdot m\)</span> cells. Therefore, the time complexity for each query is <span class="math inline">\(O(n \cdot m)\)</span>, and for all queries, it becomes <span class="math inline">\(O(k \cdot n \cdot m)\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor, which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by the <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>. This matrix is used to keep track of visited cells during the BFS traversal.</p>
<p>The BFS queue can also hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case (e.g., when all cells are part of the BFS traversal). Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting-queries--min-heap-expansion">Approach 2: Sorting Queries + Min-Heap Expansion</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the brute force approach, we restart the search from the top-left corner for every query, treating each query as an independent problem. This results in a significant amount of redundant work because many queries share overlapping information. If a smaller query has already determined that certain cells are accessible, then a larger query should be able to reuse that information instead of starting from scratch. This suggests that instead of treating each query separately, we can process them in an order that allows us to build on previously discovered results, avoiding unnecessary recomputation.</p>
<p>A natural way to achieve this is to <strong>sort the queries in increasing order</strong> while keeping track of their original indices. By doing this, we ensure that when we process a query, all smaller queries have already been resolved. This allows us to maintain a growing region of accessible cells rather than restarting the search for each query.</p>
<p>To efficiently manage this expanding region, we use a <strong>min-heap (priority queue)</strong>. The heap allows us to always expand from the lowest-value cell first, ensuring that we process cells in the correct order. We begin by inserting the top-left cell <code>(grid[0][0], (0,0))</code> into the heap.</p>
<p>As long as the smallest cell in the heap has a value less than the current query, we remove it from the heap, mark it as visited, and attempt to expand outward by pushing all its unvisited neighbors into the heap. Since the heap maintains the smallest-value cell at the top, this ensures that we always expand the lowest-value region before moving to higher values. If the smallest cell's value is greater than or equal to the current query's value, we store the current count of reachable cells in the answer array and continue expanding with the next query's value as the new threshold.</p>
<p>By the time we process a query, all the cells that could have been visited with smaller query values have already been handled. This allows us to directly store the number of reachable cells without restarting the traversal. Instead of performing redundant BFS searches for each query, we maintain a continuous expansion process, ensuring that each cell is processed only once.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Get the number of rows (<code>rowCount</code>) and columns (<code>colCount</code>) in <code>grid</code>.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Define <code>DIRECTIONS</code> array to facilitate movement in four directions.</p>
</li>
<li>
<p>Create a <code>sortedQueries</code> array to store queries along with their original indices.</p>
</li>
<li>
<p>Sort <code>sortedQueries</code> by query values in ascending order.</p>
</li>
<li>
<p>Initialize a min-heap (<code>minHeap</code>) to expand cells in increasing order of <code>grid</code> values.</p>
</li>
<li>
<p>Create a <code>visited</code> matrix to track processed cells and mark <code>(0,0)</code> as visited.</p>
</li>
<li>
<p>Push <code>{grid[0][0], {0, 0}}</code> into <code>minHeap</code> to start expansion.</p>
</li>
<li>
<p>Initialize <code>totalPoints</code> to count valid cells.</p>
</li>
<li>
<p>Iterate over sorted queries:</p>
<ul>
<li>Extract <code>queryValue</code> and <code>queryIndex</code>.</li>
<li>Expand cells while <code>minHeap</code> contains values <code>&lt; queryValue</code>:
<ul>
<li>Pop the smallest <code>cellValue</code> and its position.</li>
<li>Increment <code>totalPoints</code>.</li>
<li>Explore four possible directions:
<ul>
<li>Compute <code>newRow</code> and <code>newCol</code> as the adjacent cell.</li>
<li>If within bounds and not visited, push <code>{grid[newRow][newCol], {newRow, newCol}}</code> into <code>minHeap</code> and mark the cell as visited.</li>
</ul>
</li>
</ul>
</li>
<li>Store <code>totalPoints</code> in <code>result</code> at the corresponding query index.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the count of valid points for each query.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3F8Ff5Ud/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span></p>
<p>The algorithm first sorts the <code>k</code> queries, which takes <span class="math inline">\(O(k \log k)\)</span> time. Then, for each query, it processes cells using a min-heap. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed and pushed into the heap. Each heap operation (push or pop) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, processing all cells takes <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + n \cdot m \log (n \cdot m))\)</span>.</p>
<blockquote>
<p>Note: The exploration of 4 directions for each cell contributes a constant factor which does not change the overall time complexity.</p>
</blockquote>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m + k)\)</span></p>
<p>The space complexity is dominated by:</p>
<ol>
<li>The <code>visited</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The min-heap, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells in the worst case.</li>
<li>The <code>sortedQueries</code> vector, which stores <code>k</code> pairs of values and indices.</li>
</ol>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m + k)\)</span>.</p>
<p>The <code>DIRECTIONS</code> array and other variables use constant space and do not significantly impact the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-priority-queue-with-binary-search">Approach 3: Using Priority Queue with Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the previous approach, we processed queries sequentially and used a min-heap to expand the reachable region in increasing order, allowing us to efficiently determine the number of points collected for each query. In this approach, we will separate the precomputation step from the answer calculation to improve algorithmic clarity.</p>
<p>To implement this, we can preprocess the grid <strong>once</strong> and store the results in a structured way so that queries can be answered in constant or logarithmic time. The key insight is that every cell in the grid has a <strong>minimum value threshold</strong> that must be met in order for it to be reached. If we can determine the smallest query value required to reach each number of points, we can use <strong>binary search</strong> to efficiently answer all queries.</p>
<p>So we will begin by treating this as a shortest-path problem where we want to determine the minimum &quot;effort&quot; required to reach each cell. We can use <strong>Dijkstra’s algorithm</strong> with a min-heap to explore the grid in order of increasing cost. Each cell <code>(i, j)</code> is processed in order of its minimum required value, and we update its neighbors with the maximum value seen along the way. This ensures that we always determine the optimal way to reach a cell.</p>
<p>Thus, our approach will be divided into three key steps:</p>
<ol>
<li>Reformulating the Problem as a Shortest-Path Search</li>
<li>Running Dijkstra’s Algorithm</li>
<li>Answering Queries Using Binary Search</li>
</ol>
<h5 id="step-1-reformulating-the-problem-as-a-shortest-path-search"><strong>Step 1: Reformulating the Problem as a Shortest-Path Search</strong></h5>
<p>Instead of handling each query separately, we treat the grid as a <strong>weighted graph</strong> where each cell <code>(i, j)</code> has a weight equal to <code>grid[i][j]</code>. The goal is to expand outwards from <code>(0,0)</code>, adding cells in increasing order of their values. We need to determine <strong>the minimum effort required to reach each cell</strong>, which means that a Dijkstra-like algorithm is appropriate.</p>
<p>We use a min-heap (priority queue) to always expand the cell with the lowest current value. Each time we expand to a new cell, we record the maximum value encountered along that path. This ensures that we always determine the optimal way to reach a cell before processing its neighbors.</p>
<p>To keep track of how many points can be collected for any given query threshold, we maintain an array <code>thresholdForMaxPoints</code>, where <code>thresholdForMaxPoints[k]</code> stores the <strong>smallest query value</strong> required to collect <code>k</code> points.</p>
<h5 id="step-2-running-dijkstras-algorithm"><strong>Step 2: Running Dijkstra’s Algorithm</strong></h5>
<p>We begin by initializing a min-heap with the starting cell <code>(0,0)</code>, assigning it a value equal to <code>grid[0][0]</code>. This heap will allow us to always expand towards the next reachable cell with the smallest value, ensuring that we process cells in the correct order.</p>
<p>As we expand outward, we repeatedly extract the smallest value from the heap, which represents the next cell to be processed. From there, we attempt to move to the neighboring cells, as long as they are not already visited— this guarantees that we always find the optimal path to reach it.</p>
<p>For each newly reached cell <code>(i, j)</code>, we compute the minimum threshold required to access it. This is determined by taking the maximum value encountered along the path leading to that cell. In other words, we track the largest value that must be surpassed in order to reach <code>(i, j)</code>.</p>
<p>As we continue expanding, we maintain an array <code>thresholdForMaxPoints</code>, where each entry records the smallest query value required to collect a given number of points. Each time we reach a new cell, we store its threshold in this array, associating it with the number of cells we have accessed so far.</p>
<p>By the end of this process, <code>thresholdForMaxPoints[k]</code> holds the <strong>minimum query value</strong> needed to collect exactly <code>k</code> points.</p>
<h5 id="step-3-answering-queries-using-binary-search"><strong>Step 3: Answering Queries Using Binary Search</strong></h5>
<p>Once we have preprocessed the grid, answering a query reduces to a simple binary search on <code>thresholdForMaxPoints</code>. Since we stored thresholds in increasing order, binary search allows us to determine in <strong>logarithmic time</strong> how many points can be collected for a given query.</p>
<p>For a query <code>threshold</code>, we search for the <strong>largest index <code>k</code></strong> such that <code>thresholdForMaxPoints[k] &lt; threshold</code>. The answer to the query is simply <code>k</code>, the number of points that can be collected.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2503/approach3.json:630,940!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Define <code>DIRECTIONS</code> to facilitate movement in four directions.</p>
</li>
<li>
<p>Initialize <code>result</code> array to store the number of points for each query.</p>
</li>
<li>
<p>Get <code>rowCount</code> and <code>colCount</code> from <code>grid</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Create <code>thresholdForMaxPoints</code>, where index <code>i</code> stores the minimum query value required to reach <code>i</code> cells.</p>
</li>
<li>
<p>Create <code>minValueToReach</code>, where <code>minValueToReach[i][j]</code> holds the maximum value encountered to reach <code>(i, j)</code>, initialized to <code>MAX_VALUE</code>.</p>
</li>
<li>
<p>Run Dijkstra’s algorithm:</p>
<ul>
<li>Use <code>minHeap</code> (min-priority queue) to explore cells in increasing order of encountered values.</li>
<li>Start from <code>(0,0)</code>, setting <code>minValueToReach[0][0] = grid[0][0]</code> and pushing it into <code>minHeap</code>.</li>
<li>While <code>minHeap</code> is not empty:
<ul>
<li>Extract the cell with the smallest encountered value.</li>
<li>Store the encountered value in <code>thresholdForMaxPoints[++visitedCells]</code>.</li>
<li>Explore four possible directions:
<ul>
<li>If the adjacent cell <code>(newRow, newCol)</code> is within bounds and unvisited:
<ul>
<li>Update its <code>minValueToReach</code> as the maximum of the value to reach the current cell and  <code>grid[newRow][newCol]</code>.</li>
<li>Push it into <code>minHeap</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Process queries using binary search:</p>
<ul>
<li>For each <code>queries[i]</code>, find the rightmost <code>mid</code> where <code>thresholdForMaxPoints[mid] &lt; threshold</code>.</li>
<li>Initialize <code>left = 0</code>, <code>right = totalCells</code>.</li>
<li>Perform binary search:
<ul>
<li>Compute <code>mid = (left + right + 1) / 2</code>.</li>
<li>If <code>thresholdForMaxPoints[mid] &lt; threshold</code>, move <code>left = mid</code>.</li>
<li>Otherwise, adjust <code>right = mid - 1</code>.</li>
</ul>
</li>
<li>Store <code>left</code> in <code>result[i]</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/YbXEgeXX/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span></p>
<p>The algorithm uses a min-heap to perform a modified Dijkstra's traversal. In the worst case, all <span class="math inline">\(n \cdot m\)</span> cells are processed, and each heap operation (insertion or extraction) takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(n \cdot m \log (n \cdot m))\)</span>.</p>
<p>For each of the <code>k</code> queries, a binary search is performed on the <code>thresholdForMaxPoints</code> array, which has a size of <span class="math inline">\((n \cdot m) + 1\)</span>. Each binary search operation takes <span class="math inline">\(O(\log (n \cdot m))\)</span> time. Therefore, the time complexity for this part is <span class="math inline">\(O(k \log (n \cdot m))\)</span>.</p>
<p>Combining these, the overall time complexity is <span class="math inline">\(O(n \cdot m \log (n \cdot m) + k \log (n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n \cdot m)\)</span></p>
<p>The space complexity is dominated by:</p>
<ul>
<li>The <code>minHeap</code>, which can hold up to <span class="math inline">\(n \cdot m\)</span> cells.</li>
<li>The <code>minValueToReach</code> matrix, which is of size <span class="math inline">\(n \cdot m\)</span>.</li>
<li>The <code>thresholdForMaxPoints</code> array, which is of size <span class="math inline">\((n \cdot m) + 1\)</span>.</li>
</ul>
<p>Therefore, the overall space complexity is <span class="math inline">\(O(n \cdot m)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-disjoint-set-union-union-find">Approach 4: Disjoint Set Union (Union-Find)</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Instead of handling queries one by one, we can take a different approach where we process all grid cells first and answer queries afterward. This allows us to efficiently determine the number of reachable points for each query without having to traverse the grid multiple times.</p>
<p>To better understand this approach, let's reiterate our previous observation in a slightly different way. Think about what each query is asking. A query provides a threshold value and asks how many cells in the grid can be reached from the top-left corner <code>(0,0)</code>, while ensuring that all visited cells have values strictly less than this threshold. Instead of iterating over the grid every time a query is given, we can reverse the problem: first process the grid in increasing order of cell values, then efficiently answer all queries using this precomputed information.</p>
<p>To do this, we first extract all the grid cells and sort them in ascending order based on their values. By processing these cells in this order, we can simulate how the reachable area grows as the threshold increases. We maintain a <strong>disjoint set union (Union-Find) data structure</strong> to dynamically merge connected components as we encounter new cells with increasing values.</p>
<p>As we iterate through the sorted grid cells, we add each cell to our Union-Find structure. Whenever we add a cell, we also check its four adjacent neighbors (up, down, left, and right). If a neighbor has already been processed, we merge the current cell with its neighboring cell in the Union-Find structure. This ensures that, at any given moment, all connected components represent regions of the grid where all cells have values strictly less than the current threshold.</p>
<p>At the same time, we also sort the queries in ascending order based on their values. As we process each query, we continue adding cells to our Union-Find structure until the current cell values reach or exceed the query threshold. Once we finish adding all the relevant cells for a query, we determine how many of these cells are reachable from <code>(0,0)</code>. Since the Union-Find structure keeps track of the size of connected components, we can efficiently find the number of reachable cells by checking the size of the component that contains <code>(0,0)</code>.</p>
<p>If the query value is greater than <code>grid[0][0]</code>, then the number of reachable cells is simply the size of the connected component containing <code>(0,0)</code>. Otherwise, no additional cells are reachable, and the answer for this query is <code>0</code>.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>
<p>Define <code>Cell(row, col, value)</code> to represent grid cells and <code>Query(index, value)</code> to store queries with their original indices.</p>
</li>
<li>
<p>Initialize <code>ROW_DIRECTIONS</code> and <code>COL_DIRECTIONS</code> for moving in four directions.</p>
</li>
<li>
<p>Extract <code>rowCount</code> and <code>colCount</code>, compute <code>totalCells = rowCount * colCount</code>.</p>
</li>
<li>
<p>Sort queries:</p>
<ul>
<li>Store each query as a <code>Query</code> object in <code>sortedQueries</code>.</li>
<li>Sort <code>sortedQueries</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Sort grid cells:</p>
<ul>
<li>Store each cell as a <code>Cell</code> object in <code>sortedCells</code>.</li>
<li>Sort <code>sortedCells</code> based on <code>value</code> in ascending order.</li>
</ul>
</li>
<li>
<p>Initialize <code>UnionFind</code> data structure for dynamic connectivity.</p>
</li>
<li>
<p>Process queries:</p>
<ul>
<li>Iterate over <code>sortedQueries</code>, maintaining an index <code>cellIndex</code> to track which cells have been processed.</li>
<li>While <code>sortedCells[cellIndex].value &lt; query.value</code>, mark the cell as processed and merge it with already processed adjacent cells using <code>UnionFind.union()</code>.</li>
<li>Compute the size of the connected component containing <code>(0,0)</code>, storing the result for <code>query.index</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, containing the number of points collected for each query.</p>
</li>
</ul>
<h5 id="unionfind-class"><strong><code>UnionFind</code> Class:</strong></h5>
<ul>
<li>
<p>Define <code>UnionFind</code> class for disjoint set operations.</p>
</li>
<li>
<p>Declare <code>parent</code> array to track the representative of each set.</p>
</li>
<li>
<p>Declare <code>size</code> array to store the size of each set.</p>
</li>
<li>
<p>Constructor (<code>UnionFind(int n)</code>):</p>
<ul>
<li>Initialize <code>parent</code> with <code>-1</code>, indicating each element is its own set.</li>
<li>Initialize <code>size</code> to <code>1</code>, as each set initially has one element.</li>
</ul>
</li>
<li>
<p><code>find(int node)</code>: Implements path compression to optimize lookup.</p>
<ul>
<li>If <code>parent[node]</code> is <code>-1</code>, it is the root and returned.</li>
<li>Otherwise, recursively find the root and apply path compression (<code>parent[node] = find(parent[node])</code>).</li>
</ul>
</li>
<li>
<p><code>union(int nodeA, int nodeB)</code>:</p>
<ul>
<li>Find roots of <code>nodeA</code> and <code>nodeB</code>.</li>
<li>If both nodes share the same root, they are already in the same set, return <code>false</code>.</li>
<li>Otherwise, perform union by size:
<ul>
<li>Attach the smaller tree to the larger tree.</li>
<li>Update <code>size</code> accordingly.</li>
</ul>
</li>
<li>Return <code>true</code> to indicate a successful union.</li>
</ul>
</li>
<li>
<p><code>getSize(int node)</code>:</p>
<ul>
<li>Find the root of <code>node</code> and return the size of its set.</li>
</ul>
</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/8CUbzoZh/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> be the number of rows and columns in the grid, respectively, and <span class="math inline">\(k\)</span> be the number of queries.</p>
<blockquote>
<p><span class="math inline">\(n \cdot m\)</span> is basically the total number of cells in the grid.</p>
</blockquote>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span></p>
<p>The time complexity arises from several steps. First, sorting the <code>queries</code> array takes <span class="math inline">\(O(k \log k)\)</span>. Second, sorting the <code>sortedCells</code> array takes <span class="math inline">\(O((n \cdot m) \log (n \cdot m))\)</span>. Finally, processing each query involves iterating through the cells and performing union-find operations.</p>
<p>The union-find operations, with path compression and union by size, have an amortized time complexity of <span class="math inline">\(O(\alpha(n \cdot m))\)</span>, where <span class="math inline">\(\alpha\)</span> is the inverse Ackermann function (practically constant).</p>
<p>Since we process up to <code>totalCells</code> cells for each query, the total time for all queries is <span class="math inline">\(O(k \cdot \alpha(n \cdot m))\)</span>. Combining these, the overall time complexity is <span class="math inline">\(O(k \log k + (n \cdot m) \log (n \cdot m) + k \cdot \alpha(n \cdot m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O((n \cdot m) + k)\)</span></p>
<p>The space complexity is dominated by the <code>sortedQueries</code> array, which takes <span class="math inline">\(O(k)\)</span> space, the <code>sortedCells</code> array, which takes <span class="math inline">\(O(n \cdot m)\)</span> space, and the <code>UnionFind</code> data structure, which uses <span class="math inline">\(O(n \cdot m)\)</span> space for the <code>parent</code> and <code>size</code> arrays. Therefore, the overall space complexity is <span class="math inline">\(O((n \cdot m) + k)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-110">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-removable-characters/description" target="_blank" rel="noopener noreferrer">Maximum Number of Removable Characters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>p</code> where <code>p</code> is a <strong>subsequence </strong>of <code>s</code>. You are also given a <strong>distinct 0-indexed </strong>integer array <code>removable</code> containing a subset of indices of <code>s</code> (<code>s</code> is also <strong>0-indexed</strong>).</p>

<p>You want to choose an integer <code>k</code> (<code>0 &lt;= k &lt;= removable.length</code>) such that, after removing <code>k</code> characters from <code>s</code> using the <strong>first</strong> <code>k</code> indices in <code>removable</code>, <code>p</code> is still a <strong>subsequence</strong> of <code>s</code>. More formally, you will mark the character at <code>s[removable[i]]</code> for each <code>0 &lt;= i &lt; k</code>, then remove all marked characters and check if <code>p</code> is still a subsequence.</p>

<p>Return <em>the <strong>maximum</strong> </em><code>k</code><em> you can choose such that </em><code>p</code><em> is still a <strong>subsequence</strong> of </em><code>s</code><em> after the removals</em>.</p>

<p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcacb&quot;, p = &quot;ab&quot;, removable = [3,1,0]
<strong>Output:</strong> 2
<strong>Explanation</strong>: After removing the characters at indices 3 and 1, &quot;a<s><strong>b</strong></s>c<s><strong>a</strong></s>cb&quot; becomes &quot;accb&quot;.
&quot;ab&quot; is a subsequence of &quot;<strong><u>a</u></strong>cc<strong><u>b</u></strong>&quot;.
If we remove the characters at indices 3, 1, and 0, &quot;<s><strong>ab</strong></s>c<s><strong>a</strong></s>cb&quot; becomes &quot;ccb&quot;, and &quot;ab&quot; is no longer a subsequence.
Hence, the maximum k is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcbddddd&quot;, p = &quot;abcd&quot;, removable = [3,2,1,4,5,6]
<strong>Output:</strong> 1
<strong>Explanation</strong>: After removing the character at index 3, &quot;abc<s><strong>b</strong></s>ddddd&quot; becomes &quot;abcddddd&quot;.
&quot;abcd&quot; is a subsequence of &quot;<u><strong>abcd</strong></u>dddd&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcab&quot;, p = &quot;abc&quot;, removable = [0,1,2,3,4]
<strong>Output:</strong> 0
<strong>Explanation</strong>: If you remove the first index in the array removable, &quot;abc&quot; is no longer a subsequence.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= p.length &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= removable.length &lt; s.length</code></li>
	<li><code>0 &lt;= removable[i] &lt; s.length</code></li>
	<li><code>p</code> is a <strong>subsequence</strong> of <code>s</code>.</li>
	<li><code>s</code> and <code>p</code> both consist of lowercase English letters.</li>
	<li>The elements in <code>removable</code> are <strong>distinct</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-111">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description" target="_blank" rel="noopener noreferrer">Maximum Number of Tasks You Can Assign</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic queue</span> <span class="topic-badge">queue</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> tasks and <code>m</code> workers. Each task has a strength requirement stored in a <strong>0-indexed</strong> integer array <code>tasks</code>, with the <code>i<sup>th</sup></code> task requiring <code>tasks[i]</code> strength to complete. The strength of each worker is stored in a <strong>0-indexed</strong> integer array <code>workers</code>, with the <code>j<sup>th</sup></code> worker having <code>workers[j]</code> strength. Each worker can only be assigned to a <strong>single</strong> task and must have a strength <strong>greater than or equal</strong> to the task&#39;s strength requirement (i.e., <code>workers[j] &gt;= tasks[i]</code>).</p>

<p>Additionally, you have <code>pills</code> magical pills that will <strong>increase a worker&#39;s strength</strong> by <code>strength</code>. You can decide which workers receive the magical pills, however, you may only give each worker <strong>at most one</strong> magical pill.</p>

<p>Given the <strong>0-indexed </strong>integer arrays <code>tasks</code> and <code>workers</code> and the integers <code>pills</code> and <code>strength</code>, return <em>the <strong>maximum</strong> number of tasks that can be completed.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>3</strong></u>,<u><strong>2</strong></u>,<u><strong>1</strong></u>], workers = [<u><strong>0</strong></u>,<u><strong>3</strong></u>,<u><strong>3</strong></u>], pills = 1, strength = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong>
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 2 (0 + 1 &gt;= 1)
- Assign worker 1 to task 1 (3 &gt;= 2)
- Assign worker 2 to task 0 (3 &gt;= 3)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>5</strong></u>,4], workers = [<u><strong>0</strong></u>,0,0], pills = 1, strength = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong>
We can assign the magical pill and tasks as follows:
- Give the magical pill to worker 0.
- Assign worker 0 to task 0 (0 + 5 &gt;= 5)
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> tasks = [<u><strong>10</strong></u>,<u><strong>15</strong></u>,30], workers = [<u><strong>0</strong></u>,<u><strong>10</strong></u>,10,10,10], pills = 3, strength = 10
<strong>Output:</strong> 2
<strong>Explanation:</strong>
We can assign the magical pills and tasks as follows:
- Give the magical pill to worker 0 and worker 1.
- Assign worker 0 to task 0 (0 + 10 &gt;= 10)
- Assign worker 1 to task 1 (10 + 10 &gt;= 15)
The last pill is not given because it will not make any worker strong enough for the last task.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == tasks.length</code></li>
	<li><code>m == workers.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= pills &lt;= m</code></li>
	<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-binary-search--greedy-worker-selection">Approach: Binary Search + Greedy Worker Selection</h3>
<h4 id="hint-1">Hint 1</h4>
<p>If we already know that it’s possible to complete exactly <span class="math inline">\(k\)</span> tasks, then:</p>
<ul>
<li>We should select the <span class="math inline">\(k\)</span> lowest-valued tasks from the <code>tasks</code> array.</li>
<li>We should select the <span class="math inline">\(k\)</span> highest-valued workers from the <code>workers</code> array.</li>
</ul>
<h4 id="hint-2">Hint 2</h4>
<p>If it’s possible to complete <span class="math inline">\(k\)</span> tasks while satisfying Hint 1, then it’s also possible to complete <span class="math inline">\(k - 1\)</span> tasks using the <span class="math inline">\(k - 1\)</span> lowest-valued tasks and the <span class="math inline">\(k - 1\)</span> highest-valued workers, which also satisfies Hint 1.</p>
<h4 id="intuition">Intuition</h4>
<p>Based on Hint 2, we can use binary search to find the largest value <span class="math inline">\(k'\)</span> such that we can complete <span class="math inline">\(k'\)</span> tasks, but not <span class="math inline">\(k' + 1\)</span>. This value <span class="math inline">\(k'\)</span> is our final answer.</p>
<p>During each step of binary search, after selecting the <span class="math inline">\(k\)</span> lowest-valued tasks and the <span class="math inline">\(k\)</span> highest-valued workers, we need to determine whether it’s possible to assign the tasks to the workers.</p>
<p>To do this, we process the selected tasks in decreasing order of value. For each task, we consider the following two cases:</p>
<ul>
<li>
<p><strong>Case 1</strong>: The worker with the highest available value is greater than or equal to the task value.<br />
In this case, we do not need to use a pill. We assign this worker (with the maximum value) to this task and remove them from the pool.</p>
<blockquote>
<p>Why this is optimal: Since this is the most difficult (i.e., highest-valued) task, any worker who can complete it can also complete the easier ones. If we assign a weaker worker instead (even with a pill), and later assign the stronger worker to an easier task, we could have swapped the assignments to make a better match. So it’s always optimal to assign the strongest available worker to the hardest task that doesn't need a pill.</p>
</blockquote>
</li>
<li>
<p><strong>Case 2</strong>: No worker can complete the task without a pill.<br />
In this case, we must use a pill. We look for the weakest worker who can complete the task with the pill (i.e., a worker with value ≥ <span class="math inline">\(t - \textit{strength}\)</span>) and remove them from the pool.</p>
<blockquote>
<p>Why this is optimal: Again, since we're processing the hardest task first, any worker who can complete it using a pill can also complete easier tasks using a pill. So, it is always safe (and best) to use the weakest such worker for this hardest task.</p>
</blockquote>
</li>
</ul>
<p>Therefore, we can iterate through the tasks in decreasing order of difficulty and maintain an ordered set of available workers. For each task value <span class="math inline">\(t\)</span>:</p>
<ul>
<li>If the maximum value in the set is ≥ <span class="math inline">\(t\)</span>, we remove that maximum worker (no pill needed).</li>
<li>If not, we look for the minimum worker with value ≥ <span class="math inline">\(t - \textit{strength}\)</span>. If such a worker exists and we still have pills remaining, we use a pill and remove that worker.<br />
Otherwise, it's not possible to complete all tasks with the current value of <span class="math inline">\(k\)</span>.</li>
</ul>
<p>Using this process, we can find whether a given value of <span class="math inline">\(k\)</span> is feasible.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ZDR4QtLx/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n + m \log m + \min(m, n) \log^2 \min(m, n))\)</span></p>
<ul>
<li>
<p>Sorting the <code>tasks</code> array requires <span class="math inline">\(O(n \log n)\)</span> time.</p>
</li>
<li>
<p>Sorting the <code>workers</code> array requires <span class="math inline">\(O(m \log m)\)</span> time.</p>
</li>
<li>
<p>The lower bound of binary search is 1, and the upper bound is the smaller value between <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, so the number of binary search iterations is <span class="math inline">\(\log \min(m, n)\)</span>. Each iteration involves enumerating <span class="math inline">\(\min(m, n)\)</span> tasks. During this enumeration, deletion operations are performed on the ordered set of workers, with the time complexity of a single operation being <span class="math inline">\(\log \min(m, n)\)</span>. Therefore, the total time complexity of binary search is <span class="math inline">\(O(\min(m, n) \log^2 \min(m, n))\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(\log n + \log m + \min(m, n))\)</span></p>
<ul>
<li>
<p>Sorting the <code>tasks</code> array requires <span class="math inline">\(O(\log n)\)</span> stack space.</p>
</li>
<li>
<p>Sorting the <code>workers</code> array requires <span class="math inline">\(O(\log m)\)</span> stack space.</p>
</li>
<li>
<p>The ordered set used in binary search requires <span class="math inline">\(O(\min(m, n))\)</span> space.</p>
</li>
</ul>
</li>
</ul>
<h4 id="expansion">Expansion:</h4>
<p>It can be observed that when we enumerate each task from highest to lowest value, and maintain all workers who can complete the task (with the help of pills), then:</p>
<ul>
<li>
<p>If there is a worker who can complete the task without using a pill, we select (and remove) the worker with the highest value.</p>
</li>
<li>
<p>If all available workers need to use a pill to complete the task, we select (and remove) the worker with the lowest value.</p>
</li>
</ul>
<p>As the task value decreases, the number of workers who can complete it increases or remains the same, but never decreases. Therefore, we can use a deque to maintain all workers who can complete the task (with the use of pills). At this point, we either select (and remove) the worker at the front of the deque or the worker at the back. This reduces the time complexity of a single deletion operation from <span class="math inline">\(O(\log \min(m, n))\)</span> to <span class="math inline">\(O(1)\)</span>, and the total time complexity becomes:</p>
<p><span class="math display">\[O(n \log n + m \log m + \min(m, n) \log \min(m, n)) = O(n \log n + m \log m)
\]</span></p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/3C6y8buD/shared">code</a></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-112">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/description" target="_blank" rel="noopener noreferrer">Maximum Product of First and Last Elements of a Subsequence</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>m</code>.</p>

<p>Return the <strong>maximum</strong> product of the first and last elements of any <strong><span data-keyword="subsequence-array">subsequence</span></strong> of <code>nums</code> of size <code>m</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [-1,-9,2,3,-2,-3,1], m = 1</span></p>

<p><strong>Output:</strong> <span class="example-io">81</span></p>

<p><strong>Explanation:</strong></p>

<p>The subsequence <code>[-9]</code> has the largest product of the first and last elements: <code>-9 * -9 = 81</code>. Therefore, the answer is 81.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,3,-5,5,6,-4], m = 3</span></p>

<p><strong>Output:</strong> <span class="example-io">20</span></p>

<p><strong>Explanation:</strong></p>

<p>The subsequence <code>[-5, 6, -4]</code> has the largest product of the first and last elements.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,-1,2,-6,5,2,-5,7], m = 2</span></p>

<p><strong>Output:</strong> <span class="example-io">35</span></p>

<p><strong>Explanation:</strong></p>

<p>The subsequence <code>[5, 7]</code> has the largest product of the first and last elements.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= m &lt;= nums.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-113">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-score-of-a-good-subarray/description" target="_blank" rel="noopener noreferrer">Maximum Score of a Good Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> <strong>(0-indexed)</strong> and an integer <code>k</code>.</p>

<p>The <strong>score</strong> of a subarray <code>(i, j)</code> is defined as <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>. A <strong>good</strong> subarray is a subarray where <code>i &lt;= k &lt;= j</code>.</p>

<p>Return <em>the maximum possible <strong>score</strong> of a <strong>good</strong> subarray.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,4,3,7,4,5], k = 3
<strong>Output:</strong> 15
<strong>Explanation:</strong> The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,5,4,5,4,1,1,1], k = 0
<strong>Output:</strong> 20
<strong>Explanation:</strong> The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= k &lt; nums.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<p><strong>Intuition</strong></p>
<p>The score of a subarray is its length multiplied by its minimum element. In this problem, we must find the maximum score of all subarrays that contain <code>nums[k]</code>.</p>
<p>How can we improve our score? When we take more elements we increase the length of the subarray, which helps the score. However, we may find new minimums, which would decrease our score.</p>
<p>We can start by separating the array - numbers to the left of <code>k</code> and numbers to the right of <code>k</code> (and including <code>k</code>).</p>
<p><img src="../Figures/1793/1.png" alt="img" /><br />
<br></p>
<p>Notice that <code>k</code> is the meeting point of these sections. If we want to take elements in the left section, we start from the end of the left section and move toward the beginning. If we want to take elements in the right section, we start from the beginning and move toward the end.</p>
<p>Of course, each element we take will increase our length by <code>1</code>. But how will it affect our minimum? To compute this quickly, we can create new arrays for each section. These arrays will represent the minimum element we have seen in the section if we started from <code>k</code>.</p>
<p><img src="../Figures/1793/2.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we took two elements from the left section. We can quickly see that the minimum element from the left section is <code>3</code> using these arrays. Similarly, if we took all elements from the right section, we could quickly see that the minimum element from the right section is <code>4</code>.</p>
<blockquote>
<p>We will call these arrays that allow us to find the minimums <code>left</code> and <code>right</code>.</p>
</blockquote>
<p>Now that we have these arrays, how can we solve the problem? Because <code>nums[k]</code> is in the right section, we will iterate over the entire right section and try to take each element. Let's say we take some number of elements from the right section, and the minimum is <code>x</code>. How many elements can we take from the left section without changing <code>x</code> as the minimum? We must only take elements from the left that are greater than or equal to <code>x</code>.</p>
<p>Let's switch to another example. For a given array, assuming we have already built the <code>left</code> and <code>right</code> arrays using the previous method.</p>
<p><img src="../Figures/1793/3.png" alt="img" /><br />
<br></p>
<p>In the above example, let's say that we take four elements from the right section. The minimum is <code>5</code>. How many elements can we take from the left section without changing the minimum? Two. This gives us a total size of <code>4 + 2 = 6</code>, and a total score of <code>6 * 5 = 30</code>.</p>
<p>How do we quickly find the number of elements we can take from the left section? Note that when we are building the array <code>left</code> from right to left, each time we go left we encounter a new number that is only likely to lower the minimum value, and the further to the left we go, the smaller the minimum value becomes, i.e., <code>left</code> is already sorted from smallest to largest. Therefore, we can perform a binary search to identify how many elements we can take.</p>
<p>This brings us to our solution. We iterate with <code>j</code> over each index of <code>right</code> and assign <code>currMin = right[j]</code>, which represents the minimum of our subarray. We then perform a binary search to find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code>. Once we have <code>i</code>, we can calculate the size of our subarray, and thus the score. We take the maximum of all scores.</p>
<p>How do we calculate the size of our subarray given <code>i</code> and <code>j</code>?</p>
<p><img src="../Figures/1793/4.png" alt="img" /><br />
<br></p>
<p>Because the right section starts at index <code>k</code>, its indices are offset by <code>k</code> from the real indices. Thus, in the original array, <code>right[j]</code> points to index <code>k + j</code>. The left section is not offset at all, so <code>i</code> is correctly positioned. The size of a subarray bounded by <code>[left, right]</code> is <code>right - left + 1</code>. Thus, the size of our subarray <code>[i, k + j]</code> is <code>(k + j) - i + 1</code>. We can multiply this by <code>right[j]</code> to calculate our score.</p>
<p>You may have noticed: this algorithm assumes that in the optimal subarray, the minimum value is in the right section. But what if this assumption is wrong, and its actually in the left section? We can check the left section by simply reversing the array and then applying the same algorithm to it. Note that when we reverse the array, <code>k</code> will change. After reversal, the original <code>k</code> will be at <code>nums.length - k - 1</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Define a function <code>solve(nums, k)</code> that runs our algorithm:
<ul>
<li>Set <code>n = nums.length</code>, <code>left</code> to an array of length <code>k</code>, and <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k - 1</code> until <code>0</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and set <code>left[i] = currMin</code>.</li>
<li>Initialize an empty array <code>right</code> and reset <code>currMin</code> to a large value.</li>
<li>Iterate <code>i</code> from <code>k</code> until <code>n - 1</code>. At each index, update <code>currMin</code> with <code>nums[i]</code> if it is smaller and push <code>currMin</code> to <code>right</code>.</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>j</code> over the indices of <code>right</code>:
<ul>
<li>Set <code>currMin = right[j]</code>.</li>
<li>Find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code> using binary search.</li>
<li>Calculate <code>size = (k + j) - i - 1</code>.</li>
<li>Update <code>ans</code> with <code>currMin * size</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = solve(nums, k)</code>.</li>
<li>Reverse <code>nums</code>.</li>
<li>Return the larger of <code>ans, solve(nums, nums.length - k - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/AePxSPjG/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log{}n)\)</span></p>
<p>We require <span class="math inline">\(O(n)\)</span> time to create <code>left</code> and <code>right</code>. Then, we iterate over the indices of <code>right</code>, which is not more than <span class="math inline">\(O(n)\)</span> iterations. At each iteration, we perform a binary search over <code>left</code>, which does not cost more than <span class="math inline">\(O(\log{}n)\)</span>. Thus, <code>solve</code> costs <span class="math inline">\(O(n \cdot \log{}n)\)</span>, and we call it twice.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code> and <code>right</code> have a combined length of <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h3>
<p><strong>Intuition</strong></p>
<p>In this approach, we will use a similar idea as in the previous approach. For a given index <code>i</code>, if we treat <code>nums[i]</code> as the minimum element, we need to know how many elements we can take on the left and right such that we do not take any elements less than <code>nums[i]</code>.</p>
<blockquote>
<p>You might be thinking: what if <code>nums[k]</code> is not included? We will get to that after presenting the full idea of the approach.</p>
</blockquote>
<p>Essentially, we need to know how far away the next lesser element is on both sides. If we have this information for all indices, we can quickly calculate the maximum score possible by treating every <code>nums[i]</code> as the minimum, since in the optimal solution, one of the indices must be the minimum.</p>
<p>There is a very similar problem called <a href="https://leetcode.com/problems/next-greater-element-i/">Next Greater Element</a>. The logic is identical, except that we are looking for the next smaller element. We can accomplish this using a monotonic stack.</p>
<details><summary><b>If you aren't familiar with monotonic stacks, click here.</b></summary>
<p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>increasing</strong> stack, i.e. the elements in the stack are always sorted in ascending order.</p>
<p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the largest value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the stack is greater than <code>num</code>, we pop from it. Since there may be multiple elements greater than <code>num</code> in the stack, we need to use a while loop to &quot;clean&quot; the stack before pushing <code>num</code>.</p>
<p>Only once there are no elements in the stack greater than <code>num</code> will we push <code>num</code>.</p>
</details>
<br>
<p>We will create an array <code>left</code>, where <code>left[i]</code> has the index of the first element to the left of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>Similarly, we will create an array <code>right</code> where <code>right[i]</code> has the index of the first element to the right of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>So how do we calculate <code>right</code>? Let's say that we are iterating over <code>nums</code> from the left and we have a chain of increasing numbers:</p>
<p><img src="../Figures/1793/5.png" alt="img" /><br />
<br></p>
<p>As you can see in the example, we have 6 increasing numbers, and then a <code>1</code> that is less than all of them. This <code>1</code> (at index 6) should be the value of <code>right</code> for all the indices of the increasing numbers. If we maintain a monotonic increasing stack, then this <code>1</code> will cause all those numbers to be popped out.</p>
<p>With a monotonic increasing stack, whenever we see an element that is smaller than the top of the stack, it is guaranteed to be the first smaller element for the element at the top of the stack. This is exactly what we are looking for.</p>
<p>To calculate <code>left</code>, we use the exact same process, except we iterate backward starting from the end of <code>nums</code>.</p>
<p>Note that because we need to remember what indices to update when we pop from the stack, we will store indices on the stack instead of the elements themselves. We can easily find the values by referencing <code>nums</code>.</p>
<p>We will initialize the values of <code>left</code> to <code>-1</code> and the values of <code>right</code> to <code>n</code>. This way, the math will still work out later if there are elements that do not have any lower values to the left or right.</p>
<p>Once we have <code>left</code> and <code>right</code>, we can iterate over all indices <code>i</code> and try to find a maximum score. Remember that the subarray must contain index <code>k</code>. Thus, we can only use an index <code>i</code> as the minimum if <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>.</p>
<p>When we treat an index <code>i</code> as the minimum, what score can we achieve? Our window starts one index after <code>left[i]</code> because including <code>left[i]</code> would create a new minimum. Similarly, our window ends one index before <code>right[i]</code>. Thus, we need to subtract <code>2</code> from the normal subarray size formula. This gives us a subarray size of <code>right[i] - left[i] - 1</code>. We multiply this size by <code>nums[i]</code> to get our score.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left</code> as an array of length <code>n</code> with values of <code>-1</code>, and an empty <code>stack</code>.</li>
<li>Iterate <code>i</code> from <code>n - 1</code> until <code>0</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>left[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>right</code> as an array of length <code>n</code> with values of <code>n</code> and reset <code>stack</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>, pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the <code>stack</code>, set <code>right[j] = i</code>.</li>
<li>Push <code>i</code> to <code>stack</code>.</li>
</ul>
</li>
<li>Initialize <code>ans = 0</code>.</li>
<li>Iterate <code>i</code> over the indices of <code>nums</code>:
<ul>
<li>If <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>, update <code>ans</code> with <code>nums[i] * (right[i] - left[i] - 1)</code> if it is larger.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/N4kEkyfF/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>It costs <span class="math inline">\(O(n)\)</span> to calculate <code>left</code> and <code>right</code>. We iterate over each index once and perform amortized <span class="math inline">\(O(1)\)</span> work at each iteration. The reason it amortizes to <span class="math inline">\(O(1)\)</span>, despite the while loop, is because the while loop can run a maximum of <span class="math inline">\(n\)</span> times across all iterations, and each index can only be pushed onto and popped from the stack once.</p>
<p>To calculate <code>ans</code>, we iterate over the indices once and perform <span class="math inline">\(O(1)\)</span> work at each iteration.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p><code>left</code>, <code>right</code>, and <code>stack</code> all require <span class="math inline">\(O(n)\)</span> space.</p>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-3-greedy">Approach 3: Greedy</h3>
<p><strong>Intuition</strong></p>
<p>Sometimes the simplest approach is the best! The optimal subarray must contain index <code>k</code>, so it makes sense to consider the subarray with only <code>nums[k]</code> as a starting point.</p>
<p>From here, how do we expand the subarray? We can either add an element to the left or an element to the right. Let's say we have two pointers, <code>left</code> and <code>right</code> that represent our subarray. Which direction should we go?</p>
<p>If we move left, it's equivalent to adding <code>nums[left - 1]</code> to our subarray. If we move right, it's equivalent to adding <code>nums[right + 1]</code> to our subarray. We should move in the direction of the greater element.</p>
<p>At each step, we update <code>currMin</code> which is initially set to <code>nums[k]</code>, and try to update <code>ans</code> which is also initially set to <code>nums[k]</code>. We can update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is larger.</p>
<p>This greedy process is very similar to the one used to solve <a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a>. But why does it work? We will use a proof by contradiction to demonstrate that not doing it this way wouldn't result in a higher value either.</p>
<p>At each step, we choose between having our subarray as <code>[left - 1, right]</code> or <code>[left, right + 1]</code>. Let's assume that <code>nums[left - 1] &gt; nums[right + 1]</code> and the optimal subarray has not been found yet. The optimal subarray must include <code>nums[left - 1]</code>. If it doesn't, then it must include <code>nums[right + 1]</code>, since we could only move right to &quot;avoid&quot; <code>nums[left - 1]</code>. However, any subarray that includes <code>nums[right + 1]</code> could also include <code>nums[left - 1]</code> without affecting the minimum, while also increasing the length of the subarray and thus the score. Thus, it is impossible for the optimal subarray to include <code>nums[right + 1]</code> and not <code>nums[left - 1]</code>, and in general the optimal subarray must include <code>nums[left - 1]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>To implement the while loop, we will iterate until we have exhausted the array. If one of the pointers is out of bounds, we will consider the element it points to as <code>0</code>.</p>
<ol>
<li>Initialize <code>n = nums.length</code>, <code>left = k</code>, <code>right = k</code>, <code>ans = nums[k]</code>, and <code>currMin = nums[k]</code>.</li>
<li>While <code>left &gt; 0</code> or <code>right &lt; n - 1</code>:
<ul>
<li>Compare <code>nums[left - 1]</code> with <code>nums[right + 1]</code>:
<ul>
<li>If <code>nums[right + 1]</code> is greater, increment <code>right</code> and update <code>currMin</code> with <code>nums[right]</code> if it is lower.</li>
<li>Otherwise, decrement <code>left</code> and update <code>currMin</code> with <code>nums[left]</code> if it is lower.</li>
</ul>
</li>
<li>Update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is greater.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/ayvayDq2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math inline">\(n\)</span> as the length of <code>nums</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>At each iteration, our <code>left</code> or <code>right</code> pointers move closer to the edges of the array by <code>1</code>. Thus, we perform <span class="math inline">\(O(n)\)</span> iterations. Each iteration costs <span class="math inline">\(O(1)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We aren't using any extra space other than a few integers.</p>
</li>
</ul>
<br/>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-114">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/maximum-subarray-sum--110820/1" target="_blank" rel="noopener noreferrer">Maximum subarray sum 2</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">deque</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">set</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">You are given an array <strong>arr[]</strong> of integers and two integers <strong>a </strong>and <strong>b</strong>, You have to find the maximum possible <strong>sum </strong>of a contiguous subarray whose length is at least <strong>a </strong>and at most <strong>b</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input:&nbsp;</strong>arr[] = [4, 5, -1, -2, 6], a = 2, b = 4</span><br /><span style="font-size: 14pt;"><strong>Output:</strong> 9</span><br /><span style="font-size: 14pt;"><strong>Explanation:</strong> The subarray [4, 5] has length 2 and sum 9, which is the maximum among all subarrays of length between 2 and 4.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input:&nbsp;</strong>arr[] = [-1, 3, -1, -2, 5, 3, -5, 2, 2], a = 3, b = 5</span><br /><span style="font-size: 14pt;"><strong>Output:&nbsp;</strong>8</span><br /><span style="font-size: 14pt;"><strong>Explanation:&nbsp;</strong>The subarray [3, -1, -2, 5, 3] has length 5 and sum 8, which is the maximum among all subarrays of length between 3 and 5.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; arr.size() &le; 10<sup>5<br /></sup>-10<sup>5</sup> &le; arr[i] &le; 10<sup>5<br /></sup>1 &le; a &le; b &le; arr.size()</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-115">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-beauty-of-the-gardens/description" target="_blank" rel="noopener noreferrer">Maximum Total Beauty of the Gardens</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">greedy</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice is a caretaker of <code>n</code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.</p>

<p>You are given a <strong>0-indexed</strong> integer array <code>flowers</code> of size <code>n</code>, where <code>flowers[i]</code> is the number of flowers already planted in the <code>i<sup>th</sup></code> garden. Flowers that are already planted <strong>cannot</strong> be removed. You are then given another integer <code>newFlowers</code>, which is the <strong>maximum</strong> number of flowers that Alice can additionally plant. You are also given the integers <code>target</code>, <code>full</code>, and <code>partial</code>.</p>

<p>A garden is considered <strong>complete</strong> if it has <strong>at least</strong> <code>target</code> flowers. The <strong>total beauty</strong> of the gardens is then determined as the <strong>sum</strong> of the following:</p>

<ul>
	<li>The number of <strong>complete</strong> gardens multiplied by <code>full</code>.</li>
	<li>The <strong>minimum</strong> number of flowers in any of the <strong>incomplete</strong> gardens multiplied by <code>partial</code>. If there are no incomplete gardens, then this value will be <code>0</code>.</li>
</ul>

<p>Return <em>the <strong>maximum</strong> total beauty that Alice can obtain after planting at most </em><code>newFlowers</code><em> flowers.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
<strong>Output:</strong> 14
<strong>Explanation:</strong> Alice can plant
- 2 flowers in the 0<sup>th</sup> garden
- 3 flowers in the 1<sup>st</sup> garden
- 1 flower in the 2<sup>nd</sup> garden
- 1 flower in the 3<sup>rd</sup> garden
The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.
There is 1 garden that is complete.
The minimum number of flowers in the incomplete gardens is 2.
Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14.
No other way of planting flowers can obtain a total beauty higher than 14.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
<strong>Output:</strong> 30
<strong>Explanation:</strong> Alice can plant
- 3 flowers in the 0<sup>th</sup> garden
- 0 flowers in the 1<sup>st</sup> garden
- 0 flowers in the 2<sup>nd</sup> garden
- 2 flowers in the 3<sup>rd</sup> garden
The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.
There are 3 gardens that are complete.
The minimum number of flowers in the incomplete gardens is 4.
Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30.
No other way of planting flowers can obtain a total beauty higher than 30.
Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>
	<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-116">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-damage-with-spell-casting/description" target="_blank" rel="noopener noreferrer">Maximum Total Damage With Spell Casting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A magician has various spells.</p>

<p>You are given an array <code>power</code>, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p>

<p>It is a known fact that if a magician decides to cast a spell with a damage of <code>power[i]</code>, they <strong>cannot</strong> cast any spell with a damage of <code>power[i] - 2</code>, <code>power[i] - 1</code>, <code>power[i] + 1</code>, or <code>power[i] + 2</code>.</p>

<p>Each spell can be cast <strong>only once</strong>.</p>

<p>Return the <strong>maximum</strong> possible <em>total damage</em> that a magician can cast.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [1,1,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">power = [7,1,6,6]</span></p>

<p><strong>Output:</strong> <span class="example-io">13</span></p>

<p><strong>Explanation:</strong></p>

<p>The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= power.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= power[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-117">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-total-from-optimal-activation-order/description" target="_blank" rel="noopener noreferrer">Maximum Total from Optimal Activation Order</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>value</code> and <code>limit</code>, both of length <code>n</code>.</p>

<p>Initially, all elements are <strong>inactive</strong>. You may activate them in any order.</p>

<ul>
	<li>To activate an inactive element at index <code>i</code>, the number of <strong>currently</strong> active elements must be <strong>strictly less</strong> than <code>limit[i]</code>.</li>
	<li>When you activate the element at index <code>i</code>, it adds <code>value[i]</code> to the <strong>total</strong> activation value (i.e., the sum of <code>value[i]</code> for all elements that have undergone activation operations).</li>
	<li>After each activation, if the number of <strong>currently</strong> active elements becomes <code>x</code>, then <strong>all</strong> elements <code>j</code> with <code>limit[j] &lt;= x</code> become <strong>permanently</strong> inactive, even if they are already active.</li>
</ul>

<p>Return the <strong>maximum</strong> <strong>total</strong> you can obtain by choosing the activation order optimally.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">value = [3,5,8], limit = [2,1,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">16</span></p>

<p><strong>Explanation:</strong></p>

<p>One optimal activation order is:</p>

<table>
	<thead>
		<tr>
			<th align="center" style="border: 1px solid black;">Step</th>
			<th align="center" style="border: 1px solid black;">Activated <code>i</code></th>
			<th align="center" style="border: 1px solid black;"><code>value[i]</code></th>
			<th align="center" style="border: 1px solid black;">Active Before <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Active After <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Becomes Inactive <code>j</code></th>
			<th align="center" style="border: 1px solid black;">Inactive Elements</th>
			<th align="center" style="border: 1px solid black;">Total</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">5</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;"><code>j = 1</code> as <code>limit[1] = 1</code></td>
			<td align="center" style="border: 1px solid black;">[1]</td>
			<td align="center" style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">3</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">-</td>
			<td align="center" style="border: 1px solid black;">[1]</td>
			<td align="center" style="border: 1px solid black;">8</td>
		</tr>
		<tr>
			<td align="center" style="border: 1px solid black;">3</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">8</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;"><code>j = 0</code> as <code>limit[0] = 2</code></td>
			<td align="center" style="border: 1px solid black;">[0, 1]</td>
			<td align="center" style="border: 1px solid black;">16</td>
		</tr>
	</tbody>
</table>

<p>Thus, the maximum possible total is 16.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">value = [4,2,6], limit = [1,1,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>One optimal activation order is:</p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="center" style="border: 1px solid black;">Step</th>
			<th align="center" style="border: 1px solid black;">Activated <code>i</code></th>
			<th align="center" style="border: 1px solid black;"><code>value[i]</code></th>
			<th align="center" style="border: 1px solid black;">Active Before <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Active After <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Becomes Inactive <code>j</code></th>
			<th align="center" style="border: 1px solid black;">Inactive Elements</th>
			<th align="center" style="border: 1px solid black;">Total</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">6</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;"><code>j = 0, 1, 2</code> as <code>limit[j] = 1</code></td>
			<td align="center" style="border: 1px solid black;">[0, 1, 2]</td>
			<td align="center" style="border: 1px solid black;">6</td>
		</tr>
	</tbody>
</table>

<p>Thus, the maximum possible total is 6.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">value = [4,1,5,2], limit = [3,3,2,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">12</span></p>

<p><strong>Explanation:</strong></p>

<p>One optimal activation order is:​​​​​​​<strong>​​​​​​​</strong></p>

<table style="border: 1px solid black;">
	<thead>
		<tr>
			<th align="center" style="border: 1px solid black;">Step</th>
			<th align="center" style="border: 1px solid black;">Activated <code>i</code></th>
			<th align="center" style="border: 1px solid black;"><code>value[i]</code></th>
			<th align="center" style="border: 1px solid black;">Active Before <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Active After <code>i</code></th>
			<th align="center" style="border: 1px solid black;">Becomes Inactive <code>j</code></th>
			<th align="center" style="border: 1px solid black;">Inactive Elements</th>
			<th align="center" style="border: 1px solid black;">Total</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">5</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">-</td>
			<td align="center" style="border: 1px solid black;">[ ]</td>
			<td align="center" style="border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">0</td>
			<td align="center" style="border: 1px solid black;">4</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;"><code>j = 2</code> as <code>limit[2] = 2</code></td>
			<td align="center" style="border: 1px solid black;">[2]</td>
			<td align="center" style="border: 1px solid black;">9</td>
		</tr>
		<tr>
			<td align="center" style="border: 1px solid black;">3</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">1</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">-</td>
			<td align="center" style="border: 1px solid black;">[2]</td>
			<td align="center" style="border: 1px solid black;">10</td>
		</tr>
		<tr>
			<td align="center" style="border: 1px solid black;">4</td>
			<td align="center" style="border: 1px solid black;">3</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">2</td>
			<td align="center" style="border: 1px solid black;">3</td>
			<td align="center" style="border: 1px solid black;"><code>j = 0, 1, 3</code> as <code>limit[j] = 3</code></td>
			<td align="center" style="border: 1px solid black;">[0, 1, 2, 3]</td>
			<td align="center" style="border: 1px solid black;">12</td>
		</tr>
	</tbody>
</table>

<p>Thus, the maximum possible total is 12.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == value.length == limit.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= value[i] &lt;= 10<sup>5</sup></code>​​​​​​​</li>
	<li><code>1 &lt;= limit[i] &lt;= n</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-118">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description" target="_blank" rel="noopener noreferrer">Maximum Twin Sum of a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>

<ul>
	<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>
</ul>

<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>

<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [5,4,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong>
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6. 
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png" style="width: 250px; height: 70px;" />
<pre>
<strong>Input:</strong> head = [4,2,2,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong>
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7. 
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png" style="width: 200px; height: 88px;" />
<pre>
<strong>Input:</strong> head = [1,100000]
<strong>Output:</strong> 100001
<strong>Explanation:</strong>
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-119">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/maximum-width-ramp/description" target="_blank" rel="noopener noreferrer">Maximum Width Ramp</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>ramp</strong> in an integer array <code>nums</code> is a pair <code>(i, j)</code> for which <code>i &lt; j</code> and <code>nums[i] &lt;= nums[j]</code>. The <strong>width</strong> of such a ramp is <code>j - i</code>.</p>

<p>Given an integer array <code>nums</code>, return <em>the maximum width of a <strong>ramp</strong> in </em><code>nums</code>. If there is no <strong>ramp</strong> in <code>nums</code>, return <code>0</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [6,0,8,2,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,8,1,0,1,9,4,0,4,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force-time-limit-exceeded">Approach 1: Brute Force (Time Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>For this problem, we need to efficiently find two indices <code>i</code> and <code>j</code> such that <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>.</p>
<p>The brute force approach is to check every possible pair <code>(i, j)</code> where <code>i &lt; j</code> and <span class="math inline">\(\text{nums}[i] \leq \text{nums}[j]\)</span>, and compute the maximum ramp width.</p>
<p>For each valid pair, compute the width <code>j - i</code> and update the maximum width if necessary.</p>
<p>However, this brute force approach will not work due to the constraints below:</p>
<ul>
<li><span class="math inline">\(2 \leq \text{nums.length} \leq 5 \times 10^4\)</span></li>
<li><span class="math inline">\(0 \leq \text{nums}[i] \leq 5 \times 10^4\)</span></li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and <code>maxWidth</code> to 0.</li>
<li>Use a nested loop to iterate through all pairs <code>(i, j)</code> where:
<ul>
<li>The outer loop variable <code>i</code> goes from <code>0</code> to <code>n - 1</code>.</li>
<li>The inner loop variable <code>j</code> goes from <code>i + 1</code> to <code>n - 1</code>.</li>
</ul>
</li>
<li>For each pair <code>(i, j)</code>:
<ul>
<li>Check if <code>nums[i]</code> is less than or equal to <code>nums[j]</code>.
<ul>
<li>If true, calculate the width as <code>j - i</code>.</li>
<li>Update <code>maxWidth</code> with the maximum value between the current <code>maxWidth</code> and the calculated width.</li>
</ul>
</li>
</ul>
</li>
<li>After checking all pairs, return <code>maxWidth</code> as the result.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/E2gfxGiq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm uses a nested loop where the outer loop iterates <span class="math inline">\(n\)</span> times and the inner loop can iterate up to <span class="math inline">\(n - 1\)</span> times for each iteration of the outer loop. This results in a total of <span class="math inline">\(\frac{n(n-1)}{2}\)</span> iterations, leading to a quadratic time complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm uses a constant amount of extra space, as it only requires a few integer variables (<code>n</code> and <code>maxWidth</code>) regardless of the size of the input array <code>nums</code>. There are no data structures used that would grow with the size of the input. Hence, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-sorting">Approach 2: Sorting</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, comparing <code>nums[i]</code> with <code>nums[j]</code> needed to be done for all pairs since <code>nums</code> is not sorted in order. This leads to an inefficient solution.</p>
<p>To make our solution more efficient, we can sort the indices of the array based on the values of <code>nums</code>. This way, when processing indices in the sorted order, each value is guaranteed to be greater than or equal to the values of previously processed indices.</p>
<p>Once the indices are sorted, we track the smallest index we've seen so far as we move through the sorted list. For each index we encounter, we calculate the difference between the current index and the smallest one. This difference represents a potential ramp width, and we update our maximum width as we go.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Find the size of the input array <code>nums</code> and initialize a array <code>indices</code> of the same size to hold the indices.</li>
<li>Initialize the <code>indices</code> array and fill it with values from <code>0</code> to <code>n-1</code> (each index corresponding to its position in <code>nums</code>).</li>
<li>Sort the <code>indices</code> based on the values in <code>nums</code>:
<ul>
<li>Use a custom comparator to ensure stability while sorting:
<ul>
<li>Compare values in <code>nums</code> for the corresponding indices.</li>
<li>If the values are equal, maintain the original order of the indices.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize <code>minIndex</code> to <code>n</code> (a value larger than any possible index) to track the minimum index encountered so far.</li>
<li>Initialize <code>maxWidth</code> to <code>0</code> to store the maximum width ramp found.</li>
<li>Iterate over the sorted <code>indices</code>:
<ul>
<li>Update <code>maxWidth</code> to be the maximum of its current value and the difference between the current index (<code>indices[i]</code>) and <code>minIndex</code>.</li>
<li>Update <code>minIndex</code> to be the minimum of its current value and the current index (<code>indices[i]</code>).</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/DqjkzxEw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log n)\)</span></p>
<p>The most significant factor in the time complexity comes from the sorting operation on the <code>indices</code> array. Sorting takes <span class="math inline">\(O(n \log n)\)</span> time. The subsequent loop that calculates the maximum width ramp runs in <span class="math inline">\(O(n)\)</span> time. Thus, the overall time complexity is dominated by the sorting step, resulting in <span class="math inline">\(O(n \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n + S) = O(n)\)</span></p>
<p>The space complexity is primarily determined by the additional <code>indices</code> array that stores the indices of the <code>nums</code> array, which requires <span class="math inline">\(O(n)\)</span> space. Other variables used in the algorithm are of constant space, leading to an overall space complexity of <span class="math inline">\(O(n)\)</span>.</p>
<p>The other additional space used is for the sorting algorithm. The space taken by the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the language of implementation:</p>
<ul>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O(\log n)\)</span>.</li>
<li>In Python, the <code>sort()</code> method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointers">Approach 3: Two Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another way to approach the problem is to recognize that if we could process the indices in such a way that we can easily compare their relative positions, it might help us avoid unnecessary comparisons.</p>
<p>We can notice that it would be helpful to know the maximum value from each index to the end of the array.  Given this information, we can easily check if the ramp condition is satisfied for any left index while iterating from the start of the array. Thus, we initialize <code>rightMax</code> where each element at index <code>i</code> stores the maximum value from index <code>i</code> to the last index. We populate this array in reverse order. Starting from the end of the <code>nums</code> array, we set the last element of <code>rightMax</code> to be equal to the last element of <code>nums</code>. For all previous indices, we store the maximum of the current value in <code>nums[i]</code> and the value at <code>rightMax[i + 1]</code>. This ensures that each index in <code>rightMax</code> contains the highest value from that index to the end of the original array.</p>
<p>With <code>rightMax</code> constructed, we can proceed with our two-pointer approach. We initialize one pointer (<code>left</code>) at the start of the array and another pointer (<code>right</code>) that we will move through the array. As we iterate:</p>
<ul>
<li>We check if the condition <span class="math inline">\(nums[left] \leq rightMax[right]\)</span> holds. If true, we calculate the ramp width as <code>right - left</code> and update our maximum width if this is the largest we’ve seen.</li>
<li>If the condition is not satisfied, it means the value at <code>nums[left]</code> is too large to form a ramp with <code>rightMax[right]</code>, so we increment the <code>left</code> pointer to try and find a smaller value.</li>
</ul>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> as the size of the input vector <code>nums</code>.</li>
<li>Create a <code>rightMax</code> array of the same size to store the maximum values from the right side of <code>nums</code>.</li>
<li>Fill the <code>rightMax</code> array:
<ul>
<li>Set <code>rightMax[n - 1]</code> to <code>nums[n - 1]</code> (the last element).</li>
<li>Iterate backward from the second-to-last element to the first:
<ul>
<li>For each index <code>i</code>, set <code>rightMax[i]</code> to the maximum of <code>rightMax[i + 1]</code> and <code>nums[i]</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Initialize two pointers, <code>left</code> and <code>right</code>, both starting at 0, and a variable <code>maxWidth</code> initialized to 0.</li>
<li>Traverse the array using <code>left</code> and <code>right</code> pointers:
<ul>
<li>While <code>right</code> is less than <code>n</code>:
<ul>
<li>Move the <code>left</code> pointer forward while the current value at <code>nums[left]</code> exceeds the corresponding value in <code>rightMax[right]</code>.</li>
<li>Calculate the current width as <code>right - left</code> and update <code>maxWidth</code> to the maximum of <code>maxWidth</code> and the current width.</li>
<li>Increment the <code>right</code> pointer.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/CFRwxcEm/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm consists of two main parts. The first loop fills the <code>rightMax</code> array, which takes <span class="math inline">\(O(n)\)</span> time since it iterates through the <code>nums</code> array once. The second part uses a two-pointer technique to traverse the <code>nums</code> array and the <code>rightMax</code> array, where both pointers traverse the array at most <span class="math inline">\(n\)</span> times. Thus, the total time taken is linear in terms of the size of the input array, leading to an overall time complexity of <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the additional storage used, which in this case is the <code>rightMax</code> array. This array also has a size of <span class="math inline">\(n\)</span>, resulting in a space complexity of <span class="math inline">\(O(n)\)</span>. Other variables used (like <code>left</code>, <code>right</code>, and <code>maxWidth</code>) take constant space, <span class="math inline">\(O(1)\)</span>, but they do not contribute to the overall space complexity.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-monotonic-stack">Approach 4: Monotonic Stack</h3>
<h4 id="intuition-3">Intuition</h4>
<p>We notice that for any element <span class="math inline">\(nums[i]\)</span>, we'd like to consider the indices of all elements <span class="math inline">\(nums[j]\)</span> preceding <span class="math inline">\(nums[i]\)</span> such that <span class="math inline">\(nums[j] < nums[i]\)</span>. We can efficiently find all these indices by maintaining a monotonic stack. The key observation is that this problem involves finding valid pairs where an earlier index has a smaller or equal value than a later index, making it a perfect candidate for a monotonic stack. This way, whenever we encounter a value in <span class="math inline">\(nums\)</span> that is greater than the element at the index in top of our stack, we can pop all the indices from the stack to find left indices that can form valid pairs.</p>
<p>As we iterate over the array, we push indices onto a stack only if the value at the current index is smaller than or equal to the value at the index on top of the stack. This ensures that the stack contains a list of potential starting points for ramps, in decreasing order of value. The key insight is that when we encounter a larger value, we begin popping indices from the stack. For each index popped, we calculate the ramp width formed with the current index and check if it exceeds the maximum width we have tracked. Since the values on the stack are always decreasing, popping an index means that we have found a ramp where the condition <span class="math inline">\(nums[i] \leq nums[j]\)</span> is satisfied.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/962/monotonic.json:1025,535!?!</p>
<h4 id="algorithm-3">Algorithm</h4>
<ul>
<li>Initialize <code>n</code> to the size of the <code>nums</code> array and create an empty stack <code>indicesStack</code>.</li>
<li>Iterate through the array from index 0 to <code>n-1</code>.
<ul>
<li>If <code>indicesStack</code> is empty or the value at the top index of the stack is greater than the current value <code>nums[i]</code>, push <code>i</code> onto the stack.</li>
<li>This ensures the stack contains indices in increasing order of their corresponding values in <code>nums</code>.</li>
</ul>
</li>
<li>Initialize <code>maxWidth</code> to 0.</li>
<li>Iterate through the array from index <code>n-1</code> down to 0.
<ul>
<li>While the stack is not empty and the value at the index on the top of the stack is less than or equal to <code>nums[j]</code>:</li>
<li>Update <code>maxWidth</code> to the maximum of its current value and the width calculated as <code>j - indicesStack.top()</code>.</li>
<li>Pop the index from the stack, as it has already been processed.</li>
</ul>
</li>
<li>Return <code>maxWidth</code> as the result (the maximum width found).</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/bUmS9o8r/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The first loop iterates through the <code>nums</code> array once, pushing indices onto the stack. This operation takes <span class="math inline">\(O(n)\)</span> time in the worst case since each index is pushed at most once. The second loop also iterates through the <code>nums</code> array, but each index is popped from the stack at most once. Hence, both loops combined result in a total of <span class="math inline">\(O(n)\)</span> time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity arises primarily from the stack that holds indices. In the worst case, where all elements are in strictly increasing order, all <span class="math inline">\(n\)</span> indices could be pushed onto the stack. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span> in this scenario.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-120">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/max-number-of-k-sum-pairs/description" target="_blank" rel="noopener noreferrer">Max Number of K-Sum Pairs</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>

<p>In one operation, you can pick two numbers from the array whose sum equals <code>k</code> and remove them from the array.</p>

<p>Return <em>the maximum number of operations you can perform on the array</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], k = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,3,4,3], k = 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> Starting with nums = [3,1,3,4,3]:
- Remove the first two 3&#39;s, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-121">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/attend-all-meetings-ii/1" target="_blank" rel="noopener noreferrer">Meeting Rooms II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">heap</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18.6667px;">Given two arrays&nbsp;<strong>start[] </strong>and<strong> end[]</strong> such that start[i] is the starting time of i<sup>th</sup> meeting and end[i] is the ending time of ith meeting. R</span><span style="font-size: 18.6667px;">eturn the <strong>minimum number</strong> of rooms required to attend all meetings.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>start[] = [1, 10, 7], end[] = [4, 15, 10]
<strong>Output:</strong> 1
<strong>Explanation:</strong> </span><span style="font-size: 18.6667px;">Since all the meetings are held at different times, it is possible to attend all the meetings in a single room.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>start[] = [2, 9, 6], end[] = [4, 12, 10]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 1st and 2nd meetings at one room but for 3rd meeting one another room required.<br /></span></pre>
<p><span style="font-size: 12pt;"><strong>Constraints:</strong></span><br /><span style="font-size: 12pt;">1 &le; start.size() &le; 10<sup>5</sup></span><br /><span style="font-size: 12pt;">0 &le; start[i] &lt; end[i] &le; 10<sup>6</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-122">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-sorted-array/description" target="_blank" rel="noopener noreferrer">Merge Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>

<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>

<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array </em><code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
<strong>Output:</strong> [1,2,2,3,5,6]
<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The arrays we are merging are [1] and [].
The result of the merge is [1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>nums1.length == m + n</code></li>
	<li><code>nums2.length == n</code></li>
	<li><code>0 &lt;= m, n &lt;= 200</code></li>
	<li><code>1 &lt;= m + n &lt;= 200</code></li>
	<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up: </strong>Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-123">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-strings-alternately/description" target="_blank" rel="noopener noreferrer">Merge Strings Alternately</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>word1</code> and <code>word2</code>. Merge the strings by adding letters in alternating order, starting with <code>word1</code>. If a string is longer than the other, append the additional letters onto the end of the merged string.</p>

<p>Return <em>the merged string.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abc&quot;, word2 = &quot;pqr&quot;
<strong>Output:</strong> &quot;apbqcr&quot;
<strong>Explanation:</strong>&nbsp;The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot;
<strong>Output:</strong> &quot;apbqrs&quot;
<strong>Explanation:</strong>&nbsp;Notice that as word2 is longer, &quot;rs&quot; is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word1 = &quot;abcd&quot;, word2 = &quot;pq&quot;
<strong>Output:</strong> &quot;apbqcd&quot;
<strong>Explanation:</strong>&nbsp;Notice that as word1 is longer, &quot;cd&quot; is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 100</code></li>
	<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>
</ul></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
 <div class='video-preview'></div>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two strings <code>word1</code> and <code>word2</code>.</p>
<p>Our task is to merge the strings by adding letters in alternating order, starting with <code>word1</code>. If one string is longer than the other, the additional letters must be appended to the end of the merged string.</p>
<p>We must return the merged string that has been formed.</p>
<hr />
<h3 id="approach-1-two-pointers">Approach 1: Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>There are numerous ways in which we can combine the given strings. We've covered a few of them in this article.</p>
<p>An intuitive method is to use two pointers to iterate over both strings. Assume we have two pointers, <code>i</code> and <code>j</code>, with <code>i</code> pointing to the first letter of <code>word1</code> and <code>j</code> pointing to the first letter of <code>word2</code>. We also create an empty string <code>result</code> to store the outcome.</p>
<p>We append the letter pointed to by pointer <code>i</code> i.e., <code>word1[i]</code>, and increment <code>i</code> by <code>1</code> to point to the next letter of <code>word1</code>. Because we need to add the letters in alternating order, next we append <code>word2[j]</code> to <code>result</code>. We also increase <code>j</code> by <code>1</code>.</p>
<p>We continue iterating over the given strings until both are exhausted. We stop appending letters from <code>word1</code> when <code>i</code> reaches the end of <code>word1</code>, and we stop appending letters from <code>word2'</code> when <code>j</code> reaches the end of <code>word2</code>.</p>
<p>Here's a visual representation of how the approach works in the second example given in the problem description:</p>
<p>!?!../Documents/1768/1768-slides.json:601,301!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the length of <code>word1</code> and <code>word2</code>.</li>
<li>Create an empty string variable <code>result</code> to store the result of merged words.</li>
<li>Create two pointers, <code>i</code> and <code>j</code> to point to indices of <code>word1</code> and <code>word2</code>. We initialize both of them to <code>0</code>.</li>
<li>While <code>i &lt; m || j &lt; n</code>:
<ul>
<li>If <code>i &lt; m</code>, it means that we have not completely traversed <code>word1</code>. As a result, we append <code>word1[i]</code> to <code>result</code>. We increment <code>i</code> to point to next index of <code>word1</code>.</li>
<li>If <code>j &lt; n</code>, it means that we have not completely traversed <code>word2</code>. As a result, we append <code>word2[j]</code> to <code>result</code>. We increment <code>j</code> to point to next index of <code>word2</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<p>It is important to note how we form the <code>result</code> string in the following codes:<br />
- <code>cpp</code>: The strings are mutable in cpp, which means they can be changed. As a result, we used the <code>string</code> variable and performed all operations on it. It takes constant time to append a character to the string.<br />
- <code>java</code>: The <code>String</code> class is immutable in java. So we used the mutable <code>StringBuilder</code> to concatenate letters to <code>result</code>.<br />
- <code>python</code>: Strings are immutable in python as well. As a result, we used the list <code>result</code> to append letters and later joined the list with an empty string to return it as a string object. The <code>join</code> operation takes linear time equal to the length of <code>result</code> to merge <code>result</code> with empty string.</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/fLy387Q8/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> is the length of <code>word1</code> and <span class="math inline">\(n\)</span> is the length of <code>word2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>We iterate over <code>word1</code> and <code>word2</code> once and push their letters into <code>result</code>. It would take <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span> or <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>Without considering the space consumed by the input strings (<code>word1</code> and <code>word2</code>) and the output string (<code>result</code>), we do not use more than constant space.</li>
</ul>
</li>
</ul>
<blockquote>
<p>In Java, the <code>StringBuilder</code> requires <span class="math inline">\(O(n + m)\)</span> space to store the merged result. Thus, while auxiliary space is <span class="math inline">\(O(1)\)</span>, total space complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</blockquote>
<hr />
<h3 id="approach-2-one-pointer">Approach 2: One Pointer</h3>
<h4 id="intuition-1">Intuition</h4>
<p>To merge the given words, we can also use a single pointer.</p>
<p>Let <code>i</code> be the pointer that we'll use. We begin with <code>i = 0</code> and progress to the size of the longer word between <code>word1</code> and <code>word2</code>, i.e., till <code>i = max(word1.length(), word2.length())</code>.</p>
<p>As we progress to the size of a longer word, we check each time if <code>i</code> points to an index that is in bounds of the words or not. If <code>i &lt; word1.length()</code>, we append <code>word1[i]</code> to <code>result</code>. Similarly if <code>i &lt; word2.length()</code>, we append <code>word2[i]</code> to results.</p>
<p>However, if <code>i</code> exceeds the length of any word, we don't have any letters to add from that word, so we ignore it and continue adding the letter from the longer word.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Create two variables, <code>m</code> and <code>n</code>, to store the length of <code>word1</code> and <code>word2</code>.</li>
<li>Create an empty string variable <code>result</code> to store the result of merged words.</li>
<li>Iterate over <code>word1</code> and <code>word2</code> using a loop running from <code>i = 0</code> to <code>i &lt; max(m, n)</code> and keep incrementing <code>i</code> by <code>1</code> after each iteration:
<ul>
<li>If <code>i &lt; m</code>, it means that we have not completely traversed <code>word1</code>. As a result, we append <code>word1[i]</code> to <code>result</code>.</li>
<li>If <code>i &lt; n</code>, it means that we have not completely traversed <code>word2</code>. As a result, we append <code>word2[i]</code> to <code>result</code>.</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/afgSid65/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(m\)</span> is the length of <code>word1</code> and <span class="math inline">\(n\)</span> is the length of <code>word2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m + n)\)</span></p>
<ul>
<li>We iterate over <code>word1</code> and <code>word2</code> once pushing their letters into <code>result</code>. It would take <span class="math inline">\(O(m + n)\)</span> time.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<ul>
<li>Without considering the space consumed by the input strings (<code>word1</code> and <code>word2</code>) and the output string (<code>result</code>), we do not use more than constant space.</li>
</ul>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-124">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/merge-two-2d-arrays-by-summing-values/description" target="_blank" rel="noopener noreferrer">Merge Two 2D Arrays by Summing Values</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two <strong>2D</strong> integer arrays <code>nums1</code> and <code>nums2.</code></p>

<ul>
	<li><code>nums1[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;indicate that the number with the id <code>id<sub>i</sub></code> has a value equal to <code>val<sub>i</sub></code>.</li>
	<li><code>nums2[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;indicate that the number with the id <code>id<sub>i</sub></code> has a value equal to <code>val<sub>i</sub></code>.</li>
</ul>

<p>Each array contains <strong>unique</strong> ids and is sorted in <strong>ascending</strong> order by id.</p>

<p>Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:</p>

<ul>
	<li>Only ids that appear in at least one of the two arrays should be included in the resulting array.</li>
	<li>Each id should be included <strong>only once</strong> and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays, then assume its value in that array to be <code>0</code>.</li>
</ul>

<p>Return <em>the resulting array</em>. The returned array must be sorted in ascending order by id.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
<strong>Output:</strong> [[1,6],[2,3],[3,2],[4,6]]
<strong>Explanation:</strong> The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
<strong>Output:</strong> [[1,3],[2,4],[3,6],[4,3],[5,5]]
<strong>Explanation:</strong> There are no common ids, so we just include each id with its value in the resulting list.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 200</code></li>
	<li><code>nums1[i].length == nums2[j].length == 2</code></li>
	<li><code>1 &lt;= id<sub>i</sub>, val<sub>i</sub> &lt;= 1000</code></li>
	<li>Both arrays contain unique ids.</li>
	<li>Both arrays are in&nbsp;strictly ascending order by id.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two arrays, <code>nums1</code> and <code>nums2</code>, each containing pairs of the form <code>{id, value}</code>. These pairs represent mappings where <code>id</code> is unique within each array, and both arrays are sorted in ascending order based on <code>id</code>.</p>
<p>Our goal is to merge these two arrays of pairs into a single sorted array of pairs. Each entry in the result should correspond to an <code>id</code> that appears in either input array. If an <code>id</code> is present in both arrays, we sum the associated values; otherwise, we keep the existing pair as is. The final output must be sorted by <code>id</code>.</p>
<h5 id="examples">Examples:</h5>
<ol>
<li>If <code>nums1 = [(id1, val1)]</code> and <code>nums2 = [(id2, val2)]</code> with <code>id1 &lt; id2</code>, then the final array should be <code>[(id1, val1), (id2, val2)]</code>.</li>
<li>If <code>nums1 = [(id1, val1)]</code> and <code>nums2 = [(id1, val2)]</code>, then the final array should be <code>[(id1, val1 + val2)]</code>.</li>
<li>If <code>nums1 = [(id1, val1), (id2, val2)]</code> and <code>nums2 = [(id2, val3)]</code> with <code>id1 &lt; id2</code>, then the final array should be <code>[(id1, val1), (id2, val2 + val3)]</code>.</li>
</ol>
<hr />
<h3 id="approach-1-hashmap">Approach 1: HashMap</h3>
<h4 id="intuition">Intuition</h4>
<p>An intuitive approach to solving this problem is to use a data structure such as a map to store the <code>(key, value)</code> pairs. This is because the final result requires pairs where the value corresponds to an entry in either <code>nums1</code> or <code>nums2</code>. If the <code>id</code> exists in only one array, the value will be taken from that array. If the <code>id</code> appears in both arrays, the value will be the sum of the values from both arrays.</p>
<p>We can break the approach down into two main steps. First, we populate the map using one of the two input lists. Since each <code>id</code> is unique within a list, inserting these pairs directly into the map is straightforward. Next, we process the second array, updating the values in the map. If an <code>id</code> from the second list already exists in the map, we simply add its value to the existing value. If it does not exist, we insert it as a new entry.</p>
<p>One important consideration is the order of the pairs in the final result. Since the pairs must be sorted in ascending order of <code>id</code>, we can either copy the entries from the map to a list and then sort the list, or use an ordered map to maintain the order throughout the process. In the code, we have chosen to use an ordered map, which eliminates the need for sorting after the merge. However, both approaches will result in the same time complexity as inserting in a map takes <span class="math inline">\(O(\log N)\)</span> time.</p>
<blockquote>
<p>For a more comprehensive understanding of hash tables, check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">Hash Table Explore Card 🔗</a>. This resource provides an in-depth look at hash tables, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Create an empty map named <code>keyToSum</code> to store the sum of values for each unique key.</li>
<li>Iterate through each pair <code>(id, value)</code> in <code>nums1</code> and insert the <code>id</code> as the map key and <code>value</code> as the map value.</li>
<li>Iterate through each pair <code>(id, value)</code> in  <code>nums2</code>:
<ul>
<li>If the key already exists in the map, add the value from <code>nums2</code> to the existing value.</li>
<li>If the key does not exist in the map, insert the  pair from <code>nums2</code>.</li>
</ul>
</li>
<li>Iterate over the map and construct a vector of pairs <code>mergedArray</code> by inserting each pair from the map into the list.</li>
<li>Return <code>mergedArray</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ERuaLkPJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N1\)</span> is the number of elements in the array <code>nums1</code> and <span class="math inline">\(N2\)</span> is the number of elements in the array <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((N1 + N2) \log (N1 + N2))\)</span>.</p>
<p>Copying the <code>(id, value)</code> pairs from the array <code>nums1</code> into the ordered map will take <span class="math inline">\(O(N1 \log ⁡N1)\)</span> time, as the insert operation in an ordered map has a time complexity of <span class="math inline">\(O(\log⁡N)\)</span>. Similarly, iterating through the pairs in the array <code>nums2</code> to either add new entries or update existing values in the map will take <span class="math inline">\(O(N2 \log ⁡N2)\)</span>. Finally, iterating over the entries in the map and copying them to the <code>mergedArray</code> list takes <span class="math inline">\(O((N1 + N2) \log⁡ (N1 + N2))\)</span>. Therefore, the overall time complexity of the algorithm is <span class="math inline">\(O((N1 + N2) \log ⁡(N1 + N2))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N1 + N2)\)</span></p>
</li>
</ul>
<p>We will store each entry in the map <code>keyToSum</code>, and thus there can be at most <span class="math inline">\((N1 + N2)\)</span> entries if both arrays have unique entries. Space used to generate the output is generally not considered as part of the space complexity. Thus, the total space complexity is equal to <span class="math inline">\(O(N1 + N2)\)</span>.</p>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>This problem is a slight variation of <a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a>, except that instead of merging arrays of integers, we are merging arrays of pairs in the form <code>(id, value)</code>. In the original problem, we use a two-pointer technique, where two pointers traverse both arrays, inserting the smaller element into the result and advancing the respective pointer.</p>
<p>A similar approach works here because the input arrays are sorted in ascending order, and our goal is to merge them. The key distinction is that each element consists of an <code>(id, value)</code> pair. If the <code>id</code> values are identical in both arrays, we sum their corresponding <code>value</code>s and insert the merged pair into the result. Otherwise, we insert the pair with the smaller <code>id</code> and increment the corresponding pointer, following the same logic as in <a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a>.</p>
<p>To implement this, we initialize two pointers, <code>ptr1</code> and <code>ptr2</code>, at <code>0</code>, tracking the current positions in <code>nums1</code> and <code>nums2</code>, respectively. We then enter a while loop that continues until one of the pointers reaches the end of its array. Inside the loop, we compare the <code>id</code> values of the current pairs from <code>nums1</code> and <code>nums2</code>. If the <code>id</code>s differ, we insert the pair with the smaller <code>id</code> into the result list <code>mergedArray</code> and advance the corresponding pointer. If the <code>id</code>s match, we sum the <code>value</code>s and insert the combined pair into <code>mergedArray</code>.</p>
<p>Once the loop finishes, one array may still contain unprocessed elements. This occurs when one array has exhausted its smaller <code>id</code> values, leaving unmatched pairs in the other. In this case, we append the remaining elements directly to <code>mergedArray</code>. Finally, we return <code>mergedArray</code> as the result.</p>
<p>!?!../Documents/2570/2570_Merge_Two_2D_Arrays_by_Summing_Values.json:960,720!?! <br></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code> N1</code> and <code>N2</code> to the size of <code>nums1</code> and <code>nums2</code>. Also, <code>ptr1</code> and <code>ptr2</code> to <code>0</code>. An empty 2D list <code>mergedArray</code> to store the result.</li>
<li>While both <code>ptr1</code> is less than <code>N1</code> and <code>ptr2</code> is less than <code>N2</code>, continue merging:
<ul>
<li>If the <code>id</code> matches:
<ul>
<li>Add the key and the sum of the values from both arrays to <code>mergedArray</code>.</li>
<li>Increment both <code>ptr1</code> and <code>ptr2</code>.</li>
</ul>
</li>
<li>If the <code>id</code> in <code>nums1</code> is smaller:
<ul>
<li>Add the current pair from <code>nums1</code> to <code>mergedArray</code>.</li>
<li>Increment <code>ptr1</code>.</li>
</ul>
</li>
<li>If the <code>id</code> in <code>nums2</code> is smaller:
<ul>
<li>Add the current pair from <code>nums2</code> to <code>mergedArray</code>.</li>
<li>Increment <code>ptr2</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>ptr1</code> is still less than <code>N1</code> (i.e., there are remaining elements in <code>nums1</code>), add the remaining pairs to <code>mergedArray</code>.</li>
<li>If <code>ptr2</code> is still less than <code>N2</code> (i.e., there are remaining elements in <code>nums2</code>), add the remaining pairs to <code>mergedArray</code>.</li>
<li>Return <code>mergedArray</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/8tQRAiVf/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math inline">\(N1\)</span> is the number of elements in the array <code>nums1</code> and <span class="math inline">\(N2\)</span> is the number of elements in the array <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(N1 + N2)\)</span></p>
<p>In the while loop, we either increment one of the two pointers or increment both when the <code>id</code> is the same. Thus, we will iterate over each pair in the two arrays at most once. Also, all operations like insertion in the list is <span class="math inline">\(O(1)\)</span> and hence the total time complexity is equal to <span class="math inline">\(O(N1 + N2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(N1 + N2)\)</span></p>
<p>No extra space is required apart from the array required to store the result which is not considered as part of the space complexity and hence the total space complexity is equal to <span class="math inline">\(O(N1 + N2)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-125">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1" target="_blank" rel="noopener noreferrer">Merge Without Extra Space</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given two sorted arrays <strong>a[]</strong> and <strong>b[] </strong>of size <strong>n </strong>and <strong>m </strong>respectively, the task is to merge them in sorted order without using any <strong>extra space</strong>. Modify <strong>a[]</strong> so that it contains the first <strong>n</strong> elements and modify <strong>b[]</strong> so that it contains the last <strong>m</strong> elements.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input</strong>: a[] = [2, 4, 7, 10], b[] = [2, 3]
<strong>Output</strong>: a[] = [2, 2, 3, 4], b[] = [7, 10]
<strong>Explanation</strong>: After merging the two non-decreasing arrays, we get, [2, 2, 3, 4, 7, 10]</span></pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: a[] = [1, 5, 9, 10, 15, 20], b[] = [2, 3, 8, 13]
<strong>Output</strong>: a[] = [1, 2, 3, 5, 8, 9], b[] = [10, 13, 15, 20]
<strong>Explanation</strong>: After merging two sorted arrays we get [1, 2, 3, 5, 8, 9, 10, 13, 15, 20].</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input</strong>: a[] = [0, 1], b[] = [2, 3]
<strong>Output</strong>: a[] = [0, 1], b[] = [2, 3]
<strong>Explanation</strong>: After merging two sorted arrays we get [0, 1, 2, 3].</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong></span><br /><span style="font-size: 18px;">1 &le; n, m &le; 10<sup>5</sup><br />0 &le; a[i], b[i] &le; 10<sup>7</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-126">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/middle-of-the-linked-list/description" target="_blank" rel="noopener noreferrer">Middle of the Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, return <em>the middle node of the linked list</em>.</p>

<p>If there are two middle nodes, return <strong>the second middle</strong> node.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" style="width: 544px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [3,4,5]
<strong>Explanation:</strong> The middle node of the list is node 3.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg" style="width: 664px; height: 65px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5,6]
<strong>Output:</strong> [4,5,6]
<strong>Explanation:</strong> Since the list has two middle nodes with values 3 and 4, we return the second one.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-127">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimize-maximum-pair-sum-in-array/description" target="_blank" rel="noopener noreferrer">Minimize Maximum Pair Sum in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>The <strong>pair sum</strong> of a pair <code>(a,b)</code> is equal to <code>a + b</code>. The <strong>maximum pair sum</strong> is the largest <strong>pair sum</strong> in a list of pairs.</p>

<ul>
	<li>For example, if we have pairs <code>(1,5)</code>, <code>(2,3)</code>, and <code>(4,4)</code>, the <strong>maximum pair sum</strong> would be <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code>.</li>
</ul>

<p>Given an array <code>nums</code> of <strong>even</strong> length <code>n</code>, pair up the elements of <code>nums</code> into <code>n / 2</code> pairs such that:</p>

<ul>
	<li>Each element of <code>nums</code> is in <strong>exactly one</strong> pair, and</li>
	<li>The <strong>maximum pair sum </strong>is <strong>minimized</strong>.</li>
</ul>

<p>Return <em>the minimized <strong>maximum pair sum</strong> after optimally pairing up the elements</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,2,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,4,2,4,6]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>n</code> is <strong>even</strong>.</li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul></div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-sorting">Approach: Sorting</h3>
<p><strong>Intuition</strong></p>
<p>We are given an array of <span class="math inline">\(N\)</span> integers (where <span class="math inline">\(N\)</span> is even), and we need to pair up all these integers in such a way that the maximum sum of a pair is minimized. We need to return the minimized maximum pair sum in the array.</p>
<p>One might think of pairing up the smaller integers together so that the pair sum is minimized at the beginning. However, in this way, we will end up pairing the bigger integers together and hence will increase the maximum pair sum. For example, we can pair up the array <code>[1, 1, 2, 3]</code> as <code>(1, 1), (2, 3)</code> with maximum sum as <code>5</code>. However, the optimal way would be to make a pair like <code>(1, 3), (1, 2)</code> with a maximum sum of <code>4</code>. This suggests that pairing adjacent numbers by value may not be the optimal approach.</p>
<p>Observing the above example we can think about another potential strategy to pair up the smallest integer with the greatest integer and then second-smallest with the second-greatest and so on. This method ensures we don't end up pairing the two greatest integers as we did in the previous method. But how can we know this is optimal and would always produce the minimum pair sum?</p>
<p>Suppose we have the array <span class="math inline">\([a_{1}, a_1, a_2, ......, a_{n}]\)</span>, where these integers are sorted in ascending order and so <span class="math inline">\(a_{1}\)</span> is the minimum integer and <span class="math inline">\(a_{n}\)</span> is the greatest one in the array. As per the above potential solution, we will pair up <span class="math inline">\(a_{1}\)</span> and <span class="math inline">\(a_{n}\)</span> together, we can try to prove this method wrong by contradiction. Let's say we assume there exist two integers in the array <span class="math inline">\(a_{i}\)</span> and <span class="math inline">\(a_{j}\)</span> and satisfy this:</p>
<ul>
<li><span class="math inline">\(a_{1} \le a_{i} \le a_{n}\)</span></li>
<li><span class="math inline">\(a_{1} \le a_{j} \le a_{n}\)</span></li>
</ul>
<p>Let's assume an opposite method, and prove that it leads to contradiction. Suppose the pair <span class="math inline">\([(a_{1}, a_{i}), (a_{n}, a_{j}) ]\)</span> is optimal than pair <span class="math inline">\([(a_{1}, a_{n}), (a_{i}, a_{j}) ]\)</span>. This is however not true, because <span class="math inline">\(a_{j} + a_{n}\)</span> is always bigger than or equal to <span class="math inline">\(a_{i} + a_{1}\)</span>, hence the max of <span class="math inline">\([(a_{1}, a_{i}), (a_{n}, a_{j}) ]\)</span> will always be <span class="math inline">\(a_{j} + a_{n}\)</span>. And no matter what the max of <span class="math inline">\([(a_{1}, a_{n}), (a_{i}, a_{j}) ]\)</span> it will always be smaller than or equal to <span class="math inline">\(a_{j} + a_{n}\)</span>. Therefore, our potential solution strategy is optimal.</p>
<p>The image below demonstrates the pairing:</p>
<p><img src="../Figures/1877/1877A.png" alt="fig" /></p>
<p>Therefore, we will sort the integers in the array and then pair the integers at the left end with the integers at the right end. The minimum value is paired with the maximum value, the next smallest value is paired with the next largest value, and so on. We need to iterate over only the first half of the array because the corresponding second element in the pair can be found by using the length of the array.</p>
<p><strong>Algorithm</strong></p>
<ol>
<li>Sort the array <code>nums</code>.</li>
<li>Initialize the variable <code>maxSum</code> to <code>0</code>.</li>
<li>Iterate over the array <code>nums</code> from index <code>0</code> to <code>nums.length() / 2 - 1</code>.</li>
<li>Get the sum of the current element and its corresponding pair <code>nums[i] + nums[nums.length() - 1 - i]</code>, and update <code>maxSum</code> if the sum is larger.</li>
<li>Return <code>maxSum</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/LZKfda9j/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Here, <span class="math inline">\(N\)</span> is the number of elements in the array <code>nums</code>.</p>
<ul>
<li>
<p>Time complexity <span class="math inline">\(O(N \log N)\)</span></p>
<p>Sorting the array <code>nums</code> will take <span class="math inline">\(O(N \log N)\)</span> time, and then we iterate over the array <code>nums</code> which will take <span class="math inline">\(O(N)\)</span> time. Hence, the total time complexity is equal to <span class="math inline">\(O(N \log N)\)</span>.</p>
</li>
<li>
<p>Space complexity <span class="math inline">\(O(\log N)\)</span></p>
<p>We don't need any extra space apart from the one required for sorting. The space complexity of the sorting algorithm depends on the implementation of each programming language. For instance, in Java, the Arrays.sort() for primitives is implemented as a variant of the quicksort algorithm whose space complexity is <span class="math inline">\(O(\log N)\)</span>. In C++ std::sort() function provided by STL is a hybrid of Quick Sort, Heap Sort, and Insertion Sort and has a worst-case space complexity of <span class="math inline">\(O(\log N)\)</span>. Thus, the use of the inbuilt sort() function might add up to <span class="math inline">\(O(\log N)\)</span> to space complexity.<br />
<br/></p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-128">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/minimize-the-heights-i/1" target="_blank" rel="noopener noreferrer">Minimize the Heights I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given</span><span style="font-size: 18px;"> a </span><span style="font-size: 18px;">array </span><strong style="font-size: 18px;">arr[] </strong><span style="font-size: 18px;">and&nbsp;positive integer&nbsp;</span><strong style="font-size: 18px;">k</strong><span style="font-size: 18px;">&nbsp;denoting heights of towers</span><span style="font-size: 18px;">, you have to modify the height&nbsp;of each&nbsp;tower either by increasing or decreasing them by </span><strong style="font-size: 18px;">k</strong><span style="font-size: 18px;"> only </span><strong style="font-size: 18px;">once</strong><span style="font-size: 18px;">.</span></p>
<p><span style="font-size: 18px;">Find out what could be the possible&nbsp;<strong>minimum difference</strong> of the height&nbsp;of <strong>shortest</strong> and <strong>longest</strong> towers after you have modified each tower. The modified height of the tower can be negative.<br /></span></p>
<p><span style="font-size: 18px;">Note:<strong> </strong></span><span style="font-size: 18px;">A slight modification of the problem can be found <a href="https://practice.geeksforgeeks.org/problems/minimize-the-heights3351/1">here</a>.&nbsp;<br /><br /></span><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 5, 8, 10], k = 2
<strong>Output: </strong>5
<strong>Explanation: </strong>The array can be modified as [3, 3, 6, 8]. The difference between the largest and the smallest is 8 - 3 = 5.
</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 9, 12, 16, 20], k = 3
<strong>Output: </strong>11
<strong>Explanation: </strong>The array can be modified as [6, 12, 9, 13, 17]. The difference between the largest and the smallest is 17 - 6 = 11.&nbsp;
</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints</strong><br />1 &le; k &le; 10<sup>4</sup><br />1 &le; number of towers &le; 10<sup>5</sup><br />0 &le; arr[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-129">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/description" target="_blank" rel="noopener noreferrer">Minimum Adjacent Swaps to Reach the Kth Smallest Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>num</code>, representing a large integer, and an integer <code>k</code>.</p>

<p>We call some integer <strong>wonderful</strong> if it is a <strong>permutation</strong> of the digits in <code>num</code> and is <strong>greater in value</strong> than <code>num</code>. There can be many wonderful integers. However, we only care about the <strong>smallest-valued</strong> ones.</p>

<ul>
	<li>For example, when <code>num = &quot;5489355142&quot;</code>:

	<ul>
		<li>The 1<sup>st</sup> smallest wonderful integer is <code>&quot;5489355214&quot;</code>.</li>
		<li>The 2<sup>nd</sup> smallest wonderful integer is <code>&quot;5489355241&quot;</code>.</li>
		<li>The 3<sup>rd</sup> smallest wonderful integer is <code>&quot;5489355412&quot;</code>.</li>
		<li>The 4<sup>th</sup> smallest wonderful integer is <code>&quot;5489355421&quot;</code>.</li>
	</ul>
	</li>
</ul>

<p>Return <em>the <strong>minimum number of adjacent digit swaps</strong> that needs to be applied to </em><code>num</code><em> to reach the </em><code>k<sup>th</sup></code><em><strong> smallest wonderful</strong> integer</em>.</p>

<p>The tests are generated in such a way that <code>k<sup>th</sup></code>&nbsp;smallest wonderful integer exists.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;5489355142&quot;, k = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;5489355421&quot;. To get this number:
- Swap index 7 with index 8: &quot;5489355<u>14</u>2&quot; -&gt; &quot;5489355<u>41</u>2&quot;
- Swap index 8 with index 9: &quot;54893554<u>12</u>&quot; -&gt; &quot;54893554<u>21</u>&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;11112&quot;, k = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;21111&quot;. To get this number:
- Swap index 3 with index 4: &quot;111<u>12</u>&quot; -&gt; &quot;111<u>21</u>&quot;
- Swap index 2 with index 3: &quot;11<u>12</u>1&quot; -&gt; &quot;11<u>21</u>1&quot;
- Swap index 1 with index 2: &quot;1<u>12</u>11&quot; -&gt; &quot;1<u>21</u>11&quot;
- Swap index 0 with index 1: &quot;<u>12</u>111&quot; -&gt; &quot;<u>21</u>111&quot;
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> num = &quot;00123&quot;, k = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> The 1<sup>st</sup> smallest wonderful number is &quot;00132&quot;. To get this number:
- Swap index 3 with index 4: &quot;001<u>23</u>&quot; -&gt; &quot;001<u>32</u>&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= num.length &lt;= 1000</code></li>
	<li><code>1 &lt;= k &lt;= 1000</code></li>
	<li><code>num</code> only consists of digits.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-130">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-array-length-after-pair-removals/description" target="_blank" rel="noopener noreferrer">Minimum Array Length After Pair Removals</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">counting</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>num</code> sorted in non-decreasing order.</p>

<p>You can perform the following operation any number of times:</p>

<ul>
	<li>Choose <strong>two</strong> indices, <code>i</code> and <code>j</code>, where <code>nums[i] &lt; nums[j]</code>.</li>
	<li>Then, remove the elements at indices <code>i</code> and <code>j</code> from <code>nums</code>. The remaining elements retain their original order, and the array is re-indexed.</li>
</ul>

<p>Return the <strong>minimum</strong> length of <code>nums</code> after applying the operation zero or more times.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/18/tcase1.gif" style="width: 160px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,1,2,2,3,3]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase2.gif" style="width: 240px; height: 70px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1000000000,1000000000]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p>Since both numbers are equal, they cannot be removed.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [2,3,4,4,4]</span></p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/05/19/tcase3.gif" style="width: 210px; height: 70px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-131">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-average-of-smallest-and-largest-elements/description" target="_blank" rel="noopener noreferrer">Minimum Average of Smallest and Largest Elements</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have an array of floating point numbers <code>averages</code> which is initially empty. You are given an array <code>nums</code> of <code>n</code> integers where <code>n</code> is even.</p>

<p>You repeat the following procedure <code>n / 2</code> times:</p>

<ul>
	<li>Remove the <strong>smallest</strong> element, <code>minElement</code>, and the <strong>largest</strong> element <code>maxElement</code>,&nbsp;from <code>nums</code>.</li>
	<li>Add <code>(minElement + maxElement) / 2</code> to <code>averages</code>.</li>
</ul>

<p>Return the <strong>minimum</strong> element in <code>averages</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [7,8,3,4,15,13,4,1]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.5</span></p>

<p><strong>Explanation:</strong></p>

<table>
	<tbody>
		<tr>
			<th>step</th>
			<th>nums</th>
			<th>averages</th>
		</tr>
		<tr>
			<td>0</td>
			<td>[7,8,3,4,15,13,4,1]</td>
			<td>[]</td>
		</tr>
		<tr>
			<td>1</td>
			<td>[7,8,3,4,13,4]</td>
			<td>[8]</td>
		</tr>
		<tr>
			<td>2</td>
			<td>[7,8,4,4]</td>
			<td>[8,8]</td>
		</tr>
		<tr>
			<td>3</td>
			<td>[7,4]</td>
			<td>[8,8,6]</td>
		</tr>
		<tr>
			<td>4</td>
			<td>[]</td>
			<td>[8,8,6,5.5]</td>
		</tr>
	</tbody>
</table>
The smallest element of averages, 5.5, is returned.</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,9,8,3,10,5]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.5</span></p>

<p><strong>Explanation:</strong></p>

<table>
	<tbody>
		<tr>
			<th>step</th>
			<th>nums</th>
			<th>averages</th>
		</tr>
		<tr>
			<td>0</td>
			<td><span class="example-io">[1,9,8,3,10,5]</span></td>
			<td>[]</td>
		</tr>
		<tr>
			<td>1</td>
			<td><span class="example-io">[9,8,3,5]</span></td>
			<td>[5.5]</td>
		</tr>
		<tr>
			<td>2</td>
			<td><span class="example-io">[8,5]</span></td>
			<td>[5.5,6]</td>
		</tr>
		<tr>
			<td>3</td>
			<td>[]</td>
			<td>[5.5,6,6.5]</td>
		</tr>
	</tbody>
</table>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">nums = [1,2,3,7,8,9]</span></p>

<p><strong>Output:</strong> <span class="example-io">5.0</span></p>

<p><strong>Explanation:</strong></p>

<table>
	<tbody>
		<tr>
			<th>step</th>
			<th>nums</th>
			<th>averages</th>
		</tr>
		<tr>
			<td>0</td>
			<td><span class="example-io">[1,2,3,7,8,9]</span></td>
			<td>[]</td>
		</tr>
		<tr>
			<td>1</td>
			<td><span class="example-io">[2,3,7,8]</span></td>
			<td>[5]</td>
		</tr>
		<tr>
			<td>2</td>
			<td><span class="example-io">[3,7]</span></td>
			<td>[5,5]</td>
		</tr>
		<tr>
			<td>3</td>
			<td><span class="example-io">[]</span></td>
			<td>[5,5,5]</td>
		</tr>
	</tbody>
</table>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= n == nums.length &lt;= 50</code></li>
	<li><code>n</code> is even.</li>
	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-132">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-changes-to-make-k-semi-palindromes/description" target="_blank" rel="noopener noreferrer">Minimum Changes to Make K Semi-palindromes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an integer <code>k</code>, partition <code>s</code> into <code>k</code> <strong><span data-keyword="substring-nonempty">substrings</span></strong> such that the letter changes needed to make each substring a <strong>semi-palindrome</strong>&nbsp;are minimized.</p>

<p>Return the <em><strong>minimum</strong> number of letter changes</em> required<em>.</em></p>

<p>A <strong>semi-palindrome</strong> is a special type of string that can be divided into <strong><span data-keyword="palindrome">palindromes</span></strong> based on a repeating pattern. To check if a string is a semi-palindrome:​</p>

<ol>
	<li>Choose a positive divisor <code>d</code> of the string&#39;s length. <code>d</code> can range from <code>1</code> up to, but not including, the string&#39;s length. For a string of length <code>1</code>, it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed.</li>
	<li>For a given divisor <code>d</code>, divide the string into groups where each group contains characters from the string that follow a repeating pattern of length <code>d</code>. Specifically, the first group consists of characters at positions <code>1</code>, <code>1 + d</code>, <code>1 + 2d</code>, and so on; the second group includes characters at positions <code>2</code>, <code>2 + d</code>, <code>2 + 2d</code>, etc.</li>
	<li>The string is considered a semi-palindrome if each of these groups forms a palindrome.</li>
</ol>

<p>Consider the string <code>&quot;abcabc&quot;</code>:</p>

<ul>
	<li>The length of <code>&quot;abcabc&quot;</code> is <code>6</code>. Valid divisors are <code>1</code>, <code>2</code>, and <code>3</code>.</li>
	<li>For <code>d = 1</code>: The entire string <code>&quot;abcabc&quot;</code> forms one group. Not a palindrome.</li>
	<li>For <code>d = 2</code>:
	<ul>
		<li>Group 1 (positions <code>1, 3, 5</code>): <code>&quot;acb&quot;</code></li>
		<li>Group 2 (positions <code>2, 4, 6</code>): <code>&quot;bac&quot;</code></li>
		<li>Neither group forms a palindrome.</li>
	</ul>
	</li>
	<li>For <code>d = 3</code>:
	<ul>
		<li>Group 1 (positions <code>1, 4</code>): <code>&quot;aa&quot;</code></li>
		<li>Group 2 (positions <code>2, 5</code>): <code>&quot;bb&quot;</code></li>
		<li>Group 3 (positions <code>3, 6</code>): <code>&quot;cc&quot;</code></li>
		<li>All groups form palindromes. Therefore, <code>&quot;abcabc&quot;</code> is a semi-palindrome.</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> s = &quot;abcac&quot;, k = 2 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> 1 </span></p>

<p><strong>Explanation: </strong> Divide <code>s</code> into <code>&quot;ab&quot;</code> and <code>&quot;cac&quot;</code>. <code>&quot;cac&quot;</code> is already semi-palindrome. Change <code>&quot;ab&quot;</code> to <code>&quot;aa&quot;</code>, it becomes semi-palindrome with <code>d = 1</code>.</p>
</div>

<p><strong class="example">Example 2: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> s = &quot;abcdef&quot;, k = 2 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> 2 </span></p>

<p><strong>Explanation: </strong> Divide <code>s</code> into substrings <code>&quot;abc&quot;</code> and <code>&quot;def&quot;</code>. Each&nbsp;needs one change to become semi-palindrome.</p>
</div>

<p><strong class="example">Example 3: </strong></p>

<div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
<p><strong>Input: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> s = &quot;aabbaa&quot;, k = 3 </span></p>

<p><strong>Output: </strong> <span class="example-io" style="font-family: Menlo,sans-serif; font-size: 0.85rem;"> 0 </span></p>

<p><strong>Explanation: </strong> Divide <code>s</code> into substrings <code>&quot;aa&quot;</code>, <code>&quot;bb&quot;</code> and <code>&quot;aa&quot;</code>.&nbsp;All are already semi-palindromes.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 200</code></li>
	<li><code>1 &lt;= k &lt;= s.length / 2</code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-133">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-common-value/description" target="_blank" rel="noopener noreferrer">Minimum Common Value</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, return <em>the <strong>minimum integer common</strong> to both arrays</em>. If there is no common integer amongst <code>nums1</code> and <code>nums2</code>, return <code>-1</code>.</p>

<p>Note that an integer is said to be <strong>common</strong> to <code>nums1</code> and <code>nums2</code> if both arrays have <strong>at least one</strong> occurrence of that integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3], nums2 = [2,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The smallest element common to both arrays is 2, so we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,2,3,6], nums2 = [2,3,4,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>
	<li>Both <code>nums1</code> and <code>nums2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given the arrays <code>nums1</code> and <code>nums2</code>, we aim to find the minimum integer common to both arrays. <code>nums1</code> and <code>nums2</code> are both sorted in increasing order. If there is no common integer, return <code>-1</code>.</p>
<p>A common value between two arrays appears in both arrays at least once.</p>
<hr />
<h3 id="approach-1-hash-set">Approach 1: Hash Set</h3>
<h4 id="intuition">Intuition</h4>
<p>The brute force approach to solving this problem would be to use nested loops to iterate through each number in each array, searching for common values, and then calculate the minimum of the common values. Nested loops are inefficient. It would be helpful if, instead of searching through an array to find a value, we could look up an element in constant time. Hash tables are a data structure that facilitate constant time lookups.</p>
<p>There are two main kinds of hash tables: hash maps, which store (key, value) pairs, and hash sets, which store unique values. For this problem, we chose a hash set because we are concerned with whether an element exists, not the number of times it occurs. A hashmap could alternatively be used to solve this problem, where the element is the key and the frequency is the value. Check out the <a href="https://leetcode.com/explore/learn/card/hash-table/">hash table explore card</a> to learn more about hash tables.</p>
<p>We can add the elements in <code>nums1</code> to a hash set <code>set1</code>, where the element is the key.</p>
<p>Then, we can loop through <code>nums2</code>, and check whether each element is in <code>set1</code>. Since <code>nums2</code> is in sorted order, the first common element we find is the minimum common element.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a set <code>set1</code> and add the elements from <code>nums1</code>.</li>
<li>For each <code>num</code> in <code>nums2</code>:
<ul>
<li>If <code>num</code> is in <code>set1</code>, return <code>num</code>. We found a common element. Since <code>nums2</code> is sorted in ascending order, the first common element is the minimum common element.</li>
</ul>
</li>
<li>Return <code>-1</code> if there are no common elements.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/gEWsehHy/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2.</code></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>Creating <code>set1</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>We search for each element of <code>nums2</code> in <code>set1</code>. Searching for an element in a hash set takes <span class="math inline">\(O(1)\)</span> on average, so the time complexity of this step is <span class="math inline">\(O(m)\)</span>.</p>
<p>The total time complexity will be <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We initialize the set <code>set1</code>, which is size <span class="math inline">\(O(e)\)</span> where <span class="math inline">\(e\)</span> is the number of distinct elements in <code>nums1</code>. At worst, there can be <span class="math inline">\(n\)</span> distinct elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<h5 id="set-intersection">Set Intersection</h5>
<p>Note that given two sets, their intersection is all of their common elements. Another approach to solving this problem would be to create sets out of <code>nums1</code> and <code>nums2</code>, then find the minimum value of the intersection. Below is the Python3 code for this approach. This approach is less straightforward for languages that do not have built-in set functions and requires more space than the other approaches without an improvement in time complexity, so it is not discussed in depth.</p>
<p><a href="https://leetcode.com/playground/SLacCfPL/shared">code</a></p>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our objective is to find the minimum common value between two arrays. As discussed previously, the brute force approach would be to iterate through both arrays, searching for common values. This approach would be inefficient, with a time complexity of <span class="math inline">\(O(n \cdot m)\)</span>.</p>
<p>Can we develop a more efficient approach without using extra space?</p>
<p>Let's look at some examples to develop a strategy.</p>
<h5 id="example-1">Example 1:</h5>
<blockquote>
<p><strong>Input:</strong> nums1 = [1, 2, 3, 4, 5], nums2 = [1, 3, 5]</p>
<p><strong>Output:</strong> 1</p>
<p><strong>Explanation:</strong> There are three common elements in the arrays, 1, 3, and 5, out of which 1 is the smallest, so 1 is returned.</p>
</blockquote>
<h5 id="example-2">Example 2:</h5>
<blockquote>
<p><strong>Input:</strong> nums1 = [2, 4, 6, 8, 10], nums2 = [1, 2, 3, 4, 5]</p>
<p><strong>Output:</strong> 2</p>
<p><strong>Explanation:</strong> There are two common elements in the arrays, 2, and 4, out of which 2 is the smallest, so 2 is returned.</p>
</blockquote>
<p>What patterns can we deduce from examining these examples?</p>
<p>Notice that since the arrays are sorted, and our objective is to find the minimum common value, the first common value we find when traversing both arrays left to right is the minimum common value.</p>
<p>We can leverage this fact to develop an efficient solution.</p>
<p>We can use two pointers to traverse both arrays simultaneously without a nested loop.</p>
<p><code>first</code> will indicate the position in <code>nums1</code>, and <code>second</code> will indicate the position in <code>nums2</code>.</p>
<p>During each iteration, we compare the values of <code>nums1[first]</code> and <code>nums2[second]</code>. There are three possibilities.</p>
<ol>
<li>
<p>The elements are equal. We have found a common value, and we return it.</p>
</li>
<li>
<p><code>nums1[first] &lt; nums2[second]</code>. Because <code>nums2</code> is sorted, every element after <code>second</code> will also be greater than <code>nums1[first]</code>. However, there is a chance that an element in <code>nums1</code> after <code>first</code> will be equal to <code>nums2[second]</code>. Thus, we should increment <code>first</code>.</p>
</li>
<li>
<p><code>nums1[first] &gt; nums2[second]</code>. The logic works the other way visa versa. We should increment <code>second</code>.</p>
</li>
</ol>
<p>By traversing the arrays in this manner, we will find the first common value, if it exists.</p>
<blockquote>
<p>How do we know this approach will consistently provide the correct solution?</p>
<p>We always increment the pointer which points to the lower value. This means we will process all the elements from both arrays in ascending order.</p>
<p>Our algorithm stops in three cases:</p>
<ol>
<li>
<p>A common element is found: it must be the minimum common value because elements are processed in order.</p>
</li>
<li>
<p>Both pointers reach the end of their array: all elements were checked, and there were no common values.</p>
</li>
<li>
<p>One pointer reaches the end of its array, and the element it points to is less than the current element in the other array: all remaining elements in the other array are larger than this element, so there are no common elements.</p>
</li>
</ol>
</blockquote>
<p>Below is a visualization of this algorithm:</p>
<p>!?!../Documents/2540/2540_slideshow.json:960,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize two variables: <code>first</code>, which will store the position in <code>nums1</code>, and <code>second</code>, which will store the position in <code>nums2</code> to <code>0</code>, the starting index.</li>
<li>Iterate through <code>nums1</code> and <code>nums2</code> while <code>first</code> is less than the size of <code>nums1</code> and <code>second</code> is less than the size of <code>nums2</code>:
<ul>
<li>If <code>nums1[first]</code> is less than <code>nums2[second]</code>, increment <code>first</code> by <code>1</code> because we need a larger value from <code>nums1</code> to match the value at <code>nums2[second]</code>.</li>
<li>If <code>nums1[first]</code> is greater than <code>nums2[second]</code>, increment <code>second</code> by <code>1</code> because we need a larger value from <code>nums2</code> to match the value at <code>nums1[first]</code>.</li>
<li>Otherwise, <code>nums1[first]</code> must equal <code>nums2[second]</code>, so return the value of <code>nums1[first]</code>. We have found the minimum common value.</li>
</ul>
</li>
<li>Return <code>-1</code> if the loop completes without returning an answer. This means there is no common value between <code>nums1</code> and <code>nums2</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/L8ASNvpL/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>nums1</code> and <span class="math inline">\(m\)</span> be the length of <code>nums2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m)\)</span></p>
<p>We iterate through <code>nums1</code> and <code>nums2</code> using two pointers. On each iteration of the loop, one of the pointers is incremented, but not both. Each pointer can be incremented as many times as <span class="math inline">\(n\)</span> or <span class="math inline">\(m\)</span>, respectively, meaning we will iterate at most <span class="math inline">\(n + m\)</span> times. With each iteration, we performed <span class="math inline">\(O(1)\)</span> work. Therefore, the time complexity is <span class="math inline">\(O(n + m)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<h3 id="approach-3-binary-search">Approach 3: Binary Search</h3>
<h4 id="intuition-2">Intuition</h4>
<p>To solve this problem, we need to search for common values between two arrays. The arrays are sorted, which means we can utilize binary search.</p>
<blockquote>
<p>Binary search is a search algorithm that finds the position of a target value within a sorted array.</p>
</blockquote>
<p>If you are unfamiliar with binary search, check out the <a href="https://leetcode.com/explore/learn/card/binary-search/">binary search explore card</a>.</p>
<p>Binary search uses three pointers. We can call them <code>left</code>, <code>mid</code>, and <code>right</code>.</p>
<p>Initially, <code>left</code> points to the first index of the array and <code>right</code> points to the last. At each step, we calculate <code>mid</code> as the middle element between <code>left</code> and <code>right</code>.</p>
<p>Binary search compares the target value with the middle element at each iteration.</p>
<ul>
<li>
<p>If the target value is equal to the middle element, the target has been found.</p>
</li>
<li>
<p>If the target value is less than the middle element, continue to search in the left half.</p>
</li>
<li>
<p>If the target value is greater than the middle element, continue to search in the right half.</p>
</li>
</ul>
<p>With every iteration, the search window is divided in half, and the search is continued in either the right or the left side until either the target is found or <code>left</code> becomes greater than <code>right</code>.</p>
<p>We can solve the problem by iterating through each element in <code>nums1</code>, and using binary search to find that element in <code>nums2</code>. We want to perform binary search on the longer array, which will make the algorithm more efficient, so if <code>nums1</code> is longer, we swap the arrays.</p>
<p>Below is a visualization of this algorithm:</p>
<p>!?!../Documents/2540/2540_slideshow2.json:960,540!?!</p>
<h4 id="algorithm-2">Algorithm</h4>
<h5 id="implementation-note">Implementation Note:</h5>
<p><code>mid</code>, the middle of the subarray, is set to the index in the middle of the array. The basic midpoint formula is <code>(left + right) / 2</code>.<br />
You'll notice that the below implementations instead use <code>left + (right - left) / 2</code>. This is because if <code>left + right</code> is greater than the maximum integer value, <span class="math inline">\(2^{31} - 1\)</span>, it overflows and causes errors.</p>
<p><code>left + (right - left) / 2</code> is an equivalent formula, and never stores a value larger than <code>left</code> or <code>right</code>. Thus, if <code>left</code> and <code>right</code> are within the integer limits, we will never overflow.</p>
<ol>
<li>Declare a function <code>binarySearch</code> that takes an array <code>nums</code> and a target value as parameters and returns <code>true</code> if the target is in the array.
<ul>
<li>Initialize <code>left</code> pointer to <code>0</code> and <code>right</code> pointer to <code>nums.length -1</code>. These represent the first and last indices of the array.</li>
<li>While <code>left</code> is less than or equal to <code>right</code>, iteratively perform a binary search:
<ul>
<li>Set <code>mid</code> to <code>left + (right - left) / 2</code>, which is the middle of this section of <code>nums</code>. We will compare <code>nums[mid]</code> to <code>target</code>.</li>
<li>If <code>nums[mid]</code> is greater than <code>target</code>, set <code>right</code> to <code>mid - 1</code>, we will continue to search in the left half <code>nums</code>.</li>
<li>If <code>nums[mid]</code> is less than <code>target</code>, set <code>left</code> to <code>mid + 1</code>, we will continue to search in the right half <code>nums</code>.</li>
<li>Otherwise, <code>nums[mid]</code> equals <code>target</code>, return <code>true</code>.</li>
</ul>
</li>
</ul>
</li>
<li>If <code>nums1</code> is longer than <code>nums2</code>, call getCommon with the arrays swapped.</li>
<li>Iterate through each <code>num</code> in <code>nums1</code>, using binary search to determine whether that element is in <code>nums2</code>:
<ul>
<li>If <code>num</code> is found in <code>nums2</code>, we can return <code>num</code>. This is guaranteed to be the minimum common value, because both arrays are sorted.</li>
</ul>
</li>
<li>If we did not find any common elements, return <code>-1</code>. There is no common value.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/TxxqXwHU/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the shorter array and <span class="math inline">\(m\)</span> be the length of the longer array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log m)\)</span></p>
<p>We iterate through the shorter array, using binary search to look for each element in the longer array. Binary Search takes <span class="math inline">\(O( \log m)\)</span> time to search through <span class="math inline">\(m\)</span> elements, so the overall time complexity is <span class="math inline">\(O(n \log m)\)</span>.</p>
<p>If one of the arrays is very large relative to the other, this approach will be more efficient than the previous two.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We use a couple of variables and no additional data structures that grow with input size, so the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-134">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/description" target="_blank" rel="noopener noreferrer">Minimum Length of String After Deleting Similar Ends</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>. You are asked to apply the following algorithm on the string any number of times:</p>

<ol>
	<li>Pick a <strong>non-empty</strong> prefix from the string <code>s</code> where all the characters in the prefix are equal.</li>
	<li>Pick a <strong>non-empty</strong> suffix from the string <code>s</code> where all the characters in this suffix are equal.</li>
	<li>The prefix and the suffix should not intersect at any index.</li>
	<li>The characters from the prefix and suffix must be the same.</li>
	<li>Delete both the prefix and the suffix.</li>
</ol>

<p>Return <em>the <strong>minimum length</strong> of </em><code>s</code> <em>after performing the above operation any number of times (possibly zero times)</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ca&quot;
<strong>Output:</strong> 2
<strong>Explanation: </strong>You can&#39;t remove any characters, so the string stays as is.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cabaabac&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> An optimal sequence of operations is:
- Take prefix = &quot;c&quot; and suffix = &quot;c&quot; and remove them, s = &quot;abaaba&quot;.
- Take prefix = &quot;a&quot; and suffix = &quot;a&quot; and remove them, s = &quot;baab&quot;.
- Take prefix = &quot;b&quot; and suffix = &quot;b&quot; and remove them, s = &quot;aa&quot;.
- Take prefix = &quot;a&quot; and suffix = &quot;a&quot; and remove them, s = &quot;&quot;.</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabccabba&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> An optimal sequence of operations is:
- Take prefix = &quot;aa&quot; and suffix = &quot;a&quot; and remove them, s = &quot;bccabb&quot;.
- Take prefix = &quot;b&quot; and suffix = &quot;bb&quot; and remove them, s = &quot;cca&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> only consists of characters <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given a string <code>s</code>, we aim to return the length of <code>s</code> after deleting similar ends.</p>
<p>When the characters at the beginning and end of <code>s</code> are the same, we can delete the prefix and suffix. A prefix or suffix can contain multiple of the same character. The prefix and suffix can be of different lengths, but must not intersect.</p>
<p>Note that the objective is to find the length of <code>s</code> after deleting characters, not to return the modified string. The best practice is not to modify the input; we can count the remaining characters after identifying characters we would delete.</p>
<hr />
<h3 id="approach-1-two-pointers">Approach 1: Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>After deleting similar ends, our goal is to find the number of characters remaining in <code>s</code>.</p>
<p><strong>When can we delete the prefix and suffix?</strong></p>
<p>We can delete the prefix and suffix when the character at the beginning of <code>s</code> is the same as the character at the end of <code>s</code>. Let's call this character <code>c</code>.</p>
<p>As shown in example 3 from the problem description, for a given character <code>c</code>, we can delete multiple occurrences of it as the prefix and suffix. For the input <code>s = &quot;aabccabba&quot;</code>, two occurrences of <code>&quot;a&quot;</code> are deleted as the prefix, and one occurrence of <code>&quot;a&quot;</code> is deleted as the suffix.</p>
<p>When the characters at the beginning and end of <code>s</code> both equal <code>c</code>, we can delete characters at the beginning of <code>s</code> until the first character of <code>s</code> no longer equals <code>c</code>. Then, we can delete the characters at the end of <code>s</code> until the last character of <code>s</code> no longer equals <code>c</code>.</p>
<p>We can compare the characters at the beginning and end of <code>s</code> by using two pointers: <code>begin</code>, which points to the beginning of <code>s</code>, and <code>end</code>, which points to the end.</p>
<p>To &quot;delete&quot; a character, we move the <code>begin</code> or <code>end</code> pointer one step to the center.</p>
<p>We can process <code>s</code> with these pointers until they meet in the middle or the characters at the beginning and end of the substring of <code>s</code> differ. When we cannot delete more characters, we find the remaining characters. The characters between <code>begin</code> and <code>end</code> are the remaining characters. To calculate the number of remaining characters, we can subtract <code>begin</code> from <code>end</code>, then add <code>1</code>. We add <code>1</code> because when <code>end</code> and <code>begin</code> are the same and have a difference of <code>0</code>, there is <code>1</code> remianing character in the string.</p>
<blockquote>
<p><strong>How do we know this approach will delete all similar ends?</strong></p>
<p>With each iteration, <code>begin</code> is incremented to delete the prefix, and <code>end</code> is decremented to delete the suffix, unless all remaining characters are the same, in which case the <code>begin</code> pointer is used to delete both the prefix and suffix. The pointers move towards each other, so we will process a prefix and suffix with each iteration.</p>
<p>Our algorithm stops in three cases:</p>
<ol>
<li>The character at <code>s[begin]</code> is different from the character at <code>s[end]</code>: every time we delete a character, we delete all occurrences of that character on each end. This means that when there are no longer similar ends, we have deleted them all.</li>
<li><code>begin</code> is equal to <code>end</code>: we have processed the whole string and deleted all but <code>1</code> character; we can no longer delete a separate prefix and suffix, so all similar ends have been deleted.</li>
<li><code>begin</code> is greater than <code>end</code>: we have processed and deleted the whole string.</li>
</ol>
</blockquote>
<p>Below is a visualization of the two-pointer method for deleting similar ends:</p>
<p>!?!../Documents/1750/1750_slideshow.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize two variables, <code>begin</code> to <code>0</code> and <code>end</code> to <code>s.length() - 1</code>. <code>begin</code> points to the first index of <code>s</code> and <code>end</code> points to the last index.</li>
<li>While <code>begin</code> is less than <code>end</code> and the character at <code>s[begin]</code> equals the character at <code>s[end]</code>:
<ul>
<li>Initialize a character <code>c</code> to <code>s[begin]</code>.</li>
<li>While <code>begin</code> is less than or equal to <code>end</code> and <code>s[begin]</code> equals <code>c</code>, increment <code>begin</code> by <code>1</code> to delete a prefix character.</li>
<li>While <code>end</code> is greater than <code>begin</code> and <code>s[end]</code> equals <code>c</code>, decrement <code>end</code> by <code>1</code> to delete a suffix character.</li>
</ul>
</li>
<li>After processing <code>s</code>, return <code>end - begin + 1</code>, the number of remaining characters.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><strong>Implementation 1: Iterative</strong></p>
<p><a href="https://leetcode.com/playground/h3EcDrkL/shared">code</a></p>
<p><strong>Implementation 2: Tail Recursion</strong></p>
<p>We can implement the above approach recursively as well as iteratively. We can delete similar ends, and then recursively delete similar ends on the remaining string.</p>
<p>We use a helper function, <code>deleteSimilarEnds</code>, so we can pass <code>begin</code> and <code>end</code> as parameters. The base case is when a prefix and suffix cannot be deleted because the ends differ or meet in the middle. In this case, we return the number of remaining characters.<br />
When there are similar ends, the function deletes them using a similar process as the above implementation and recursively calls itself.</p>
<p>In a recursive function, each recursive call creates a new stack frame, which can lead to a stack overflow if the function is called too many times. Tail recursion reduces this problem by reusing the current stack frame instead of creating a new one.<br />
It's an optimization technique used in functional programming to avoid the use of explicit loops and improve performance.</p>
<p>To use tail recursion, the last statement of a function must be a recursive call, and the function must have a base case that can be reached by the recursive call. The base case is used to stop the recursion and return a value.<br />
Since our approach has both conditions, we can use tail recursion in the below implementation.</p>
<blockquote>
<p>Note: The implementation shown here is provided for the purpose of building perspective on different ways to solve a problem. While the recursion-based solution is valid, the two-pointer implementation remains the most intuitive and optimized solution.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/79jpHN4R/shared">code</a></p>
<p>The time complexity of the recursive implementation is the same as the iterative implementation. The main space required for this recursive implementation is the call stack, which can grow as large as the number of recursive calls. There will be a recursive call for each pair of similar ends, and there can be as many as <span class="math inline">\(\frac{n}{2}\)</span> similar ends, so our implementation will have <span class="math inline">\(\frac{n}{2}\)</span> recursive calls. <span class="math inline">\(\frac{n}{2}\)</span> is a linear complexity, so we describe the space complexity as <span class="math inline">\(O(n)\)</span>.</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We process <code>s</code> using the pointers <code>begin</code> and <code>end</code> until they meet in the middle. Although we use nested while loops, with each iteration,  <code>begin</code> is incremented, and/or <code>end</code> is decremented, or the loop terminates because a prefix and suffix can no longer be deleted. We handle each character of <code>s</code> at most once, so the time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The iterative implementation uses a few variables and no additional data structures that grow with input size, so the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-135">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-i/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Make Binary Grid Palindromic I</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A row or column is considered <strong>palindromic</strong> if its values read the same forward and backward.</p>

<p>You can <strong>flip</strong> any number of cells in <code>grid</code> from <code>0</code> to <code>1</code>, or from <code>1</code> to <code>0</code>.</p>

<p>Return the <strong>minimum</strong> number of cells that need to be flipped to make <strong>either</strong> all rows <strong>palindromic</strong> or all columns <strong>palindromic</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0],[0,0,0],[0,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-20-10.png" style="width: 420px; height: 108px;" /></p>

<p>Flipping the highlighted cells makes all the rows palindromic.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = </span>[[0,1],[0,1],[0,0]]</p>

<p><strong>Output:</strong> <span class="example-io">1</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-31-23.png" style="width: 300px; height: 100px;" /></p>

<p>Flipping the highlighted cell makes all the columns palindromic.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>All rows are already palindromic.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-136">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-flips-to-make-binary-grid-palindromic-ii/description" target="_blank" rel="noopener noreferrer">Minimum Number of Flips to Make Binary Grid Palindromic II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> binary matrix <code>grid</code>.</p>

<p>A row or column is considered <strong>palindromic</strong> if its values read the same forward and backward.</p>

<p>You can <strong>flip</strong> any number of cells in <code>grid</code> from <code>0</code> to <code>1</code>, or from <code>1</code> to <code>0</code>.</p>

<p>Return the <strong>minimum</strong> number of cells that need to be flipped to make <strong>all</strong> rows and columns <strong>palindromic</strong>, and the total number of <code>1</code>&#39;s in <code>grid</code> <strong>divisible</strong> by <code>4</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1,0,0],[0,1,0],[0,0,1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">3</span></p>

<p><strong>Explanation:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2024/08/01/image.png" style="width: 400px; height: 105px;" /></p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[0,1],[0,1],[0,0]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/07/08/screenshot-from-2024-07-09-01-37-48.png" style="width: 300px; height: 104px;" /></p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">grid = [[1],[1]]</span></p>

<p><strong>Output:</strong> <span class="example-io">2</span></p>

<p><strong>Explanation:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2024/08/01/screenshot-from-2024-08-01-23-05-26.png" style="width: 200px; height: 70px;" /></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == grid.length</code></li>
	<li><code>n == grid[i].length</code></li>
	<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-137">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/description" target="_blank" rel="noopener noreferrer">Minimum Number of Moves to Make Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary indexed tree</span> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting only of lowercase English letters.</p>

<p>In one <strong>move</strong>, you can select any two <strong>adjacent</strong> characters of <code>s</code> and swap them.</p>

<p>Return <em>the <strong>minimum number of moves</strong> needed to make</em> <code>s</code> <em>a palindrome</em>.</p>

<p><strong>Note</strong> that the input will be generated such that <code>s</code> can always be converted to a palindrome.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aabb&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong>
We can obtain two palindromes from s, &quot;abba&quot; and &quot;baab&quot;. 
- We can obtain &quot;abba&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;ab<u><strong>ab</strong></u>&quot; -&gt; &quot;abba&quot;.
- We can obtain &quot;baab&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;<u><strong>ab</strong></u>ab&quot; -&gt; &quot;baab&quot;.
Thus, the minimum number of moves needed to make s a palindrome is 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;letelt&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong>
One of the palindromes we can obtain from s in 2 moves is &quot;lettel&quot;.
One of the ways we can obtain it is &quot;lete<u><strong>lt</strong></u>&quot; -&gt; &quot;let<u><strong>et</strong></u>l&quot; -&gt; &quot;lettel&quot;.
Other palindromes such as &quot;tleelt&quot; can also be obtained in 2 moves.
It can be shown that it is not possible to obtain a palindrome in less than 2 moves.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 2000</code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>s</code> can be converted to a palindrome using a finite number of moves.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-138">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/description" target="_blank" rel="noopener noreferrer">Minimum Number of Swaps to Make the String Balanced</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> string <code>s</code> of <strong>even</strong> length <code>n</code>. The string consists of <strong>exactly</strong> <code>n / 2</code> opening brackets <code>&#39;[&#39;</code> and <code>n / 2</code> closing brackets <code>&#39;]&#39;</code>.</p>

<p>A string is called <strong>balanced</strong> if and only if:</p>

<ul>
	<li>It is the empty string, or</li>
	<li>It can be written as <code>AB</code>, where both <code>A</code> and <code>B</code> are <strong>balanced</strong> strings, or</li>
	<li>It can be written as <code>[C]</code>, where <code>C</code> is a <strong>balanced</strong> string.</li>
</ul>

<p>You may swap the brackets at <strong>any</strong> two indices <strong>any</strong> number of times.</p>

<p>Return <em>the <strong>minimum</strong> number of swaps to make </em><code>s</code> <em><strong>balanced</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;][][&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> You can make the string balanced by swapping index 0 with index 3.
The resulting string is &quot;[[]]&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;]]][[[&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> You can do the following to make the string balanced:
- Swap index 0 with index 4. s = &quot;[]][][&quot;.
- Swap index 1 with index 5. s = &quot;[[][]]&quot;.
The resulting string is &quot;[[][]]&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;[]&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> The string is already balanced.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == s.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>
	<li><code>n</code> is even.</li>
	<li><code>s[i]</code> is either <code>&#39;[&#39; </code>or <code>&#39;]&#39;</code>.</li>
	<li>The number of opening brackets <code>&#39;[&#39;</code> equals <code>n / 2</code>, and the number of closing brackets <code>&#39;]&#39;</code> equals <code>n / 2</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We are given a 0-indexed string <code>s</code> of even length <code>n</code> made up of <code>n/2</code> opening brackets <code>[</code> and <code>n/2</code> closing brackets <code>]</code>. Our task is to return the minimum number of swaps to make the string balanced.</p>
<p>Balanced parentheses mean that every opening bracket <code>[</code> has a matching closing bracket <code>]</code> in the correct order. Unbalanced parentheses occur when there are more closing brackets <code>]</code> than opening brackets <code>[</code> at some point in the string.</p>
<p>There are two key points to keep in mind:</p>
<ol>
<li>Swapping balanced brackets won't help. If you swap characters in a balanced pair like <code>[]</code>, it becomes <code>][</code>, which makes the string unbalanced. So, this type of swap increases the problem instead of solving it.</li>
<li>Swapping unbalanced brackets can fix the string. If a closing bracket <code>]</code> appears before its matching opening bracket <code>[</code>, a swap between an unbalanced <code>]</code> and an unbalanced <code>[</code> will balance one pair.</li>
</ol>
<p>What is the maximum number of brackets that you can balance with a single swap? The answer is 2 for all parentheses of the form <code>][</code>. Therefore, the optimal approach is to swap unbalanced parentheses with each other. Since 2 unbalanced parentheses are made balanced with a single swap, the total number of swaps to balance are given by <code>unbalanced / 2</code>.</p>
<p>Let's understand this with an example:</p>
<p>For the string <code>]]][[[</code>,</p>
<p>There are total 3 mismatches in the string. Now, we need to swap the <code>]</code> and <code>[</code> at index <code>0</code> and <code>5</code> respectively.</p>
<p>The string is now given by <code>[]][[]</code>. There is 1 mismatch in the string. So, swap <code>]</code> and <code>[</code> at index <code>2</code> and <code>3</code> respectively. This swap reduced exactly 2 mismatches.</p>
<p>The string is balanced and given by <code>[][][]</code>. Therefore, it requires exactly 2 swaps to balance the string.</p>
<p>To solve the problem, we can use a stack to keep track of unmatched opening brackets <code>[</code> as we move through the string. Each time we find a closing bracket <code>]</code>, we check if there’s an unmatched opening bracket <code>[</code> on the stack. If there is, we remove it, as we’ve found a match and balanced the pair. If the stack is empty when we encounter a closing bracket <code>]</code>, this bracket is unbalanced.</p>
<p>We count how many unbalanced closing brackets <code>]</code> we find. After traversing the string, the number of unbalanced <code>]</code> brackets tells us how many swaps are needed. Each swap fixes two brackets—one unbalanced <code>[</code> and one unbalanced <code>]</code>. So, the minimum number of swaps is half the total number of unbalanced closing brackets.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize a <code>stack</code> to keep track of unmatched opening brackets <code>[</code> and an integer <code>unbalanced</code> to count unbalanced closing brackets <code>]</code>.</li>
<li>Traverse the string <code>s</code> character by character:
<ul>
<li>If the current character is an opening bracket <code>[</code>, push it onto the <code>stack</code>.</li>
<li>If the current character is a closing bracket <code>]</code>:
<ul>
<li>Check if the <code>stack</code> is not empty:
<ul>
<li>If it is not empty, pop the top element from the <code>stack</code>.</li>
<li>If the <code>stack</code> is empty, increment the <code>unbalanced</code> counter.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result as the minimum number of swaps required to balance the string. The minimum number of swaps is calculated as <code>(unbalanced + 1) / 2</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/JnbKuFHN/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through each character of the string exactly once in the loop. Each push or pop operation on the stack takes constant time <span class="math inline">\(O(1)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>In the worst case, we may end up pushing all opening brackets <code>[</code> into the stack, so the space used by the stack can go up to <span class="math inline">\(O(n)\)</span>. Therefore, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-space-optimized-stack">Approach 2: Space-Optimized Stack</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We only need to count the unbalanced opening brackets <code>[</code> that don't have matching closing brackets <code>]</code>. This helps us figure out how many swaps are needed. Instead of using a stack, we can track the number of unmatched brackets with an integer, which saves space.</p>
<p>The <code>stackSize</code> represents the number of unmatched <code>[</code> brackets as we go through the string. When we encounter a closing bracket <code>]</code>, we try to balance it by reducing <code>stackSize</code> if there’s already an unmatched opening bracket (i.e., <code>stackSize</code> &gt; 0).</p>
<p>After the loop, the value of <code>stackSize</code> will show how many opening brackets are still unmatched. These remaining <code>[</code> brackets need to be balanced with closing brackets by performing swaps. Each swap balances two brackets (one <code>[</code> and one <code>]</code>), so the minimum number of swaps is <code>(stackSize + 1) / 2</code>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize <code>stackSize</code> to 0. This integer will keep track of the number of unmatched opening brackets <code>[</code>.</li>
<li>For each character <code>ch</code> in the string <code>s</code>:
<ul>
<li>If <code>ch</code> is an opening bracket <code>[</code>, increment <code>stackSize</code> by 1.</li>
<li>If <code>ch</code> is a closing bracket <code>]</code>:
<ul>
<li>Check if <code>stackSize</code> is greater than 0:
<ul>
<li>If true, decrement <code>stackSize</code> by 1 (indicating a matching opening bracket has been found).</li>
<li>If false, do nothing (this indicates an unbalanced closing bracket <code>]</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return the result as the minimum number of swaps required to balance the string. The minimum number of swaps is calculated as <code>(stackSize+1)/2</code>.</li>
</ol>
<p>!?!../Documents/1963/slideshow1.json:960,540!?!</p>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/PfFu3Nah/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the given string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We iterate through each character of the string exactly once in the loop. Each increment or decrement operation on the <code>stackSize</code> variable takes constant time <span class="math inline">\(O(1)\)</span>. Therefore, the total time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use a single integer (<code>stackSize</code>) to keep track of unmatched opening brackets, which means the space complexity is constant. Thus, the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-139">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/most-profit-assigning-work/description" target="_blank" rel="noopener noreferrer">Most Profit Assigning Work</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You have <code>n</code> jobs and <code>m</code> workers. You are given three arrays: <code>difficulty</code>, <code>profit</code>, and <code>worker</code> where:</p>

<ul>
	<li><code>difficulty[i]</code> and <code>profit[i]</code> are the difficulty and the profit of the <code>i<sup>th</sup></code> job, and</li>
	<li><code>worker[j]</code> is the ability of <code>j<sup>th</sup></code> worker (i.e., the <code>j<sup>th</sup></code> worker can only complete a job with difficulty at most <code>worker[j]</code>).</li>
</ul>

<p>Every worker can be assigned <strong>at most one job</strong>, but one job can be <strong>completed multiple times</strong>.</p>

<ul>
	<li>For example, if three workers attempt the same job that pays <code>$1</code>, then the total profit will be <code>$3</code>. If a worker cannot complete any job, their profit is <code>$0</code>.</li>
</ul>

<p>Return the maximum profit we can achieve after assigning the workers to the jobs.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
<strong>Output:</strong> 100
<strong>Explanation:</strong> Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == difficulty.length</code></li>
	<li><code>n == profit.length</code></li>
	<li><code>m == worker.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>4</sup></code></li>
	<li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given some jobs that each have a difficulty level and an amount of profit that can be made from performing the job. We also have some workers.</p>
<p>You can think of these jobs as roles within a company. Each worker can have only one role, and the role must not be too difficult for them. However, just like in the real world, the assigned role can be easier than what the worker is capable of handling. Our goal is to assign roles to workers in a way that maximizes the company's profit.</p>
<p>Constraints on <code>n</code> and <code>m</code> are <code>1 &lt;= n</code> &amp; <code>m &lt;= 10000</code>, respectively. Therefore, we need to consider an approach with linear or log-linear time complexity.</p>
<hr />
<h3 id="approach-1-binary-search-and-greedy-sort-by-job-difficulty">Approach 1: Binary Search and Greedy (Sort by Job Difficulty)</h3>
<h4 id="intuition">Intuition</h4>
<p>When assigning a job to any worker, we disregard any jobs that are too difficult and then select the job with the highest profit. An example is shown below:</p>
<p><img src="../Figures/826/Slide1.PNG" alt="figA" /></p>
<p>If we need to choose the most optimal job for the worker algorithmically, we could use a linear search to find the maximum profit among all jobs. However, this approach would result in a Time Limit Exceeded (TLE) verdict since each job assignment would take <span class="math inline">\(O(n)\)</span> time, where <code>n</code> is the size of the job list.</p>
<p>Another approach is to use a binary search for every worker. We can sort the <code>difficulty</code> array in increasing order to apply binary search and rearrange the <code>profits</code> array in the same order.</p>
<p>For each worker, we will find the index where the difficulty value is just less than or equal to the worker's ability. The worker can perform all jobs up to this index. Consequently, the worker will choose the job with the highest profit up to this index. To do this, we can preprocess the array to store the maximum profit values up to each index.</p>
<p>During the binary search process, we will add the value of the preprocessed maximum profit of the calculated job for each worker. This sum will give us the total profit. Since the profit for each worker is maximized, the total profit will also be maximized.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code> with <code>{0, 0}</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>difficulty</code> in ascending order.</li>
<li>For <code>i</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Update <code>jobProfile[i].profit</code> to be the maximum of its current value and the previous profit value.</li>
</ul>
</li>
<li>Initialize <code>netProfit</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>Set binary search parameters: <code>l = 0</code>, <code>r = n-1</code>, <code>jobProfit = 0</code>.</li>
<li>While <code>l</code> &lt;= <code>r</code>:
<ul>
<li>Calculate <code>mid = (l + r) / 2</code>.</li>
<li>If <code>jobProfile[mid].difficulty</code> &lt;= <code>ability</code>:
<ul>
<li>Update <code>jobProfit</code> to the maximum of <code>jobProfit</code> and <code>jobProfile[mid].profit</code>.</li>
<li>Set <code>l = mid + 1</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Set <code>r = mid - 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add <code>jobProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.<br />
 </li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/kGBK3vMr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays, and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span></p>
<p>The time complexity for sorting the <code>jobProfile</code> array is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<p>While iterating the <code>worker</code> array of size <code>m</code>, we perform a binary search with search space size <code>n</code>. The time complexity is given by <span class="math inline">\(O(m \cdot \log n)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-binary-search-and-greedy-sort-by-profit">Approach 2: Binary Search and Greedy (Sort by profit)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Is it possible to use binary search on the <code>profit</code> array to maximize the profit for a worker?</p>
<p>Suppose we sort the <code>profit</code> array in decreasing order while rearranging the <code>difficulty</code> array to preserve the original ordering of indices. For each worker, we will find the first index where the value of difficulty is less than or equal to the worker's ability. This index will store the maximum profit possible for that worker's ability. To efficiently apply binary search, we can preprocess the array to store the minimum difficulty up to the current index.</p>
<p>Similar to the previous approach, we will return the sum of all individual job profits as the maximum total profit.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code> with <code>{0, 0}</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>profit</code> in descending order.</li>
<li>For <code>i</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Update <code>jobProfile[i].difficulty</code> to be the minimum of its current value and the previous difficulty value.</li>
</ul>
</li>
<li>Initialize <code>netProfit</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>Set binary search parameters: <code>l = 0</code>, <code>r = n-1</code>, <code>jobProfit = 0</code>.</li>
<li>While <code>l</code> &lt;= <code>r</code>:
<ul>
<li>Calculate <code>mid = (l + r) / 2</code>.</li>
<li>If <code>jobProfile[mid].difficulty</code> &lt;= <code>ability</code>:
<ul>
<li>Update <code>jobProfit</code> to the maximum of <code>jobProfit</code> and <code>jobProfile[mid].profit</code>.</li>
<li>Set <code>r = mid - 1</code>.</li>
</ul>
</li>
<li>Else:
<ul>
<li>Set <code>l = mid + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Add <code>jobProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.<br />
 </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/SqTPfTzF/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span></p>
<p>The time complexity for sorting the difficulty array is <span class="math inline">\(O(n \cdot \log n)\)</span>.</p>
<p>While iterating the <code>worker</code> array of size <code>m</code>, we perform a binary search with search space size <code>n</code>. The time complexity for is given by <span class="math inline">\(O(m \cdot \log n)\)</span>.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-greedy-and-two-pointers">Approach 3: Greedy and Two-Pointers</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In the first approach, we sorted the <code>jobProfile</code> array by difficulty values. Now, let's also sort the <code>worker</code> array in increasing order.</p>
<p>Once we've assigned the optimal job to a worker, then all the workers ahead of that worker (in ability) will receive a job with difficulty greater than or equal to the assigned job. Therefore, after assigning a job, we don't need the jobs present before it.</p>
<p>So, we can use two pointers to find the most optimal job while iterating through the sorted job profile and sorted worker arrays.</p>
<p>Start with the first worker and iterate through the list maintaining a maxima of profits until you find the last assignable job with maximum difficulty. The maximum profit up to this index will give us the profit of the first worker.</p>
<p>Since the worker array is sorted, the ability of the next worker will be greater than all previous workers. So, continue iterating the job profile until you find the last assignable job. Repeat the process for all workers and store the total profit as the sum of the maximum profit.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>Initialize an array of pairs <code>jobProfile</code>.</li>
<li>For <code>i</code> from <code>0</code> to <code>n</code> (where <code>n</code> is the size of the <code>difficulty</code> and <code>profit</code> arrays):
<ul>
<li>Append <code>{difficulty[i], profit[i]}</code> to <code>jobProfile</code>.</li>
</ul>
</li>
<li>Sort <code>jobProfile</code> by <code>difficulty</code> in ascending order.</li>
<li>Sort <code>worker</code> in ascending order by their abilities.</li>
<li>Initialize <code>netProfit</code>, <code>maxProfit</code>, and <code>index</code> to <code>0</code>.</li>
<li>For each <code>ability</code> in the <code>worker</code> array:
<ul>
<li>While <code>index</code> is within bounds and the worker's ability is greater than or equal to <code>jobProfile[index].difficulty</code>:
<ul>
<li>Update <code>maxProfit</code> to the maximum of <code>maxProfit</code> and <code>jobProfile[index].profit</code>.</li>
<li>Increment <code>index</code> by <code>1</code>.</li>
</ul>
</li>
<li>Add <code>maxProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.</li>
</ol>
<p>!?!../Documents/826/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/cYrBiVNB/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \cdot \log n + m \cdot \log(m))\)</span></p>
<p>The time taken for sorting the <code>difficulty</code> array is <span class="math inline">\(O(n \cdot \log n)\)</span> and sorting the <code>worker</code> array is <span class="math inline">\(O(m \cdot \log(m))\)</span>.</p>
<p>In the two pointers, while iterating through the <code>worker</code> array we iterate the <code>jobProfile</code> array exactly once. Time complexity is given by <span class="math inline">\(O(n + m)\)</span></p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log n + m \cdot \log(m))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We create an additional <code>jobProfile</code> array of size <span class="math inline">\(2 \cdot n\)</span>. Apart from this, some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>
<ul>
<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has <span class="math inline">\(O(n)\)</span> additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span> for sorting an array.</li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worse-case space complexity of <span class="math inline">\(O( \log n)\)</span>.</li>
</ul>
<p>Therefore, space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-memoization">Approach 4: Memoization</h3>
<h4 id="intuition-3">Intuition</h4>
<p>Given the constraints on the maximum values of the <code>difficulty</code> and <code>ability</code> arrays, we can create an array of this size to store the maximum profit for every possible ability.</p>
<p>We don't need the profit of jobs with a difficulty level higher than what the worker can handle. Therefore, we can create an array sized to the maximum ability to store the results.</p>
<p>Store the profit in this array with the difficulty of each job as the index. If multiple jobs share the same difficulty (same index), store the maximum profit among them.</p>
<p>Now, what if there exists a job with difficulty lower than another job but provides a higher profit? To find the maximum profit at each index, we must determine the highest value occurrence in all indices up to the current index. To do this, we need to store the maxima of all previous profit values in this array while iterating through the abilities.</p>
<p>Therefore, the maximum total profit is given by the sum of values in this array with worker abilities as the indices.</p>
<h4 id="algorithm-3">Algorithm</h4>
<ol>
<li>Initialize <code>maxAbility</code> as the maximum ability in the <code>worker</code> array.</li>
<li>Initialize an array <code>jobs</code> of size <code>maxAbility</code>.</li>
<li>Iterate a variable <code>i</code> from 0 to <code>difficulty.size - 1</code>:
<ul>
<li>If the <code>difficulty</code> at the current index <code>i</code> is less than or equal to the worker's ability:
<ul>
<li>Store the <code>profit</code> at index <code>i</code> at the <code>difficulty[i]</code> index of <code>jobs</code> array. If a value already exists, take the maximum of both values.</li>
</ul>
</li>
</ul>
</li>
<li>Iterate through all values in <code>jobs</code>:
<ul>
<li>Store the maximum of current and previous <code>jobs</code> values in the current <code>jobs</code> index.</li>
</ul>
</li>
<li>Iterate through all abilities in the <code>worker</code> array:
<ul>
<li>Store <code>maxProfit</code> as <code>jobs[ability]</code> where <code>ability</code> denotes the ability of the current worker.</li>
<li>Increment <code>maxProfit</code> to <code>netProfit</code>.</li>
</ul>
</li>
<li>Return <code>netProfit</code>.</li>
</ol>
<p>!?!../Documents/826/slideshow2.json:960,540!?!</p>
<h4 id="implementation-3">Implementation</h4>
<p><a href="https://leetcode.com/playground/PGosiv2m/shared">code</a></p>
<h4 id="complexity-analysis-3">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>difficulty</code> and <code>profit</code> arrays and <code>m</code> be the size of the <code>worker</code> array. Also, let <code>maxAbility</code> be the maximum value in the <code>worker</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n + m + maxAbility)\)</span></p>
<p>In this approach, we iterate through the <code>difficulty</code>, <code>worker</code> and <code>jobs</code> arrays exactly once.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n + m + maxAbility)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(maxAbility)\)</span></p>
<p>We create an additional <code>jobs</code> array of size <span class="math inline">\(maxAbility\)</span>. Apart from this, no additional space is used.</p>
<p>Therefore, space complexity is given by <span class="math inline">\(O(maxAbility)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-140">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/move-pieces-to-obtain-a-string/description" target="_blank" rel="noopener noreferrer">Move Pieces to Obtain a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>start</code> and <code>target</code>, both of length <code>n</code>. Each string consists <strong>only</strong> of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code> where:</p>

<ul>
	<li>The characters <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code> represent pieces, where a piece <code>&#39;L&#39;</code> can move to the <strong>left</strong> only if there is a <strong>blank</strong> space directly to its left, and a piece <code>&#39;R&#39;</code> can move to the <strong>right</strong> only if there is a <strong>blank</strong> space directly to its right.</li>
	<li>The character <code>&#39;_&#39;</code> represents a blank space that can be occupied by <strong>any</strong> of the <code>&#39;L&#39;</code> or <code>&#39;R&#39;</code> pieces.</li>
</ul>

<p>Return <code>true</code> <em>if it is possible to obtain the string</em> <code>target</code><em> by moving the pieces of the string </em><code>start</code><em> <strong>any</strong> number of times</em>. Otherwise, return <code>false</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> start = &quot;_L__R__R_&quot;, target = &quot;L______RR&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to &quot;<strong>L</strong>___R__R_&quot;.
- Move the last piece one step to the right, start becomes equal to &quot;L___R___<strong>R</strong>&quot;.
- Move the second piece three steps to the right, start becomes equal to &quot;L______<strong>R</strong>R&quot;.
Since it is possible to get the string target from start, we return true.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> start = &quot;R_L_&quot;, target = &quot;__LR&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> The &#39;R&#39; piece in the string start can move one step to the right to obtain &quot;_<strong>R</strong>L_&quot;.
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> start = &quot;_R&quot;, target = &quot;R_&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == start.length == target.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>start</code> and <code>target</code> consist of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given two strings, <code>start</code> and <code>target</code>, both of the same length <span class="math inline">\(n\)</span>. These strings consist only of the characters <code>'L'</code>, <code>'R'</code>, and <code>'_'</code>.</p>
<p>Let's look at an example with a <code>start</code> string of <code>&quot;R_L&quot;</code> and a <code>target</code> string of <code>&quot;L_R&quot;</code>. To achieve this transformation, <code>'L'</code> would need to move leftward and <code>'R'</code> would need to move rightward, but neither can &quot;jump over&quot; the other due to the step-by-step movement rules that only allow moves into adjacent blank spaces. This restriction inherently prevents characters from crossing each other, making the transformation impossible. Therefore, we return <code>false</code>.</p>
<hr />
<h3 id="approach-1-brute-force-memory-limit-exceeded">Approach 1: Brute Force (Memory Limit Exceeded)</h3>
<h4 id="intuition">Intuition</h4>
<p>A natural first thought to solve this problem is to explore all possible ways to move the pieces. We generate all possible states of the <code>start</code> string by making valid moves and checking if any of these states match the <code>target</code> string.</p>
<p>To implement this logic, we start by initializing a queue to store the current states (<code>stateQueue</code>) of the <code>start</code> string. To avoid repetitive lookups for the same state, we use a set to keep track of visited states (<code>visitedStates</code>).</p>
<p>Once we have the <code>visitedStates</code> and <code>stateQueue</code> ready, we begin by pushing the initial <code>start</code> string into the queue. For each state, we check if it matches the <code>target</code> string. If it does, we return <code>true</code> because we have found a valid transformation sequence. If the current state does not match the <code>target</code>, we generate new states by moving <code>'L'</code> to the left and <code>'R'</code> to the right, ensuring that each move is valid according to the rules. We then push each new valid state into the queue and mark it as visited. If the queue is exhausted and we haven't found a matching state, we return <code>false</code> because no valid transformation sequence exists.</p>
<p>Due to the worst-case scenario where all possible states (which can be up to <span class="math inline">\(n^2\)</span> unique states) need to be stored in the visited states set, this solution results in a memory limit exceeded error.</p>
<details>
<summary>Explanation of the Total Number of Unique States (Click Here)</summary>
The total number of unique states depends on the number of blank spaces available, as more blank spaces allow for more possible movements. Consider a string of length $n$ with $n-2$ blank spaces, represented as: <code>_…_L_…_R_…_</code>.
<ul>
<li>The character <code>'L'</code> can move to any position <code>i</code> with <span class="math inline">\(0 \leq i < n - 1\)</span>.</li>
<li>For each position of <code>'L'</code>, the character <code>'R'</code> can move to <span class="math inline">\(n - 1 - i\)</span> positions (any position to the right of <code>'L'</code>).</li>
</ul>
<p>This gives the total number of states as:</p>
<p><span class="math display">\[\begin{aligned}
 (n - 1) + (n - 2) + (n - 3) + \ldots + (n - (n - 1)) = O(n^2)
\end{aligned}
\]</span></p>
</details>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize an unordered set <code>visitedStates</code> to track states that have already been visited and avoid cycles.</p>
</li>
<li>
<p>Initialize a queue <code>stateQueue</code> and push the <code>start</code> state into the queue.</p>
</li>
<li>
<p>While <code>stateQueue</code> is not empty:</p>
<ul>
<li>
<p>Extract the front of the queue into <code>currentState</code>.</p>
</li>
<li>
<p>If <code>currentState</code> matches <code>target</code>, return <code>true</code>.</p>
</li>
<li>
<p>For each position in <code>currentState</code> from index <code>1</code> to the end:</p>
<ul>
<li>If <code>currentState[position]</code> is <code>'L'</code> and the position to its left is <code>'_'</code>:
<ul>
<li>Swap <code>'L'</code> with <code>'_'</code> to simulate moving <code>'L'</code> left.</li>
<li>If the new state has not been visited:
<ul>
<li>Push the new state into the queue.</li>
<li>Mark the state as visited by inserting it into <code>visitedStates</code>.</li>
</ul>
</li>
<li>Restore <code>currentState</code> to its original form by swapping back.</li>
</ul>
</li>
<li>If <code>currentState[position - 1]</code> is <code>'R'</code> and the position to its right is <code>'_'</code>:
<ul>
<li>Swap <code>'R'</code> with <code>'_'</code> to simulate moving <code>'R'</code> right.</li>
<li>If the new state has not been visited:
<ul>
<li>Push the new state into the queue.</li>
<li>Mark the state as visited by inserting it into <code>visitedStates</code>.</li>
</ul>
</li>
<li>Restore <code>currentState</code> to its original form by swapping back.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>If the process completes without finding a valid transformation sequence, return <code>false</code>.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6CFw8vyq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>start</code> and <code>target</code> strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The algorithm explores all possible states. In the worst case, each character in the string can be swapped with its adjacent character, leading to <span class="math inline">\(n\)</span> possible swaps per state. Since each state can generate up to <span class="math inline">\(n\)</span> new states, and the algorithm explores all possible states, the time complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>The space complexity is dominated by the space required to store the states in the <code>visitedStates</code> set and the <code>stateQueue</code>. In the worst case, all possible states (which can be up to <span class="math inline">\(n^2\)</span> unique states) need to be stored in the <code>visitedStates</code> set. The <code>stateQueue</code> can also grow to store up to <span class="math inline">\(n\)</span> states at any given time during the traversal.</p>
<p>Therefore, the space complexity is <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-queue">Approach 2: Using Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of generating all possible moves, we can focus on the fundamental rules that govern whether a transformation is possible. The <code>'L'</code> pieces can only move left, and the <code>'R'</code> pieces can only move right. This means that for any valid transformation:</p>
<ol>
<li>The relative order of <code>'L'</code>s and <code>'R'</code>s must remain unchanged since they cannot pass through each other.</li>
<li>An <code>'L'</code> in the <code>start</code> string must be at the same position or to the right of its target position.</li>
<li>An <code>'R'</code> in the <code>start</code> string must be at the same position or to the left of its target position.</li>
</ol>
<p>This observation allows us to drastically simplify our approach. Rather than trying different combinations of moves, we can simply extract the positions of all <code>'L'</code> and <code>'R'</code> pieces from both strings and compare them in order. By storing these positions in queues (one for the <code>start</code> string and one for the <code>target</code> string), we maintain the relative ordering of pieces while ignoring the underscores.</p>
<p>The actual implementation becomes a matter of comparing corresponding pieces from both queues. For each pair of pieces:</p>
<ol>
<li>First, verify they are the same type (both <code>'L'</code> or both <code>'R'</code>).</li>
<li>Then, depending on the piece type, check if their positions satisfy our movement constraints:
<ul>
<li><code>'L'</code> pieces in the <code>start</code> must not be to the left of their target positions.</li>
<li><code>'R'</code> pieces must not be to the right of their target positions.</li>
</ul>
</li>
</ol>
<p>To implement this concept, start by creating two queues to store character-position pairs. Next, populate these queues by iterating through both the <code>start</code> and <code>target</code> strings, recording only the non-underscore characters along with their positions. Once the queues are populated, compare their sizes to ensure they match, as this confirms that both strings contain the same number of pieces. Then, process both queues simultaneously, comparing each pair of front characters to verify that they are of the same type (both <code>'L'</code> or both <code>'R'</code>) and that their positions allow for valid moves according to the rules. Specifically, for <code>'L'</code> pieces, ensure that the start position is not to the left of the target position, and for <code>'R'</code> pieces, ensure that the start position is not to the right of the target position.</p>
<p>This way we transform what would be a quadratic-complexity problem of move generation into a linear-time solution that simply validates position constraints.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize two queues, <code>startQueue</code> and <code>targetQueue</code>, to store the non-underscore characters and their indices from <code>start</code> and <code>target</code>.</p>
</li>
<li>
<p>Traverse the <code>start</code> and <code>target</code> strings:</p>
<ul>
<li>If a character in <code>start</code> is not an underscore (<code>'_'</code>), add it along with its index to <code>startQueue</code>.</li>
<li>If a character in <code>target</code> is not an underscore, add it along with its index to <code>targetQueue</code>.</li>
</ul>
</li>
<li>
<p>Check if the sizes of <code>startQueue</code> and <code>targetQueue</code> are different:</p>
<ul>
<li>If they are, return <code>false</code> because the number of movable pieces must match.</li>
</ul>
</li>
<li>
<p>While <code>startQueue</code> is not empty:</p>
<ul>
<li>Dequeue the front element from both <code>startQueue</code> and <code>targetQueue</code>.</li>
<li>Compare the character and movement rules:
<ul>
<li>If the characters don't match, return <code>false</code>.</li>
<li>If the character is <code>'L'</code> (must only move left), check if its index in <code>start</code> is less than its index in <code>target</code>. If so, return <code>false</code>.</li>
<li>If the character is <code>'R'</code> (must only move right), check if its index in <code>start</code> is greater than its index in <code>target</code>. If so, return <code>false</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>true</code> if all characters and their movement rules are valid, indicating that <code>start</code> can be transformed into <code>target</code>.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/K38qd65e/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>start</code> and <code>target</code> strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through both strings once, which takes <span class="math inline">\(O(n)\)</span> time. Pushing elements into the queues and popping elements from the queues also take <span class="math inline">\(O(n)\)</span> time in total. Therefore, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The space complexity is determined by the space used by the two queues. In the worst case, if all characters in the strings are non-underscore, both queues will store <span class="math inline">\(n\)</span> elements each. Thus, the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointer">Approach 3: Two pointer</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Instead of using additional data structures like queues or generating possible states, we can directly compare both strings by scanning them simultaneously using two pointers. These pointers will help us compare the corresponding <code>'L'</code> and <code>'R'</code> pieces. When we encounter underscores, we can simply skip over them because they don't affect the validity of the transformation.</p>
<p>What really matters is the relative positions of the <code>'L'</code> and <code>'R'</code> pieces and whether they can move to their target positions according to the movement rules. Each time we find an <code>'L'</code> or <code>'R'</code> in both strings (after skipping underscores), we can immediately check if the movement is possible based on their positions:</p>
<ul>
<li><code>'L'</code> pieces can only move left, so their position in the <code>start</code> string must be greater than or equal to their position in the <code>target</code> string.</li>
<li><code>'R'</code> pieces can only move right, so their position in the <code>start</code> string must be less than or equal to their position in the <code>target</code> string.</li>
</ul>
<p>To implement this, we use two pointers, <code>startIndex</code> and <code>targetIndex</code>, to traverse the <code>start</code> and <code>target</code> strings respectively. By making a single pass through the strings, we validate two key aspects:</p>
<ol>
<li>Character Matching: Ensure that the sequence of <code>'L'</code> and <code>'R'</code> pieces is identical in both strings.</li>
<li>Position Constraints: Check that <code>'L'</code> pieces don't need to move right and <code>'R'</code> pieces don't need to move left.</li>
</ol>
<p>By checking these conditions as we go, we can achieve the same validation as a more complex queue-based approach, but with constant space complexity and cleaner code.</p>
<p>The algorithm is visualized below:</p>
<p>!?!../Documents/2337/2337_two_pointer.json:1045,445!?!</p>
<blockquote>
<p>For a more comprehensive understanding of the two-pointer technique, check out the <a href="https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/">Two Pointer Explore Card 🔗</a>. This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.</p>
</blockquote>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>startLength</code> as the length of the <code>start</code> string.</p>
</li>
<li>
<p>Initialize two pointers, <code>startIndex</code> and <code>targetIndex</code>, both set to <code>0</code>, to traverse the <code>start</code> and <code>target</code> strings.</p>
</li>
<li>
<p>While either <code>startIndex</code> or <code>targetIndex</code> is less than <code>startLength</code>:</p>
<ul>
<li>Skip underscores in the <code>start</code> string by incrementing <code>startIndex</code> until a non-underscore character is found or the end of the string is reached.</li>
<li>Skip underscores in the <code>target</code> string by incrementing <code>targetIndex</code> until a non-underscore character is found or the end of the string is reached.</li>
<li>If one string is fully traversed and the other is not, return <code>false</code> as both strings should be exhausted simultaneously.</li>
<li>If the characters at <code>start[startIndex]</code> and <code>target[targetIndex]</code> do not match, return <code>false</code> as the transformations are invalid.</li>
<li>If the character is <code>'L'</code> in <code>start</code>, ensure <code>startIndex &gt;= targetIndex</code> (left pieces can only move left); otherwise, return <code>false</code>.</li>
<li>If the character is <code>'R'</code> in <code>start</code>, ensure <code>startIndex &lt;= targetIndex</code> (right pieces can only move right); otherwise, return <code>false</code>.</li>
</ul>
</li>
<li>
<p>Increment both <code>startIndex</code> and <code>targetIndex</code> to move to the next characters.</p>
</li>
<li>
<p>If the loop ends without returning <code>false</code>,  all conditions for a valid transformation are satisfied; return <code>true</code>.</p>
</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/bZRzw8As/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>start</code> and <code>target</code> strings.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through both strings once, skipping underscores and comparing characters. Each character is processed at most once, resulting in a linear time complexity.</p>
<ul>
<li>The inner <code>while</code> loops that skip underscores run in constant time for each character, so they do not increase the overall time complexity.</li>
<li>The main <code>while</code> loop runs until both indices reach the end of the strings, which takes <span class="math inline">\(O(n)\)</span> time in the worst case.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The space complexity is constant because the algorithm uses a fixed amount of extra space regardless of the input size.</p>
<ul>
<li>The only additional space used is for the indices <code>startIndex</code> and <code>targetIndex</code>, which are single integer variables.</li>
<li>No additional data structures are used that grow with the input size.</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-141">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/move-zeroes/description" target="_blank" rel="noopener noreferrer">Move Zeroes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>

<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [0,1,0,3,12]
<strong>Output:</strong> [1,3,12,0,0]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you minimize the total number of operations done?</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
 <div class='video-preview'></div>
<h2 id="solution">Solution</h2>
<hr />
<p>This question comes under a broad category of &quot;Array Transformation&quot;. This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn't require any boilerplate code and most of your code will look like the Pseudocode itself.</p>
<p>The 2 requirements of the question are:</p>
<ol>
<li>
<p>Move all the 0's to the end of array.</p>
</li>
<li>
<p>All the non-zero elements must retain their original order.</p>
</li>
</ol>
<p>It's good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</p>
<h3 id="approach-1-space-sub-optimal-accepted">Approach #1 (Space Sub-Optimal) [Accepted]</h3>
<p>Traverse the <code>nums</code> list first to count the number of zeroes. Then traverse the <code>nums</code> list again to store all non-zero elements in <code>ans</code>.</p>
<h4 id="algorithm">Algorithm:</h4>
<ul>
<li>
<p>Determine the size of the <code>nums</code> array and store it in <code>n</code>.</p>
</li>
<li>
<p>Count the number of zeroes in <code>nums</code>:</p>
<ul>
<li>Initialize <code>numZeroes</code> to 0.</li>
<li>Iterate through each element in <code>nums</code>:
<ul>
<li>Increment <code>numZeroes</code> for each zero encountered.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Create a new vector <code>ans</code> to store non-zero elements in their original order:</p>
<ul>
<li>Iterate through each element in <code>nums</code>:
<ul>
<li>Add non-zero elements to <code>ans</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Append all zeroes to the end of the <code>ans</code> vector:</p>
<ul>
<li>Append <code>numZeroes</code> zeroes to <code>ans</code>.</li>
</ul>
</li>
<li>
<p>Update the original <code>nums</code> array with the elements from <code>ans</code>:</p>
<ul>
<li>Copy each element from <code>ans</code> back to <code>nums</code>.</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/ZftizFjx/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Space Complexity : <span class="math inline">\(O(n)\)</span>. Since we are creating the &quot;ans&quot; array to store results.</p>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>. We traverse the nums list first to count the number of zeroes using <span class="math inline">\(O(n)\)</span> time. Then, we traverse the nums list again to store all non-zero elements in ans which also costs <span class="math inline">\(O(n)\)</span> time. Hence, the overall time complexity is <span class="math inline">\(O(2n)\)</span>, which is simplified to <span class="math inline">\(O(n)\)</span>. However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.</p>
<p>If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.</p>
<hr />
<h3 id="approach-2-space-optimal-operation-sub-optimal-accepted">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</h3>
<p>This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, &quot; Bring all the non 0 elements to the front of array keeping their relative order same&quot;.</p>
<p>This is a 2 pointer approach. The fast pointer(<code>nums[i]</code>) does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer <code>lastNonZeroFoundAt</code> variable. As we keep finding new non-0 elements, we just overwrite them at the <code>lastNonZeroFoundAt + 1</code> 'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it's corresponding index,or if it were 0 it will be handled later in time).</p>
<p>After the <code>nums[i]</code> reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, &quot;Move all 0's to the end&quot;. We now simply need to fill all the indexes after the <code>lastNonZeroFoundAt</code> index with 0.</p>
<h4 id="algorithm-1">Algorithm:</h4>
<ul>
<li>
<p>Initialize <code>lastNonZeroFoundAt</code> to 0:</p>
<ul>
<li>This variable tracks the position where the next non-zero element should be placed.</li>
</ul>
</li>
<li>
<p>Iterate through each element in <code>nums</code>:</p>
<ul>
<li>If the current element <code>nums[i]</code> is not zero:
<ul>
<li>Place <code>nums[i]</code> at index <code>lastNonZeroFoundAt</code>.</li>
<li>Increment <code>lastNonZeroFoundAt</code> to move to the next position for future non-zero elements.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>After processing all elements:</p>
<ul>
<li>Fill the remaining positions in the array (from <code>lastNonZeroFoundAt</code> to the end) with zeros.</li>
</ul>
</li>
<li>
<p>This ensures that all non-zero elements are moved to the beginning of the array and all zeros are placed at the end.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/Vbpqu24K/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Space Complexity : <span class="math inline">\(O(1)\)</span>. Only constant space is used.</p>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>. We traverse the nums list first to move all non-zero elements to the beginning of array which costs <span class="math inline">\(O(n)\)</span> time. At the worst case when the original array only consists of 0s, we will use <span class="math inline">\(O(n)\)</span> time to fill all remaining elements with 0s. Hence, the overall time complexity is <span class="math inline">\(O(2n)\)</span>, which is simplified to <span class="math inline">\(O(n)\)</span>. However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is <span class="math inline">\(n\)</span> (Total number of elements).</p>
<hr />
<h3 id="approach-3-optimal-accepted">Approach #3 (Optimal) [Accepted]</h3>
<p>The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0's <span class="math inline">\(n-1\)</span> times, which is not necessary. We could have instead written just once. How?<br />
.....<br />
By only fixing the non-0 element,i.e., 1.</p>
<p>The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its' correct position can at best be it's current position or a position earlier. If it's the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than 'cur' index. We fill the current position by 0 right away,so that unlike the previous solution, we don't need to come back here in next iteration.</p>
<p>In other words, the code will maintain the following invariant:</p>
<blockquote>
<ol>
<li>
<p>All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.</p>
</li>
<li>
<p>All elements between the current and slow pointer are zeroes.</p>
</li>
</ol>
</blockquote>
<p>Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it's zero element, we just advance current pointer.</p>
<p>With this invariant in-place, it's easy to see that the algorithm will work.</p>
<h4 id="algorithm-2">Algorithm:</h4>
<ul>
<li>
<p>Initialize <code>lastNonZeroFoundAt</code> to 0 to track the position of the last non-zero element.</p>
</li>
<li>
<p>Iterate through each element in <code>nums</code> using <code>cur</code> as the index:</p>
<ul>
<li>If <code>nums[cur]</code> is not zero:
<ul>
<li>Swap <code>nums[lastNonZeroFoundAt]</code> with <code>nums[cur]</code> to move the non-zero element to the correct position.</li>
<li>Increment <code>lastNonZeroFoundAt</code> to update the position for the next non-zero element.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Continue iterating until all elements are processed, ensuring all non-zero elements are moved to the front of the array and zeros are pushed to the end.</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/4YFvmDiq/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Space Complexity : <span class="math inline">\(O(1)\)</span>. Only constant space is used.</p>
<p>Time Complexity: <span class="math inline">\(O(n)\)</span>. However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.</p>
<p>Analysis written by: @spandan.pathak</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-142">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-greater-element-iii/description" target="_blank" rel="noopener noreferrer">Next Greater Element III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">math</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a positive integer <code>n</code>, find <em>the smallest integer which has exactly the same digits existing in the integer</em> <code>n</code> <em>and is greater in value than</em> <code>n</code>. If no such positive integer exists, return <code>-1</code>.</p>

<p><strong>Note</strong> that the returned integer should fit in <strong>32-bit integer</strong>, if there is a valid answer but it does not fit in <strong>32-bit integer</strong>, return <code>-1</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> n = 12
<strong>Output:</strong> 21
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> n = 21
<strong>Output:</strong> -1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-143">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/next-permutation/description" target="_blank" rel="noopener noreferrer">Next Permutation</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>

<ul>
	<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>
</ul>

<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>

<ul>
	<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>
	<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>
	<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>
</ul>

<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>

<p>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in place</a></strong> and use only constant extra memory.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [1,3,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> [1,2,3]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,5]
<strong>Output:</strong> [1,5,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="video-solution">Video Solution</h2>
<hr />
<div class='video-preview'></div>
<div>&nbsp;
</div>
<h2 id="solution-article">Solution Article</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p><strong>Algorithm</strong></p>
<p>In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is<br />
just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation<br />
which will take really long time and the implementation is complex.<br />
Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.</p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <span class="math inline">\(O(n!)\)</span>. Total possible permutations is <span class="math inline">\(n!\)</span>.</li>
<li>Space complexity : <span class="math inline">\(O(n)\)</span>. Since an array will be used to store the permutations.<br />
<br /><br />
<br /></li>
</ul>
<hr />
<h3 id="approach-2-single-pass-approach">Approach 2: Single Pass Approach</h3>
<p><strong>Algorithm</strong></p>
<p>First, we observe that for any given sequence that is in descending order, no next larger permutation is possible.<br />
For example, no next permutation is possible for the following array:</p>
<pre><code>[9, 5, 4, 3, 1]
</code></pre>
<p>We need to find the first pair of two successive numbers <span class="math inline">\(a[i]\)</span> and <span class="math inline">\(a[i-1]\)</span>, from the right, which satisfy</p>
<p><span class="math display">\[Thus, we need to rearrange the numbers to the right of $$a[i-1]$$ including itself.

Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number $$a[i-1]$$ with the number which is just larger than itself among the numbers lying to its right section, say $$a[j]$$.

![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)

We swap the numbers $$a[i-1]$$ and $$a[j]$$. We now have the correct number at index $$i-1$$. But still the current permutation isn't the permutation
   that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of $$a[i-1]$$. Therefore, we need to place those
    numbers in ascending order to get their smallest permutation.

But, recall that while scanning the numbers from the right, we simply kept decrementing the index
     until we found the pair $$a[i]$$ and $$a[i-1]$$ where,  $$a[i] > a[i-1]$$. Thus, all numbers to the right of $$a[i-1]$$ were already sorted in descending order.
     Furthermore, swapping $$a[i-1]$$ and $$a[j]$$ didn't change that order.
     Therefore, we simply need to reverse the numbers following $$a[i-1]$$ to get the next smallest lexicographic permutation.

The following animation will make things clearer:

![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)

[code](https://leetcode.com/playground/Dm6PeACq/shared)

**Complexity Analysis**

Let $n$ be the size of the `nums` array.

- Time complexity: $O(n)$

  The first `while` loop runs at most $n$ iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes $O(n)$ time.
   
  The second `while` loop also runs at most $n$ iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take $O(n)$ time.
   
  The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of $O(n)$.
   
  The `swap` function runs in constant time, $O(1)$, since it only exchanges two elements.
   
   Therefore, the overall time complexity is $O(n)$.

- Space complexity: $O(1)$

  The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data.
   
  Only a few constant space variables (`i`, `j`, and `temp`) are used.
   
  The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array.

   Hence, the space complexity is $O(1)$.\]</span></p>
</div>
				</div>
		</div>

<div class="question-card" id="question-144">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-arithmetic-triplets/description" target="_blank" rel="noopener noreferrer">Number of Arithmetic Triplets</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong>, <strong>strictly increasing</strong> integer array <code>nums</code> and a positive integer <code>diff</code>. A triplet <code>(i, j, k)</code> is an <strong>arithmetic triplet</strong> if the following conditions are met:</p>

<ul>
	<li><code>i &lt; j &lt; k</code>,</li>
	<li><code>nums[j] - nums[i] == diff</code>, and</li>
	<li><code>nums[k] - nums[j] == diff</code>.</li>
</ul>

<p>Return <em>the number of unique <strong>arithmetic triplets</strong>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,4,6,7,10], diff = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong>
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,5,6,7,8,9], diff = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong>
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 200</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 200</code></li>
	<li><code>1 &lt;= diff &lt;= 50</code></li>
	<li><code>nums</code> is <strong>strictly</strong> increasing.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-145">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-distinct-averages/description" target="_blank" rel="noopener noreferrer">Number of Distinct Averages</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of <strong>even</strong> length.</p>

<p>As long as <code>nums</code> is <strong>not</strong> empty, you must repetitively:</p>

<ul>
	<li>Find the minimum number in <code>nums</code> and remove it.</li>
	<li>Find the maximum number in <code>nums</code> and remove it.</li>
	<li>Calculate the average of the two removed numbers.</li>
</ul>

<p>The <strong>average</strong> of two numbers <code>a</code> and <code>b</code> is <code>(a + b) / 2</code>.</p>

<ul>
	<li>For example, the average of <code>2</code> and <code>3</code> is <code>(2 + 3) / 2 = 2.5</code>.</li>
</ul>

<p>Return<em> the number of <strong>distinct</strong> averages calculated using the above process</em>.</p>

<p><strong>Note</strong> that when there is a tie for a minimum or maximum number, any can be removed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,1,4,0,3,5]
<strong>Output:</strong> 2
<strong>Explanation:</strong>
1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].
2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].
3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,100]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
There is only one average to be calculated after removing 1 and 100, so we return 1.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 100</code></li>
	<li><code>nums.length</code> is even.</li>
	<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-146">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subarrays-with-bounded-maximum/description" target="_blank" rel="noopener noreferrer">Number of Subarrays with Bounded Maximum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and two integers <code>left</code> and <code>right</code>, return <em>the number of contiguous non-empty <strong>subarrays</strong> such that the value of the maximum array element in that subarray is in the range </em><code>[left, right]</code>.</p>

<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,1,4,3], left = 2, right = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three subarrays that meet the requirements: [2], [2, 1], [3].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,9,2,5,6], left = 2, right = 8
<strong>Output:</strong> 7
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>0 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-147">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description" target="_blank" rel="noopener noreferrer">Number of Subsequences That Satisfy the Given Sum Condition</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an array of integers <code>nums</code> and an integer <code>target</code>.</p>

<p>Return <em>the number of <strong>non-empty</strong> subsequences of </em><code>nums</code><em> such that the sum of the minimum and maximum element on it is less or equal to </em><code>target</code>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,5,6,7], target = 9
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 subsequences that satisfy the condition.
[3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9)
[3,5] -&gt; (3 + 5 &lt;= 9)
[3,5,6] -&gt; (3 + 6 &lt;= 9)
[3,6] -&gt; (3 + 6 &lt;= 9)
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,3,6,8], target = 10
<strong>Output:</strong> 6
<strong>Explanation:</strong> There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3,3,4,6,7], target = 12
<strong>Output:</strong> 61
<strong>Explanation:</strong> There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>1 &lt;= target &lt;= 10<sup>6</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-148">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/description" target="_blank" rel="noopener noreferrer">Number of Ways Where Square of Number Is Equal to Product of Two Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two arrays of integers <code>nums1</code> and <code>nums2</code>, return the number of triplets formed (type 1 and type 2) under the following rules:</p>

<ul>
	<li>Type 1: Triplet (i, j, k) if <code>nums1[i]<sup>2</sup> == nums2[j] * nums2[k]</code> where <code>0 &lt;= i &lt; nums1.length</code> and <code>0 &lt;= j &lt; k &lt; nums2.length</code>.</li>
	<li>Type 2: Triplet (i, j, k) if <code>nums2[i]<sup>2</sup> == nums1[j] * nums1[k]</code> where <code>0 &lt;= i &lt; nums2.length</code> and <code>0 &lt;= j &lt; k &lt; nums1.length</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [7,4], nums2 = [5,2,8,9]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Type 1: (1, 1, 2), nums1[1]<sup>2</sup> = nums2[1] * nums2[2]. (4<sup>2</sup> = 2 * 8). 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [1,1], nums2 = [1,1,1]
<strong>Output:</strong> 9
<strong>Explanation:</strong> All Triplets are valid, because 1<sup>2</sup> = 1 * 1.
Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]<sup>2</sup> = nums2[j] * nums2[k].
Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]<sup>2</sup> = nums1[j] * nums1[k].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums1 = [7,7,8,3], nums2 = [1,2,9,7]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are 2 valid triplets.
Type 1: (3,0,2).  nums1[3]<sup>2</sup> = nums2[0] * nums2[2].
Type 2: (3,0,1).  nums2[3]<sup>2</sup> = nums1[0] * nums1[1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-149">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindrome-linked-list/description" target="_blank" rel="noopener noreferrer">Palindrome Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword="palindrome-sequence"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" style="width: 422px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2,2,1]
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" style="width: 182px; height: 62px;" />
<pre>
<strong>Input:</strong> head = [1,2]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>
	<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-150">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/palindromic-substrings/description" target="_blank" rel="noopener noreferrer">Palindromic Substrings</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p>

<p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p>

<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abc&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaa&quot;
<strong>Output:</strong> 6
<strong>Explanation:</strong> Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-151">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/pancake-sorting/description" target="_blank" rel="noopener noreferrer">Pancake Sorting</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code>, sort the array by performing a series of <strong>pancake flips</strong>.</p>

<p>In one pancake flip we do the following steps:</p>

<ul>
	<li>Choose an integer <code>k</code> where <code>1 &lt;= k &lt;= arr.length</code>.</li>
	<li>Reverse the sub-array <code>arr[0...k-1]</code> (<strong>0-indexed</strong>).</li>
</ul>

<p>For example, if <code>arr = [3,2,1,4]</code> and we performed a pancake flip choosing <code>k = 3</code>, we reverse the sub-array <code>[3,2,1]</code>, so <code>arr = [<u>1</u>,<u>2</u>,<u>3</u>,4]</code> after the pancake flip at <code>k = 3</code>.</p>

<p>Return <em>an array of the </em><code>k</code><em>-values corresponding to a sequence of pancake flips that sort </em><code>arr</code>. Any valid answer that sorts the array within <code>10 * arr.length</code> flips will be judged as correct.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [3,2,4,1]
<strong>Output:</strong> [4,2,4,3]
<strong>Explanation: </strong>
We perform 4 pancake flips, with k values 4, 2, 4, and 3.
Starting state: arr = [3, 2, 4, 1]
After 1st flip (k = 4): arr = [<u>1</u>, <u>4</u>, <u>2</u>, <u>3</u>]
After 2nd flip (k = 2): arr = [<u>4</u>, <u>1</u>, 2, 3]
After 3rd flip (k = 4): arr = [<u>3</u>, <u>2</u>, <u>1</u>, <u>4</u>]
After 4th flip (k = 3): arr = [<u>1</u>, <u>2</u>, <u>3</u>, 4], which is sorted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> []
<strong>Explanation: </strong>The input is already sorted, so there is no need to flip anything.
Note that other answers, such as [3, 3], would also be accepted.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 100</code></li>
	<li><code>1 &lt;= arr[i] &lt;= arr.length</code></li>
	<li>All integers in <code>arr</code> are unique (i.e. <code>arr</code> is a permutation of the integers from <code>1</code> to <code>arr.length</code>).</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-sort-like-bubble-sort">Approach 1: Sort like Bubble-Sort</h3>
<p><strong>Intuition</strong></p>
<p>One might argue that this is an awkward question to do things.<br />
Indeed, it is not the most practical operation that one can have with the <em>pancake flipping</em>, in order to sort a list.</p>
<p>However awkward the problem might be, it is the game that we play with. And in order to win the game, we have to play by the rules.<br />
Actually, from this perspective, this problem does share some similarity with the <strong><em><a href="https://en.wikipedia.org/wiki/Rubik%27s_Cube">Rubik's cube</a></em></strong>, <em>i.e.</em> one cannot move one tile without moving other tiles along with.<br />
Let us get on with it, by playing a few rounds ourselves to get the hang of the problem.</p>
<p>Given the input of <code>[3, 2, 4, 1]</code>, the desired sorted output would be <code>[1, 2, 3, 4]</code>.</p>
<p>As a reminder, the only operation that we could perform in order to move the elements in the list, is the so-called <em>pancake flip</em>, which is to reverse a <em>prefix</em> of the list.</p>
<p>Starting from the largest value in the list, <em>i.e.</em> <code>4</code> in the example, its desired position would be the tail of the list.<br />
While in the input, it is located at the third of the list, if we look at the list from left to right.</p>
<p>In order to move the value of <code>4</code> to its desired position, we could perform the following two steps:</p>
<ul>
<li>Firstly, we do the pancake flip on the prefix of <code>[3, 2, 4]</code>. With this operation, we then move the value <code>4</code> to the <em><strong>head</strong></em> of the updated list as <code>[4, 2, 3, 1]</code>.</li>
</ul>
<p><img src="../Figures/969/969_flip_head.png" alt="flip to head" /></p>
<ul>
<li>Now that, the value <code>4</code> is located at the head of the list, we could now perform another pancake flip on the entire list, which would get us the list of <code>[1, 3, 2, 4]</code>.</li>
</ul>
<p><img src="../Figures/969/969_flip_tail.png" alt="flip to tail" /></p>
<p>Voila. With the obtained list of <code>[1, 3, 2, 4]</code>, we are now one step closer to our final goal, with the value <code>4</code> now at its proper place.<br />
For the following steps, we only need to focus on the sublist of <code>[1, 3, 2]</code>.</p>
<blockquote>
<p>If one looks over the above steps again, it might ring a bell to a well-known algorithm called <em><strong><a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a></strong></em>.</p>
</blockquote>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif">
</p>
<p>Indeed, we share the same strategy as the bubble sort, by <em>sinking</em> the numbers to the bottom one by one.</p>
<blockquote>
<p>Here we can make a statement that for any given number, in order to move it to any desired position, it takes <strong><em>at most</em></strong> two pancake flips to do so.</p>
</blockquote>
<p>The idea is simple. First we move the number to the head of the list, then we can switch it with any other element by performing another pancake flip.</p>
<p><strong>Algorithm</strong></p>
<p>One can inspire from the bubble sort to implement the algorithm.</p>
<ul>
<li>
<p>First of all, we implement a function called <code>flip(list, k)</code>, which performs the pancake flip on the prefix of <code>list[0:k]</code> (in Python).</p>
</li>
<li>
<p>The main algorithm runs a loop over the values of the list, starting from the largest one.</p>
<ul>
<li>
<p>At each round, we identify the value to sort (named as <code>value_to_sort</code>), which is the number we would put in place at this round.</p>
</li>
<li>
<p>We then locate the index of the <code>value_to_sort</code>.</p>
</li>
<li>
<p>If the <code>value_to_sort</code> is not at its place already, we can then perform <em>at most</em> two pancake flips as we explained in the intuition.</p>
</li>
<li>
<p>At the end of the round, the <code>value_to_sort</code> would be put in place.</p>
</li>
</ul>
</li>
</ul>
<p><a href="https://leetcode.com/playground/74miTuW6/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the length of the input list.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N^2)\)</span></p>
<ul>
<li>
<p>In the algorithm, we run a loop with <span class="math inline">\(N\)</span> iterations.</p>
</li>
<li>
<p>Within each iteration, we are dealing with the corresponding prefix of the list.<br />
Here we denote the length of the prefix as <span class="math inline">\(k\)</span>, <em>e.g.</em> in the first iteration, the length of the prefix is <span class="math inline">\(N\)</span>. While in the second iteration, the length of the prefix is <span class="math inline">\(N-1\)</span>.</p>
</li>
<li>
<p>Within each iteration, we have operations whose time complexity is linear to the length of the prefix, such as iterating through the prefix to find the index, or flipping the entire prefix <em>etc.</em> Hence, for each iteration, its time complexity would be <span class="math inline">\(\mathcal{O}(k)\)</span></p>
</li>
<li>
<p>To sum up all iterations, we have the overall time complexity of the algorithm as <span class="math inline">\(\sum_{k=1}^{N} \mathcal{O}(k) = \mathcal{O}(N^2)\)</span>.</p>
</li>
</ul>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span></p>
<ul>
<li>
<p>Within the algorithm, we use a list to maintain the final results, which is proportional to the number of pancake flips.</p>
</li>
<li>
<p>For each round of iteration, at most we would add two pancake flips. Therefore, the maximal number of pancake flips needed would be <span class="math inline">\(2\cdot N\)</span>.</p>
</li>
<li>
<p>As a result, the space complexity of the algorithm is <span class="math inline">\(\mathcal{O}(N)\)</span>. If one does not take into account the space required to hold the result of the function, then one could consider the above algorithm as a constant space solution.</p>
</li>
</ul>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-152">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-array-according-to-given-pivot/description" target="_blank" rel="noopener noreferrer">Partition Array According to Given Pivot</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>pivot</code>. Rearrange <code>nums</code> such that the following conditions are satisfied:</p>

<ul>
	<li>Every element less than <code>pivot</code> appears <strong>before</strong> every element greater than <code>pivot</code>.</li>
	<li>Every element equal to <code>pivot</code> appears <strong>in between</strong> the elements less than and greater than <code>pivot</code>.</li>
	<li>The <strong>relative order</strong> of the elements less than <code>pivot</code> and the elements greater than <code>pivot</code> is maintained.
	<ul>
		<li>More formally, consider every <code>p<sub>i</sub></code>, <code>p<sub>j</sub></code> where <code>p<sub>i</sub></code> is the new position of the <code>i<sup>th</sup></code> element and <code>p<sub>j</sub></code> is the new position of the <code>j<sup>th</sup></code> element. If <code>i &lt; j</code> and <strong>both</strong> elements are smaller (<em>or larger</em>) than <code>pivot</code>, then <code>p<sub>i</sub> &lt; p<sub>j</sub></code>.</li>
	</ul>
	</li>
</ul>

<p>Return <code>nums</code><em> after the rearrangement.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [9,12,5,10,14,3,10], pivot = 10
<strong>Output:</strong> [9,5,3,10,10,12,14]
<strong>Explanation:</strong> 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-3,4,3,2], pivot = 2
<strong>Output:</strong> [-3,2,4,3]
<strong>Explanation:</strong> 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>pivot</code> equals to an element of <code>nums</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an array <code>nums</code> and a value <code>pivot</code>. Our goal is to rearrange <code>nums</code> such that all elements <strong>less than</strong> <code>pivot</code> appear first, followed by all elements <strong>equal to</strong> <code>pivot</code>, and finally, all elements <strong>greater than</strong> <code>pivot</code>. Additionally, the <strong>relative order</strong> of elements within each group must be preserved.</p>
<blockquote>
<p>Note: The relative order of elements means that if one element appears before another in the original array, it must still appear before that element in the rearranged array as long as they belong to the same group (less than, equal to, or greater than <code>pivot</code>).</p>
</blockquote>
<p>For example, consider <code>nums = [9,12,5,10,14,3,10]</code> with <code>pivot = 10</code>. The correct rearrangement is <code>[9,5,3,10,10,12,14]</code>:</p>
<ul>
<li>The numbers <code>9, 5, 3</code> (which are less than <code>pivot</code>) appear first, maintaining their original order.</li>
<li>The numbers <code>10, 10</code> (which are equal to <code>pivot</code>) appear next.</li>
<li>The numbers <code>12, 14</code> (which are greater than <code>pivot</code>) appear last, also maintaining their original order.</li>
</ul>
<p>A common mistake in solving this problem is not preserving the relative order of elements. It’s tempting to use quicksort style partitioning, but that approach disrupts the relative order. Instead, for the initial phase, we should try to build the output array step by step, placing elements into separate lists based on their comparison with <code>pivot</code>, and then combining these lists at the end.</p>
<h3 id="approach-1-dynamic-lists">Approach 1: Dynamic Lists</h3>
<h4 id="intuition">Intuition</h4>
<p>When we rearrange <code>nums</code>, we know that it is composed of three sections, from left to right:</p>
<ol>
<li>The elements less than <code>pivot</code>.</li>
<li>The elements equal to <code>pivot</code>.</li>
<li>The elements greater than <code>pivot</code>.</li>
</ol>
<p>Thus, one approach is to use dynamic lists to build each of the three sections. To do this, we can iterate through <code>nums</code>, left to right, and append each element into its corresponding dynamic list based on its comparison with <code>pivot</code>. This way, as we process each element, their relative position is maintained within their list. After iterating, we can stitch together the three lists to obtain the final rearranged result.</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Declare three dynamic lists <code>less</code>, <code>equal</code>, and <code>greater</code> for all elements less than, equal to, and greater than <code>pivot</code>, respectively.</li>
<li>Iterate through each element <code>num</code> in <code>nums</code>:
<ul>
<li>If <code>num &lt; pivot</code>: append <code>num</code> to <code>less</code>.</li>
<li>If <code>num &gt; pivot</code>: append <code>num</code> to <code>greater</code>.</li>
<li>Else: append <code>num</code> to <code>equal</code>.</li>
</ul>
</li>
<li>Stitch together the dynamic lists:
<ul>
<li>Append all elements of <code>equal</code> to <code>less</code>.</li>
<li>Append all elements of <code>greater</code>.</li>
</ul>
</li>
<li>Return the resulting list.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/CDSppTfJ/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>Appending to a dynamic list is an <span class="math inline">\(O(1)\)</span> operation for each element, so building the three lists (<code>less</code>, <code>equal</code>, and <code>greater</code>) takes a total of <span class="math inline">\(O(N)\)</span> time, where <span class="math inline">\(N\)</span> is the number of elements in <code>nums</code>. The <code>extend()</code> operations also take <span class="math inline">\(O(N)\)</span> time since you're adding all elements from <code>equal</code> and <code>greater</code> into <code>less</code>. Thus, the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>Although the answer container (<code>less</code>) is returned and doesn't contribute to space complexity (as it is considered part of the output), the two temporary lists (<code>equal</code> and <code>greater</code>) can require additional <span class="math inline">\(O(N)\)</span> space to hold elements temporarily. Thus, the auxiliary space complexity is <span class="math inline">\(O(N)\)</span>. If only one list were used for temporary storage and returned as the result, it would be considered <span class="math inline">\(O(1)\)</span> space since no additional space would be required for other containers.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-passes-with-fixed-array">Approach 2: Two Passes With Fixed Array</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In Approach 1, we used dynamic lists to build the three sections of the array because we did not know initially how many elements belong in each section. The flexibility of dynamic lists allowed us to append elements and grow our list as needed, but there is extra space/time overhead with dynamically sized lists.</p>
<p>For this approach, we will rearrange <code>nums</code> using only a single fixed-size array instead. The challenge is knowing how to place each element of <code>nums</code> in the correct index of our array without overwriting/overlapping elements from other sections. To solve this, we first need to determine the specific indices our second and third sections start at (we know that our first section will always start at index <code>0</code>).</p>
<p>To do this, we can perform an initial pass through <code>nums</code> to keep count of the number of elements that are in the first and second sections. We can call these counts <code>numLess</code> (number of elements less than <code>pivot</code>) and <code>numEqual</code> (number of elements equal to <code>pivot</code>). Using these 2 counters, we can initialize 3 pointers for each section to help us properly find the correct indices to insert our elements:</p>
<ul>
<li>The first section will always start at index <code>0</code>, so its pointer will be initialized to <code>0</code>.</li>
<li>The second section follows right after, so its index starts at <code>numLess</code>.</li>
<li>The third section comes next, so its index would be initialized to the total number of elements from the earlier 2 sections -  <code>numLess + numEqual</code>.</li>
</ul>
<p>With these pointers set, we can do a second pass through <code>nums</code> and correctly place its elements in our fixed-sized array <code>ans</code> using these pointers. For each element we process, we determine which section it belongs in and use its corresponding pointer to place it in the correct index in <code>ans</code>. After placing it, we can increment the corresponding pointer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>numLess</code> and <code>numEqual</code> to 0.</li>
<li>Iterate through <code>nums</code>. For each <code>num</code> in <code>nums</code>:
<ul>
<li>If <code>num &lt; pivot</code>, increment <code>numLess</code>.</li>
<li>If <code>num == pivot</code>, increment <code>numEqual</code>.</li>
</ul>
</li>
<li>Initialize a fixed-sized array <code>ans</code> to contain our rearranged array.</li>
<li>Calculate our 3 pointers:
<ul>
<li><code>lessI = 0</code> since the first section starts at index <code>0</code></li>
<li><code>equalI = numLess</code> since the second section starts at index <code>numLess</code>.</li>
<li><code>greaterI = numLess + numEqual</code> since the third section starts at index <code>numLess + numEqual</code></li>
</ul>
</li>
<li>For each <code>num</code> in <code>nums</code>:
<ul>
<li>If <code>num &lt; pivot</code>: <code>ans[lessI] = num</code> and increment <code>lessI</code>.</li>
<li>If <code>num == pivot</code>: <code>ans[equalI] = num</code> and increment <code>equalI</code>.</li>
<li>If <code>num &gt; pivot</code>: <code>ans[greaterI] = num</code> and increment <code>greaterI</code>.</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/S9kEhGzX/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We perform two passes of <code>nums</code>, each with constant time operations. so the total time complexity is <span class="math inline">\(O(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The algorithm uses an additional array <code>ans</code> of the same size as <code>nums</code>, which requires <span class="math inline">\(O(N)\)</span> extra space. Other auxiliary variables, such as <code>lessI</code> and <code>greaterI</code>, require only <span class="math inline">\(O(1)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(N)\)</span> due to the extra array used to store the result. However, if we consider only the auxiliary space complexity, it would be <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-two-pointer">Approach 3: Two Pointer</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The idea of this approach is to maintain two pointers, <code>lessI</code> and <code>greaterI</code>, which track the positions where the next smaller and larger elements should be placed, respectively. As we iterate through the array from both ends (using <code>i</code> for the left-to-right pass and <code>j</code> for the right-to-left pass), we compare each element to the pivot. If an element is smaller than the pivot, it is placed at the <code>lessI</code> position, and <code>lessI</code> is incremented. Similarly, if an element is greater than the pivot, it is placed at the <code>greaterI</code> position, and <code>greaterI</code> is decremented. This ensures that smaller elements are placed at the beginning of the array and larger elements at the end.</p>
<p>After the initial pass, all elements smaller than the pivot are at the beginning of the array, and all elements larger than the pivot are at the end. The remaining positions between <code>lessI</code> and <code>greaterI</code> are filled with the pivot value, ensuring that elements equal to the pivot are placed in the middle.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize a fixed-sized array <code>ans</code> to contain our rearranged array.</li>
<li>Initialize pointer for first section <code>lessI = 0</code> going left to right.</li>
<li>Initialize pointer for third section <code>greaterI = nums.length - 1</code> going right to left.</li>
<li>Start a forward and backward iteration of <code>nums</code>. For forward, we initialize <code>i = 0</code>. For backward, we initialize <code>j = nums.length - 1</code>. For each iteration:
<ul>
<li>If <code>nums[i] &lt; pivot</code>, then write in first section: <code>ans[lessI] = nums[i]</code> and increment <code>lessI</code>.</li>
<li>If <code>nums[j] &gt; pivot</code>, then write in third section: <code>ans[greaterI] = nums[j]</code> and decrement <code>greaterI</code>.</li>
<li>Increment <code>i</code> and decrement <code>j</code>.</li>
</ul>
</li>
<li>Fill in the remaining spots of <code>ans</code> with pivot:
<ul>
<li>While <code>lessI &lt;= greaterI</code>:
<ul>
<li><code>ans[lessI] = pivot</code></li>
<li><code>lessI++</code></li>
</ul>
</li>
</ul>
</li>
<li>Return <code>ans</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/FPYQhHNF/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(N\)</span> be the size of <code>nums</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>We perform a simultaneous forward and backwards iteration of <code>nums</code>, taking a total of <span class="math inline">\(O(N)\)</span> time.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The algorithm uses an additional array <code>ans</code> of the same size as <code>nums</code>, which requires <span class="math inline">\(O(N)\)</span> extra space. Other auxiliary variables, such as <code>lessI</code> and <code>greaterI</code>, require only <span class="math inline">\(O(1)\)</span> space. Therefore, the overall space complexity is <span class="math inline">\(O(N)\)</span> due to the extra array used to store the result. However, if we consider only the auxiliary space complexity, it would be <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-153">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description" target="_blank" rel="noopener noreferrer">Partition Array Into Two Arrays to Minimize Sum Difference</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">bitmask</span> <span class="topic-badge">ordered set</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an integer array <code>nums</code> of <code>2 * n</code> integers. You need to partition <code>nums</code> into <strong>two</strong> arrays of length <code>n</code> to <strong>minimize the absolute difference</strong> of the <strong>sums</strong> of the arrays. To partition <code>nums</code>, put each element of <code>nums</code> into <strong>one</strong> of the two arrays.</p>

<p>Return <em>the <strong>minimum</strong> possible absolute difference</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="example-1" src="https://assets.leetcode.com/uploads/2021/10/02/ex1.png" style="width: 240px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [3,9,7,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One optimal partition is: [3,9] and [7,3].
The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-36,36]
<strong>Output:</strong> 72
<strong>Explanation:</strong> One optimal partition is: [-36] and [36].
The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.
</pre>

<p><strong class="example">Example 3:</strong></p>
<img alt="example-3" src="https://assets.leetcode.com/uploads/2021/10/02/ex3.png" style="width: 316px; height: 106px;" />
<pre>
<strong>Input:</strong> nums = [2,-1,0,4,-2,-9]
<strong>Output:</strong> 0
<strong>Explanation:</strong> One optimal partition is: [2,4,-9] and [-1,0,-2].
The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 15</code></li>
	<li><code>nums.length == 2 * n</code></li>
	<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-154">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-labels/description" target="_blank" rel="noopener noreferrer">Partition Labels</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code>&quot;ababcc&quot;</code> can be partitioned into <code>[&quot;abab&quot;, &quot;cc&quot;]</code>, but partitions such as <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> or <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> are invalid.</p>

<p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p>

<p>Return <em>a list of integers representing the size of these parts</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababcbacadefegdehijhklij&quot;
<strong>Output:</strong> [9,7,8]
<strong>Explanation:</strong>
The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.
This is a partition so that each letter appears in at most one part.
A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;eccbbbbdec&quot;
<strong>Output:</strong> [10]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 500</code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code> consisting of lowercase letters, and our task is to partition it into the maximum number of contiguous groups while ensuring that each letter appears in only one group. This means that if a letter appears more than once in the string, all of its occurrences must be contained within the same partition. Our goal is to return a list of integers representing the sizes of these partitions rather than the partitions themselves.</p>
<p>For example, in the string <code>&quot;abcd&quot;</code>, since no letter repeats, we can split it into the maximum number of groups: <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</code>, resulting in <code>[1,1,1,1]</code>. However, if we take <code>&quot;aabbacc&quot;</code>, the letter <code>'a'</code> appears multiple times, so we need to form a partition that includes all its occurrences, leading to <code>[&quot;aabba&quot;, &quot;cc&quot;]</code> with a response of <code>[5,2]</code>. Similarly, in <code>&quot;abab&quot;</code>, we might be tempted to split at <code>&quot;aba&quot;</code> and <code>&quot;b&quot;</code>, but since <code>'b'</code> appears in both parts, we must instead merge them into a single group, resulting in <code>[&quot;abab&quot;]</code> with <code>[4]</code> as the output.</p>
<p>A more natural example like <code>&quot;bobhaspepper&quot;</code> helps visualize this rule. Here, we get partitions like <code>[&quot;bob&quot;, &quot;h&quot;, &quot;a&quot;, &quot;s&quot;, &quot;peppe&quot;, &quot;r&quot;]</code> because each repeated letter is contained within its respective segment. The key challenge in solving this problem is correctly identifying the last occurrence of each letter to determine partition boundaries. If we attempt to split too early, we might create an invalid partition where a character appears in multiple groups, which is not allowed.</p>
<hr />
<h3 id="approach-1-two-pointers">Approach 1: Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>At first glance, the problem seems tricky because we need to break the string into contiguous partitions while ensuring that each character appears in at most one partition. The key challenge is figuring out where to split the string.</p>
<p>To get a better sense of the problem, let's take an example: <code>s = &quot;abacbc&quot;</code></p>
<p>If we try to make a partition at the first occurrence of a character, it might not work. For example, if we cut right after <code>'a'</code>, we'd get <code>&quot;a&quot;</code> and <code>&quot;bacbc&quot;</code>, but that wouldn't be valid because <code>'a'</code> appears again later in the string. This tells us that a partition must extend until the last occurrence of all characters within it.</p>
<p>So, the first thing we should do is find out where each character appears for the last time. This helps us determine the boundaries of a partition dynamically while iterating through the string.</p>
<p>We start by scanning the string to record the last occurrence of each character in an index array. This helps us determine how far we must extend a partition to fully include any character we encounter.</p>
<p>Now, we use two pointers:</p>
<ul>
<li>One pointer (<code>partitionEnd</code>) keeps track of the farthest point we need to reach for the current partition.</li>
<li>The other pointer (<code>partitionStart</code>) marks where the current partition begins.</li>
</ul>
<p>As we iterate through the string, we keep extending <code>partitionEnd</code> to the maximum last occurrence of any character encountered. Once we reach <code>partitionEnd</code>, we finalize the partition and store its size. Then, we update <code>partitionStart</code> for the next partition.</p>
<p>Once we reach the end of this boundary, we record the partition size and move on to the next segment. By the end, we obtain the possible valid partitions, ensuring that no character appears in more than one.</p>
<p><img src="../Figures/763/greedy_approach_1.png" alt="Two_Pointers" /></p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Create an array <code>lastOccurrence</code> of size <code>26</code> to store the last index of each character in <code>s</code>.</p>
</li>
<li>
<p>Iterate through <code>s</code> and update <code>lastOccurrence</code> to record the last position of each character.</p>
</li>
<li>
<p>Initialize <code>partitionStart</code> and <code>partitionEnd</code> to <code>0</code> to track the start and end of the current partition, respectively.</p>
</li>
<li>
<p>Create a list <code>partitionSizes</code> to store the sizes of partitions.</p>
</li>
<li>
<p>Iterate through <code>s</code>:</p>
<ul>
<li>Update <code>partitionEnd</code> to the maximum of its current value and the last occurrence of the current character.</li>
<li>If the current index <code>i</code> reaches <code>partitionEnd</code>, it means the partition is complete:
<ul>
<li>Compute the partition size <code>(i - partitionStart + 1)</code> and add it to <code>partitionSizes</code>.</li>
<li>Update <code>partitionStart</code> to <code>i + 1</code> for the next partition.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>partitionSizes</code> containing the sizes of all partitions.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<blockquote>
<p>Note: We are using an array of size 26 instead of a hash map to track the last occurrence of each character, since there can be at most 26 distinct letters in the string <code>s</code>.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/MN685Ka5/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>s</code> and <span class="math inline">\(k\)</span> be the number of unique characters in <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the string twice. The first loop takes <span class="math inline">\(O(n)\)</span> time to store the index of the last occurrence of each character in the <code>lastOccurrence</code> array. The second loop, also running in <span class="math inline">\(O(n)\)</span> time, determines the partitions by tracking the end of each partition using the <code>lastOccurrence</code> array. Since both loops are linear and independent, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The algorithm uses a fixed-size array, <code>lastOccurrence</code>, of size 26 to store the last occurrence of each lowercase English letter. In the general case, the space required is proportional to the number of distinct letters in <code>s</code>. Thus, for an arbitrary alphabet (a set of distinct values) of size <span class="math inline">\(k\)</span>, the space complexity of the algorithm is <span class="math inline">\(O(k)\)</span>.</p>
<p>The <code>partitionSizes</code> array, which stores the lengths of the partitions, is part of the output and is not included in the space complexity analysis, since it is required by the problem statement.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-merge-intervals">Approach 2: Merge Intervals</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Instead of directly deciding partitions while scanning the string, another intuitive approach is to think in terms of character intervals. Each character appears within a specific range in the string, and our goal is to merge overlapping intervals to determine the correct partitions. This question becomes closely related to <a href="https://leetcode.com/problems/merge-intervals/description/">56. Merge Intervals</a></p>
<p>To begin, we first identify where the occurrences of each character in the string start and end. The first occurrence of a character marks the beginning of its interval, and the last occurrence marks its end. If we can determine these intervals for all characters, we essentially get a set of segments that show where each letter is confined within the string.</p>
<p>Once we have these intervals, we need to merge overlapping ones. If two intervals overlap, it means that the characters in those intervals must be part of the same partition since they share a dependency. The merging process ensures that we are not splitting a character across multiple partitions.</p>
<p>As we iterate through the string, we keep track of the current partition’s boundaries. If we reach an index that extends beyond the current partition’s range, we update the boundary. When we reach the end of the partition, we record its size and start a new partition.</p>
<p>This method allows us to process the string in two sweeps: the first one to determine character intervals and the second to merge them while forming partitions. In terms of complexity, there is not much difference from the above approach. Although it does have a little overhead in terms of space complexity, it can be more intuitive for those who already know the concept of merging intervals.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize an empty array, <code>partitionSizes</code> to store partition lengths.</p>
</li>
<li>
<p>Create two arrays, <code>lastOccurrence</code> and <code>firstOccurrence</code> to track character positions.</p>
</li>
<li>
<p>Initialize <code>partitionStart</code> and <code>partitionEnd</code> to <code>0</code> to track partition boundaries.</p>
</li>
<li>
<p>Iterate through <code>s</code> to record the last occurrence of each character.</p>
</li>
<li>
<p>Iterate through <code>s</code> again:</p>
<ul>
<li>Store the first occurrence of the current character <code>s[i]</code> if not already set.
<ul>
<li>If a new partition starts at current index, i.e. <code>i &gt; partitionEnd</code>, store the last partition size and update partition boundaries.</li>
</ul>
</li>
<li>Update <code>partitionEnd</code> to the maximum of its current value and and the last occurrence of <code>s[i]</code> to ensure that all occurrences of <code>s[i]</code> are in the same (current) partition.</li>
</ul>
</li>
<li>
<p>Add the final partition size if it exists.</p>
</li>
<li>
<p>Return <code>partitionSizes</code> containing partition lengths.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<blockquote>
<p>Note: We are using an array of size 26 instead of a hash map to track the last occurrence of each character, since there can be at most 26 distinct letters in the string <code>s</code>.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/XDkcMY5o/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the input string <code>s</code> and <span class="math inline">\(k\)</span> be the number of unique characters in <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm iterates through the string twice. The first loop runs in <span class="math inline">\(O(n)\)</span> time to store the last occurrence index of each character. The second loop also runs in <span class="math inline">\(O(n)\)</span> time to determine the partitions by checking the first and last occurrences of each character. Since both loops are linear and independent of each other, the overall time complexity is <span class="math inline">\(O(n)\)</span>.</p>
<p>The built-in functions used, such as <code>min</code> and <code>max</code>, operate in constant time <span class="math inline">\(O(1)\)</span>, and the operations on the array are amortized <span class="math inline">\(O(1)\)</span>. Thus, they do not significantly impact the overall time complexity.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(k)\)</span></p>
<p>The algorithm uses two fixed-size arrays, <code>firstOccurrence</code> and <code>lastOccurrence</code>, of size 26 to store each character's interval boundaries. In the general case, the space required is proportional to the number of distinct letters in <code>s</code>. Thus, for an arbitrary alphabet (a set of distinct values) of size <span class="math inline">\(k\)</span>, the space complexity of the algorithm is <span class="math inline">\(O(k)\)</span>.</p>
<p>The <code>partitionSizes</code> array, which stores the lengths of the partitions, is part of the output and is not included in the space complexity analysis since it is required by the problem statement.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-155">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/partition-list/description" target="_blank" rel="noopener noreferrer">Partition List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>

<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" style="width: 662px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3
<strong>Output:</strong> [1,2,2,4,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [2,1], x = 2
<strong>Output:</strong> [1,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-156">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/permutation-in-string/description" target="_blank" rel="noopener noreferrer">Permutation in String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">sliding window</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> if <code>s2</code> contains a <span data-keyword="permutation-string">permutation</span> of <code>s1</code>, or <code>false</code> otherwise.</p>

<p>In other words, return <code>true</code> if one of <code>s1</code>&#39;s permutations is the substring of <code>s2</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> s2 contains one permutation of s1 (&quot;ba&quot;).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot;
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<blockquote>
<p>Note: This approach is included because it is a logical first step towards building an efficient solution. However, it is a brute-force approach and is not expected to pass all test cases. Readers are still recommended to read it because it helps to understand the following approaches.</p>
</blockquote>
<p><strong>Algorithm</strong></p>
<p>The simplest method is to generate all the permutations of the short string  and to check if the generated permutation is a substring of the longer string.</p>
<p>In order to generate all the possible pairings, we make use of a function <code>permute(string_1, string_2, current_index)</code>. This function creates all the possible permutations of the short string <span class="math inline">\(s1\)</span>.</p>
<p>To do so, permute takes the index of the current element <span class="math inline">\(current\_index\)</span> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>
<p>Thus, when we reach the end of the array, a new ordering of the array's elements is generated. The following animation depicts the process of generating the permutations.</p>
<p>!?!../Documents/561_Array.json:1000,563!?!</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/LWP4QuTU/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(n\)</span> be the length of <span class="math inline">\(s1\)</span></p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n!)\)</span>. The permute method generates all possible permutations of the string <code>s1</code>. In a permutation problem, the number of ways to permute a string of length <span class="math inline">\(n\)</span> is <span class="math inline">\(n!\)</span>. Each recursive call swaps characters at different positions to explore every possible permutation at each level of recursion. At the first level, there are <span class="math inline">\(n\)</span> choices for which character to place in the first position. At the second level, there are <span class="math inline">\(n−1\)</span> choices for which character to place in the second position, and so on, leading to <span class="math inline">\(n!\)</span> total recursive calls.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span>. The depth of the recursion tree is <span class="math inline">\(n$$($$n\)</span> refers to the length of the short string <code>s1</code>). Every node of the recursion tree contains a string of max. length <span class="math inline">\(n\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-sorting">Approach 2: Using sorting:</h3>
<p><strong>Algorithm</strong></p>
<p>The idea behind this approach is that one string will be a permutation of another string only if both of them contain the same characters the same number of times. One string <span class="math inline">\(x\)</span> is a permutation of other string <span class="math inline">\(y\)</span> only if <span class="math inline">\(sorted(x)=sorted(y)\)</span>.</p>
<p>In order to check this, we can sort the two strings and compare them.  We sort the short string <span class="math inline">\(s1\)</span> and all the substrings of <span class="math inline">\(s2\)</span>, sort them and compare them with the sorted <span class="math inline">\(s1\)</span> string. If the two matches completely, <span class="math inline">\(s1\)</span>'s permutation is a substring of <span class="math inline">\(s2\)</span>, otherwise not.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/Wb5Q7yA8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(l_1\)</span> be the length of string <span class="math inline">\(s_1\)</span> and <span class="math inline">\(l_2\)</span> be the length of string <span class="math inline">\(s_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((l_2 - l_1) \cdot l_1 \log l_1)\)</span>.</p>
<p>First, we sort <span class="math inline">\(s_1\)</span> which takes <span class="math inline">\(O(l_1 \log l_1)\)</span>. Then, we iterate through a range of <span class="math inline">\((l_2 - l_1 + 1)\)</span> and within the loop, we sort a substring of length <span class="math inline">\(l_1\)</span>. This process takes <span class="math inline">\(O((l_2 - l_1 + 1) \cdot l_1 \log l_1)\)</span> time. Overall, we combine both time complexities: <span class="math inline">\(O((l_2 - l_1 + 1 + 1) \cdot l_1 \log l_1) \rightarrow O((l_2 - l_1) \cdot l_1 \log l_1)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(l_1 + S)\)</span>. <span class="math inline">\(t\)</span> array is used.</p>
<p>Some extra space is used when we sort an array of size <span class="math inline">\(n\)</span> in place. The space complexity of the sorting algorithm (<span class="math inline">\(S\)</span>) depends on the programming language. The value of <span class="math inline">\(S\)</span> depends on the programming language and the sorting algorithm being used:</p>
<ul>
<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of <span class="math inline">\(O(n)\)</span></li>
<li>In C++, the <code>sort()</code> function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of <span class="math inline">\(O( \log n )\)</span></li>
<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of <span class="math inline">\(O( \log n)\)</span></li>
</ul>
<p>Thus, the total space complexity of the algorithm is <span class="math inline">\(O(l_1 + S)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-hashmap">Approach 3: Using Hashmap</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed above, one string will be a permutation of another string only if both of them contain the same characters with the same frequency. We can consider every possible substring in the long string <span class="math inline">\(s2\)</span> of the same length as that of <span class="math inline">\(s1\)</span> and check the frequency of occurence of the characters appearing in the two. If the frequencies of every letter match exactly, then only <span class="math inline">\(s1\)</span>'s permutation can be a substring of <span class="math inline">\(s2\)</span>.</p>
<p>In order to implement this approach, instead of sorting and then comparing the elements for equality, we make use of a hashmap <span class="math inline">\(s1map\)</span> which stores the frequency of occurence of all the characters in the short string <span class="math inline">\(s1\)</span>. We consider every possible substring of <span class="math inline">\(s2\)</span> of the same length as that of <span class="math inline">\(s1\)</span>, find its corresponding hashmap as well, namely <span class="math inline">\(s2map\)</span>. Thus, the substrings considered can be viewed as a window of length as that of <span class="math inline">\(s1\)</span> iterating over <span class="math inline">\(s2\)</span>. If the two hashmaps obtained are identical for any such window, we can conclude that <span class="math inline">\(s1\)</span>'s permutation is a substring of <span class="math inline">\(s2\)</span>, otherwise not.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/J6Pashup/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(l_1\)</span> be the length of string <span class="math inline">\(s_1\)</span> and <span class="math inline">\(l_2\)</span> be the length of string <span class="math inline">\(s_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(l_1 + (26 + l_1) \cdot (l_2 - l_1))\)</span></p>
<p>The initialization of the map <code>s1map</code> takes <span class="math inline">\(O(l_1)\)</span> since we loop through each character of <span class="math inline">\(s_1\)</span> once and store the counts.</p>
<p>The outer loop runs <span class="math inline">\((l_2 - l_1 + 1)\)</span> times, as we need to consider each possible substring of length <span class="math inline">\(l_1\)</span> within <span class="math inline">\(s_2\)</span>.</p>
<p>For each iteration of the outer loop, we build <code>s2map</code>, which takes <span class="math inline">\(O(l_1)\)</span> time (since we process <span class="math inline">\(l_1\)</span> characters for each substring in <span class="math inline">\(s_2\)</span>).</p>
<p>In the <code>matches</code> function, we iterate through <code>s1map</code> to compare it with <code>s2map</code>. This takes <span class="math inline">\(O(26) = O(1)\)</span>, as the alphabet size is constant (26 characters). Thus, checking equality of the two maps involves a constant-time comparison for each character in the alphabet.</p>
<p>Thus, the total time complexity becomes: <span class="math inline">\(O(l_1 + (26 + l_1) \cdot (l_2 - l_1))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(l_2 - l_1)\)</span></p>
<p>Each substring from <span class="math inline">\(s_2\)</span> of length <span class="math inline">\(l_1\)</span> creates a <code>HashMap</code> (<code>s2map</code>) to store the character frequencies.</p>
<p>The size of this <code>HashMap</code> is <span class="math inline">\(O(26)\)</span>, since there are at most 26 characters in the alphabet.</p>
<p>Over <span class="math inline">\(l_2 - l_1 + 1\)</span> iterations of the outer loop, we create one such <code>HashMap</code> per iteration, resulting in <span class="math inline">\(O(26 \cdot (l_2 - l_1 + 1))\)</span> space usage.</p>
<p>We also create a <code>HashMap</code> for <span class="math inline">\(s_1\)</span> (<code>s1map</code>), which similarly takes <span class="math inline">\(O(26)\)</span> space.</p>
<p>Since we need to store a <code>HashMap</code> for each of the <span class="math inline">\(l_2 - l_1 + 1\)</span> substrings in the worst case, the space complexity is proportional to the number of substrings and the size of each <code>HashMap</code>.</p>
<p>Therefore, the total space complexity is: <span class="math inline">\(O(26 \cdot (l_2 - l_1 + 1) + 26) = O(26 \cdot (l_2 - l_1 + 1))\)</span>. In simplified terms: <span class="math inline">\(O(l_2 - l_1)\)</span></p>
</li>
</ul>
<hr />
<h3 id="approach-4-using-array-accepted">Approach 4: Using Array [Accepted]</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of making use of a special HashMap datastructure just to store the frequency of occurence of characters, we can use a simpler array data structure to store the frequencies. Given strings contains only lowercase alphabets ('a' to 'z'). So we need to take an array of size 26.The rest of the process remains the same as the last approach.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/YTLoQomr/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(l_1\)</span> be the length of string <span class="math inline">\(s_1\)</span> and <span class="math inline">\(l_2\)</span> be the length of string <span class="math inline">\(s_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(l_1 + (26 + l_1) \cdot (l_2 - l_1))\)</span></p>
<p>The initialization of the array <code>s1arr</code> takes <span class="math inline">\(O(l_1)\)</span> since we loop through each character of <span class="math inline">\(s_1\)</span> once and store the counts.</p>
<p>The outer loop runs <span class="math inline">\((l_2 - l_1 + 1)\)</span> times, as we need to consider each possible substring of length <span class="math inline">\(l_1\)</span> within <span class="math inline">\(s_2\)</span>.</p>
<p>For each iteration of the outer loop, we build <code>s2arr</code>, which takes <span class="math inline">\(O(l_1)\)</span> time (since we process <span class="math inline">\(l_1\)</span> characters for each substring in <span class="math inline">\(s_2\)</span>).</p>
<p>In the <code>matches</code> function, we iterate through <code>s1arr</code> to compare it with <code>s2arr</code>. This takes <span class="math inline">\(O(26) = O(1)\)</span>, as the alphabet size is constant (26 characters). Thus, checking equality of the two maps involves a constant-time comparison for each character in the alphabet.</p>
<p>Thus, the total time complexity becomes: <span class="math inline">\(O(l_1 + (26 + l_1) \cdot (l_2 - l_1))\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(l_2 - l_1)\)</span></p>
<p>Each substring from <span class="math inline">\(s_2\)</span> of length <span class="math inline">\(l_1\)</span> creates a array (<code>s2arr</code>) to store the character frequencies.</p>
<p>The size of this array is <span class="math inline">\(O(26)\)</span>, since there are at most 26 characters in the alphabet.</p>
<p>Over <span class="math inline">\(l_2 - l_1 + 1\)</span> iterations of the outer loop, we create one such array per iteration, resulting in <span class="math inline">\(O(26 \cdot (l_2 - l_1 + 1))\)</span> space usage.</p>
<p>We also create a array for <span class="math inline">\(s_1\)</span> (<code>s1arr</code>), which similarly takes <span class="math inline">\(O(26)\)</span> space.</p>
<p>Since we need to store a array for each of the <span class="math inline">\(l_2 - l_1 + 1\)</span> substrings in the worst case, the space complexity is proportional to the number of substrings and the size of each array.</p>
<p>Therefore, the total space complexity is: <span class="math inline">\(O(26 \cdot (l_2 - l_1 + 1) + 26) = O(26 \cdot (l_2 - l_1 + 1))\)</span>. In simplified terms: <span class="math inline">\(O(l_2 - l_1)\)</span></p>
</li>
</ul>
<hr />
<h3 id="approach-5-sliding-window--accepted">Approach 5: Sliding Window  [Accepted]:</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of building a new hashmap from scratch for every window we check in <span class="math inline">\(s2\)</span>, we can just set up a fixed-size array of length 26 once for the first window in <span class="math inline">\(s2\)</span>. Then, as we slide the window over, we can simply update it. Basically, we’ll remove the character that's no longer in the window and add the new one that’s now part of it. So, the array gets tweaked only at the two spots related to those two characters. Each time we update the array, we just compare all the elements to check if everything matches up for the result we want.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/VaR6ouAa/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(l_1\)</span> be the length of string <span class="math inline">\(s_1\)</span> and <span class="math inline">\(l_2\)</span> be the length of string <span class="math inline">\(s_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(l_1 + 26 \cdot (l_2 - l_1)) = O(l_1 + (l_2 - l_1)) = O(l_2)\)</span></p>
<p>The loop that populates two frequency arrays runs for <span class="math inline">\(l_1\)</span> iterations, as it processes all characters in <span class="math inline">\(s_1\)</span> and the first <span class="math inline">\(l_1\)</span> characters in <span class="math inline">\(s_2\)</span>. This step takes <span class="math inline">\(O(l_1)\)</span> time.</p>
<p>The outer loop runs <span class="math inline">\(l_2 - l_1\)</span> times, sliding the window of size <span class="math inline">\(l_1\)</span> across <span class="math inline">\(s_2\)</span>. For each iteration, two operations are performed:</p>
<ul>
<li>Increment the count of the new character added to the window (<code>s2arr[s2.charAt(i + l_1) - 'a']++</code>).</li>
<li>Decrement the count of the character leaving the window (<code>s2arr[s2.charAt(i) - 'a']--</code>).<br />
Both of these operations are constant-time, <span class="math inline">\(O(1)\)</span>, for each iteration since the arrays are of fixed size (26). Thus, the time complexity for this part is <span class="math inline">\(O(l_2 - l_1)\)</span>.</li>
</ul>
<p>The <code>matches</code> function compares the two arrays element by element, which takes <span class="math inline">\(O(26) = O(1)\)</span> time because the arrays have a fixed size of 26.</p>
<p>Combining the preprocessing and sliding window steps, the total time complexity is: <span class="math inline">\(O(l_1 + 26 \cdot (l_2 - l_1))\)</span></p>
<p>Since <span class="math inline">\(26\)</span> is a constant, this simplifies to: <span class="math inline">\(O(l_1 + (l_2 - l_1)) = O(l_2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(26 + 26) = O(1)\)</span></p>
<p>Two arrays, <code>s1arr</code> and <code>s2arr</code>, are used to store character frequencies. Each array has a fixed size of 26, regardless of the lengths of <span class="math inline">\(s_1\)</span> and <span class="math inline">\(s_2\)</span>. Therefore, the space used for these arrays is <span class="math inline">\(O(26 + 26) = O(52) = O(1)\)</span>.</p>
<p>No other data structures that depend on the size of <span class="math inline">\(s_1\)</span> or <span class="math inline">\(s_2\)</span> are used. The space required is constant, independent of the input size.</p>
<p>Thus, the total space complexity is: <span class="math inline">\(O(1)\)</span></p>
</li>
</ul>
<hr />
<h3 id="approach-6-optimized-sliding-window-accepted">Approach 6: Optimized Sliding Window [Accepted]:</h3>
<p><strong>Algorithm</strong></p>
<p>The last approach can be optimized, if instead of comparing all the elements of the <code>s1arr</code> for every updated <code>s2arr</code> corresponding to every window of <span class="math inline">\(s2\)</span> considered, we keep a track of the number of elements which were already matching in the <code>s1arr</code> and update just the count of matching elements when we shift the window towards the right.</p>
<p>To do so, we maintain a <code>count</code> variable, which stores the number of characters(out of the 26 alphabets), which have the same frequency of occurence in <span class="math inline">\(s1\)</span> and the current window in <span class="math inline">\(s2\)</span>. When we slide the window, if the deduction of the last element and the addition of the new element leads to a new frequency match of any of the characters, we increment the <code>count</code> by 1. If not, we keep the <code>count</code> intact. But, if a character whose frequency was the same earlier(prior to addition and removal) is added, it now leads to a frequency mismatch which is taken into account by decrementing the same <code>count</code> variable. If, after the shifting of the window, the <code>count</code> evaluates to 26, it means all the characters match in frequency totally. So, we return a True in that case immediately.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/FhVsu6SM/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(l_1\)</span> be the length of string <span class="math inline">\(s_1\)</span> and <span class="math inline">\(l_2\)</span> be the length of string <span class="math inline">\(s_2\)</span>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(l_1 + (l_2 - l_1)) \approx O(l_2)\)</span></p>
<p>Populating <code>s1arr</code> and <code>s2arr</code> takes <span class="math inline">\(O(l_1)\)</span> time since we iterate over the first <span class="math inline">\(l_1\)</span> characters of both strings.</p>
<p>The outer loop runs <span class="math inline">\(l_2 - l_1\)</span> times. In each iteration, we update two characters (one entering and one leaving the window) in constant time <span class="math inline">\(O(1)\)</span>, and we maintain a count of matches. This step takes <span class="math inline">\(O(l_2 - l_1)\)</span>.</p>
<p>Checking if <code>count == 26</code> also happens in <span class="math inline">\(O(1)\)</span>, since it's a constant comparison.</p>
<p>Thus, the total time complexity is: <span class="math inline">\(O(l_1 + (l_2 - l_1)) \approx O(l_2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Two fixed-size arrays (<code>s1arr</code> and <code>s2arr</code>) of size 26 are used for counting character frequencies. No additional space that grows with the input size is used.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-157">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/police-and-thieves--141631/1" target="_blank" rel="noopener noreferrer">Police and Thieves</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">greedy</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[]</strong>, where each element contains either a <strong>'P'</strong> for policeman or a <strong>'T'</strong> for thief. Find the <strong>maximum number of thieves </strong>that can be caught by the police.&nbsp;<br />Keep in mind the following conditions :</span></p>
<ol>
<li><span style="font-size: 18px;">Each policeman can catch only one thief.</span></li>
<li><span style="font-size: 18px;">A policeman cannot catch a thief who is more than <strong>k</strong> units away from him.</span></li>
</ol>
<p><strong><span style="font-size: 18px;">Examples:</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ['P', 'T', 'T', 'P', 'T'], k = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> Maximum 2 thieves can be caught. First policeman catches first thief and second police man can catch either second or third thief.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = ['T', 'T', 'P', 'P', 'T', 'P'], k = 2
<strong>Output:</strong> 3
<strong>Explanation: </strong>Maximum 3 thieves can be caught.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; arr.size() &le; 10<sup>5</sup><br />1 &le; k &le; 1000<br />arr[i] = 'P' or 'T'</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-158">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/push-dominoes/description" target="_blank" rel="noopener noreferrer">Push Dominoes</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>

<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>

<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>

<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>

<p>You are given a string <code>dominoes</code> representing the initial state where:</p>

<ul>
	<li><code>dominoes[i] = &#39;L&#39;</code>, if the <code>i<sup>th</sup></code> domino has been pushed to the left,</li>
	<li><code>dominoes[i] = &#39;R&#39;</code>, if the <code>i<sup>th</sup></code> domino has been pushed to the right, and</li>
	<li><code>dominoes[i] = &#39;.&#39;</code>, if the <code>i<sup>th</sup></code> domino has not been pushed.</li>
</ul>

<p>Return <em>a string representing the final state</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> dominoes = &quot;RR.L&quot;
<strong>Output:</strong> &quot;RR.L&quot;
<strong>Explanation:</strong> The first domino expends no additional force on the second domino.
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png" style="height: 196px; width: 512px;" />
<pre>
<strong>Input:</strong> dominoes = &quot;.L.R...LR..L..&quot;
<strong>Output:</strong> &quot;LL.RR.LLRRLL..&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == dominoes.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>dominoes[i]</code> is either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-adjacent-symbols-accepted">Approach #1: Adjacent Symbols [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>Between every group of vertical dominoes (<code>'.'</code>), we have up to two non-vertical dominoes bordering this group.  Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: there are 9 of them (as the border could be empty). Actually, if we border the dominoes by <code>'L'</code> and <code>'R'</code>, there are only 4 cases.  We'll write new letters between these symbols depending on each case.</p>
<p><strong>Algorithm</strong></p>
<p>Continuing our explanation, we analyze cases:</p>
<ul>
<li>
<p>If we have say <code>&quot;A....B&quot;</code>, where A = B, then we should write <code>&quot;AAAAAA&quot;</code>.</p>
</li>
<li>
<p>If we have <code>&quot;R....L&quot;</code>, then we will write <code>&quot;RRRLLL&quot;</code>, or <code>&quot;RRR.LLL&quot;</code> if we have an odd number of dots.  If the initial symbols are at positions <code>i</code> and <code>j</code>, we can check our distance <code>k-i</code> and <code>j-k</code> to decide at position <code>k</code> whether to write <code>'L'</code>, <code>'R'</code>, or <code>'.'</code>.</p>
</li>
<li>
<p>(If we have <code>&quot;L....R&quot;</code> we don't do anything.  We can skip this case.)</p>
</li>
</ul>
<p><a href="https://leetcode.com/playground/fitEjZPW/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time and Space Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>dominoes</code>.</li>
</ul>
<hr />
<h3 id="approach-2-calculate-force-accepted">Approach #2: Calculate Force [Accepted]</h3>
<p><strong>Intuition</strong></p>
<p>We can calculate the net force applied on every domino.  The forces we care about are how close a domino is to a leftward <code>'R'</code>, and to a rightward <code>'L'</code>: the closer we are, the stronger the force.</p>
<p><strong>Algorithm</strong></p>
<p>Scanning from left to right, our force decays by 1 every iteration, and resets to <code>N</code> if we meet an <code>'R'</code>, so that <code>force[i]</code> is higher (than <code>force[j]</code>) if and only if <code>dominoes[i]</code> is closer (looking leftward) to <code>'R'</code> (than <code>dominoes[j]</code>).</p>
<p>Similarly, scanning from right to left, we can find the force going rightward (closeness to <code>'L'</code>).</p>
<p>For some domino <code>answer[i]</code>, if the forces are equal, then the answer is <code>'.'</code>.  Otherwise, the answer is implied by whichever force is stronger.</p>
<p><strong>Example</strong></p>
<p>Here is a worked example on the string <code>S = 'R.R...L'</code>:  We find the force going from left to right is <code>[7, 6, 7, 6, 5, 4, 0]</code>.  The force going from right to left is <code>[0, 0, 0, -4, -5, -6, -7]</code>.  Combining them (taking their vector addition), the combined force is <code>[7, 6, 7, 2, 0, -2, -7]</code>, for a final answer of <code>RRRR.LL</code>.</p>
<p><a href="https://leetcode.com/playground/E9fUayEf/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time and Space Complexity:  <span class="math inline">\(O(N)\)</span>.</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-159">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/range-sum-of-sorted-subarray-sums/description" target="_blank" rel="noopener noreferrer">Range Sum of Sorted Subarray Sums</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the array <code>nums</code> consisting of <code>n</code> positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of <code>n * (n + 1) / 2</code> numbers.</p>

<p><em>Return the sum of the numbers from index </em><code>left</code><em> to index </em><code>right</code> (<strong>indexed from 1</strong>)<em>, inclusive, in the new array. </em>Since the answer can be a huge number return it modulo <code>10<sup>9</sup> + 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 5
<strong>Output:</strong> 13 
<strong>Explanation:</strong> All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 3, right = 4
<strong>Output:</strong> 6
<strong>Explanation:</strong> The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4], n = 4, left = 1, right = 10
<strong>Output:</strong> 50
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<h4 id="intuition">Intuition</h4>
<p>This problem requires us to calculate all subarray sums of the given array, store the totals in a new array, sort this new array in non-decreasing order, and then sum the elements between the given <code>left</code> and <code>right</code> indices.</p>
<p>To achieve this, we'll create a new array called <code>storeSubarray</code> to store the sums of each subarray. Once we've iterated through the entire given array to calculate the subarray sums, we'll sort <code>storeSubarray</code> to be in non-decreasing order. Finally, we'll calculate and return the sum of the elements between the given <code>left</code> and <code>right</code> indices of <code>storeSubarray</code>, inclusive.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Initialize an array given by <code>storeSubarray</code> to store all the subarray sums.</li>
<li>Iterate <code>i</code> through <code>nums</code>:</li>
</ol>
<ul>
<li>Initialize an integer <code>sum</code> with 0, to store the subarray sums starting at <code>i</code>.</li>
<li>Iterate <code>j</code> from <code>i</code> to the end of <code>nums</code>:
<ul>
<li>Increment <code>sum</code> with <code>nums[j]</code>.</li>
<li>Append <code>sum</code> to the <code>storeSubarray</code> array.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Sort <code>storeSubarray</code> in non-decreasing order.</li>
<li>Initialize <code>rangeSum</code> with 0 and mod with 1000000009.</li>
<li>Iterate all elements in <code>storeSubarray</code> between <code>left-1</code> and <code>right-1</code>:</li>
</ol>
<ul>
<li>Add the current value of <code>storeSubarray</code> to rangeSum and take its modulo with <code>mod</code>.</li>
</ul>
<ol start="6">
<li>Return <code>rangeSum</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ekg42VMR/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> twice to store all the subarray sums. This operation takes <span class="math inline">\(O(n^2)\)</span> time. Then, we sort this array storing all the subarray sums. The time complexity for this operation is <span class="math inline">\(O(n^2\cdot \log n)\)</span>. Iterating all indices between <code>left</code> and <code>right</code> also takes <span class="math inline">\(O(n^2)\)</span> time in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2 \cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n^2)\)</span></p>
<p>We create a <code>storeSubarray</code> array with size proportional to <span class="math inline">\(O(n^2)\)</span>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n^2)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-priority-queue">Approach 2: Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can maintain the sorted order of subarray sums using a priority queue, which stores elements in a sorted order using a heap data structure. By inserting all the subarray sums into the priority queue, we ensure that the smallest sums are always easily accessible.</p>
<p>Inserting all subarray sums into the priority queue results in the same time and space complexity as the previous approach, but it's possible to refine this strategy to optimize space complexity.</p>
<p>In our first approach, we created an array to store all possible subarray sums. In this approach, we'll use the priority queue to store pairs. The first element of each pair will represent the sum of the current subarray and the second element will represent the end index of that subarray. We'll initialize the priority queue with pairs representing all one-sized subarrays.</p>
<p>As we process the queue, we repeatedly pop the smallest element, which represents the smallest subarray sum. However, this subarray could be part of a larger subarray. To account for this, we expand the subarray by one element (incrementing the end index), update its sum, and push the updated pair back into the priority queue.</p>
<p>Once we have performed exactly <code>left</code> pop operations, we start accumulating the subarray sums. The process continues until we reach the <code>right</code> pop operation, at which point we return the accumulated sum.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>
<p>Initialize a priority queue <code>pq</code> of pairs, where each pair contains:</p>
<ul>
<li>The value of the current sum of subarray.</li>
<li>The ending index of that subarray.</li>
</ul>
</li>
<li>
<p>The priority queue is ordered by the smallest sums first.</p>
</li>
<li>
<p>Populate the priority queue with the initial values:</p>
<ul>
<li>Iterate through the first <code>n</code> elements of <code>nums</code> and push pairs of each element and its index into the priority queue.</li>
</ul>
</li>
<li>
<p>Initialize <code>ans</code> to 0 to store the result and <code>mod</code> to (10^9 + 7) for the modulo operation.</p>
</li>
<li>
<p>Iterate from <code>1</code> to <code>right</code>:</p>
<ul>
<li>Extract the smallest sum from the priority queue (top of the queue).</li>
<li>If the current index <code>i</code> is greater than or equal to <code>left</code>, add the value of the current pair to <code>ans</code>, taking modulo <code>mod</code> to avoid overflow.</li>
<li>If the index of the extracted pair is less than the last index (<code>n-1</code>):
<ul>
<li>Increment the index.</li>
<li>Update the pair's value by adding the next element to the array <code>nums</code>.</li>
<li>Push the updated pair back into the priority queue.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Return <code>ans</code> as a result.</p>
</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/deXYG3zj/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n^2 \cdot \log n)\)</span></p>
<p>We iterate through <code>nums</code> once to store all the one-sized subarray sums. This operation takes <span class="math inline">\(O(n)\)</span> time. Then, we iterate all indices between <code>left</code> and <code>right</code>, performing pop operation in each iteration, which takes <span class="math inline">\(O(n^2 \cdot \log n)\)</span> time total in the worst case.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n^2\cdot \log n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The size of <code>pq</code> never exceeds <code>n</code>. Apart from this, no additional memory is used.</p>
<p>Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-binary-search-and-sliding-window">Approach 3: Binary Search and Sliding Window</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Can we use binary search to solve this problem? We can apply binary search if the search space is sorted. Here, our search space can be defined as the sum of the first <code>k</code> smallest subarray sums. To find the sum of all subarrays in this range, we calculate the difference between this sum at <code>right</code> and <code>left-1</code>.</p>
<p>We will create a binary search function that calculates the sum of the first <code>k</code> smallest subarray sums. The minimum and maximum possible values for this search space are the minimum array value and the total sum of the array, respectively. In our binary search function, for a particular <code>mid</code> value, we calculate the number of subarrays with a sum less than or equal to <code>mid</code>. If this count is greater than <code>k</code>, we need to search in the left part of the search space. Conversely, if it is less than <code>k</code>, we move to the right side.</p>
<p>To find the number of subarrays with a sum less than or equal to <code>mid</code>, we use the sliding window approach. We initialize two pointers, <code>left</code> and <code>right</code>, representing the ends of the window. If the sum of the window exceeds <code>mid</code>, we decrease the size of the window from the left side. We increment the count of windows for every valid <code>left</code> and <code>right</code> pair.</p>
<p>While counting subarrays, we also need to calculate their sum. To do this, we can determine the number of windows an element is part of by calculating <code>right - left + 1</code>. We then multiply the current element by this number and add it to a sum variable. This sum is maintained along with the count in the binary search process.</p>
<h4 id="algorithm-2">Algorithm</h4>
<p><strong>Main function - <code>rangeSum(nums,n,left,right)</code></strong></p>
<ol>
<li>Calculate <code>result</code> as the difference of <code>sumOfFirstK(nums,n,right) - sumOfFirstK(nums,n,left-1)</code>. Return this <code>result</code> after taking modulo with <code>mod</code>.</li>
</ol>
<p><strong><code>sumOfFirstK(nums,n,k)</code></strong></p>
<ol>
<li>Initialize <code>minSum</code> and <code>maxSum</code> with minimum element value in <code>nums</code> and the total sum of <code>nums</code>, respectively.</li>
<li>Initialize <code>left</code> with <code>minSum</code> and <code>right</code> with <code>maxSum</code>.</li>
<li>Iterate while <code>left &lt;= right</code>:
<ul>
<li>Initialize <code>mid</code> as the mean of <code>left</code> and <code>right</code>.</li>
<li>If <code>countAndSum(nums,n,mid)</code>'s count value is greater than or equal to <code>k</code>:
<ul>
<li>Set <code>right</code> as <code>mid - 1</code>.</li>
</ul>
</li>
<li>Otherwise, set <code>left</code> as <code>mid + 1</code>.</li>
</ul>
</li>
<li>Return the difference of <code>sum</code> and <code>left * (count - k)</code>, where <code>count</code> is the calculated count value.</li>
</ol>
<p><strong><code>countAndSum(nums,n,target)</code></strong></p>
<ol>
<li>Initialize <code>count = 0</code>, <code>currentSum = 0</code>, <code>totalSum = 0</code> and <code>windowSum = 0</code>.</li>
<li>Iterate through <code>nums</code> while <code>j &lt; n</code> and initialize <code>j</code> and <code>i</code> with 0:
<ul>
<li>Add <code>nums[j]</code> to <code>currentSum</code>.</li>
<li>Add <code>nums[j]*(j-i+1)</code> to <code>windowSum</code>.</li>
<li>While <code>currentSum</code> &gt; <code>target</code>:
<ul>
<li>Decrement <code>currentSum</code> from <code>windowSum</code>.</li>
<li>Decrement <code>nums[i]</code> from <code>currentSum</code> and increment <code>i</code>.</li>
</ul>
</li>
<li>Add <code>j-i+1</code> to <code>count</code>.</li>
<li>Add <code>windowSum</code> to <code>totalCount</code>.</li>
</ul>
</li>
<li>Return <code>{count,totalSum}</code>.</li>
</ol>
<p>!?!../Documents/1508/slideshow1.json:960,540!?!</p>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/SER6g6tf/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the size and <code>sum</code> be the total sum of the <code>nums</code> array.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n \log sum)\)</span></p>
<p>The total size of the search space is <span class="math inline">\(O(sum)\)</span>. Therefore, time complexity for binary search is <span class="math inline">\(O(\log sum)\)</span>. Inside each binary search operation, the <code>countAndSum</code> function takes <span class="math inline">\(O(n)\)</span> time.</p>
<p>Therefore, the total time complexity is given by <span class="math inline">\(O(n \cdot \log sum)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>Apart from some constant sized variables, no additional memory is used. Therefore, the total space complexity is given by <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-160">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rearrange-array-elements-by-sign/description" target="_blank" rel="noopener noreferrer">Rearrange Array Elements by Sign</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of <strong>even</strong> length consisting of an <strong>equal</strong> number of positive and negative integers.</p>

<p>You should return the array of nums such that the the array follows the given conditions:</p>

<ol>
	<li>Every <strong>consecutive pair</strong> of integers have <strong>opposite signs</strong>.</li>
	<li>For all integers with the same sign, the <strong>order</strong> in which they were present in <code>nums</code> is <strong>preserved</strong>.</li>
	<li>The rearranged array begins with a positive integer.</li>
</ol>

<p>Return <em>the modified array after rearranging the elements to satisfy the aforementioned conditions</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,-2,-5,2,-4]
<strong>Output:</strong> [3,-2,1,-5,2,-4]
<strong>Explanation:</strong>
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,1]
<strong>Output:</strong> [1,-1]
<strong>Explanation:</strong>
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>nums.length</code> is <strong>even</strong></li>
	<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5</sup></code></li>
	<li><code>nums</code> consists of <strong>equal</strong> number of positive and negative integers.</li>
</ul>

<p>&nbsp;</p>
It is not required to do the modifications in-place.</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>​<br />
[TOC]<br />
​</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-two-pointers">Approach: Two Pointers</h3>
<h4 id="intuition">Intuition</h4>
<p>The first and third conditions state that every consecutive pair of integers should have opposite signs and the resultant array should begin with a positive integer. Hence, the <code>0th</code> index shall contain a positive integer, the <code>1st</code> index shall contain a negative integer, and so on. From these conditions, we can say that all even indices of the result should have positive integers and all odd indices should have negative integers. This suggests we can use two pointers to track the even and odd indices of the resultant array <code>ans</code>.<br />
Let us now consider the second condition, which states that all integers of the same sign should be in the same order as they were in the original array <code>nums</code>. If we were to iterate over <code>nums</code> in order and populate our <code>ans</code> array using the two pointers based on the sign of the current integer, the order of the integers of the same sign would be maintained. Therefore, we can satisfy all the conditions in one pass! Note that since every other index will be odd and every other index will be even, both pointers would increment by 2 rather than 1.</p>
<h4 id="algorithm">Algorithm</h4>
<p>Let us label the two pointers to track even and odd indices as <code>posIndex</code> and <code>negIndex</code> respectively. These pointers shall be initialized with 0 for <code>posIndex</code> and 1 for <code>negIndex</code>. These indices will traverse the <code>ans</code> array which will be initialized with the same size as <code>nums</code>.<br />
Now, we'll start traversing <code>nums</code> from the <code>0th</code> index. Recall that traversing <code>nums</code> from the start will ensure that the order is maintained in our <code>ans</code> array. If a positive integer is encountered in <code>nums</code>, we'll set it in <code>ans[posIndex]</code>. Since the next positive integer should be placed in <code>posIndex + 2</code>, we'll increment <code>posIndex</code> accordingly. This process will be the same for any negative integer and <code>negIndex</code>. Since it is given that there are equal numbers of positive and negative integers, we don't stand the risk of going out of bounds with either of the two indices.</p>
<p>Let us summarize the algorithm.</p>
<ol>
<li>
<p>Initialize <code>n</code> to the size of <code>nums</code>. Initialize <code>ans</code> array of size <code>n</code>.</p>
</li>
<li>
<p>Initialize two integers <code>posIndex</code> and <code>negIndex</code> with 0 and 1 respectively.</p>
</li>
<li>
<p>Traverse <code>nums</code> from the start. Note that <code>0</code> won't be in the array according to the constraints.</p>
<p>i. If the current integer is positive, set <code>ans[posIndex]</code> equal to it. Increment <code>posIndex</code> by 2.</p>
<p>ii. If the current integer is negative, set <code>ans[negIndex]</code> equal to it. Increment <code>negIndex</code> by 2.</p>
</li>
<li>
<p>Once <code>nums</code> is fully traversed, return <code>ans</code>.</p>
</li>
</ol>
<p>!?!../Documents/2149/slideshow1.json:960,540!?!<br />
<br>​</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/hQKNvgj7/shared">code</a><br />
​</p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>​Let <span class="math inline">\(n\)</span> be the length of <code>nums</code><br />
​</p>
<ul>
<li>Time complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We traverse <code>nums</code> once and populate <code>ans</code>. Since both these arrays have size <span class="math inline">\(n\)</span>, this results in a time complexity of <span class="math inline">\(O(n)\)</span>.<br />
​</li>
</ul>
</li>
<li>Space complexity: <span class="math inline">\(O(n)\)</span>
<ul>
<li>We create an auxiliary array <code>ans</code> of size <span class="math inline">\(n\)</span>.</li>
</ul>
</li>
</ul>
<hr />
<p>​</p>
</div>
				</div>
		</div>

<div class="question-card" id="question-161">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/recover-the-original-array/description" target="_blank" rel="noopener noreferrer">Recover the Original Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">enumeration</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice had a <strong>0-indexed</strong> array <code>arr</code> consisting of <code>n</code> <strong>positive</strong> integers. She chose an arbitrary <strong>positive integer</strong> <code>k</code> and created two new <strong>0-indexed</strong> integer arrays <code>lower</code> and <code>higher</code> in the following manner:</p>

<ol>
	<li><code>lower[i] = arr[i] - k</code>, for every index <code>i</code> where <code>0 &lt;= i &lt; n</code></li>
	<li><code>higher[i] = arr[i] + k</code>, for every index <code>i</code> where <code>0 &lt;= i &lt; n</code></li>
</ol>

<p>Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays <code>lower</code> and <code>higher</code>, but not the array each integer belonged to. Help Alice and recover the original array.</p>

<p>Given an array <code>nums</code> consisting of <code>2n</code> integers, where <strong>exactly</strong> <code>n</code> of the integers were present in <code>lower</code> and the remaining in <code>higher</code>, return <em>the <strong>original</strong> array</em> <code>arr</code>. In case the answer is not unique, return <em><strong>any</strong> valid array</em>.</p>

<p><strong>Note:</strong> The test cases are generated such that there exists <strong>at least one</strong> valid array <code>arr</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,10,6,4,8,12]
<strong>Output:</strong> [3,7,11]
<strong>Explanation:</strong>
If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].
Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.
Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. 
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,3,3]
<strong>Output:</strong> [2,2]
<strong>Explanation:</strong>
If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].
Combining lower and higher gives us [1,1,3,3], which is equal to nums.
Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.
This is invalid since k must be positive.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [5,435]
<strong>Output:</strong> [220]
<strong>Explanation:</strong>
The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 * n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 1000</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li>The test cases are generated such that there exists <strong>at least one</strong> valid array <code>arr</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-162">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicates-from-sorted-array/description" target="_blank" rel="noopener noreferrer">Remove Duplicates from Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in </em><code>nums</code>.</p>

<p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p>

<ul>
	<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>
	<li>Return <code>k</code>.</li>
</ul>

<p><strong>Custom Judge:</strong></p>

<p>The judge will test your solution with the following code:</p>

<pre>
int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>

<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong> 2, nums = [1,2,_]
<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]
<strong>Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-163">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description" target="_blank" rel="noopener noreferrer">Remove Duplicates from Sorted Array II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove some duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><strong>in-place</strong></a> such that each unique element appears <strong>at most twice</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>

<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code>&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;<code>k</code>&nbsp;elements.</p>

<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>

<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a></strong> with O(1) extra memory.</p>

<p><strong>Custom Judge:</strong></p>

<p>The judge will test your solution with the following code:</p>

<pre>
int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>

<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1,2,2,3]
<strong>Output:</strong> 5, nums = [1,1,2,2,3,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,0,1,1,1,1,2,3,3]
<strong>Output:</strong> 7, nums = [0,0,1,1,2,3,3,_,_]
<strong>Explanation:</strong> Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-164">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description" target="_blank" rel="noopener noreferrer">Remove Duplicates from Sorted List II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="width: 500px; height: 142px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,3,4,4,5]
<strong>Output:</strong> [1,2,5]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="width: 500px; height: 205px;" />
<pre>
<strong>Input:</strong> head = [1,1,1,2,3]
<strong>Output:</strong> [2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-165">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-element/description" target="_blank" rel="noopener noreferrer">Remove Element</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in </em><code>nums</code><em> which are not equal to </em><code>val</code>.</p>

<p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p>

<ul>
	<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>
	<li>Return <code>k</code>.</li>
</ul>

<p><strong>Custom Judge:</strong></p>

<p>The judge will test your solution with the following code:</p>

<pre>
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i &lt; actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>

<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,2,3], val = 3
<strong>Output:</strong> 2, nums = [2,2,_,_]
<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2
<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= nums.length &lt;= 100</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
	<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-166">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-nth-node-from-end-of-list/description" target="_blank" rel="noopener noreferrer">Remove Nth Node From End of List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], n = 2
<strong>Output:</strong> [1,2,3,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [1], n = 1
<strong>Output:</strong> []
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = [1,2], n = 1
<strong>Output:</strong> [1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>sz</code>.</li>
	<li><code>1 &lt;= sz &lt;= 30</code></li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Could you do this in one pass?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-167">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/remove-palindromic-subsequences/description" target="_blank" rel="noopener noreferrer">Remove Palindromic Subsequences</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> consisting <strong>only</strong> of letters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>. In a single step you can remove one <strong>palindromic subsequence</strong> from <code>s</code>.</p>

<p>Return <em>the <strong>minimum</strong> number of steps to make the given string empty</em>.</p>

<p>A string is a <strong>subsequence</strong> of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does <strong>not</strong> necessarily need to be contiguous.</p>

<p>A string is called <strong>palindrome</strong> if is one that reads the same backward as well as forward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;ababa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> s is already a palindrome, so its entirety can be removed in a single step.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abb&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> &quot;<u>a</u>bb&quot; -&gt; &quot;<u>bb</u>&quot; -&gt; &quot;&quot;. 
Remove palindromic subsequence &quot;a&quot; then &quot;bb&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;baabb&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> &quot;<u>baa</u>b<u>b</u>&quot; -&gt; &quot;<u>b</u>&quot; -&gt; &quot;&quot;. 
Remove palindromic subsequence &quot;baab&quot; then &quot;b&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
	<li><code>s[i]</code> is either <code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-168">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reorder-list/description" target="_blank" rel="noopener noreferrer">Reorder List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">recursion</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the head of a singly linked-list. The list can be represented as:</p>

<pre>
L<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>
</pre>

<p><em>Reorder the list to be on the following form:</em></p>

<pre>
L<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;
</pre>

<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" style="width: 422px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,4,2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg" style="width: 542px; height: 222px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [1,5,2,4,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-169">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-only-letters/description" target="_blank" rel="noopener noreferrer">Reverse Only Letters</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, reverse the string according to the following rules:</p>

<ul>
	<li>All the characters that are not English letters remain in the same position.</li>
	<li>All the English letters (lowercase or uppercase) should be reversed.</li>
</ul>

<p>Return <code>s</code><em> after reversing it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "ab-cd"
<strong>Output:</strong> "dc-ba"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "a-bC-dEf-ghIj"
<strong>Output:</strong> "j-Ih-gfE-dCba"
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> s = "Test1ng-Leet=code-Q!"
<strong>Output:</strong> "Qedo1ct-eeLg=ntse-T!"
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s</code> consists of characters with ASCII values in the range <code>[33, 122]</code>.</li>
	<li><code>s</code> does not contain <code>&#39;\&quot;&#39;</code> or <code>&#39;\\&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-stack-of-letters">Approach 1: Stack of Letters</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>Collect the letters of <code>S</code> separately into a stack, so that popping the stack reverses the letters.  (Alternatively, we could have collected the letters into an array and reversed the array.)</p>
<p>Then, when writing the characters of <code>S</code>, any time we need a letter, we use the one we have prepared instead.</p>
<p><a href="https://leetcode.com/playground/CZS4Xt2M/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>S</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
<hr />
<h3 id="approach-2-reverse-pointer">Approach 2: Reverse Pointer</h3>
<p><strong>Intuition</strong></p>
<p>Write the characters of <code>S</code> one by one.  When we encounter a letter, we want to write the next letter that occurs if we iterated through the string backwards.</p>
<p>So we do just that: keep track of a pointer <code>j</code> that iterates through the string backwards.  When we need to write a letter, we use it.</p>
<p><a href="https://leetcode.com/playground/6GZqDBvz/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity:  <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the length of <code>S</code>.</p>
</li>
<li>
<p>Space Complexity:  <span class="math inline">\(O(N)\)</span>.<br />
<br /><br />
<br /></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-170">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-prefix-of-word/description" target="_blank" rel="noopener noreferrer">Reverse Prefix of Word</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>0-indexed</strong> string <code>word</code> and a character <code>ch</code>, <strong>reverse</strong> the segment of <code>word</code> that starts at index <code>0</code> and ends at the index of the <strong>first occurrence</strong> of <code>ch</code> (<strong>inclusive</strong>). If the character <code>ch</code> does not exist in <code>word</code>, do nothing.</p>

<ul>
	<li>For example, if <code>word = &quot;abcdefd&quot;</code> and <code>ch = &quot;d&quot;</code>, then you should <strong>reverse</strong> the segment that starts at <code>0</code> and ends at <code>3</code> (<strong>inclusive</strong>). The resulting string will be <code>&quot;<u>dcba</u>efd&quot;</code>.</li>
</ul>

<p>Return <em>the resulting string</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;<u>abcd</u>efd&quot;, ch = &quot;d&quot;
<strong>Output:</strong> &quot;<u>dcba</u>efd&quot;
<strong>Explanation:</strong>&nbsp;The first occurrence of &quot;d&quot; is at index 3. 
Reverse the part of word from 0 to 3 (inclusive), the resulting string is &quot;dcbaefd&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;<u>xyxz</u>xe&quot;, ch = &quot;z&quot;
<strong>Output:</strong> &quot;<u>zxyx</u>xe&quot;
<strong>Explanation:</strong>&nbsp;The first and only occurrence of &quot;z&quot; is at index 3.
Reverse the part of word from 0 to 3 (inclusive), the resulting string is &quot;zxyxxe&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> word = &quot;abcd&quot;, ch = &quot;z&quot;
<strong>Output:</strong> &quot;abcd&quot;
<strong>Explanation:</strong>&nbsp;&quot;z&quot; does not exist in word.
You should not do any reverse operation, the resulting string is &quot;abcd&quot;.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 250</code></li>
	<li><code>word</code> consists of lowercase English letters.</li>
	<li><code>ch</code> is a lowercase English letter.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a string <code>word</code> and need to reverse the prefix that starts at index <code>0</code> and ends at the first occurrence of <code>ch</code>.</p>
<p>If the <code>word</code> does not contain <code>ch</code>, we return <code>word</code> unmodified.</p>
<p>In C++, we can use built-in functions to accomplish this:</p>
<p><a href="https://leetcode.com/playground/2YXAzPy2/shared">code</a></p>
<p>This is not the most universal solution, as many programming languages do not have built-in string reverse capabilities. Additionally, strings are immutable in many programming languages.</p>
<blockquote>
<p>Immutable means something cannot be changed once it has been created.</p>
</blockquote>
<p>This problem is intended to provide practice with string manipulation, so we focus on approaches that use string manipulation techniques.</p>
<hr />
<h3 id="approach-1-stack">Approach 1: Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>Whenever a problem requires reversing a sequence, it is worth considering using a stack.</p>
<p>Stacks are a First-In-Last-Out (FILO) data structure, which means that the first items added to the stack are the last items removed from the stack. This means that if you push a sequence of items into a stack, and then remove all of the items, the sequence of items will be reversed. Learn more about stacks by reading our <a href="https://leetcode.com/explore/learn/card/queue-stack/230/usage-stack/">Stack Explore Card</a>.</p>
<p>Since strings are immutable in many programming languages, we cannot directly modify the original string. Instead, we need to build a new string incrementally. In C++, we can use a string <code>result</code> to store the answer. In Python, we can use a list, and in Java, we can use a StringBuilder.</p>
<p>To reverse <code>word</code>, we loop through the characters of <code>word</code> and push each character onto the stack until we reach the first occurrence of <code>ch</code>.</p>
<p>Once we reach the character <code>ch</code>, we can start popping the characters off the stack and appending them to the <code>result</code> string. This will reverse the prefix of the <code>word</code>.</p>
<p>After we have emptied the stack, we can append the remaining characters of the <code>word</code> (i.e., the part of the word that comes after the first occurrence of <code>ch</code>) to the <code>result</code> string, in their original order.</p>
<p>Finally, we return <code>result</code>, converting it to a string if necessary. If <code>ch</code> was not found in <code>word</code>, we return the original <code>word</code> instead.</p>
<p><img src="../Figures/2000/2000_Stack.png" alt="Stack Visualization" /></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize the following:</p>
<ul>
<li>A <code>stack</code> to store characters that need to be reversed.</li>
<li>A string or list <code>result</code> for building the reversed string.</li>
<li>A variable <code>index</code> for iterating through the characters in <code>word</code>.</li>
</ul>
</li>
<li>
<p>Loop through <code>word</code> until <code>index</code> reaches the end of <code>word</code>:</p>
<ul>
<li>Push the character <code>word[index]</code> onto the <code>stack</code>.</li>
<li>If the current character equals <code>ch</code>:
<ul>
<li>Pop each of the characters from the stack and add them to the <code>result</code></li>
<li>Increment <code>index</code> by <code>1</code> because we already added <code>ch</code> to the <code>result</code>.</li>
<li>Add the rest of the characters from <code>word</code> to <code>result</code>.</li>
<li>Return <code>result</code> and convert to a string if necessary.</li>
</ul>
</li>
<li>Increment <code>index</code> by <code>1</code>; we have not yet reached <code>ch</code>.</li>
</ul>
</li>
<li>
<p>Return <code>word</code>, which does not contain <code>ch</code>.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/3myFaghr/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Finding <code>ch</code> in <code>word</code> and adding the characters to the stack takes up to <span class="math inline">\(O(n)\)</span> when <code>ch</code> is the last character in <code>word</code>.</p>
<p>Adding the characters to <code>result</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>Therefore, the time complexity is <span class="math inline">\(O(2n)\)</span>, which we can simplify to <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>stack</code> which can grow to contain up to <span class="math inline">\(n\)</span> elements, so the space complexity is <span class="math inline">\(O(n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-find-the-index-and-fill-result">Approach 2: Find the Index and Fill Result</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We usually read text from left to right. Reading right to left, the text will appear reversed.</p>
<p>To reverse the prefix, we can &quot;read&quot; the prefix in reverse order (end to beginning and right to left).</p>
<p>First, we need to find the end of the prefix. This will be the index in <code>word</code> of the first occurrence of <code>ch</code>. Most languages have a built-in function we can use to locate the index of a character in a string, which we will use to find <code>chIndex</code>.</p>
<p>If <code>ch</code> is not in <code>word</code>, we return <code>word</code> unaltered.</p>
<p>Similar to the previous solution, we will add characters to <code>result</code> one by one. To traverse <code>word</code> from the end of the prefix to the beginning while adding characters to <code>result</code>, we can use a standard <code>for</code> loop with <code>word[chIndex - i]</code>.</p>
<p>Once the prefix has been added to the <code>result</code>, we can then proceed with the <code>for</code> loop, appending <code>word[i]</code> to the result.</p>
<p>Finally, we return <code>result</code>, and if necessary, convert it to a string.</p>
<p><img src="../Figures/2000/2000_Find.png" alt="Find Visualization" /></p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Find the index of <code>ch</code> in <code>word</code> and set the variable <code>chIndex</code> to this value.</p>
</li>
<li>
<p>If <code>chIndex</code> equals <code>-1</code>, <code>ch</code> is not in <code>word</code>, so return <code>word</code>.</p>
</li>
<li>
<p>Initialize a string or list <code>result</code> for building the string with the reversed prefix.</p>
</li>
<li>
<p>Loop through the characters of <code>word</code> using the iterator <code>i</code>:</p>
<ul>
<li>If <code>i</code> is less than or equal to <code>chIndex</code>, the character at this index of <code>result</code> should be the corresponding character from <code>word</code> but in reverse. Append <code>word[chIndex - i]</code> to <code>result</code>.</li>
<li>Otherwise, the character at this index of <code>result</code> should contain a character in the original order. Append <code>word[i]</code> to <code>result</code>.</li>
</ul>
</li>
<li>
<p>Return <code>result</code>, converting it to a string if necessary.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/95qiEEDM/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<p>Certainly. I'll provide a more detailed explanation for each point:</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span> or <span class="math inline">\(O(n^2)\)</span></p>
<p>The time complexity varies across implementations:</p>
<ul>
<li>In Java, using <code>StringBuilder</code> results in <span class="math inline">\(O(n)\)</span>. The <code>append()</code> operation is <span class="math inline">\(O(1)\)</span>, and we perform it <span class="math inline">\(n\)</span> times.</li>
<li>In Python, string concatenation inside the loop leads to <span class="math inline">\(O(n^2)\)</span>. Each '+=' operation creates a new string, taking <span class="math inline">\(O(n)\)</span> time, and we do this <span class="math inline">\(n\)</span> times.</li>
<li>In C++, using <code>std::string</code> results in <span class="math inline">\(O(n)\)</span>. The concetanation(+=) is <span class="math inline">\(O(1)\)</span> as C++ strings are mutable, and we perform it <span class="math inline">\(n\)</span> times.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span></p>
<p>We use <code>result</code>, which has a size of <span class="math inline">\(n\)</span>, to build the answer.</p>
<p>The space usage is consistent across implementations:</p>
<ul>
<li>In Java, using <code>StringBuilder</code> results in <span class="math inline">\(O(n)\)</span>. It preallocates space efficiently.</li>
<li>In Python, despite creating multiple strings, only one full-length string exists at any time, so <span class="math inline">\(O(n)\)</span>. However, it may use more memory during execution due to the creation of temporary strings.</li>
<li>In C++, using <code>std::string</code> results in <span class="math inline">\(O(n)\)</span>. C++ strings are mutable so the performance considerations of concatenation(+=) are less of a concern.</li>
</ul>
<p>Therefore, the space complexity is <span class="math inline">\(O(n)\)</span> for all implementations. While the actual memory usage may vary slightly, the asymptotic space complexity remains the same.</p>
</li>
</ul>
<blockquote>
<p>Note: The main difference in efficiency comes from how each language handles string manipulations. Java's StringBuilder and C++'s string are optimized for repeated concatenations, while Python's strings, being immutable, require more operations for the same task.</p>
</blockquote>
<h3 id="approach-3-two-pointer-swapping">Approach 3: Two-Pointer Swapping</h3>
<h4 id="intuition-2">Intuition</h4>
<p>When we reverse a string, the characters at the ends are swapped. Likewise, the characters one spot away from the ends are swapped.</p>
<p>This reversal strategy can be performed in place, as demonstrated in this problem: <a href="https://leetcode.com/problems/reverse-string/editorial/">344 Reverse String</a>. However, this problem differs from the one at hand since the input is provided as a character array instead of a string.</p>
<p>We can utilize this strategy by initially adding the characters from <code>word</code> to <code>result</code>, where <code>result</code> is a list or array of characters.</p>
<p>We iterate through <code>result</code> using <code>right</code> until it reaches the first occurrence of <code>ch</code>. If <code>ch</code> is not in <code>word</code>, we return <code>word</code>.</p>
<p>Subsequently, we traverse through the prefix of <code>result</code> with two pointers, <code>left</code> pointing to the beginning of the prefix and <code>right</code> pointing to the end of the prefix, until they meet in the middle. During each iteration, we swap the values at the indices <code>left</code> and <code>right</code>, then progress each pointer one step towards each other.</p>
<p>Finally, we return <code>result</code> and convert it to a string if necessary.</p>
<p><img src="../Figures/2000/2000_Two-Pointer.png" alt="Swapping Visualization" /></p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
<li>
<p>Initialize a string or list <code>result</code> for building the string with the reversed prefix.</p>
</li>
<li>
<p>Initialize a pointer <code>left</code> to <code>0</code>.</p>
</li>
<li>
<p>Use a <code>for</code> loop to iterate through <code>result</code>, using the iterator <code>right</code>:</p>
<ul>
<li>If <code>result[right]</code> is equal to <code>ch</code>:
<ul>
<li>While <code>left</code> is less than <code>right</code>, swap the characters of <code>result</code> at indices <code>left</code> and <code>right</code>, then increment <code>left</code> and decrement <code>right</code>.</li>
</ul>
</li>
<li>After the loop, return <code>result</code> and convert it to a string if needed.</li>
</ul>
</li>
<li>
<p>If the loop completes without finding <code>ch</code>, return the original <code>word</code>.</p>
</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/h7nii6YC/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>word</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>Copying <code>word</code> to <code>result</code> takes <span class="math inline">\(O(n)\)</span>.</p>
<p>In the worst case scenario, when <code>ch</code> is located at the last index of <code>word</code>, we traverse <code>result</code> once to find <code>ch</code>, and then we swap <span class="math inline">\(\frac{n}{2}\)</span> elements.</p>
<p>Therefore, the time complexity remains <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(n)\)</span> (Python and Java) or <span class="math inline">\(O(1)\)</span> (C++)</p>
<p>We use the <code>result</code> array of size <span class="math inline">\(n\)</span> to store and reverse the letters from <code>word</code>.</p>
<blockquote>
<p><strong>Note:</strong> The C++ version uses <span class="math inline">\(O(1)\)</span> space because the characters are reversed in place instead of using an auxiliary data structure. It is recommended to check with your interviewer before modifying the input, as it might lead to issues in certain scenarios.</p>
</blockquote>
<hr />
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-171">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-string/description" target="_blank" rel="noopener noreferrer">Reverse String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>

<p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a> with <code>O(1)</code> extra memory.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = ["h","e","l","l","o"]
<strong>Output:</strong> ["o","l","l","e","h"]
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = ["H","a","n","n","a","h"]
<strong>Output:</strong> ["h","a","n","n","a","H"]
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is a <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank">printable ascii character</a>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-172">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-string-ii/description" target="_blank" rel="noopener noreferrer">Reverse String II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>

<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code> characters and leave the other as original.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "abcdefg", k = 2
<strong>Output:</strong> "bacdfeg"
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "abcd", k = 2
<strong>Output:</strong> "bacd"
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists of only lowercase English letters.</li>
	<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<hr />
<h3 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h3>
<p><strong>Intuition and Algorithm</strong></p>
<p>We will reverse each block of <code>2k</code> characters directly.</p>
<p>Each block starts at a multiple of <code>2k</code>: for example, <code>0, 2k, 4k, 6k, ...</code>. One thing to be careful about is we may not reverse each block if there aren't enough characters.</p>
<p>To reverse a block of characters from <code>i</code> to <code>j</code>, we can swap characters in positions <code>i++</code> and <code>j--</code>.</p>
<p><a href="https://leetcode.com/playground/ke3DMSV2/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span>, where <span class="math inline">\(N\)</span> is the size of <code>s</code>. We build a helper array, plus reverse about half the characters in <code>s</code>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span>, the size of <code>a</code>.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-173">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-vowels-of-a-string/description" target="_blank" rel="noopener noreferrer">Reverse Vowels of a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>

<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;IceCreAm&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;AceCreIm&quot;</span></p>

<p><strong>Explanation:</strong></p>

<p>The vowels in <code>s</code> are <code>[&#39;I&#39;, &#39;e&#39;, &#39;e&#39;, &#39;A&#39;]</code>. On reversing the vowels, s becomes <code>&quot;AceCreIm&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;leetcode&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">&quot;leotcede&quot;</span></p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-174">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-words-in-a-string/description" target="_blank" rel="noopener noreferrer">Reverse Words in a String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>

<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>

<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>

<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;the sky is blue&quot;
<strong>Output:</strong> &quot;blue is sky the&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;  hello world  &quot;
<strong>Output:</strong> &quot;world hello&quot;
<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;a good   example&quot;
<strong>Output:</strong> &quot;example good a&quot;
<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>
	<li>There is <strong>at least one</strong> word in <code>s</code>.</li>
</ul>

<p>&nbsp;</p>
<p><b data-stringify-type="bold">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type="bold">in-place</b>&nbsp;with&nbsp;<code data-stringify-type="code">O(1)</code>&nbsp;extra space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-175">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/reverse-words-in-a-string-iii/description" target="_blank" rel="noopener noreferrer">Reverse Words in a String III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;Let&#39;s take LeetCode contest&quot;
<strong>Output:</strong> &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;Mr Ding&quot;
<strong>Output:</strong> &quot;rM gniD&quot;
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> contains printable <strong>ASCII</strong> characters.</li>
	<li><code>s</code> does not contain any leading or trailing spaces.</li>
	<li>There is <strong>at least one</strong> word in <code>s</code>.</li>
	<li>All the words in <code>s</code> are separated by a single space.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>The problem is a variation of similar reverse string problems, <a href="https://leetcode.com/problems/reverse-words-in-a-string/">Reverse Words In a String</a> and <a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/">Reverse Words In String II</a>.</p>
<p>In the first one, we had to reverse all characters, and in the second variation, we had to reverse the order of words. In this problem, we have to reverse the characters of each word in the sentences.</p>
<hr />
<h3 id="approach-1-traverse-and-reverse-each-character-one-by-one">Approach 1: Traverse and Reverse each character one by one</h3>
<p><strong>Intuition</strong></p>
<p>To solve the problem let's look at the example carefully,</p>
<pre><code>Input: &quot;Let's take LeetCode contest&quot;`

Output: &quot;s'teL ekat edoCteeL tsetnoc&quot;
</code></pre>
<p>There are a few observations here,</p>
<ul>
<li>
<p>The characters of each word in the string are reversed, but the order of words remains the same.</p>
<p>For example, in the input, the word <code>Let's</code> is the first word in the string. In the output, the characters in the word <code>Let's</code> are reversed to <code>s'teL</code>. But it is still at the first position in the string.<br />
Similarly the second word <code>take</code> is reversed as <code>ekat</code> and placed at the same second position in the output string.</p>
</li>
<li>
<p>The words in the string are separated by a space character. So we can say that to build the output string, we must extract and reverse the substring between 2 consecutive space characters.</p>
<p><img src="../Figures/557/second_observation.png" alt="Second Observation Illustration" /></p>
</li>
</ul>
<p>Using this intuition, let's understand how to implement this problem.</p>
<p><strong>Algorithm</strong></p>
<p>By analyzing the above two key observations, we can derive the following algorithm,</p>
<ul>
<li>
<p>Find the starting and ending position of each word in the string.</p>
<p>As a space character is a separator for each word, we are finding the substrings having a space character before its first character and after its last character.</p>
<blockquote>
<p>Note: Take care of 2 edge cases here, the first word does not have a space before its first character. Similarly, the last word does not have a space after its last character.</p>
</blockquote>
</li>
<li>
<p>For each identified word, reverse the characters of the word one by one.</p>
</li>
</ul>
<p><em>Steps</em></p>
<p>Traverse the string from left to right, starting from <span class="math inline">\(0^{th}\)</span> to <span class="math inline">\(n^{th}\)</span> index. As we traverse, the pointer <code>strIndex</code> tracks each character.<br />
The implementation can be divided into 2 steps,</p>
<ol>
<li>
<p>Find the start and end index of every word</p>
<ul>
<li>
<p>Traverse over the string until the current pointer <code>strIndex</code> points to a space character.</p>
</li>
<li>
<p>As <code>strIndex</code> points to the space character, the index <code>strIndex - 1</code> points to the last character of the current word.</p>
<p><img src="../Figures/557/current_pointer_traversal.png" alt="Current Pointer Traversal" /></p>
</li>
<li>
<p>Let's understand how to find the first character of the word,</p>
<ul>
<li>
<p>For the first word, its first character is always the first character of the string.</p>
</li>
<li>
<p>For the remaining words, the first character would be the character after the last space character.</p>
<p>Thus, to mark the start of the current character, we must keep track of the last found space character. Let's use a variable <code>lastSpaceIndex</code>. The variable will be initialized to <code>-1</code>  and updated every time we find the next space character.</p>
<p><img src="../Figures/557/start_and_end_index.png" alt="Mark Start And End Index" /></p>
<p>The first character of the current word is thus <code>lastSpaceIndex + 1</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Reverse the characters within the word</p>
<ul>
<li>
<p>Now that we have the first and last index of the current word, we have to reverse the current word and append it to the result string.</p>
</li>
<li>
<p>To reverse the current word, we can traverse it in reverse order i.e start from the end index <code>strIndex - 1</code> to the first index i.e <code>lastSpaceIndex + 1</code>, appending each character one by one to the result string.</p>
</li>
<li>
<p>To separate the current word from the next, append a space character (&quot; &quot;) at the end after the reverse operation. However, for the last word, this step is skipped.</p>
</li>
</ul>
</li>
</ol>
<p>Repeat 1 and 2 for all the words in the string.</p>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/FhDtNBbw/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the length of input string <code>s</code>.</p>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> Every character in the string is traversed twice. First, to find the end of the current word, and second to reverse the word and append it to the result. Thus the time complexity is, <span class="math inline">\(\mathcal{O}(N + N) = \mathcal{O}(N)\)</span>.</p>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(1)\)</span> We use constant extra space to track the last space index. You could also argue that we are using <span class="math inline">\(O(n)\)</span> space to build the output string (we normally don't count the output as part of the space complexity, but in this case we are temporarily using some space to build it).</p>
<hr />
<h3 id="approach-2-using-two-pointers">Approach 2: Using Two Pointers</h3>
<p><strong>Intuition</strong></p>
<p>In the previous approach, the words were reversed by copying every character into another string one by one in reverse order. This operation takes <span class="math inline">\(\mathcal{O}(N)\)</span> time, where <code>N</code> is the length of the word.</p>
<p>However, there is another optimal approach to reverse the string in <span class="math inline">\(\mathcal{O}(N/2)\)</span> time in place using two pointer approach.</p>
<p>In this solution, we will traverse the string and find every word's start and end index. Then, we will reverse each word using the two-pointer approach.</p>
<p><em>Approach to reverse a string using a two-pointer approach</em></p>
<ol>
<li>
<p>Find the start and end index of every word given by <code>startIndex</code> and <code>endIndex</code>.</p>
</li>
<li>
<p>Swap the characters in the word pointed by <code>startIndex</code> and <code>endIndex</code>.</p>
</li>
<li>
<p>Increment <code>startIndex</code> by 1 and decrement <code>endIndex</code> by 1.</p>
</li>
<li>
<p>While <code>startIndex &lt; endIndex</code>, repeat steps 2 and 3.</p>
<p><img src="../Figures/557/2_pointer_approach.png" alt="Two Pointer Approach To Reverse String" /></p>
</li>
</ol>
<p>Here's the code snippet for reversing the string stored in character array <code>chArray</code> using two pointer approach.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span>startIndex <span style="color:#000;font-weight:bold">&lt;</span> endIndex<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">char</span> temp <span style="color:#000;font-weight:bold">=</span> chArray<span style="color:#000;font-weight:bold">[</span>startIndex<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        chArray<span style="color:#000;font-weight:bold">[</span>startIndex<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> chArray<span style="color:#000;font-weight:bold">[</span>endIndex<span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>        chArray<span style="color:#000;font-weight:bold">[</span>endIndex<span style="color:#000;font-weight:bold">]</span> <span style="color:#000;font-weight:bold">=</span> temp<span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>        startIndex<span style="color:#000;font-weight:bold">++;</span>
</span></span><span style="display:flex;"><span>        endIndex<span style="color:#000;font-weight:bold">--;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre><p><strong>Algorithm</strong></p>
<ul>
<li>
<p>The variable <code>lastSpaceIndex</code> stores the index of space character last found. Initialize its value to <code>-1</code>.</p>
</li>
<li>
<p>Traverse over each character of the string from <span class="math inline">\(0^{th}\)</span> index to <span class="math inline">\(n^{th}\)</span> index using pointer <code>strIndex</code>.</p>
</li>
<li>
<p>As <code>strIndex</code> points to a space character, mark the start and end index of the current word in the variables <code>startIndex</code> and <code>endIndex</code> as,</p>
<ul>
<li>The <code>startIndex</code> of the current word is the value of <code>lastSpaceIndex + 1</code>.</li>
<li>The <code>endIndex</code> of the current word is the value of <code>strIndex - 1</code>.</li>
</ul>
</li>
<li>
<p>Reverse the characters in the current word using two pointer approach.</p>
</li>
<li>
<p>Update the <code>lastSpaceIndex</code> to the value of <code>strIndex</code> i.e the index of current space character. The next iteration will refer to this variable to identify the start position of the next word.</p>
</li>
<li>
<p>Repeat the process for all the words in the string.</p>
</li>
</ul>
<p><strong>Implementation</strong></p>
<p><a href="https://leetcode.com/playground/btY3HPsv/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<p>Let <span class="math inline">\(N\)</span> be the length of string <code>s</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(\mathcal{O}(N)\)</span> The outer loop iterates over <span class="math inline">\(\text{N}\)</span> characters to find the <code>start</code> and <code>end</code> index of every word. The algorithm to reverse the word also iterates <span class="math inline">\(\text{N}\)</span> times to perform <span class="math inline">\(\text{N/2}\)</span> swaps. Thus, the time complexity is <span class="math inline">\(\mathcal{O}(N + N) = {O}(N)\)</span>.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(\mathcal{O}(1)\)</span> We use constant extra space to track the last space index. You could also argue that we are using <span class="math inline">\(O(n)\)</span> space to build the output string (we normally don't count the output as part of the space complexity, but in this case we are temporarily using some space to build it).</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-176">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotate-array/description" target="_blank" rel="noopener noreferrer">Rotate Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>Output:</strong> [5,6,7,1,2,3,4]
<strong>Explanation:</strong>
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-1,-100,3,99], k = 2
<strong>Output:</strong> [3,99,-1,-100]
<strong>Explanation:</strong> 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
	<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong></p>

<ul>
	<li>Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.</li>
	<li>Could you do it in-place with <code>O(1)</code> extra space?</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-177">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotate-list/description" target="_blank" rel="noopener noreferrer">Rotate List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked&nbsp;list, rotate the list to the right by <code>k</code> places.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 450px; height: 191px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [4,5,1,2,3]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 305px; height: 350px;" />
<pre>
<strong>Input:</strong> head = [0,1,2], k = 4
<strong>Output:</strong> [2,0,1]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li>
	<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
	<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-178">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/rotating-the-box/description" target="_blank" rel="noopener noreferrer">Rotating the Box</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given an <code>m x n</code> matrix of characters <code>boxGrid</code> representing a side-view of a box. Each cell of the box is one of the following:</p>

<ul>
	<li>A stone <code>&#39;#&#39;</code></li>
	<li>A stationary obstacle <code>&#39;*&#39;</code></li>
	<li>Empty <code>&#39;.&#39;</code></li>
</ul>

<p>The box is rotated <strong>90 degrees clockwise</strong>, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity <strong>does not</strong> affect the obstacles&#39; positions, and the inertia from the box&#39;s rotation <strong>does not </strong>affect the stones&#39; horizontal positions.</p>

<p>It is <strong>guaranteed</strong> that each stone in <code>boxGrid</code> rests on an obstacle, another stone, or the bottom of the box.</p>

<p>Return <em>an </em><code>n x m</code><em> matrix representing the box after the rotation described above</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png" style="width: 300px; height: 150px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]
<strong>Output:</strong> [[&quot;.&quot;],
&nbsp;        [&quot;#&quot;],
&nbsp;        [&quot;#&quot;]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png" style="width: 375px; height: 195px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;.&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;]]
<strong>Output:</strong> [[&quot;#&quot;,&quot;.&quot;],
&nbsp;        [&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;*&quot;,&quot;*&quot;],
&nbsp;        [&quot;.&quot;,&quot;.&quot;]]
</pre>

<p><strong class="example">Example 3:</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png" style="width: 400px; height: 218px;" /></p>

<pre>
<strong>Input:</strong> boxGrid = [[&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;*&quot;,&quot;.&quot;,&quot;.&quot;],
&nbsp;             [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;]]
<strong>Output:</strong> [[&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;],
&nbsp;        [&quot;#&quot;,&quot;#&quot;,&quot;*&quot;],
&nbsp;        [&quot;#&quot;,&quot;*&quot;,&quot;.&quot;],
&nbsp;        [&quot;#&quot;,&quot;.&quot;,&quot;*&quot;],
&nbsp;        [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == boxGrid.length</code></li>
	<li><code>n == boxGrid[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 500</code></li>
	<li><code>boxGrid[i][j]</code> is either <code>&#39;#&#39;</code>, <code>&#39;*&#39;</code>, or <code>&#39;.&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given an <code>m x n</code> grid that represents the side view of a box, containing stones (denoted as <code>'#'</code>) and immovable obstacles (denoted as <code>'*'</code>), as well as some empty cells in between (<code>'.'</code>).</p>
<p>Our task is to simulate a 90-degree clockwise rotation of this box. After rotating, we must apply &quot;gravity&quot; to make the rocks fall as far down as possible, without moving the obstacles. The goal is to return the final layout of the box, as a new <code>n x m</code> grid, after both the rotation and gravity effects.</p>
<hr />
<h3 id="approach-1-row-by-row-brute-force">Approach 1: Row by Row (Brute Force)</h3>
<h4 id="intuition">Intuition</h4>
<p>In this approach, we separate the task into two distinct operations: first, rotating the grid; then, applying the gravity effect. We execute each operation independently to simplify the process.</p>
<h6 id="1-rotate-the-grid">1. Rotate the grid</h6>
<p>Let's start by observing how the grid changes after a 90-degree clockwise rotation:</p>
<ul>
<li>The first row of the input grid becomes the last column of the output grid.</li>
<li>The second row of the input grid becomes the second-to-last column of the output grid.</li>
<li>...</li>
<li>The last row of the input grid becomes the first column of the output grid.</li>
</ul>
<blockquote>
<p>The <strong>transpose</strong> of a matrix is obtained by interchanging rows into columns or columns to rows.</p>
</blockquote>
<p>If you aren't familiar with this concept, you might want to try out this problem first: <a href="https://leetcode.com/problems/transpose-matrix/description/">867. Transpose Matrix</a>, as a good lead-in to this one.<br />
Let's try to express this pattern, using the <strong>transpose</strong> of the original grid:</p>
<ul>
<li>The first column of the transpose grid becomes the last column of the output grid.</li>
<li>The second column of the transpose grid becomes the second-to-last column of the output grid.</li>
<li>...</li>
<li>The last column of the transpose grid becomes the first column of the output grid.</li>
</ul>
<p>We can break down this rotation step further: first, find the transpose of the input grid, then reverse each row in the transpose grid.</p>
<p><img src="../Figures/1861/1861_rotate_operation.png" alt="rotate operation" /></p>
<h6 id="2-apply-the-gravity-effect">2. Apply the gravity effect</h6>
<p>To apply the gravity effect to the rotated grid, we can follow a simple approach: for each empty cell, identify the first stone directly above it, ensuring there are no obstacles in between. This way, each stone falls to the lowest possible empty cell beneath it.</p>
<p>!?!../Documents/1861/1861_approach1_fix.json:960,540!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>.</li>
<li>Set <code>result</code> to be the transpose of the input grid:
<ul>
<li>Iterate over the rows with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>Iterate over the columns with <code>j</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Set <code>result[j][i] = box[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Reverse the order of elements in each row of the transpose grid.</li>
<li>Iterate over the columns of the rotated grid with <code>j</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each column <code>j</code>, iterate over its elements with <code>i</code> from <code>n-1</code> to <code>0</code>:
<ul>
<li>If <code>result[i][j]</code> is an empty cell:
<ul>
<li>Initialize <code>nextRowWithStone</code> to <code>-1</code>.</li>
<li>Loop through all rows above <code>i</code> with <code>k</code> from <code>i-1</code> to <code>0</code>.
<ul>
<li>If <code>result[k][j]</code> contains an obstacle, exit the loop.</li>
<li>If <code>result[k][j]</code> contains a stone, set <code>nextRowWithStone</code> equal to <code>k</code> and exit the loop.</li>
</ul>
</li>
<li>If the loop ends and <code>nextRowWithStone</code> remains equal to <code>-1</code>, no stone exists above the current empty cell with no obstacles in between; continue.</li>
<li>Else, let the stone in <code>result[nextRowWithStone][j]</code> land on <code>result[i][j]</code> by setting <code>result[nextRowWithStone][j] = '.'</code> and <code>result[i][j] = '#'</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/Po6ADV3z/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n^2)\)</span></p>
<p>We need to access each cell to compute the transpose of the grid. This requires <span class="math inline">\(O(m \times n)\)</span> time since there are <span class="math inline">\(m\)</span> rows and <span class="math inline">\(n\)</span> columns in the grid.</p>
<p>After transposing, we reverse each of the <span class="math inline">\(n\)</span> rows. Reversing a row involves swapping elements from the start and end until we reach the middle, which takes <span class="math inline">\(O(m)\)</span> time per row. Since there are <span class="math inline">\(n\)</span> rows, the total time for this operation is: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The gravity effect is implemented using an outer loop that iterates through the <span class="math inline">\(m\)</span> columns. For each column, two inner nested loops iterate through the rows:</p>
<ul>
<li>The first inner loop checks each row from the bottom to the top, running up to <span class="math inline">\(O(n)\)</span> times.</li>
<li>The second inner loop checks the rows above the current empty cell to find a stone, which in the worst case can also iterate up to <span class="math inline">\(O(n)\)</span> times.</li>
</ul>
<p>Therefore, for each column, the worst-case scenario for the gravity application results in <span class="math inline">\(O(n) \times O(n) = O(n^2)\)</span></p>
<p>Consequently, for all <span class="math inline">\(m\)</span> columns, the total time complexity for applying gravity is <span class="math inline">\(O(m \times n^2)\)</span></p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Since we avoid modifying the input, we create a second grid, <code>result</code>, of size <span class="math inline">\(n \times m\)</span>. Note that if we were allowed to alter the input directly, we could reduce the space complexity to <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-row-by-row-optimized">Approach 2: Row By Row (Optimized)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When optimizing our solution, it's important to consider the lower bound of the algorithm's complexity. In this case, we need to somehow fill an <span class="math inline">\(n \times m\)</span> grid, with a minimum required time of <span class="math inline">\(O(m \times n)\)</span>.</p>
<p>This prompts us to investigate whether we can reduce the time complexity of our previous approach to this lower bound. It turns out that we can achieve this because the third inner loop, which currently increases the time complexity to <span class="math inline">\(O(m \times n^2)\)</span>, is actually redundant.</p>
<p>Specifically, instead of checking each empty cell to see if a stone can land on it, we can maintain a pointer to the lowest empty cell in the current column that has no obstacles above it. When we encounter a stone, we allow it to fall to the cell indicated by this pointer and then update the pointer to the row directly above where the stone landed. If we encounter an obstacle, we reset the pointer to the row directly above the obstacle.</p>
<p>We will use the <a href="#1-rotate-the-grid">same algorithm</a> from our initial approach to simulate the rotation of the grid, before applying the gravity effect as described above.</p>
<p>!?!../Documents/1861/1861_approach2_fix.json:960,540!?!</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>.</li>
<li>Set <code>result</code> to be the transpose of the input grid:
<ul>
<li>Iterate over the rows with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>Iterate over the columns with <code>j</code> from <code>0</code> to <code>n-1</code>:
<ul>
<li>Set <code>result[j][i] = box[i][j]</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Reverse the order of elements in each row of the transpose grid.</li>
<li>Iterate over the columns of the rotated grid with <code>j</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each column <code>j</code>:
<ul>
<li>Initialize a variable <code>lowestRowWithEmptyCell</code> to <code>n-1</code></li>
<li>Iterate over all of its elements in reversed order with <code>i</code> from <code>n-1</code> to <code>0</code>. On each iteration:
<ul>
<li>If <code>result[i][j]</code> contains a stone, let it fall to the lowest empty cell:
<ul>
<li>Set <code>result[lowestRowWithEmptyCell][j] = '#'</code>.</li>
<li>Set <code>result[i][j] = '.'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
<li>if <code>result[i][j]</code> contains an obstacle, set <code>lowestRowWithEmptyCell = i-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/S8dHpXwx/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Similar to the first approach, the rotation operation takes <span class="math inline">\(O(m \times n)\)</span> time. The gravity effect is now implemented using two nested loops instead of three. The outer loop iterates over the <span class="math inline">\(m\)</span> columns, and for each column, the inner loop processes all <span class="math inline">\(n\)</span> elements. As a result, the total time complexity of the algorithm remains <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Once again, we avoid modifying the input directly by creating a second grid, <code>result</code>, of size <span class="math inline">\(n \times m\)</span>. However, if we were allowed to modify the input in place, the space complexity could be reduced to <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-combine-rotation-and-gravity-operations">Approach 3: Combine rotation and gravity operations</h3>
<h4 id="intuition-2">Intuition</h4>
<p>As mentioned earlier, the time complexity of <span class="math inline">\(O(m \times n)\)</span> achieved with the second approach represents a lower bound for this particular problem. This means we cannot further optimize our algorithm in terms of complexity. However, in this approach, we aim to streamline our code by combining the operations of rotation and the effects of gravity. This will allow us to generate the result in a single pass instead of three, potentially reducing the runtime of our program.</p>
<p>First, let's derive the formula to find the position of the cell originally located at <span class="math inline">\((i, j)\)</span> in the rotated grid. Following the strategy outlined for the transpose grid, we will first map the position <span class="math inline">\((i, j)\)</span> to <span class="math inline">\((j, i)\)</span>. Then, we will reverse each row, meaning that the first element becomes the last, the second element becomes the second-to-last, and so on. Specifically, the element at index <span class="math inline">\(i\)</span> will move to the position <span class="math inline">\(m-i-1\)</span>. Combining these two conversions, we get that the cell originally located at <span class="math inline">\((i, j)\)</span> will end up in the position <span class="math inline">\((j, m-i-1)\)</span>.</p>
<p>Now, we are ready to execute the same algorithm as before. This time, we will read the type of each cell from the original grid, <code>box</code>, and place the results into the <code>result</code> grid using the positions determined by the formula outlined above.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ul>
<li>Initialize <code>m</code> and <code>n</code> to the number of rows and columns of the original grid, respectively.</li>
<li>Create an <code>n x m</code> grid, called <code>result</code>, and initialize all of its elements to be empty cells (<code>'.'</code>).</li>
<li>Iterate over the rows of the original grid, <code>box</code>, with <code>i</code> from <code>0</code> to <code>m-1</code>:
<ul>
<li>For each row <code>i</code>, initialize a variable <code>lowestRowWithEmptyCell</code> to <code>n-1</code>.</li>
<li>Iterate over all of its elements in reversed order with <code>j</code> from <code>n-1</code> to <code>0</code>. On each iteration:
<ul>
<li>If <code>box[i][j]</code> contains a stone, let it fall to the lowest empty cell:
<ul>
<li>Set <code>result[lowestRowWithEmptyCell][m-i-1] = '#'</code>.</li>
<li>(Optionally) Set <code>result[j][m-i-1] = '.'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
<li>If <code>box[i][j]</code> contains an obstacle:
<ul>
<li>Set <code>result[j][m-i-1] = '*'</code>.</li>
<li>Update <code>lowestRowWithEmptyCell</code> to <code>i-1</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>result</code>.</li>
</ul>
<h4 id="implementation-2">Implementation</h4>
<p><a href="https://leetcode.com/playground/WNSuvFk7/shared">code</a></p>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>The rotation of the grid and the gravity effect are implemented using two nested loops. The outer loop iterates over the <span class="math inline">\(m\)</span> rows of the original grid, and for each row, the inner loop processes all <span class="math inline">\(n\)</span> elements. Therefore, the total time complexity of the algorithm is <span class="math inline">\(O(m \times n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m \times n)\)</span></p>
<p>Similar to the other two approaches, we prefer not to modify the input, by creating a new <span class="math inline">\(n \times m\)</span> grid.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-179">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/row-with-max-1s--162208/1" target="_blank" rel="noopener noreferrer">Row with Max 1s</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search</span> <span class="topic-badge">matrix</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given a 2D&nbsp;</span><span style="font-size: 18px;">binary matrix</span><strong style="font-size: 18px;">&nbsp;mat[][] </strong><span style="font-size: 18px;"><span style="font-size: 18px;">of size n x m,&nbsp;where each row contains only 0s and 1s, and each row is sorted in </span><strong style="font-size: 18px;">non-decreasing</strong><span style="font-size: 18px;"> order (all the 0s come before any 1s).</span><br /><span style="font-size: 18px;">Find the <strong>index </strong>of the <strong>row </strong>that contains the highest number of <strong>1s</strong>.</span></span></p>
<p><strong style="font-size: 18px;">Note:&nbsp;</strong><span style="font-size: 18px;">If multiple rows have the same maximum count of 1s, return the row with the smallest index.</span></p>
<p><strong><span style="font-size: 18px;">Examples :</span></strong></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[0, 0, 1, 1],<br />                [0, 1, 1, 1],<br />                [0, 0, 0, 1]]
<strong>Output: </strong>1
<strong>Explanation: </strong>Row at index 1 has three 1s, which is the highest among all rows.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>mat[][] = [[1, 1, 1],<br />                [0, 1, 1],<br />                [1, 1, 1]]
<strong>Output: </strong>0
<strong>Explanation: </strong>The first row (index 0) and the last row (index 2) both contain three 1s, which is the maximum among all rows. Since we return the smallest index in case of a tie, the answer is 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; n, m &le; 1000<br /></span><span style="font-size: 18px;">0 &le; mat[i][j] &le; 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-180">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sentence-similarity-iii/description" target="_blank" rel="noopener noreferrer">Sentence Similarity III</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>sentence1</code> and <code>sentence2</code>, each representing a <strong>sentence</strong> composed of words. A sentence is a list of <strong>words</strong> that are separated by a <strong>single</strong> space with no leading or trailing spaces. Each word consists of only uppercase and lowercase English characters.</p>

<p>Two sentences <code>s1</code> and <code>s2</code> are considered <strong>similar</strong> if it is possible to insert an arbitrary sentence (<em>possibly empty</em>) inside one of these sentences such that the two sentences become equal. <strong>Note</strong> that the inserted sentence must be separated from existing words by spaces.</p>

<p>For example,</p>

<ul>
	<li><code>s1 = &quot;Hello Jane&quot;</code> and <code>s2 = &quot;Hello my name is Jane&quot;</code> can be made equal by inserting <code>&quot;my name is&quot;</code> between <code>&quot;Hello&quot;</code><font face="monospace"> </font>and <code>&quot;Jane&quot;</code><font face="monospace"> in s1.</font></li>
	<li><font face="monospace"><code>s1 = &quot;Frog cool&quot;</code> </font>and<font face="monospace"> <code>s2 = &quot;Frogs are cool&quot;</code> </font>are <strong>not</strong> similar, since although there is a sentence <code>&quot;s are&quot;</code> inserted into <code>s1</code>, it is not separated from <code>&quot;Frog&quot;</code> by a space.</li>
</ul>

<p>Given two sentences <code>sentence1</code> and <code>sentence2</code>, return <strong>true</strong> if <code>sentence1</code> and <code>sentence2</code> are <strong>similar</strong>. Otherwise, return <strong>false</strong>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><code>sentence2</code> can be turned to <code>sentence1</code> by inserting &quot;name is&quot; between &quot;My&quot; and &quot;Haley&quot;.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">false</span></p>

<p><strong>Explanation:</strong></p>

<p>No single sentence can be inserted inside one of the sentences to make it equal to the other.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">true</span></p>

<p><strong>Explanation:</strong></p>

<p><code>sentence2</code> can be turned to <code>sentence1</code> by inserting &quot;right now&quot; at the end of the sentence.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>
	<li><code>sentence1</code> and <code>sentence2</code> consist of lowercase and uppercase English letters and spaces.</li>
	<li>The words in <code>sentence1</code> and <code>sentence2</code> are separated by a single space.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-deque">Approach 1: Deque</h3>
<h4 id="intuition">Intuition</h4>
<p>Given two string sentences <code>sentence1</code> and <code>sentence2</code>, we need to find if both the sentences are similar. Two sentences are similar if it is possible to insert an arbitrary sentence in one of the sentences to make them equal. All the words in the given sentences are separated by spaces.</p>
<p>Let's assume that <code>sentence2</code> is the bigger sentence and contains more words than <code>sentence1</code>. Now, to check if both sentences can be made identical, we need to check for two conditions:</p>
<ul>
<li>Matching the beginning (prefix): We compare words from the start of both sentences.</li>
<li>Matching the end (suffix): We compare words from the end of both sentences.<br />
If all the words of the smaller sentence match either the prefix or the suffix of the bigger sentence, then both sentences can be made equal by inserting an arbitrary sentence.</li>
</ul>
<p>This can be explained with an example:</p>
<ul>
<li>Let's say <code>sentence1 = &quot;hello jane&quot;</code> and <code>sentence2 = &quot;hello my name is jane&quot;</code>.</li>
<li>Comparing the prefixes of <code>sentence1</code> and <code>sentence2</code>, <code>hello</code> is the longest matching prefix.</li>
<li>Similarly, <code>jane</code> is the longest common suffix.</li>
<li>Observe that no word is left in the <code>sentence1</code>. Therefore, it can be converted to <code>sentence2</code> by adding the string <code>my name is</code>.</li>
</ul>
<p>Deque allows for efficient insertion and popping operations from the front and the back in constant time. This is ideal because to check if a sentence can be matched as a prefix or suffix, we need to compare from both ends. So, we can use two deques and populate them with words from <code>sentence1</code> and <code>sentence2</code>.</p>
<p>We can pop the deques until the prefix words are equal for both. Similarly, we can pop them until the suffixes of both deques are equal. If one deque is emptied completely after this process, one sentence can be transformed into the other by removing the unmatched middle portion.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Split both sentences <code>s1</code> and <code>s2</code> into arrays of words and store them in two deques <code>deque1</code> and <code>deque2</code>.</li>
<li>Compare the prefixes (beginning of the strings):
<ul>
<li>While both deques are not empty and the front elements are equal, remove the front elements from both deques.</li>
</ul>
</li>
<li>Compare the suffixes (ending of the strings):
<ul>
<li>While both deques are not empty and the last elements are equal, remove the last elements from both deques.</li>
</ul>
</li>
<li>After comparing both the prefixes and suffixes, return <code>true</code> if either <code>deque1</code> or <code>deque2</code> is empty.</li>
</ol>
<p>!?!../Documents/1813/Slideshow1.json:960,540!?!</p>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/ev8EE8PT/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the size of the given <code>sentence1</code> string and <span class="math inline">\(n\)</span> be the size of <code>sentence2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m+n)\)</span></p>
<p>We iterate through the words of the <code>sentence1</code> and <code>sentence2</code> exactly once. The total sum of the length of the words is given by <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> for both sentences. Therefore, the total time complexity is given by <span class="math inline">\(O(m+n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m+n)\)</span></p>
<p>We store the words of both sentences in the deque. The total sum of the length of the words is given by <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> for both sentences. Therefore, the total space complexity is given by <span class="math inline">\(O(m+n)\)</span>.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the deque-based approach, we compare and remove elements from both the front and back of two deques. Instead of popping from the front and back of a deque, we can simulate this process using two pointers, where the <code>start</code> pointer starts at the beginning (front) and the <code>end</code> pointer (j) starts at the end (back) of both sentences.</p>
<p>The goal is still the same: check if the sentences are similar by matching words from the beginning (prefix) and the end (suffix). If all words at the start and end match, the remaining words in the middle can be ignored, making the sentences similar.</p>
<p>Initialize <code>start</code> and <code>end</code> at the beginning and end of each sentence, respectively. Move the pointers inward while the words at both ends match. Once the words stop matching, the middle words are ignored. If the pointers cross, meaning all necessary prefix and suffix words match, the sentences are considered similar.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Split both sentences <code>s1</code> and <code>s2</code> into arrays of words: <code>s1Words</code> and <code>s2Words</code>.</li>
<li>Initialize four variables:
<ul>
<li><code>start</code> to 0, which will track matching words from the beginning.</li>
<li><code>ends1</code> to the last index of <code>s1Words</code> and <code>ends2</code> to the last index of <code>s2Words</code>, which will track matching words from the end.</li>
<li><code>s1WordsLength</code> and <code>s2WordsLength</code> to store the lengths of <code>s1Words</code> and <code>s2Words</code>.</li>
</ul>
</li>
<li>If <code>s1WordsLength</code> is greater than <code>s2WordsLength</code>, swap the sentences by calling the function recursively with <code>s2</code> and <code>s1</code>.</li>
<li>Find the maximum number of matching words from the beginning of both arrays by incrementing <code>start</code> while the words at the current index are the same.</li>
<li>Find the maximum number of matching words from the end by decrementing <code>ends1</code> and <code>ends2</code> while the words at the current indices are the same.</li>
<li>If <code>ends1</code> is less than <code>start</code>, meaning all remaining words can be removed to make the sentences similar, return <code>true</code>. Otherwise, return <code>false</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/RvwrK7CS/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the size of the given <code>sentence1</code> string and <span class="math inline">\(n\)</span> be the size of <code>sentence2</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(m+n)\)</span></p>
<p>We iterate through the words of the <code>sentence1</code> and <code>sentence2</code> exactly once. The total sum of the length of the words is given by <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> for both sentences. Therefore, the total time complexity is given by <span class="math inline">\(O(m+n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m+n)\)</span></p>
<p>We store the words of both sentences in an array. The total sum of the length of the words is given by <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> for both sentences. Therefore, the total space complexity is given by <span class="math inline">\(O(m+n)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-181">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/separate-black-and-white-balls/description" target="_blank" rel="noopener noreferrer">Separate Black and White Balls</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>There are <code>n</code> balls on a table, each ball has a color black or white.</p>

<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> of length <code>n</code>, where <code>1</code> and <code>0</code> represent black and white balls, respectively.</p>

<p>In each step, you can choose two adjacent balls and swap them.</p>

<p>Return <em>the <strong>minimum</strong> number of steps to group all the black balls to the right and all the white balls to the left</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;101&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> We can group all the black balls to the right in the following way:
- Swap s[0] and s[1], s = &quot;011&quot;.
Initially, 1s are not grouped together, requiring at least 1 step to group them to the right.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;100&quot;
<strong>Output:</strong> 2
<strong>Explanation:</strong> We can group all the black balls to the right in the following way:
- Swap s[0] and s[1], s = &quot;010&quot;.
- Swap s[1] and s[2], s = &quot;001&quot;.
It can be proven that the minimum number of steps needed is 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;0111&quot;
<strong>Output:</strong> 0
<strong>Explanation:</strong> All the black balls are already grouped to the right.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>We are given a binary string <code>s</code>, where each <code>0</code> represents a white ball and each <code>1</code> represents a black ball. Our goal is to move all the white balls to the left and all the black balls to the right.</p>
<p>In each operation, we can swap two adjacent characters. The task is to find the minimum number of swaps required to achieve the desired arrangement, where all <code>0</code>s come before all <code>1</code>s.</p>
<h3 id="approach-1-two-pointer">Approach 1: Two Pointer</h3>
<h4 id="intuition">Intuition</h4>
<p>Our job is to move all the white balls to the front of the string. Each move forward requires one swap. The number of swaps needed for a white ball equals the gap between its current and final positions. Once the white balls are in place, the black balls will naturally move to the back.</p>
<p>To find out where each white ball should go, we use a pointer, <code>whitePosition</code>. When we find a white ball, we calculate how many swaps it needs to reach the position marked by <code>whitePosition</code>. After calculating, we update <code>whitePosition</code> to the next available spot.</p>
<p>We track the total number of swaps with a counter, <code>totalSwaps</code>. For each white ball, we add its swaps to the counter. This approach counts all the necessary moves without physically making them.</p>
<p>By the end, <code>totalSwaps</code> will hold the minimum number of swaps required to move the white balls to the front.</p>
<p>The algorithm is visualized in the slideshow below:</p>
<p>!?!../Documents/2938/slideshow.json:1264,620!?!</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>whitePosition</code> to 0. This represents the next available position for a white ball.</li>
<li><code>totalSwaps</code> to 0 to keep track of the total number of swaps required.</li>
</ul>
</li>
<li>Iterate over each character in the string <code>s</code>:
<ul>
<li>If the character is <code>0</code> (a white ball):
<ul>
<li>Calculate the number of swaps needed by subtracting <code>whitePosition</code> from the current position. Add it to <code>totalSwaps</code>.</li>
<li>Increment <code>whitePosition</code> by 1 to mark the next available position for a white ball.</li>
</ul>
</li>
</ul>
</li>
<li>After the loop ends, return the value of <code>totalSwaps</code>.</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/FFEmTNQc/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm makes a single pass through the string <code>s</code>. Each operation inside the loop (addition and subtraction) takes constant time. Thus, the time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm does not use any data structures which scale with input space. Thus, the space complexity is constant.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-counter">Approach 2: Counter</h3>
<h4 id="intuition-1">Intuition</h4>
<p>When we find a white ball in the array, we need to move it to the front by swapping it past the black balls. Here's what that looks like:</p>
<p><img src="../Figures/2938/app2.png" alt="" /></p>
<p>To push a white ball to the front, we need to swap it with each black ball in front of it. Each swap moves the white ball forward by one position. The number of swaps for each white ball is equal to the number of black balls before it.</p>
<p>As we go through the array, we use a variable <code>blackBallCount</code> to track how many black balls we've passed. Each time we find a white ball, we add the current value of <code>blackBallCount</code> to the total swap count <code>totalSwaps</code>. When we're done, <code>totalSwaps</code> holds the answer.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ul>
<li>Initialize variables:
<ul>
<li><code>totalSwaps</code> to 0 to keep track of the total number of swaps required.</li>
<li><code>blackBallCount</code> to 0 to count the number of black balls encountered.</li>
</ul>
</li>
<li>Loop over each character in the string <code>s</code>:
<ul>
<li>If the character is <code>0</code>:
<ul>
<li>Add the current <code>blackBallCount</code> to <code>totalSwaps</code>.</li>
</ul>
</li>
<li>If it is not <code>0</code> (meaning it's a black ball):
<ul>
<li>Increment <code>blackBallCount</code> by 1.</li>
</ul>
</li>
</ul>
</li>
<li>Return the value of <code>totalSwaps</code>.</li>
</ul>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/D6tTDtnk/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of the input string <code>s</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span></p>
<p>The algorithm also traverses the input string <code>s</code> only once, taking linear time. The operations inside the loop take constant time. Thus, the overall time complexity of the algorithm is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span></p>
<p>The algorithm only uses two variables, <code>totalSwaps</code> and <code>blackBallCount</code>. Thus, the space complexity is constant, <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-182">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-distance-to-a-character/description" target="_blank" rel="noopener noreferrer">Shortest Distance to a Character</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code> and a character <code>c</code> that occurs in <code>s</code>, return <em>an array of integers </em><code>answer</code><em> where </em><code>answer.length == s.length</code><em> and </em><code>answer[i]</code><em> is the <strong>distance</strong> from index </em><code>i</code><em> to the <strong>closest</strong> occurrence of character </em><code>c</code><em> in </em><code>s</code>.</p>

<p>The <strong>distance</strong> between two indices <code>i</code> and <code>j</code> is <code>abs(i - j)</code>, where <code>abs</code> is the absolute value function.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;loveleetcode&quot;, c = &quot;e&quot;
<strong>Output:</strong> [3,2,1,0,1,0,0,1,2,2,1,0]
<strong>Explanation:</strong> The character &#39;e&#39; appears at indices 3, 5, 6, and 11 (0-indexed).
The closest occurrence of &#39;e&#39; for index 0 is at index 3, so the distance is abs(0 - 3) = 3.
The closest occurrence of &#39;e&#39; for index 1 is at index 3, so the distance is abs(1 - 3) = 2.
For index 4, there is a tie between the &#39;e&#39; at index 3 and the &#39;e&#39; at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.
The closest occurrence of &#39;e&#39; for index 8 is at index 6, so the distance is abs(8 - 6) = 2.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aaab&quot;, c = &quot;b&quot;
<strong>Output:</strong> [3,2,1,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s[i]</code> and <code>c</code> are lowercase English letters.</li>
	<li>It is guaranteed that <code>c</code> occurs at least once in <code>s</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-183">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-matching-substring/description" target="_blank" rel="noopener noreferrer">Shortest Matching Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">string matching</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a string <code>s</code> and a pattern string <code>p</code>, where <code>p</code> contains <strong>exactly two</strong> <code>&#39;*&#39;</code> characters.</p>

<p>The <code>&#39;*&#39;</code> in <code>p</code> matches any sequence of zero or more characters.</p>

<p>Return the length of the <strong>shortest</strong> <span data-keyword="substring">substring</span> in <code>s</code> that matches <code>p</code>. If there is no such substring, return -1.</p>
<strong>Note:</strong> The empty substring is considered valid.
<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;abaacbaecebce&quot;, p = &quot;ba*c*ce&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">8</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<u><strong>ba</strong></u>e<u><strong>c</strong></u>eb<u><strong>ce</strong></u>&quot;</code>.</p>
</div>

<p><strong class="example">Example 2:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;baccbaadbc&quot;, p = &quot;cc*baa*adb&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">-1</span></p>

<p><strong>Explanation:</strong></p>

<p>There is no matching substring in <code>s</code>.</p>
</div>

<p><strong class="example">Example 3:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;a&quot;, p = &quot;**&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">0</span></p>

<p><strong>Explanation:</strong></p>

<p>The empty substring is the shortest matching substring.</p>
</div>

<p><strong class="example">Example 4:</strong></p>

<div class="example-block">
<p><strong>Input:</strong> <span class="example-io">s = &quot;madlogic&quot;, p = &quot;*adlogi*&quot;</span></p>

<p><strong>Output:</strong> <span class="example-io">6</span></p>

<p><strong>Explanation:</strong></p>

<p>The shortest matching substring of <code>p</code> in <code>s</code> is <code>&quot;<strong><u>adlogi</u></strong>&quot;</code>.</p>
</div>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= p.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> contains only lowercase English letters.</li>
	<li><code>p</code> contains only lowercase English letters and exactly two <code>&#39;*&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-184">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/shortest-range-in-bst--141631/1" target="_blank" rel="noopener noreferrer">Shortest Range In BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">binary search tree</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size:18px">Given a BST (Binary Search Tree), find the shortest range <strong>[x, y]</strong>, such that,&nbsp;at least one node of every level of the&nbsp;BST lies in the&nbsp;range.<br />
If there are multiple ranges with the same gap (i.e. <strong>(y-x)</strong>) return the range with<strong> </strong>the<strong> smallest x</strong>.</span></p>

<p><span style="font-size:18px"><strong>Example 1:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
    </span>&nbsp;        <span style="font-size:18px"> 8
&nbsp; &nbsp; &nbsp; &nbsp;   /&nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3&nbsp; &nbsp;  10
&nbsp; &nbsp;    /&nbsp; \&nbsp; &nbsp; &nbsp; \
&nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; 6&nbsp; &nbsp; &nbsp; 14
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp;\&nbsp; &nbsp; &nbsp;/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4&nbsp;  7&nbsp; &nbsp;12
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; \
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;11&nbsp;  13
<strong>Output:</strong> 6 11
<strong>Explanation:</strong> Level order traversal of the tree 
is [8], [3, 10], [2, 6, 14], [4, 7, 12], [11, 13]. 
The shortest range which satisfies the above 
mentioned condition is [6, 11]. </span></pre>

<p><br />
<span style="font-size:18px"><strong>Example 2:</strong></span></p>

<pre>
<span style="font-size:18px"><strong>Input:</strong>
   12
&nbsp; &nbsp; \
&nbsp; &nbsp; &nbsp;13
&nbsp; &nbsp; &nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; 14
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 15
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  \
&nbsp; &nbsp; &nbsp; &nbsp;    16

<strong>Output:</strong> 12 16
<strong>Explanation:</strong> Each level contains one node, 
so the shortest range is [12, 16].</span></pre>

<p><br />
<span style="font-size:18px"><strong>Your Task:</strong><br />
You don&#39;t need to read input or print anything. Complete the function <strong>shortestRange() </strong>which takes the root of the tree as an input parameter and returns the pair of numbers</span></p>

<p><span style="font-size:18px"><strong>Expected Time Complexity:</strong> O(N)<br />
<strong>Expected Auxiliary Space:</strong> O(N)</span></p>

<p><br />
<span style="font-size:18px"><strong>Constraints:</strong><br />
1 &le; N&nbsp;&le; 10<sup>5</sup><br />
1 &le; Node Value &le; 10<sup>5</sup></span></p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-185">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description" target="_blank" rel="noopener noreferrer">Shortest Subarray to be Removed to Make Array Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>arr</code>, remove a subarray (can be empty) from <code>arr</code> such that the remaining elements in <code>arr</code> are <strong>non-decreasing</strong>.</p>

<p>Return <em>the length of the shortest subarray to remove</em>.</p>

<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,10,4,2,3,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [5,4,3,2,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array is already non-decreasing. We do not need to remove any elements.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="overview">Overview</h3>
<p>Given an array <code>arr</code>, we want to return the size of the smallest possible subarray we can remove to make the remaining elements sorted in non-decreasing order. It's acceptable to return an empty subarray if the elements are already sorted correctly.</p>
<p><img src="../Figures/1574/shortest_subarray_to_be_removed.png" alt="Test cases split into 3 parts" /></p>
<p>We can think of <code>arr</code> as being composed of 3 parts. The first part is a block of numbers in sorted order (blue region in the image above), followed by a block of numbers that breaks the sorted order (yellow region), and then finally another block of numbers in sorted order (green region).</p>
<p>For the nontrivial cases depicted above, we know that the subarray to remove resides somewhere in the middle of the array. Here, there can be multiple possibilities for what the middle elements can be. For the first example in the image, one option is to remove the block <code>[2, 3, 10, 4]</code>, leaving the remaining sorted sequence <code>[1, 2, 3, 5]</code>. Another option is to remove the block <code>[10, 4, 2]</code>, leaving another valid sequence <code>[1, 2, 3, 3, 5]</code>. The question then boils down to how we can find the smallest middle block of numbers to remove.</p>
<hr />
<h3 id="approach-1-binary-search">Approach 1: Binary Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We need to find the shortest subarray that, if removed, would make the array sorted. To do this, we must understand the problem from a few perspectives and break it down logically.</p>
<h5 id="1-identifying-the-longest-non-decreasing-subarrays">1. Identifying the Longest Non-Decreasing Subarrays</h5>
<p>The first thing to consider is that the array might already be mostly sorted, but just have a small portion that disrupts the order. This means that if we could find the longest part of the array that is already non-decreasing from the left and from the right, we would be left with just a small part in the middle that needs to be removed to make the entire array sorted.</p>
<p>The concept is to iterate through the array, looking for the longest continuous subarray that follows the non-decreasing order. We start from the left and move right, stopping when we hit a decrease. This is the first natural choice because if we can identify the longest subarray from the left, we know the part from the right must complement it or be the part we need to focus on.</p>
<p>Similarly, we do the same thing from the right side. This parallelism helps us understand both ends of the array and figure out where the sorting breaks down. These steps build on each other, showing us the boundaries within which we need to find the subarray to remove.</p>
<h5 id="2-the-case-where-the-array-is-already-sorted">2. The Case Where the Array is Already Sorted</h5>
<p>Now that we know how to find the longest non-decreasing subarrays from both ends, we need to think about the case where the array is already sorted. In this case, there’s no need to remove anything. So, we check if the left and right pointers (or indices) overlap or meet. If they do, the entire array is already sorted, and our work is done. This is an important insight because it helps us immediately return 0 when there’s no need to remove any subarray, avoiding unnecessary work.</p>
<h5 id="3-the-core-problem-what-to-remove">3. The Core Problem: What to Remove?</h5>
<p>If the array is not sorted, we are left with the task of determining the shortest subarray that can be removed to make the array sorted. We could remove just the left part, just the right part, or try merging the two non-decreasing sections.</p>
<p>Now, this might seem a bit tricky at first, but if we look closely, we can use the fact that if a section on the left is non-decreasing and a section on the right is also non-decreasing, there may still be a possibility of merging these sections by removing the middle. The relationship between the two sections plays a critical role. Specifically, we want to find a point where elements in the right section are greater than or equal to elements in the left section after considering the removal of the middle portion.</p>
<h5 id="4-the-final-search">4. The Final Search</h5>
<p>This leads us to the next part on how do we efficiently find where the two sections can merge? A naive approach might involve checking all pairs of elements, but that could be inefficient. Instead, we use binary search to find the smallest index in the right part of the array where the element is greater than or equal to the last element of the left part. By doing this, we can quickly pinpoint where the array can be &quot;joined&quot; back together, minimizing the subarray to remove.</p>
<p>This binary search approach leverages the sorted nature of the two subarrays. Since we know both the left and right subarrays are sorted, binary search allows us to find this boundary in logarithmic time, which is much more efficient than checking each element.</p>
<p>Finally, the solution is to take the minimum length of the subarrays that can be removed, whether that’s the left part, the right part, or the middle part (which we find through binary search).</p>
<h4 id="algorithm">Algorithm</h4>
<ul>
<li>
<p>Initialize <code>n</code> as the size of <code>arr</code>, <code>left</code> as 0, and <code>right</code> as <code>n - 1</code>.</p>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the left:</p>
<ul>
<li>While <code>left + 1 &lt; n</code> and <code>arr[left] &lt;= arr[left + 1]</code>, increment <code>left</code> to expand the left subarray.</li>
</ul>
</li>
<li>
<p>Find the longest non-decreasing subarray starting from the right:</p>
<ul>
<li>While <code>right - 1 &gt;= 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code> to expand the right subarray.</li>
</ul>
</li>
<li>
<p>If the entire array is already sorted (i.e., <code>left &gt;= right</code>), return <code>0</code> as no subarray removal is needed.</p>
</li>
<li>
<p>Initialize <code>ans</code> to the smaller of removing the left or right part completely:</p>
<ul>
<li><code>ans = min(n - (left + 1), right)</code></li>
</ul>
</li>
<li>
<p>Try to merge the left and right parts:</p>
<ul>
<li>For each index <code>i</code> from 0 to <code>left</code>, use binary search (<code>helperBinarySearch</code>) to find the smallest index <code>j</code> where <code>arr[j] &gt;= arr[i]</code>.</li>
<li>Update <code>ans</code> as the minimum of <code>ans</code> and the difference <code>j - (i + 1)</code>.</li>
</ul>
</li>
<li>
<p>Return <code>ans</code>, the length of the shortest subarray that can be removed to make the array sorted.</p>
</li>
</ul>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/haaC2UUS/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N \log N)\)</span></p>
<p>The first two <code>while</code> loops each run in <span class="math inline">\(O(N)\)</span> time to find the longest non-decreasing subarrays from the left and right.</p>
<p>After that, the <code>for</code> loop iterates up to <code>N</code> times, where for each iteration, a binary search is performed. Since binary search runs in <span class="math inline">\(O(\log N)\)</span> time, the total time complexity for the loop is <span class="math inline">\(O(N \log N)\)</span>.</p>
<p>Therefore, the overall time complexity is dominated by the <span class="math inline">\(O(N \log N)\)</span> component.</p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>The space complexity is mainly determined by the space required to store the input array <code>arr</code>, which takes <span class="math inline">\(O(N)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-two-pointers">Approach 2: Two Pointers</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can optimize the solution further by replacing binary search (<span class="math inline">\(O(N \log N)\)</span>) with a more efficient two-pointer approach, reducing the complexity to <span class="math inline">\(O(N)\)</span>.</p>
<p>A key insight in the diagram below is that the unsorted yellow region must always be part of the removed subarray, as it breaks the sorted order. In other words, the remaining sorted array will always consist of a prefix of the blue subarray (from the first element up to some index), followed by a suffix of the green subarray (from the last element down to some index).</p>
<p><img src="../Figures/1574/two_pointers.png" alt="2 pointers" /></p>
<p>To consider all possibilities, use two pointers, <code>left</code> and <code>right</code>. The pointers represent the prefix blue array <code>arr[0:left]</code> and suffix green array <code>arr[right:]</code> consisting of the remaining sorted array we are considering. Initially, <code>left</code> is set to 0, meaning we’re considering keeping the first element of the blue array. <code>Right</code> is set to the index of the start of the green subarray, meaning we consider keeping the entirety of the green subarray.</p>
<p>Using this two-pointer method, for each position of <code>left</code>, we search for the smallest <code>right</code> where <code>arr[left] &lt;= arr[right]</code>. If this condition holds, then we have found a valid subarray candidate to remove—the subarray between <code>arr[left]</code> and <code>arr[right]</code>, which has a length of <code>right - left - 1</code>. If <code>arr[left] &gt; arr[right]</code>, we increment <code>right</code> to find the next possible match. Once a valid <code>right</code> is found, we advance <code>left</code> to the next element, repeating the process.</p>
<details>
  <summary>Why <code>arr[left] <= arr[right]</code> is Important (Click Here!)</summary>
  </br>
  <p><strong>Sorted Left Portion:</strong> The elements before left (i.e.,  <code>arr[0:left]</code>) are already sorted. Therefore,  <code>arr[left-1]</code> is the largest element in this prefix.</p>
  <p><strong>Sorted Right Portion:</strong> The elements from right onwards (i.e., <code>arr[right:]</code>) are sorted as well. Thus, <code>arr[right]</code> is the smallest element in the suffix.</p>
  <p>For the two sorted sections to form one valid sorted sequence when combined, we need the largest element in the left portion (<code>arr[left-1]</code>) to be less than or equal to the smallest element in the right portion (<code>arr[right]</code>), because:</p>
  <ul>
    <li>If <code>arr[left-1]</code> is greater than <code>arr[right]</code>, it means that after removing the unsorted middle section, the combined array would not be sorted.</li>
    <li>If <code>arr[left-1] <= arr[right]</code>, it guarantees that the largest element from the left side is smaller than or equal to the smallest element from the right side, ensuring the merged sequence is still sorted.</li>
  </ul>
</details>
</br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>Initialize our <code>right</code> pointer to the last index of <code>arr</code>.</li>
<li>We want to start our two-pointer process with <code>right</code> pointing to the start of the green sorted subarray. So we want to update <code>right</code> to the right index:
<ul>
<li>While <code>right &gt; 0</code> and <code>arr[right] &gt;= arr[right - 1]</code>, decrement <code>right</code></li>
</ul>
</li>
<li>We initialize our <code>ans = right</code>. We note that the biggest subarray that can be removed is the entire subarray preceding <code>right</code>. Thus, the maximum size subarray to be removed is <code>right</code>.</li>
<li>We initialize our <code>left</code> pointer to <code>0</code>, the start of the blue sorted subarray.</li>
<li>While <code>left &lt; right</code> and <code>left</code> is still in the blue region: <code>left == 0 || arr[left - 1] &lt;= arr[left]</code>:
<ul>
<li>Find the right number after arr[left]:
<ul>
<li>While <code>right &lt; arr.length</code> and <code>arr[left] &gt; arr[right]</code>, increment <code>right</code></li>
</ul>
</li>
<li>Save length of the removed subarray: <code>ans = min(ans, right - left - 1)</code></li>
<li>Increment <code>left</code></li>
</ul>
</li>
<li>Return <code>ans</code></li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/QgsqkvCG/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <code>N</code> be the size of <code>arr</code>.</p>
<ul>
<li>
<p>Time Complexity: <span class="math inline">\(O(N)\)</span></p>
<p>In the worst case for our two pointer algorithm, <code>left</code> will traverse through the entire blue sorted region once, and <code>right</code> will traverse through the entire <code>green</code> sorted region once. Thus, the time complexity grows linearly with the size of <code>arr</code>: <span class="math inline">\(O(N)\)</span></p>
</li>
<li>
<p>Space Complexity: <span class="math inline">\(O(1)\)</span></p>
<p>We only use two pointers to store indices and do not have any auxiliary data structures, so the space complexity is <span class="math inline">\(O(1)\)</span>.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-186">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/shortest-unsorted-continuous-subarray/description" target="_blank" rel="noopener noreferrer">Shortest Unsorted Continuous Subarray</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">greedy</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">sorting</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, you need to find one <b>continuous subarray</b> such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.</p>

<p>Return <em>the shortest such subarray and output its length</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,6,4,8,10,9,15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 0
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1]
<strong>Output:</strong> 0
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time complexity?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-187">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-array-by-parity/description" target="_blank" rel="noopener noreferrer">Sort Array By Parity</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, move all the even integers at the beginning of the array followed by all the odd integers.</p>

<p>Return <em><strong>any array</strong> that satisfies this condition</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,1,2,4]
<strong>Output:</strong> [2,4,3,1]
<strong>Explanation:</strong> The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-188">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-array-by-parity-ii/description" target="_blank" rel="noopener noreferrer">Sort Array By Parity II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>nums</code>, half of the integers in <code>nums</code> are <strong>odd</strong>, and the other half are <strong>even</strong>.</p>

<p>Sort the array so that whenever <code>nums[i]</code> is odd, <code>i</code> is <strong>odd</strong>, and whenever <code>nums[i]</code> is even, <code>i</code> is <strong>even</strong>.</p>

<p>Return <em>any answer array that satisfies this condition</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,5,7]
<strong>Output:</strong> [4,5,2,7]
<strong>Explanation:</strong> [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,3]
<strong>Output:</strong> [2,3]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>nums.length</code> is even.</li>
	<li>Half of the integers in <code>nums</code> are even.</li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow Up:</strong> Could you solve it in-place?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-189">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-colors/description" target="_blank" rel="noopener noreferrer">Sort Colors</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>

<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>

<p>You must solve this problem without using the library&#39;s sort function.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,0,2,1,1,0]
<strong>Output:</strong> [0,0,1,1,2,2]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,0,1]
<strong>Output:</strong> [0,1,2]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 &lt;= n &lt;= 300</code></li>
	<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-190">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sort-list/description" target="_blank" rel="noopener noreferrer">Sort List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">divide and conquer</span> <span class="topic-badge">linked list</span> <span class="topic-badge">merge sort</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" style="width: 450px; height: 194px;" />
<pre>
<strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" style="width: 550px; height: 184px;" />
<pre>
<strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>
<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-191">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sort-the-half-sorted2157/1" target="_blank" rel="noopener noreferrer">Sort the Half Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an integer array of which both the first halve and second halve are sorted. The task is to merge these two sorted halves of the array into a single sorted array.<br /><strong>Note</strong>: The two halves can be of arbitrary sizes (i.e. if first halve of size k then the second halve is of size N-k where 0&lt;=k&lt;=N).</span></p>
<p><span style="font-size: 18px;"><strong>Example 1:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:
</strong>N = 6
arr[] = {2 3 8 -1 7 10}
<strong>Output: </strong>-1 2 3 7 8 10 
<strong>Explanation: </strong>{2 3 8} and {-1 7 10} are sorted 
in the original array. The overall sorted 
version is {-1 2 3 7 8 10}</span></pre>
<p><span style="font-size: 18px;"><strong>Example 2:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong>
N = 5
arr[] = {-4 6 9 -1 3}
<strong>Output: </strong>-4 -1 3 6 9 
<strong>Explanation: </strong>{-4 -1} and {3 6 9} are sorted 
in the original array. The overall sorted 
version is {-4 -1 3 6 9}</span></pre>
<p><br /><strong>Your Task:</strong><br /><span style="font-size: 18px;">You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>sortHalves ()&nbsp;</strong>which takes the array arr[] and its size n as inputs and modifies the array such that it gets sorted completely.</span></p>
<p><br /><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n).<br /><strong>Expected Auxiliary Space:&nbsp;</strong>O(n).</span></p>
<p><br /><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &lt;= N &lt;= 10<sup>6</sup></span></p>
<p>&nbsp;</p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-192">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/split-two-strings-to-make-palindrome/description" target="_blank" rel="noopener noreferrer">Split Two Strings to Make Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>a</code> and <code>b</code> of the same length. Choose an index and split both strings <strong>at the same index</strong>, splitting <code>a</code> into two strings: <code>a<sub>prefix</sub></code> and <code>a<sub>suffix</sub></code> where <code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code>, and splitting <code>b</code> into two strings: <code>b<sub>prefix</sub></code> and <code>b<sub>suffix</sub></code> where <code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>. Check if <code>a<sub>prefix</sub> + b<sub>suffix</sub></code> or <code>b<sub>prefix</sub> + a<sub>suffix</sub></code> forms a palindrome.</p>

<p>When you split a string <code>s</code> into <code>s<sub>prefix</sub></code> and <code>s<sub>suffix</sub></code>, either <code>s<sub>suffix</sub></code> or <code>s<sub>prefix</sub></code> is allowed to be empty. For example, if <code>s = &quot;abc&quot;</code>, then <code>&quot;&quot; + &quot;abc&quot;</code>, <code>&quot;a&quot; + &quot;bc&quot;</code>, <code>&quot;ab&quot; + &quot;c&quot;</code> , and <code>&quot;abc&quot; + &quot;&quot;</code> are valid splits.</p>

<p>Return <code>true</code><em> if it is possible to form</em><em> a palindrome string, otherwise return </em><code>false</code>.</p>

<p><strong>Notice</strong> that&nbsp;<code>x + y</code> denotes the concatenation of strings <code>x</code> and <code>y</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;x&quot;, b = &quot;y&quot;
<strong>Output:</strong> true
<strong>Explaination:</strong> If either a or b are palindromes the answer is true since you can split in the following way:
a<sub>prefix</sub> = &quot;&quot;, a<sub>suffix</sub> = &quot;x&quot;
b<sub>prefix</sub> = &quot;&quot;, b<sub>suffix</sub> = &quot;y&quot;
Then, a<sub>prefix</sub> + b<sub>suffix</sub> = &quot;&quot; + &quot;y&quot; = &quot;y&quot;, which is a palindrome.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;xbdef&quot;, b = &quot;xecab&quot;
<strong>Output:</strong> false
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;
<strong>Output:</strong> true
<strong>Explaination:</strong> Split them at index 3:
a<sub>prefix</sub> = &quot;ula&quot;, a<sub>suffix</sub> = &quot;cfd&quot;
b<sub>prefix</sub> = &quot;jiz&quot;, b<sub>suffix</sub> = &quot;alu&quot;
Then, a<sub>prefix</sub> + b<sub>suffix</sub> = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot;, which is a palindrome.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>
	<li><code>a.length == b.length</code></li>
	<li><code>a</code> and <code>b</code> consist of lowercase English letters</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-193">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/squares-of-a-sorted-array/description" target="_blank" rel="noopener noreferrer">Squares of a Sorted Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [-4,-1,0,3,10]
<strong>Output:</strong> [0,1,9,16,100]
<strong>Explanation:</strong> After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [-7,-3,2,3,11]
<strong>Output:</strong> [4,9,9,49,121]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
	<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Squaring each element and sorting the new array is very trivial, could you find an <code>O(n)</code> solution using a different approach?</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-194">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/strictly-palindromic-number/description" target="_blank" rel="noopener noreferrer">Strictly Palindromic Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">brainteaser</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>An integer <code>n</code> is <strong>strictly palindromic</strong> if, for <strong>every</strong> base <code>b</code> between <code>2</code> and <code>n - 2</code> (<strong>inclusive</strong>), the string representation of the integer <code>n</code> in base <code>b</code> is <strong>palindromic</strong>.</p>

<p>Given an integer <code>n</code>, return <code>true</code> <em>if </em><code>n</code><em> is <strong>strictly palindromic</strong> and </em><code>false</code><em> otherwise</em>.</p>

<p>A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 9
<strong>Output:</strong> false
<strong>Explanation:</strong> In base 2: 9 = 1001 (base 2), which is palindromic.
In base 3: 9 = 100 (base 3), which is not palindromic.
Therefore, 9 is not strictly palindromic so we return false.
Note that in bases 4, 5, 6, and 7, n = 9 is also not palindromic.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> false
<strong>Explanation:</strong> We only consider base 2: 4 = 100 (base 2), which is not palindromic.
Therefore, we return false.

</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>4 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-195">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/string-compression/description" target="_blank" rel="noopener noreferrer">String Compression</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of characters <code>chars</code>, compress it using the following algorithm:</p>

<p>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:</p>

<ul>
	<li>If the group&#39;s length is <code>1</code>, append the character to <code>s</code>.</li>
	<li>Otherwise, append the character followed by the group&#39;s length.</li>
</ul>

<p>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.</p>

<p>After you are done <strong>modifying the input array,</strong> return <em>the new length of the array</em>.</p>

<p>You must write an algorithm that uses only constant extra space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]
<strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]
<strong>Explanation:</strong> The groups are &quot;aa&quot;, &quot;bb&quot;, and &quot;ccc&quot;. This compresses to &quot;a2b2c3&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> chars = [&quot;a&quot;]
<strong>Output:</strong> Return 1, and the first character of the input array should be: [&quot;a&quot;]
<strong>Explanation:</strong> The only group is &quot;a&quot;, which remains uncompressed since it&#39;s a single character.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]
<strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].
<strong>Explanation:</strong> The groups are &quot;a&quot; and &quot;bbbbbbbbbbbb&quot;. This compresses to &quot;ab12&quot;.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= chars.length &lt;= 2000</code></li>
	<li><code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.</li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h4 id="intuition">Intuition</h4>
<p>First, we make the following observation. Consider a group <code>t</code> of consecutive repeating characters. The length of compressed <code>t</code> is less than or equal to the length of <code>t</code>. For example, <code>d</code> tranforms into <code>d</code>, <code>cc</code> into <code>c2</code>, <code>aaaa</code> into <code>a4</code>, <code>bbbbbbbbbbbb</code> into <code>b12</code>.</p>
<p>This observation allows processing groups in the array <code>chars</code> from left to right.</p>
<p>!?!../Documents/443/slideshow.json:960,540!?!</p>
<p>In the slideshow above, we compress the array <code>chars = [&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</code>. First, we process the group <code>cc</code>, then <code>b</code>, and finally <code>aaaaaaaaaa</code>.</p>
<p>Unprocessed characters are in white cells.</p>
<p>Processed characters that we may overwrite in the future are in blue cells.</p>
<p>Characters that belong to the answer and will not change are in green cells.</p>
<p>When processing a group, we first find its size <code>groupLength</code> and paint its cells blue. Then we append the character of the group to the answer. If <code>groupLength</code> is greater than <span class="math inline">\(1\)</span>, we also append the string representation of <code>groupLength</code> to the answer. Because the problem wants us to form the answer in place, instead of &quot;appending&quot; to the answer we will overwrite the corresponding blue cells by repainting them green.</p>
<p>White cells will eventually become blue and blue ones may become green. Since the compressed group takes up fewer cells than the uncompressed, the white cell cannot immediately become green.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>Declare the variables <code>i</code> – the first index of the current group, and <code>res</code> – the length of the answer (of the compressed string). Initialize <code>i = 0</code>, <code>res = 0</code>.</li>
<li>While <code>i</code> is less than the length of <code>chars</code>:
<ul>
<li>Find the length of the current group of consecutive repeating characters <code>groupLength</code>.</li>
<li>Add <code>chars[i]</code> to the answer (<code>chars[res++] = chars[i]</code>).</li>
<li>If <code>groupLength &gt; 1</code>, add the string representation of <code>groupLength</code> to the answer and increase <code>res</code> accordingly.</li>
<li>Increase <code>i</code> by <code>groupLength</code> and proceed to the next group.</li>
</ul>
</li>
<li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/6To4QHZq/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(n\)</span> be the length of <code>chars</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O(n)\)</span>.</p>
<p>All cells are initially white. We will repaint each white cell blue, and we may repaint some blue cells green. Thus each cell will be repainted at most twice. Since there are <span class="math inline">\(n\)</span> cells, the total number of repaintings is <span class="math inline">\(O(n)\)</span>.</p>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(1)\)</span>.</p>
<p>We store only a few integer variables and the string representation of <code>groupLength</code> which takes up <span class="math inline">\(O(1)\)</span> space.</p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-196">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/subsequence-with-the-minimum-score/description" target="_blank" rel="noopener noreferrer">Subsequence With the Minimum Score</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two strings <code>s</code> and <code>t</code>.</p>

<p>You are allowed to remove any number of characters from the string <code>t</code>.</p>

<p>The score of the string is <code>0</code> if no characters are removed from the string <code>t</code>, otherwise:</p>

<ul>
	<li>Let <code>left</code> be the minimum index among all removed characters.</li>
	<li>Let <code>right</code> be the maximum index among all removed characters.</li>
</ul>

<p>Then the score of the string is <code>right - left + 1</code>.</p>

<p>Return <em>the minimum possible score to make </em><code>t</code><em>&nbsp;a subsequence of </em><code>s</code><em>.</em></p>

<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abacaba&quot;, t = &quot;bzaa&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> In this example, we remove the character &quot;z&quot; at index 1 (0-indexed).
The string t becomes &quot;baa&quot; which is a subsequence of the string &quot;abacaba&quot; and the score is 1 - 1 + 1 = 1.
It can be proven that 1 is the minimum score that we can achieve.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;cde&quot;, t = &quot;xyz&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, we remove characters &quot;x&quot;, &quot;y&quot; and &quot;z&quot; at indices 0, 1, and 2 (0-indexed).
The string t becomes &quot;&quot; which is a subsequence of the string &quot;cde&quot; and the score is 2 - 0 + 1 = 3.
It can be proven that 3 is the minimum score that we can achieve.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of only lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-197">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/successful-pairs-of-spells-and-potions/description" target="_blank" rel="noopener noreferrer">Successful Pairs of Spells and Potions</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>

<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>

<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7
<strong>Output:</strong> [4,0,3]
<strong>Explanation:</strong>
- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.
- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.
Thus, [4,0,3] is returned.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16
<strong>Output:</strong> [2,0,2]
<strong>Explanation:</strong>
- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.
- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == spells.length</code></li>
	<li><code>m == potions.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-198">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/sum-of-mode/1" target="_blank" rel="noopener noreferrer">Sum of Mode</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">hash</span> <span class="topic-badge">set</span> <span class="topic-badge">sliding window</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of positive integers and an integer <strong>k</strong>. You have to find the sum of the <strong>modes</strong> of all the subarrays of size <strong>k</strong>.</span><br /><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;</span><span style="font-size: 18.6667px;">The mode of a subarray is the element that occurs with the highest frequency. If multiple elements have the same highest frequency, the smallest such element is considered the mode.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 2, 3, 2, 5, 2, 4, 4], k = 3<strong><br />Output:</strong> 13<strong><br />Explanation:</strong> The mode of each k size subarray is [1, 2, 2, 2, 2, 4] and sum of all modes is 13.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 2, 1, 3, 5], k = 2<strong><br />Output:</strong> 6<strong><br />Explanation:&nbsp;</strong>The mode of each k size subarray is [1, 1, 1, 3] and sum of all modes is 6.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; k &le; arr.size() &le;10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-199">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/sum-of-square-numbers/description" target="_blank" rel="noopener noreferrer">Sum of Square Numbers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search</span> <span class="topic-badge">math</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a non-negative integer <code>c</code>, decide whether there&#39;re two integers <code>a</code> and <code>b</code> such that <code>a<sup>2</sup> + b<sup>2</sup> = c</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> c = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> c = 3
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The simplest solution would be to consider every possible combination of integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> and check if the sum of their squares equals <span class="math inline">\(c\)</span>. Now, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> can lie within the range <span class="math inline">\((0,\sqrt{c})\)</span>. Thus, we need to check for the values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in this range only.</p>
<p><a href="https://leetcode.com/playground/bun3d8ez/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(c)\)</span>.</p>
<p>Two loops up to <span class="math inline">\(\sqrt{c}\)</span>. Here, <span class="math inline">\(c\)</span> refers to the given integer (sum of squares).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-2-better-brute-force">Approach 2: Better Brute Force</h3>
<p>We can improve the last solution, if we make the following observation. For any particular <span class="math inline">\(a\)</span> chosen, the value of <span class="math inline">\(b\)</span> required to satisfy the equation <span class="math inline">\(a^2 + b^2 = c\)</span> will be such that <span class="math inline">\(b^2 = c - a^2\)</span>. Thus, we need to traverse over the range <span class="math inline">\((0, \sqrt{c})\)</span> only for considering the various values of <span class="math inline">\(a\)</span>. For every current value of <span class="math inline">\(a\)</span> chosen, we can determine the corresponding <span class="math inline">\(b^2\)</span> value and check if it is a perfect square or not. If it happens to be a perfect square, <span class="math inline">\(c\)</span> is a sum of squares of two integers, otherwise not.</p>
<p>Now, to determine, if the number <span class="math inline">\(c - a^2\)</span> is a perfect square or not, we can make use of the following theorem:</p>
<blockquote>
<p>The square of <span class="math inline">\(n^{th}\)</span> positive integer can be represented as a sum of first <span class="math inline">\(n\)</span> odd positive integers.</p>
</blockquote>
<p>Or in mathematical terms:</p>
<p><span class="math display">\[n^2 = 1 + 3 + 5 + ... + (2 \cdot n-1) = \sum_{i=1}^{n} (2 \cdot i - 1)
\]</span></p>
<p>To look at the proof of this statement, look at the L.H.S. of the above statement.</p>
<p><span class="math display">\[\begin{aligned}
&1 + 3 + 5 + \ldots + (2 \cdot n-1) \\
= \; &(2 \cdot 1-1) + (2 \cdot 2-1) + (2 \cdot 3-1) + \ldots + (2 \cdot n-1) \\
= \; &2 \cdot (1+2+3+....+n) - (\underbrace{1+1+ \ldots +1}_{n\text{ times}}) \\
= \; &2 \cdot \frac{n\;(n+1)}{2} - n \\
= \; &n\;(n+1) - n \\
= \; &n^2 + n - n \\
= \; &n^2
\end{aligned}
\]</span></p>
<p>This completes the proof of the above statement.</p>
<p><a href="https://leetcode.com/playground/ZTefZRX8/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(c)\)</span>.</p>
<p>The total number of times the <span class="math inline">\(sum\)</span> is updated is: <span class="math inline">\(1 + 2 + 3 + \ldots + \sqrt{c} = \frac{\sqrt{c}\;(\sqrt{c}+1)}{2} = O(c)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-3-using-sqrt-function">Approach 3: Using Sqrt Function</h3>
<p><strong>Algorithm</strong></p>
<p>Instead of finding if <span class="math inline">\(c - a^2\)</span> is a perfect square using sum of odd numbers, as done in the last approach, we can make use of the inbuilt <span class="math inline">\(sqrt\)</span> function and check if <span class="math inline">\(\sqrt{c - a^2}\)</span> turns out to be an integer. If it happens for any value of <span class="math inline">\(a\)</span> in the range <span class="math inline">\([0, \sqrt{c}]\)</span>, we can return a True value immediately.</p>
<p><a href="https://leetcode.com/playground/N9KMxCjz/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(\sqrt{c}\log c\big)\)</span>.</p>
<p>We iterate over <span class="math inline">\(\sqrt{c}\)</span> values for choosing <span class="math inline">\(a\)</span>. For every <span class="math inline">\(a\)</span> chosen, finding square root of <span class="math inline">\(c - a^2\)</span> takes <span class="math inline">\(O\big(\log c\big)\)</span> time in the worst case.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant extra space is used.</p>
</li>
</ul>
<hr />
<h3 id="approach-4-binary-search">Approach 4: Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>Another method to check if <span class="math inline">\(c - a^2\)</span> is a perfect square, is by making use of Binary Search. The method remains same as that of a typical Binary Search to find a number.<br />
The only difference lies in that we need to find an integer, <span class="math inline">\(mid\)</span> in the range <span class="math inline">\([0, c - a^2]\)</span>, such that this number is the square root of <span class="math inline">\(c - a^2\)</span>.<br />
Or in other words, we need to find an integer, <span class="math inline">\(mid\)</span>, in the range <span class="math inline">\([0, c - a^2]\)</span>, such that <span class="math inline">\(mid \times mid = c - a^2\)</span>.</p>
<p>The following animation illustrates the search process for a particular value of <span class="math inline">\(c - a^2 = 36\)</span>.</p>
<p>!?!../Documents/633_Sum_of_Squares.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/6o4MgefR/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\big(\sqrt{c}\log c\big)\)</span>.<br />
Binary search taking <span class="math inline">\(O\big(\log c\big)\)</span> in the worst case is done for <span class="math inline">\(\sqrt{c}\)</span> values of <span class="math inline">\(a\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log c)\)</span>. Binary Search will take <span class="math inline">\(O(\log c)\)</span> space.</p>
</li>
</ul>
<hr />
<h3 id="approach-5-fermat-theorem">Approach 5: Fermat Theorem</h3>
<p><strong>Algorithm</strong></p>
<p>This approach is based on the following statement, which is based on Fermat's Theorem:</p>
<blockquote>
<p>Any positive number <span class="math inline">\(n\)</span> is expressible as a sum of two squares if and only if the prime factorization of <span class="math inline">\(n\)</span>, every prime of the form <span class="math inline">\((4k+3)\)</span> occurs an even number of times.</p>
</blockquote>
<p>By making use of the above theorem, we can directly find out if the given number <span class="math inline">\(c\)</span> can be expressed as a sum of two squares.</p>
<p>To do so we simply find all the prime factors of the given number <span class="math inline">\(c\)</span>, which could range from <span class="math inline">\([2,\sqrt{c}]\)</span> along with the count of those factors, by repeated division.<br />
If at any step, we find out that the number of occurrences of any prime factor of the form <span class="math inline">\((4k+3)\)</span> occurs an odd number of times, we can return a False value.</p>
<p>In case, <span class="math inline">\(c\)</span> itself is a prime number, it won't be divisible by any of the primes in the <span class="math inline">\([2,\sqrt{c}]\)</span>. Thus, we need to check if <span class="math inline">\(c\)</span> can be expressed in the form of<br />
<span class="math inline">\(4k+3\)</span>. If so, we need to return a False value, indicating that this prime occurs an odd number(1) of times.</p>
<p>Otherwise, we can return a True value.</p>
<p>The proof of this theorem includes the knowledge of advanced mathematics and is beyond the scope of this article. However, interested reader can refer to <a href="http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html">this</a> documentation.</p>
<p><a href="https://leetcode.com/playground/j4TXamHq/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O\left(\sqrt{c}\right)\)</span>.</p>
<p>We find the factors of <span class="math inline">\(c\)</span> and their count using repeated division. We check for the factors in the range <span class="math inline">\([0, \sqrt{c}]\)</span>.</p>
<p>However, the number of times a factor can occur is spread over the entire outer loop, so the entire complexity caused by the inner loop is effectively <span class="math inline">\(O(\log c)\)</span>. As a result, the total time complexity is <span class="math inline">\(O(\sqrt{c} + \log c) = O\left(\sqrt{c}\right)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>.</p>
<p>Constant space is used.</p>
</li>
</ul>
<hr />
</div>
				</div>
		</div>

<div class="question-card" id="question-200">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swap-adjacent-in-lr-string/description" target="_blank" rel="noopener noreferrer">Swap Adjacent in LR String</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>In a string composed of <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;X&#39;</code> characters, like <code>&quot;RXXLRXRXL&quot;</code>, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with <code>&quot;XR&quot;</code>. Given the starting string <code>start</code> and the ending string <code>result</code>, return <code>True</code> if and only if there exists a sequence of moves to transform <code>start</code> to <code>result</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> start = &quot;RXXLRXRXL&quot;, result = &quot;XRLXXRRLX&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> We can transform start to result following these steps:
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> start = &quot;X&quot;, result = &quot;L&quot;
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= start.length&nbsp;&lt;= 10<sup>4</sup></code></li>
	<li><code>start.length == result.length</code></li>
	<li>Both <code>start</code> and <code>result</code> will only consist of characters in <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and&nbsp;<code>&#39;X&#39;</code>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-201">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/swapping-nodes-in-a-linked-list/description" target="_blank" rel="noopener noreferrer">Swapping Nodes in a Linked List</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">linked list</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given the <code>head</code> of a linked list, and an integer <code>k</code>.</p>

<p>Return <em>the head of the linked list after <strong>swapping</strong> the values of the </em><code>k<sup>th</sup></code> <em>node from the beginning and the </em><code>k<sup>th</sup></code> <em>node from the end (the list is <strong>1-indexed</strong>).</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/linked1.jpg" style="width: 400px; height: 112px;" />
<pre>
<strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [1,4,3,2,5]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> head = [7,9,6,6,7,8,3,0,9,5], k = 5
<strong>Output:</strong> [7,9,6,6,8,7,3,0,9,5]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the list is <code>n</code>.</li>
	<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-202">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/the-celebrity-problem/1" target="_blank" rel="noopener noreferrer">The Celebrity Problem</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">A celebrity is a person who is known to all but&nbsp;<strong>does not know</strong>&nbsp;anyone at a party. A party is being organized by some people. A square matrix&nbsp;<strong>mat[][]&nbsp;</strong>of size n*n is used to represent people at the party such that if an element of row<strong> i </strong>and column<strong> j </strong>is<strong> set to 1</strong> it means <strong>ith person knows jth person</strong>.&nbsp;You need to return the <strong>index </strong>of the<strong> celebrity</strong> in the party, if the celebrity does not exist, return&nbsp;<strong>-1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;Follow <strong>0-based </strong>indexing.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1, 0],<br />                [0, 1, 0],<br />                [0, 1, 1]]
<strong>Output:</strong> 1
<strong>Explanation: </strong>0th and 2nd person both know 1st person and 1st person does not know anyone. Therefore, 1 is the celebrity person.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1], <br />                [1, 1]]
<strong>Output:</strong> -1
<strong>Explanation: </strong>Since both the people at the party know each other. Hence none of them is a celebrity person.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1]]
<strong>Output:</strong> 0</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 1000<br />0 &le; mat[i][j] &le; 1<br />mat[i][i] = 1</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-203">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-k-strongest-values-in-an-array/description" target="_blank" rel="noopener noreferrer">The k Strongest Values in an Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an array of integers <code>arr</code> and an integer <code>k</code>.</p>

<p>A value <code>arr[i]</code> is said to be stronger than a value <code>arr[j]</code> if <code>|arr[i] - m| &gt; |arr[j] - m|</code> where <code>m</code> is the <strong>centre</strong> of the array.<br />
If <code>|arr[i] - m| == |arr[j] - m|</code>, then <code>arr[i]</code> is said to be stronger than <code>arr[j]</code> if <code>arr[i] &gt; arr[j]</code>.</p>

<p>Return <em>a list of the strongest <code>k</code></em> values in the array. return the answer <strong>in any arbitrary order</strong>.</p>

<p>The <strong>centre</strong> is the middle value in an ordered integer list. More formally, if the length of the list is n, the centre is the element in position <code>((n - 1) / 2)</code> in the sorted list <strong>(0-indexed)</strong>.</p>

<ul>
	<li>For <code>arr = [6, -3, 7, 2, 11]</code>, <code>n = 5</code> and the centre is obtained by sorting the array <code>arr = [-3, 2, 6, 7, 11]</code> and the centre is <code>arr[m]</code> where <code>m = ((5 - 1) / 2) = 2</code>. The centre is <code>6</code>.</li>
	<li>For <code>arr = [-7, 22, 17,&thinsp;3]</code>, <code>n = 4</code> and the centre is obtained by sorting the array <code>arr = [-7, 3, 17, 22]</code> and the centre is <code>arr[m]</code> where <code>m = ((4 - 1) / 2) = 1</code>. The centre is <code>3</code>.</li>
</ul>

<div class="simple-translate-system-theme" id="simple-translate">
<div>
<div class="simple-translate-button isShow" style="background-image: url(&quot;moz-extension://8a9ffb6b-7e69-4e93-aae1-436a1448eff6/icons/512.png&quot;); height: 22px; width: 22px; top: 266px; left: 381px;">&nbsp;</div>

<div class="simple-translate-panel " style="width: 300px; height: 200px; top: 0px; left: 0px; font-size: 13px;">
<div class="simple-translate-result-wrapper" style="overflow: hidden;">
<div class="simple-translate-move" draggable="true">&nbsp;</div>

<div class="simple-translate-result-contents">
<p class="simple-translate-result" dir="auto">&nbsp;</p>

<p class="simple-translate-candidate" dir="auto">&nbsp;</p>
</div>
</div>
</div>
</div>
</div>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,2,3,4,5], k = 2
<strong>Output:</strong> [5,1]
<strong>Explanation:</strong> Centre is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also <strong>accepted</strong> answer.
Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 &gt; 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> arr = [1,1,3,5,5], k = 2
<strong>Output:</strong> [5,5]
<strong>Explanation:</strong> Centre is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> arr = [6,7,11,7,6,8], k = 5
<strong>Output:</strong> [11,8,6,6,7]
<strong>Explanation:</strong> Centre is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].
Any permutation of [11,8,6,6,7] is <strong>accepted</strong>.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k &lt;= arr.length</code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-204">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/the-latest-time-to-catch-a-bus/description" target="_blank" rel="noopener noreferrer">The Latest Time to Catch a Bus</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>buses</code> of length <code>n</code>, where <code>buses[i]</code> represents the departure time of the <code>i<sup>th</sup></code> bus. You are also given a <strong>0-indexed</strong> integer array <code>passengers</code> of length <code>m</code>, where <code>passengers[j]</code> represents the arrival time of the <code>j<sup>th</sup></code> passenger. All bus departure times are unique. All passenger arrival times are unique.</p>

<p>You are given an integer <code>capacity</code>, which represents the <strong>maximum</strong> number of passengers that can get on each bus.</p>

<p>When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at <code>x</code> minutes if you arrive at <code>y</code> minutes where <code>y &lt;= x</code>, and the bus is not full. Passengers with the <strong>earliest</strong> arrival times get on the bus first.</p>

<p>More formally when a bus arrives, either:</p>

<ul>
	<li>If <code>capacity</code> or fewer passengers are waiting for a bus, they will <strong>all</strong> get on the bus, or</li>
	<li>The <code>capacity</code> passengers with the <strong>earliest</strong> arrival times will get on the bus.</li>
</ul>

<p>Return <em>the latest time you may arrive at the bus station to catch a bus</em>. You <strong>cannot</strong> arrive at the same time as another passenger.</p>

<p><strong>Note: </strong>The arrays <code>buses</code> and <code>passengers</code> are not necessarily sorted.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> buses = [10,20], passengers = [2,17,18,19], capacity = 2
<strong>Output:</strong> 16
<strong>Explanation:</strong> Suppose you arrive at time 16.
At time 10, the first bus departs with the 0<sup>th</sup> passenger. 
At time 20, the second bus departs with you and the 1<sup>st</sup> passenger.
Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1<sup>st</sup> passenger to catch the bus.</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> Suppose you arrive at time 20.
At time 10, the first bus departs with the 3<sup>rd</sup> passenger. 
At time 20, the second bus departs with the 5<sup>th</sup> and 1<sup>st</sup> passengers.
At time 30, the third bus departs with the 0<sup>th</sup> passenger and you.
Notice if you had arrived any later, then the 6<sup>th</sup> passenger would have taken your seat on the third bus.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == buses.length</code></li>
	<li><code>m == passengers.length</code></li>
	<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>
	<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>
	<li>Each element in <code>buses</code> is <strong>unique</strong>.</li>
	<li>Each element in <code>passengers</code> is <strong>unique</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-205">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/three-sum/1" target="_blank" rel="noopener noreferrer">Three Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">sliding window</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an integer array <strong>arr</strong>, return all the <strong>unique </strong>triplets [arr[i], arr[j], arr[k]] such that<strong> i != j, i != k, and j != k, </strong>and <strong>arr[i] + arr[j] + arr[k] == 0.</strong></span></p>
<p><span style="font-size: 14pt;">Note: The triplets must be returned in <strong>sorted </strong>order, the solution vector should also be <strong>sorted</strong>, and the answer must not contain any <strong>duplicate </strong>triplets.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr = [-1,0,1,2,-1,-4]
<strong>Output: </strong>[[-1,-1,2],[-1,0,1]]<strong>
Explanation: </strong>arr[0] + arr[1] + arr[2] = (-1) + 0 + 1 = 0.
arr[1] + arr[2] + arr[4] = 0 + 1 + (-1) = 0.
arr[0] + arr[3] + arr[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr = [0,0,0]
<strong>Output: </strong>[[0,0,0]]<strong>
Explanation: </strong>The only possible triplet sums up to 0.</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n<sup>2</sup>)<br /><strong>Expected Auxiliary Space:</strong> O(n<sup>2</sup>)</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong></span><span style="font-size: 18px;">3 &lt;= arr.length &lt;= 3000<br /></span><span style="font-size: 18px;">-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-206">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/total-cost-to-hire-k-workers/description" target="_blank" rel="noopener noreferrer">Total Cost to Hire K Workers</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>You are given a <strong>0-indexed</strong> integer array <code>costs</code> where <code>costs[i]</code> is the cost of hiring the <code>i<sup>th</sup></code> worker.</p>

<p>You are also given two integers <code>k</code> and <code>candidates</code>. We want to hire exactly <code>k</code> workers according to the following rules:</p>

<ul>
	<li>You will run <code>k</code> sessions and hire exactly one worker in each session.</li>
	<li>In each hiring session, choose the worker with the lowest cost from either the first <code>candidates</code> workers or the last <code>candidates</code> workers. Break the tie by the smallest index.
	<ul>
		<li>For example, if <code>costs = [3,2,7,7,1,2]</code> and <code>candidates = 2</code>, then in the first hiring session, we will choose the <code>4<sup>th</sup></code> worker because they have the lowest cost <code>[<u>3,2</u>,7,7,<u><strong>1</strong>,2</u>]</code>.</li>
		<li>In the second hiring session, we will choose <code>1<sup>st</sup></code> worker because they have the same lowest cost as <code>4<sup>th</sup></code> worker but they have the smallest index <code>[<u>3,<strong>2</strong></u>,7,<u>7,2</u>]</code>. Please note that the indexing may be changed in the process.</li>
	</ul>
	</li>
	<li>If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.</li>
	<li>A worker can only be chosen once.</li>
</ul>

<p>Return <em>the total cost to hire exactly </em><code>k</code><em> workers.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
<strong>Output:</strong> 11
<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [<u>17,12,10,2</u>,7,<u>2,11,20,8</u>]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [<u>17,12,10,7</u>,<u>2,11,20,8</u>]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [<u>17,12,10,7,11,20,8</u>]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> costs = [1,2,4,1], k = 3, candidates = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [<u>1,2,4,1</u>]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [<u>2,4,1</u>]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [<u>2,4</u>]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= costs.length &lt;= 10<sup>5 </sup></code></li>
	<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-2-priority-queues">Approach 1: 2 Priority Queues</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
<p>If you are not familiar with the priority queue, please refer to our explore cards <a href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/">Heaps Explore Card</a>. We will focus on the usage in this article and not the implementation details.</p>
</blockquote>
<p><strong>For the sake of brevity, let <code>m</code> represent the input integer <code>candidates</code> for the rest of the article.</strong></p>
<p>To begin with, we need to understand the problem requirements. In each of the <code>k</code> hiring rounds, we must hire a worker with the lowest cost (with the smallest index being a tiebreaker) based on the provided rules.</p>
<p>We have the option to select the worker with the lowest cost from either the first <code>m</code> candidates or the last <code>m</code> candidates from <code>costs</code>. Once we choose a worker from either of these sections, we remove the chosen worker from the array, which makes space for another worker to be in either the first or last <code>m</code> candidates. We continue to select the worker with the lowest cost, each time making space for another worker from <code>costs</code> to be into consideration. Because we need to repeatedly find the minimum cost, using a priority queue is the most appropriate approach to simulate this process.</p>
<br>
<p>During each hiring session, our goal is to select the worker with the lowest cost. As mentioned above, after selecting a worker, a spot will open up for another worker to be among the first or last <code>m</code> candidates. As such, we need to distinguish between the first <code>m</code> candidates and the last <code>m</code> candidates. That way, when we choose a worker, we know if a spot was opened in the first <code>m</code> candidates or the last <code>m</code> candidates.</p>
<p><img src="../Figures/2462/1.png" alt="img" /></p>
<p>To store the workers in two sections separately, we can use two priority queues, <code>head_workers</code> and <code>tail_workers</code>, where the worker with the lowest cost has the highest priority.</p>
<p><img src="../Figures/2462/2.png" alt="img" /></p>
<p>Throughout the process, after we hire a worker from a section, we need to add an additional candidate to this section. Therefore, we need two pointers, <code>next_head</code> and <code>next_tail</code>, that denotes the next worker to be added to the respective queues.</p>
<p><img src="../Figures/2462/3.png" alt="img" /></p>
<p>Just like in this situation shown in the picture, if two workers with the same cost appear at the top of both queues, we will hire the one from <code>head_workers</code>, since this worker has a smaller index compared with the other one from <code>tail_workers</code>. Afterwards, we need to refill <code>head_workers</code> with the worker at <code>next_head</code> to ensure that it still contains the first <code>m</code> unselected candidates.</p>
<p><img src="../Figures/2462/4.png" alt="img" /></p>
<p>We add the worker <code>costs[next_head]</code> to <code>head_workers</code>, and then increment this pointer by 1, indicating the next unselected worker.</p>
<p><img src="../Figures/2462/5.png" alt="img" /></p>
<p>However, if we encounter the condition <code>next_tail &lt; next_head</code>, it indicates that all the workers have been selected as candidates and there are no more workers outside the two queues. To avoid double counting, we should not add a worker to both queues or update either pointer. Therefore, we can simply move on without making any updates to the queues or pointers.</p>
<p><img src="../Figures/2462/6.png" alt="img" /></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
<li>
<p>Initialize two priority queues <code>head_workers</code> and <code>tail_workers</code> that store the first <code>m</code> workers and the last <code>m</code> workers, where the worker with the lowest cost has the highest priority.</p>
</li>
<li>
<p>Set up two pointers <code>next_head = m</code>, <code>next_tail = n - m - 1</code> indicating the next worker to be added to two queues.</p>
</li>
<li>
<p>Compare the top workers in both queues, and hire the one with the lowest cost, if both workers have the same cost, hire the worker from <code>head_workers</code>. Add the cost of this worker to the total cost.</p>
</li>
<li>
<p>If <code>next_head &lt;= next_tail</code>, we need to fill the queue with one worker:</p>
<ul>
<li>If the hired worker is from <code>head_workers</code>, we add the worker <code>costs[next_head]</code> to it and increment <code>next_head</code> by 1.</li>
<li>If the hired worker is from <code>tail_workers</code>, we add the worker <code>costs[tail_head]</code> to it and decrement <code>tail_head</code> by 1.</li>
</ul>
<p>Otherwise, skip this step.</p>
</li>
<li>
<p>Repeat steps 3 and 4 <code>k</code> times.</p>
</li>
<li>
<p>Return the total cost of all the hired workers.</p>
</li>
</ol>
<h4 id="implementation">Implementation</h4>
<p><a href="https://leetcode.com/playground/nVvzczAb/shared">code</a></p>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math inline">\(m\)</span> be the given integer <code>candidates</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((k + m) \cdot\log m)\)</span></p>
<ul>
<li>We need to initialize two priority queues of size <span class="math inline">\(m\)</span>, which takes <span class="math inline">\(O(m \cdot\log m)\)</span> time.</li>
<li>During the hiring rounds, we keep removing the top element from priority queues and adding new elements for up to <span class="math inline">\(k\)</span> times. Operations on a priority queue take amortized <span class="math inline">\(O(\log m)\)</span> time. Thus this process takes <span class="math inline">\(O(k \cdot\log m)\)</span> time.</li>
<li>Note: in Python, <code>heapq.heapify()</code> creates the priority queue in linear time. Therefore, in Python, the time complexity is <span class="math inline">\(O(m + k \cdot \log m)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<ul>
<li>We need to store the first <span class="math inline">\(m\)</span> and the last <span class="math inline">\(m\)</span> workers in two priority queues.</li>
</ul>
</li>
</ul>
<br/>
<hr />
<h3 id="approach-2-1-priority-queue">Approach 2: 1 Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also implement the hiring process using a single priority queue. However, if we only store the costs of the candidates as before, we cannot sort them based on their index. To address this, we can add a new field to each worker to denote their section ID. For instance, we can assign <code>0</code> to the first <code>m</code> candidates and <code>1</code> to the last <code>m</code> candidates. This way, when two workers have the same cost, the priority queue can sort them based on their section IDs, and the worker with the smaller section ID will be hired. This approach fully meets the requirements given in the problem.</p>
<p>As illustrated in the following picture, we store each candidate in <code>pq</code>, in the format of <code>(cost, section ID)</code>. For example:</p>
<ul>
<li>
<p><code>costs[1] = 12</code> is from the head section and stored as <code>(12, 0)</code>.</p>
</li>
<li>
<p><code>costs[9] = 2</code> is from the tail section and stored as <code>(2, 1)</code>.</p>
</li>
</ul>
<p><img src="../Figures/2462/7.png" alt="img" /></p>
<p>We will proceed with the hiring process for <code>k</code> rounds by hiring the top worker from <code>pq</code> each time.</p>
<p>Similar to the previous solution:</p>
<blockquote>
<p>If we choose a worker from <code>head_workers</code>, we add the worker at <code>next_head</code> to <code>head_workers</code>.<br />
If we choose a worker from <code>tail_workers</code>, we add the worker at <code>next_tail</code> to <code>tail_workers</code>.</p>
</blockquote>
<p>Here, we check whether the hired worker is from the first <code>m</code> candidates or the last <code>m</code> candidates by checking his section ID.</p>
<blockquote>
<p>If the section ID is <code>0</code>, it means that the worker is from the first <code>m</code> candidates, we add the worker at <code>next_head</code> to <code>pq</code> with a section ID as <code>0</code>.<br />
If the section ID is <code>1</code>, it means that the worker is from the last <code>m</code> candidates, we add the worker at <code>next_tail</code> to <code>pq</code> with a section ID as <code>1</code>.</p>
</blockquote>
<p><img src="../Figures/2462/8.png" alt="img" /></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
<li>
<p>Create a priority queue <code>pq</code> and initialize it with the first <code>m</code> workers and last <code>m</code> workers from <code>costs</code>, along with their section IDs (0 for the first <code>m</code> workers, and 1 for the last <code>m</code> workers). The worker with the lowest cost has the highest priority.</p>
</li>
<li>
<p>Initialize two pointers <code>next_head = m</code> and <code>next_tail = n - m - 1</code>, indicating the next worker to be added to <code>pq</code>.</p>
</li>
<li>
<p>Pop the top worker with the lowest cost from <code>pq</code> and add the cost of this hired worker to the total cost.</p>
</li>
<li>
<p>If <code>next_head &gt;= next_tail</code>, we need to fill <code>pq</code> with the next worker:</p>
<ul>
<li>If the hired worker's section ID is <code>0</code>, we push the worker <code>costs[next_head]</code> to into <code>pq</code> and increment <code>next_head</code> by 1.</li>
<li>If the hired worker's section ID is <code>1</code>, we push the worker <code>costs[next_tail]</code> to into <code>pq</code> and decrement <code>next_tail</code> by 1.</li>
</ul>
<p>Otherwise, skip this step.</p>
</li>
<li>
<p>Repeat steps 3 and 4 <code>k</code> times.</p>
</li>
<li>
<p>Return the total cost of all the hired workers.</p>
</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<p><a href="https://leetcode.com/playground/ep4hDwjw/shared">code</a></p>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>For the sake of brevity, let <span class="math inline">\(m\)</span> be the given integer <code>candidates</code>.</p>
<ul>
<li>
<p>Time complexity: <span class="math inline">\(O((k + m) \cdot\log m)\)</span></p>
<ul>
<li>We need to initialize one priority queue <code>pq</code> of size up to <span class="math inline">\(2\cdot m\)</span>, which takes <span class="math inline">\(O(m \cdot\log m)\)</span> time.</li>
<li>During <code>k</code> hiring rounds, we keep popping top elements from <code>pq</code> and pushing new elements into <code>pq</code> for up to <span class="math inline">\(k\)</span> times. Operations on a priority queue take amortized <span class="math inline">\(O(\log m)\)</span> time. Thus this process takes <span class="math inline">\(O(k \cdot\log m)\)</span> time.</li>
<li>Note: in Python, <code>heapq.heapify()</code> creates the priority queue in linear time. Therefore, in Python, the time complexity is <span class="math inline">\(O(m + k \cdot \log m)\)</span>.</li>
</ul>
</li>
<li>
<p>Space complexity: <span class="math inline">\(O(m)\)</span></p>
<ul>
<li>We need to store at most <span class="math inline">\(2 \cdot m\)</span> elements (the first <span class="math inline">\(m\)</span> and the last <span class="math inline">\(m\)</span> elements) of <code>costs</code> in the priority queue <code>pq</code>.</li>
</ul>
</li>
</ul>
<br/></div>
				</div>
		</div>

<div class="question-card" id="question-207">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/trapping-rain-water/description" target="_blank" rel="noopener noreferrer">Trapping Rain Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">monotonic stack</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" style="width: 412px; height: 161px;" />
<pre>
<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> height = [4,2,0,3,2,5]
<strong>Output:</strong> 9
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == height.length</code></li>
	<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-208">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1" target="_blank" rel="noopener noreferrer">Trapping Rain Water</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge hard">Hard</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 18px;">Given an array <strong>arr[] </strong>with non-negative integers representing the height of blocks. If the width of each block is 1, compute how much water can be trapped between the blocks during the rainy season.&nbsp;</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 0, 1, 0, 4, 0 2]
<strong>Output: </strong>10<strong>
Explanation: </strong>Total water trapped = 0 + 3 + 2 + 3 + 0 + 2 + 0 = 10 units.<br /></span><img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701211/Web/Other/blobid0_1741784862.png" alt="" /></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [3, 0, 2, 0, 4]
<strong>Output: </strong>7<strong>
Explanation: </strong>Total water trapped = 0 + 3 + 1 + 3 + 0 = 7 units.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [1, 2, 3, 4]
<strong>Output: </strong>0<strong>
Explanation: </strong>We cannot trap water as there is no height bound on both sides.</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr[] = [2, 1, 5, 3, 1, 0, 4]
<strong>Output: </strong>9<strong>
Explanation: </strong>Total water trapped = 0 + 1 + 0 + 1 + 3 + 4 + 0 = 9 units.</span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 <u>&lt;</u> arr.size() <u>&lt;</u> 10<sup>5</sup><br />0 <u>&lt;</u> arr[i] <u>&lt;</u> 10<sup>3</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-209">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/triplet-sum-in-array-1587115621/1" target="_blank" rel="noopener noreferrer">Triplet Sum in Array</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">algorithms</span> <span class="topic-badge">array</span> <span class="topic-badge">datastructures</span> <span class="topic-badge">hash</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> and an integer <strong>target</strong>, determine if there exists a triplet in the array whose sum equals the given <strong>target</strong>.</span></p>
<p><span style="font-size: 14pt;">Return <strong>true</strong>&nbsp;if such a triplet exists, otherwise, return <strong>false</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:&nbsp;<br /></strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 4, 45, 6, 10, 8], target = 13<br /><strong>Output</strong>: true <br /><strong>Explanation</strong>: The triplet {1, 4, 8} sums up to 13.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [1, 2, 4, 3, 6, 7], target = 10<br /><strong>Output</strong>: true <br /><strong>Explanation</strong>: The triplets {1, 3, 6} and {1, 2, 7} both sum to 10. </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input</strong>: arr[] = [40, 20, 10, 3, 6, 7], target = 24<br /><strong>Output</strong>: false <br /><strong>Explanation</strong>: No triplet in the array sums to 24.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />3 &le; arr.size() &le; 5*10<sup>3</sup><br />0 &le; arr[i], target &le; 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-210">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-ii-input-array-is-sorted/description" target="_blank" rel="noopener noreferrer">Two Sum II - Input Array Is Sorted</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>

<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>

<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>

<p>Your solution must use only constant extra space.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6
<strong>Output:</strong> [1,3]
<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
	<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>
	<li><code>-1000 &lt;= target &lt;= 1000</code></li>
	<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-211">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/two-sum-iv-input-is-a-bst/description" target="_blank" rel="noopener noreferrer">Two Sum IV - Input is a BST</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">binary search tree</span> <span class="topic-badge">binary tree</span> <span class="topic-badge">breadth-first search</span> <span class="topic-badge">depth-first search</span> <span class="topic-badge">tree</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true</code> <em>if there exist two elements in the BST such that their sum is equal to</em> <code>k</code>, <em>or</em> <code>false</code> <em>otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" style="width: 400px; height: 229px;" />
<pre>
<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
	<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>
	<li><code>root</code> is guaranteed to be a <strong>valid</strong> binary search tree.</li>
	<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-212">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/count-pairs-with-given-sum5022/1" target="_blank" rel="noopener noreferrer">Two sum -Pairs with 0 Sum</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given an integer array&nbsp;<strong>arr</strong>, return all the&nbsp;<strong>unique&nbsp;</strong>pairs [arr[i], arr[j]] such that<strong>&nbsp;i != j </strong>and<strong> arr[i] + arr[j] == 0.</strong></span></p>
<p><span style="font-size: 14pt;">Note: The pairs must be returned in&nbsp;<strong>sorted&nbsp;</strong>order, the&nbsp;solution array<strong> </strong>should also be&nbsp;<strong>sorted</strong>, and the answer must not contain any&nbsp;<strong>duplicate&nbsp;</strong>pairs.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr = [-1, 0, 1, 2, -1, -4]
<strong>Output: </strong>[[-1, 1]]<strong>
Explanation: </strong>arr[0] + arr[2] = (-1)+ 1 = 0.
arr[2] + arr[4] = 1 + (-1) = 0.
The distinct pair are [-1,1].</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>arr = [6, 1, 8, 0, 4, -9, -1, -10, -6, -5]
<strong>Output: </strong>[[-6, 6],[-1, 1]]<strong>
Explanation: </strong>The distinct pairs are [-1, 1] and [-6, 6].</span></pre>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:</strong> O(n log n)<br /><strong>Expected Auxiliary Space:</strong> O(n).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:<br /></strong>3 &lt;= arr.size &lt;= 10<sup>5</sup><br />-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-213">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-palindrome/description" target="_blank" rel="noopener noreferrer">Valid Palindrome</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>

<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;race a car&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot; &quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li><code>s</code> consists only of printable ASCII characters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-214">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-palindrome-ii/description" target="_blank" rel="noopener noreferrer">Valid Palindrome II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge easy">Easy</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">greedy</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given a string <code>s</code>, return <code>true</code> <em>if the </em><code>s</code><em> can be palindrome after deleting <strong>at most one</strong> character from it</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;aba&quot;
<strong>Output:</strong> true
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abca&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> You could delete the character &#39;c&#39;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abc&quot;
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> consists of lowercase English letters.</li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-215">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.geeksforgeeks.org/problems/valid-substring0624/1" target="_blank" rel="noopener noreferrer">Valid Substring</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">GeeksForGeeks</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">datastructures</span> <span class="topic-badge">stack</span> <span class="topic-badge">string</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p><span style="font-size: 14pt;">Given a string <code>s</code> consisting only of opening and closing parentheses <code>(</code> and <code>)</code>, find the length of the longest valid (well-formed) parentheses substring.</span></p>
<p><span style="font-size: 14pt;"><strong>Note: </strong>The length of the smallest valid substring <code>()</code> is 2.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "(()("
<strong>Output:</strong> 2
<strong>Explanation: </strong>The longest valid substring is <code>()</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 2.</span> </span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "()(())("
<strong>Output:</strong> 6
<strong>Explanation: </strong>The longest valid substring is <code>()(())</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 6.</span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>s = "(()())"
<strong>Output:</strong> 6
<strong>Explanation: </strong>The longest valid substring is <code>(()())</code><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">. Its length is 6.</span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &lt;= s.size() &lt;= 10<sup>5</sup><br />s[i] = { '(' , ')' }</span></p></div>
			</div>
			
			
		</div>

<div class="question-card" id="question-216">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/valid-triangle-number/description" target="_blank" rel="noopener noreferrer">Valid Triangle Number</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						<span class="availability-badge solution">Solution</span>
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">greedy</span> <span class="topic-badge">sorting</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [2,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [4,2,3,4]
<strong>Output:</strong> 4
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
	<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</div>
			</div>
			
			<div class="solution-section">
					<h3>Solution</h3>
					<div class="content-section"><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr />
<h3 id="approach-1-brute-force">Approach 1: Brute Force</h3>
<p>The condition for the triplets <span class="math inline">\((a, b, c)\)</span> representing the lengths of the sides of a triangle, to form a valid triangle, is that the sum of any two sides should always be greater than the third side alone. i.e. <span class="math inline">\(a + b > c\)</span>, <span class="math inline">\(b + c > a\)</span>, <span class="math inline">\(a + c > b\)</span>.</p>
<p>The simplest method to check this is to consider every possible triplet in the given <span class="math inline">\(nums\)</span> array and checking if the triplet satisfies the three inequalities mentioned above. Thus, we can keep a track of the <span class="math inline">\(count\)</span> of the number of triplets satisfying these inequalities. When all the triplets have been considered, the <span class="math inline">\(count\)</span> gives the required result.</p>
<blockquote>
<p><strong>Caution:</strong> The brute force approach is included here because it is an intuitive way to approach this problem. However, when there are <span class="math inline">\(10^3\)</span> numbers, the if statement will be checked approximately <span class="math inline">\(10^9\)</span> times. Thus, this approach will result in TLE. In the following approaches we will discuss ways to optimize our solution.</p>
</blockquote>
<p><a href="https://leetcode.com/playground/K5p9fUjs/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^3)\)</span>. Three nested loops are there to check every triplet.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(1)\)</span>. Constant space is used.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-2-using-binary-search">Approach 2: Using Binary Search</h3>
<p><strong>Algorithm</strong></p>
<p>If we sort the given <span class="math inline">\(nums\)</span> array once, we can solve the given problem in a better way. This is because, if we consider a triplet <span class="math inline">\((a, b, c)\)</span> such that <span class="math inline">\(a &leq; b &leq; c\)</span>, we need not check all the three inequalities for checking the validity of the triangle formed by them. But, only one condition <span class="math inline">\(a + b > c\)</span> would suffice. This happens because <span class="math inline">\(c &geq; b\)</span> and <span class="math inline">\(c &geq; a\)</span>. Thus, adding any number to <span class="math inline">\(c\)</span> will always produce a sum which is greater than either <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> considered alone. Thus, the inequalities <span class="math inline">\(c + a > b\)</span> and <span class="math inline">\(c + b > a\)</span> are satisfied implicitly by virtue of the  property <span class="math inline">\(a < b < c\)</span>.</p>
<p>From this, we get the idea that we can sort the given <span class="math inline">\(nums\)</span> array. Then, for every pair <span class="math inline">\((nums[i], nums[j])\)</span> considered starting from the beginning of the array, such that <span class="math inline">\(j > i\)</span>(leading to <span class="math inline">\(nums[j] &geq; nums[i]\)</span>), we can find out the count of elements <span class="math inline">\(nums[k]$$(\)</span>k &gt; j<span class="math inline">\(), which satisfy the inequality \)</span>nums[k] &gt; nums[i] + nums[j]<span class="math inline">\(. We can do so for every pair \)</span>(i, j)$$ considered and get the required result.</p>
<p>We can also observe that, since we've sorted the <span class="math inline">\(nums\)</span> array, as we traverse towards the right for choosing the index <span class="math inline">\(k\)</span>(for number <span class="math inline">\(nums[k]\)</span>), the value of <span class="math inline">\(nums[k]\)</span> could increase or remain the same(doesn't decrease relative to the previous value). Thus, there will exist a right limit on the value of index <span class="math inline">\(k\)</span>, such that the elements satisfy <span class="math inline">\(nums[k] > nums[i] + nums[j]\)</span>. Any elements beyond this value of <span class="math inline">\(k\)</span> won't satisfy this inequality as well, which is obvious.</p>
<p>Thus, if we are able to find this right limit value of <span class="math inline">\(k\)</span>(indicating the element just greater than <span class="math inline">\(nums[i] + nums[j]\)</span>), we can conclude that all the elements in <span class="math inline">\(nums\)</span> array in the range <span class="math inline">\((j+1, k-1)\)</span>(both included) satisfy the required inequality. Thus, the <span class="math inline">\(count\)</span> of elements satisfying the inequality will be given by <span class="math inline">\((k-1) - (j+1) + 1 = k - j - 1\)</span>.</p>
<p>Since the <span class="math inline">\(nums\)</span> array has been sorted now, we can make use of Binary Search to find this right limit of <span class="math inline">\(k\)</span>. The following animation shows how Binary Search can be used to find the right limit for a simple example.</p>
<p>!?!../Documents/Valid_Triangle_Binary.json:1000,563!?!</p>
<p>Another point to be observed is that once we find a right limit index <span class="math inline">\(k_{(i,j)}\)</span> for a particular pair <span class="math inline">\((i, j)\)</span> chosen, when we choose a higher value of <span class="math inline">\(j\)</span> for the same value of <span class="math inline">\(i\)</span>, we need not start searching for the right limit <span class="math inline">\(k_{(i,j+1)}\)</span> from the index <span class="math inline">\(j+2\)</span>. Instead, we can start off from the index <span class="math inline">\(k_{(i,j)}\)</span> directly where we left off for the last <span class="math inline">\(j\)</span> chosen.</p>
<p>This holds correct because when we choose a higher value of <span class="math inline">\(j\)</span>(higher or equal <span class="math inline">\(nums[j]\)</span> than the previous one), all the <span class="math inline">\(nums[k]\)</span>, such that <span class="math inline">\(k < k_{(i,j)}\)</span> will obviously satisfy <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the new value of <span class="math inline">\(j\)</span> chosen.</p>
<p>By taking advantage of this observation, we can limit the range of Binary Search for <span class="math inline">\(k\)</span> to shorter values for increasing values of <span class="math inline">\(j\)</span> considered while choosing the pairs <span class="math inline">\((i, j)\)</span>.</p>
<p><a href="https://leetcode.com/playground/jSUCbmrc/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2 \log n)\)</span>. In worst case inner loop will take <span class="math inline">\(n\log n\)</span> (binary search applied <span class="math inline">\(n\)</span> times).</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log n)\)</span>. Sorting takes <span class="math inline">\(O(\log n)\)</span> space.<br />
<br><br />
<br></p>
</li>
</ul>
<hr />
<h3 id="approach-3-linear-scan">Approach 3: Linear Scan</h3>
<p><strong>Algorithm</strong></p>
<p>As discussed in the last approach, once we sort the given <span class="math inline">\(nums\)</span> array, we need to find the right limit of the index <span class="math inline">\(k\)</span> for a pair of indices <span class="math inline">\((i, j)\)</span> chosen to find the <span class="math inline">\(count\)</span> of elements satisfying <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the triplet <span class="math inline">\((nums[i], nums[j], nums[k])\)</span> to form a valid triangle.</p>
<p>We can find this right limit by simply traversing the index <span class="math inline">\(k\)</span>'s values starting from the index <span class="math inline">\(k=j+1\)</span> for a pair <span class="math inline">\((i, j)\)</span> chosen and stopping at the first value of <span class="math inline">\(k\)</span> not satisfying the above inequality. Again, the <span class="math inline">\(count\)</span> of elements <span class="math inline">\(nums[k]\)</span> satisfying <span class="math inline">\(nums[i] + nums[j] > nums[k]\)</span> for the pair of indices <span class="math inline">\((i, j)\)</span> chosen is given by <span class="math inline">\(k - j - 1\)</span> as discussed in the last approach.</p>
<p>Further, as discussed in the last approach, when we choose a higher value of index <span class="math inline">\(j\)</span> for a particular <span class="math inline">\(i\)</span> chosen, we need not start from the index <span class="math inline">\(j + 1\)</span>. Instead, we can start off directly from the value of <span class="math inline">\(k\)</span> where we left for the last index <span class="math inline">\(j\)</span>. This helps to save redundant computations.</p>
<p>The following animation depicts the process:</p>
<p>!?!../Documents/Valid_Triangle_Linear.json:1000,563!?!</p>
<p><a href="https://leetcode.com/playground/HT9jpv3e/shared">code</a></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <span class="math inline">\(O(n^2)\)</span>. Loop of <span class="math inline">\(k\)</span> and <span class="math inline">\(j\)</span> will be executed <span class="math inline">\(O(n^2)\)</span> times in total, because, we do not reinitialize the value of <span class="math inline">\(k\)</span> for a new value of <span class="math inline">\(j\)</span> chosen(for the same <span class="math inline">\(i\)</span>). Thus the complexity will be <span class="math inline">\(O(n \log n + n^2)=O(n^2)\)</span>.</p>
</li>
<li>
<p>Space complexity : <span class="math inline">\(O(\log n)\)</span>. Sorting takes <span class="math inline">\(O(\log n)\)</span> space.<br />
<br><br />
<br></p>
</li>
</ul>
</div>
				</div>
		</div>

<div class="question-card" id="question-217">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/watering-plants-ii/description" target="_blank" rel="noopener noreferrer">Watering Plants II</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">simulation</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>Alice and Bob want to water <code>n</code> plants in their garden. The plants are arranged in a row and are labeled from <code>0</code> to <code>n - 1</code> from left to right where the <code>i<sup>th</sup></code> plant is located at <code>x = i</code>.</p>

<p>Each plant needs a specific amount of water. Alice and Bob have a watering can each, <strong>initially full</strong>. They water the plants in the following way:</p>

<ul>
	<li>Alice waters the plants in order from <strong>left to right</strong>, starting from the <code>0<sup>th</sup></code> plant. Bob waters the plants in order from <strong>right to left</strong>, starting from the <code>(n - 1)<sup>th</sup></code> plant. They begin watering the plants <strong>simultaneously</strong>.</li>
	<li>It takes the same amount of time to water each plant regardless of how much water it needs.</li>
	<li>Alice/Bob <strong>must</strong> water the plant if they have enough in their can to <strong>fully</strong> water it. Otherwise, they <strong>first</strong> refill their can (instantaneously) then water the plant.</li>
	<li>In case both Alice and Bob reach the same plant, the one with <strong>more</strong> water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.</li>
</ul>

<p>Given a <strong>0-indexed</strong> integer array <code>plants</code> of <code>n</code> integers, where <code>plants[i]</code> is the amount of water the <code>i<sup>th</sup></code> plant needs, and two integers <code>capacityA</code> and <code>capacityB</code> representing the capacities of Alice&#39;s and Bob&#39;s watering cans respectively, return <em>the <strong>number of times</strong> they have to refill to water all the plants</em>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> plants = [2,2,3,3], capacityA = 5, capacityB = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong>
- Initially, Alice and Bob have 5 units of water each in their watering cans.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 3 units and 2 units of water respectively.
- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.
So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> plants = [2,2,3,3], capacityA = 3, capacityB = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong>
- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.
- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.
So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> plants = [5], capacityA = 10, capacityB = 8
<strong>Output:</strong> 0
<strong>Explanation:</strong>
- There is only one plant.
- Alice&#39;s watering can has 10 units of water, whereas Bob&#39;s can has 8 units. Since Alice has more water in her can, she waters this plant.
So, the total number of times they have to refill is 0.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>n == plants.length</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>
	<li><code>max(plants[i]) &lt;= capacityA, capacityB &lt;= 10<sup>9</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>

<div class="question-card" id="question-218">
			<div class="question-header">
				<div class="question-title-section">
					<h2 class="question-title">
						<a href="https://www.leetcode.com/problems/ways-to-split-array-into-three-subarrays/description" target="_blank" rel="noopener noreferrer">Ways to Split Array Into Three Subarrays</a>
					</h2>
					<div class="question-meta">
						<span class="platform-badge">LeetCode</span>
						<span class="difficulty-badge medium">Medium</span>
						
					</div>
				</div>
			</div>
			<div class="topics-section">
				<strong>Topics:</strong> <span class="topic-badge">array</span> <span class="topic-badge">binary search</span> <span class="topic-badge">prefix sum</span> <span class="topic-badge">two pointers</span>
			</div>
			<div class="question-content">
				<div class="content-section"><p>A split of an integer array is <strong>good</strong> if:</p>

<ul>
	<li>The array is split into three <strong>non-empty</strong> contiguous subarrays - named <code>left</code>, <code>mid</code>, <code>right</code> respectively from left to right.</li>
	<li>The sum of the elements in <code>left</code> is less than or equal to the sum of the elements in <code>mid</code>, and the sum of the elements in <code>mid</code> is less than or equal to the sum of the elements in <code>right</code>.</li>
</ul>

<p>Given <code>nums</code>, an array of <strong>non-negative</strong> integers, return <em>the number of <strong>good</strong> ways to split</em> <code>nums</code>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only good way to split nums is [1] [1] [1].</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,2,2,2,5,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no good way to split nums.</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
			</div>
			
			
		</div>
        </div>
    </div>
    
    <div class="footer">
        <p>Generated by pushkar</p>
        <p>Programming Questions Collection</p>
    </div>
    
    <script>
        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Add scroll-to-top functionality
        window.addEventListener('scroll', function() {
            if (window.scrollY > 300) {
                if (!document.querySelector('.scroll-top')) {
                    const scrollTop = document.createElement('button');
                    scrollTop.className = 'scroll-top';
                    scrollTop.innerHTML = '↑';
                    scrollTop.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #58a6ff; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 20px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s ease;';
                    scrollTop.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
                    document.body.appendChild(scrollTop);
                }
            } else {
                const scrollTop = document.querySelector('.scroll-top');
                if (scrollTop) scrollTop.remove();
            }
        });
    </script>
    
    <style>
        .footer {
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            color: #8b949e;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-top: 2px solid #30363d;
        }
        
        .footer p {
            margin: 8px 0;
            font-size: 1rem;
        }
        
        .footer p:first-child {
            color: #f0f6fc;
            font-weight: 600;
            font-size: 1.1rem;
        }
    </style>
</body>
</html>